
				this->LeaveCritSection();
				DPL(0, "Couldn't get binary location %i!", 1, i);
				return;
			} // end if (couldn't get that item)

			FileSprintfWriteLine(hFile, "\t\t\tVersion= %04u.%04u.%04u.%04u",
								4, HIWORD(pBinaryLoc->m_dwMS), LOWORD(pBinaryLoc->m_dwMS),
								HIWORD(pBinaryLoc->m_dwLS), LOWORD(pBinaryLoc->m_dwLS));

			FileSprintfWriteLine(hFile, "\t\t\tBuild= %s",
								1, ((pBinaryLoc->m_fDebug) ? "Debug" : "Retail"));

			if (pBinaryLoc->m_dwFileSizeHigh > 0)
			{
				FileSprintfWriteLine(hFile, "\t\t\tFilesizeHigh= %u",
									1, pBinaryLoc->m_dwFileSizeHigh);
			} // end if (there's a top 32 bits of file size
			FileSprintfWriteLine(hFile, "\t\t\tFilesize= %u",
								1, pBinaryLoc->m_dwFileSizeLow);

			StringGetStrFromFiletime(&(pBinaryLoc->m_createtime), FALSE, szBuffer);
			FileSprintfWriteLine(hFile, "\t\t\tCreated= %s", 1, szBuffer);

			StringGetStrFromFiletime(&(pBinaryLoc->m_writetime), FALSE, szBuffer);
			FileSprintfWriteLine(hFile, "\t\t\tLastWritten= %s", 1, szBuffer);
		} // end for (each location the binary has)

	} // end for (each data item in the list)

	this->LeaveCritSection();
} // CTNTrackedBinaries::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no tracked binaries supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::SearchFor()"
//==================================================================================
// CTNTrackedBinaries::SearchFor
//----------------------------------------------------------------------------------
//
// Description: Searches for all matching files with the name specified in the
//				directory given, and all subdirectories if specified.  The paths to
//				the matches are added to the passed in string list.
//
// Arguments:
//	char* szFilename				Filename to search for.
//	char* szSearchDirPath			Directory to start search in.
//	BOOL fSubdirs					Should subdirectories be searched?
//	PLSTRINGLIST pResultPaths		Pointer to string list to attach paths of found
//									matching filenames to.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTrackedBinaries::SearchFor(char* szFilename, char* szSearchDirPath,
									BOOL fSubdirs, PLSTRINGLIST pResultPaths)
{
	HRESULT				hr;
	char				szLwrSearchFilename[MAX_PATH];
	char				szLwrFoundFilename[MAX_PATH];
	DWORD				dwSearchPatternSize = 0;
	char*				pszSearchPattern = NULL;
	HANDLE				hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA		founddata;
	DWORD				dwSubItemPathSize = 0;
	char*				pszSubItemPath = NULL;


	strcpy(szLwrSearchFilename, szFilename);
	_strlwr(szLwrSearchFilename);

	//StringPrepend(blah, "\\\\?\\");

	dwSearchPatternSize = strlen(szSearchDirPath) + strlen("*.*") + 1;

	if (! StringEndsWith(szSearchDirPath, "\\", FALSE))
		dwSearchPatternSize += 1;

	pszSearchPattern = (char*) LocalAlloc(LPTR, dwSearchPatternSize);
	if (pszSearchPattern == NULL)
		return (E_OUTOFMEMORY);

	strcpy(pszSearchPattern, szSearchDirPath);
	if (! StringEndsWith(szSearchDirPath, "\\", FALSE))
		strcat(pszSearchPattern, "\\");
	strcat(pszSearchPattern, "*.*");

#ifndef _XBOX // Damn Ascii to Unicode conversion...
	hFind = FindFirstFile(pszSearchPattern, &founddata);
#else // ! XBOX
	LPWSTR	pszWideSearchPattern = NULL;
	int     nWideSize = 0;

	//Determine the size of the wide string we should be allocating, then allocate it and copy the wide string into it
	nWideSize = MultiByteToWideChar(CP_ACP, 0, pszSearchPattern, strlen(pszSearchPattern), NULL, 0) + 1;
	pszWideSearchPattern = (LPWSTR) LocalAlloc(LPTR, nWideSize * sizeof(WCHAR));
	MultiByteToWideChar(CP_ACP, 0, pszSearchPattern, strlen(pszSearchPattern), pszWideSearchPattern, nWideSize);
#pragma TODO(tristanj, "Might want to check to make sure this worked")
	hFind = FindFirstFile(pszWideSearchPattern, &founddata);
	LocalFree(pszWideSearchPattern);
#endif // XBOX
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();

		DPL(0, "Couldn't start search in \"%s\"!  %e",
			2, szSearchDirPath, hr);

		LocalFree(pszSearchPattern);
		pszSearchPattern = NULL;

	     // We ignore the error because it's probably because the directory didn't
		// exist.  The user could have some bogus info in his PATH environment
		// variable, for example.
		return (S_OK);
	} // end if (couldn't find first file)

	LocalFree(pszSearchPattern);
	pszSearchPattern = NULL;


	do
	{
		if ((strcmp(founddata.cFileName, ".") != 0) &&
			(strcmp(founddata.cFileName, "..") != 0))
		{
			dwSubItemPathSize = strlen(szSearchDirPath)+ strlen(founddata.cFileName) + 1;
			if (! StringEndsWith(szSearchDirPath, "\\", FALSE))
				dwSubItemPathSize += 1;

			// If this found item is a directory and we're allowed, then search it
			// recursively.  Otherwise, check to see if it's a matching file.
			if (fSubdirs &&
				(founddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			{
				dwSubItemPathSize++; // include backslash for this directory, too

				pszSubItemPath = (char*) LocalAlloc(LPTR, dwSubItemPathSize);
				if (pszSubItemPath == NULL)
				{
					FindClose(hFind);
					return (E_OUTOFMEMORY);
				} // end if (couldn't allocate memory)

				strcpy(pszSubItemPath, szSearchDirPath);
				if (! StringEndsWith(szSearchDirPath, "\\", FALSE))
					strcat(pszSubItemPath, "\\");
				strcat(pszSubItemPath, founddata.cFileName);
				strcat(pszSubItemPath, "\\");

				// This is a sub dir, so duh, we're searching subdirs, just pass
				// TRUE for that parameter.
				hr = this->SearchFor(szFilename, pszSubItemPath, TRUE, pResultPaths);
				if (hr != S_OK)
				{
					//DPL(0, "Couldn't search for %s in %s!", 2, szFilename, pszSubItemPath);
					LocalFree(pszSubItemPath);
					FindClose(hFind);
					return (hr);
				} // end if (couldn't find paths)

				LocalFree(pszSubItemPath);
				pszSubItemPath = NULL;
			} // end if (this found item is a directory)
			else
			{
				strcpy(szLwrFoundFilename, founddata.cFileName);
				_strlwr(szLwrFoundFilename);

				if (strcmp(szLwrFoundFilename, szLwrSearchFilename) == 0)
				{
					pszSubItemPath = (char*) LocalAlloc(LPTR, dwSubItemPathSize);
					if (pszSubItemPath == NULL)
					{
						FindClose(hFind);
						return (E_OUTOFMEMORY);
					} // end if (couldn't allocate memory)

					strcpy(pszSubItemPath, szSearchDirPath);
					if (! StringEndsWith(szSearchDirPath, "\\", FALSE))
						strcat(pszSubItemPath, "\\");
					strcat(pszSubItemPath, founddata.cFileName);

					hr = pResultPaths->AddString(pszSubItemPath);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add string %s to result paths!", 1, pszSubItemPath);
						LocalFree(pszSubItemPath);
						FindClose(hFind);
						return (hr);
					} // end if (couldn't add string)

					LocalFree(pszSubItemPath);
					pszSubItemPath = NULL;
				} // end if (this file is a match)
			} // end else (this found item is not a directory)
		} // end if (didn't find current or parent directory)

		if (! FindNextFile(hFind, &founddata))
		{
			hr = GetLastError();

			// If there aren't any more files, get out of the loop.
			if (hr == ERROR_NO_MORE_FILES)
			{
				hr = S_OK;
				break;
			} // end if (that was the last file)
		} // end if (finding next file failed)
		else
			hr = S_OK;

	} // end do
	while (hr == S_OK);


	if (! FindClose(hFind))
	{
		hr = GetLastError();

		DPL(0, "Couldn't close search!", 0);
		return (hr);
	} // end if (couldn't close search)

	return (S_OK);
} // CTNTrackedBinaries::SearchFor
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinaryManager::CTNBinaryManager()"
//==================================================================================
// CTNBinaryManager constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNBinaryManager object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNBinaryManager::CTNBinaryManager(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNBinaryManager));

	this->m_pPlacedBins = NULL;
	this->m_pSavedBins = NULL;
} //CTNBinaryManager::CTNBinaryManager
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinaryManager::~CTNBinaryManager()"
//==================================================================================
// CTNBinaryManager destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNBinaryManager object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNBinaryManager::~CTNBinaryManager(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pPlacedBins != NULL)
	{
		delete (this->m_pPlacedBins);
		this->m_pPlacedBins = NULL;
	} // end if (allocated a placed bins object)

	if (this->m_pSavedBins != NULL)
	{
		delete (this->m_pSavedBins);
		this->m_pSavedBins = NULL;
	} // end if (allocated a saved bins object)
} // CTNBinaryManager::~CTNBinaryManager
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#ifndef _XBOX // no swapping supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinaryManager::SaveSnapshot()"
//==================================================================================
// CTNBinaryManager::SaveSnapshot
//----------------------------------------------------------------------------------
//
// Description: Saves the state of the binaries being managed so they can be
//				restored at a later time.
//
// Arguments:
//	PTNTRACKEDBINARIES pBinsToSave		Pointer to list of tracked binaries to save.
//	char* szBinSnapshotPath				Directory to store the saved binaries.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNBinaryManager::SaveSnapshot(PTNTRACKEDBINARIES pBinsToSave,
										char* szBinSnapshotPath)
{
	HRESULT				hr;
	int					i;
	PTNBINARYLOCSLIST	pTrackedBinary = NULL;
	PTNBINARYLOCSLIST	pSavedBinary = NULL;
	int					j;
	PTNBINARY			pTrackedBinaryLoc = NULL;
	PTNBINARY			pSavedBinaryLoc = NULL;
	char*				pszMungedName = NULL;
	DWORD				dwAttemptNumber = 0;


	if ((this->m_pPlacedBins != NULL) || (this->m_pSavedBins != NULL))
	{
		DPL(0, "This object already has a snapshot stored, can't create another one!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (this object already has a snapshot)

	this->m_pPlacedBins = new (CTNTrackedBinaries);
	if (this->m_pPlacedBins == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	this->m_pSavedBins = new (CTNTrackedBinaries);
	if (this->m_pSavedBins == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)


	// Loop through all the binaries to save, and copy all instances (locations) to
	// our save directory.

	for(i = 0; i < pBinsToSave->Count(); i++)
	{
		// Grab the list of locations for this binary
		pTrackedBinary = (PTNBINARYLOCSLIST) pBinsToSave->GetItem(i);
		if (pTrackedBinary == NULL)
		{
			DPL(0, "Couldn't get binary %i to save!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		// Add the list to our own so we know where to restore them to
		hr = this->m_pPlacedBins->Add(pTrackedBinary);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add tracked binary %s to placed binaries list!",
				1, pTrackedBinary->m_pszName);
			goto DONE;
		} // end if (couldn't get item)


		// Duplicate the tracked binary object

		pSavedBinary = new (CTNBinaryLocsList);
		if (pSavedBinary == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		pSavedBinary->m_pszName = (char*) LocalAlloc(LPTR, (strlen(pTrackedBinary->m_pszName) + 1));
		if (pSavedBinary->m_pszName == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
		strcpy(pSavedBinary->m_pszName, pTrackedBinary->m_pszName);


		// Loop through all the locations and save them, noting in our duplicated
		// list where we put the backup copy.

		for(j = 0; j < pTrackedBinary->m_bins.Count(); j++)
		{
			// Grab the location
			pTrackedBinaryLoc = (PTNBINARY) pTrackedBinary->m_bins.GetItem(j);
			if (pTrackedBinaryLoc == NULL)
			{
				DPL(0, "Couldn't get binary location %i to save!", 1, j);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)

			// Build a name for the object that is based off of the original
			// binary's name, but contains no periods or spaces.
			pszMungedName = (char*) LocalAlloc(LPTR, (strlen(pTrackedBinary->m_pszName) + 1));
			if (pszMungedName == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			strcpy(pszMungedName, pTrackedBinary->m_pszName);
			StringReplaceAll(pszMungedName, ".", "_", false, 0, strlen(pszMungedName) + 1);
			StringReplaceAll(pszMungedName, " ", "", false, 0, strlen(pszMungedName) + 1);


			// Build a duplicate object but with the new location.

			pSavedBinaryLoc = new (CTNBinary);
			if (pSavedBinaryLoc == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)

			// Yeah, so we allocated more memory than necessary, deal with it.
			// I don't want to bother calculating size.
			pSavedBinaryLoc->m_pszPath = (char*) LocalAlloc(LPTR, (strlen(szBinSnapshotPath) + MAX_PATH + 1));
			if (pSavedBinaryLoc->m_pszPath == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			// Keep trying to copy the file to our stored location until we
			// successfully generate a unique name and copy it, or find an
			// identical backup already.
			dwAttemptNumber = 1;
			do
			{
				wsprintf(pSavedBinaryLoc->m_pszPath, "%s%s_%s%i.bak",
						szBinSnapshotPath,
						((StringEndsWith(szBinSnapshotPath, "\\", false)) ? "b": "\\b"),
						pszMungedName,
						dwAttemptNumber);

				// Attempt to load any file with that name already there.  If it
				// exists, determine whether the info is the same.  If the info does
				// match, then we don't have to bother copying the file again, we'll
				// just use the existing one.
				hr = pSavedBinaryLoc->LoadInfo();
				if (hr != S_OK)
				{
					// Assume an error means the file wasn't found.
					// We should be okay to copy the file then.

					if (! CopyFile(pTrackedBinaryLoc->m_pszPath,
									pSavedBinaryLoc->m_pszPath, TRUE))
					{
						DPL(0, "Couldn't copy file %s to %s!", 2,
							pTrackedBinaryLoc->m_pszPath,
							pSavedBinaryLoc->m_pszPath);
						hr = GetLastError();
						goto DONE;
					} // end if (couldn't copy the file)

					//BUGBUG write textfile log info

					// We copied the file successfully.  We're done.
					break;
				} // end if (there wasn't a file by that name already)

				// If we're here, it means found an object with that name already.

				DPL(0, "Binary %s already exists...",
					1, pSavedBinaryLoc->m_pszPath);

				if (pSavedBinaryLoc->IsEqualTo(pTrackedBinaryLoc))
				{
					DPL(0, "...appears to be identical, not copying.", 0);
					break; // stop trying
				} // end if (the binary is the same)

				// We need to make another attempt but with a different
				// number.  Make sure we're not in an endless loop though.

				if (dwAttemptNumber == MAX_NUMBER_ATTEMPTS)
				{
					DPL(0, "ERROR: Something is wrong!  Failed attempt %i!",
						1, dwAttemptNumber);
					DPL(0, "       Make sure you don't have a ton of binaries building up in %s.",
							1, szBinSnapshotPath);
					hr = E_FAIL;
					goto DONE;
				} // end if (exceeded max number of attempts)

				dwAttemptNumber++;

				DPL(0, "...does not appear to be identical, moving to attempt %i.",
					1, dwAttemptNumber);

			} // end do
			while (TRUE);


			hr = pSavedBinary->m_bins.Add(pSavedBinaryLoc);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add tracked binary location %s to list!",
					1, pSavedBinaryLoc->m_pszPath);
				goto DONE;
			} // end if (couldn't get item)

			pSavedBinaryLoc = NULL; // forget about it so we don't free it below
		} // end for (each location of the tracked binary)


		hr = this->m_pSavedBins->Add(pSavedBinary);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add tracked binary %s to placed binaries list!",
				1, pSavedBinary->m_pszName);
			goto DONE;
		} // end if (couldn't get item)

		pSavedBinary = NULL; // forget about it so we don't free it below
	} // end for (each binary to save)


DONE:

	if (pSavedBinaryLoc != NULL)
	{
		delete (pSavedBinaryLoc);
		pSavedBinaryLoc = NULL;
	} // end if (have a saved binary loc)

	if (pszMungedName != NULL)
	{
		LocalFree(pszMungedName);
		pszMungedName = NULL;
	} // end if (have a munged name)

	if (pSavedBinary != NULL)
	{
		delete (pSavedBinary);
		pSavedBinary = NULL;
	} // end if (have a saved binary object)

	return (hr);
} // CTNBinaryManager::SaveSnapshot
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // !	XBOX






#ifndef _XBOX // no swapping supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinaryManager::RestoreSnapshot()"
//==================================================================================
// CTNBinaryManager::RestoreSnapshot
//----------------------------------------------------------------------------------
//
// Description: Restores the binaries being managed to the state they were in when
//				the snapshot was taken.
//
// Arguments: None.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNBinaryManager::RestoreSnapshot(void)
{
	HRESULT					hr;
	int						i;
	PTNBINARYLOCSLIST		pPlacedBinLocs = NULL;
	PTNBINARYLOCSLIST		pSavedBinLocs = NULL;
	int						j;
	PTNBINARY				pPlacedBinary = NULL;
	PTNBINARY				pSavedBinary = NULL;


	if ((this->m_pPlacedBins == NULL) || (this->m_pSavedBins == NULL))
	{
		DPL(0, "This object does not have a snapshot stored, can't restore it!", 0);
		//hr = ERROR_BAD_ENVIRONMENT;
		//goto DONE;
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (this object doesn't have a snapshot)


	for(i = 0; i < this->m_pSavedBins->Count(); i++)
	{
		pPlacedBinLocs = (PTNBINARYLOCSLIST) this->m_pPlacedBins->GetItem(i);
		if (pPlacedBinLocs == NULL)
		{
			DPL(0, "Couldn't get placed item %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get item)

		pSavedBinLocs = (PTNBINARYLOCSLIST) this->m_pSavedBins->GetItem(i);
		if (pSavedBinLocs == NULL)
		{
			DPL(0, "Couldn't get saved item %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get item)

		for(j = 0; j < pSavedBinLocs->m_bins.Count(); j++)
		{
			pPlacedBinary = (PTNBINARY) pPlacedBinLocs->m_bins.GetItem(j);
			if (pPlacedBinary == NULL)
			{
				DPL(0, "Couldn't get placed binary %i!", 1, j);
				return (E_FAIL);
			} // end if (couldn't get item)

			pSavedBinary = (PTNBINARY) pSavedBinLocs->m_bins.GetItem(j);
			if (pSavedBinary == NULL)
			{
				DPL(0, "Couldn't get saved binary %i!", 1, j);
				return (E_FAIL);
			} // end if (couldn't get item)

			if (! CopyFile(pSavedBinary->m_pszPath, pPlacedBinary->m_pszPath, FALSE))
			{
				hr = GetLastError();
				DPL(0, "Couldn't restore binary from %s to %s!",
					2, pSavedBinary->m_pszPath, pPlacedBinary->m_pszPath);
				return (hr);
			} // end if (couldn't copy file)
		} // end for (each saved binary)
	} // end for (each saved binary)

	return (S_OK);
} // CTNBinaryManager::RestoreSnapshot
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no swapping supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinaryManager::SwitchBinaryTo()"
//==================================================================================
// CTNBinaryManager::SwitchBinaryTo
//----------------------------------------------------------------------------------
//
// Description: Changes all found instances of the passed in binary to the one
//				located in the path specified.
//
// Arguments:
//	char* szBinaryName		Name of binary to swap.
//	char* szNewBinaryPath	Directory path to retrieve new binary from.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNBinaryManager::SwitchBinaryTo(char* szBinaryName, char* szNewBinaryPath)
{
	//HRESULT					hr;
	PTNBINARYLOCSLIST		pBinaryLocs = NULL;
	char*					pszCopyPath = NULL;
	int						i;
	PTNBINARY				pBinary = NULL;


	//BUGBUG don't save & restore every snapshot item, only the one's SwitchBinaryTo'd.

	if (this->m_pPlacedBins == NULL)
	{
		DPL(0, "No shapshot has been taken, we'd have no way to restore to previous state!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (a snapshot hasn't been taken)

	this->m_pPlacedBins->EnterCritSection();

	pBinaryLocs = this->m_pPlacedBins->GetBinary(szBinaryName);
	if (pBinaryLocs == NULL)
	{
		this->m_pPlacedBins->LeaveCritSection();
		DPL(0, "Couldn't get binary %s!", 1, szBinaryName);
		return (E_FAIL);
	} // end if (couldn't find specified binary)

	pszCopyPath = (char*) LocalAlloc(LPTR, strlen(szNewBinaryPath) + strlen(szBinaryName) + 1);
	if (pszCopyPath == NULL)
	{
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate memory)

	strcpy(pszCopyPath, szNewBinaryPath);
	if (! StringEndsWith(szNewBinaryPath, "\\", false))
		strcat(pszCopyPath, "\\");

	pBinaryLocs->m_bins.EnterCritSection();
	for(i = 0; i < pBinaryLocs->m_bins.Count(); i++)
	{
		pBinary = (PTNBINARY) pBinaryLocs->m_bins.GetItem(i);
		if (pBinary == NULL)
		{
			pBinaryLocs->m_bins.LeaveCritSection();
			DPL(0, "Couldn't get binary location %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get item)

		if (! CopyFile(pszCopyPath, pBinary->m_pszPath, FALSE))
		{
			HRESULT		hr;


			hr = GetLastError();

			pBinaryLocs->m_bins.LeaveCritSection();
			DPL(0, "Couldn't copy file from %s to %s!",
				2, pszCopyPath, pBinary->m_pszPath);
			return (hr);
		} // end if (couldn't replace file)
	} // end for (each location in which we found the binary)
	pBinaryLocs->m_bins.LeaveCritSection();


	return (S_OK);
} // CTNBinaryManager::SwitchBinaryTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\version.h ===
#ifndef __TNCOMMON_VERSION__
#define __TNCOMMON_VERSION__





//==================================================================================
// Versioning information
//==================================================================================

#define TNCOMMON_VERSION_MAJOR		1

#define TNCOMMON_VERSION_MINOR1		1

#define TNCOMMON_VERSION_MINOR2		2

#define TNCOMMON_VERSION_BUILD		26

#define TNCOMMON_VERSION_STRING		"01.01.02.0026"





#endif // __TNCOMMON_VERSION__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\binmgmt.h ===
#ifndef __TNCONTROL_BINMGMT__
#define __TNCONTROL_BINMGMT__
//#pragma message("Defining __TNCONTROL_BINMGMT__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG



#define MAX_NUMBER_ATTEMPTS		50





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNBinary:public LLITEM
{
	public:
		char*		m_pszPath; // place on the machine where the binary was found
		BOOL		m_fDebug; // is this a debug version of the binary
		DWORD		m_dwMS; // most significant 32 bits of binary version
		DWORD		m_dwLS; // least significant 32 bits of binary version
		FILETIME	m_createtime; // time when the file was created
		FILETIME	m_writetime; // time when the file was last written to
		DWORD		m_dwFileSizeHigh; // high order DWORD describing file size
		DWORD		m_dwFileSizeLow; // low order DWORD describing file size


		CTNBinary(void);
		virtual ~CTNBinary(void);

		HRESULT LoadInfo(void);
		BOOL IsEqualTo(PTNBINARY pOtherBinary);
};

class DLLEXPORT CTNBinaryLocsList:public LLITEM
{
	public:
		char*			m_pszName; // (original) name of the binary
		LLIST			m_bins; // list of binaries


		CTNBinaryLocsList(void);
		virtual ~CTNBinaryLocsList(void);
};

class DLLEXPORT CTNTrackedBinaries:public LLIST
{
	// These are declared as friends so they can access the protected functions.
	friend class CTNMachineInfo;
	friend class CTNSlaveInfo;


	private:
		HRESULT SearchFor(char* szFilename, char* szSearchDirPath, BOOL fSubdirs,
						PLSTRINGLIST pResultPaths);


	protected:
		HRESULT PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize);
		HRESULT UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize);
#ifndef _XBOX // no file printing supported
		void PrintToFile(HANDLE hFile);
#endif // ! XBOX


	public:
		CTNTrackedBinaries(void);
		virtual ~CTNTrackedBinaries(void);

		HRESULT LocateAndAddBinary(char* szBinaryName);
		PTNBINARYLOCSLIST GetBinary(char* szBinaryName);

		HRESULT FirstBinIsVersion(char* szBinaryName, DWORD dwHighVersion,
									DWORD dwLowVersion, BOOL* pfResult);
		HRESULT FirstBinIsAtLeastVersion(char* szBinaryName, DWORD dwHighVersion,
										DWORD dwLowVersion, BOOL* pfResult);
		HRESULT LoadSymbolsForFirstBinaries(void);
};

class DLLEXPORT CTNBinaryManager
{
	// This is declared as a friend so it can access the protected functions.
	friend class CTNSlave;


	private:
		PTNTRACKEDBINARIES	m_pPlacedBins; // pointer to list indicating the binaries in their "in-use" locations
		PTNTRACKEDBINARIES	m_pSavedBins; // pointer to list indicating the correspondingly indexed binaries in their "saved" locations


	protected:
#ifndef _XBOX // no swapping supported
		HRESULT SaveSnapshot(PTNTRACKEDBINARIES pBinsToSave, char* szBinSnapshotPath);
		HRESULT RestoreSnapshot(void);
#endif

		
	public:
		DLLSAFE_NEWS_AND_DELETES;

		CTNBinaryManager(void);
		virtual ~CTNBinaryManager(void);

#ifndef _XBOX // no swapping supported
		HRESULT SwitchBinaryTo(char* szBinaryName, char* szNewBinaryPath);
#endif
};






#else //__TNCONTROL_BINMGMT__
//#pragma message("__TNCONTROL_BINMGMT__ already included!")
#endif //__TNCONTROL_BINMGMT__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\comm.h ===
#ifndef __TNCONTROL_COMM__
#define __TNCONTROL_COMM__
//#pragma message("Defining __TNCONTROL_COMM__")





//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Structs
//==================================================================================
typedef struct tagCTRLCOMM_ADDRESSLIST
{
	DWORD	dwNumAddresses; // how many entries in the list
} CTRLCOMM_ADDRESSLIST, * PCTRLCOMM_ADDRESSLIST;

typedef struct tagCONTROLCOMMINITPBLOCK
{
	DWORD				dwSize; // size of this structure
	DWORD				dwControlMethodID; // ID of control method being loaded
	PTNCONTROLLAYER		pControlLayerObj; // pointer to the master or slave object
	BOOL				fMaster; // is the app a testmaster
	DWORD				dwFlags; // method specific extra flags that can be specified
	PVOID				pvData; // pointer to method specific extra data buffer
	DWORD				dwDataSize; // size of data in above buffer
} CONTROLCOMMINITPBLOCK, * PCONTROLCOMMINITPBLOCK;





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNCtrlComm
{
	// These are friends so they can access the protected members
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX

	friend CTNSlave;


	private:
		HANDLE					m_hSendThread; // the send thread
		HANDLE					m_hReceiveThread; // the receive thread


	protected:
		DWORD					m_dwMethodID; // ID of the control method
		BOOL					m_fMaster; // are we the testmaster
		LPTHREAD_START_ROUTINE	m_lpSendThreadProc; // procedure to send data with.
		LPTHREAD_START_ROUTINE	m_lpReceiveThreadProc; // procedure to receive data with.


		HRESULT StartThreads(void);
		HRESULT KillThreads(void);


	public:
		// These are only public so the threads can access them
		DWORD					m_dwRefCount; // how many people are using us
		PTNCONTROLLAYER			m_pControlObj; // pointer to object using us that is receiving incoming messages
		CTNSendDataQueue		m_sendqueue; // linked list with data to send
		HANDLE					m_hKillSendThreadEvent; // when to kill the send thread
		HANDLE					m_hKillReceiveThreadEvent; // when to kill the receive thread


		DLLSAFE_NEWS_AND_DELETES;

		CTNCtrlComm(void);
		virtual ~CTNCtrlComm(void);


		// These are pure virtuals, derived classes must implement them because we sure
		// don't!
		virtual HRESULT Initialize(void) = 0;

		virtual HRESULT Release(void) = 0;

		virtual HRESULT GetBroadcastAddress(PVOID pvModifierData,
											DWORD dwModifierDataSize,
											PVOID pvAddress,
											DWORD* pdwAddressSize) = 0;

		virtual HRESULT ConvertStringToAddress(char* szString,
												PVOID pvModifierData,
												DWORD dwModifierDataSize,
												PVOID pvAddress,
												DWORD* pdwAddressSize) = 0;

		virtual HRESULT GetSelfAddressAsString(char* pszString,
												DWORD* pdwStringSize) = 0;

		virtual HRESULT BindDataToAddress(PCOMMDATA pCommData) = 0;

		virtual HRESULT UnbindDataFromAddress(PCOMMDATA pCommData) = 0;

		virtual HRESULT FlushSendQueue(void) = 0;


		virtual HRESULT StartAcceptingReachCheck(PTNREACHCHECK pReachCheck) = 0;

		virtual HRESULT StopAcceptingReachCheck(PTNREACHCHECK pReachCheck) = 0;

		virtual HRESULT PrepareToReachCheck(PTNREACHCHECK pReachCheck) = 0;

		virtual HRESULT CleanupReachCheck(PTNREACHCHECK pReachCheck) = 0;
};





#else //__TNCONTROL_COMM__
//#pragma message("__TNCONTROL_COMM__ already included!")
#endif //__TNCONTROL_COMM__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\comm.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\sprintf.h"

#include "tncontrl.h"
#include "main.h"

#include "sendq.h"
#include "comm.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlComm::CTNCtrlComm()"
//==================================================================================
// CTNCtrlComm constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNCtrlComm object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNCtrlComm::CTNCtrlComm(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNCtrlComm));

	this->m_hSendThread = NULL;
	this->m_hReceiveThread = NULL;

	this->m_dwMethodID = 0;
	this->m_fMaster = FALSE;
	this->m_lpSendThreadProc = NULL;
	this->m_lpReceiveThreadProc = NULL;

	this->m_dwRefCount = 0;
	this->m_pControlObj = NULL;
	this->m_hKillSendThreadEvent = NULL;
	this->m_hKillReceiveThreadEvent = NULL;
} // CTNCtrlComm::CTNCtrlComm
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlComm::~CTNCtrlComm()"
//==================================================================================
// CTNCtrlComm destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNCtrlComm object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNCtrlComm::~CTNCtrlComm(void)
{
	HRESULT		hr;


	//DPL(0, "this = %x", 1, this);

#ifdef DEBUG
	if (this->m_dwRefCount != 0)
	{
		DPL(0, "Deleting ctrl comm object %x when refcount is not 0 (its %u)!  DEBUGBREAK()-ing",
			2, this, this->m_dwRefCount);

		DEBUGBREAK();
	} // end if (not last refcount)
#endif // DEBUG


	// Empty the send queue
	hr = this->m_sendqueue.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "Failed remove all the data to send from the queue!  %e", 1, hr);
	} // end if (couldn't empty send queue)

	hr = this->KillThreads();
	if (hr != S_OK)
	{
		DPL(0, "Failed to kill threads!  %e", 1, hr);
	} // end if (failed to kill threads)
} // CTNCtrlComm::~CTNCtrlComm
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlComm::StartThreads()"
//==================================================================================
// CTNCtrlComm::StartThreads
//----------------------------------------------------------------------------------
//
// Description: Creates the events and threads the control layer needs.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlComm::StartThreads(void)
{
	DWORD	dwThreadID;


	if (this->m_lpSendThreadProc != NULL)
	{
		// Create send thread and associated manual reset event
		this->m_hKillSendThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		if (this->m_hKillSendThreadEvent == NULL)
			return (GetLastError());

		this->m_hSendThread = CreateThread(NULL, 0, this->m_lpSendThreadProc,
										this, 0, &dwThreadID);
		if (this->m_hSendThread == NULL)
			return (GetLastError());
	} // end if (the send thread can be created)

	if (this->m_lpReceiveThreadProc != NULL)
	{
		// Create receive thread and associated manual reset event
		this->m_hKillReceiveThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		if (this->m_hKillReceiveThreadEvent == NULL)
			return (GetLastError());

		this->m_hReceiveThread = CreateThread(NULL, 0, this->m_lpReceiveThreadProc,
											this, 0, &dwThreadID);
		if (this->m_hReceiveThread == NULL)
			return (GetLastError());
	} // end if (the receive thread can be created)

	return (S_OK);
} // CTNCtrlComm::StartThreads
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlComm::KillThreads()"
//==================================================================================
// CTNCtrlComm::KillThreads
//----------------------------------------------------------------------------------
//
// Description: Shuts down any threads and releases the events the control layer
//				used.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlComm::KillThreads(void)
{
	// Close all items associated with the send thread
	if (this->m_hSendThread != NULL)
	{
		if (this->m_hKillSendThreadEvent == NULL) // ack, we won't be able to tell it to die
			return (E_FAIL);

		if (! SetEvent(this->m_hKillSendThreadEvent))
			return (E_FAIL);

		switch (WaitForSingleObject(this->m_hSendThread, TIMEOUT_DIE_CONTROLSENDTHREAD))
		{
			case WAIT_OBJECT_0:
				// what we want
			  break;
			case WAIT_TIMEOUT:
				DPL(0, "Waited %i ms for control send thread to die but it didn't!",
					1, TIMEOUT_DIE_CONTROLSENDTHREAD);


#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
				DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT

			  break;
			default:
				DPL(0, "Got unexpected return code from WaitForSingleObject on the control send thread!", 0);
			  break;
		} // end switch (on result of waiting for thread to die)

		CloseHandle(this->m_hSendThread);
		this->m_hSendThread = NULL;
	} // end if (the send thread exists)

	if (this->m_hKillSendThreadEvent != NULL)
	{
		CloseHandle(this->m_hKillSendThreadEvent);
		this->m_hKillSendThreadEvent = NULL;
	} // end if (have event)

	// Close all items associated with the receive thread
	if (this->m_hReceiveThread != NULL)
	{
		if (this->m_hKillReceiveThreadEvent == NULL) // ack, we won't be able to tell it to die
			return (E_FAIL);

		if (! SetEvent(this->m_hKillReceiveThreadEvent))
			return (E_FAIL);

		switch (WaitForSingleObject(this->m_hReceiveThread, TIMEOUT_DIE_CONTROLRECEIVETHREAD))
		{
			case WAIT_OBJECT_0:
				// what we want
			  break;
			case WAIT_TIMEOUT:
				DPL(0, "Waited %i ms for control receive thread to die but it didn't!",
					1, TIMEOUT_DIE_CONTROLRECEIVETHREAD);


#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
				DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT

			  break;
			default:
				DPL(0, "Got unexpected return code from WaitForSingleObject on the control receive thread!", 0);
			  break;
		} // end switch (on result of waiting for thread to die)

		CloseHandle(this->m_hReceiveThread);
		this->m_hReceiveThread = NULL;
	} // end if (the receive thread exists)

	if (this->m_hKillReceiveThreadEvent != NULL)
	{
		CloseHandle(this->m_hKillReceiveThreadEvent);
		this->m_hKillReceiveThreadEvent = NULL;
	} // end if (have event)

	return (S_OK);
} // CTNCtrlComm::KillThreads
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\comports.h ===
#ifndef __TNCONTROL_COMPORTS__
#define __TNCONTROL_COMPORTS__
//#pragma message("Defining __TNCONTROL_COMPORTS__")





//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG




//==================================================================================
// Defines
//==================================================================================
#define COMPORTLIST_FILENAME	"comports.ini"




//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNCOMPort:public CLString
{
	// These are friends so they can access the protected members.
	friend CTNMachineInfo;
	friend CTNCOMPortsList;


	protected:
		DWORD	m_dwCOMPort; // COM port number of this object


	public:
		CTNCOMPort(char* szConnectedMachineName, DWORD dwCOMPort);
		virtual ~CTNCOMPort(void);

		DWORD GetCOMPort(void);
};

class DLLEXPORT CTNCOMPortsList:public CLStringList
{
	// These are friends so they can access the protected members.
	friend CTNMachineInfo;
	friend CTNSlaveInfo;


	protected:
		//CTNCOMPortsList(void);
		//virtual ~CTNCOMPortsList(void);

		HRESULT PackIntoBuffer(PVOID pvBuffer, DWORD* pdwSize);
		HRESULT UnpackFromBuffer(PVOID pvBuffer, DWORD dwSize);
#ifndef _XBOX // no file printing supported
		void PrintToFile(HANDLE hFile);
#endif // ! XBOX
};





#else //__TNCONTROL_COMPORTS__
//#pragma message("__TNCONTROL_COMPORTS__ already included!")
#endif //__TNCONTROL_COMPORTS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\control.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\sprintf.h"

#include "tncontrl.h"
#include "main.h"

#include "sendq.h"
#include "comm.h"
#include "control.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNControlLayer::CTNControlLayer()"
//==================================================================================
// CTNControlLayer constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNControlLayer object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNControlLayer::CTNControlLayer(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNControlLayer));

	this->m_pfnLogString = NULL;
	this->m_pCtrlComm = NULL;
	this->m_hCompletionOrUpdateEvent = NULL;
} // CTNControlLayer::CTNControlLayer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNControlLayer::~CTNControlLayer()"
//==================================================================================
// CTNControlLayer destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNControlLayer object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNControlLayer::~CTNControlLayer(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pCtrlComm != NULL)
	{
		this->m_pCtrlComm->Release(); // ignoring error
		delete (this->m_pCtrlComm);
		this->m_pCtrlComm = NULL;
	} // end if (there is still a control method object)
} // CTNControlLayer::~CTNControlLayer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNControlLayer::Log()"
//==================================================================================
// CTNControlLayer::Log
//----------------------------------------------------------------------------------
//
// Description: Logs the passed in string to the shell, noting whether this is
//				critical, normal or verbose information.  The string will be
//				parsed for special tokens, see tncommon\sprintf.cpp for possible
//				arguments.
//
// Arguments:
//	DWORD dwLogStringType	What significance does the string have (see TNLST_xxx).
//	char* szFormatString	String with optional special tokens to log.
//	DWORD dwNumParms		Number of parameters in the following variable parameter
//							list.
//	...						Variable parameter list; items are interpreted as the
//							special token replacements.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNControlLayer::Log(DWORD dwLogStringType, char* szFormatString,
							DWORD dwNumParms, ...)
{
	HRESULT		hr;
	PVOID*		papvParms = NULL;
	va_list		currentparam;
	DWORD		dwTemp;
	char*		pszLogString = NULL;


	// If the shell doesn't have a log function
	if (this->m_pfnLogString == NULL)
	{
		//BUGBUG is this what we want?
		hr = S_OK;
		goto DONE;
	} // end if (no log function)

	
	if (dwNumParms == 0)
	{
#ifndef _XBOX
		hr = this->m_pfnLogString(dwLogStringType, szFormatString);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't log string!", 0);
		} // end if (shell's log string function failed)
#else // ! XBOX
#pragma TODO(tristanj, "Map this logging to Xbox's logging subsystem")
#endif // XBOX

		goto DONE;
	} // end if (there are format items)


#ifndef _XBOX // no TNsprintf functions
	papvParms = (PVOID*) LocalAlloc(LPTR, (dwNumParms * sizeof (PVOID)));
	if (papvParms == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)


	// Loop through the variable arguments and put them into an array for passing
	// to sprintf.
	va_start(currentparam, dwNumParms);
	for(dwTemp = 0; dwTemp < dwNumParms; dwTemp++)
	{
		papvParms[dwTemp] = va_arg(currentparam, PVOID);
	} // end for (each variable parameter)
	va_end(currentparam);

	TNsprintf_array(&pszLogString, szFormatString, dwNumParms, papvParms);

	hr = this->m_pfnLogString(dwLogStringType, pszLogString);
	if (hr != S_OK)
	{
		DPL(0, "Shell's LogString function failed!", 0);
		goto DONE;
	} // end if (shell's log string function failed)
#else // ! XBOX
#pragma TODO(tristanj, "Need to map control layer logging to xLog")
#endif // XBOX


DONE:

	if (papvParms != NULL)
	{
		LocalFree(papvParms);
		papvParms = NULL;
	} // end if (have array)

	if (pszLogString != NULL)
		TNsprintf_free(&pszLogString);

	return (hr);
} // CTNControlLayer::Log
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\commtcp.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock2 fn proto's, for getprocaddress
#include <windows.h>
#ifndef _XBOX
#include <winsock2.h>
#else
#include <winsockx.h>		// Needed for XNet initialization
#include <stdio.h>			// Needed for ANSI/Unicode conversion
#include <stdlib.h>			// Needed for ANSI/Unicode conversion
#endif // XBOX


#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\strutils.h"

#include "tncontrl.h"
#include "main.h"

#include "sendq.h"
#include "comm.h"
#include "commtcp.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CtrlCommTCPLoadOptimal()"
//==================================================================================
// CtrlCommTCPLoadOptimal
//----------------------------------------------------------------------------------
//
// Description: Creates the WinSock TCP/IP optimal WinSock version control method
//				object.
//
// Arguments:
//	PCONTROLCOMMINITPBLOCK pParams		Data coming in to the function.
//	PTNCTRLCOMM* ppCTNCtrlComm			Pointer to pointer to hold object created.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CtrlCommTCPLoadOptimal(PCONTROLCOMMINITPBLOCK pParams,
								PTNCTRLCOMM* ppCTNCtrlComm)
{
	PTNCTRLCOMMTCP		pObj = NULL;


	// Create the object.
	// TRUE = we can use winsock 2 functionality if available
	pObj = new (CTNCtrlCommTCP)(pParams, TRUE);
	if (pObj == NULL)
		return (E_OUTOFMEMORY);

	pObj->m_dwRefCount++; // caller is using it

	// Return our new object
	(*ppCTNCtrlComm) = pObj;

	return (S_OK);
} // CtrlCommTCPLoadOptimal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CtrlCommTCPLoadWinSock1()"
//==================================================================================
// CtrlCommTCPLoadWinSock1
//----------------------------------------------------------------------------------
//
// Description: Creates the WinSock TCP/IP forced non WinSock version 2
//				functionality control method object.
//
// Arguments:
//	PCONTROLCOMMINITPBLOCK pParams		Data coming in to the function.
//	PTNCTRLCOMM* ppTNCtrlComm			Pointer to pointer to hold object created.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CtrlCommTCPLoadWinSock1(PCONTROLCOMMINITPBLOCK pParams,
								PTNCTRLCOMM* ppTNCtrlComm)
{
	PTNCTRLCOMMTCP	pObj = NULL;


	// Create the object
	// FALSE = we won't use winsock 2 functionality ever
	pObj = new (CTNCtrlCommTCP)(pParams, FALSE);
	if (pObj == NULL)
		return (E_OUTOFMEMORY);

	pObj->m_dwRefCount++; // caller is using it

	// Return our new object
	(*ppTNCtrlComm) = pObj;

	return (S_OK);
} // CtrlCommTCPLoadWinSock1
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CtrlCommTCPLoadWinSock2OneToOne()"
//==================================================================================
// CtrlCommTCPLoadWinSock2OneToOne
//----------------------------------------------------------------------------------
//
// Description: Creates the WinSock TCP/IP optimal WinSock version control method
//				object.
//
// Arguments:
//	PCONTROLCOMMINITPBLOCK pParams		Data coming in to the function.
//	PTNCTRLCOMM* ppTNCtrlComm			Pointer to pointer to hold object created.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CtrlCommTCPLoadWinSock2OneToOne(PCONTROLCOMMINITPBLOCK pParams,
										PTNCTRLCOMM* ppTNCtrlComm)
{
	PTNCTRLCOMMTCP	pObj = NULL;


	// Create the object.
	// TRUE = we can use winsock 2 functionality if available
	pObj = new (CTNCtrlCommTCP)(pParams, TRUE);
	if (pObj == NULL)
		return (E_OUTOFMEMORY);

	pObj->m_dwRefCount++; // caller is using it

	// Return our new object
	(*ppTNCtrlComm) = pObj;

	return (S_OK);
} // CtrlCommTCPLoadWinSock2OneToOne
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::CLinkedSocket()"
//==================================================================================
// CLinkedSocket constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CLinkedSocket, using the passed in parameters.
//
// Arguments:
//	SOCKET sNew				Socket to add.
//	SOCKADDR_IN address		The address of the socket being added.
//	BOOL fTCP				Whether the socket is TCP or not.
//	BOOL fListen			If the socket is TCP, whether its a listen socket or not.
//	BOOL fBroadcast			If the socket is UDP, whether its capable of sending
//							broadcasts or not.
//	HANDLE hWinSock2Event	Handle to event associated with socket, if available.
//
// Returns: None (just the object).
//==================================================================================
CLinkedSocket::CLinkedSocket(SOCKET sNew, SOCKADDR_IN address, BOOL fTCP, BOOL fListen,
							BOOL fBroadcast, HANDLE hWinSock2Event):
	m_socket(sNew),
	m_address(address),
	m_pCommData(NULL),
	m_fTCP(fTCP),
	m_fListen(fListen),
	m_fBroadcast(fBroadcast),
	m_hWS2Event(hWinSock2Event),
	m_dwFoundPriorToReachCheck(0)
{
	DPL(9, "this = %x, sizeof (this) = %i", 2, this, sizeof (CLinkedSocket));

	if ((fTCP) && (fListen))
		this->m_fListen = TRUE;

	if ((! fTCP) && (fBroadcast))
		this->m_fBroadcast = TRUE;
} // CLinkedSocket::CLinkedSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::~CLinkedSocket()"
//==================================================================================
// CLinkedSocket destructor
//----------------------------------------------------------------------------------
//
// Description: Releases data associated with the CLinkedSocket object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CLinkedSocket::~CLinkedSocket(void)
{
	HRESULT		hr;


	DPL(9, "this = %x", 1, this);

	hr = this->CloseSocket();
	if (hr != S_OK)
	{
		DPL(0, "Closing the socket failed!  %e", 1, hr);
	} // end if (failed closing the socket)
} // CLinkedSocket::~CLinkedSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::GetSocket()"
//==================================================================================
// CLinkedSocket::GetSocket
//----------------------------------------------------------------------------------
//
// Description: Retrieves this socket.
//
// Arguments: None.
//
// Returns: Pointer to this socket.
//==================================================================================
SOCKET* CLinkedSocket::GetSocket(void)
{
	return (&(this->m_socket));
} // CLinkedSocket::GetSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::GetAddress()"
//==================================================================================
// CLinkedSocket::GetAddress
//----------------------------------------------------------------------------------
//
// Description: Retrieves this socket's address.
//
// Arguments: None.
//
// Returns: Pointer to this item's socket address.
//==================================================================================
SOCKADDR_IN* CLinkedSocket::GetAddress(void)
{
	return (&(this->m_address));
} // CLinkedSocket::GetAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::GetEvent()"
//==================================================================================
// CLinkedSocket::GetEvent
//----------------------------------------------------------------------------------
//
// Description: Retrieves this socket's event.
//
// Arguments: None.
//
// Returns: Handle of this socket's event.
//==================================================================================
HANDLE CLinkedSocket::GetEvent(void)
{
	return (this->m_hWS2Event);
} // CLinkedSocket::GetEvent
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::IsTCPListen()"
//==================================================================================
// CLinkedSocket::IsTCPListen
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this is a TCP socket that is listening, FALSE
//				otherwise.
//
// Arguments: None.
//
// Returns: TRUE if TCP and listen, FALSE otherwise.
//==================================================================================
BOOL CLinkedSocket::IsTCPListen(void)
{
	return ((this->m_fTCP) && (this->m_fListen));
} // CLinkedSocket::IsTCPListen
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::IsUDP()"
//==================================================================================
// CLinkedSocket::IsUDP
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this is a UDP socket, FALSE otherwise.
//
// Arguments: None.
//
// Returns: TRUE if UDP, FALSE otherwise.
//==================================================================================
BOOL CLinkedSocket::IsUDP(void)
{
	return (!(this->m_fTCP));
} // CLinkedSocket::IsUDP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::IsUDPBroadcast()"
//==================================================================================
// CLinkedSocket::IsUDPBroadcast
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this is a UDP socket capable of sending to the
//				broadcast address, FALSE otherwise.
//
// Arguments: None.
//
// Returns: TRUE if UDP, FALSE otherwise.
//==================================================================================
BOOL CLinkedSocket::IsUDPBroadcast(void)
{
	return ((! this->m_fTCP) && (this->m_fBroadcast));
} // CLinkedSocket::IsUDPBroadcast
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLinkedSocket::CloseSocket()"
//==================================================================================
// CLinkedSocket::CloseSocket
//----------------------------------------------------------------------------------
//
// Description: Closes the socket gracefully.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CLinkedSocket::CloseSocket(void)
{
	HRESULT		hr;


	// Silently return if the socket is bad
	if (this->m_socket == INVALID_SOCKET)
		return (S_OK);

	if ((this->m_fTCP) && (! this->m_fListen))
	{
		DPL(3, "Closing connection to %o", 1, &(this->m_address));

		// Disable sends, tell other side we want to shutdown.
		if (shutdown(this->m_socket, SD_SEND) == SOCKET_ERROR)
		{
			hr = WSAGetLastError();
			DPL(0, "Shutting down sends on stream socket failed!", 0);
			return (hr);
		} // end if (shutdown failed)

		/*
		// Read any pending data
		while (1)
		{
			hr = recv(this->m_socket, lpBuffer, iBufferSize, 0);
			if (hr == SOCKET_ERROR)
			{
				DPL(0, "Failed to receive stream data!  %e", 1, WSAGetLastError());
				break;
			} // end if (failed to receive data)
			else if (hr == 0)
			{
				break;
			} // end if (connection was closed)
		} // end while (haven't received all data)
		*/

		// Let other side know we are finished.
		if (shutdown(this->m_socket, SD_BOTH) == SOCKET_ERROR)
		{
			DPL(0, "Shutting down stream socket failed!", 0);
			return (WSAGetLastError());
		} // end if (shutdown failed)
	} // end if (this is a TCP socket)

	if (closesocket(this->m_socket) != 0)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to close socket!", 0);
		return (hr);
	} // end if (failed to close socket)
	this->m_socket = INVALID_SOCKET;

	if (this->m_pCommData != NULL)
	{
		this->m_pCommData->fDropped = TRUE;
		/*
		if (! SetEvent(this->m_lpCommData->hStatusEvent))
		{
			DPL(0, "Couldn't set status event!", 0);
		} // end if (failed to set status event)
		*/
	} // end if (this socket was bound by the control layer)

	return (S_OK);
} // CLinkedSocket::CloseSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLSocketsList::CLSocketsList()"
//==================================================================================
// CLSocketsList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CLSocketsList object.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CLSocketsList::CLSocketsList(void)
{
	HRESULT		hr;


	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CLSocketsList));

	this->m_hListChangedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (this->m_hListChangedEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create list changed event!  %e", 1, hr);
	} // end if (couldn't create event)
} // CLSocketsList::CLSocketsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLSocketsList::~CLSocketsList()"
//==================================================================================
// CLSocketsList destructor
//----------------------------------------------------------------------------------
//
// Description: Releases data associated with the CLSocketsList object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CLSocketsList::~CLSocketsList(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_hListChangedEvent != NULL)
	{
		CloseHandle(this->m_hListChangedEvent);
		this->m_hListChangedEvent = NULL;
	} // end if (have event)
} // CLSocketsList::~CLSocketsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLSocketsList::AddSocket()"
//==================================================================================
// CLSocketsList::AddSocket
//----------------------------------------------------------------------------------
//
// Description: Adds the passed in socket to this list and sets the list changed
//				event if applicable.
//
// Arguments:
//	SOCKET sNew					Socket to add.
//	SOCKADDR_IN address			The address of the socket being added.
//	BOOL fTCP					Whether the socket is TCP or not.
//	BOOL fListen				If the socket is TCP, whether its a listen socket or
//								not.
//	BOOL fBroadcast				If the socket is UDP, whether its capable of sending
//								broadcasts or not.
//	HANDLE hWinSock2Event		Handle to event to associate with socket, or NULL to
//								not associate anything.
//	PLINKEDSOCKET* ppLSocket	Place to store pointer to socket object created, or
//								 NULL if not wanted.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CLSocketsList::AddSocket(SOCKET sNew, SOCKADDR_IN address, BOOL fTCP,
								BOOL fListen, BOOL fBroadcast, HANDLE hWinSock2Event,
								PLINKEDSOCKET* ppLSocket)
{
	HRESULT			hr;
	PLINKEDSOCKET	pNewItem = NULL;


	pNewItem = new (CLinkedSocket)(sNew, address, fTCP, fListen, fBroadcast,
									hWinSock2Event);
	if (pNewItem == NULL)
		return (E_OUTOFMEMORY);

	this->EnterCritSection();

	hr = this->Add(pNewItem);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add linked socket to list!", 0);
	} // end if (couldn't add item to list)
	else if (hWinSock2Event)
	{
		if (! SetEvent(this->m_hListChangedEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set list changed event (%x)!",
				1, this->m_hListChangedEvent);
		} // end if (couldn't set event)
	} // end else if (could add item to list and using WinSock2)

	/*
	DPL(9, "Added %s socket at index %i.",
		2, (fTCP ? "TCP" : "UDP"), (this->Count() - 1));
	*/

	if (ppLSocket != NULL)
		(*ppLSocket) = pNewItem;

	this->LeaveCritSection();

	return (hr);
} // CLSocketsList::AddSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLSocketsList::AddNewConnectionFromSocket()"
//==================================================================================
// CLSocketsList::AddNewConnectionFromSocket
//----------------------------------------------------------------------------------
//
// Description: Accepts the next connection available on the socket passed in, and
//				and adds that connection to this list.  If hWinSock2Event and
//				lpfnWSAEventSelect are not NULL, the event will be associated with
//				the new socket (using that proc).
//
// Arguments:
//	SOCKET* pListenSocket					Socket that is ready to accept a
//											connection.
//	HANDLE hWinSock2Event					Event to associate with socket, if any.
//	LPFN_WSAEVENTSELECT lpfnWSAEventSelect	Pointer to WinSock2 procedure to call.
//	BOOL fSocketOwnsEvent					TRUE if the new socket should own (and
//											thus, know about) the WinSock 2 event.
//	PLINKEDSOCKET* ppLSocket				Place to store pointer to socket object
//											created, or NULL if not wanted.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CLSocketsList::AddNewConnectionFromSocket(SOCKET* pListenSocket,
												HANDLE hWinSock2Event,
												LPFN_WSAEVENTSELECT lpfnWSAEventSelect,
												BOOL fSocketOwnsEvent,
												PLINKEDSOCKET* ppLSocket)
{
	HRESULT			hr;
	SOCKET			sNew;
	SOCKADDR_IN		fromSockAddress;
	int				iFromSockAddressSize = sizeof (SOCKADDR_IN);
	HANDLE			hEvent = NULL;


	sNew = accept((*pListenSocket), (SOCKADDR*) (&fromSockAddress), &iFromSockAddressSize);
	if (sNew == INVALID_SOCKET)
	{
		hr = WSAGetLastError();

		// WinSock2 seems to be setting our events twice, so trying to handle the
		// item again returns WSAEWOULDBLOCK.
		if (hr != WSAEWOULDBLOCK)
		{
			DPL(0, "Stream socket accept failed!", 0);
		} // end if (not special case)
		return (hr);
	} // end if (accept failed)

	if ((hWinSock2Event != NULL) && (lpfnWSAEventSelect != NULL))
	{
		hr = lpfnWSAEventSelect(sNew, hWinSock2Event, FD_CLOSE | FD_READ);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't associate receive event with new socket!", 0);
			return (hr);
		} // end if (WSAEventSelect failed)
	} // end if (we're using WinSock2 functionality)

	hr = this->AddSocket(sNew, fromSockAddress, TRUE, FALSE, FALSE,
						((fSocketOwnsEvent) ? hWinSock2Event : NULL),
						ppLSocket);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add accepted socket!  Closing it.", 0);
		closesocket(sNew); // ignoring error
		return (hr);
	} // end if (failed to add socket)


	DPL(5, "Successfully received connection from %o", 1, &fromSockAddress);

	return (S_OK);
} // CLSocketsList::AddNewConnectionFromSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLSocketsList::GetLSocketByAddress()"
//==================================================================================
// CLSocketsList::GetLSocketByAddress
//----------------------------------------------------------------------------------
//
// Description: If TCP, this searches the list of sockets for one connected to the
//				specified address and port.  If UDP, then the first UDP socket found
//				using a matching port is returned.  If the address is the broadcast
//				address, only broadcast capable sockets are returned.
//				If pAddress is NULL, then the first socket of the given type is
//				returned.
//
// Arguments:
//	SOCKADDR_IN* pAddress	Address to search for.
//	BOOL fTCP				Whether to look for a TCP socket or not.
//
// Returns: Pointer to the socket found or NULL if doesn't exist.
//==================================================================================
PLINKEDSOCKET CLSocketsList::GetLSocketByAddress(SOCKADDR_IN* pAddress, BOOL fTCP)
{
	BOOL				fLocal = FALSE;
	BOOL				fUDPBroadcast = FALSE;
	int					i;
	PLINKEDSOCKET		pItem = NULL;



	// UDP sockets are connectionless and therefore always only have port
	// information.
	if (! fTCP)
	{
		fLocal = TRUE;
	} // end if (not TCP socket)

	// If there's a socket, note if it specifies the special unknown or broadcast
	// addresses.
	if (pAddress)
	{
		unsigned long*		pulIPaddr;


		pulIPaddr = (unsigned long*) (&pAddress->sin_addr.S_un);

		if ((*pulIPaddr) == INADDR_ANY)
		{
			fLocal = TRUE;
		} // end if (unspecified address)


		if ((*pulIPaddr) == INADDR_BROADCAST)
		{
#ifdef DEBUG
			if (fTCP)
			{
				DPL(0, "Looking for TCP connection to the broadcast address!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
			} // end if (looking for TCP socket)
#endif // DEBUG

			fUDPBroadcast = TRUE;
		} // end if (address is the broadcast address)

#ifdef DEBUG
		if (pAddress->sin_port == 0)
		{
			DPL(0, "Looking for %s socket with an unspecified port!?  DEBUGBREAK()-ing.",
				1, ((fTCP) ? "TCP" : "UDP"));
			DEBUGBREAK();
		} // end if (no port)
#endif // DEBUG
	} // end if (there's an address)


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PLINKEDSOCKET) this->GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Failed to get socket %i!", 1, i);
			this->LeaveCritSection();
			return (NULL);
		} // end if (couldn't get that item)


		// Skip sockets of the wrong type.
		if (((fTCP) && (pItem->IsUDP())) ||
			((! fTCP) && (! pItem->IsUDP())))
		{
			continue;
		} // end if (socket of wrong type)


		// If the socket needs to be broadcast capable, and this isn't, skip it.
		if ((fUDPBroadcast) && (! pItem->IsUDPBroadcast()))
			continue;


		if (pAddress)
		{
			SOCKADDR_IN*	pCompareAddress;


			pCompareAddress = pItem->GetAddress();

			// If it's a local address, we only care about the port.
			if (fLocal)
			{
				// Check if it's using the right port.
				if (pCompareAddress->sin_port != pAddress->sin_port)
					continue;

				// If we're looking for a local TCP socket, make sure this
				// one is a TCP listen socket.
				if ((fTCP) && (! pItem->IsTCPListen()))
					continue;
			} // end if (local)
			else
			{
				// Check if it's a connection to the right address.
				if (memcmp(pCompareAddress, pAddress, sizeof (SOCKADDR_IN)) != 0)
					continue;
			} // end else (not local)
		} // end if (there's an address to compare)


		// If we're here, it means we found an item to use.  We're done.
		this->LeaveCritSection();
		return (pItem);
	} // end for (each item in this list)
	this->LeaveCritSection();

	return (NULL);
} // CLSocketsList::GetLSocketByAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::CTNCtrlCommTCP()"
//==================================================================================
// CTNCtrlCommTCP constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNCtrlCommTCP object, using the passed in parameters.
//
// Arguments:
//	PCONTROLCOMMINITPBLOCK pParams	How to create the object.
//	BOOL fWinSock2					Whether WinSock2 can be looked for.
//
// Returns: None (just the object).
//==================================================================================
CTNCtrlCommTCP::CTNCtrlCommTCP(PCONTROLCOMMINITPBLOCK pParams, BOOL fWinSock2):
	m_fWinSock2(fWinSock2)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNCtrlCommTCP));

	this->m_dwMethodID = pParams->dwControlMethodID;

	this->m_hWinSock2DLL = NULL;

	// Assume we're not going to use a Send thread.  See below.
	this->m_lpSendThreadProc = NULL;

	// Assume we're using WinSock 1 for now, this will get overwritten if we in
	// fact load WinSock 2.
	this->m_lpReceiveThreadProc = WS1ReceiveThreadProc;

	this->m_fWinSockStarted = FALSE;

	// If we're in a special mode, we need to delay our socket setup, otherwise,
	// go ahead and startup the appropriate ctrl method stuff
	this->m_fCtrlMethodMode = FALSE;
	if (pParams->dwFlags == 0)
	{
		this->m_fCtrlMethodMode = TRUE;
		this->m_lpSendThreadProc = WSSendThreadProc;
	} // end if (we're in normal mode)


	this->m_fWinSock2 = fWinSock2;
	this->m_hAllSocketsReceiveEvent = NULL;
	this->m_lpfnWSAEventSelect = NULL;
	this->m_lpfnWSAWaitForMultipleEvents = NULL;
	this->m_lpfnWSAResetEvent = NULL;

	this->m_pControlObj = pParams->pControlLayerObj;
	this->m_fMaster = pParams->fMaster;
} // CTNCtrlCommTCP::CTNCtrlCommTCP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::~CTNCtrlCommTCP()"
//==================================================================================
// CTNCtrlCommTCP destructor
//----------------------------------------------------------------------------------
//
// Description: Releases data associated with the CTNCtrlCommTCP object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNCtrlCommTCP::~CTNCtrlCommTCP(void)
{
	HRESULT		hr;


	//DPL(0, "this = %x", 1, this);

	hr = this->Release();
	if (hr != S_OK)
	{
		DPL(0, "Releasing object failed!", 0);
	} // end if (releasing object failed)
} // CTNCtrlCommTCP::~CTNCtrlCommTCP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::Initialize()"
//==================================================================================
// CTNCtrlCommTCP::Initialize
//----------------------------------------------------------------------------------
//
// Description: Initializes the UDP and TCP sockets necessary for communication.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::Initialize(void)
{
	HRESULT		hr = S_OK;
	WSADATA		wsaData;

	
	// Init WinSock.  First look for version 2.2, but fall back to version 1.1
	// if that's not available.
    hr = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (hr == WSAVERNOTSUPPORTED)
	{
		// There is a bug in winsock 1.1.  if you've called WSAStartup 1x in a
		// process, then if any subsequent call asks for a version # > then that
		// returned to the first call, you get WSAEVERNOTSUPPORTED.  We'll just
		// revert to 1.1 functionality.
	    hr = WSAStartup(MAKEWORD(1, 1), &wsaData);
	} // end if (version not supported)
	if (hr != 0) 
	{
		DPL(0, "Could not start WinSock!", 0);
		return (hr);
	} // end if (error opening WinSock)

	this->m_fWinSockStarted = TRUE;

	if (this->m_fWinSock2)
	{
		if (LOBYTE(wsaData.wVersion) >= 2)
		{
			DPL(1, "Found WinSock version %i.%i, using WinSock 2 functionality.",
				2, LOBYTE(wsaData.wVersion), HIBYTE(wsaData.wVersion));

			hr = this->InitWinSock2();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't initialize WinSock 2!", 0);
				return (hr);
			} // end if (failed to init winsock2)
		} // end if (we have WinSock 2 functionality)
		else
		{
			DPL(1, "Found WinSock version %i.%i, not able to use WinSock 2 functionality.",
				2, LOBYTE(wsaData.wVersion), HIBYTE(wsaData.wVersion));
			this->m_fWinSock2 = FALSE;
		} // end if (we don't have WinSock 2 functionality)
	} // end if (can use WinSock 2 if we found it)
	else
	{
		DPL(1, "Found WinSock version %i.%i; forcing to non-WinSock 2 functionality.",
			2, LOBYTE(wsaData.wVersion), HIBYTE(wsaData.wVersion));
	} // end else (we can't use WinSock 2, no matter what)


	// If we're in control method mode and we're a master we need a UDP socket that
	// can receive on a well known port.  If we're a slave we need any old UPD socket,
	// but it must be broadcast capable.

	if (this->m_fCtrlMethodMode)
	{
		if (this->m_fMaster)
			hr = this->CreateUDPSocket(CTRLCOMM_TCPIP_PORT, FALSE, NULL);
		else 
			hr = this->CreateUDPSocket(0, TRUE, NULL);

		if (hr != S_OK)
		{
			DPL(0, "Couldn't create appropriate UDP socket!", 0);
			return (hr);
		} // end if (couldn't create UDP socket)
	} // end if (in control method mode)


	// If we're in control method mode and we're the master, we need a listening
	// TCP socket.
	if ((this->m_fCtrlMethodMode) && (this->m_fMaster))
	{
		hr = this->CreateTCPListenSocket(CTRLCOMM_TCPIP_PORT, NULL);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't create appropriate TCP socket!", 0);
			return (hr);
		} // end if (couldn't create TCP socket)
	} // end if (in control method mode and master)


	hr = this->StartThreads();
	if (hr != S_OK)
	{
		DPL(0, "Failed to start threads!", 0);
		return (hr);
	} // end if (failed to start threads)

	return (S_OK);
} // CTNCtrlCommTCP::Initialize
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::Release()"
//==================================================================================
// CTNCtrlCommTCP::Release
//----------------------------------------------------------------------------------
//
// Description: Releases data associated with the WinSock TCP/IP control method.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::Release(void)
{
	HRESULT		hr;


	// Make sure everything is sent.
	hr = this->FlushSendQueue();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't flush the send queue!", 0);
		return (hr);
	} // end if (couldn't flush send queue)

	hr = this->KillThreads();
	if (hr != S_OK)
	{
		DPL(0, "Failed to kill threads!", 0);
		return (hr);
	} // end if (failed to kill threads)

	hr = this->m_socketlist.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "Failed to remove all linked sockets!", 0);
		return (hr);
	} // end if (removeall failed)

	if (this->m_fWinSockStarted)
	{
		DPL(1, "Cleaning up WinSock.", 0);
		WSACleanup();
		this->m_fWinSockStarted = FALSE;
	} // end if (WinSock was started)

	if (this->m_hWinSock2DLL)
	{
		if (! FreeLibrary(this->m_hWinSock2DLL))
		{
			hr = GetLastError();
			DPL(0, "Could not free WinSock 2 library!", 0);
		} // end if (free library failed)

		this->m_hWinSock2DLL = NULL;
	} // end if (we have the WinSock2 DLL loaded)

	if (this->m_hAllSocketsReceiveEvent != NULL)
	{
		CloseHandle(this->m_hAllSocketsReceiveEvent);
		this->m_hAllSocketsReceiveEvent = NULL;
	} // end if (have receive event)

	return (hr);
} // CTNCtrlCommTCP::Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::GetBroadcastAddress()"
//==================================================================================
// CTNCtrlCommTCP::GetBroadcastAddress
//----------------------------------------------------------------------------------
//
// Description: Returns the address data necessary to broadcast data.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required.
//
// Arguments:
//	PVOID pvModifierData		Additional data used to modify address, or NULL to
//								use defaults.
//	DWORD dwModifierDataSize	Size of additional data used to modify address.
//	PVOID pvAddress				Place to store the resulting address.
//	DWORD* pdwAddressSize		Pointer to hold the size of the buffer.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::GetBroadcastAddress(PVOID pvModifierData,
											DWORD dwModifierDataSize,
											PVOID pvAddress,
											DWORD* pdwAddressSize)
{
	HRESULT						hr = S_OK;
	SOCKADDR_IN*				pSocketAddress = (SOCKADDR_IN*) pvAddress;
	unsigned long*				pulIPaddr;

	
	if ((pvModifierData != NULL) && (dwModifierDataSize != sizeof (WORD)))
	{
		DPL(0, "Unexpected modifier data (size %u != %u)!",
			2, dwModifierDataSize, sizeof (WORD));
		return (ERROR_INVALID_PARAMETER);
	} // end if (unexpected modifier)

	(*pdwAddressSize) = sizeof (SOCKADDR_IN);

	if (pvAddress == NULL)
		return (S_OK);

	// Fill in address structure
	pSocketAddress->sin_family = AF_INET;
	if (pvModifierData == NULL)
	{
		pSocketAddress->sin_port = BYTEREVERSEWORD(CTRLCOMM_TCPIP_PORT);
	} // end if (no modifier data)
	else
	{
		pSocketAddress->sin_port = BYTEREVERSEWORD(*((WORD*) pvModifierData));
	} // end else (modifier data)

	pulIPaddr = (unsigned long*) (&pSocketAddress->sin_addr.S_un);
	(*pulIPaddr) = INADDR_BROADCAST;

	return (S_OK);
} // CTNCtrlCommTCP::GetBroadcastAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::ConvertStringToAddress()"
//==================================================================================
// CTNCtrlCommTCP::ConvertStringToAddress
//----------------------------------------------------------------------------------
//
// Description: Returns the usable address information the specified string
//				corresponds to.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required.
//
// Arguments:
//	char* szString				String to convert.
//	PVOID pvModifierData		Additional data used to modify address, or NULL to
//								use defaults.
//	DWORD dwModifierDataSize	Size of additional data used to modify address.
//	PVOID pvAddress				Place to store the resulting address.
//	DWORD* pdwAddressSize		Pointer to hold the size of the buffer.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::ConvertStringToAddress(char* szString,
												PVOID pvModifierData,
												DWORD dwModifierDataSize,
												PVOID pvAddress,
												DWORD* pdwAddressSize)
{
	HRESULT				hr;
	SOCKADDR_IN*		pSocketAddress = (SOCKADDR_IN*) pvAddress;
	unsigned long*		pulIPaddr;
	PHOSTENT			phostent = NULL;
	int					i;
	IN_ADDR				hostaddr;

	
	if (szString == NULL)
	{
		DPL(0, "String to convert is not valid!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (string is invalid)

	if ((pvModifierData != NULL) && (dwModifierDataSize != sizeof (WORD)))
	{
		DPL(0, "Unexpected modifier data (size %u != %u)!",
			2, dwModifierDataSize, sizeof (WORD));
		return (ERROR_INVALID_PARAMETER);
	} // end if (unexpected modifier)

	(*pdwAddressSize) = sizeof (SOCKADDR_IN);

	if (pvAddress == NULL)
		return (S_OK);


	// Fill in address structure

	pSocketAddress->sin_family = AF_INET;
	if (pvModifierData == NULL)
	{
		pSocketAddress->sin_port = BYTEREVERSEWORD(CTRLCOMM_TCPIP_PORT);
	} // end if (no modifier data)
	else
	{
		pSocketAddress->sin_port = BYTEREVERSEWORD(*((WORD*) pvModifierData));
	} // end else (modifier data)

	pulIPaddr = (unsigned long*) (&(pSocketAddress->sin_addr.S_un));

	// This next call looks up the IP address for the string specified
	(*pulIPaddr) = inet_addr(szString);

	if ((*pulIPaddr) == INADDR_NONE)
	{
		phostent = gethostbyname(szString);
		if (phostent == NULL)
		{
			hr = WSAGetLastError();
			DPL(0, "Couldn't convert \"%s\" to IP address!",
				1, szString);

			return (hr);
		} // end if (couldn't convert the string any way)

		// BUGBUG there may be multiple ways to reach a dude, we should handle that 

		i = 0;
		while (phostent->h_addr_list[i] != NULL)
			i++;

		if (i < 1)
		{
			DPL(0, "Couldn't find any valid IP addresses for \"%s\"!",
				1, szString);
			return (E_FAIL);
		} // end if (didn't get any valid addresses)

		if (i > 1)
		{
			DPL(0, "WARNING: \"%s\" has multiple (%i) IP addresses!  Using first one.",
				2, szString, i);
			//return (E_FAIL);
		} // end if (didn't get any valid addresses)

		CopyMemory(&hostaddr, phostent->h_addr_list[0], sizeof (IN_ADDR));
		(*pulIPaddr) = hostaddr.S_un.S_addr;
	} // end if (we couldn't convert it that way)


	return (S_OK);
} // CTNCtrlCommTCP::ConvertStringToAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::GetSelfAddressAsString()"
//==================================================================================
// CTNCtrlCommTCP::GetSelfAddressAsString
//----------------------------------------------------------------------------------
//
// Description: Returns the string representation of this machine's address.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the string size is still set to the amount of memory
//				required, including NULL termination.
//
// Arguments:
//	char* pszString			Pointer to buffer to store results in.
//	DWORD* pdwAddressSize	Pointer to hold the size of the buffer.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::GetSelfAddressAsString(char* pszString,
												DWORD* pdwStringSize)
{
	HRESULT			hr;
	char			szTemp[MAX_COMPUTERNAME_SIZE];
	DWORD			dwTemp = MAX_COMPUTERNAME_SIZE;
	PHOSTENT		phostent = NULL;
	int				i;
#ifdef _XBOX // Damn ANSI conversion
	WCHAR			szWideString[16];
#endif

	(*pdwStringSize) = 16;

	if (pszString == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

#ifndef _XBOX // GetComputerName not supported
	if (! GetComputerName(szTemp, &dwTemp))
	{
		hr = GetLastError();
		DPL(0, "Couldn't get this computer's name!", 0);
		return (hr);
	} // end if (couldn't get this computer's name)
#else // ! XBOX
	dwTemp = MAX_COMPUTERNAME_SIZE;
	gethostname(szTemp, dwTemp);
#endif // XBOX

	phostent = gethostbyname(szTemp);
	if (phostent == NULL)
	{
		hr = WSAGetLastError();
		DPL(0, "Couldn't convert our name \"%s\" to IP address!",
			1, szTemp);

		return (hr);
	} // end if (couldn't convert the string any way)

	// BUGBUG there may be multiple ways to reach a dude, we should handle that 

	i = 0;
	while (phostent->h_addr_list[i] != NULL)
		i++;

	if (i < 1)
	{
		DPL(0, "Couldn't find any valid IP addresses for ourselves (\"%s\")!",
			1, szTemp);
		return (E_FAIL);
	} // end if (didn't get any valid addresses)

	if (i > 1)
	{
		DPL(0, "WARNING: We (\"%s\") have multiple (%i) IP addresses!  Using first one.",
			2, szTemp, i);
		//return (E_FAIL);
	} // end if (didn't get any valid addresses)

#ifndef _XBOX // Damn ANSI conversion
	wsprintf(pszString, "%i.%i.%i.%i",
			((LPBYTE) ((IN_ADDR*) (phostent->h_addr_list[0])))[0],
			((LPBYTE) ((IN_ADDR*) (phostent->h_addr_list[0])))[1],
			((LPBYTE) ((IN_ADDR*) (phostent->h_addr_list[0])))[2],
			((LPBYTE) ((IN_ADDR*) (phostent->h_addr_list[0])))[3]);
#else // ! XBOX
	// Use swprintf and then convert the result ot ANSI
	swprintf(szWideString, L"%i.%i.%i.%i",
			((LPBYTE) ((IN_ADDR*) (phostent->h_addr_list[0])))[0],
			((LPBYTE) ((IN_ADDR*) (phostent->h_addr_list[0])))[1],
			((LPBYTE) ((IN_ADDR*) (phostent->h_addr_list[0])))[2],
			((LPBYTE) ((IN_ADDR*) (phostent->h_addr_list[0])))[3]);
	wcstombs(pszString, szWideString, wcslen(szWideString));
	pszString[wcslen(szWideString)] = 0;
#endif // XBOX

	return (S_OK);
} // CTNCtrlCommTCP::GetSelfAddressAsString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::BindDataToAddress()"
//==================================================================================
// CTNCtrlCommTCP::BindDataToAddress
//----------------------------------------------------------------------------------
//
// Description: Binds the machine data with the address, particularly the event,
//				so if a connection drops, we can inform the control layer object
//				using us.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::BindDataToAddress(PCOMMDATA pCommData)
{
	SOCKADDR_IN*	pSockAddr = NULL;
	PLINKEDSOCKET	pLSocket = NULL;


	pSockAddr = (SOCKADDR_IN*) pCommData->pvAddress;
	if (pCommData->dwAddressSize != sizeof (SOCKADDR_IN))
	{
		DPL(0, "Got passed unexpected address data!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (we got passed a wacky address)

	
#pragma TODO(vanceo, "Handle UDP case gracefully.")
	pLSocket = this->m_socketlist.GetLSocketByAddress(pSockAddr, TRUE);
	if (pLSocket == NULL)
	{
		DPL(0, "Couldn't find socket in list!", 0);
		return (E_FAIL);
	} // end if (couldn't find item in list)

	pLSocket->m_pCommData = pCommData;

	return (S_OK);
} // CTNCtrlCommTCP::BindDataToAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::UnbindDataFromAddress()"
//==================================================================================
// CTNCtrlCommTCP::UnbindDataFromAddress
//----------------------------------------------------------------------------------
//
// Description: Unbinds the machine data from the address.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::UnbindDataFromAddress(PCOMMDATA pCommData)
{
	HRESULT			hr;
	SOCKADDR_IN*	pSockAddr = NULL;
	PLINKEDSOCKET	pLSocket = NULL;


	
	if (pCommData->dwAddressSize != sizeof (SOCKADDR_IN))
	{
		DPL(0, "Got passed unexpected address data!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (we got passed a wacky address)

	pSockAddr = (SOCKADDR_IN*) pCommData->pvAddress;


	this->m_socketlist.EnterCritSection();

	// Assume its TCP...
	pLSocket = this->m_socketlist.GetLSocketByAddress(pSockAddr, TRUE);
	if (pLSocket == NULL)
	{
		// If it's not TCP, see if it's UDP.
		pLSocket = this->m_socketlist.GetLSocketByAddress(pSockAddr, FALSE);
		if (pLSocket == NULL)
		{
			DPL(0, "Couldn't find socket in list!", 0);
			this->m_socketlist.LeaveCritSection();
			return (E_FAIL);
		} // end if (couldn't find UDP socket in list)

		DPL(2, "No need to unbind UDP sockets (leaving %o alone).",
			1, pLSocket->GetAddress());

		this->m_socketlist.LeaveCritSection();
		return (S_OK);
	} // end if (couldn't find TCP socket in list)

	// If there's no data bound to this socket yet, it means the user just wants
	// to disconnect.  Don't print the warning in that case.  Otherwise, note if
	// somehow the bound data doesn't match what the user passed in.
	if ((pLSocket->m_pCommData != NULL) &&
		(pLSocket->m_pCommData != pCommData))
	{
		DPL(0, "WARNING: Unbinding different data (%x != %x)!",
			2, pLSocket->m_pCommData, pCommData);
	} // end if (the socket was bound but data wasn't right)

	// The user wants to shut the connection down.
	hr = pLSocket->CloseSocket();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't close the socket!", 0);
		this->m_socketlist.LeaveCritSection();
		return (hr);
	} // end if (failed closing the socket)

	// Pull it off the list
	hr = this->m_socketlist.RemoveFirstReference(pLSocket);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove socket from list!", 0);
		this->m_socketlist.LeaveCritSection();
		return (E_FAIL);;
	} // end if (couldn't find socket in list)

	if (pLSocket->m_dwRefCount != 0)
	{
		DPL(0, "WARNING: Still an outstanding reference to linked socket %x!",
			1, pLSocket);
	} // end if (not last reference to object)
	else
	{
		delete (pLSocket);
		pLSocket = NULL;
	} // end else (that was the last reference)

	if (this->m_fWinSock2)
	{
		if (! SetEvent(this->m_socketlist.m_hListChangedEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set socket list changed event (%x)!",
				1, this->m_socketlist.m_hListChangedEvent);
		} // end if (couldn't notify thread that the list changed)
	} // end if (we're using WinSock2)

	this->m_socketlist.LeaveCritSection();

	// Just to make sure we know he's gone.
	pCommData->fDropped = TRUE;

	return (hr);
} // CTNCtrlCommTCP::UnbindDataFromAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::FlushSendQueue()"
//==================================================================================
// CTNCtrlCommTCP::FlushSendQueue
//----------------------------------------------------------------------------------
//
// Description: Waits for all outgoing data to be sent.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::FlushSendQueue(void)
{
	HRESULT		hr;
	int			i = 0;


	DPL(9, "==>", 0);

#pragma BUGBUG(vanceo, "Improve this whole function (dumping destroys reliability)")

	// Give the send queue some time to empty.
	while (this->m_sendqueue.Count() > 0)
	{
		i++;
		if (i > 20) // 10 seconds total
		{
			DPL(0, "Aborting flush, 10 seconds reached, %i items in queue.",
				1, this->m_sendqueue.Count());
			break;
		} // end if (waited maximum amount)

		Sleep(500); // sleep for half a second
	} // end while (the send queue isn't empty)


	// If there's still some items left, dump them.
	hr = this->m_sendqueue.RemoveAll();


	// HACKHACK: This extra sleep hopefully allows the send thread to get the
	//			 current message its sending (if there were one) out the door.
	//			 It's not on the queue, so the above while won't cover this.
	Sleep(500);


	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNCtrlCommTCP::FlushSendQueue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::StartAcceptingReachCheck()"
//==================================================================================
// CTNCtrlCommTCP::StartAcceptingReachCheck
//----------------------------------------------------------------------------------
//
// Description: Starts allowing incoming IP/NAT detection data for the given reach
//				check object.
//
// Arguments:
//	PTNREACHCHECK pReachCheck	Reach check being performed.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::StartAcceptingReachCheck(PTNREACHCHECK pReachCheck)
{
	HRESULT			hr = S_OK;
	SOCKADDR_IN		sockaddrin;
	unsigned long*	pulIPaddr = NULL;
	PLINKEDSOCKET	pLSocket = NULL;
	BOOL			fAddedToList = FALSE;
	BOOL			fInCritSect = FALSE;


	DPL(9, "==> (%x)", 1, pReachCheck);


	// The method data is a port, so make sure that's actually what we got.
	if (pReachCheck->m_dwMethodDataSize != sizeof (WORD))
	{
		DPL(0, "Reach check method data is not expected size (%u != %u)!",
			2, pReachCheck->m_dwMethodDataSize, sizeof (WORD));
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (data is wrong)

	// Make sure we're not being called to accept for a method we don't support.
	if ((pReachCheck->m_dwMethod != TNRCM_UDPBROADCAST) &&
		(pReachCheck->m_dwMethod != TNRCM_UDP) &&
		(pReachCheck->m_dwMethod != TNRCM_TCP))
	{
		DPL(0, "This control comm object doesn't support reach check method %u!",
			1, pReachCheck->m_dwMethod);
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (wrong method)


	// Add this item (or an alias to it actually) to our internal list.
	hr = this->m_reachchecks.Add(pReachCheck);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add alias to reach check to list!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't add alias)

	fAddedToList = TRUE;


	ZeroMemory(&sockaddrin, sizeof (SOCKADDR_IN));
	sockaddrin.sin_family = AF_INET;
	pulIPaddr = (unsigned long*) (&(sockaddrin.sin_addr.S_un));
	(*pulIPaddr) = INADDR_ANY;
	sockaddrin.sin_port = BYTEREVERSEWORD(*((WORD*) pReachCheck->m_pvMethodData));


	DPL(1, "Trying to use %s sockets on port %u.",
		2, ((pReachCheck->m_dwMethod == TNRCM_TCP) ? "TCP" : "UDP"),
		*((WORD*) pReachCheck->m_pvMethodData));


	this->m_socketlist.EnterCritSection();
	fInCritSect = TRUE;

	
	// Find or add an appropriate socket on the given port.
	if (pReachCheck->m_dwMethod == TNRCM_TCP)
	{
		pLSocket = this->m_socketlist.GetLSocketByAddress(&sockaddrin, TRUE);
		if (pLSocket == NULL)
		{
			DPL(1, "Couldn't find TCP socket on port %u, will try to create one.",
				1, *((WORD*) pReachCheck->m_pvMethodData));
				
			hr = this->CreateTCPListenSocket(*((WORD*) pReachCheck->m_pvMethodData),
											&pLSocket);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't create TCP listen socket on port %u!",
					1, *((WORD*) pReachCheck->m_pvMethodData));
				goto ERROR_EXIT;
			} // end if (couldn't create TCP socket)
		} // end if (didn't find a TCP socket already)
		else
		{
			pLSocket->m_dwFoundPriorToReachCheck++;
		} // end else (found TCP socket)
	} // end if (TCP reach check)
	else
	{
		pLSocket = this->m_socketlist.GetLSocketByAddress(&sockaddrin, FALSE);
		if (pLSocket == NULL)
		{
			DPL(1, "Couldn't find UDP socket on port %u, will try to create one.",
				1, *((WORD*) pReachCheck->m_pvMethodData));
				
			//BUGBUG maybe allow using port 0, if so retrieve the port actually used
			hr = this->CreateUDPSocket(*((WORD*) pReachCheck->m_pvMethodData), FALSE,
										&pLSocket);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't create UDP socket on port %u!",
					1, *((WORD*) pReachCheck->m_pvMethodData));
				goto ERROR_EXIT;
			} // end if (couldn't create UDP socket)
		} // end if (didn't find a UDP socket already)
		else
		{
			pLSocket->m_dwFoundPriorToReachCheck++;
		} // end else (found UDP socket)
	} // end else (UDP or UDP broadcast reach check)


	// Add a ref for the object, and attach it to the reach check.
	pLSocket->m_dwRefCount++;
	pReachCheck->m_pvCommData = pLSocket;


	fInCritSect = FALSE;
	this->m_socketlist.LeaveCritSection();


	DPL(9, "<== S_OK", 0);

	return (S_OK);


ERROR_EXIT:

	if (fAddedToList)
	{
		// Ignoring error
		this->m_reachchecks.RemoveFirstReference(pReachCheck);
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(0, "WARNING: Deleting search %x because reference count is 0!?",
				1, pReachCheck);

			DEBUGBREAK();

			delete (pReachCheck);
			pReachCheck = NULL;
		} // end if (should delete search now)

		fAddedToList = FALSE;
	} // end if (added search to list)

	if (fInCritSect)
	{
		this->m_socketlist.LeaveCritSection();
		fInCritSect = FALSE;
	} // end if (in critical section)


	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNCtrlCommTCP::StartAcceptingReachCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::StopAcceptingReachCheck()"
//==================================================================================
// CTNCtrlCommTCP::StopAcceptingReachCheck
//----------------------------------------------------------------------------------
//
// Description: Stops allowing incoming IP/NAT detection data for the given
//				reach check object.
//
// Arguments:
//	PTNREACHCHECK pReachCheck	Reach check being performed.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::StopAcceptingReachCheck(PTNREACHCHECK pReachCheck)
{
	HRESULT		hr;


	DPL(9, "==> (%x)", 1, pReachCheck);

	hr = this->InternalCloseReachCheck(pReachCheck);

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNCtrlCommTCP::StopAcceptingReachCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::PrepareToReachCheck()"
//==================================================================================
// CTNCtrlCommTCP::PrepareToReachCheck
//----------------------------------------------------------------------------------
//
// Description: Prepares necessary items to allow sending IP/NAT detection data for
//				the given reach check object.
//
// Arguments:
//	PTNREACHCHECK pReachCheck	Reach check being performed.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::PrepareToReachCheck(PTNREACHCHECK pReachCheck)
{
	HRESULT			hr = S_OK;
	SOCKADDR_IN		sockaddrin;
	unsigned long*	pulIPaddr = NULL;
	PLINKEDSOCKET	pLSocket = NULL;
	BOOL			fAddedToList = FALSE;
	BOOL			fInCritSect = FALSE;


	DPL(9, "==> (%x)", 1, pReachCheck);


	// The method data is a port, so make sure that's actually what we got.
	if (pReachCheck->m_dwMethodDataSize != sizeof (WORD))
	{
		DPL(0, "Reach check method data is not expected size (%u != %u)!",
			2, pReachCheck->m_dwMethodDataSize, sizeof (WORD));
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (data is wrong)

	// Make sure we're not being called to accept for a method we don't support.
	if ((pReachCheck->m_dwMethod != TNRCM_UDPBROADCAST) &&
		(pReachCheck->m_dwMethod != TNRCM_UDP) &&
		(pReachCheck->m_dwMethod != TNRCM_TCP))
	{
		DPL(0, "This control comm object doesn't support reach check method %u!",
			1, pReachCheck->m_dwMethod);
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (wrong method)


	// Add this item (or an alias to it actually) to our internal list.
	hr = this->m_reachchecks.Add(pReachCheck);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add alias to reach check to list!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't add alias)

	fAddedToList = TRUE;


	ZeroMemory(&sockaddrin, sizeof (SOCKADDR_IN));
	sockaddrin.sin_family = AF_INET;
	pulIPaddr = (unsigned long*) (&(sockaddrin.sin_addr.S_un));
	(*pulIPaddr) = INADDR_ANY;
	sockaddrin.sin_port = BYTEREVERSEWORD(*((WORD*) pReachCheck->m_pvMethodData));


	DPL(1, "Trying to use %s sockets on port %u.",
		2, ((pReachCheck->m_dwMethod == TNRCM_TCP) ? "TCP" : "UDP"),
		*((WORD*) pReachCheck->m_pvMethodData));


	this->m_socketlist.EnterCritSection();
	fInCritSect = TRUE;


	// Find or add an appropriate socket, UDP only.  TCP will make the various
	// connections on the fly.  We don't need to remember the sockets we used,
	// because as long as the other side shuts the connections down when they're
	// done with it, our side will notice that (and the fact that the socket
	// isn't being used by anybody anymore) and remove it from our list, too.
	// UDP has to have a socket to receive on as well as send to using the
	// specified port, so we make sure we have one capable of doing that.
	if (pReachCheck->m_dwMethod != TNRCM_TCP)
	{
		// Make sure there's a UDP socket that's using that port.  We'll use
		// it both for sending and for listening for replies.
		pLSocket = this->m_socketlist.GetLSocketByAddress(&sockaddrin,
														FALSE);
		if (pLSocket == NULL)
		{
			hr = this->CreateUDPSocket(*((WORD*) pReachCheck->m_pvMethodData),
										((pReachCheck->m_dwMethod == TNRCM_UDPBROADCAST) ? TRUE : FALSE),
										&pLSocket);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't create UDP socket on port %u!",
					1, *((WORD*) pReachCheck->m_pvMethodData));
				goto ERROR_EXIT;
			} // end if (couldn't create UDP socket)
		} // end if (didn't find a UDP socket already)
		else
		{
			// If it's the UDP broadcast method but this socket isn't capable
			// of broadcasting, change it.
			if ((pReachCheck->m_dwMethod == TNRCM_UDPBROADCAST) &&
				(! pLSocket->IsUDPBroadcast()))
			{
				BOOL	fTemp;
				

				if (setsockopt(*(pLSocket->GetSocket()), SOL_SOCKET, SO_BROADCAST, (char*) &fTemp, sizeof (BOOL)) != 0)
				{
					hr = WSAGetLastError();
					DPL(0, "Failed to set datagram socket (port %u) as broadcast capable!",
						1, *((WORD*) pReachCheck->m_pvMethodData));
					goto ERROR_EXIT;
				} // end if (failed to set datagram socket options)
			} // end if (it's not broadcast capable)

			pLSocket->m_dwFoundPriorToReachCheck++;
		} // end else (found UDP socket)


		// Add a ref for the object, and attach it to the reach check.
		pLSocket->m_dwRefCount++;
		pReachCheck->m_pvCommData = pLSocket;
	} // end if (not TCP reach check method)


	fInCritSect = FALSE;
	this->m_socketlist.LeaveCritSection();


	DPL(9, "<== S_OK", 0);

	return (S_OK);


ERROR_EXIT:

	if (fAddedToList)
	{
		// Ignoring error
		this->m_reachchecks.RemoveFirstReference(pReachCheck);
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(0, "WARNING: Deleting search %x because reference count is 0!?",
				1, pReachCheck);

			DEBUGBREAK();

			delete (pReachCheck);
			pReachCheck = NULL;
		} // end if (should delete search now)

		fAddedToList = FALSE;
	} // end if (added search to list)

	if (fInCritSect)
	{
		this->m_socketlist.LeaveCritSection();
		fInCritSect = FALSE;
	} // end if (in critical section)


	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNCtrlCommTCP::PrepareToReachCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::CleanupReachCheck()"
//==================================================================================
// CTNCtrlCommTCP::CleanupReachCheck
//----------------------------------------------------------------------------------
//
// Description: Stops trying to send IP/NAT detection data for the given reach check
//				object.
//
// Arguments:
//	PTNREACHCHECK pReachCheck	Reach check being performed.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::CleanupReachCheck(PTNREACHCHECK pReachCheck)
{
	HRESULT		hr;


	DPL(9, "==> (%x)", 1, pReachCheck);

	hr = this->InternalCloseReachCheck(pReachCheck);

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNCtrlCommTCP::CleanupReachCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::SendFirstData()"
//==================================================================================
// CTNCtrlCommTCP::SendFirstData
//----------------------------------------------------------------------------------
//
// Description: Sends the first item in the send queue via UDP or TCP, depending on
//				the reliability setting.
//				NOTE: The sendqueue lock must be held with 1 and only 1 level of
//				recursion upon entering this function.  
//
// Arguments: None.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::SendFirstData(void)
{
	HRESULT			hr = S_OK;
	PTNSENDDATA		pSendData = NULL;


	// Pop the first item off the list
	pSendData = (PTNSENDDATA) this->m_sendqueue.PopFirstItem();
	if (pSendData == NULL)
	{
		DPL(0, "Failed to pop first item in queue!", 0);
		return (E_FAIL);
	} // end if (failed to get first item)

	// Drop lock now that we pulled the send off the queue
	this->m_sendqueue.LeaveCritSection();

	/*
	DPL(0, "Sending %i bytes of data at %x to %o", 3, pSendData->dwDataSize,
		pSendData->lpData, pSendData->m_pvAddress);
	*/

	if (! pSendData->m_fGuaranteed)
	{
		hr = this->SendUDPDataTo((SOCKADDR_IN*) (pSendData->m_pvAddress),
								pSendData->m_pvData, pSendData->m_dwDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Failed to send UDP data to %o!  %e  Ignoring.",
				2, hr, pSendData->m_pvAddress);
			hr = S_OK;
		} // end if (failed to send UDP message)
	} // end if (we don't have to send it guaranteed)
	else
	{
		hr = this->SendTCPDataTo((SOCKADDR_IN*) (pSendData->m_pvAddress),
								pSendData->m_pvData, pSendData->m_dwDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Failed to send TCP data to %o, removing all items still queued up for him!",
				1, pSendData->m_pvAddress);

			// Ignore error
			this->m_sendqueue.RemoveAllItemsTo(pSendData->m_pvAddress,
												pSendData->m_dwDataSize);
		} // end if (failed to send TCP message)
	} // end else (we need to send it guaranteed)

	if (hr != S_OK)
	{
		DPL(0, "Failed sending %u bytes of %seliable data to %o submitted by %X!  %e",
			5, pSendData->m_dwDataSize,
			(pSendData->m_fGuaranteed ? "r" : "unr"),
			(SOCKADDR_IN*) (pSendData->m_pvAddress),
			pSendData->m_pvSubmittersAddress,
			hr);
	} // end if (there was a failure)

	pSendData->m_dwRefCount--; // subtract our refcount
	if (pSendData->m_dwRefCount == 0)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (last reference to object)
	else
	{
		DPL(0, "WARNING: Still %u outstanding references to send data object %x!?",
			2, pSendData->m_dwRefCount, pSendData);
	} // end else (not last reference to object)


	// Take the lock again to return us to the state we were in when we entered.
	this->m_sendqueue.EnterCritSection();

	return (hr);
} // CTNCtrlCommTCP::SendFirstData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::CheckForReceiveData()"
//==================================================================================
// CTNCtrlCommTCP::CheckForReceiveData
//----------------------------------------------------------------------------------
//
// Description: Instantly checks for data on the receive socket and puts it into
//				the control message queue & sets the receive event if there is.
//
// Arguments: None.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::CheckForReceiveData(void)
{
	HRESULT			hr = S_OK;
	int				i;
	PLINKEDSOCKET	pLSocket = NULL;



	this->m_socketlist.EnterCritSection();
	for(i = 0; i < this->m_socketlist.Count(); i++)
	{
		pLSocket = (PLINKEDSOCKET) this->m_socketlist.GetItem(i);
		if (pLSocket == NULL)
		{
			DPL(0, "Failed to get socket %i in list!", 1, i);
			this->m_socketlist.LeaveCritSection();
			return (E_FAIL);
		} // end if (couldn't get item)

		if (*(pLSocket->GetSocket()) == INVALID_SOCKET)
		{
			DPL(0, "Skipping socket %i because it has been shutdown.", 1, i);
		} // end if (the socket is gone)
		else
		{
			// Note that this may drop the socket list lock.  That should be
			// okay, but at worst we might skip checking some sockets this
			// time around (only would happen if sockets got inserted before
			// this item, which should never happen since we always append
			// at the end of the list).
			hr = this->CheckAndHandleEventOnSocket(pLSocket);
			if (hr != S_OK)
			{
				DPL(0, "Failed to check for data or shutdown on socket %i!", 1, i);
				this->m_socketlist.LeaveCritSection();
				return (hr);
			} // end if (failed to check for socket event)
		} // end else (it's a valid socket)
	} // end for (each socket in the list)
	this->m_socketlist.LeaveCritSection();

	return (S_OK);
} // CTNCtrlCommTCP::CheckForReceiveData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::InitWinSock2()"
//==================================================================================
// CTNCtrlCommTCP::InitWinSock2
//----------------------------------------------------------------------------------
//
// Description: Attempts to load and initialize the WinSock2 DLL.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::InitWinSock2(void)
{
	HRESULT		hr;


#ifndef _XBOX // Damn ANSI conversoin
	this->m_hWinSock2DLL = LoadLibrary("ws2_32.dll");
#else // ! XBOX
	this->m_hWinSock2DLL = LoadLibrary(L"ws2_32.dll");
#endif // XBOX
	if (! this->m_hWinSock2DLL) 
	{
		hr = GetLastError();
		DPL(0, "Could not load ws2_32.dll!", 0);
		goto ERROR_EXIT;
	} // end if (we couldn't load the WinSock2 DLL)

	// Get pointers to the entry points we need

	this->m_lpfnWSAEventSelect = (LPFN_WSAEVENTSELECT) GetProcAddress(this->m_hWinSock2DLL,
																"WSAEventSelect");
	if (! this->m_lpfnWSAEventSelect)
	{
		hr = GetLastError();
		DPL(0, "Could not find WinSock entry point \"WSAEventSelect\"!", 0);
		goto ERROR_EXIT;
	} // end if (we couldn't load the WinSock2 DLL)

	this->m_lpfnWSAWaitForMultipleEvents = (LPFN_WSAWAITFORMULTIPLEEVENTS)
											GetProcAddress(this->m_hWinSock2DLL,
															"WSAWaitForMultipleEvents");
	if(! this->m_lpfnWSAWaitForMultipleEvents)
	{
		hr = GetLastError();
		DPL(0, "Could not find WinSock entry point \"WSAWaitForMultipleEvents\"!", 0);
		goto ERROR_EXIT;
	} // end if (we couldn't load the WinSock2 DLL)

	this->m_lpfnWSAResetEvent = (LPFN_WSARESETEVENT) GetProcAddress(this->m_hWinSock2DLL,
																"WSAResetEvent");
	if (! this->m_lpfnWSAResetEvent)
	{
		hr = GetLastError();
		DPL(0, "Could not find WinSock entry point \"WSAResetEvent\"!", 0);
		goto ERROR_EXIT;
	} // end if (we couldn't load the WinSock2 DLL)

	// Override the WinSock 1 receive thread proc we specified.
	if (this->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK2_ONETOONE)
	{
		DPL(0, "WARNING: Using one-to-one mapping of sockets and events, connections can be starved!", 0);

		this->m_lpReceiveThreadProc = WS2OneToOneReceiveThreadProc;
	} // end if (should use one to one event/socket mapping)
	else
	{
		this->m_lpReceiveThreadProc = WS2ReceiveThreadProc;

		this->m_hAllSocketsReceiveEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (this->m_hAllSocketsReceiveEvent == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create generic receive event!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't create event)
	} // end else (shouldn't use one to one event/socket mapping)

	return (S_OK);	


ERROR_EXIT:

	if (this->m_hWinSock2DLL != NULL)
	{
		FreeLibrary(this->m_hWinSock2DLL);
		this->m_hWinSock2DLL = NULL;
	} // end if (have WinSock2 DLL)

	return (hr);
} // CTNCtrlCommTCP::InitWinSock2
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::CreateUDPSocket()"
//==================================================================================
// CTNCtrlCommTCP::CreateUDPSocket
//----------------------------------------------------------------------------------
//
// Description: Creates a new UDP socket with the passed in port.
//
// Arguments:
//	WORD wPort					Port to bind UDP socket to (0 for random/doesn't
//								matter).
//	BOOL fBroadcast				Whether to allow broadcasts on the socket or not.
//	PLINKEDSOCKET* ppLSocket	Place to store pointer to socket created, or NULL
//								if not wanted.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::CreateUDPSocket(WORD wPort, BOOL fBroadcast,
										PLINKEDSOCKET* ppLSocket)
{
	HRESULT			hr;
	SOCKET			sUDP = INVALID_SOCKET;
	SOCKADDR_IN		addr;
	unsigned long*	lpulIPaddr;
	HANDLE			hWinSock2Event = NULL;
	BOOL			fTemp = TRUE;			


	sUDP = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sUDP == INVALID_SOCKET)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to create a datagram socket!", 0);
		return (hr);
	} // end if (failed to create a datagram socket)


	ZeroMemory(&addr, sizeof (SOCKADDR_IN));

	addr.sin_family = AF_INET;
	lpulIPaddr = (unsigned long*) (&addr.sin_addr.S_un);
	(*lpulIPaddr) = INADDR_ANY;
	addr.sin_port = BYTEREVERSEWORD(wPort);

	if (bind(sUDP, (SOCKADDR*) (&addr), sizeof (SOCKADDR_IN)) != 0)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to bind datagram socket on port %u!",
			1, wPort);
		return (hr);
	} // end if (failed to bind datagram socket)


	// If the port wasn't specified, retrieve what actually got bound.
	if (wPort == 0)
	{
		int		iSize;


		ZeroMemory(&addr, sizeof (SOCKADDR_IN));

		iSize = sizeof (SOCKADDR_IN);
		if (getsockname(sUDP, (SOCKADDR*) &addr, &iSize) != 0)
		{
			hr = WSAGetLastError();

			DPL(0, "Couldn't get information on just bound datagram socket!", 0);

			if (hr == S_OK)
				hr = E_FAIL;

			return (hr);
		} // end if (couldn't get information on bound socket)

		DPL(8, "Binding datagram socket to unspecified port got assigned as %o.",
			1, &addr);
	} // end if (got a zero port)


	if (fBroadcast)
	{
		if (setsockopt(sUDP, SOL_SOCKET, SO_BROADCAST, (char*) &fTemp, sizeof (BOOL)) != 0)
		{
			hr = WSAGetLastError();
			DPL(0, "Failed to set datagram socket options on port %u!",
				1, wPort);
			return (hr);
		} // end if (failed to set datagram socket options)
	} // end if (broadcasts are allowed on the socket)


	// If we're using WinSock 2, associate an event with this socket
	if (this->m_fWinSock2)
	{
		if (this->m_hAllSocketsReceiveEvent != NULL)
		{
			hWinSock2Event = this->m_hAllSocketsReceiveEvent;
		} // end if (there's a generic receive event)
		else
		{
			hWinSock2Event = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (hWinSock2Event == NULL)
			{
				hr = GetLastError();
				DPL(0, "Couldn't create socket event!", 0);
				return (hr);
			} // end if (couldn't create event)
		} // end else (there's no generic receive event)

		hr = this->m_lpfnWSAEventSelect(sUDP, hWinSock2Event, FD_READ);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't associate receive event with datagram socket on port %u!",
				1, wPort);
			return (hr);
		} // end if (WSAEventSelect failed)
	} // end if (we're using WinSock2 functionality)

	hr = this->m_socketlist.AddSocket(sUDP, addr, FALSE, FALSE, fBroadcast,
									hWinSock2Event, ppLSocket);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add new UDP socket to list!", 0);
	} // end if (couldn't add socket)

	return (hr);
} // CTNCtrlCommTCP::CreateUDPSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::CreateTCPListenSocket()"
//==================================================================================
// CTNCtrlCommTCP::CreateTCPListenSocket
//----------------------------------------------------------------------------------
//
// Description: Creates a new TCP listen socket with the passed in port.
//
// Arguments:
//	WORD wPort					Port to bind TCP socket to.
//	PLINKEDSOCKET* ppLSocket	Place to store pointer to socket created, or NULL
//								if not wanted.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::CreateTCPListenSocket(WORD wPort, PLINKEDSOCKET* ppLSocket)
{
	HRESULT			hr;
	SOCKET			sTCP = INVALID_SOCKET;
	SOCKADDR_IN		addr;
	unsigned long*	lpulIPaddr;
	HANDLE			hWinSock2Event = NULL;


	sTCP = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sTCP == INVALID_SOCKET)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to create a stream socket!", 0);
		return (hr);
	} // end if (failed to create a stream socket)


	ZeroMemory(&addr, sizeof (SOCKADDR_IN));

	addr.sin_family = AF_INET;
	lpulIPaddr = (unsigned long*) (&addr.sin_addr.S_un);
	(*lpulIPaddr) = INADDR_ANY;
	addr.sin_port = BYTEREVERSEWORD(wPort);

	if (bind(sTCP, (SOCKADDR*) (&addr), sizeof (SOCKADDR_IN)) != 0)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to bind stream socket to port %u!",
			1, wPort);
		return (hr);
	} // end if (failed to bind stream socket)

	if (listen(sTCP, SOMAXCONN) != 0)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to start inbound stream socket listening on port %u!",
			1, wPort);
		return (hr);
	} // end if (failed to listen inbound stream socket)


	// If we're using WinSock 2, associate an event with this socket
	if (this->m_fWinSock2)
	{
		if (this->m_hAllSocketsReceiveEvent != NULL)
		{
			hWinSock2Event = this->m_hAllSocketsReceiveEvent;
		} // end if (there's a generic receive event)
		else
		{
			hWinSock2Event = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (hWinSock2Event == NULL)
			{
				hr = GetLastError();
				DPL(0, "Couldn't create socket event!", 0);
				return (hr);
			} // end if (couldn't create event)
		} // end else (there's no generic receive event)

		hr = this->m_lpfnWSAEventSelect(sTCP, hWinSock2Event, FD_ACCEPT | FD_READ);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't associate receive event with TCP listen socket on port %u!",
				1, wPort);
			return (hr);
		} // end if (WSAEventSelect failed)
	} // end if (we're using WinSock2 functionality)

	hr = this->m_socketlist.AddSocket(sTCP, addr, TRUE, TRUE, FALSE, hWinSock2Event,
									ppLSocket);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add new TCP listen socket to list!", 0);
	} // end if (couldn't add socket)

	return (hr);
} // CTNCtrlCommTCP::CreateTCPListenSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::CreateAndConnectTCPSocket()"
//==================================================================================
// CTNCtrlCommTCP::CreateAndConnectTCPSocket
//----------------------------------------------------------------------------------
//
// Description: Creates a new TCP socket and connects it to the passed in address.
//
// Arguments:
//	SOCKADDR_IN* pAddress		Address to establish connection to.
//	PLINKEDSOCKET* ppLSocket	Place to store pointer to socket created, or NULL
//								if not wanted.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::CreateAndConnectTCPSocket(SOCKADDR_IN* pAddress,
												PLINKEDSOCKET* ppLSocket)
{
	HRESULT			hr;
	SOCKET			sTCP = INVALID_SOCKET;
	SOCKADDR_IN		addr;
	unsigned long*	pulIPaddr = NULL;
	HANDLE			hWinSock2Event = NULL;

	
	sTCP = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sTCP == INVALID_SOCKET)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to create a TCP send socket!", 0);
		return (hr);
	} // end if (failed to get a TCP socket)


	ZeroMemory(&addr, sizeof (SOCKADDR_IN));
	addr.sin_family = AF_INET;
	pulIPaddr = (unsigned long*) (&addr.sin_addr.S_un);
	(*pulIPaddr) = INADDR_ANY;
	addr.sin_port = 0;

	if (bind(sTCP, (SOCKADDR*) (&addr), sizeof (SOCKADDR_IN)) != 0)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to bind TCP socket to %o!", 1, (&addr));
		return (hr);
	} // end if (failed to bind TCP socket)


	DPL(7, "Attempting to establish new TCP connection to %o.",
		1, pAddress);

	if (connect(sTCP, (SOCKADDR*) pAddress, sizeof (SOCKADDR_IN)) != 0)
	{
		hr = WSAGetLastError();
		DPL(0, "Failed to connect TCP socket to %o!", 1, pAddress);
		return (hr);
	} // end if (failed to connect TCP socket)

	if (this->m_fWinSock2)
	{
		if (this->m_hAllSocketsReceiveEvent != NULL)
		{
			hWinSock2Event = this->m_hAllSocketsReceiveEvent;
		} // end if (there's a generic receive event)
		else
		{
			hWinSock2Event = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (hWinSock2Event == NULL)
			{
				hr = GetLastError();
				DPL(0, "Couldn't create socket event!", 0);
				return (hr);
			} // end if (couldn't create event)
		} // end else (there's no generic receive event)

		hr = this->m_lpfnWSAEventSelect(sTCP, hWinSock2Event, FD_CLOSE | FD_READ);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't associate receive event with new TCP socket connected to %o!",
				1, pAddress);
			return (hr);
		} // end if (WSAEventSelect failed)
	} // end if (we're using WinSock2 functionality)

	hr = this->m_socketlist.AddSocket(sTCP, (*pAddress), TRUE, FALSE, FALSE,
										hWinSock2Event, ppLSocket);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add socket to list!", 0);
		return (hr);
	} // end if (failed to bind TCP socket)


#ifdef DEBUG
	{
		int		iSize;


		ZeroMemory(&addr, sizeof (SOCKADDR_IN));

		iSize = sizeof (SOCKADDR_IN);
		if (getsockname(sTCP, (SOCKADDR*) &addr, &iSize) != 0)
		{
			hr = WSAGetLastError();

			DPL(0, "Couldn't get information on just connected stream socket!", 0);

			if (hr == S_OK)
				hr = E_FAIL;

			return (hr);
		} // end if (couldn't get information on bound socket)

		DPL(8, "Successfully connected to %o using %o.",
			2, pAddress, &addr);
	} // end if (got a zero port)
#endif // DEBUG


	return (S_OK);
} // CTNCtrlCommTCP::CreateAndConnectTCPSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::CheckAndGetEventOnSocket()"
//==================================================================================
// CTNCtrlCommTCP::CheckAndGetEventOnSocket
//----------------------------------------------------------------------------------
//
// Description: Instantly checks (as opposed to blocking while waiting) for an event
//				on the passed linked socket.  If there is an event, it is handled.
//
// Arguments:
//	PLINKEDSOCKET pLSocket	Pointer to linked socket to check.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::CheckAndHandleEventOnSocket(PLINKEDSOCKET pLSocket)
{
	HRESULT		hr;
	FD_SET		readfds;
	TIMEVAL		timeout;


	FD_ZERO(&readfds);
	FD_SET(*(pLSocket->GetSocket()), &readfds);

	timeout.tv_sec = 0;
	timeout.tv_usec = 0;

	hr = select(NULL, &readfds, NULL, NULL, &timeout);
	if (hr == SOCKET_ERROR)
	{
		DPL(0, "Failed to check for event on socket!", 0);
		hr = WSAGetLastError();

#if 1 // ! BOUNDSCHECKER
		// If WinSock is not bothering to tell us what the problem is, say it's
		// generic
		if (hr == S_OK)
			hr = E_FAIL;
		return (hr);
#endif // ! BOUNDSCHECKER
	} // end if (failed to check for event on socket)

	if (hr == 0)
	{
		/*
		DPL(9, "No event for socket (%x, %o, %s).",
			3, *(pLSocket->GetSocket()), pLSocket->GetAddress(),
			(pLSocket->IsUDP() ? "UDP" : "TCP"));
		*/

		return (S_OK);
	} // end else (timed out)


	DPL(9, "Event on socket (%x, %o, %s)",
		3, *(pLSocket->GetSocket()), pLSocket->GetAddress(),
		(pLSocket->IsUDP() ? "UDP" : "TCP"));

	return (this->HandleEventOnSocket(pLSocket));
} // CTNCtrlCommTCP::CheckAndHandleEventOnSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::HandleEventOnSocket()"
//==================================================================================
// CTNCtrlCommTCP::HandleEventOnSocket
//----------------------------------------------------------------------------------
//
// Description: Handles an event on a socket.  If it's a TCP port that is listening,
//				it accepts the incoming connection.  Otherwise, the incoming data
//				is received and the control layer's handler is called.
//				IMPORTANT: The socket list lock is assumed to be held, but we will
//				drop it while calling the HandleMessage callback to prevent
//				deadlocks.  Callers must make sure this is okay.
//
// Arguments:
//	PLINKEDSOCKET pLSocket		Pointer to linked socket to handle.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::HandleEventOnSocket(PLINKEDSOCKET pLSocket)
{
	HRESULT						hr;
	PCTRLCOMM_TCP_DATAHEADER	pDataWithHeader = NULL;
	int							iReadDataIndicatedSize = 0;
	int							iReadDataBufferSize = 0;
	int							iReadDataActualSize = 0;
	SOCKADDR_IN*				pFromSockAddress = NULL;
	int							iFromSockAddressSize = sizeof (SOCKADDR_IN);

	DPL(9, "(%x)==>(%x)", 2, this, pLSocket);

	// If it's a special listen socket, assume it's a connection event
	if (pLSocket->IsTCPListen())
	{
		HANDLE	hWinSock2Event;


		hWinSock2Event = NULL;
		if (this->m_fWinSock2)
		{
			if (this->m_hAllSocketsReceiveEvent != NULL)
			{
				hWinSock2Event = this->m_hAllSocketsReceiveEvent;
			} // end if (there's a generic receive event)
			else
			{
				hWinSock2Event = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (hWinSock2Event == NULL)
				{
					hr = GetLastError();
					DPL(0, "Couldn't create socket event!", 0);
					goto DONE;
				} // end if (couldn't create event)
			} // end else (there's no generic receive event)
		} // end if (WinSock 2)

		hr = this->m_socketlist.AddNewConnectionFromSocket(pLSocket->GetSocket(),
														hWinSock2Event,
														this->m_lpfnWSAEventSelect,
														((this->m_hAllSocketsReceiveEvent == NULL) ? TRUE : FALSE),
														NULL);
		if (hr != S_OK)
		{
			// WinSock seems to be setting our events twice, so trying to handle
			// this again returns WSAEWOULDBLOCK.
			if (hr == WSAEWOULDBLOCK)
			{
				DPL(7, "WARNING: Connection appears to already have been accepted!  Continuing.", 0);
				hr = S_OK;
			} // end if (the event was already consumed)
			else
			{
				DPL(0, "AddNewConnectionFromSocket failed!", 0);

				// Get rid of the event we created, if any.
				if ((this->m_fWinSock2) &&
					(this->m_hAllSocketsReceiveEvent == NULL))
				{
					CloseHandle(hWinSock2Event);
					hWinSock2Event = NULL;
				} // end if (there's a generic receive event)
			} // end else (unexpected error)
		} // end if (AddNewConnectionFromSocket failed)

		goto DONE;
	} // end if (this is a TCP listening socket)


	// Build a buffer that we can use to peek at the data on the socket.  We
	// assume it starts with a header, which we use to determine how much
	// data is following.  This is a denial-of-service attack susceptible
	// method, but who's going to do that to a measly test app?

	iReadDataBufferSize = sizeof (CTRLCOMM_TCP_DATAHEADER);
	pDataWithHeader = (PCTRLCOMM_TCP_DATAHEADER) LocalAlloc(LPTR, iReadDataBufferSize);
	if (pDataWithHeader == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Now peek at the data, or check for a shutdown event.  If recv
	// returns zero and it's a TCP socket it means the connection has been
	// shutdown.  That case will get handled below in the TCP specific
	// handler.
	// Unfortunately, the Alpha version of WinSock (on NT4, at least) returns 
	// WSAENOTCONN when you try a recv on a datagram socket, so we have to do
	// separate calls for UDP vs. TCP.  Oh well, that's pretty minor.

	if (pLSocket->IsUDP())
	{
		DPL(9, "recvfrom(%x, %x, %i, MSG_PEEK, NULL, NULL)",
			3, *(pLSocket->GetSocket()), pDataWithHeader,
			iReadDataBufferSize);

#ifndef _XBOX // Xbox doesn't support MSG_PEEK
		hr = recvfrom(*(pLSocket->GetSocket()), (char*) pDataWithHeader,
					iReadDataBufferSize, MSG_PEEK, NULL, NULL);
#else // ! XBOX

		// Since we don't implement MSG_PEEK, determine size of packet before calling recvfrom
		DWORD	dwNextDGramSize = 0;

		// Determine size of next datagram
		ioctlsocket(*(pLSocket->GetSocket()), FIONREAD, &dwNextDGramSize);

		// We'll be reading the whole datagram instead of just header, need to reallocate
		LocalFree(pDataWithHeader);

		// Some sort of error occured, since we were told earlier that there was data on this socket
		if(dwNextDGramSize == 0)
		{
			OutputDebugString(L"No datagram was pending, but select said socket was readable!");
			hr = E_FAIL;
			goto DONE;
		} // no datagram data was pending

		iReadDataBufferSize = dwNextDGramSize;

		// Reallocate the buffer
		pDataWithHeader = (PCTRLCOMM_TCP_DATAHEADER) LocalAlloc(LPTR, iReadDataBufferSize);

		pFromSockAddress = (SOCKADDR_IN*) LocalAlloc(LPTR, iFromSockAddressSize);
		if (pFromSockAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		hr = recvfrom(*(pLSocket->GetSocket()), (char*) pDataWithHeader,
					iReadDataBufferSize, 0,(SOCKADDR*) pFromSockAddress,
					&iFromSockAddressSize);

		// We're done... go to where we process the message
		goto RECVCOMPLETE;

#endif // XBOX
	} // end if (UDP)
	else
	{
#ifndef _XBOX // Xbox doesn't support MSG_PEEK
		hr = recv(*(pLSocket->GetSocket()), (char*) pDataWithHeader,
					iReadDataBufferSize, MSG_PEEK);
#else // ! XBOX
		hr = recv(*(pLSocket->GetSocket()), (char*) pDataWithHeader,
					iReadDataBufferSize, 0);
#endif // XBOX
	} // end else (not UDP)

	iReadDataIndicatedSize = hr;
	if (hr != SOCKET_ERROR)
		hr = S_OK;
	else
	{
		hr = WSAGetLastError();

#if 1 // BOUNDSCHECKER
		// Boundschecker is stealing the LastError for some reason.  Assume it's
		// WSAEMSGSIZE.
		if (hr == S_OK)
			hr = WSAEMSGSIZE;
#else
		// If WinSock is not bothering to tell us what the problem is, say it's
		// generic
		if (hr == S_OK)
			hr = E_FAIL;
#endif // ! BOUNDSCHECKER
	} // end else (there was an error)

	if ((hr != S_OK) &&
		(! ((pLSocket->IsUDP()) && (hr == WSAEMSGSIZE))) && // didn't read all of the datagram
		(! ((! pLSocket->IsUDP()) && (hr == WSAECONNRESET))) && // other end closed stream somewhat gracefully
		(! ((! pLSocket->IsUDP()) && (hr == WSAECONNABORTED)))) // other end closed stream crappily
	{
		// WinSock seems to be setting our events twice, so trying handle this again
		// returns WSAEWOULDBLOCK.
		if (hr == WSAEWOULDBLOCK)
		{
			//DPL(0, "WARNING: Data on socket appears to already have been received!  Continuing.", 0);
			hr = S_OK;
		} // end if (the event was already consumed)
		else if (hr == WSAECONNRESET)
		{
			// Windows 2000 throws you this notification via your receive path
			// (because the send path already indicated success) if the machine
			// on the other end actively refused (read: is up, but isn't listening
			// on that socket) a datagram you sent to it.  Datagrams are unreliable,
			// we know that, we don't require that it get there!
			DPL(1, "Received notification that a UDP datagram was refused (in peek).  Who cares!?", 0);
			hr = S_OK;
			goto DONE;
		} // end if (new Windows 2000 behavior)
		else
		{
			DPL(0, "Failed to peek at data on %s socket!",
				1, (pLSocket->IsUDP() ? "UDP" : "TCP"));
		} // end else (unexpected error)
		goto DONE;
	} // end if (failed to peek at data on socket)
	/*
	else
	{
		DPL(0, "Data peek %e", 1, hr);
	} // end else (didn't fail)
	*/

	// If we got valid data, or the error was WSAEMSGSIZE (which will always happen
	// for UDP data since we only read part of the message), get a new buffer to
	// hold the entire message, and create a buffer to store the return address as
	// well.
	if ((iReadDataIndicatedSize > 0) || (hr == WSAEMSGSIZE))
	{
#ifndef _XBOX // Xbox doesn't support MSG_PEEK
		iReadDataBufferSize = pDataWithHeader->dwSize;

		// Dump the old peek buffer to store the real one
		LocalFree(pDataWithHeader);
		pDataWithHeader = NULL;

		pDataWithHeader = (PCTRLCOMM_TCP_DATAHEADER) LocalAlloc(LPTR, iReadDataBufferSize);
		if (pDataWithHeader == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		pFromSockAddress = (SOCKADDR_IN*) LocalAlloc(LPTR, iFromSockAddressSize);
		if (pFromSockAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
#else // ! XBOX
		PCTRLCOMM_TCP_DATAHEADER	pTempData = NULL;
		// Since we don't support MSG_PEEK, we'll have to copy the part of the buffer
		// we already read back into the final buffer.

		// Possibly fatal if we couldn't read the whole header... shouldn't happen
		if((iReadDataIndicatedSize > 0) && (iReadDataIndicatedSize < sizeof (CTRLCOMM_TCP_DATAHEADER)))
		{
			OutputDebugString(L"We didn't read the whole header!\r\n");
			hr = E_FAIL;
			goto DONE;
		}

		// Get the size of the whole packet
		iReadDataBufferSize = pDataWithHeader->dwSize;

		// Save the buffer that we already read
		pTempData = pDataWithHeader;
		pDataWithHeader = NULL;

		// Create the new buffer
		pDataWithHeader = (PCTRLCOMM_TCP_DATAHEADER) LocalAlloc(LPTR, iReadDataBufferSize);
		if (pDataWithHeader == NULL)
		{
			hr = E_OUTOFMEMORY;
			LocalFree(pTempData);
			goto DONE;
		} // end if (couldn't allocate memory)

		// Copy the old peek buffer to the new real one
		memcpy(pDataWithHeader, pTempData, sizeof (CTRLCOMM_TCP_DATAHEADER));

		// Dump the old peek buffer
		LocalFree(pTempData);

		// Create the buffer for the sock address
		pFromSockAddress = (SOCKADDR_IN*) LocalAlloc(LPTR, iFromSockAddressSize);
		if (pFromSockAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

#endif // XBOX
	} // end if (we actually read data)

	if (pLSocket->IsUDP())
	{
#ifndef _XBOX // Xbox doesn't support MSG_PEEK
		// Now pull it off the queue

		DPL(9, "recvfrom(%x, %x, %i, 0, %x, %x)",
			5, *(pLSocket->GetSocket()), pDataWithHeader,
			iReadDataBufferSize, pFromSockAddress, iFromSockAddressSize);

		hr = recvfrom(*(pLSocket->GetSocket()), (char*) pDataWithHeader,
						iReadDataBufferSize, 0, (SOCKADDR*) pFromSockAddress,
						&iFromSockAddressSize);
#else // ! XBOX
RECVCOMPLETE:
#endif // XBOX

		iReadDataActualSize = hr;

		if (hr != SOCKET_ERROR)
			hr = S_OK;
		else
		{
			hr = WSAGetLastError();

			if (hr == WSAECONNRESET)
			{
				DPL(1, "Received notification that a UDP datagram was refused (in remove).  Who cares!?", 0);
				hr = S_OK;
				goto DONE;
			} // end if (got CONNRESET)

#if 1 // BOUNDSCHECKER
			// Boundschecker is stealing the LastError for some reason.  Assume it's
			// WSAEMSGSIZE.
			if (hr == S_OK)
				hr = WSAEMSGSIZE;
#else
			// If WinSock is not bothering to tell us what the problem is, say it's
			// generic
			if (hr == S_OK)
				hr = E_FAIL;
#endif // ! BOUNDSCHECKER
		} // end else (there was an error)

		if (hr != S_OK)
		{
			DPL(0, "Failed to retrieve data from datagram socket!", 0);
			goto DONE;
		} // end if (failed to peek at data on socket)

		//BUGBUG we may want to have a lower level reject mechanism (one that
		//		 throws out broadcasts from ourselves, but you have to be
		//		 careful in cases where we have multiple instances of this app
		//		 on the same machine.  In any case, it's not entirely necessary
		//		 because we ignore ENUMs at the next higher up level.
		/*
			// Check if it's just a reflection back to us (from a broadcast)
			if ((fromSockAddress.sin_addr.S_un.S_addr == lpAddress_SockAddr->socketAddress.sin_addr.S_un.S_addr) &&
				(fromSockAddress.sin_port == lpAddress_SockAddr->socketAddress.sin_port))
			{
				//DPL(0, "Message is from our address (%o), ignoring.",
				//	1, &fromAddress);
				hr = S_OK;
				goto DONE;
			} // end if (it's from us)
		*/
	} // end if (a datagram socket)
	else
	{
		if ((iReadDataIndicatedSize == 0) ||
			(hr == WSAECONNRESET) ||
			(hr == WSAECONNABORTED))
		{
			DPL(1, "Received shutdown socket event for connection to %o.",
				1, pLSocket->GetAddress());

			hr = pLSocket->CloseSocket();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't close the socket!", 0);
				goto DONE;
			} // end if (failed closing the socket)

			if (pLSocket->m_pCommData == NULL)
			{
				// Pull it off the list
				hr = this->m_socketlist.RemoveFirstReference(pLSocket);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't remove socket from list!", 0);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't find socket in list)

				if (pLSocket->m_dwRefCount != 0)
				{
					DPL(0, "WARNING: Still an outstanding reference to linked socket %x!",
						1, pLSocket);
				} // end if (not last reference to object)
				else
				{
					delete (pLSocket);
					pLSocket = NULL;
				} // end else (that was the last reference)

				if (this->m_fWinSock2)
				{
					if (! SetEvent(this->m_socketlist.m_hListChangedEvent))
					{
						hr = GetLastError();
						DPL(0, "Couldn't set socket list changed event (%x)!",
							1, this->m_socketlist.m_hListChangedEvent);
						goto DONE;
					} // end if (couldn't notify thread that the list changed)
				} // end if (we're using WinSock2)
			} // end if (this socket isn't bound to anything yet)
			else
			{
				DPL(6, "Not removing socket from list because it is still bound.", 0);
			} // end else (the socket is bound)

			hr = S_OK;
			goto DONE;
		} // end if (it's a shutdown socket event)

#ifndef _XBOX // Xbox doesn't support MSG_PEEK
		// Now pull it off the queue
		hr = recv(*(pLSocket->GetSocket()), (char*) pDataWithHeader,
					iReadDataBufferSize, 0);
#else // ! XBOX
		// Read the second part of the packet (the part after the size field) into remaining part of the buffer
		hr = recv(*(pLSocket->GetSocket()), (char*) pDataWithHeader + sizeof(CTRLCOMM_TCP_DATAHEADER),
					iReadDataBufferSize - sizeof(CTRLCOMM_TCP_DATAHEADER), 0);
#endif // XBOX
		if (hr != SOCKET_ERROR)
		{

#ifndef _XBOX // Xbox doesn't support MSG_PEEK
			iReadDataActualSize = hr;
#else // ! XBOX
		// If we didn't fail, then adjust the number of bytes read to make it look like we read this packet
		// with one call instead of two.
		iReadDataActualSize = hr + sizeof(CTRLCOMM_TCP_DATAHEADER);
#endif // XBOX

#ifdef DEBUG
			if (iReadDataActualSize != iReadDataBufferSize)
			{
				DPL(0, "Didn't read blob same size as buffer (%i != %i)!  DEBUGBREAK()-ing.",
					2, iReadDataActualSize, iReadDataBufferSize);
				DEBUGBREAK();
			} // end if (didn't read expected)
#endif // DEBUG

			hr = S_OK;
		} // end if (no error)
		else
		{
			hr = WSAGetLastError();

			iReadDataActualSize = 0;

			#if 1 // ! BOUNDSCHECKER
			// If WinSock is not bothering to tell us what the problem is, say it's
			// generic
			if (hr == S_OK)
				hr = E_FAIL;
			#endif // ! BOUNDSCHECKER
		} // end else (there was an error)

		if (hr != S_OK)
		{
			DPL(0, "Failed to retrieve data from stream socket!", 0);
			goto DONE;
		} // end if (failed to peek at data on socket)

		// Copy the from address from the socket in the list
		CopyMemory(pFromSockAddress, pLSocket->GetAddress(), iFromSockAddressSize);
	} // end else (a stream socket)


	DPL(9, "Received %u bytes of data from %o", 2, iReadDataActualSize,
		pFromSockAddress);


	// Drop the socket list lock to prevent possible deadlocks
	this->m_socketlist.LeaveCritSection();

	//BUGBUG int to DWORD conversion
	hr = this->m_pControlObj->HandleMessage((LPVOID*) &pFromSockAddress, iFromSockAddressSize,
					((LPBYTE) pDataWithHeader) + sizeof (CTRLCOMM_TCP_DATAHEADER),
					iReadDataActualSize - sizeof (CTRLCOMM_TCP_DATAHEADER));

	// Retake the lock before continuing
	this->m_socketlist.EnterCritSection();

	if (hr != S_OK)
	{
		DPL(0, "Control object message handler failed!", 0);
		// Ignoring errors
		this->m_pControlObj->Log(TNLST_CRITICAL,
								"Control object message handler failed!  %e", 1, hr);
		goto DONE;
	} // end if (it handle message failed)


DONE:

	// This could be reset to NULL even if the memory wasn't explicitly freed here
	// if HandleMessage() turned around and used it in a send.  This is not a great
	// way to do this but it reduces CopyMemorys.
	if (pFromSockAddress != NULL)
	{
		LocalFree(pFromSockAddress);
		pFromSockAddress = NULL;
	} // end if (allocated a from address)

	if (pDataWithHeader != NULL)
	{
		LocalFree(pDataWithHeader);
		pFromSockAddress = NULL;
	} // end if (allocated a data with header buffer)


	DPL(9, "(%x)<== %e", 2, this, hr);

	return (hr);
} // CTNCtrlCommTCP::HandleEventOnSocket
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::InternalCloseReachCheck()"
//==================================================================================
// CTNCtrlCommTCP::InternalCloseReachCheck
//----------------------------------------------------------------------------------
//
// Description: Cleans up the given reach check object.
//
// Arguments:
//	PTNREACHCHECK pReachCheck	Reach check being closed.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNCtrlCommTCP::InternalCloseReachCheck(PTNREACHCHECK pReachCheck)
{
	HRESULT			hr;
	BOOL			fInCritSect = FALSE;
	PLINKEDSOCKET	pLSocket = NULL;



	DPL(9, "==> (%x)", 1, pReachCheck);


	if (pReachCheck->m_pvCommData == NULL)
	{
		DPL(2, "No socket used for reach check ID %u.",
			1, pReachCheck->m_dwID);
	} // end if (no socket)
	else
	{
		pLSocket = (PLINKEDSOCKET) pReachCheck->m_pvCommData;
		pReachCheck->m_pvCommData = NULL;


		// Remove all items still remaining to be sent.
		hr = this->m_sendqueue.RemoveAllItemsTo(pLSocket->GetAddress(),
												sizeof (SOCKADDR_IN));
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove all remaining items to be sent to %o!",
				1, pLSocket->GetAddress());
			goto DONE;
		} // end if (couldn't remove all items)


		this->m_socketlist.EnterCritSection();
		fInCritSect = TRUE;


		// If the socket only existed for this reach check, remove it.
		if (pLSocket->m_dwFoundPriorToReachCheck == 0)
		{
			DPL(2, "Removing %s socket %x used exclusively for reach check (current ID %u).",
				3, (pLSocket->IsUDP() ? "UDP" : "TCP"), *(pLSocket->GetSocket()),
				pReachCheck->m_dwID);

			hr = this->m_socketlist.RemoveFirstReference(pLSocket);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't remove original socket from list!", 0);
				goto DONE;
			} // end if (couldn't remove reference)

			pLSocket->m_dwRefCount--; // delete the comm data reference
			if (pLSocket->m_dwRefCount != 0)
			{
				DPL(0, "Can't delete socket %x (refcount is %u)!?",
					2, pLSocket, pLSocket->m_dwRefCount);

				DEBUGBREAK();
			} // end if (can't delete socket)

			// Deleting it will cause it to shut down.
			delete (pLSocket);
			pLSocket = NULL;
		} // end if (there's only one ref left)
		else
		{
			pLSocket->m_dwFoundPriorToReachCheck--;

			pLSocket->m_dwRefCount--; // delete the comm data reference
			if (pLSocket->m_dwRefCount == 0)
			{
				DPL(0, "Deleting socket %x!?", 1, pLSocket);

				DEBUGBREAK();

				delete (pLSocket);
			} // end if (last reference)
			else
			{
				DPL(0, "Not deleting %s socket %x, (object %x), found count is %u, refcount is %u, reach check ID is %u.",
					6, (pLSocket->IsUDP() ? "UDP" : "TCP"),
					*(pLSocket->GetSocket()),
					pLSocket,
					pLSocket->m_dwFoundPriorToReachCheck,
					pLSocket->m_dwRefCount,
					pReachCheck->m_dwID);
			} // end else (not last reference)

			pLSocket = NULL;
		} // end else (there's more refs left)


		fInCritSect = FALSE;
		this->m_socketlist.LeaveCritSection();
	} // end else (there is a socket)


	hr = this->m_reachchecks.RemoveFirstReference(pReachCheck);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove reach check from list!", 0);
		//goto DONE;
	} // end if (couldn't remove reference)

	if (pReachCheck->m_dwRefCount == 0)
	{
		DPL(0, "Deleting search %x because reference count is 0!?  DEBUGBREAK()-ing.",
			1, pReachCheck);

		DEBUGBREAK();

		delete (pReachCheck);
		pReachCheck = NULL;
	} // end if (should delete search now)


DONE:

	if (fInCritSect)
	{
		fInCritSect = FALSE;
		this->m_socketlist.LeaveCritSection();
	} // end if (in critical section)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNCtrlCommTCP::InternalCloseReachCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::SendUDPDataTo()"
//==================================================================================
// CTNCtrlCommTCP::SendUDPDataTo
//----------------------------------------------------------------------------------
//
// Description: Sends the passed in item via UDP to the passed in address.
//
// Arguments:
//	SOCKADDR_IN* pAddress	Pointer to address to use.
//	PVOID pvData			Pointer to data to send.
//	DWORD dwDataSize		Size of data to send.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::SendUDPDataTo(SOCKADDR_IN* pAddress, PVOID pvData,
										DWORD dwDataSize)
{
	HRESULT						hr = S_OK;
	PLINKEDSOCKET				pLSocket = NULL;
	PCTRLCOMM_TCP_DATAHEADER	pWrappedData = NULL;
	DWORD						dwWrappedDataSize = 0;

	
	DPL(8, "Sending %u bytes of data at %x to: %o", 3, dwDataSize, pvData, pAddress);


	// Look for a UDP socket using the given port.
	pLSocket = this->m_socketlist.GetLSocketByAddress(pAddress, FALSE);
	if (pLSocket == NULL)
	{
		SOCKADDR_IN*		pLocalAddress;


		// We didn't find one, so try using any old UDP socket.
		pLSocket = this->m_socketlist.GetLSocketByAddress(NULL, FALSE);
		if (pLSocket == NULL)
		{
			DPL(0, "Couldn't get any UDP sockets!", 0);
			return (E_FAIL);
		} // end if (a UDP socket wasn't found)

		pLocalAddress = pLSocket->GetAddress();

		DPL(8, "Sending with local socket on port %u (no UDP sockets on port %u).",
			2, BYTEREVERSEWORD(pLocalAddress->sin_port),
			BYTEREVERSEWORD(pAddress->sin_port));
	} // end if (a UDP socket wasn't using that port)


	// Tack on our header
	dwWrappedDataSize = sizeof (CTRLCOMM_TCP_DATAHEADER) +
						dwDataSize;
	pWrappedData = (PCTRLCOMM_TCP_DATAHEADER) LocalAlloc(LPTR, dwWrappedDataSize);
	if (pWrappedData == NULL)
		return (E_OUTOFMEMORY);

	pWrappedData->dwSize = dwWrappedDataSize;
	CopyMemory(((LPBYTE) pWrappedData) + sizeof (CTRLCOMM_TCP_DATAHEADER),
			pvData, dwDataSize);

	// Now send the whole shebang
	hr = sendto(*(pLSocket->GetSocket()), (char*) pWrappedData, dwWrappedDataSize,
				0, (SOCKADDR*) pAddress, sizeof (SOCKADDR_IN));
	if (hr == SOCKET_ERROR)
	{
		hr = WSAGetLastError();

		DPL(0, "Failed to send datagram to address (%o)!", 1, pAddress);

#if 1 // ! BOUNDSCHECKER
		// If WinSock is not bothering to tell us what the problem is, say it's generic
		if (hr == S_OK)
			hr = E_FAIL;
#endif // ! BOUNDSCHECKER
	} // end if (failed to send data)
	else
		hr = S_OK;

	if (pWrappedData != NULL)
	{
		LocalFree(pWrappedData);
		pWrappedData = NULL;
	} // end if (allocated memory)

	return (hr);
} // CTNCtrlCommTCP::SendUDPDataTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCtrlCommTCP::SendTCPDataTo()"
//==================================================================================
// CTNCtrlCommTCP::SendTCPDataTo
//----------------------------------------------------------------------------------
//
// Description: Sends the passed in item via TCP to the passed in address.  It uses
//				a connection to the person if it already exists, or if one doesn't
//				but we're not a testmaster, it tries to create a connection.
//
// Arguments:
//	SOCKADDR_IN* pAddress	Pointer to address to use.
//	PVOID pvData			Pointer to data to send.
//	DWORD dwDataSize		Size of data to send.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CTNCtrlCommTCP::SendTCPDataTo(SOCKADDR_IN* pAddress, PVOID pvData,
										DWORD dwDataSize)
{
	HRESULT						hr = S_OK;
	PLINKEDSOCKET				pLSocket = NULL;
	PCTRLCOMM_TCP_DATAHEADER	pWrappedData = NULL;
	DWORD						dwWrappedDataSize = 0;
	DWORD						dwTemp;

	
	DPL(8, "Sending %u bytes of data at %x to: %o", 3, dwDataSize, pvData, pAddress);

	pLSocket = this->m_socketlist.GetLSocketByAddress(pAddress, TRUE);
	if (pLSocket == NULL)
	{
		//DPL(0, "No connection to that machine already exists.", 0);


#pragma TODO(vanceo, "Reconnect protection?")


		// Create a new socket and try to establish a new connection.

		hr = this->CreateAndConnectTCPSocket(pAddress, &pLSocket);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't create and connect TCP socket to %o!", 1, pAddress);
			return (hr);
		} // end if (couldn't create socket)
	} // end if (the connection doesn't exist)


	// Tack on our header
	dwWrappedDataSize = sizeof (CTRLCOMM_TCP_DATAHEADER) +
						dwDataSize;
	pWrappedData = (PCTRLCOMM_TCP_DATAHEADER) LocalAlloc(LPTR, dwWrappedDataSize);
	if (pWrappedData == NULL)
		return (E_OUTOFMEMORY);

	pWrappedData->dwSize = dwWrappedDataSize;
	CopyMemory(((LPBYTE) pWrappedData) + sizeof (CTRLCOMM_TCP_DATAHEADER),
			pvData, dwDataSize);

	// BUGBUG int and DWORD conversion
	dwTemp = send(*(pLSocket->GetSocket()), (char*) pWrappedData, dwWrappedDataSize, 0);
	if (dwTemp == SOCKET_ERROR)
	{
		hr = WSAGetLastError();
		DPL(0, "Send failed!", 0);
	} // end if (send failed)
	else
	{
		if (dwTemp != dwWrappedDataSize)
			DPL(0, "Sent (%u) different amount of data than expected (%u)",
				2, dwTemp, dwWrappedDataSize);
		hr = S_OK;
	} // end else (send succeeded)

	if (pWrappedData != NULL)
	{
		LocalFree(pWrappedData);
		pWrappedData = NULL;
	} // end if (allocated memory)

	return (hr);
} // CTNCtrlCommTCP::SendTCPDataTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"WSSendThreadProc()"
//==================================================================================
// WSSendThreadProc
//----------------------------------------------------------------------------------
//
// Description: Waits for data to send, and then sends it.
//
// Arguments:
//	LPVOID lpvParameter		Thread data.  Cast to a CTNCtrlCommTCP object.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI WSSendThreadProc(LPVOID lpvParameter)
{
	HRESULT			hr;
	PTNCTRLCOMMTCP	pThisObj = (PTNCTRLCOMMTCP) lpvParameter;
	HANDLE			ahWaitObjects[3];


	DPL(1, "Starting up.", 0);

	if (pThisObj->m_hKillSendThreadEvent == NULL)
	{
		DPL(0, "Kill thread event doesn't exist!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (event doesn't exist)

	if (pThisObj->m_sendqueue.m_hSendDataEvent == NULL)
	{
		DPL(0, "Send data event doesn't exist!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (event doesn't exist)

	ahWaitObjects[0] = pThisObj->m_hKillSendThreadEvent;
	ahWaitObjects[1] = pThisObj->m_sendqueue.m_hSendDataEvent;
	ahWaitObjects[2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	do
	{
		switch (WaitForMultipleObjects(2, ahWaitObjects, FALSE, INFINITE))
		{
			case WAIT_OBJECT_0:
				// Time to die
				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// There should be something in the queue

				pThisObj->m_sendqueue.EnterCritSection();

				if (pThisObj->m_sendqueue.Count() == 0)
				{
					DPL(0, "WARNING: Send queue event fired but there's nothing in the queue.", 0);
					pThisObj->m_sendqueue.LeaveCritSection();
				} // end if (there's nothing in the queue)
				else
				{
					hr = pThisObj->SendFirstData();
					if (hr != S_OK)
					{
						DPL(0, "WARNING: Control layer sending data failed!  %e", 1, hr);

						// Ignoring errors
						pThisObj->m_pControlObj->Log(TNLST_CRITICAL,
														"WARNING: Control layer sending data failed!  %e",
														1, hr);

						// but continue on...
						hr = S_OK;
					} // end if (sending data failed)

					// If there are still items left in the queue, refire our event
					if (pThisObj->m_sendqueue.Count() > 0)
					{
						if (! SetEvent(pThisObj->m_sendqueue.m_hSendDataEvent))
						{
							hr = GetLastError();
							DPL(0, "Couldn't refire send queue event (%x)!",
								1, pThisObj->m_sendqueue.m_hSendDataEvent);
							pThisObj->m_sendqueue.LeaveCritSection();
							goto DONE;
						} // end if (couldn't set event)
					} // end if (there are still items in the send queue)

					pThisObj->m_sendqueue.LeaveCritSection();
				} // end else (there's something in the send queue)
			  break;

			default:
				DPL(0, "Got unexpected return from WaitForMultipleObjects!", 0);
				hr = E_FAIL;
			  break;
		} // end while (we got new data to send)
	} // end do (while it's not time to die)
	while (hr == S_OK);

DONE:

	if (hr != S_OK)
	{
		DPL(0, "WinSock Send thread aborting!  DEBUGBREAK()-ing.  %e",
			1, hr);

		// Ignoring errors
		pThisObj->m_pControlObj->Log(TNLST_CRITICAL,
									"WinSock Send thread aborting!  DEBUGBREAK()-ing.  %e",
									1, hr);

		DEBUGBREAK();
	} // end if (quitting with a failure)

	DPL(1, "Exiting.", 0);

	return (hr);
} // WSSendThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"WS1ReceiveThreadProc()"
//==================================================================================
// WS1ReceiveThreadProc
//----------------------------------------------------------------------------------
//
// Description: Waits for data to come in on the various sockets, then passes it up.
//
// Arguments:
//	LPVOID lpvParameter		Thread data.  Cast to a CTNCtrlCommTCP object.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI WS1ReceiveThreadProc(LPVOID lpvParameter)
{
	HRESULT			hr = S_OK;
	PTNCTRLCOMMTCP	pThisObj = (PTNCTRLCOMMTCP) lpvParameter;

	DPL(1, "Starting up.", 0);

	if (pThisObj->m_hKillReceiveThreadEvent == NULL)
	{
		DPL(0, "Kill thread event doesn't exist!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (event doesn't exist)

	// Without WinSock2 functionality, there's no way to wait for a kill thread event
	// while checking for a socket event, so we use this CPU intensive check.  Ugh.
	while (WaitForSingleObject(pThisObj->m_hKillReceiveThreadEvent, 0) == WAIT_TIMEOUT)
	{
		hr = pThisObj->CheckForReceiveData();
		if (hr != S_OK)
		{
			DPL(0, "CheckForReceiveData failed!", 0);
			goto DONE;
		} // end if (check for receive data failed)
	} // end while (we're not being told to stop)

DONE:

	if (hr != S_OK)
	{
		DPL(0, "WinSock WS1Receive thread aborting!  DEBUGBREAK()-ing.  %e",
			1, hr);

		// Ignoring errors
		pThisObj->m_pControlObj->Log(TNLST_CRITICAL,
									"WinSock WS1Receive thread aborting!  DEBUGBREAK()-ing.  %e",
									1, hr);

		DEBUGBREAK();
	} // end if (quitting with a failure)

	DPL(1, "Exiting.", 0);
	return (hr);
} // WS1ReceiveThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"WS2ReceiveThreadProc()"
//==================================================================================
// WS2ReceiveThreadProc
//----------------------------------------------------------------------------------
//
// Description: Waits for data to come in on the various sockets, then passes it up.
//
// Arguments:
//	LPVOID lpvParameter		Thread data.  Cast to a CTNCtrlCommTCP object.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI WS2ReceiveThreadProc(LPVOID lpvParameter)
{
	HRESULT			hr = S_OK;
	PTNCTRLCOMMTCP	pThisObj = (PTNCTRLCOMMTCP) lpvParameter;
	HANDLE			ahWaitObjects[3];


	DPL(1, "Starting up.", 0);

	if (pThisObj->m_hKillReceiveThreadEvent == NULL)
	{
		DPL(0, "Kill thread event doesn't exist!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (event doesn't exist)

	if (pThisObj->m_hAllSocketsReceiveEvent == NULL)
	{
		DPL(0, "All sockets recieve event doesn't exist!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (event doesn't exist)

	ahWaitObjects[0] = pThisObj->m_hKillReceiveThreadEvent;
	ahWaitObjects[1] = pThisObj->m_hAllSocketsReceiveEvent;
	ahWaitObjects[2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	// With WinSock2 functionality we can wait until we either get a socket event
	// or a shutdown event, and not use CPU time in between.

	do
	{
		hr = WaitForMultipleObjects(2, ahWaitObjects, FALSE, INFINITE);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// We're being told to die.

				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// We've gotten a receive event.

				hr = pThisObj->CheckForReceiveData();
				if (hr != S_OK)
				{
					DPL(0, "CheckForReceiveData failed!", 0);
					goto DONE;
				} // end if (check for receive data failed)
			  break;

			default:
				// Something was goofy.

				DPL(0, "Got unexpected return from WaitForMultiple objects!", 0);
				goto DONE;
			  break;
		} // end switch (on wait result)
	} // end do
	while (TRUE); // loop until we are told to quit or get an error


DONE:

	if (hr != S_OK)
	{
		DPL(0, "WinSock WS2Receive thread aborting!  DEBUGBREAK()-ing.  %e",
			1, hr);

		// Ignoring errors
		pThisObj->m_pControlObj->Log(TNLST_CRITICAL,
									"WinSock WS2Receive thread aborting!  DEBUGBREAK()-ing.  %e",
									1, hr);

		DEBUGBREAK();
	} // end if (quitting with a failure)

	DPL(1, "Exiting.", 0);

	return (hr);
} // WS2ReceiveThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"WS2OneToOneReceiveThreadProc()"
//==================================================================================
// WS2OneToOneReceiveThreadProc
//----------------------------------------------------------------------------------
//
// Description: Waits for data to come in on the various sockets, then passes it up.
//
// Arguments:
//	LPVOID lpvParameter		Thread data.  Cast to a CTNCtrlCommTCP object.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI WS2OneToOneReceiveThreadProc(LPVOID lpvParameter)
{
	HRESULT				hr = S_OK;
	PTNCTRLCOMMTCP		pThisObj = (PTNCTRLCOMMTCP) lpvParameter;
	BOOL				fRebuildArray = TRUE;
	BOOL				fInCritSect = FALSE;
	HANDLE*				pahWaitObjects = NULL;
	int					iNumSockets = 0;
	int					i;
	PLINKEDSOCKET		pLSocket = NULL;


	DPL(1, "Starting up.", 0);

	if (pThisObj->m_hKillReceiveThreadEvent == NULL)
	{
		DPL(0, "Kill thread event doesn't exist!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (event doesn't exist)

	if (pThisObj->m_socketlist.m_hListChangedEvent == NULL)
	{
		DPL(0, "List changed event doesn't exist!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (event doesn't exist)

	// With WinSock2 functionality we can wait until we either get a socket event
	// or a shutdown event, and not use CPU time in between.

	do
	{
		if (fRebuildArray)
		{
			//DPL(0, "Rebuilding socket list array.", 0);

			fRebuildArray = FALSE;

			// If the array already existed, clear it out (closing references).
			if (pahWaitObjects != NULL)
			{
				for(i = 2; i < iNumSockets + 2; i++)
				{
					// Close our reference to the item, ignoring errors
					CloseHandle(pahWaitObjects[i]);
					pahWaitObjects[i] = NULL;
				} // end for (each item already in the array)

				LocalFree(pahWaitObjects);
				pahWaitObjects = NULL;
			} // end if (there was an array already)

			pThisObj->m_socketlist.EnterCritSection();
			fInCritSect = TRUE;

			// Reset the event just in case it got fired again or what not to
			// prevent needless rebuilding of the array.
			if (! ResetEvent(pThisObj->m_socketlist.m_hListChangedEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't reset the list changed event (%x)!",
					1, pThisObj->m_socketlist.m_hListChangedEvent);
				goto DONE;
			} // end if (couldn't reset the event)

			iNumSockets = pThisObj->m_socketlist.Count();

			pahWaitObjects = (HANDLE*) LocalAlloc(LPTR, ((iNumSockets + 3) * sizeof (HANDLE)));
			if (pahWaitObjects == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			pahWaitObjects[0] = pThisObj->m_hKillReceiveThreadEvent;
			pahWaitObjects[1] = pThisObj->m_socketlist.m_hListChangedEvent;

			for(i = 0; i < iNumSockets; i++)
			{
				pLSocket = (PLINKEDSOCKET) pThisObj->m_socketlist.GetItem(i);
				if (pLSocket == NULL)
				{
					DPL(0, "Couldn't get socket %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get item)

				// We need a handle to the object, but we can't just use the
				// other handle because another thread might close it and we'd
				// have a bogus handle.
				if (! DuplicateHandle(GetCurrentProcess(), pLSocket->GetEvent(),
										GetCurrentProcess(), &(pahWaitObjects[i + 2]),
										0, FALSE, DUPLICATE_SAME_ACCESS))
				{
					hr = GetLastError();
					DPL(0, "Couldn't duplicate player event handle %i (%x)!",
						2, i, pLSocket->GetEvent());
					goto DONE;
				} // end if (couldn't duplicate handle)
			} // end for (each socket in the list)

			pahWaitObjects[iNumSockets + 2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array
			
			fInCritSect = FALSE;
			pThisObj->m_socketlist.LeaveCritSection();
		} // end if (should rebuild array)


		DPL(9, "++ Waiting for event on %i sockets.", 1, iNumSockets);

		hr = WaitForMultipleObjects(iNumSockets + 2, pahWaitObjects, FALSE, INFINITE);

		DPL(9, "-- Got event %x", 1, hr);

		switch (hr)
		{
			case WAIT_OBJECT_0:
				// We're being told to die.

				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// We've gotten a list changed event.

				fRebuildArray = TRUE;
				hr = S_OK;
			  break;

			case WAIT_FAILED:
				// Something was goofy.

				hr = GetLastError();
				DPL(0, "Wait failed!", 0);
				goto DONE;
			  break;

			default:
				i = hr - WAIT_OBJECT_0 - 2; // get the index of the item that caused this

				pThisObj->m_socketlist.EnterCritSection();
				fInCritSect = TRUE;

				if (iNumSockets != pThisObj->m_socketlist.Count())
				{
					DPL(0, "List appears to have changed (%i != %i) but we haven't been told yet, forcing array rebuild and reactivating item %i!",
						3, iNumSockets, pThisObj->m_socketlist.Count(), i);
					fRebuildArray = TRUE;

					// Otherwise, refire the event that triggered this so we can retry,
					// if we can.
					if ((i >= 0) && (i < iNumSockets))
					{
						if (! SetEvent(pahWaitObjects[i + 2]))
						{
							hr = GetLastError();
							DPL(0, "WARNING: Couldn't refire event %x!  %e",
								2, pahWaitObjects[i + 2], hr);
						} // end if (couldn't refire event)
					} // end if (have a valid index to try refiring)
					else
					{
						DPL(0, "WARNING: Item %i was not a valid object before, not trying to refire anything!",
							1, i);
					} // end else (no object to refire)

					fInCritSect = FALSE;
					pThisObj->m_socketlist.LeaveCritSection();
					break;
				} // end if (list changed but we didn't see it yet)

				// Check to make sure it was a valid event
				if ((i < 0) || (i >= iNumSockets))
				{
					DPL(0, "Got unexpected return from WaitForMultipleObjects!", 0);
					hr = E_FAIL;
					goto DONE;
				} // end if (got wacky return)

				// Otherwise, grab the object that signalled
				pLSocket = (PLINKEDSOCKET) pThisObj->m_socketlist.GetItem(i);
				if (pLSocket == NULL)
				{
					//BUGBUG figure out why it's actually doing this
					/*
					DPL(0, "Couldn't get activated object item %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
					*/
					DPL(0, "WARNING: Couldn't get activated object item %i, forcing array rebuild!", 1, i);
					fRebuildArray = TRUE;

					fInCritSect = FALSE;
					pThisObj->m_socketlist.LeaveCritSection();
					break;
				} // end if (couldn't get signalled socket)


				DPL(8, "Got event on socket %i", 1, i);

				if (*(pLSocket->GetSocket()) == INVALID_SOCKET)
				{
					DPL(0, "Skipping socket %i because it has been shutdown.", 1, i);
				} // end if (the socket is gone)
				else
				{
					// Note that this may drop the socket list lock.  That should be
					// okay since we don't use the items any more in this loop, and
					// if the user made a call that changed the array, the event
					// would be set, and we'll rebuild like usual.
					hr = pThisObj->HandleEventOnSocket(pLSocket);
					if (hr != S_OK)
					{
						DPL(0, "Failed to handle event on socket %i!", 1, i);
						goto DONE;
					} // end if (failed to check for socket event)
				} // end else (it's a valid socket)

				pLSocket = NULL; // for BoundsChecker's sake

				fInCritSect = FALSE;
				pThisObj->m_socketlist.LeaveCritSection();
			  break;
		} // end switch (on wait result)
	} // end do
	while (TRUE); // loop until we are told to quit or get an error

DONE:

	if (fInCritSect)
		pThisObj->m_socketlist.LeaveCritSection();

	if (pahWaitObjects != NULL)
	{
		for(i = 2; i < iNumSockets + 2; i++)
		{
			// Close our reference to the item, ignoring errors
			CloseHandle(pahWaitObjects[i]);
			pahWaitObjects[i] = NULL;
		} // end for (each item already in the array)

		LocalFree(pahWaitObjects);
		pahWaitObjects = NULL;
	} // end if (we had an object array)


	if (hr != S_OK)
	{
		DPL(0, "WinSock WS2OneToOneReceive thread aborting!  DEBUGBREAK()-ing.  %e",
			1, hr);

		// Ignoring errors
		pThisObj->m_pControlObj->Log(TNLST_CRITICAL,
									"WinSock WS2OneToOneReceive thread aborting!  DEBUGBREAK()-ing.  %e",
									1, hr);

		DEBUGBREAK();
	} // end if (quitting with a failure)

	DPL(1, "Exiting.", 0);

	return (hr);
} // WS2OneToOneReceiveThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\control.h ===
#ifndef __TNCONTROL_CONTROL__
#define __TNCONTROL_CONTROL__
//#pragma message("Defining __TNCONTROL_CONTROL__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNControlLayer
{
	// These are friends so they can access the protected members
	friend CTNExecutor;
	friend CTNExecutorPriv;


	protected:
		PTNLOGSTRINGPROC	m_pfnLogString; // callback to use to log strings for the user
		PTNCTRLCOMM			m_pCtrlComm; // pointer to control method we're using
		HANDLE				m_hCompletionOrUpdateEvent; // handle to event to set when session status changes or stats are updated


	public:
		DLLSAFE_NEWS_AND_DELETES;

		CTNControlLayer(void);
		virtual ~CTNControlLayer(void);


		HRESULT Log(DWORD dwLogStringType, char* szFormatString, DWORD dwNumParms, ...);

		// This is a pure virtual function, derived classes must implement it because
		// we sure don't.
		virtual HRESULT HandleMessage(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									  PVOID pbData, DWORD dwDataSize) = 0;
};






#else //__TNCONTROL_CONTROL__
//#pragma message("__TNCONTROL_CONTROL__ already included!")
#endif //__TNCONTROL_CONTROL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\commtcp.h ===
#ifndef __TNCONTROL_COMMTCP__
#define __TNCONTROL_COMMTCP__
//#pragma message("Defining __TNCONTROL_COMMTCP__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG



// This is the primary port used to receive data.
#define CTRLCOMM_TCPIP_PORT				1977

#define INITIAL_RECEIVEBUFFER_SIZE		256 // in bytes


#ifndef INCL_WINSOCK_API_TYPEDEFS
#pragma message("ERROR: You will need to #define INCL_WINSOCK_API_TYPEDEFS 1 and #include <winsock2.h> before you #include <windows.h>")
#endif //! INCL_WINSOCK_API_TYPEDEFS




//==================================================================================
// Macros
//==================================================================================
#define BYTEREVERSEWORD(word)	(MAKEWORD(HIBYTE(word), LOBYTE(word)))



//==================================================================================
// External Prototypes
//==================================================================================
HRESULT CtrlCommTCPLoadOptimal(PCONTROLCOMMINITPBLOCK pParams,
								PTNCTRLCOMM* ppTNCtrlComm);
HRESULT CtrlCommTCPLoadWinSock1(PCONTROLCOMMINITPBLOCK pParams,
								PTNCTRLCOMM* ppTNCtrlComm);
HRESULT CtrlCommTCPLoadWinSock2OneToOne(PCONTROLCOMMINITPBLOCK pParams,
										PTNCTRLCOMM* ppTNCtrlComm);





//==================================================================================
// Structs
//==================================================================================
typedef struct tagCTRLCOMM_TCP_DATAHEADER
{
	DWORD	dwSize;
} CTRLCOMM_TCP_DATAHEADER, * PCTRLCOMM_TCP_DATAHEADER;





//==================================================================================
// Local Prototypes
//==================================================================================
DWORD WINAPI WSSendThreadProc(LPVOID lpvParameter);
DWORD WINAPI WS1ReceiveThreadProc(LPVOID lpvParameter);
DWORD WINAPI WS2ReceiveThreadProc(LPVOID lpvParameter);
DWORD WINAPI WS2OneToOneReceiveThreadProc(LPVOID lpvParameter);





//==================================================================================
// Classes
//==================================================================================
typedef class CLinkedSocket	CLinkedSocket, * PLINKEDSOCKET;
class CLinkedSocket:public LLITEM
{
	// This is declared a friend class so it can access the protected data.
	friend class CTNCtrlCommTCP;

	protected:
		SOCKET			m_socket; // the socket
		SOCKADDR_IN		m_address; // who the socket is connected to
		BOOL			m_fTCP; // is this a TCP (as opposed to UDP) socket?
		BOOL			m_fListen; // if it's TCP, is it a listening socket?
		BOOL			m_fBroadcast; // if it's UDP, can it send to the broadcast?
		PCOMMDATA		m_pCommData; // pointer to structure shared with control layer
		HANDLE			m_hWS2Event; // event associated with socket
		DWORD			m_dwFoundPriorToReachCheck; // number of times reach check functions searched for the socket and found it already existing


	public:
		CLinkedSocket(SOCKET sNew, SOCKADDR_IN address, BOOL fTCP, BOOL fListen,
					BOOL fBroadcast, HANDLE hWinSock2Event);
		virtual ~CLinkedSocket(void);


		SOCKET* GetSocket(void);
		SOCKADDR_IN* GetAddress(void);
		HANDLE GetEvent(void);

		BOOL IsTCPListen(void);
		BOOL IsUDP(void);
		BOOL IsUDPBroadcast(void);

		HRESULT CloseSocket(void);
};



typedef class CLSocketsList	CLSocketsList, * PLSOCKETSLIST;
class CLSocketsList:public LLIST
{
	public:
		HANDLE		m_hListChangedEvent; // event to set when the list changes


		CLSocketsList(void);
		virtual ~CLSocketsList(void);

		/*
		void EnterCritSection(void);
		void LeaveCritSection(void);
		*/

		HRESULT AddSocket(SOCKET sNew, SOCKADDR_IN address, BOOL fTCP, BOOL fListen,
							BOOL fBroadcast, HANDLE hWinSock2Event,
							PLINKEDSOCKET* ppLSocket);

		HRESULT AddNewConnectionFromSocket(SOCKET* pListenSocket,
											HANDLE hWinSock2Event,
											LPFN_WSAEVENTSELECT lpfnWSAEventSelect,
											BOOL fSocketOwnsEvent,
											PLINKEDSOCKET* ppLSocket);

		PLINKEDSOCKET GetLSocketByAddress(SOCKADDR_IN* pAddress, BOOL fTCP);
};


class CTNCtrlCommTCP:public CTNCtrlComm
{
	// Declare these as friends so they can access the protected members
	friend CTNSlave;
	friend DWORD WINAPI SlavePeriodicSendThreadProc(LPVOID lpvParameter); // see slave.h

	friend DWORD WINAPI WSSendThreadProc(LPVOID lpvParameter);
	friend DWORD WINAPI WS1ReceiveThreadProc(LPVOID lpvParameter);
	friend DWORD WINAPI WS2ReceiveThreadProc(LPVOID lpvParameter);
	friend DWORD WINAPI WS2OneToOneReceiveThreadProc(LPVOID lpvParameter);


	private:
		BOOL				m_fCtrlMethodMode; // whether this a real comm tcp object or only temporary
		BOOL				m_fWinSockStarted; // whether WSAStartup was successfully called yet or not
		HINSTANCE			m_hWinSock2DLL; // handle to WinSock 2 DLL if loaded
		CTNReachChecksList	m_reachchecks; // list of all currently outstanding IP data accepts or connects


		HRESULT InitWinSock2(void);
		HRESULT CreateUDPSocket(WORD wPort, BOOL fBroadcast,
								PLINKEDSOCKET* ppLSocket);
		HRESULT CreateTCPListenSocket(WORD wPort, PLINKEDSOCKET* ppLSocket);
		HRESULT CreateAndConnectTCPSocket(SOCKADDR_IN* pAddress,
										PLINKEDSOCKET* ppLSocket);


	protected:
		CLSocketsList					m_socketlist; // linked list of socket descriptors and other info
		BOOL							m_fWinSock2; // can we use WinSock 2 functionality?
		HANDLE							m_hAllSocketsReceiveEvent; // handle to read event associated with all sockets
		LPFN_WSAEVENTSELECT				m_lpfnWSAEventSelect; // pointer to WinSock2 proc
		LPFN_WSAWAITFORMULTIPLEEVENTS	m_lpfnWSAWaitForMultipleEvents; // pointer to WinSock2 proc
		LPFN_WSARESETEVENT				m_lpfnWSAResetEvent; // pointer to WinSock2 proc

		HRESULT SendFirstData(void);
		HRESULT CheckForReceiveData(void);
		HRESULT CheckAndHandleEventOnSocket(PLINKEDSOCKET pLSocket);
		HRESULT HandleEventOnSocket(PLINKEDSOCKET pLSocket);
		HRESULT InternalCloseReachCheck(PTNREACHCHECK pReachCheck);


		HRESULT SendUDPDataTo(SOCKADDR_IN* pAddress, PVOID pvData,
							DWORD dwDataSize);
		HRESULT SendTCPDataTo(SOCKADDR_IN* pAddress, PVOID pvData,
							DWORD dwDataSize);


	public:
		CTNCtrlCommTCP(PCONTROLCOMMINITPBLOCK pParams, BOOL fWinSock2);
		virtual ~CTNCtrlCommTCP(void);


		// Implementation of virtuals
		virtual HRESULT Initialize(void);

		virtual HRESULT Release(void);

		virtual HRESULT GetBroadcastAddress(PVOID pvModifierData,
											DWORD dwModifierDataSize,
											PVOID pvAddress,
											DWORD* pdwAddressSize);

		virtual HRESULT ConvertStringToAddress(char* szString,
												PVOID pvModifierData,
												DWORD dwModifierDataSize,
												PVOID pvAddress,
												DWORD* pdwAddressSize);

		virtual HRESULT GetSelfAddressAsString(char* pszString,
												DWORD* pdwStringSize);

		virtual HRESULT BindDataToAddress(PCOMMDATA pCommData);

		virtual HRESULT UnbindDataFromAddress(PCOMMDATA pCommData);

		virtual HRESULT FlushSendQueue(void);


		virtual HRESULT StartAcceptingReachCheck(PTNREACHCHECK pReachCheck);

		virtual HRESULT StopAcceptingReachCheck(PTNREACHCHECK pReachCheck);

		virtual HRESULT PrepareToReachCheck(PTNREACHCHECK pReachCheck);

		virtual HRESULT CleanupReachCheck(PTNREACHCHECK pReachCheck);
};





#else //__TNCONTROL_COMMTCP__
//#pragma message("__TNCONTROL_COMMTCP__ already included!")
#endif //__TNCONTROL_COMMTCP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\comports.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#ifndef _XBOX // no TAPI supported
#include <tapi.h>
#endif // ! XBOX


#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
//#include "..\tncommon\strutils.h"

#include "tncontrl.h"
#include "main.h"

#include "tapidevs.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCOMPort::CTNCOMPort()"
//==================================================================================
// CTNCOMPort constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNCOMPort object.  Initializes the data structures.
//
// Arguments:
//	char* szConnectedMachineName	Name of computer on other end of connection.
//	DWORD dwCOMPort					COM port this object represents.
//
// Returns: None (just the object).
//==================================================================================
CTNCOMPort::CTNCOMPort(char* szConnectedMachineName, DWORD dwCOMPort):
	CLString(szConnectedMachineName),
	m_dwCOMPort(dwCOMPort)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNCOMPort));
} // CTNCOMPort::CTNCOMPort
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCOMPort::~CTNCOMPort()"
//==================================================================================
// CTNCOMPort destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNCOMPort object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNCOMPort::~CTNCOMPort(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNCOMPort::~CTNCOMPort
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCOMPort::GetCOMPort()"
//==================================================================================
// CTNCOMPort::GetCOMPort
//----------------------------------------------------------------------------------
//
// Description: Returns the COM port number for this device.
//
// Arguments: None.
//
// Returns: The COM port number for this object.
//==================================================================================
DWORD CTNCOMPort::GetCOMPort(void)
{
	return (this->m_dwCOMPort);
} // CTNCOMPort::GetPhoneNumber
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCOMPortsList::PackIntoBuffer()"
//==================================================================================
// CTNCOMPortsList::PackIntoBuffer
//----------------------------------------------------------------------------------
//
// Description: Flattens this list into a contiguous buffer for easy transmission.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required, and ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to fill in with
//							buffer size required.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNCOMPortsList::PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize)
{
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				i;
	PTNCOMPORT		pCOMPort = NULL;
	DWORD			dwNameStringSize;



	if (pvBuffer == NULL)
	{
		(*pdwBufferSize) = 0;
	} // end if (just retrieving size)

	this->EnterCritSection();

	i = this->Count();

	if (i <= 0)
	{
		this->LeaveCritSection();
		return (S_OK);
	} // end if (there aren't any items in this list)


	// If we have the buffer already, start copying.
	if (pvBuffer == NULL)
	{
		(*pdwBufferSize) = sizeof (int);
	} // end if (just retrieving size)
	else
	{
		// Copy the number of items in.
		CopyAndMoveDestPointer(lpCurrent, &i, sizeof (int))
	} // end else (have buffer)


	for(i = 0; i < this->Count(); i++)
	{
		pCOMPort = (PTNCOMPORT) this->GetItem(i);
		if (pCOMPort == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get COM port %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)

		dwNameStringSize = 0;
		if (pCOMPort->GetString() != NULL)
			dwNameStringSize = strlen(pCOMPort->GetString());


		if (pvBuffer == NULL)
		{
			(*pdwBufferSize) += sizeof (DWORD)
							+ sizeof (DWORD) + dwNameStringSize;
		} // end if (just retrieving size)
		else
		{
			CopyAndMoveDestPointer(lpCurrent, &(pCOMPort->m_dwCOMPort), sizeof (DWORD));
			CopyAndMoveDestPointer(lpCurrent, &dwNameStringSize, sizeof (DWORD));
			if (dwNameStringSize > 0)
			{
				CopyAndMoveDestPointer(lpCurrent, pCOMPort->GetString(), dwNameStringSize);
			} // end if (theres actually a phone number string)
		} // end else (have buffer)

	} // end for (each device)
	this->LeaveCritSection();

	if (pvBuffer == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
} // CTNCOMPortsList::PackIntoBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCOMPortsList::UnpackFromBuffer()"
//==================================================================================
// CTNCOMPortsList::UnpackFromBuffer
//----------------------------------------------------------------------------------
//
// Description: Populates this list with the contents previously stored in a
//				contiguous buffer.
//
// Arguments:
//	LPVOID lpvBuffer		Pointer to buffer to use.
//	DWORD dwBufferSize		Size of buffer.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNCOMPortsList::UnpackFromBuffer(LPVOID lpvBuffer, DWORD dwBufferSize)
{
	HRESULT		hr;
	LPBYTE		lpCurrent = (LPBYTE) lpvBuffer; // start at the beginning
	int			iNumItems = 0;
	int			i;
	PTNCOMPORT	pCOMPort = NULL;
	DWORD		dwCOMPort;
	char*		pszTemp = NULL;
	DWORD		dwNameStringSize;



	this->EnterCritSection();

	CopyAndMoveSrcPointer(&iNumItems, lpCurrent, sizeof (int));

	for(i = 0; i < iNumItems; i++)
	{
		CopyAndMoveSrcPointer(&dwCOMPort, lpCurrent, sizeof (DWORD));
		CopyAndMoveSrcPointer(&dwNameStringSize, lpCurrent, sizeof (DWORD));
		if (dwNameStringSize > 0)
		{
			pszTemp = (char*) LocalAlloc(LPTR, dwNameStringSize + 1);
			if (pszTemp == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate string)

			CopyAndMoveSrcPointer(pszTemp, lpCurrent, dwNameStringSize);
		} // end if (there's a phone number)
		
		pCOMPort = new (CTNCOMPort)(pszTemp, dwCOMPort);
		if (pCOMPort == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		if (pszTemp != NULL)
		{
			LocalFree(pszTemp);
			pszTemp = NULL;
		} // end if (there's a name string)

		hr = this->Add(pCOMPort);
		if (hr != S_OK)
		{
			DPL(0, "Adding COM port %i failed!", 1, i);
			goto DONE;
		} // end if (couldn't add item)

		pCOMPort = NULL; // forget about it so we don't free it below
	} // end for (each binary location list)


DONE:

	this->LeaveCritSection();

	if (pCOMPort != NULL)
	{
		delete (pCOMPort);
		pCOMPort = NULL;
	} // end if (have leftover object)

	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (there's a name string)

	return (hr);
} // CTNCOMPortsList::UnpackFromBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#ifndef _XBOX // no file printing supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNCOMPortsList::PrintToFile()"
//==================================================================================
// CTNCOMPortsList::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints all the objects in this list to the file specified.
//
// Arguments:
//	HANDLE hFile	File to print to.
//
// Returns: None.
//==================================================================================
void CTNCOMPortsList::PrintToFile(HANDLE hFile)
{
	int			i;
	PTNCOMPORT	pCOMPort = NULL;


	FileWriteLine(hFile, "\t(COMPorts)"); //ignoring errors

	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pCOMPort = (PTNCOMPORT) this->GetItem(i);
		if (pCOMPort == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get COM port object %i!", 1, i);
			return;
		} // end if (couldn't get that item)

		// ignoring errors
		FileSprintfWriteLine(hFile, "\t\t<COM%u>",
							1, pCOMPort->GetCOMPort());

		if (pCOMPort->GetString() != NULL)
		{
			FileSprintfWriteLine(hFile, "\t\t\tConnectedTo= %s",
								1, pCOMPort->GetString());
		} // end if (there's a connection name)
	} // end for (each item in the list)

	this->LeaveCritSection();
} // CTNCOMPortsList::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\excptns.h ===
#ifndef __TNCONTROL_EXCEPTIONS__
#define __TNCONTROL_EXCEPTIONS__
//#pragma message("Defining __TNCONTROL_EXCEPTIONS__")






//==================================================================================
// Common Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// Exceptino handling helper functions for macros
//==================================================================================
DLLEXPORT HRESULT TNHandleCatchExceptionList(PTNEXCEPTIONSLIST pExceptions,
											PTNTESTRESULT pTestResult);
DLLEXPORT HRESULT TNHandleCatchGeneric(void);









#else //__TNCONTROL_EXCEPTIONS__
//#pragma message("__TNCONTROL_EXCEPTIONS__ already included!")
#endif //__TNCONTROL_EXCEPTIONS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\excptns.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\excptns.h"
#include "..\tncommon\stack.h"
#include "..\tncommon\strutils.h"

#include "tncontrl.h"
#include "main.h"

#include "excptns.h"







#ifndef _XBOX // We don't support GetModuleFileName and this function ultimately depends on it
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNHandleCatchExceptionList()"
//==================================================================================
// TNHandleCatchExceptionList
//----------------------------------------------------------------------------------
//
// Description: Handles a thrown exception list.
//
// Arguments:
//	PTNEXCEPTIONSLIST pExceptions	Pointer to exception object thrown.
//	PTNTESTRESULT pTestResult		Pointer to test result to set to the exception
//									thrown.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT TNHandleCatchExceptionList(PTNEXCEPTIONSLIST pExceptions,
									PTNTESTRESULT pTestResult)
{
	HRESULT			hr;
	PTNEXCEPTION	pException;
	TNGETSTACKDATA	gsd;
	PVOID			pvCallersCaller;
	char			szModule[256];
	char			szSection[256];
	char			szFile[256];
	int				iLineNum;
	char			szInfoString[256];
	DWORD			dwNoteAge;

	
	pException = (PTNEXCEPTION) pExceptions->GetItem(0);
	if (pException == NULL)
	{
		DPL(0, "Couldn't get first exception in list!", 0);
		return (E_FAIL);
	} // end if (couldn't get first item)
	
	hr = pException->PrintSelf();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't have most recent exception print itself!", 0);
		return (hr);
	} // end if (failed printself)

	(*pTestResult) = pException->m_dwExceptionCode;
	


	if (TNDebugGetThreadBlockNote(GetCurrentThreadId(), szModule, szSection, szFile, &iLineNum, szInfoString, &dwNoteAge))
	{
		DPL(0, "Last known position (%u ms ago) = %s:%s (%s line %i) \"%s\".",
			6, dwNoteAge, szModule, szSection, szFile, iLineNum, szInfoString);
	} // end if (got last known thread position)
	

	
	ZeroMemory(&gsd, sizeof (TNGETSTACKDATA));
	gsd.dwSize = sizeof (TNGETSTACKDATA);
	gsd.fCallStack = TRUE;
	TNStackGetCallersAddress(&(gsd.pvIgnoreCallsAboveFunction), &pvCallersCaller);
	gsd.dwRawStackDepth = 250;
	hr = TNStackGetStackForCurrentThread(&gsd);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get stack for this thread!", 0);
		return (hr);
	} // end if (failed getting the stack for the current thread)


	//BUGBUG make runtime option
	DEBUGBREAK();


	return (S_OK);
} // TNHandleCatchExceptionList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // We don't support GetModuleFileName and this function ultimately depends on it
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNHandleCatchGeneric()"
//==================================================================================
// TNHandleCatchGeneric
//----------------------------------------------------------------------------------
//
// Description: Handles a generic exception.
//
// Arguments: None.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT TNHandleCatchGeneric(void)
{
	HRESULT			hr;
	TNGETSTACKDATA	gsd;
	PVOID			pvCallersCaller;
	char			szModule[256];
	char			szSection[256];
	char			szFile[256];
	int				iLineNum;
	char			szInfoString[256];
	DWORD			dwNoteAge;
	char			szTemp[1024];



	if (TNDebugGetThreadBlockNote(GetCurrentThreadId(), szModule, szSection, szFile, &iLineNum, szInfoString, &dwNoteAge))
	{
		DPL(0, "Last known position (%u ms ago) = %s:%s (%s line %i) \"%s\".",
			6, dwNoteAge, szModule, szSection, szFile, iLineNum, szInfoString);
	} // end if (got last known thread position)
	

	ZeroMemory(&gsd, sizeof (TNGETSTACKDATA));
	gsd.dwSize = sizeof (TNGETSTACKDATA);
	gsd.fCallStack = TRUE;
	TNStackGetCallersAddress(&(gsd.pvIgnoreCallsAboveFunction), &pvCallersCaller);
	gsd.dwRawStackDepth = 250;
	hr = TNStackGetStackForCurrentThread(&gsd);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get stack for this thread!", 0);
		return (hr);
	} // end if (failed getting the stack for the current thread)

	StringGetCurrentDateStr(szTemp);
	StringPrepend(szTemp, "Exception mem log dump printed ");
	
	//BUGBUG I'm not sure I like forced memlog dump locations like this
	TNDebugDumpMemoryLogToFile("reports\\exception.txt", szTemp, TRUE);


	//BUGBUG make runtime option
	DEBUGBREAK();

	
	return (S_OK);
} // TNHandleCatchGeneric
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\faultsim.h ===
#ifndef __TNCONTROL_FAULTSIM__
#define __TNCONTROL_FAULTSIM__
//#pragma message("Defining __TNCONTROL_FAULTSIM__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNFaultSim:public LLITEM
{
	// These are friends so that they can access the protected members
	friend CTNExecutor;
	friend CTNExecutorPriv;
	friend CTNFaultSimIMTest;
	friend CTNMachineInfo;


	protected:
		DWORD	m_dwID; // ID of this fault sim object
		BOOL	m_fInitialized; // whether this object has been initialized or not
		HANDLE	m_hExclusiveLock; // handle to mutex preventing multi-thread/process access



		CTNFaultSim(void);
		virtual ~CTNFaultSim(void);


		HRESULT EnsureExclusiveUse(void);
		HRESULT RelenquishExclusiveUse(void);

		// Virtual functions which the derived classes should implement as well.
		virtual HRESULT Initialize(PVOID pvInitData, DWORD dwInitDataSize);
		virtual HRESULT Release(void);

		// Pure virtuals.  The derived classes must implement these because we sure
		// don't.
		virtual BOOL IsInstalledAndCanBeRun(void) = 0;

		virtual HRESULT SetBandwidth(BOOL fSend, DWORD dwHundredBytesPerSec) = 0;
		virtual HRESULT SetLatency(BOOL fSend, DWORD dwMSDelay) = 0;
		virtual HRESULT SetDropPacketsPercent(BOOL fSend, DWORD dwPercent) = 0;
		virtual HRESULT Reconnect(BOOL fSend) = 0;
		virtual HRESULT Disconnect(BOOL fSend) = 0;

		/*
		virtual HRESULT SetDropPacketsPattern(BOOL fSend, char* szPatternString) = 0;
		virtual HRESULT CorruptPackets(BOOL fSend, ?) = 0;
		virtual HRESULT ReorderPackets(BOOL fSend, ?) = 0;
		*/
};

class DLLEXPORT CTNFaultSimList:public LLIST
{
	/*
	// This is a friend so it can access the protected members
	friend CTNSlave;

	public:
		CTNFaultSimList(void);
		virtual ~CTNFaultSimList(void);
	*/
};






#else //__TNCONTROL_FAULTSIM__
//#pragma message("__TNCONTROL_FAULTSIM__ already included!")
#endif //__TNCONTROL_FAULTSIM__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\executor.h ===
#ifndef __TNCONTRL_EXECUTOR__
#define __TNCONTRL_EXECUTOR__
//#pragma message("Defining __TNCONTRL_EXECUTOR__")






//==================================================================================
// Common Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG




//==================================================================================
// External Structures
//==================================================================================
typedef struct tagTNEXECUTORINITBYSLAVEDATA
{
	// Pointer to slave object this executor represents.  This must be non-NULL.
	PTNSLAVE						pOwningSlave;

	// The mode this session will be run in (TNMODE_xxx).
	DWORD							dwMode;

	// Pointer to structure that uniquely identifies the calling application and
	// version of that app.
	PTNMODULEID						pModuleID;

	// Pointer to root testnet path.  Must end in a backslash.
	char*							pszTestNetRootPath;

	// Array of procedures that will be called to retrieve the total test list.
	// At least one entry required.
	PTNLOADTESTTABLEPROC*			apfnLoadTestTable;

	// Number of procedures in preceding array.  At least one is required.
	DWORD							dwNumLoadTestTables;

	// Procedure that will be called to retrieve the list of binaries that the
	// module wants to make note of, and/or may swap during a test.  Optional.
	PTNADDIMPORTANTBINARIESPROC		pfnAddImportantBinaries;

	// Procedure that will be called just before testing begins, to allow the slave
	// a chance to create any objects and do preparation for testing if it needs to.
	// Optional.
	PTNINITIALIZETESTINGPROC		pfnInitializeTesting;

	// Procedure that will be called after testing has completed, to allow the slave
	// to free any resources allocated during testing. Optional.
	PTNCLEANUPTESTINGPROC			pfnCleanupTesting;

	// Procedure that will be called to retrieve the window for APIs that require
	// it.  Optional.
	PTNGETTESTINGWINDOWPROC			pfnGetTestingWindow;

	// Whether CoInitialize (or CoInitializeEx, if available) should be called to
	// setup the testthread.
	BOOL							fInitializeCOMInTestThread;

	// Whether to prompt user for action if test thread has problems shutting down
	// or not.
	BOOL							fPromptTestThreadDieTimeout;

	// Handle to an manual-reset event that the app can set when it wants to abort
	// or cancel the session.  Optional.
	HANDLE							hUserCancelEvent;

	// Optional path to file to use when writing ErrToSrc data.
	char*							pszErrToSrcFilepath;

	// Optional search path to redirect ErrToSrc filepaths.
	char*							pszErrToSrcPathSearch;

	// Optional replace path to redirect ErrToSrc filepaths.
	char*							pszErrToSrcPathReplace;

	// Optional path to file to use when writing documentation build data.
	char*							pszDocFilepath;

	// Number of other slave instances on this machine.  Used to generate a unique
	// computer name.
	int								iMultiInstanceNum;
} TNEXECUTORINITBYSLAVEDATA, * PTNEXECUTORINITBYSLAVEDATA;





//==================================================================================
// Prototypes
//==================================================================================
DWORD WINAPI ExecutorTestThreadProc(LPVOID lpvParameter);





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNExecutorPriv
{
	// These are friends so they can access the protected members
	friend CTNExecutor;
	friend DWORD WINAPI ExecutorTestThreadProc(LPVOID lpvParameter);
	friend CTNSlave;
	friend DWORD WINAPI SlavePeriodicSendThreadProc(LPVOID lpvParameter);
#ifndef _XBOX // no IPC supported
	friend CTNIPCObject;
	friend CTNLeech;
	friend CTNLeechesList;
#endif // ! XBOX


	private:
		HANDLE						m_hTestThread; // the test thread
		HANDLE						m_hKillTestThreadEvent; // when to kill the test thread
		HANDLE						m_hNewTestEvent; // set when there is a new test for the thread to run

		CTNTestSsList				m_queuedtests; // list of tests queued up to run
		PTNTESTINSTANCES			m_pTest; // test to run
		CTNTestSsList				m_ongoingtests; // list of ongoing tests we're still working on
		CTNResultsChain				m_results; // list of all results for this machine

		BOOL						m_fInitCOMForTestThread; // whether the test thread should initialize COM
		PTNINITIALIZETESTINGPROC	m_pfnInitializeTesting; // callback to use to prep for testing
		PTNCLEANUPTESTINGPROC		m_pfnCleanupTesting; // callback to use to clean up after testing
		PTNGETTESTINGWINDOWPROC		m_pfnGetTestingWindow; // callback to use to retrieve testing window

		HANDLE						m_hErrToSrcFile; // handle to file being used to write ErrToSrc data
		char*						m_pszErrToSrcPathSearch; // pointer to ErrToSrc path strings to search for
		char*						m_pszErrToSrcPathReplace;  // pointer to ErrToSrc path strings to replace with
		HANDLE						m_hDocFile; // handle to file being used to write documentation-build data

		BOOL						m_fPromptTestThreadDieTimeout; // boolean whether we should prompt for action when test thread has problems shutting down


	protected:
		CTNMachineInfo				m_info; // information about this machine object
		DWORD						m_dwMode; // what mode this object is in (TNMODE_xxx)
		TNMODULEID					m_moduleID; // ID of module using us
		HANDLE						m_hUserCancelEvent; // event given to us by user, set when the user wants to abort

		DWORD						m_dwTestThreadID; // ID of the test thread
		BOOL						m_fDeadlockCheck; // whether to do the deadlock check or not
		DWORD						m_dwLastTestthreadPing; // last time we heard from the test thread

		PTNSLAVE					m_pOwningSlave; // pointer to slave object this executor represents

#ifndef _XBOX // no IPC supported
		PTNLEECH					m_pOwningLeech; // pointer to leech object this executor represents
#endif // ! XBOX

		TNCTRLMACHINEID				m_id; // ID to identify this object in the control session
		CTNTestTableGroup			m_testtable; // table of tests generated from the module

#ifndef _XBOX // no IPC supported
		CTNLeechesList				m_leeches; // list of leech processes attached to this object
#endif // ! XBOX

		CTNFaultSimList				m_faultsims; // list of fault simulator objects used by this object

		
		DLLSAFE_NEWS_AND_DELETES;

		CTNExecutorPriv(void);
		virtual ~CTNExecutorPriv(void);


		HRESULT InitializeBySlave(PTNEXECUTORINITBYSLAVEDATA pTNeibsd);

		HRESULT Cleanup(void);

		HRESULT StartTestThread(void);

		HRESULT KillTestThread(BOOL fKillingSelf);

		HRESULT HandleNewTest(DWORD dwUniqueTestID,
							char* pszCaseID, char* pszInstanceID,
							int iNumMachines, PTNCTRLMACHINEID aTesters,
							PVOID pvInputData, DWORD dwInputDataSize);

		HRESULT HandleAnnounceResponse(DWORD dwResponseID, DWORD dwUniqueTestID);

		HRESULT HandleSyncResponse(DWORD dwResponseID, PVOID pvData, DWORD dwDataSize);

		HRESULT HandleLostTester(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
								int iLostTesterNum);

		HRESULT HandleGetMachineInfoResponse(DWORD dwResponseID, PVOID pvData,
											DWORD dwDataSize);

		HRESULT DoTestThread(void);

		HRESULT LogInternal(DWORD dwLogStringType, char* szString);

		HRESULT SprintfLogInternal(DWORD dwLogStringType, char* szFormatString,
								DWORD dwNumParms, ...);

		HRESULT ReportInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
								BOOL fTestComplete, BOOL fSuccess,
								BOOL fExecCaseExitReport,
								PVOID pvOutputData, DWORD dwOutputDataSize,
								PTNOUTPUTVARSLIST pOutputVars);

		HRESULT WarnInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
							PVOID pvUserData, DWORD dwUserDataSize);

		HRESULT CreateSubTest(PTNTESTINSTANCES pParentTest,
								PTNTESTTABLECASE pCase,
								int iNumMachines,
								PTNCTRLMACHINEID aTesters);

		HRESULT SyncInternal(PTNTESTINSTANCES pTest,
							char* szSyncName,
							PVOID pvSendData,
							DWORD dwSendDataSize,
							PTNSYNCDATALIST pReceiveData,
							int iNumMachines,
							int* aiTesters);

		BOOL IsTesterOnSameMachineInternal(PTNTESTINSTANCES pTest,
											int iTesterNum);

		HRESULT GetTesterIPInternal(PTNTESTINSTANCES pTest, int iTesterNum,
									WORD wPort, char* szIPString);

		HRESULT GetTesterPhoneNumInternal(PTNTESTINSTANCES pTest, int iTesterNum,
										char* szPhoneNumber);

		HRESULT GetTesterCOMPortInternal(PTNTESTINSTANCES pTest, int iTesterNum,
										DWORD* lpdwCOMPort);

		PTNTESTINSTANCES GetTest(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID);

		PTNTESTINSTANCES GetLeechTest(DWORD dwLeechTopLevelUniqueID,
										DWORD dwTestUniqueID);

		HRESULT RunTest(PTNTESTINSTANCES pTest, PVOID pvInputData,
						DWORD dwInputDataSize);

		HRESULT FreeResultsInternal(char* pszCaseID, char* pszInstanceID,
									PTNTESTINSTANCES pUserCallingTest);

		HRESULT FreeOutputVarsInternal(char* pszCaseID, char* pszInstanceID,
									char* pszName, char* pszType,
									BOOL fFreeData,
									PTNTESTINSTANCES pUserCallingTest);

		HRESULT GetTestersMachineInfoInternal(PTNTESTINSTANCES pTest,
											int iTesterNum,
											PTNMACHINEINFO* ppInfo);

		HRESULT DoDocumentation(PTNTESTTABLEITEM pItem);
};


class DLLEXPORT CTNExecutor
{
	// These are friends so they can access the protected members
	friend CTNExecutorPriv;


	private:
		PTNEXECUTORPRIV		m_pRealExecutor; // pointer to real executor class
		PTNTESTINSTANCES	m_pTest; // test being run
		char*				m_pszTestSectionName; // string name of most recent test section name
		char*				m_pszTestSectionFilepath; // string with most recent test section source file path
		int					m_iTestSectionLineNum; // most recent test section source line number


	protected:
		DLLSAFE_NEWS_AND_DELETES;

		CTNExecutor(PTNEXECUTORPRIV pRealExecutor, PTNTESTINSTANCES pTest);
		virtual ~CTNExecutor(void);


	public:
		BOOL IsCase(char* szCaseID);

		HWND GetTestingWindow(void);

		HRESULT FirstBinIsVersion(char* szBinaryName, DWORD dwHighVersion,
									DWORD dwLowVersion, BOOL* pfResult);

		HRESULT FirstBinIsAtLeastVersion(char* szBinaryName, DWORD dwHighVersion,
										DWORD dwLowVersion, BOOL* lpfResult);

		HRESULT Log(DWORD dwFlags, char* szFormatString, DWORD dwNumParms, ...);

		HRESULT Report(HRESULT hresult, BOOL fSuccess);

		HRESULT Warn(HRESULT hresult, PVOID pvUserData, DWORD dwUserDataSize);

		HRESULT WaitForEventOrCancel(HANDLE* pahEvents, int iNumEvents,
									int* paiRelevantTesters, int iNumRelevantTesters,
									DWORD dwTimeout, int* piItemNum);

		HRESULT ExecSubTestCase(char* szCaseModuleID, PVOID pvSubInputData,
								DWORD dwSubInputDataSize, int iNumMachines, ...);

		HRESULT ExecSubTestCaseArray(char* szCaseModuleID, PVOID pvSubInputData,
									DWORD dwSubInputDataSize, int iNumMachines,
									int* aiTesterArray);

		HRESULT SyncWithTesters(char* szSyncName,
								PVOID pvSendData,
								DWORD dwSendDataSize,
								PTNSYNCDATALIST pReceiveData,
								int iNumMachines, ...);

		HRESULT SyncWithTestersArray(char* szSyncName,
									PVOID pvSendData,
									DWORD dwSendDataSize,
									PTNSYNCDATALIST pReceiveData,
									int iNumMachines,
									int* aiTesters);

		BOOL IsTesterOnSameMachine(int iTesterNum);

		HRESULT GetTestersIPForPort(int iTesterNum, WORD wPort,
									char* szIPString);

		HRESULT GetFirstTAPIDeviceNameWithNumber(char** ppszDeviceName);

		HRESULT GetPhoneNumberForTester(int iTesterNum, char* szPhoneNumber);

		HRESULT GetCOMPortConnectedToTester(int iTesterNum, DWORD* pdwCOMPort);

#ifndef _XBOX // no IPC supported
		HRESULT CreateNewLeechAttachment(PTNLEECH* ppLeech,
										PVOID pvSendConnectData,
										DWORD dwSendConnectDataSize);

		HRESULT DetachAndReleaseLeech(PTNLEECH* ppLeech);

		HRESULT AllowStaticIDAttachment(PTNLEECH pLeech, char* szPreplannedID);

		HRESULT WaitForLeechConnection(PTNLEECH pTNLeech, DWORD dwTimeout);

		HRESULT GetLeechConnectData(PTNLEECH pTNLeech, PVOID* ppvData,
									DWORD* pdwDataSize);

		HRESULT ExecLeechTestCase(PTNLEECH pLeech, char* szCaseModuleID,
								PVOID pvLeechInputData, DWORD dwLeechInputDataSize,
								int iNumMachines, ...);

		HRESULT ExecLeechTestCaseArray(PTNLEECH pLeech, char* szCaseModuleID,
									PVOID pvLeechInputData, DWORD dwLeechInputDataSize,
									int iNumMachines, int* aiTesterArray);
#endif // ! XBOX

		HRESULT CreateNewFaultSim(PTNFAULTSIM* ppFaultSim, DWORD dwFaultSimID,
									PVOID pvInitData, DWORD dwInitDataSize);

		HRESULT ReleaseFaultSim(PTNFAULTSIM* ppFaultSim);

		HRESULT SetFaultSimBandwidth(PTNFAULTSIM pFaultSim,
									BOOL fSend, DWORD dwHundredBytesPerSec);
		HRESULT SetFaultSimLatency(PTNFAULTSIM pFaultSim,
									BOOL fSend, DWORD dwMSDelay);
		HRESULT SetFaultSimDropPacketsPercent(PTNFAULTSIM pFaultSim,
											BOOL fSend, DWORD dwPercent);
		/*
		HRESULT SetFaultSimDropPacketsPattern(PTNFAULTSIM pFaultSim,
											BOOL fSend, char* szPatternString);
		HRESULT FaultSimCorruptPackets(PTNFAULTSIM pFaultSim,
										BOOL fSend, ?);
		HRESULT FaultSimReorderPackets(PTNFAULTSIM pFaultSim,
										BOOL fSend, ?);
		*/

		HRESULT FaultSimReconnect(PTNFAULTSIM pFaultSim,
									BOOL fSend);
		
		HRESULT FaultSimDisconnect(PTNFAULTSIM pFaultSim,
									BOOL fSend);
		
		void NoteTestIsStillRunning(void);

		HRESULT SetDeadlockCheck(BOOL fOn);

		HRESULT FreeResults(char* pszCaseID, char* pszInstanceID);

		HRESULT FreeOutputVars(char* pszCaseID, char* pszInstanceID,
							char* pszName, char* pszType, BOOL fFreeData);

#ifndef _XBOX
		HRESULT PromptUser(char* szTitle, char* szMessageFormat,
							DWORD dwDialogType,
							PVOID pvDialogData, DWORD dwDialogDataSize,
							int* paiRelevantTesters, int iNumRelevantTesters,
							int* piResponse,
							DWORD dwNumParms, ...);
#endif // ! XBOX

		HRESULT GetMachineInfoForTester(int iTesterNum, PTNMACHINEINFO* ppInfo);
		HRESULT ReleaseMachineInfoForTester(PTNMACHINEINFO* ppInfo);

		HRESULT NoteBeginTestCase(char* szDebugModule,
									char* szDebugSection,
									char* szBeginTestCaseFilepath,
									int iBeginTestCaseLineNum);

		HRESULT NoteNewTestSection(char* szTestSectionName,
									char* szDebugModule,
									char* szDebugSection,
									char* szTestSectionFilepath,
									int iTestSectionLineNum);

		HRESULT NoteThrowTestResult(char* szThrowTestResultFilepath,
									int iThrowTestResultLineNum);

#ifndef _XBOX // no documentation builds supported
		HRESULT DocBuildBeginTestCase(char* szBeginTestCaseFilepath,
									int iBeginTestCaseLineNum);

		HRESULT DocBuildEndTestCase(char* szEndTestCaseFilepath,
									int iEndTestCaseLineNum);

		HRESULT DocBuildNewTestSection(char* szTestSectionName,
										char* szTestSectionFilepath,
										int iTestSectionLineNum);

		HRESULT DocBuildTestSectionControl(char* szControl,
										char* pszControlExpression,
										char* szControlFilepath,
										int iControlLineNum);
#endif // ! XBOX
};




#else //__TNCONTRL_EXECUTOR__
//#pragma message("__TNCONTRL_EXECUTOR__ already included!")
#endif //__TNCONTRL_EXECUTOR__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\faultsimimtest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock2 fn proto's, for getprocaddress
#ifndef _XBOX
#include <winsock2.h>
#else // ! XBOX
#include <winsockx.h>		// Needed for XnetInitialize
#endif // XBOX

#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\sprintf.h"

//#include "..\..\imtest\inc\imtcommon.h"
//#include "..\..\imtest\inc\imtlib.h"

#include "tncontrl.h"
#include "main.h"
#include "sendq.h"
#include "comm.h"
#include "commtcp.h"

#include "faultsim.h"
#include "faultsimimtest.h"




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::CTNFaultSimIMTest()"
//==================================================================================
// CTNFaultSimIMTest constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNFaultSimIMTest object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNFaultSimIMTest::CTNFaultSimIMTest(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNFaultSimIMTest));

	this->m_dwID = TN_FAULTSIM_IMTEST;
} // CTNFaultSimIMTest::CTNFaultSimIMTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::~CTNFaultSimIMTest()"
//==================================================================================
// CTNFaultSimIMTest destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNFaultSimIMTest object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNFaultSimIMTest::~CTNFaultSimIMTest(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNFaultSimIMTest::~CTNFaultSimIMTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::Initialize()"
//==================================================================================
// CTNFaultSimIMTest::Initialize
//----------------------------------------------------------------------------------
//
// Description: Sets up this object, and prepares it for use.
//
// Arguments:
//	LPVOID lpvInitData		Pointer to data to use when initializing.
//	DWORD dwInitDataSize	Size of data to use when initializing.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSimIMTest::Initialize(LPVOID lpvInitData, DWORD dwInitDataSize)
{
#ifndef _XBOX // fault simulation not supported at this time
	HRESULT				hr;
	BOOL				fEnsuredExclusiveUse = FALSE;
	BOOL				fInitted = FALSE;
	IM_GLOBAL_PROPERTY	imgp;
	BOOL				fSourcePortSet = FALSE;
	BOOL				fDestPortSet = FALSE;


	DPL(9, "==>(%x, %u)", 2, lpvInitData, dwInitDataSize);

	hr = this->EnsureExclusiveUse();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't ensure exclusive use!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't ensure exclusive use)

	fEnsuredExclusiveUse = TRUE;


	hr = InitializeIMTest();
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't initialize IMTest driver!", 0);
		goto ERROR_EXIT;
	} // end if (failed initting IMTest)

	fInitted = TRUE;


	// Tell the driver to ignore incoming control layer traffic.
	ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
	imgp.ulGlobalProperty = GI_IGNORE_IP_SOURCE_PORT;
	imgp.ulFlagEnable = 1;
	//imgp.ucData = 0;
	imgp.ulValue = CTRLCOMM_TCPIP_PORT; // port control layer uses

	hr = SetIMGlobalProperty(&imgp);
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't tell IMTest to leave incoming control layer traffic alone!", 0);
		goto ERROR_EXIT;
	} // end if (failed turning IMTest property on)

	fSourcePortSet = TRUE;


	// Tell the driver to ignore outgoing control layer traffic.
	ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
	imgp.ulGlobalProperty = GI_IGNORE_IP_DESTINATION_PORT;
	imgp.ulFlagEnable = 1;
	//imgp.ucData = 0;
	imgp.ulValue = CTRLCOMM_TCPIP_PORT; // port control layer uses

	hr = SetIMGlobalProperty(&imgp);
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't tell IMTest to leave outgoing control layer traffic alone!", 0);
		goto ERROR_EXIT;
	} // end if (failed turning IMTest property on)

	fDestPortSet = TRUE;


	// Tell the driver to ignore Address Resolution Protocol traffic.
	ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
	imgp.ulGlobalProperty = GI_IGNORE_ARP;
	imgp.ulFlagEnable = 1;
	//imgp.ucData = 0;
	//imgp.ulValue = 0;

	hr = SetIMGlobalProperty(&imgp);
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't tell IMTest to leave ARP traffic alone!", 0);
		goto ERROR_EXIT;
	} // end if (failed turning IMTest property on)



	DPL(9, "<== S_OK", 0);

	return (S_OK);


ERROR_EXIT:

	if (fDestPortSet)
	{
		ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
		imgp.ulGlobalProperty = GI_IGNORE_IP_DESTINATION_PORT;
		//imgp.ulFlagEnable = 0;
		//imgp.ucData = 0;
		//imgp.ulValue = 0;

		// Ignore error
		SetIMGlobalProperty(&imgp);

		fDestPortSet = FALSE;
	} // end if (dest port set to be ignored)

	if (fSourcePortSet)
	{
		ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
		imgp.ulGlobalProperty = GI_IGNORE_IP_SOURCE_PORT;
		//imgp.ulFlagEnable = 0;
		//imgp.ucData = 0;
		//imgp.ulValue = 0;

		// Ignore error
		SetIMGlobalProperty(&imgp);

		fSourcePortSet = FALSE;
	} // end if (source port set to be ignored)

	if (fInitted)
	{
		CleanupIMTest();
		fInitted = FALSE;
	} // end if (initialized driver)

	if (fEnsuredExclusiveUse)
	{
		// Ignore error
		this->RelenquishExclusiveUse();
		fEnsuredExclusiveUse = FALSE;
	} // end if (we took the lock)

	DPL(9, "<== %e", 1, hr);

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "No fault simulation supported at this time.")
	return S_OK;
#endif // XBOX
} // CTNFaultSimIMTest::Initialize
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::Release()"
//==================================================================================
// CTNFaultSimIMTest::Release
//----------------------------------------------------------------------------------
//
// Description: Releases this object after a successful call to Initialize.  Must be
//				done prior to deletion.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSimIMTest::Release(void)
{
#ifndef _XBOX // fault simulation not supported at this time
	HRESULT				hr = S_OK;
	//IM_GLOBAL_PROPERTY	imgp;


	DPL(9, "==>", 0);


	hr = ResetGlobalProperties();
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't reset/turn off all properties!", 0);
		goto DONE;
	} // end if (couldn't reset properties)


	CleanupIMTest();
	

	hr = this->RelenquishExclusiveUse();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't relenquish exclusive use!", 0);
		goto DONE;
	} // end if (couldn't relenquish exclusive use)


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "No fault simulation supported at this time.")
	return S_OK;
#endif // XBOX
} // CTNFaultSimIMTest::Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::IsInstalledAndCanBeRun()"
//==================================================================================
// CTNFaultSimIMTest::IsInstalledAndCanBeRun
//----------------------------------------------------------------------------------
//
// Description: Sets up this object, and prepares it for use.
//
// Arguments:
//	LPVOID lpvInitData		Pointer to data to use when initializing.
//	DWORD dwInitDataSize	Size of data to use when initializing.
//
// Returns: TRUE if the fault simulator is installed, FALSE if not.
//==================================================================================
BOOL CTNFaultSimIMTest::IsInstalledAndCanBeRun(void)
{
#ifndef _XBOX // fault simulation not supported at this time
	HRESULT			hr;
	BOOL			fResult = FALSE;
	OSVERSIONINFO	ovi;


	// Check to see if we're on a Windows 2000 platform

	ZeroMemory(&ovi, sizeof (OSVERSIONINFO));
	ovi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	if (! GetVersionEx(&ovi))
		goto DONE;

	if (! (ovi.dwPlatformId & VER_PLATFORM_WIN32_NT))
	{
		DPL(5, "Not Windows 2000 (non-NT OS v%i.%i.%i), IMTest not supported.",
			3, HIBYTE(HIWORD(ovi.dwBuildNumber)),
			LOBYTE(HIWORD(ovi.dwBuildNumber)),
			LOWORD(ovi.dwBuildNumber));
		goto DONE;
	} // end if (not Windows 2000)

	if (ovi.dwMajorVersion < 5)
	{
		DPL(5, "NT based OS, but not Windows 2000 (v%i.%i.%i), IMTest not supported.",
			3, ovi.dwMajorVersion, ovi.dwMinorVersion, ovi.dwBuildNumber);
		goto DONE;
	} // end if (not Windows 2000)


	// Try initializing IMTest.  If it fails, it's probably not installed.

	hr = InitializeIMTest();
	if (hr != ERROR_SUCCESS)
	{
		DPL(3, "Couldn't initialize IMTest, assuming not installed.  %e",
			1, hr);
		goto DONE;
	} // end if (couldn't initialize driver)

	CleanupIMTest();

	DPL(3, "IMTest driver appears to be installed.", 0);
	fResult = TRUE;


DONE:

	return (fResult);
#else // ! XBOX
#pragma TODO(tristanj, "No fault simulation supported at this time.")
	return FALSE;
#endif // XBOX
} // CTNFaultSimIMTest::IsInstalledAndCanBeRun
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::SetBandwidth()"
//==================================================================================
// CTNFaultSimIMTest::SetBandwidth
//----------------------------------------------------------------------------------
//
// Description: Sets the artificial send or receive bandwidth limit for this object.
//				Pass in zero to turn bandwidth limiting off.
//
// Arguments:
//	BOOL fSend					TRUE to limit the send (outgoing) bandwidth, FALSE
//								to limit the receive (incoming) bandwidth.
//	DWORD dwHundredBytesPerSec	Rate to constrict the bandwidth to, or 0 for none.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSimIMTest::SetBandwidth(BOOL fSend, DWORD dwHundredBytesPerSec)
{
#ifndef _XBOX // fault simulation not supported at this time
	HRESULT				hr;
	IM_GLOBAL_PROPERTY	imgp;


	ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
	imgp.ulGlobalProperty = (fSend) ? GI_LINK_SEND_SPEED : GI_LINK_RECEIVE_SPEED;
	imgp.ulFlagEnable = (dwHundredBytesPerSec == 0) ? 0: 1;
	//imgp.ucData = 0;
	imgp.ulValue = dwHundredBytesPerSec;

	hr = SetIMGlobalProperty(&imgp);
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't set IMTest bandwidth limiter!", 0);
		goto DONE;
	} // end if (failed setting IMTest property)


DONE:

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "No fault simulation supported at this time.")
	return S_OK;
#endif // XBOX
} // CTNFaultSimIMTest::SetBandwidth
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::SetLatency()"
//==================================================================================
// CTNFaultSimIMTest::SetLatency
//----------------------------------------------------------------------------------
//
// Description: Sets the artificial send or receive latency for this object.
//				Pass in zero to turn artificial latency off.
//
// Arguments:
//	BOOL fSend			TRUE to incur the latency on sends (outgoing data), FALSE to
//						incur the latency on receives (incoming data).
//	DWORD dwMSDelay		Number of milliseconds to increase the latency by, or 0 for
//						none.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSimIMTest::SetLatency(BOOL fSend, DWORD dwMSDelay)
{
#ifndef _XBOX // fault simulation not supported at this time
	HRESULT				hr;
	IM_GLOBAL_PROPERTY	imgp;


	ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
	imgp.ulGlobalProperty = (fSend) ? GI_DELAY_SENDS : GI_DELAY_RECVS;
	imgp.ulFlagEnable = (dwMSDelay == 0) ? 0: 1;
	//imgp.ucData = 0;
	imgp.ulValue = dwMSDelay;

	hr = SetIMGlobalProperty(&imgp);
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't set IMTest latency!", 0);
		goto DONE;
	} // end if (failed setting IMTest property)


DONE:

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "No fault simulation supported at this time.")
	return S_OK;
#endif // XBOX
} // CTNFaultSimIMTest::SetLatency
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::SetDropPacketsPercent()"
//==================================================================================
// CTNFaultSimIMTest::SetDropPacketsPercent
//----------------------------------------------------------------------------------
//
// Description: Sets the percentage of sent or received packets which should be
//				randomly dropped.
//				Pass 0 to turn function off.
//
// Arguments:
//	BOOL fSend			TRUE to set the drop percentage for sends (outgoing data),
//						FALSE to set the drop percentage for receives (incoming
//						data).
//	DWORD dwPercent		Percentage of packets to randomly drop, or 0 for none.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSimIMTest::SetDropPacketsPercent(BOOL fSend, DWORD dwPercent)
{
#ifndef _XBOX // fault simulation not supported at this time
	HRESULT				hr;
	IM_GLOBAL_PROPERTY	imgp;


	ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
	imgp.ulGlobalProperty = (fSend) ? GI_SIMULATE_SEND_LOSS_OF_PACKETS : GI_SIMULATE_RECV_LOSS_OF_PACKETS;
	imgp.ulFlagEnable = (dwPercent == 0) ? 0: 1;
	//imgp.ucData = 0;
	imgp.ulValue = dwPercent;

	hr = SetIMGlobalProperty(&imgp);
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't set IMTest latency!", 0);
		goto DONE;
	} // end if (failed setting IMTest property)


DONE:

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "No fault simulation supported at this time.")
	return S_OK;
#endif // XBOX
} // CTNFaultSimIMTest::SetDropPacketsPercent
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::Reconnect()"
//==================================================================================
// CTNFaultSimIMTest::Reconnect
//----------------------------------------------------------------------------------
//
// Description: Re-enables the connection.
//
// Arguments:
//	BOOL fSend	Determines whether to set the send/receive for disconnecting
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSimIMTest::Reconnect(BOOL fSend)
{
#ifndef _XBOX // fault simulation not supported at this time
	HRESULT				hr;
	IM_GLOBAL_PROPERTY	imgp;


	ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
	imgp.ulGlobalProperty = (fSend) ? GI_DONT_SEND_PKTS : GI_DONT_RECV_PKTS;
	imgp.ulFlagEnable = 0;
	
	hr = SetIMGlobalProperty(&imgp);
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't set IMTest Reconnect(fSend = %d)!", 1, fSend);
		goto DONE;
	} // end if (failed setting IMTest property)


DONE:

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "No fault simulation supported at this time.")
	return S_OK;
#endif // XBOX
} // CTNFaultSimIMTest::Reconnect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSimIMTest::Disconnect()"
//==================================================================================
// CTNFaultSimIMTest::Disconnect
//----------------------------------------------------------------------------------
//
// Description: Terminates the specified connection.
//
// Arguments:
//	BOOL fSend	Determines whether to set the send/receive for disconnecting
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSimIMTest::Disconnect(BOOL fSend)
{
#ifndef _XBOX // fault simulation not supported at this time
	HRESULT				hr;
	IM_GLOBAL_PROPERTY	imgp;


	ZeroMemory(&imgp, sizeof (IM_GLOBAL_PROPERTY));
	imgp.ulGlobalProperty = (fSend) ? GI_DONT_SEND_PKTS : GI_DONT_RECV_PKTS;
	imgp.ulFlagEnable = 1;
	
	hr = SetIMGlobalProperty(&imgp);
	if (hr != ERROR_SUCCESS)
	{
		DPL(0, "Couldn't set IMTest Disconnect(fSend = %d)!", 1, fSend);
		goto DONE;
	} // end if (failed setting IMTest property)


DONE:

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "No fault simulation supported at this time.")
	return S_OK;
#endif // XBOX
} // CTNFaultSimIMTest::Disconnect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\info.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#ifndef _XBOX
#include <winsock.h>
#else // ! XBOX
#include <stdio.h>		// Needed for ANSI/Unicode conversion
#include <stdlib.h>		// Needed for ANSI/Unicode conversion
#include <winsockx.h>	// Needed for XnetInitialize
#endif // XBOX


#include <wsipx.h>

#ifndef _XBOX // no TAPI supported
#include <tapi.h>
#endif

#include <mmreg.h> // NT BUILD requires this before dsound.h
#include <dsound.h>


// We set the version to 4 so we don't go getting extra elements in our RASCONN
// structure (otherwise we might build with a larger size that earlier versions of
// RAS barf on)
#ifdef WINVER
#undef WINVER
#endif // WINVER
#define WINVER	0x0400
#include <ras.h>
#include <raserror.h>


#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\verutils.h"

#include "tncontrl.h"
#include "main.h"

#include "tapidevs.h"
#include "faultsim.h"
#include "faultsimimtest.h"

#include "info.h"





//==================================================================================
// Defines
//==================================================================================
#define REQUIRED_TAPI_VERSION			0x00010003 // v1.3
//#define REQUIRED_TAPI_VERSION			0x00010004 // v1.4
//#define REQUIRED_TAPI_VERSION			0x00020000 // v2.0

#define MAX_TAPI_VERSION				REQUIRED_TAPI_VERSION
//#define MAX_TAPI_VERSION				TAPI_CURRENT_VERSION


#define LINEDEVCAPS_BUFFER_INCREMENT	1024 // in bytes




//==================================================================================
// RAS function type definitions
//==================================================================================
typedef DWORD	(FAR PASCAL *PRASENUMCONNECTIONSAPROC)		(LPRASCONNA, LPDWORD, LPDWORD);
typedef DWORD	(FAR PASCAL *PRASGETCONNECTSTATUSAPROC)		(HRASCONN, LPRASCONNSTATUSA);



//==================================================================================
// TAPI function type definitions
//==================================================================================
#ifndef _XBOX // no TAPI supported
typedef LONG	(FAR PASCAL *PLINEINITIALIZEPROC)			(LPHLINEAPP, HINSTANCE,
															LINECALLBACK, LPCSTR,
															LPDWORD);
typedef LONG	(FAR PASCAL *PLINENEGOTIATEAPIVERSIONPROC)	(HLINEAPP, DWORD, DWORD,
															DWORD, LPDWORD,
															LPLINEEXTENSIONID);
typedef LONG	(FAR PASCAL *PLINEGETDEVCAPSPROC)			(HLINEAPP, DWORD, DWORD,
															DWORD, LPLINEDEVCAPS);
typedef LONG	(FAR PASCAL *PLINESHUTDOWNPROC)				(HLINEAPP);
#endif // ! XBOX


//==================================================================================
// DSound function type definitions
//==================================================================================
#ifndef _XBOX // no DirectSound callbacks for now
typedef HRESULT		(FAR PASCAL *PDIRECTSOUNDENUMERATEAPROC)	(LPDSENUMCALLBACKA,
																LPVOID);
#endif // ! XBOX





//==================================================================================
// Local structures
//==================================================================================
typedef struct tagTAPIDEVICECONTEXT
{
	PTNTAPIDEVICE	pDevice; // device we're looking for
	BOOL			fInSection; // whether we're in the section or not
} TAPIDEVICECONTEXT, * PTAPIDEVICECONTEXT;

typedef struct tagCOMPORTCONTEXT
{
	PTNCOMPORT		pCOMPort; // COM port object we're looking for
	BOOL			fInSection; // whether we're in the section or not
} COMPORTCONTEXT, * PCOMPORTCONTEXT;



//==================================================================================
// Local prototypes
//==================================================================================
void FAR PASCAL InfoLineCallbackProc(DWORD hDevice, DWORD dwMsg, DWORD_PTR dwContext,
									DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);

HRESULT SearchForTAPIDeviceReadFileCB(char* szLine, PFILELINEINFO pInfo,
									PVOID pvContext, BOOL* pfStopReading);
HRESULT SearchForCOMPortReadFileCB(char* szLine, PFILELINEINFO pInfo,
									PVOID pvContext, BOOL* pfStopReading);

BOOL CALLBACK DSEnumCallback(LPGUID lpGuid, LPCSTR lpcstrDescription,
							LPCSTR lpcstrModule, LPVOID lpvContext);





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::CTNMachineInfo()"
//==================================================================================
// CTNMachineInfo constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNMachineInfo object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNMachineInfo::CTNMachineInfo(void)
{
	//DPL(0, "this = %x, sizeof (this) = %u", 2, this, sizeof (CTNMachineInfo));


	ZeroMemory(this->m_szComputerName, MAX_COMPUTERNAME_SIZE * sizeof (char));
	ZeroMemory(this->m_szUserName, MAX_USERNAME_SIZE * sizeof (char));
#ifndef _XBOX
	ZeroMemory(&(this->m_os), sizeof (OSVERSIONINFO));
	this->m_os.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
#else
	ZeroMemory(&(this->m_os), sizeof (OSVERSIONINFOA));
	this->m_os.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA);
#endif

	this->m_wProcessorArchitecture = 0;
	this->m_dwNumberOfProcessors = 0;
	ZeroMemory(&(this->m_memstats), sizeof (MEMORYSTATUS));
	this->m_wWinSock = 0;
	this->m_fIPXInstalled = FALSE;
	this->m_fFaultSimIMTestAvailable = FALSE;

	this->m_pvUserData = NULL;
} // CTNMachineInfo::CTNMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::~CTNMachineInfo()"
//==================================================================================
// CTNMachineInfo destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNMachineInfo object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNMachineInfo::~CTNMachineInfo(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNMachineInfo::~CTNMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::IsNTBasedOS()"
//==================================================================================
// CTNMachineInfo::IsNTBasedOS
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this info represents a machine that is using a
//				Windows NT based operating system (NT4, Windows 2000 Professional).
//
// Arguments: None.
//
// Returns: TRUE if machine is NT, FALSE otherwise.
//==================================================================================
BOOL CTNMachineInfo::IsNTBasedOS(void)
{
	if (this->m_os.dwPlatformId == VER_PLATFORM_WIN32_NT)
		return (TRUE);

	return (FALSE);
} // CTNMachineInfo::IsNTBasedOS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::IsMillenniumOS()"
//==================================================================================
// CTNMachineInfo::IsMillenniumOS
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this info represents a machine that is using
//				Windows Millennium Edition.
//
// Arguments: None.
//
// Returns: TRUE if machine is Windows Millennium Edition, FALSE otherwise.
//==================================================================================
BOOL CTNMachineInfo::IsMillenniumOS(void)
{
	// 9x version 4.90.xxxx

	if (this->m_os.dwPlatformId == VER_PLATFORM_WIN32_NT)
		return (FALSE);

	if (HIBYTE(HIWORD(this->m_os.dwBuildNumber)) != 4)
		return (FALSE);

	if (LOBYTE(HIWORD(this->m_os.dwBuildNumber)) != 90)
		return (FALSE);

	return (TRUE);
} // CTNMachineInfo::IsMillenniumOS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::GetOSString()"
//==================================================================================
// CTNMachineInfo::GetOSString
//----------------------------------------------------------------------------------
//
// Description: Copies a string representation of the machine's OS version/type into
//				the buffer provided.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::GetOSString(char* szString)
{
	VerGetStrFromOSVersion(&(this->m_os), szString);

	return (S_OK);
} // CTNMachineInfo::GetOSString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::LoadLocalMachineInfo()"
//==================================================================================
// CTNMachineInfo::LoadLocalMachineInfo
//----------------------------------------------------------------------------------
//
// Description: Fills in this object with the information pertaining to this
//		      machine.
//
// Arguments:
//	char* szTestnetRootPath									Path to root testnet
//															directory.  Should end
//															in a backslash.
//	PTNADDIMPORTANTBINARIESPROC pfnAddImportantBinaries		Pointer to optional
//															callback to use to
//															retrieve a list of
//															binaries relevant to the
//															upcoming testing.
//	int iComputerNameUniqueness								Value used to generate a
//															unique computer name
//															even when multiple
//															instances are on same
//															machine.
//
// Returns: S_OK if successful, failure code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::LoadLocalMachineInfo(char* szTestnetRootPath,
											PTNADDIMPORTANTBINARIESPROC pfnAddImportantBinaries,
											int iComputerNameUniqueness)
{
	HRESULT			hr;
	char			szNumber[32];
#ifndef _XBOX
	DWORD			dwSize;				// GetComputerName not supported
	SYSTEM_INFO		systeminfo;			// SYSTEM_INFO not supported
#else // ! XBOX
	char			szHostName[MAX_COMPUTERNAME_SIZE + 32];
	OSVERSIONINFO	osWide;
	WCHAR			szWideNumber[256];
#endif // XBOX

#ifdef DEBUG
	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (bad object pointer)

	if (szTestnetRootPath == NULL)
	{
		DPL(0, "Testnet root path is invalid/NULL!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (path is invalid)

	if (! StringEndsWith(szTestnetRootPath, "\\", TRUE))
	{
		DPL(0, "Testnet root path doesn't end in backslash!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (path is invalid)
#endif // DEBUG


#ifndef _XBOX // GetComputerName not supported
	// Get the user and computer names
	dwSize = MAX_COMPUTERNAME_SIZE;
	if (! GetComputerName(this->m_szComputerName, &dwSize))
	{
		hr = GetLastError();

		DPL(0, "Couldn't get computer name!  %e", 1, hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get computer name)
#else // ! XBOX
	// Create a unique hostname by prepending the MAC address with "Xbox"
	gethostname(szHostName, MAX_COMPUTERNAME_SIZE);
	strcpy(this->m_szComputerName, "Xbox");
	strcat(this->m_szComputerName, szHostName);
	DebugPrint("Local host name is %hs\r\n", this->m_szComputerName);
#endif // XBOX


	// If the uniqueness value is not the first one (0), then tack on some
	// qualifiers to the computer name.
	if (iComputerNameUniqueness > 0)
	{
#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szNumber, " #%i", (iComputerNameUniqueness + 1));
#else // ! XBOX
		// Use swprintf and then convert the result ot ANSI
		swprintf(szWideNumber, L" #%i", (iComputerNameUniqueness + 1));
		wcstombs(szNumber, szWideNumber, wcslen(szWideNumber));
		szNumber[wcslen(szWideNumber)] = 0;
#endif // XBOX
		strcat(this->m_szComputerName, szNumber);
	} // end if (not first uniqueness value)


#ifndef _XBOX // GetUserName not supported
	dwSize = MAX_USERNAME_SIZE;
	if (! GetUserName(this->m_szUserName, &dwSize))
	{
		hr = GetLastError();

		DPL(0, "Couldn't get user name!  %e", 1, hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get user name)
#else // ! XBOX
#pragma TODO(tristanj, "Hardcoded local username to Xboxuser")
	strcpy(this->m_szUserName, "XboxUser");
#endif // XBOX

#ifndef _XBOX
	// Get OS version.
	// dwOSVersionInfoSize was set in the CTNMachineInfo object's constructor
	if (! GetVersionEx(&(this->m_os)))
	{
		hr = GetLastError();

		DPL(0, "Couldn't get OS version information!  %e", 1, hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get computer name)

#else
	ZeroMemory(&osWide, sizeof(OSVERSIONINFO));
	osWide.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	// Get OS version.
	// dwOSVersionInfoSize was set in the CTNMachineInfo object's constructor
	if (! GetVersionEx(&osWide))
	{
		hr = GetLastError();

		DPL(0, "Couldn't get OS version information!  %e", 1, hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get computer name)

	this->m_os.dwBuildNumber = osWide.dwBuildNumber;
	this->m_os.dwMajorVersion = osWide.dwMajorVersion;
	this->m_os.dwMinorVersion = osWide.dwMinorVersion;
	this->m_os.dwOSVersionInfoSize = osWide.dwOSVersionInfoSize;
	this->m_os.dwPlatformId = osWide.dwPlatformId;
	wcstombs(this->m_os.szCSDVersion, osWide.szCSDVersion, wcslen(osWide.szCSDVersion));
	this->m_os.szCSDVersion[wcslen(osWide.szCSDVersion)] = 0;
#endif

	// The extra info string often seems to have spaces in it, so get rid of those
	StringPopLeadingChars(this->m_os.szCSDVersion, " ", TRUE);
	StringPopTrailingChars(this->m_os.szCSDVersion, " ", TRUE);


	// Get information on the processor(s).

#ifndef _XBOX // GetSystemInfo not supported
	ZeroMemory(&systeminfo, sizeof (SYSTEM_INFO));
	GetSystemInfo(&systeminfo);
	this->m_wProcessorArchitecture = systeminfo.wProcessorArchitecture;
	this->m_dwNumberOfProcessors = systeminfo.dwNumberOfProcessors;
#else // ! XBOX
	this->m_wProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
	this->m_dwNumberOfProcessors = 1;
#endif // XBOX


	// Get the current memory statistics
	GlobalMemoryStatus(&(this->m_memstats));


	hr = this->LoadLocalWinSockInfo();
	if (hr != S_OK)
	{
		DPL(0, "Loading local WinSock info failed!", 0);
		goto DONE;
	} // end if (couldn't load WinSock info)

	hr = this->LoadLocalRASInfo();
	if (hr != S_OK)
	{
		DPL(0, "Loading local RAS info failed!", 0);
		goto DONE;
	} // end if (couldn't load RAS info)

	hr = this->LoadLocalTAPIInfo(szTestnetRootPath);
	if (hr != S_OK)
	{
		DPL(0, "Loading local TAPI info failed!", 0);
		goto DONE;
	} // end if (couldn't load TAPI info)

	hr = this->LoadLocalCOMPortInfo(szTestnetRootPath);
	if (hr != S_OK)
	{
		DPL(0, "Loading local COM port info failed!", 0);
		goto DONE;
	} // end if (couldn't load COM port info)

	hr = this->LoadLocalSoundCardInfo();
	if (hr != S_OK)
	{
		DPL(0, "Loading local sound card info failed!", 0);
		goto DONE;
	} // end if (couldn't load sound card info)

	hr = this->GetFaultSimCapabilities();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get fault simulator capabilites!", 0);
		goto DONE;
	} // end if (couldn't get fault sims)

	if (pfnAddImportantBinaries != NULL)
	{
		hr = pfnAddImportantBinaries(&(this->m_binaries));
		if (hr != S_OK)
		{
			DPL(0, "Module's AddImportantBinaries callback failed!", 0);
			goto DONE;
		} // end if (module's callback failed)
	} // end if (there are important binaries to get)


DONE:

	return (hr);
} // CTNMachineInfo::LoadLocalMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::PackIntoBuffer()"
//==================================================================================
// CTNMachineInfo::PackIntoBuffer
//----------------------------------------------------------------------------------
//
// Description: Flattens this list into a contiguous buffer for easy transmission.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required.
//
// Arguments:
//	PVOID pvBuffer		Pointer to buffer to use.
//	DWORD* pdwSize		Pointer to a DWORD with the size of the buffer, or will be
//						set to the size required.
//
// Returns: S_OK if successful, failure code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::PackIntoBuffer(PVOID pvBuffer, DWORD* pdwSize)
{
	HRESULT		hr;
	DWORD		dwSize = 0;
	LPBYTE		lpCurrentItem = NULL;
	DWORD		dwIPListSize = 0;
	DWORD		dwTAPIDevListSize = 0;
	DWORD		dwCOMPortListSize = 0;
	DWORD		dwSoundCardsListSize = 0;
	DWORD		dwBinariesSize = 0;


	// Ignore errors, assume BUFFER_TOO_SMALL
	this->m_ipaddrs.PackIntoBuffer(NULL, &dwIPListSize);
	this->m_TAPIdevices.PackIntoBuffer(NULL, &dwTAPIDevListSize);
	this->m_COMports.PackIntoBuffer(NULL, &dwCOMPortListSize);
	this->m_soundcards.PackIntoBuffer(NULL, &dwSoundCardsListSize);
	this->m_binaries.PackIntoBuffer(NULL, &dwBinariesSize);

#ifdef _XBOX
//	DebugPrint("m_ipaddrs size:             %u\r\n", dwIPListSize);
//	DebugPrint("m_TAPIdevices size:         %u\r\n", dwTAPIDevListSize);
//	DebugPrint("m_COMports size:            %u\r\n", dwCOMPortListSize);
//	DebugPrint("m_soundcards size:          %u\r\n", dwSoundCardsListSize);
//	DebugPrint("m_binaries size:            %u\r\n", dwBinariesSize);
#endif

	// How big a buffer will we need?
	dwSize = sizeof (char) * MAX_COMPUTERNAME_SIZE
			+ sizeof (char) * MAX_USERNAME_SIZE
			+ sizeof (OSVERSIONINFOA)
			+ sizeof (WORD) // processor type
			+ sizeof (DWORD) // number of processors
			+ sizeof (MEMORYSTATUS)
			+ sizeof (WORD) // winsock version
			+ sizeof (BOOL) // IPX installed
			+ sizeof (BOOL) // IMTest available
			+ sizeof (DWORD) + dwIPListSize
			+ sizeof (DWORD) + dwTAPIDevListSize
			+ sizeof (DWORD) + dwCOMPortListSize
			+ sizeof (DWORD) + dwSoundCardsListSize
			+ sizeof (DWORD) + dwBinariesSize;

#ifdef _XBOX
//	DebugPrint("MAX_COMPUTERNAME_SIZE size: %u\r\n", sizeof (char) * MAX_COMPUTERNAME_SIZE);
//	DebugPrint("MAX_USERNAME_SIZE size:     %u\r\n", sizeof (char) * MAX_USERNAME_SIZE);
//	DebugPrint("OSVERSIONINFO size:         %u\r\n", sizeof (OSVERSIONINFOA));
//	DebugPrint("Processor type size:        %u\r\n", sizeof (WORD));
//	DebugPrint("Number of processors size:  %u\r\n", sizeof (DWORD));
//	DebugPrint("Memory status size:         %u\r\n", sizeof (MEMORYSTATUS));
//	DebugPrint("Winsock version size:       %u\r\n", sizeof (WORD));
//	DebugPrint("IPX installed size:         %u\r\n", sizeof (BOOL));
//	DebugPrint("IM test available size:     %u\r\n", sizeof (BOOL));
//	DebugPrint("Total size:                 %u\r\n", dwSize);
#endif

	(*pdwSize) = dwSize;

	// If the caller just wants the buffer size, we're done.
	if (pvBuffer == NULL)
		return (ERROR_BUFFER_TOO_SMALL);


	lpCurrentItem = (LPBYTE) pvBuffer; // start at beginning

	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_szComputerName),
							(sizeof (char) * MAX_COMPUTERNAME_SIZE));
	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_szUserName),
							(sizeof (char) * MAX_USERNAME_SIZE));
#ifndef _XBOX
	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_os), (sizeof (OSVERSIONINFO)));
#else
	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_os), (sizeof (OSVERSIONINFOA)));
#endif
	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_wProcessorArchitecture), (sizeof (WORD)));
	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_dwNumberOfProcessors), (sizeof (DWORD)));
	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_memstats), (sizeof (MEMORYSTATUS)));
	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_wWinSock), (sizeof (WORD)));

	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_fIPXInstalled), (sizeof (BOOL)));
	CopyAndMoveDestPointer(lpCurrentItem, &(this->m_fFaultSimIMTestAvailable), (sizeof (BOOL)));

	CopyAndMoveDestPointer(lpCurrentItem, &(dwIPListSize), (sizeof (DWORD)));
	hr = this->m_ipaddrs.PackIntoBuffer(lpCurrentItem, &dwIPListSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack IP address list into buffer!", 0);
		return (hr);
	} // end if (couldn't pack IP address list into buffer)
	lpCurrentItem += dwIPListSize;

	CopyAndMoveDestPointer(lpCurrentItem, &(dwTAPIDevListSize), (sizeof (DWORD)));
	hr = this->m_TAPIdevices.PackIntoBuffer(lpCurrentItem, &dwTAPIDevListSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack TAPI device list into buffer!", 0);
		return (hr);
	} // end if (couldn't pack TAPI device list into buffer)
	lpCurrentItem += dwTAPIDevListSize;

	CopyAndMoveDestPointer(lpCurrentItem, &(dwCOMPortListSize), (sizeof (DWORD)));
	hr = this->m_COMports.PackIntoBuffer(lpCurrentItem, &dwCOMPortListSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack COM port list into buffer!", 0);
		return (hr);
	} // end if (couldn't pack COM port list into buffer)
	lpCurrentItem += dwCOMPortListSize;

	CopyAndMoveDestPointer(lpCurrentItem, &(dwSoundCardsListSize), (sizeof (DWORD)));
	hr = this->m_soundcards.PackIntoBuffer(lpCurrentItem, &dwSoundCardsListSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack sound cards list into buffer!", 0);
		return (hr);
	} // end if (couldn't pack sound cards list into buffer)
	lpCurrentItem += dwSoundCardsListSize;

	CopyAndMoveDestPointer(lpCurrentItem, &(dwBinariesSize), (sizeof (DWORD)));
	hr = this->m_binaries.PackIntoBuffer(lpCurrentItem, &dwBinariesSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack binaries' info into buffer!", 0);
		return (hr);
	} // end if (couldn't pack binaries info into buffer)
	//lpCurrentItem += dwBinariesSize;

	return (S_OK);
} // CTNMachineInfo::PackIntoBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::UnpackFromBuffer()"
//==================================================================================
// CTNMachineInfo::UnpackFromBuffer
//----------------------------------------------------------------------------------
//
// Description: Converts a previously packed CTNMachineInfo object back from the
//				contiguous buffer.
//
// Arguments:
//	PVOID pvBuffer	Pointer to the packed buffer to read from.
//	DWORD dwSize	Size of the buffer.
//
// Returns: S_OK if successful, failure code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::UnpackFromBuffer(PVOID pvBuffer, DWORD dwSize)
{
	HRESULT		hr;
	DWORD		dwTempSize = 0;
	LPBYTE		lpCurrentItem = NULL;
	DWORD		dwIPListSize = 0;
	DWORD		dwTAPIDevListSize = 0;
	DWORD		dwCOMPortListSize = 0;
	DWORD		dwSoundCardsListSize = 0;
	DWORD		dwBinariesSize = 0;


	// How big a buffer do we expect?
	dwTempSize = sizeof (char) * MAX_COMPUTERNAME_SIZE
				+ sizeof (char) * MAX_USERNAME_SIZE
#ifndef _XBOX
				+ sizeof (OSVERSIONINFO)
#else
				+ sizeof (OSVERSIONINFOA)
#endif
				+ sizeof (WORD) // processor type
				+ sizeof (DWORD) // number of processors
				+ sizeof (MEMORYSTATUS)
				+ sizeof (WORD) // winsock version
				+ sizeof (BOOL) // IPX installed
				+ sizeof (BOOL); // IMTest available

	// Now check to see if we got what we expected so far
	if (dwSize < dwTempSize + sizeof (DWORD))
	{
		DPL(0, "Buffer to unpack machine info from (at fixed) is of unexpected size (%u is < %u)!",
			2, dwSize, dwTempSize);
		return (E_FAIL);
	} // end if (got unexpected size)

	lpCurrentItem = ((LPBYTE) pvBuffer) + dwTempSize;
    //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
	dwIPListSize = *((UNALIGNED DWORD*) lpCurrentItem);

	dwTempSize += sizeof (DWORD) + dwIPListSize;

	// And check again
	if (dwSize < dwTempSize + sizeof (DWORD))
	{
		DPL(0, "Buffer to unpack machine info from (at IP list) is of unexpected size (%u is < %u)!",
			2, dwSize, dwTempSize);
		return (E_FAIL);
	} // end if (got unexpected size)

	lpCurrentItem = ((LPBYTE) pvBuffer) + dwTempSize;
    //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
	dwTAPIDevListSize = *((UNALIGNED DWORD*) lpCurrentItem);

	dwTempSize += sizeof (DWORD) + dwTAPIDevListSize;

	// And check again
	if (dwSize < dwTempSize + sizeof (DWORD))
	{
		DPL(0, "Buffer to unpack machine info from (at TAPI device list) is of unexpected size (%u is < %u)!",
			2, dwSize, dwTempSize);
		return (E_FAIL);
	} // end if (got unexpected size)

	lpCurrentItem = ((LPBYTE) pvBuffer) + dwTempSize;
    //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
	dwCOMPortListSize = *((UNALIGNED DWORD*) lpCurrentItem);

	dwTempSize += sizeof (DWORD) + dwCOMPortListSize;

	// And check again
	if (dwSize < dwTempSize + sizeof (DWORD))
	{
		DPL(0, "Buffer to unpack machine info from (at COM port list) is of unexpected size (%u is < %u)!",
			2, dwSize, dwTempSize);
		return (E_FAIL);
	} // end if (got unexpected size)

	lpCurrentItem = ((LPBYTE) pvBuffer) + dwTempSize;
    //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
	dwSoundCardsListSize = *((UNALIGNED DWORD*) lpCurrentItem);

	dwTempSize += sizeof (DWORD) + dwSoundCardsListSize;

	// And check again
	if (dwSize < dwTempSize + sizeof (DWORD))
	{
		DPL(0, "Buffer to unpack machine info from (at sound cards list) is of unexpected size (%u is < %u)!",
			2, dwSize, dwTempSize);
		return (E_FAIL);
	} // end if (got unexpected size)

	lpCurrentItem = ((LPBYTE) pvBuffer) + dwTempSize;
    //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
	dwBinariesSize = *((UNALIGNED DWORD*) lpCurrentItem);

	dwTempSize += sizeof (DWORD) + dwBinariesSize;

	// Now check to see if we got what we expected
	if (dwSize != dwTempSize)
	{
		DPL(0, "Buffer to unpack machine info from (at binaries list) is of unexpected size (%u is != %u)!",
			2, dwSize, dwTempSize);
		return (E_FAIL);
	} // end if (got unexpected size)


	lpCurrentItem = (LPBYTE) pvBuffer; // start at beginning

	CopyAndMoveSrcPointer(&(this->m_szComputerName), lpCurrentItem,
							(sizeof (char) * MAX_COMPUTERNAME_SIZE));
	CopyAndMoveSrcPointer(&(this->m_szUserName), lpCurrentItem,
							(sizeof (char) * MAX_USERNAME_SIZE));
#ifndef _XBOX
	CopyAndMoveSrcPointer(&(this->m_os), lpCurrentItem, (sizeof (OSVERSIONINFO)));
#else
	CopyAndMoveSrcPointer(&(this->m_os), lpCurrentItem, (sizeof (OSVERSIONINFOA)));
#endif
	CopyAndMoveSrcPointer(&(this->m_wProcessorArchitecture), lpCurrentItem, (sizeof (WORD)));
	CopyAndMoveSrcPointer(&(this->m_dwNumberOfProcessors), lpCurrentItem, (sizeof (DWORD)));
	CopyAndMoveSrcPointer(&(this->m_memstats), lpCurrentItem, (sizeof (MEMORYSTATUS)));
	CopyAndMoveSrcPointer(&(this->m_wWinSock), lpCurrentItem, (sizeof (WORD)));
	CopyAndMoveSrcPointer(&(this->m_fIPXInstalled), lpCurrentItem, (sizeof (BOOL)));
	CopyAndMoveSrcPointer(&(this->m_fFaultSimIMTestAvailable), lpCurrentItem, (sizeof (BOOL)));

	CopyAndMoveSrcPointer(&dwIPListSize, lpCurrentItem, (sizeof (DWORD)));
	if (dwIPListSize > 0)
	{
		hr = this->m_ipaddrs.UnpackFromBuffer(lpCurrentItem, dwIPListSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack IP address list from buffer!", 0);
			return (hr);
		} // end if (failed to unpack from buffer)

		lpCurrentItem += dwIPListSize;
	} // end if (there are actually items in the address list)

	CopyAndMoveSrcPointer(&dwTAPIDevListSize, lpCurrentItem, (sizeof (DWORD)));
	if (dwTAPIDevListSize > 0)
	{
		hr = this->m_TAPIdevices.UnpackFromBuffer(lpCurrentItem, dwTAPIDevListSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack TAPI device list from buffer!", 0);
			return (hr);
		} // end if (failed to unpack from buffer)

		lpCurrentItem += dwTAPIDevListSize;
	} // end if (there are actually items in the devices list)

	CopyAndMoveSrcPointer(&dwCOMPortListSize, lpCurrentItem, (sizeof (DWORD)));
	if (dwCOMPortListSize > 0)
	{
		hr = this->m_COMports.UnpackFromBuffer(lpCurrentItem, dwCOMPortListSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack COM port list from buffer!", 0);
			return (hr);
		} // end if (failed to unpack from buffer)

		lpCurrentItem += dwCOMPortListSize;
	} // end if (there are actually items in the COM ports list)

	CopyAndMoveSrcPointer(&dwSoundCardsListSize, lpCurrentItem, (sizeof (DWORD)));
	if (dwSoundCardsListSize > 0)
	{
		hr = this->m_soundcards.UnpackFromBuffer(lpCurrentItem, dwSoundCardsListSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack sound cards list from buffer!", 0);
			return (hr);
		} // end if (failed to unpack from buffer)

		lpCurrentItem += dwSoundCardsListSize;
	} // end if (there are actually items in the sound cards list)

	CopyAndMoveSrcPointer(&dwBinariesSize, lpCurrentItem, (sizeof (DWORD)));
	if (dwBinariesSize > 0)
	{
		hr = this->m_binaries.UnpackFromBuffer(lpCurrentItem, dwBinariesSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack binaries' info list from buffer!", 0);
			return (hr);
		} // end if (failed to unpack from buffer)

		//lpCurrentItem += dwBinariesSize;
	} // end if (there are actually items in the binaries list)

	return (S_OK);
} // CTNMachineInfo::UnpackFromBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::LoadLocalWinSockInfo()"
//==================================================================================
// CTNMachineInfo::LoadLocalWinSockInfo
//----------------------------------------------------------------------------------
//
// Description: Loads the local machine's WinSock information.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::LoadLocalWinSockInfo(void)
{
	HRESULT		hr;
	WSADATA		wsadata;
	SOCKET		sCheckIPX = INVALID_SOCKET;


	ZeroMemory(&wsadata, sizeof (WSADATA));

	hr = WSAStartup(MAKEWORD(2, 2), &wsadata);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't start up WinSock!", 0);
		return (hr);
	} // end if (we couldn't startup WinSock)

	this->m_wWinSock = wsadata.wHighVersion;

#pragma TODO(vanceo, "Load info")

	hr = this->m_ipaddrs.LoadLocalIPs();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't load local IPs!", 0);
		goto DONE;
	} // end if (couldn't load local IPs)

	
	sCheckIPX = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);

	if (sCheckIPX != INVALID_SOCKET)
	{
		closesocket(sCheckIPX); // ignore error
		sCheckIPX = INVALID_SOCKET;

		this->m_fIPXInstalled = TRUE;
	} // end if (successfully created socket)


DONE:

	WSACleanup(); // ignoring error

	return (hr);
} // CTNMachineInfo::LoadLocalWinSockInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::LoadLocalRASInfo()"
//==================================================================================
// CTNMachineInfo::LoadLocalRASInfo
//----------------------------------------------------------------------------------
//
// Description: Loads the local machine's RAS information.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::LoadLocalRASInfo(void)
{
#ifndef _XBOX // no RAS API supported (for now)
	HRESULT						hr;
	HMODULE						hRASAPI32DLL = NULL;
	PRASENUMCONNECTIONSAPROC	pfnRasEnumConnectionsA = NULL;
	PRASGETCONNECTSTATUSAPROC	pfnRasGetConnectStatusA = NULL;
	LPRASCONN					lpRASConns = NULL;
	DWORD						dwSize = 0;
	DWORD						dwNumConnections = 0;
	DWORD						dwTemp;
	RASCONNSTATUS				rasconnstatus;


	// Check for any RAS/DUN connections.  We dynamically link to the RAS DLL
	// because on WinNT 4 (at least) RAS is not installed by default.

	hRASAPI32DLL = LoadLibrary("RASAPI32.DLL");
	if (hRASAPI32DLL == NULL)
	{
		DPL(0, "Couldn't load RASAPI32 DLL, assuming it's not installed.  Skipping.", 0);
	} // end if (couldn't load DLL)
	else
	{
		pfnRasEnumConnectionsA = (PRASENUMCONNECTIONSAPROC) GetProcAddress(hRASAPI32DLL, "RasEnumConnectionsA");
		pfnRasGetConnectStatusA = (PRASGETCONNECTSTATUSAPROC) GetProcAddress(hRASAPI32DLL, "RasGetConnectStatusA");

		if (pfnRasEnumConnectionsA == NULL)
		{
			DPL(0, "Couldn't find RasEnumConnectionsA in RASAPI32 DLL!?  Skipping.", 0);
		} // end if (couldn't find function)
		if (pfnRasGetConnectStatusA == NULL)
		{
			DPL(0, "Couldn't find RasGetConnectStatusA in RASAPI32 DLL!?  Skipping.", 0);
		} // end else if (couldn't find function)
		else
		{
			// We found the functions, so go ahead and check the stuff.


			// Start with one object
			dwSize = sizeof (RASCONN);
			lpRASConns = (LPRASCONN) LocalAlloc(LPTR, dwSize);
			if (lpRASConns == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			lpRASConns[0].dwSize = sizeof (RASCONN);


			hr = pfnRasEnumConnectionsA(lpRASConns, &dwSize, &dwNumConnections);
			if (hr != S_OK)
			{
				if (hr != ERROR_BUFFER_TOO_SMALL)
				{
					DPL(0, "Got unexpected error from RasEnumConnections (expected ERROR_BUFFER_TOO_SMALL)!", 0);
					goto DONE;
				} // end if (we couldn't enumerate RAS connections)

				LocalFree(lpRASConns);
				lpRASConns = (LPRASCONN) LocalAlloc(LPTR, dwSize);
				if (lpRASConns == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				lpRASConns[0].dwSize = sizeof (RASCONN);
				

				hr = pfnRasEnumConnectionsA(lpRASConns, &dwSize, &dwNumConnections);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't enumerate RAS connections!", 0);
					goto DONE;
				} // end if (we couldn't enumerate RAS connections)
			} // end if (we failed our first attempt to enumerate)

			ZeroMemory(&rasconnstatus, sizeof (RASCONNSTATUS));
			rasconnstatus.dwSize = sizeof (RASCONNSTATUS);
			for (dwTemp = 0; dwTemp < dwNumConnections; dwTemp++)
			{
				DPL(0, "Found RAS connection %s",
					1, lpRASConns[dwTemp].szEntryName);

				hr = pfnRasGetConnectStatusA(lpRASConns[dwTemp].hrasconn, &rasconnstatus);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't get RAS connection status!", 0);
					goto DONE;
				} // end if (we couldn't get RAS connection status)

				if (rasconnstatus.rasconnstate == RASCS_Connected)
				{
					DPL(0, "RAS connection is connected.", 0);
				} // end if (this is connected)
				else if (rasconnstatus.rasconnstate == RASCS_Disconnected)
				{
					DPL(0, "RAS connection is disconnected.", 0);
				} // end if (this is disconnected)
				else
				{
					DPL(0, "RAS connection is in some wierd state.", 0);
				} // end if (this is not a handled state)

				DPL(0, "szDeviceType = %s, szDeviceName = %s",
					2, rasconnstatus.szDeviceType, rasconnstatus.szDeviceName);
			} // end for (each RAS connection)
		} // end else (we found valid functions)
	} // end else (we loaded the RAS DLL)
	

DONE:

	if (lpRASConns != NULL)
	{
		LocalFree(lpRASConns);
		lpRASConns = NULL;
	} // end if (have RAS connections)

	if (hRASAPI32DLL != NULL)
	{
		FreeLibrary(hRASAPI32DLL);
		hRASAPI32DLL = NULL;
	} // end if (have RAS DLL)

	return (hr);
#else // ! XBOX
	return (S_OK);
#endif // XBOX
} // CTNMachineInfo::LoadLocalRASInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::LoadLocalTAPIInfo()"
//==================================================================================
// CTNMachineInfo::LoadLocalTAPIInfo
//----------------------------------------------------------------------------------
//
// Description: Loads the local machine's TAPI information.
//
// Arguments:
//	char* szTestnetRootPath		Path to root testnet directory.  Should end in a
//								backslash.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::LoadLocalTAPIInfo(char* szTestnetRootPath)
{
#ifndef _XBOX // no TAPI supported
	HRESULT							hr;
	HRESULT							temphr;
	HMODULE							hTAPIDLL = NULL;
	PLINEINITIALIZEPROC				pfnLineInitialize = NULL;
	PLINENEGOTIATEAPIVERSIONPROC	pfnLineNegotiateAPIVersion = NULL;
	PLINEGETDEVCAPSPROC				pfnLineGetDevCaps = NULL;
	PLINESHUTDOWNPROC				pfnLineShutdown = NULL;
	char*							pszIniPath = NULL;
	BOOL							fTAPIInitted = FALSE;
	HLINEAPP						hLineApp;
	DWORD							dwNumDevices;
	DWORD							dwTemp;
	DWORD							dwDevTAPIVersion;
	LINEEXTENSIONID					leid;
	LPLINEDEVCAPS					lpLineDevCaps = NULL;
	DWORD							dwLineDevCapsSize = 0;
	char*							pszLineName;
	PTNTAPIDEVICE					pTAPIDev = NULL;
	TAPIDEVICECONTEXT				tdc;


	hTAPIDLL = LoadLibrary("tapi32.dll");
	if (hTAPIDLL == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't load TAPI32.DLL!  %e", 1, hr);
		
		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't load TAPI)

	pfnLineInitialize = (PLINEINITIALIZEPROC) GetProcAddress(hTAPIDLL,
															"lineInitialize");
	if (pfnLineInitialize == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't get \"lineInitialize\" function!  %e", 1, hr);
		
		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get proc)

	pfnLineNegotiateAPIVersion = (PLINENEGOTIATEAPIVERSIONPROC) GetProcAddress(hTAPIDLL,
																				"lineNegotiateAPIVersion");
	if (pfnLineNegotiateAPIVersion == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't get \"lineNegotiateAPIVersion\" function!  %e", 1, hr);
		
		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get proc)

	pfnLineGetDevCaps = (PLINEGETDEVCAPSPROC) GetProcAddress(hTAPIDLL,
															"lineGetDevCaps");
	if (pfnLineGetDevCaps == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't get \"lineGetDevCaps\" function!  %e", 1, hr);
		
		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get proc)

	pfnLineShutdown = (PLINESHUTDOWNPROC) GetProcAddress(hTAPIDLL,
														"lineShutdown");
	if (pfnLineShutdown == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't get \"lineShutdown\" function!  %e", 1, hr);
		
		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get proc)


	// Build the path to the ini file
	pszIniPath = (char*) LocalAlloc(LPTR, strlen(szTestnetRootPath) + strlen(TAPIDEVICELIST_FILENAME) + 1);
	if (pszIniPath == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	strcpy(pszIniPath, szTestnetRootPath);
	strcat(pszIniPath, TAPIDEVICELIST_FILENAME);


	hr = pfnLineInitialize(&hLineApp, s_hInstance, InfoLineCallbackProc, NULL,
							&dwNumDevices);
	if (hr != 0)
	{
		DPL(0, "Initializing TAPI failed!", 0);

		if (hr == LINEERR_REINIT)
		{
			DPL(0, "TAPI wants to reinitialize (a device was installed possibly), so shutdown all TAPI apps and try again.", 0);
		} // end if (reinit)

		goto DONE;
	} // end if (init failed)

	fTAPIInitted = TRUE;
	DPL(1, "TAPI reports %u devices.", 1, dwNumDevices);


	for(dwTemp = 0; dwTemp < dwNumDevices; dwTemp++)
	{
		hr = pfnLineNegotiateAPIVersion(hLineApp, dwTemp, REQUIRED_TAPI_VERSION,
										MAX_TAPI_VERSION, &dwDevTAPIVersion, &leid);
		if (hr != 0)
		{
			DPL(0, "Negotiating API version with device %u failed (doesn't like v%x - v%x), skipping.  %e",
				4, dwTemp, REQUIRED_TAPI_VERSION, MAX_TAPI_VERSION, hr);

			hr = S_OK;
			continue;
		} // end if (getting version failed)

		// Keep looping until we have a buffer large enough to hold the caps.
		do
		{
			if (lpLineDevCaps != NULL)
			{
				LocalFree(lpLineDevCaps);
				lpLineDevCaps = NULL;
			} // end if (already have buffer)

			dwLineDevCapsSize += LINEDEVCAPS_BUFFER_INCREMENT;
			lpLineDevCaps = (LPLINEDEVCAPS) LocalAlloc(LPTR, dwLineDevCapsSize);
			if (lpLineDevCaps == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
			lpLineDevCaps->dwTotalSize = dwLineDevCapsSize;

			hr = pfnLineGetDevCaps(hLineApp, dwTemp, dwDevTAPIVersion, 0, lpLineDevCaps);
		} // end do (while need to increase buffer size)
		while (hr == LINEERR_STRUCTURETOOSMALL);

		if (hr != 0)
		{
			DPL(0, "Couldn't get device %u's capabilities!  Skipping.  %e",
				2, dwTemp, hr);
			hr = S_OK;
			continue;
		} // end if (getting caps failed)


		pszLineName = ((char *) lpLineDevCaps) + lpLineDevCaps->dwLineNameOffset;

		if (pszLineName[0] == '\0')
		{
			DPL(0, "Device %u's name was an empty string!", 0);
			hr = E_FAIL;
		    goto DONE;
		} //  end if (line name had no characters)

		// Make sure the device name is null terminated.
		if (pszLineName[lpLineDevCaps->dwLineNameSize - 1] != '\0')
		{
			char*	pszTemp;


			pszTemp = (char*) LocalAlloc(LPTR, lpLineDevCaps->dwLineNameSize + 1);
			if (pszTemp == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			CopyMemory(pszTemp, pszLineName, lpLineDevCaps->dwLineNameSize);

			pTAPIDev = new (CTNTAPIDevice)(pszTemp, dwTemp);

			LocalFree(pszTemp);
			pszTemp = NULL;
		} // end if (name isn't NULL terminated)
		else
		{
			pTAPIDev = new (CTNTAPIDevice)(pszLineName, dwTemp);
		} // end else (name is NULL terminated)

		if (pTAPIDev == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)


		// Skip non-data-modems.
		if (! (lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM))
		{
			DPL(2, "Skipping non-data-modem \"%s\" (device %u).",
				2, pTAPIDev->GetString(), dwTemp);

			delete (pTAPIDev);
			pTAPIDev = NULL;

			continue;
		} // end if (not a data-modem)

		DPL(1, "Found data-modem \"%s\" (device %u).", 2, pTAPIDev->GetString(), dwTemp);


		ZeroMemory(&tdc, sizeof (TAPIDEVICECONTEXT));
		tdc.pDevice = pTAPIDev;
		//tdc.fInSection = FALSE;

		hr = FileReadTextFile(pszIniPath, FILERTFO_EXTENDEDINIOPTIONS,
							SearchForTAPIDeviceReadFileCB, &tdc);

		// Hmm.  For now, the file not existing is okay, we'll just treat it as if
		// the device didn't have a number specified
		if (hr == ERROR_FILE_NOT_FOUND)
		{
			DPL(0, "TAPI device list file \"%s\" doesn't exist, so there's no number for device \"%s\".",
				2, pszIniPath, pTAPIDev->GetString());
			hr = S_OK;
		} // end if (file doesn't exist)

		if (hr != S_OK)
		{
			DPL(0, "Couldn't read TAPI device list file \"%s\" to search for device \"%s\"!",
				2, pszIniPath, pTAPIDev->GetString());
			goto DONE;
		} // end if (couldn't allocate object)


		hr = this->m_TAPIdevices.Add(pTAPIDev);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add TAPI device %x (# %u) to list!",
				2, pTAPIDev, dwTemp);
			goto DONE;
		} // end if (couldn't allocate object)

		pTAPIDev = NULL; // forget it, so we don't free it below
	} // end for (each device)


DONE:

	if (fTAPIInitted)
	{
		temphr = pfnLineShutdown(hLineApp);
		if (temphr != 0)
		{
			DPL(0, "Couldn't shutdown TAPI!  %e", 1, hr);
			if (hr == S_OK)
				hr = temphr;
		} // end if (couldn't shutdown TAPI)

		fTAPIInitted = FALSE;
	} // end if (TAPI was initialized)

	if (pTAPIDev != NULL)
	{
		delete (pTAPIDev);
		pTAPIDev = NULL;
	} // end if (have leftover object)

	if (lpLineDevCaps != NULL)
	{
		LocalFree(lpLineDevCaps);
		lpLineDevCaps = NULL;
	} // end if (have buffer)

	if (pszIniPath != NULL)
	{
		LocalFree(pszIniPath);
		pszIniPath = NULL;
	} // end if (have string)

	if (hTAPIDLL != NULL)
	{
		FreeLibrary(hTAPIDLL); // ignore error
		hTAPIDLL = NULL;
	} // end if (have TAPI DLL)

	return (hr);
#else // ! XBOX
	return (S_OK);
#endif // XBOX

} // CTNMachineInfo::LoadLocalTAPIInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
	



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::LoadLocalCOMPortInfo()"
//==================================================================================
// CTNMachineInfo::LoadLocalCOMPortInfo
//----------------------------------------------------------------------------------
//
// Description: Loads the local machine's COM port information.
//
// Arguments:
//	char* szTestnetRootPath		Path to root testnet directory.  Should end in a
//								backslash.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::LoadLocalCOMPortInfo(char* szTestnetRootPath)
{
#ifndef _XBOX // no COM port crap supported
	HRESULT			hr = S_OK;
	char*			pszIniPath = NULL;
	DWORD			dwTemp;
	char			szCOMPort[8];
	HANDLE			hFile = INVALID_HANDLE_VALUE;
	PTNCOMPORT		pCOMPort = NULL;
	COMPORTCONTEXT	cpc;



	// Build the path to the ini file
	pszIniPath = (char*) LocalAlloc(LPTR, strlen(szTestnetRootPath) + strlen(COMPORTLIST_FILENAME) + 1);
	if (pszIniPath == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	strcpy(pszIniPath, szTestnetRootPath);
	strcat(pszIniPath, COMPORTLIST_FILENAME);


	for(dwTemp = 1; dwTemp <= MAX_COMPORT; dwTemp++)
	{
		wsprintf(szCOMPort, "COM%u", dwTemp);

		hFile = CreateFile(szCOMPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
							OPEN_EXISTING, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			hr = GetLastError();

			if ((hr == ERROR_FILE_NOT_FOUND) || (hr == ERROR_ACCESS_DENIED))
				hr = S_OK;
			else
			{
				DPL(0, "Couldn't open %s!  %e", 2, szCOMPort, hr);
		
				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end else (error trying to open COM port)
		} // end if (couldn't open COM port)
		else
		{
			// We don't actually need the COM port, so just close it.
			CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;

			DPL(1, "Opened %s.", 1, szCOMPort);


			pCOMPort = new (CTNCOMPort)(NULL, dwTemp);
			if (pCOMPort == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)


			ZeroMemory(&cpc, sizeof (COMPORTCONTEXT));
			cpc.pCOMPort = pCOMPort;
			//cpc.fInSection = FALSE;

			hr = FileReadTextFile(pszIniPath, FILERTFO_EXTENDEDINIOPTIONS,
								SearchForCOMPortReadFileCB, &cpc);

			// Hmm.  For now, the file not existing is okay, we'll just treat it as if
			// the device didn't have a number specified
			if (hr == ERROR_FILE_NOT_FOUND)
			{
				DPL(0, "COM port list file \"%s\" doesn't exist, so there's no connection machine name for COM%u.",
					2, pszIniPath, pCOMPort->GetCOMPort());
				hr = S_OK;
			} // end if (file doesn't exist)

			if (hr != S_OK)
			{
				DPL(0, "Couldn't read COM port list file \"%s\" to search for COM%u!",
					2, pszIniPath, pCOMPort->GetCOMPort());
				goto DONE;
			} // end if (couldn't allocate object)


			hr = this->m_COMports.Add(pCOMPort);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add %s to list!", 1, szCOMPort);
				goto DONE;
			} // end if (couldn't add item)

			pCOMPort = NULL; // forget about it so we don't free it later
		} // end else (could open COM port)
	} // end for (each comport)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (have open COM port)

	if (pCOMPort != NULL)
	{
		delete (pCOMPort);
		pCOMPort = NULL;
	} // end if (have left over object)

	if (pszIniPath != NULL)
	{
		LocalFree(pszIniPath);
		pszIniPath = NULL;
	} // end if (have string)

	return (hr);
#else // ! XBOX
	return (S_OK);
#endif // XBOX
} // CTNMachineInfo::LoadLocalCOMPortInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::LoadLocalSoundCardInfo()"
//==================================================================================
// CTNMachineInfo::LoadLocalSoundCardInfo
//----------------------------------------------------------------------------------
//
// Description: Loads the local machine's sound card information.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::LoadLocalSoundCardInfo(void)
{
#ifndef _XBOX // Not sure if our DSound works this way yet... skip for now
	HRESULT						hr;
	HMODULE						hDSoundDLL = NULL;
	PDIRECTSOUNDENUMERATEAPROC	pfnDirectSoundEnumerateA = NULL;


	hDSoundDLL = LoadLibrary("dsound.dll");

	if (hDSoundDLL == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't load dsound.dll!  %e", 1, hr);
		
		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't load DSound library)

	pfnDirectSoundEnumerateA = (PDIRECTSOUNDENUMERATEAPROC) GetProcAddress(hDSoundDLL,
																		"DirectSoundEnumerateA");
	if (pfnDirectSoundEnumerateA == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't find \"DirectSoundEnumerateA\" in dsound.dll!  %e", 1, hr);
		
		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't get proc)


	hr = pfnDirectSoundEnumerateA(DSEnumCallback, &(this->m_soundcards));
	if (hr != DS_OK)
	{
		DPL(0, "Couldn't enumerate sound cards!", 0);
		//goto DONE;
	} // end if (couldn't enum)


DONE:

	if (hDSoundDLL != NULL)
	{
		FreeLibrary(hDSoundDLL);
		hDSoundDLL = NULL;
	} // end if (have library)

	return (hr);
#else // ! XBOX
#pragma BUGBUG(tristanj, "We will probably want to do DSound enumeration later, but for now, skip it.")

	return S_OK;
#endif // XBOX
} // CTNMachineInfo::LoadLocalSoundCardInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMachineInfo::GetFaultSimCapabilities()"
//==================================================================================
// CTNMachineInfo::GetFaultSimCapabilities
//----------------------------------------------------------------------------------
//
// Description: Determines whether or not the fault simulators are installed and
//				available.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMachineInfo::GetFaultSimCapabilities(void)
{
	HRESULT				hr = S_OK;
	PTNFAULTSIMIMTEST	pIMTest = NULL;


	pIMTest = new (CTNFaultSimIMTest);
	if (pIMTest == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	this->m_fFaultSimIMTestAvailable = pIMTest->IsInstalledAndCanBeRun();

	delete (pIMTest);
	pIMTest = NULL;


DONE:

	return (hr);
} // CTNMachineInfo::GetFaultSimCapabilities
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOtherMachineInfo::CTNOtherMachineInfo()"
//==================================================================================
// CTNOtherMachineInfo constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNOtherMachineInfo object.  Initializes the data
//				structures.
//
// Arguments:
//	PTNCTRLMACHINEID pID	ID this machine info represents.
//
// Returns: None (just the object).
//==================================================================================
CTNOtherMachineInfo::CTNOtherMachineInfo(PTNCTRLMACHINEID pID)
{
	DPL(9, "this = %x, sizeof (this) = %u", 2, this, sizeof (CTNOtherMachineInfo));

	CopyMemory(&(this->m_id), pID, sizeof (TNCTRLMACHINEID));
} // CTNOtherMachineInfo::CTNOtherMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOtherMachineInfo::~CTNOtherMachineInfo()"
//==================================================================================
// CTNOtherMachineInfo destructor
//----------------------------------------------------------------------------------
//
// Description: Release the CTNOtherMachineInfo object and any memory it may have
//				allocated.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNOtherMachineInfo::~CTNOtherMachineInfo(void)
{
	DPL(9, "this = %x", 1, this);
} // CTNOtherMachineInfo::~CTNOtherMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOtherMachineInfosList::GetInfoForMachine()"
//==================================================================================
// CTNOtherMachineInfosList::GetInfoForMachine
//----------------------------------------------------------------------------------
//
// Description: Returns pointer to info object of machine with ID passed in.  If the
//				item was not found, NULL is returned.
//
// Arguments:
//	PTNCTRLMACHINEID pID	ID of machine to look up.
//
// Returns: Pointer to machine info object, or NULL if an error occurred.
//==================================================================================
PTNOTHERMACHINEINFO CTNOtherMachineInfosList::GetInfoForMachine(PTNCTRLMACHINEID pID)
{
	HRESULT					hr = S_OK;
	int						i;
	PTNOTHERMACHINEINFO		pInfo;


	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pInfo = (PTNOTHERMACHINEINFO) this->GetItem(i);
		if (pInfo == NULL)
		{
			DPL(0, "Couldn't get info item %i!", 1, i);
			goto DONE;
		} // end if (couldn't item)

		if (memcmp(&(pInfo->m_id), pID, sizeof (TNCTRLMACHINEID)) == 0)
		{
			goto DONE;
		} // end if (found ID)
	} // end for (each item in this list)


	// If we got here, then we didn't find the object.
	pInfo = NULL;


DONE:

	this->LeaveCritSection();

	return (pInfo);
} // CTNOtherMachineInfosList::GetInfoForMachine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"InfoLineCallbackProc()"
//==================================================================================
// InfoLineCallbackProc
//----------------------------------------------------------------------------------
//
// Description: Loads the local machine's TAPI information.
//
// Arguments:
//	DWORD hDevice		Handle to device or call, depending on message.
//	DWORD dwMsg			Message to process.
//	DWORD dwContext		User defined context.
//	DWORD dwParam1		First parameter for the message.
//	DWORD dwParam2		Second parameter for the message.
//	DWORD dwParam3		Third parameter for the message.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
void FAR PASCAL InfoLineCallbackProc(DWORD hDevice, DWORD dwMsg, DWORD_PTR dwContext,
									DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{
	DPL(0, "msg = %u", 1, dwMsg);
} // InfoLineCallbackProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"SearchForTAPIDeviceReadFileCB()"
//==================================================================================
// SearchForTAPIDeviceReadFileCB
//----------------------------------------------------------------------------------
//
// Description: Callback that handles a line read from a text file.
//
// Arguments:
//	char* szLine			Line that was read.
//	PFILELINEINFO pInfo		Information on line that was read.
//	PVOID pvContext			Pointer to context.  Cast as a TAPIDEVICECONTEXT
//							pointer.
//	BOOL* pfStopReading		Pointer to boolean to set to TRUE to discontinue reading
//							from the file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT SearchForTAPIDeviceReadFileCB(char* szLine, PFILELINEINFO pInfo,
										PVOID pvContext, BOOL* pfStopReading)
{
	HRESULT				hr = S_OK;
	PTAPIDEVICECONTEXT	pContext = (PTAPIDEVICECONTEXT) pvContext;


	//DPL(9, "Reading line %u:\"%s\".", 2, lpInfo->dwLineNumber, szLine);

	switch (pInfo->dwType)
	{
		case FILERTFT_SECTION:
			if (StringCmpNoCase(szLine, pContext->pDevice->GetString()))
				pContext->fInSection = TRUE;
			else
				pContext->fInSection = FALSE;
		  break;

		default:
			// If we're not in the devices section, just skip the line.
			if (! pContext->fInSection)
				break;

			if (StringIsKey(szLine, "Number"))
			{
				hr = pContext->pDevice->SetPhoneNumber(StringGetKeyValue(szLine));
				if (hr != S_OK)
				{
					DPL(0, "Couldn't set \"%s\"'s phone number!",
						1, pContext->pDevice->GetString());
					return (hr);
				} // end if (couldn't save value)

				DPL(6, "Device \"%s\" uses number \"%s\".",
					2, pContext->pDevice->GetString(),
					pContext->pDevice->GetPhoneNumber());

				// Don't read any more
				(*pfStopReading) = TRUE;
			} // end if (found number for item)
		  break;
	} // end switch (on line type)

	return (S_OK);
} // SearchForTAPIDeviceReadFileCB 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"SearchForCOMPortReadFileCB()"
//==================================================================================
// SearchForCOMPortReadFileCB
//----------------------------------------------------------------------------------
//
// Description: Callback that handles a line read from a text file.
//
// Arguments:
//	char* szLine			Line that was read.
//	PFILELINEINFO pInfo		Information on line that was read.
//	PVOID pvContext			Pointer to context.  Cast as a COMPORTCONTEXT pointer.
//	BOOL* pfStopReading		Pointer to boolean to set to TRUE to discontinue reading
//							from the file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT SearchForCOMPortReadFileCB(char* szLine, PFILELINEINFO pInfo,
									PVOID pvContext, BOOL* pfStopReading)
{
	HRESULT				hr = S_OK;
	PCOMPORTCONTEXT		pContext = (PCOMPORTCONTEXT) pvContext;


	//DPL(9, "Reading line %u:\"%s\".", 2, lpInfo->dwLineNumber, szLine);

	switch (pInfo->dwType)
	{
		case FILERTFT_SECTION:
			char	szCOMPort[8];


			wsprintf(szCOMPort, "COM%u", pContext->pCOMPort->GetCOMPort());

			if (StringCmpNoCase(szLine, szCOMPort))
				pContext->fInSection = TRUE;
			else
				pContext->fInSection = FALSE;
		  break;

		default:
			// If we're not in the devices section, just skip the line.
			if (! pContext->fInSection)
				break;

			if (StringIsKey(szLine, "ConnectedTo"))
			{
				hr = pContext->pCOMPort->SetString(StringGetKeyValue(szLine));
				if (hr != S_OK)
				{
					DPL(0, "Couldn't set COM%u's machine connection name!",
						1, pContext->pCOMPort->GetCOMPort());
					return (hr);
				} // end if (couldn't save value)

				DPL(6, "COM%u is connected to \"%s\".",
					2, pContext->pCOMPort->GetCOMPort(),
					pContext->pCOMPort->GetString());

				// Don't read any more
				(*pfStopReading) = TRUE;
			} // end if (found number for item)
		  break;
	} // end switch (on line type)

	return (S_OK);
} // SearchForCOMPortReadFileCB 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"DSEnumCallback()"
//==================================================================================
// DSEnumCallback
//----------------------------------------------------------------------------------
//
// Description: Callback that handles a line read from a text file.
//
// Arguments:
//	LPGUID lpGuid				Pointer to GUID that identifies the DirectSound
//								driver being enumerated.
//	LPCSTR lpcstrDescription	Pointer to textual description of the DirectSound
//								device.
//	LPCSTR lpcstrModule			Pointer to module name of the DirectSound driver
//								for this device.
//	LPVOID lpvContext			User specified context.  Cast as a pointer to a
//								CTNSoundCardsList object.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
BOOL CALLBACK DSEnumCallback(LPGUID lpGuid, LPCSTR lpcstrDescription,
							LPCSTR lpcstrModule, LPVOID lpvContext)
{
	HRESULT				hr;
	PTNSOUNDCARDSLIST	pList = (PTNSOUNDCARDSLIST) lpvContext;
	BOOL				fHalfDuplex = FALSE;
	PTNSOUNDCARD		pSoundCard = NULL;


	if (lpGuid != NULL)
	{
		if (lpcstrDescription == NULL)
		{
			DPL(0, "GUID %g was enumerated, but it has no text description!",
				1, lpGuid);
			return (FALSE);
		} // end if (have no way to describe sound card)


		// These are funky devices that are known to be half-duplex.
		if (StringMatchesWithWildcard("Voice Modem Wave #* Line", (char*) lpcstrDescription, TRUE))
			fHalfDuplex = TRUE;
		else if (StringMatchesWithWildcard("Voice Modem Wave #* Headset", (char*) lpcstrDescription, TRUE))
			fHalfDuplex = TRUE;
		else if (strcmp((char*) lpcstrDescription, "Game Compatible Device") == 0)
			fHalfDuplex = TRUE;


		pSoundCard = new (CTNSoundCard)((char*) lpcstrDescription, lpGuid,
										fHalfDuplex);
		if (pSoundCard == NULL)
		{
			return (FALSE);
		} // end if (couldn't allocate memory)


		hr = pList->Add(pSoundCard);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add sound card %x to list!  %e", 2, pSoundCard, hr);

			delete (pSoundCard);
			pSoundCard = NULL;

			return (FALSE);
		} // end if (couldn't add sound card)
	} // end if (there's a device)

	return (TRUE);
} // DSEnumCallback 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\faultsim.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#ifdef _XBOX // Damn ANSI conversion
#include <stdio.h>
#include <stdlib.h>
#endif

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\sprintf.h"

#include "tncontrl.h"
#include "main.h"

#include "faultsim.h"



//==================================================================================
// Defines
//==================================================================================
#ifndef _XBOX // Damn ANSI conversion
#define FAULTSIM_PREFIX_MUTEX		"TN FaultSim mutex "
#else
#define FAULTSIM_PREFIX_MUTEX		L"TN FaultSim mutex "
#endif






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSim::CTNFaultSim()"
//==================================================================================
// CTNFaultSim constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNFaultSim object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNFaultSim::CTNFaultSim(void):
	m_dwID(0),
	m_fInitialized(FALSE),
	m_hExclusiveLock(NULL)
{
	DPL(9, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNFaultSim));
} // CTNFaultSim::CTNFaultSim
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSim::~CTNFaultSim()"
//==================================================================================
// CTNFaultSim destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNFaultSim object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNFaultSim::~CTNFaultSim(void)
{
	HRESULT		hr;


	DPL(9, "this = %x", 1, this);

	if (this->m_fInitialized)
	{
		DPL(0, "WARNING: Fault sim object %x is still initialized on delete!",
			1, this);

		hr = this->Release();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't release fault sim object %x!", 2, this, hr);
		} // end if (couldn't release object)
	} // end if (still initialized)

	// Just in case we somehow have the lock still.
	if (this->m_hExclusiveLock != NULL)
	{
		ReleaseMutex(this->m_hExclusiveLock);
		CloseHandle(this->m_hExclusiveLock);
		this->m_hExclusiveLock = NULL;
	} // end if (have mutex handle)
} // CTNFaultSim::~CTNFaultSim
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSim::Initialize()"
//==================================================================================
// CTNFaultSim::Initialize
//----------------------------------------------------------------------------------
//
// Description: Sets up this object, and prepares it for use.
//
// Arguments:
//	LPVOID lpvInitData		Pointer to data to use when initializing.
//	DWORD dwInitDataSize	Size of data to use when initializing.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSim::Initialize(LPVOID lpvInitData, DWORD dwInitDataSize)
{
	HRESULT		hr = S_OK;


	DPL(9, "==>", 0);

	if (this->m_fInitialized)
	{
		DPL(0, "FaultSim already initialized!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not initialized)


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNFaultSim::Initialize
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSim::Release()"
//==================================================================================
// CTNFaultSim::Release
//----------------------------------------------------------------------------------
//
// Description: Releases this object after a successful call to Initialize.  Must be
//				done prior to deletion.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSim::Release(void)
{
	HRESULT		hr = S_OK;


	DPL(9, "==>", 0);

	if (! this->m_fInitialized)
	{
		DPL(0, "FaultSim not initialized!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not initialized)


	// Drop the lock, if we have it.
	if (this->m_hExclusiveLock != NULL)
	{
		ReleaseMutex(this->m_hExclusiveLock);
		CloseHandle(this->m_hExclusiveLock);
		this->m_hExclusiveLock = NULL;
	} // end if (have mutex handle)


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNFaultSim::Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSim::EnsureExclusiveUse()"
//==================================================================================
// CTNFaultSim::EnsureExclusiveUse
//----------------------------------------------------------------------------------
//
// Description: Prevents other threads and processes from using this type of fault
//				simulator simultaneously.
//				This may block until a previous fault simulator relenquishes its
//				exclusive control.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSim::EnsureExclusiveUse(void)
{
	HRESULT		hr;
	char		szName[256];


#ifndef _XBOX // Damn ANSI conversion
	wsprintf(szName, FAULTSIM_PREFIX_MUTEX "%u", this->m_dwID);
	this->m_hExclusiveLock = CreateMutex(NULL, FALSE, szName);
#else // ! XBOX
	WCHAR		szWideName[256];
	// Use swprintf and then convert the result ot ANSI
	swprintf(szWideName, FAULTSIM_PREFIX_MUTEX L"%u", this->m_dwID);
	this->m_hExclusiveLock = CreateMutex(NULL, FALSE, szWideName);
#endif // XBOX
	if (this->m_hExclusiveLock == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get fault sim exclusive lock \"%s\"!", 1, szName);
		goto ERROR_EXIT;
	} // end if (couldn't create mutex)


	// Now grab the mutex lock

#pragma BUGBUG(vanceo, "Get user cancel here")
	hr = WaitForSingleObjectEx(this->m_hExclusiveLock, INFINITE, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Got the lock, we're cool
		  break;

		default:
			// Got some unexpected error
			DPL(0, "Got unexpected result from WaitForSingleObjectEx!", 0);
			goto ERROR_EXIT;
		  break;
	} // end switch (on wait result)

	return (S_OK);


ERROR_EXIT:


	if (this->m_hExclusiveLock != NULL)
	{
		CloseHandle(this->m_hExclusiveLock);
		this->m_hExclusiveLock = NULL;
	} // end if (have mutex handle)

	return (hr);
} // CTNFaultSim::EnsureExclusiveUse
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNFaultSim::RelenquishExclusiveUse()"
//==================================================================================
// CTNFaultSim::RelenquishExclusiveUse
//----------------------------------------------------------------------------------
//
// Description: Allows other threads and processes to use this type of fault
//				simulator after previously gaining exclusive control.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNFaultSim::RelenquishExclusiveUse(void)
{
	HRESULT		hr = S_OK;


	if (this->m_hExclusiveLock == NULL)
	{
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (don't have lock)

	ReleaseMutex(this->m_hExclusiveLock);
	CloseHandle(this->m_hExclusiveLock);
	this->m_hExclusiveLock = NULL;


DONE:

	return (hr);
} // CTNFaultSim::RelenquishExclusiveUse
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\executor.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define _WIN32_DCOM // so we can use CoInitializeEx.  requires DCOM95 on Win95
#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock2 fn proto's, for getprocaddress

#ifndef _XBOX
#include <winsock2.h>
#else // ! XBOX
#include <winsockx.h>		// Needed for XnetInitialize
#endif // XBOX

#include <windows.h>
#include <windowsx.h>

#include <mmsystem.h>

// We set the version to 4 so we don't go getting extra elements in our RASCONN
// structure (otherwise we might build with a larger size that earlier versions of
// RAS barf on)
#ifdef WINVER
#undef WINVER
#endif // WINVER
#define WINVER	0x0400
#include <ras.h>
#include <raserror.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\sprintf.h"

#include "tncontrl.h"
#include "main.h"
#include "resource.h"

#include "script.h"
#include "faultsim.h"
#include "faultsimimtest.h"

#include "executor.h"





//==================================================================================
// Defines
//==================================================================================
//BUGBUG make customizable
#define TIMEOUT_DIE_TESTTHREAD			40000 // in milliseconds

#define MAX_WAITFOREVENTORCANCEL_TIME	600000 // 10 minutes


#define WM_MYCLOSEDIALOG				(WM_USER + 1)




//==================================================================================
// DCOM function type definitions
//==================================================================================
typedef HRESULT	(WINAPI *PCOINITIALIZEEXPROC)	(LPVOID, DWORD);




//==================================================================================
// Local Prototypes
//==================================================================================
INT_PTR CALLBACK PromptAllDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::CTNExecutorPriv()"
//==================================================================================
// CTNExecutorPriv constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNExecutorPriv object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNExecutorPriv::CTNExecutorPriv(void)
{
	DPL(9, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNExecutorPriv));


	// protected
	this->m_dwMode = 0;
	ZeroMemory(&(this->m_moduleID), sizeof (TNMODULEID));

	this->m_pOwningSlave = NULL;

#ifndef _XBOX // no IPC supported
	this->m_pOwningLeech = NULL;
#endif // ! XBOX

	ZeroMemory(&(this->m_id), sizeof (TNCTRLMACHINEID));
	this->m_hUserCancelEvent = NULL;

	this->m_dwTestThreadID = 0;
	this->m_fDeadlockCheck = TRUE;
	this->m_dwLastTestthreadPing = 0;


	// private
	this->m_hTestThread = NULL;
	this->m_hKillTestThreadEvent = NULL;
	this->m_hNewTestEvent = NULL;

	this->m_pTest = NULL;

	this->m_fInitCOMForTestThread = FALSE;
	this->m_pfnInitializeTesting = NULL;
	this->m_pfnCleanupTesting = NULL;
	this->m_pfnGetTestingWindow = NULL;

	this->m_hErrToSrcFile = INVALID_HANDLE_VALUE;
	this->m_hDocFile = INVALID_HANDLE_VALUE;

	this->m_fPromptTestThreadDieTimeout = FALSE;
} // CTNExecutorPriv::CTNExecutorPriv
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::~CTNExecutorPriv()"
//==================================================================================
// CTNExecutorPriv destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNExecutorPriv object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNExecutorPriv::~CTNExecutorPriv(void)
{
	HRESULT		hr;


	DPL(9, "this = %x", 1, this);

	hr = this->Cleanup();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't clean up!  %e", 1, hr);
	} // end if (couldn't clean up)
} // CTNExecutorPriv::~CTNExecutorPriv
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::InitializeBySlave()"
//==================================================================================
// CTNExecutorPriv::InitializeBySlave
//----------------------------------------------------------------------------------
//
// Description: Prepares this object for usage.  Retrieves machine information.
//				This is only called when initializing a slave's executor.  Leeches
//				currently initialize their executors manually.
//
// Arguments:
//	PTNEXECUTORINITBYSLAVEDATA pTNeibsd		Pointer to parameter block to use when
//											initializing this object.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::InitializeBySlave(PTNEXECUTORINITBYSLAVEDATA pTNeibsd)
{
	HRESULT		hr;
	DWORD		dwTemp;
	char		szTemp[1024];

	this->m_pOwningSlave = pTNeibsd->pOwningSlave;

	switch (pTNeibsd->dwMode)
	{
		case TNMODE_API:
			DPL(1, "Using API mode.", 0);
		break;

		case TNMODE_STRESS:
			DPL(1, "Using stress mode.", 0);
		  break;

		case TNMODE_POKE:
			DPL(1, "Using poke mode.", 0);
		  break;

		case TNMODE_PICKY:
			DPL(1, "Using picky mode.", 0);
		  break;

		case TNMODE_DOCUMENTATION:
			DPL(1, "Using documentation mode.", 0);
		  break;
	} // end switch (on mode)
	this->m_dwMode = pTNeibsd->dwMode;

	CopyMemory(&(this->m_moduleID), pTNeibsd->pModuleID, sizeof (TNMODULEID));

	hr = this->m_info.LoadLocalMachineInfo(pTNeibsd->pszTestNetRootPath,
											pTNeibsd->pfnAddImportantBinaries,
											pTNeibsd->iMultiInstanceNum);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't load local machine info!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't load local info)

	this->m_pfnInitializeTesting = pTNeibsd->pfnInitializeTesting;
	this->m_pfnCleanupTesting = pTNeibsd->pfnCleanupTesting;
	this->m_pfnGetTestingWindow = pTNeibsd->pfnGetTestingWindow;
	this->m_fInitCOMForTestThread = pTNeibsd->fInitializeCOMInTestThread;
	this->m_fPromptTestThreadDieTimeout = pTNeibsd->fPromptTestThreadDieTimeout;


	hr = ScriptLoadTestTable(&(this->m_testtable));
	if (hr != S_OK)
	{
		DPL(0, "Loading built-in script functions failed!", 0);
		goto ERROR_EXIT;
	} // end if (loading built-in script functions failed)


	for(dwTemp = 0; dwTemp < pTNeibsd->dwNumLoadTestTables; dwTemp++)
	{
		hr = pTNeibsd->apfnLoadTestTable[dwTemp](&(this->m_testtable));
		if (hr != S_OK)
		{
			DPL(0, "Module's LoadTestTable callback %u failed!", 1, dwTemp);
			goto ERROR_EXIT;
		} // end if (module's callback failed)
	} // end for (each LoadTestTable callback)


	// If there's a user cancel event, duplicate it.
	if (pTNeibsd->hUserCancelEvent != NULL)
	{
		if (! DuplicateHandle(GetCurrentProcess(), pTNeibsd->hUserCancelEvent,
								GetCurrentProcess(), &(this->m_hUserCancelEvent),
								0, FALSE, DUPLICATE_SAME_ACCESS))
		{
			hr = GetLastError();
			DPL(0, "Couldn't duplicate user cancel event handle (%x)!",
				2, pTNeibsd->hUserCancelEvent);
			goto ERROR_EXIT;
		} // end if (couldn't duplicate handle)
	} // end if (there's a user cancel event)


#ifndef _XBOX // ErrToSrc not supported
	// If there's a path to use for ErrToSrc data, use it.
	if (pTNeibsd->pszErrToSrcFilepath != NULL)
	{
		DPL(1, "Creating ErrToSrc file \"%s\".", 1, pTNeibsd->pszErrToSrcFilepath);

		if ((pTNeibsd->pszErrToSrcPathSearch != NULL) &&
			(pTNeibsd->pszErrToSrcPathReplace != NULL))
		{
			this->m_pszErrToSrcPathSearch = (char*) LocalAlloc(LPTR, strlen(pTNeibsd->pszErrToSrcPathSearch) + 1);
			if (this->m_pszErrToSrcPathSearch == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto ERROR_EXIT;
			} // end if (couldn't allocate memory)

			strcpy(this->m_pszErrToSrcPathSearch, pTNeibsd->pszErrToSrcPathSearch);


			this->m_pszErrToSrcPathReplace = (char*) LocalAlloc(LPTR, strlen(pTNeibsd->pszErrToSrcPathReplace) + 1);
			if (this->m_pszErrToSrcPathReplace == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto ERROR_EXIT;
			} // end if (couldn't allocate memory)

			strcpy(this->m_pszErrToSrcPathReplace, pTNeibsd->pszErrToSrcPathReplace);


			DPL(1, "Will replace ErrToSrc paths containing \"%s\" with \"%s\".",
				2, this->m_pszErrToSrcPathSearch, this->m_pszErrToSrcPathReplace);
		} // end if (search/replace ErrToSrc)

		hr = FileCreateAndOpenFile(pTNeibsd->pszErrToSrcFilepath, FALSE, FALSE,
									FALSE, &(this->m_hErrToSrcFile));
		if (hr != S_OK)
		{
			DPL(0, "Couldn't create ErrToSrc file \"%s\"!",
				1, pTNeibsd->pszErrToSrcFilepath);
			goto ERROR_EXIT;
		} // end if (couldn't create file)


		StringGetCurrentDateStr(szTemp);
		StringPrepend(szTemp, "// ErrToSrc starting at ");

		FileWriteLine(this->m_hErrToSrcFile,
					"//==================================================================================");
		FileWriteLine(this->m_hErrToSrcFile, szTemp);
		FileWriteLine(this->m_hErrToSrcFile,
					"//==================================================================================");
		FileWriteLine(this->m_hErrToSrcFile, ""); // double space
	} // end if (should write ErrToSrc data)
#endif // ! XBOX

#ifndef _XBOX // Documentation mode not supported
	// If there's a path to use for documentation data, use it.  Make sure
	// the mode is appropriate, regardless.
	if (pTNeibsd->dwMode == TNMODE_DOCUMENTATION)
	{
		if (pTNeibsd->pszDocFilepath == NULL)
		{
			DPL(0, "In documentation mode but no filepath was specified!", 0);
			hr = ERROR_INVALID_PARAMETER;
			goto ERROR_EXIT;
		} // end if (no documentation filepath)


#ifndef _XBOX // Removed unnecessary logging
		wsprintf(szTemp, "Creating documentation file \"%s\"",
				pTNeibsd->pszDocFilepath);

		DPL(1, szTemp, 0);
		this->LogInternal(TNLST_CONTROLLAYER_INFO, szTemp);
#endif // ! XBOX


		hr = FileCreateAndOpenFile(pTNeibsd->pszDocFilepath, FALSE, FALSE,
									FALSE, &(this->m_hDocFile));
		if (hr != S_OK)
		{
			DPL(0, "Couldn't create documentation file \"%s\"!",
				1, pTNeibsd->pszDocFilepath);
			goto ERROR_EXIT;
		} // end if (couldn't create file)


		StringGetCurrentDateStr(szTemp);
		StringPrepend(szTemp, "// Documentation starting at ");

		FileWriteLine(this->m_hDocFile,
					"//==================================================================================");
		FileWriteLine(this->m_hDocFile, szTemp);
		FileWriteLine(this->m_hDocFile,
					"//==================================================================================");
		FileWriteLine(this->m_hDocFile, ""); // double space


		// We need to kick off the test thread right away, because it's the
		// worker thread which generates the documentation.
		hr = this->StartTestThread();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't start test thread!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't start test thread)
	} // end if (in documentation mode)
	else
	{
		if (pTNeibsd->pszDocFilepath != NULL)
		{
			DPL(0, "Not in documentation mode but a filepath (\"%s\") was specified!",
				1, pTNeibsd->pszDocFilepath);
			hr = ERROR_INVALID_PARAMETER;
			goto ERROR_EXIT;
		} // end if (documentation filepath specified)
	} // end else (not in documentation mode)
#endif // ! XBOX

	return (S_OK);


ERROR_EXIT:

	if (this->m_hUserCancelEvent != NULL)
	{
		CloseHandle(this->m_hUserCancelEvent);
		this->m_hUserCancelEvent = NULL;
	} // end if (duplicated handle)

	if (this->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(this->m_hDocFile);
		this->m_hDocFile = INVALID_HANDLE_VALUE;
	} // end if (opened doc file)

	if (this->m_hErrToSrcFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(this->m_hErrToSrcFile);
		this->m_hErrToSrcFile = INVALID_HANDLE_VALUE;
	} // end if (opened errtosrc file)

	if (this->m_pszErrToSrcPathSearch != NULL)
	{
		LocalFree(this->m_pszErrToSrcPathSearch);
		this->m_pszErrToSrcPathSearch = NULL;
	} // end if (allocated string)

	if (this->m_pszErrToSrcPathReplace != NULL)
	{
		LocalFree(this->m_pszErrToSrcPathReplace);
		this->m_pszErrToSrcPathReplace = NULL;
	} // end if (allocated string)

	// We may have started up the test thread, so ensure it's gone.  Ignore errors.
	this->KillTestThread(FALSE);

	return (hr);
} // CTNExecutorPriv::InitializeBySlave
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::Cleanup()"
//==================================================================================
// CTNExecutorPriv::Cleanup
//----------------------------------------------------------------------------------
//
// Description: Cleans up after this object.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::Cleanup(void)
{
	HRESULT			hr;
	int				i;
#ifndef _XBOX // no IPC supported
	PTNLEECH		pLeech;
#endif // ! XBOX
	PTNFAULTSIM		pFaultSim = NULL;


#pragma TODO(vanceo, "Remove/stop ongoing tests?")

	hr = this->KillTestThread(FALSE);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't kill test thread!  %e", 1, hr);
	} // end if (couldn't kill test thread)


#ifndef _XBOX // no IPC supported
	i = this->m_leeches.Count();
	while (i > 0)
	{
		pLeech = (PTNLEECH) this->m_leeches.GetItem(0);
		if (pLeech == NULL)
		{
			DPL(0, "Couldn't get first leech item (there should be %i remaining)!",
				1, i);
			break;
		} // end if (couldn't get item)

		hr = this->m_leeches.RemoveLeech(pLeech);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove leech %x!  %e", 2, pLeech, hr);
			break;
		} // end if (couldn't remove leech)
		pLeech = NULL;

		i--;
	} // end while (there are still leeches)
#endif // ! XBOX

	i = this->m_faultsims.Count();
	while (i > 0)
	{
		pFaultSim = (PTNFAULTSIM) this->m_faultsims.PopFirstItem();
		if (pFaultSim == NULL)
		{
			DPL(0, "Couldn't pop first fault sim item (there should be %i remaining)!",
				1, i);
			break;
		} // end if (couldn't pop item)

		hr = pFaultSim->Release();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't release fault sim %x!  %e", 2, pFaultSim, hr);
			break;
		} // end if (couldn't release fault sim)

		pFaultSim->m_dwRefCount--;
		if (pFaultSim->m_dwRefCount == 0)
		{
			delete (pFaultSim);
		} // end if (can delete object)
		else
		{
			DPL(0, "WARNING: Can't delete fault simulator %x, its refcount is %u!",
				2, pFaultSim, pFaultSim->m_dwRefCount);
		} // end else (can't delete object)

		pFaultSim = NULL;

		i--;
	} // end while (there are still fault sims)


	// Remove all results.
	hr = this->m_results.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove all results!  %e", 1, hr);
	} // end if (couldn't remove all items)


	// Reset the members, just like in the constructor

	this->m_dwMode = 0;
	ZeroMemory(&(this->m_moduleID), sizeof (TNMODULEID));

	if (this->m_pTest != NULL)
	{
		this->m_pTest->m_dwRefCount--;
		if (this->m_pTest->m_dwRefCount == 0)
		{
			DPL(0, "Deleting current test %x.", 1, this->m_pTest);
			delete (this->m_pTest);
		} // end if (refcount hit 0)
		else
		{
			DPL(0, "Not deleting current test %x, its refcount is %u.",
				2, this->m_pTest, this->m_pTest->m_dwRefCount);
		} // end else (refcount hasn't hit 0)

		this->m_pTest = NULL;
	} // end if (still have current test)


	// Remove all queued tests.
	hr = this->m_queuedtests.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove all queued tests!  %e", 1, hr);
	} // end if (couldn't remove all items)

	// Remove all ongoing tests.
	hr = this->m_ongoingtests.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove all ongoing tests!  %e", 1, hr);
	} // end if (couldn't remove all items)


	if (this->m_hUserCancelEvent != NULL)
	{
		CloseHandle(this->m_hUserCancelEvent);
		this->m_hUserCancelEvent = NULL;
	} // end if (have cancel event)


	if (this->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(this->m_hDocFile);
		this->m_hDocFile = INVALID_HANDLE_VALUE;
	} // end if (still have doc file)

	if (this->m_hErrToSrcFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(this->m_hErrToSrcFile);
		this->m_hErrToSrcFile = INVALID_HANDLE_VALUE;
	} // end if (still have errtosrc file)

	if (this->m_pszErrToSrcPathSearch != NULL)
	{
		LocalFree(this->m_pszErrToSrcPathSearch);
		this->m_pszErrToSrcPathSearch = NULL;
	} // end if (allocated string)

	if (this->m_pszErrToSrcPathReplace != NULL)
	{
		LocalFree(this->m_pszErrToSrcPathReplace);
		this->m_pszErrToSrcPathReplace = NULL;
	} // end if (allocated string)

	return (hr);
} // CTNExecutorPriv::Cleanup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::StartTestThread()"
//==================================================================================
// CTNExecutorPriv::StartTestThread
//----------------------------------------------------------------------------------
//
// Description: Creates the events and thread used for testing, if they don't
//				already exist.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::StartTestThread(void)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed bad pointer)


	// Create kill thread manual reset event if it doesn't exist
	if (this->m_hKillTestThreadEvent == NULL)
	{
		this->m_hKillTestThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		if (this->m_hKillTestThreadEvent == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create kill thread event!", 0);
			return (hr);
		} // end if (couldn't create kill thread event)
	} // end if (kill event doesn't exist)


	// Create new test auto reset event if it doesn't exist
	if (this->m_hNewTestEvent == NULL)
	{
		this->m_hNewTestEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (this->m_hNewTestEvent == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create new test event!", 0);
			return (hr);
		} // end if (couldn't create new test event)
	} // end if (new test event doesn't exist)


	// Create the actual thread if it doesn't exist
	if (this->m_hTestThread == NULL)
	{
		this->m_hTestThread = CreateThread(NULL, 0, ExecutorTestThreadProc,
											this, 0, &(this->m_dwTestThreadID));
		if (this->m_hTestThread == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create test thread!", 0);
			return (hr);
		} // end if (couldn't create thread)

		// The test thread is starting up, so initialize the time.
		this->m_dwLastTestthreadPing = GetTickCount();
	} // end if (kill event doesn't exist)

	return (S_OK);
} // CTNExecutorPriv::StartTestThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::KillTestThread()"
//==================================================================================
// CTNExecutorPriv::KillTestThread
//----------------------------------------------------------------------------------
//
// Description: Shuts down the test thread and releases the events it used.
//
// Arguments:
//	BOOL fKillingSelf	Only TRUE when the test thread itself is calling this
//						function.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::KillTestThread(BOOL fKillingSelf)
{
	HRESULT		hr = S_OK;
	DWORD		dwExitCode;
	DWORD		dwTimeout;
	int			iResult;


	DPL(9, "==> (%B)", 1, fKillingSelf);

	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (got passed bad pointer)


	// If the thread is initiating the shutdown, go right to the cleanup.
	if (fKillingSelf)
		goto DONE;

		
	// Close all items associated with the thread
	if (this->m_hTestThread != NULL)
	{
		// First check to see if it already died on its own
		if (! GetExitCodeThread(this->m_hTestThread, &dwExitCode))
		{
			hr = GetLastError();
			DPL(0, "Couldn't get thread exit code!", 0);
			goto DONE;
		} // end if (couldn't get the thread's exit code)

		if (dwExitCode != STILL_ACTIVE)
		{
			DPL(0, "Test thread killed itself!  %e", 1, dwExitCode);

			// Note: hr == S_OK
			goto DONE;
		} // end if (the thread must have killed itself)

		if (this->m_hKillTestThreadEvent == NULL) // ack, we won't be able to tell it to die
		{
			DPL(0, "Kill thread event doesn't exist, can't tell it to die!", 0);
			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (kill event doesn't exist)

		if (! SetEvent(this->m_hKillTestThreadEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set kill thread event!", 0);
			goto DONE;
		} // end if (couldn't set kill event)


		dwTimeout = TIMEOUT_DIE_TESTTHREAD;

RETRY:

		hr = WaitForSingleObject(this->m_hTestThread, dwTimeout);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// what we want
				hr = S_OK;
			  break;

			case WAIT_TIMEOUT:
				// Hmm, let's try getting the exit code again
				if (! GetExitCodeThread(this->m_hTestThread, &dwExitCode))
				{
					hr = GetLastError();
					DPL(0, "Couldn't get thread exit code!", 0);
					goto DONE;
				} // end if (couldn't get the thread's exit code)

				if (dwExitCode != STILL_ACTIVE)
				{
					DPL(0, "Test thread died in unusual way!  %e", 1, dwExitCode);

					// Note: hr == S_OK
					goto DONE;
				} // end if (the thread must have killed itself)


#ifndef _XBOX // removed unnecessary logging
				DPL(0, "Waited %i ms for test thread to die but it didn't (process ID = %x/%u, test thread ID %x/%u)!",
					5, dwTimeout,
					GetCurrentProcessId(), GetCurrentProcessId(),
					this->m_dwTestThreadID, this->m_dwTestThreadID);
#endif // ! XBOX


				if (this->m_fPromptTestThreadDieTimeout)
				{
					DPL(0, "Prompting user for action to take with this test thread that just won't die...", 0);

#ifndef _XBOX // no GDI supported
					iResult = MessageBox(NULL,
										"TestNet's test thread has not finished yet.  Press Abort to break into debugger, Retry to wait 10 more seconds, or Ignore to continue with your fingers crossed.\n"
										"Please see the debug spew for more information.",
										"TestNet test thread still hasn't finished!",
										MB_ABORTRETRYIGNORE | MB_ICONSTOP | MB_DEFBUTTON1);
#else // ! XBOX
#pragma TODO(tristanj, "Removed MessageBox, so hardcoded as if ABORT was returned.")
					iResult = IDABORT;
#endif // XBOX
					switch (iResult)
					{
						case IDABORT:
#ifndef _XBOX // removed unnecessary logging
							DPL(0, "User elected to DEBUGBREAK() because of test thread that hasn't finished (process ID = %x/%u, test thread ID %x/%u)!",
								4, GetCurrentProcessId(), GetCurrentProcessId(),
								this->m_dwTestThreadID, this->m_dwTestThreadID);
#endif // ! XBOX

							DEBUGBREAK();

							hr = E_FAIL;
						  break;

						case IDRETRY:
							DPL(0, "User elected to wait 10 more seconds for test thread to shut down.", 0);

							// Wait another 10 seconds.
							dwTimeout = 10000;
							goto RETRY;
						  break;
						  
						case IDIGNORE:
							DPL(0, "User elected to ignore problems shutting down test thread!  This app may hang!", 0);
							hr = S_OK;
						  break;
						  
						default:
							hr = GetLastError();
							DPL(0, "Unexpected return from MessageBox (%i)!  DEBUGBREAK()-ing.  %e",
								2, iResult, hr);

							DEBUGBREAK();

							if (hr == S_OK)
								hr = E_FAIL;
						  break;
					} // end switch (on button pressed)
				} // end if (should prompt user for action)
				else
				{
#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
					DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT

					//hr = WAIT_TIMEOUT;
				} // end else (should not prompt user for action)
			  break;

			default:
				DPL(0, "Got unexpected return code (%i) from WaitForSingleObject on the test thread!",
					1, hr);
			  break;
		} // end switch (on result of waiting for thread to die)

	} // end if (the test thread exists)


DONE:

	if (this->m_hTestThread != NULL)
	{
		CloseHandle(this->m_hTestThread);
		this->m_hTestThread = NULL;
	} // end if (have handle)

	if (this->m_hKillTestThreadEvent != NULL)
	{
		CloseHandle(this->m_hKillTestThreadEvent);
		this->m_hKillTestThreadEvent = NULL;
	} // end if (have event)

	if (this->m_hNewTestEvent != NULL)
	{
		CloseHandle(this->m_hNewTestEvent);
		this->m_hNewTestEvent = NULL;
	} // end if (have event)

	this->m_dwLastTestthreadPing = 0;

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutorPriv::KillTestThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::HandleNewTest()"
//==================================================================================
// CTNExecutorPriv::HandleNewTest
//----------------------------------------------------------------------------------
//
// Description: Handles a new test to run.
//
// Arguments:
//	DWORD dwUniqueTestID		Unique ID of test to run.
//	char* pszCaseID				Module defined case ID of the test.
//	char* pszInstanceID			User defined instance ID of the test.
//	int iNumMachines			Total number of testers for the instance
//	PTNCTRLMACHINEID aTesters	Array of tester IDs in tester number order.
//	PVOID pvInputData			Pointer to input data, if any.
//	DWORD dwInputDataSize		Pointer to input data size, if any.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::HandleNewTest(DWORD dwUniqueTestID,
									char* pszCaseID, char* pszInstanceID,
									int iNumMachines, PTNCTRLMACHINEID aTesters,
									PVOID pvInputData, DWORD dwInputDataSize)
{
	HRESULT				hr = S_OK;
	PTNTESTINSTANCES	pTest = NULL;
	PTNTESTTABLECASE	pCase = NULL;


	pCase = this->m_testtable.GetTest(pszCaseID);
	if (pCase == NULL)
	{
		DPL(0, "Couldn't find test case ID %s in table!", 1, pszCaseID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find that test in the table)

	//BUGBUG do we want to get the TNTIO_xxx options from the master?
	pTest = new (CTNTestInstanceS)(dwUniqueTestID,
									pCase,
									pszInstanceID,
									iNumMachines,
									aTesters,
									//0,
									NULL);
	if (pTest == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pTest->m_dwRefCount++; // we're using the object

	if (dwInputDataSize > 0)
	{
		hr = pTest->SetInputData(pvInputData, dwInputDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't set the input data for the test!", 0);
			goto DONE;
		} // end if (couldn't set the test's input data)
	} // end if (there's input data for the test)


	// This really shouldn't be happening, because the only time we're told to
	// run a new test is when we don't have anything else to be running.  But
	// for now, just print a warning and queue it up.
	if (this->m_queuedtests.Count() > 0)
	{
		DPL(0, "WARNING: Queueing test (case \"%s\", unique ID %u) behind %i other items!",
			3, pTest->m_pCase->m_pszID, pTest->m_dwUniqueID,
			this->m_queuedtests.Count());
	} // end if (there are tests queued already)


	// Add it to the queue to be run.
	hr = this->m_queuedtests.Add(pTest);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add test %x to queue!", 1, pTest);
		goto DONE;
	} // end if (couldn't add it to the list)

	// Trigger the event to wake up the testing thread.
	if (! SetEvent(this->m_hNewTestEvent))
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't set new test event (%x)!", 1, this->m_hNewTestEvent);
		goto DONE;
	} // end if (couldn't set event)



DONE:

	if (pTest != NULL)
	{
		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Not deleting test %x (ID %u).",
				2, pTest, pTest->m_dwUniqueID);
			delete (pTest);
			pTest = NULL;
		} // end if (can delete test)
		else
		{
			DPL(7, "Not deleting test %x (ID %u), its refcount = %u.",
				3, pTest, pTest->m_dwUniqueID, pTest->m_dwRefCount);
		} // end else (can't delete test)
	} // end if (we have the test)

	return (hr);
} // CTNExecutorPriv::HandleNewTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::HandleAnnounceResponse()"
//==================================================================================
// CTNExecutorPriv::HandleAnnounceResponse
//----------------------------------------------------------------------------------
//
// Description: Handles a test response resulting from a test announcement.
//
// Arguments:
//	DWORD dwResponseID		ID of request that asked for this test, or 0 for none.
//	DWORD dwUniqueTestID	Unique ID of test to run.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::HandleAnnounceResponse(DWORD dwResponseID, DWORD dwUniqueTestID)
{
	HRESULT				hr = S_OK;
	BOOL				fSetNewTestEvent = FALSE;
	PTNTESTINSTANCES	pTest = NULL;
	int					i;


	// Check the list of queued tests first.
	for(i = 0; i < this->m_queuedtests.Count(); i++)
	{
		pTest = (PTNTESTINSTANCES) this->m_queuedtests.GetItem(i);
		if (pTest == NULL)
		{
			DPL(0, "Couldn't get top level ongoing test %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		pTest = pTest->GetTestWithRequestID(dwResponseID);
		if (pTest != NULL)
		{
			fSetNewTestEvent = TRUE;
			break;
		} // end if (we found it in the queue)
	} // end for (each ongoing test heirarchy)

	// If we haven't found the announcing parent test yet, check the current active
	// test hierarchy.
	if (pTest == NULL)
	{
		if (this->m_pTest != NULL)
		{
			pTest = this->m_pTest->GetTestWithRequestID(dwResponseID);
		} // end if (have a current active test)
	} // end if (haven't found test yet)

	// If we haven't found the announcing parent test yet, check the ongoing tests.
	if (pTest == NULL)
	{
		for(i = 0; i < this->m_ongoingtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCES) this->m_ongoingtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get top level ongoing test %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)

			pTest = pTest->GetTestWithRequestID(dwResponseID);
			if (pTest != NULL)
				break;
		} // end for (each ongoing test heirarchy)
	} // end if (have a current active test)

	// If we still haven't found the announcing parent test, something's wrong.
	if (pTest == NULL)
	{
		DPL(0, "Couldn't find test that announced using request ID %u!",
			1, dwResponseID);
		hr = E_FAIL;
		goto DONE;
	} // end if (didn't find test)


	// If we're in Poke mode, the test with the request is the one which was
	// waiting for an ID.  Otherwise, it's the parent test of the subtest that
	// was waiting.
	if (this->m_dwMode == TNMODE_POKE)
	{
		// Make sure the test hasn't already been given an ID.
		if (pTest->m_dwUniqueID != 0xFFFFFFFF)
		{
			DPL(0, "Test to get ID %u received using request ID %u already has test ID %u!",
				3, dwUniqueTestID, dwResponseID, pTest->m_dwUniqueID);
			hr = E_FAIL;
			goto DONE;
		} // end if (didn't find test)

		// The test gets the ID.
		pTest->m_dwUniqueID = dwUniqueTestID;
	} // end if (in Poke mode)
	else
	{
		// Make sure the parent test has a valid subtest.
		if (pTest->m_pSubTest == NULL)
		{
			DPL(0, "Couldn't find subtest that should get ID (%u) received using request ID %u!",
				2, dwUniqueTestID, dwResponseID);
			hr = E_FAIL;
			goto DONE;
		} // end if (didn't find test)

		// Make sure the subtest hasn't already been given an ID.
		if (pTest->m_pSubTest->m_dwUniqueID != 0xFFFFFFFF)
		{
			DPL(0, "Subtest to get ID %u received using request ID %u already has test ID %u!",
				3, dwUniqueTestID, dwResponseID, pTest->m_pSubTest->m_dwUniqueID);
			hr = E_FAIL;
			goto DONE;
		} // end if (didn't find test)

		// The sub test gets the ID.
		pTest->m_pSubTest->m_dwUniqueID = dwUniqueTestID;
	} // end else (not in Poke mode)


	pTest->m_hrResponseResult = S_OK;

	if (fSetNewTestEvent)
	{
		pTest->m_dwRequestID = 0; // clear the request ID

		DPL(8, "Notifying test thread that test %u is now ready.",
			1, dwUniqueTestID);

		if (! SetEvent(this->m_hNewTestEvent))
		{
			hr = GetLastError();

			DPL(0, "WARNING: Couldn't set new test event (%x)!  %e",
				2, this->m_hNewTestEvent, hr);

			// Treat it as OK.  See notes below.
			hr = S_OK;
		} // end if (couldn't set event)
	} // end if (should notify test thread)
	else
	{
		DPL(8, "Notifying some waiting thread that test %u is now ready.",
			1, dwUniqueTestID);

		if (! SetEvent(pTest->m_hResponseEvent))
		{
			hr = GetLastError();

			DPL(0, "WARNING: Couldn't set announcement response event (%x)!  %e",
				2, pTest->m_hResponseEvent, hr);

			// Treat it as OK because I have seen an instance where this failed
			// for no apparent reason.  The waiting thread got triggered fine,
			// so I suspect what happened was that the waiting thead managed to
			// close the event handle before the SetEvent call officially
			// returned, and thus it ended up failing with ERROR_INVALID_HANDLE.
			hr = S_OK;
		} // end if (couldn't set event)
	} // end else (should release whomever was waiting on this)


DONE:

	return (hr);
} // CTNExecutorPriv::HandleAnnounceResponse
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::HandleSyncResponse()"
//==================================================================================
// CTNExecutorPriv::HandleSyncResponse
//----------------------------------------------------------------------------------
//
// Description: Handles a response resulting from a sync request.
//
// Arguments:
//	DWORD dwResponseID		ID of request that asked for this test, or 0 for none.
//	PVOID pvData			Pointer to incoming data from other testers.
//	DWORD dwDataSize		Size of incoming data buffer.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::HandleSyncResponse(DWORD dwResponseID, PVOID pvData,
											DWORD dwDataSize)
{
	HRESULT				hr = S_OK;
	PTNTESTINSTANCES	pTest = NULL;
	int					i;


	// Check the current active test hierarchy first
	if (this->m_pTest != NULL)
	{
		pTest = this->m_pTest->GetTestWithRequestID(dwResponseID);
	} // end if (have a current active test)

	// If we haven't found the syncing test yet, check the ongoing tests
	if (pTest == NULL)
	{
		for(i = 0; i < this->m_ongoingtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCES) this->m_ongoingtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get top level ongoing test %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)

			pTest = pTest->GetTestWithRequestID(dwResponseID);
			if (pTest != NULL)
				break;
		} // end for (each ongoing test heirarchy)
	} // end if (have a current active test)

	// If we still haven't found the syncing test, something's wrong
	if (pTest == NULL)
	{
		DPL(0, "Couldn't find test that synchronized using request ID %u!",
			1, dwResponseID);
		hr = E_FAIL;
		goto DONE;
	} // end if (didn't find test)

	if (pvData != NULL)
	{
		if (pTest->m_pSyncDataList == NULL)
		{
			DPL(0, "Test %u's receive sync data list doesn't exist but data is incoming!",
				1, pTest->m_dwUniqueID);
			hr = E_FAIL;
			goto DONE;
		} // end if (the receive data list is gone)

		hr = pTest->m_pSyncDataList->UnpackFromBuffer(pvData, dwDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack sync data list!", 0);
			goto DONE;
		} // end if (couldn't add sync data from tester)
	} // end if (there's actually data associated with the response)


	pTest->m_hrResponseResult = S_OK;

	if (! SetEvent(pTest->m_hResponseEvent))
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't set sync response event (%x)!",
			1, pTest->m_hResponseEvent);
		goto DONE;
	} // end if (couldn't set event)


DONE:

	return (hr);
} // CTNExecutorPriv::HandleSyncResponse
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::HandleLostTester()"
//==================================================================================
// CTNExecutorPriv::HandleLostTester
//----------------------------------------------------------------------------------
//
// Description: Handles a lost tester.  If we're already done with that test, or
//				minding our own business, we ignore it.  If we're doing something
//				involving that tester right now, though, then we have to abort it.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test under which a tester was lost.
//	DWORD dwTestUniqueID		ID of test with problem.
//	int iLostTesterNum			Tester number who was lost.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::HandleLostTester(DWORD dwTopLevelUniqueID,
										DWORD dwTestUniqueID,
										int iLostTesterNum)
{
	HRESULT				hr = S_OK;
	PTNTESTINSTANCES	pTest = NULL;
#ifndef _XBOX // no IPC supported
	int					i;
	PTNLEECH			pLeech;
#endif // ! XBOX



#pragma BUGBUG(vanceo, "There really should be a locking mechanism here")

	pTest = this->GetTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(1, "Couldn't find test %u:%u which lost tester %i, ignoring.",
			3, dwTopLevelUniqueID, dwTestUniqueID, iLostTesterNum);

		// See comments above.
		goto DONE;
	} // end if (couldn't find test)


	pTest->m_dwRefCount++; // we're using it

	pTest->m_paTesterSlots[iLostTesterNum].fGone = TRUE;


	// If the test is currently waiting for something, fire it and let it know
	// there's a problem.
	if (pTest->m_dwRequestID != 0)
	{
		DPL(0, "Lost tester %i in test %u:%u, alerting waiting operation %u.",
			4, iLostTesterNum, dwTopLevelUniqueID, dwTestUniqueID,
			pTest->m_dwRequestID);

		pTest->m_hrResponseResult = TNERR_LOSTTESTER;

		// Since we don't have a lock, it's possible to try setting the event
		// after the handle has been closed.  Just ignore the error.
		if (! SetEvent(pTest->m_hResponseEvent))
		{
			hr = GetLastError();

			DPL(0, "WARNING: Couldn't set response event (%x)!  %e",
				2, pTest->m_hResponseEvent, hr);

			hr = S_OK;

			goto DONE;
		} // end if (couldn't set event)
	} // end if (some request is outstanding)
	else
	{
		DPL(3, "Test %u:%u lost tester %i, alerting any leeches and noting for future reference.",
			3, dwTopLevelUniqueID, dwTestUniqueID, iLostTesterNum);

#ifndef _XBOX // no IPC supported
		// We want to pass the LostTester message down to any leeches we may have.
		this->m_leeches.EnterCritSection();
		for(i = 0; i < this->m_leeches.Count(); i++)
		{
			pLeech = (PTNLEECH) this->m_leeches.GetItem(i);
			if (pLeech == NULL)
			{
				DPL(0, "Couldn't get leech %i!", 1, i);
				this->m_leeches.LeaveCritSection();
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get leech)

			hr = pLeech->SendLostTesterMsgToOtherSide(dwTopLevelUniqueID, dwTestUniqueID,
													iLostTesterNum);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't send lost tester message (%u:%u, %i) to leech %i!",
					4, dwTopLevelUniqueID, dwTestUniqueID, iLostTesterNum, i);
				this->m_leeches.LeaveCritSection();
				goto DONE;
			} // end if (couldn't ping leech)
		} // end for (each leech)
		this->m_leeches.LeaveCritSection();
#endif // ! XBOX

	} // end else (no requests outstanding)


DONE:

	if (pTest != NULL)
	{
		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting test %x (id %u).", 2, pTest, pTest->m_dwUniqueID);
			delete (pTest);
			pTest = NULL;
		} // end if (we can delete the test)
		else
		{
			DPL(7, "Not deleting test %x (id %u), its refcount = %u.",
				3, pTest, pTest->m_dwUniqueID, pTest->m_dwRefCount);
		} // end else (we can't delete the test)
	} // end if (have test)

	return (hr);
} // CTNExecutorPriv::HandleLostTester
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::HandleGetMachineInfoResponse()"
//==================================================================================
// CTNExecutorPriv::HandleGetMachineInfoResponse
//----------------------------------------------------------------------------------
//
// Description: Handles a response resulting from a GetMachineInfo request.
//
// Arguments:
//	DWORD dwResponseID		ID of request that asked for this test, or 0 for none.
//	PVOID pvData			Pointer to machine info data buffer.
//	DWORD dwDataSize		Size of buffer.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::HandleGetMachineInfoResponse(DWORD dwResponseID, PVOID pvData,
													DWORD dwDataSize)
{
	HRESULT				hr = S_OK;
	PTNTESTINSTANCES	pTest = NULL;
	int					i;


	// Check the current active test hierarchy first
	if (this->m_pTest != NULL)
	{
		pTest = this->m_pTest->GetTestWithRequestID(dwResponseID);
	} // end if (have a current active test)

	// If we haven't found the syncing test yet, check the ongoing tests
	if (pTest == NULL)
	{
		for(i = 0; i < this->m_ongoingtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCES) this->m_ongoingtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get top level ongoing test %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)

			pTest = pTest->GetTestWithRequestID(dwResponseID);
			if (pTest != NULL)
				break;
		} // end for (each ongoing test heirarchy)
	} // end if (have a current active test)

	// If we still haven't found the syncing test, something's wrong
	if (pTest == NULL)
	{
		DPL(0, "Couldn't find test that tried to GetMachineInfo using request ID %u!",
			1, dwResponseID);
		hr = E_FAIL;
		goto DONE;
	} // end if (didn't find test)

	if ((pvData != NULL) && (pTest->m_pReturnedInfo != NULL))
	{
		hr = pTest->m_pReturnedInfo->UnpackFromBuffer(pvData, dwDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack info data!", 0);
			goto DONE;
		} // end if (couldn't unpack info)
	} // end if (there's data and a place to store it)
	else
	{
		DPL(0, "No data or no place to store it (%x, %x)!?  DEBUGBREAK()-ing.",
			2, pvData, pTest->m_pReturnedInfo);
		DEBUGBREAK();
	} // end else (no data or no place to store it)


	pTest->m_hrResponseResult = S_OK;

	if (! SetEvent(pTest->m_hResponseEvent))
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't set GetMachineInfo response event (%x)!",
			1, pTest->m_hResponseEvent);
		goto DONE;
	} // end if (couldn't set event)


DONE:

	return (hr);
} // CTNExecutorPriv::HandleGetMachineInfoResponse
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::DoTestThread()"
//==================================================================================
// CTNExecutorPriv::DoTestThread
//----------------------------------------------------------------------------------
//
// Description: Function that performs the real test thread behavior.  Waits for an
//				item to test, then executes it.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::DoTestThread(void)
{
	HRESULT					hr = S_OK;
	HMODULE					hOle32 = NULL;
	PCOINITIALIZEEXPROC		pfnCoInitializeEx = NULL;
	BOOL					fCOMInitted = FALSE;
	BOOL					fInitTestingCalled = FALSE;
	HANDLE					ahWaitArray[3];
	int						i;
	char					szTemp[1024];


	if (this->m_hKillTestThreadEvent == NULL)
	{
		DPL(0, "Kill thread event doesn't exist!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (event doesn't exist)

	if (this->m_hNewTestEvent == NULL)
	{
		DPL(0, "New test event doesn't exist!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (event doesn't exist)

	if (this->m_fInitCOMForTestThread)
	{
#ifndef _XBOX // CoInitialize not supported
#pragma BUGBUG(vanceo, "CoInitializeEx is crashing my Win9x machines when CoCreating DNWSOCK")
		//hOle32 = LoadLibrary("ole32.dll");
		if (hOle32 != NULL)
			pfnCoInitializeEx = (PCOINITIALIZEEXPROC) GetProcAddress(hOle32, "CoInitializeEx");

		// If we couldn't get it, assume it's because we're on a Win95 Gold machine
		if (pfnCoInitializeEx == NULL)
		{
			DPL(8, "Initializing COM with single thread apartment concurrency model.", 0);

			// Just use the regular CoInitialize.  S_FALSE is okay, it just means it
			// was already called.
			hr = CoInitialize(NULL);
			if ((hr != S_OK) && (hr != S_FALSE))
			{
				DPL(0, "Couldn't initialize COM!", 0);
				goto DONE;
			} // end if (couldn't initialize COM)
		}
		else
		{
			DPL(8, "Initializing COM with multithread apartment concurrency model.", 0);

			// Note: this function call requires DCOM95 to be installed on Win95
			// machines and it returns S_FALSE if it was already called (which is
			// documented as being okay, as long as we balance the calls).
			hr = pfnCoInitializeEx(NULL, COINIT_MULTITHREADED);
			if ((hr != S_OK) && (hr != S_FALSE))
			{
				DPL(0, "Couldn't initialize COM using Ex interface!", 0);
				goto DONE;
			} // end if (couldn't initialize COM ex)
		} // end if (got CoInitializeEx)
#endif // ! XBOX

		fCOMInitted = TRUE;

		if (hOle32 != NULL)
		{
			FreeLibrary(hOle32); // ignore error
			hOle32 = NULL;
		} // end if (have OLE library)
	} // end if (the test thread should initialize COM)


	// Let the user prep for testing if it wants too.
	if (this->m_pfnInitializeTesting != NULL)
	{
		DPL(9, "Calling module's InitializeTesting function %X",
			1, this->m_pfnInitializeTesting);

		hr = this->m_pfnInitializeTesting(&(this->m_info));
		if (hr != S_OK)
		{
			DPL(0, "Module's InitializeTesting callback failed!", 0);
			goto DONE;
		} // end if (app's callback failed)

		fInitTestingCalled = TRUE;
	} // end if (the module has an init testing callback)


	// If we're in documentation mode, we have to do things a little
	// differently.
	if (this->m_dwMode == TNMODE_DOCUMENTATION)
	{
		DPL(0, "Beginning documentation.", 0);
		this->LogInternal(TNLST_CONTROLLAYER_INFO, "Beginning documentation.");


		// Ping the UI to let it know.
		if (! SetEvent(this->m_pOwningSlave->m_hCompletionOrUpdateEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set event %x!",
				1, this->m_pOwningSlave->m_hCompletionOrUpdateEvent);
			goto DONE;
		} // end if (couldn't set event)


		hr = this->DoDocumentation(&(this->m_testtable));
		if (hr != S_OK)
		{
			DPL(0, "Doing documentation failed!", 0);
			goto DONE;
		} // end if (doing documentation)


		DPL(0, "Documentation done.", 0);
		this->LogInternal(TNLST_CONTROLLAYER_INFO, "Documentation done.");


		// Ping the UI to let it know.
		if (! SetEvent(this->m_pOwningSlave->m_hCompletionOrUpdateEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set event %x!",
				1, this->m_pOwningSlave->m_hCompletionOrUpdateEvent);
			goto DONE;
		} // end if (couldn't set event)


		// This thread's mission in life is now complete.
		goto DONE;
	} // end if (in documenation mode)


	ahWaitArray[0] = this->m_hKillTestThreadEvent;
	ahWaitArray[1] = this->m_hNewTestEvent;
	ahWaitArray[2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	do
	{
		// Update the control layer to let it know we're still alive
		this->m_dwLastTestthreadPing = GetTickCount();

		switch (WaitForMultipleObjects(2, ahWaitArray, FALSE, IDLE_INTERVAL))
		{
			case WAIT_OBJECT_0:
				// Time to die.
				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// We probably have a new test, so check our queue.

#ifdef DEBUG
				if (this->m_pTest != NULL)
				{
					DPL(0, "Current test is not NULL!", 0);
					DEBUGBREAK();
				} // end if (current test is not NULL)
#endif // DEBUG

				do
				{
					this->m_queuedtests.EnterCritSection();
					for(i = 0; i < this->m_queuedtests.Count(); i++)
					{
						this->m_pTest = (PTNTESTINSTANCES) this->m_queuedtests.GetItem(i);
						if (this->m_pTest == NULL)
						{
							DPL(0, "Couldn't get queued test %i!", 1, i);
							this->m_queuedtests.LeaveCritSection();
							hr = E_FAIL;
							goto DONE;
						} // end if (no test)

						if (this->m_pTest->m_dwRequestID != 0)
						{
							DPL(8, "Not running test %u, it's waiting for something (request ID %u).",
								1, this->m_pTest->m_dwRequestID);

							// Forget about the test.
							this->m_pTest = NULL;
						} // end if (this test is waiting for something)
						else
						{
							// Make sure it's known we're using the test.
							this->m_pTest->m_dwRefCount++;

							// Pull it from the queue.
							hr = this->m_queuedtests.RemoveFirstReference(this->m_pTest);
							if (hr != S_OK)
							{
								DPL(0, "Couldn't remove test %x from queue!",
									1, this->m_pTest);
								goto DONE;
							} // end if (couldn't remove test)

							break;
						} // end else (this test isn't waiting)
					} // end for (each test in the queue)
					this->m_queuedtests.LeaveCritSection();


					// If we couldn't get a test it's because there aren't any left
					// to run.  Stop looping and go back to sleep.
					if (this->m_pTest == NULL)
						break;


					// Otherwise, run the test.

					hr = this->RunTest(this->m_pTest, this->m_pTest->m_pvInputData,
										this->m_pTest->m_dwInputDataSize);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't run top level test!", 0);
						goto DONE;
					} // end if (couldn't run test)


#pragma BUGBUG(vanceo, "Having ReportInternal clear this->m_pTest is kind of funky")
					// Note that ReportInternal is the function where this->m_pTest
					// is cleared, so it might be invalid at this point.


					// Update the control layer to let it know we're still alive
					this->m_dwLastTestthreadPing = GetTickCount();
				} // end do (while there are more tests to run)
				while (TRUE);
			  break;

			case WAIT_TIMEOUT:
				if (this->m_pOwningSlave == NULL)
				{
#pragma TODO(vanceo, "Implement leech idle")
				} // end if (not owned by slave)
				else
				{
					// Twiddle our thumbs while we're waiting.
					hr = this->m_pOwningSlave->DoIdle(CTRLIDLE_NOTHING);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't perform the idle activities!", 0);
						goto DONE;
					} // end if (failed idling)
				} // end else (owned by slave)
			  break;

			default:
				DPL(0, "Got unexpected return from WaitForMultipleObjects!", 0);
				hr = E_FAIL;
			  break;
		} // end switch (on wait return)
	} // end do
	while (hr == S_OK);


DONE:

	// Let the user cleanup after testing if it wants too.
	if (fInitTestingCalled && (this->m_pfnCleanupTesting != NULL))
	{
		HRESULT		temphr;


		DPL(9, "Calling module's CleanupTesting function %X",
			1, this->m_pfnCleanupTesting);

		temphr = this->m_pfnCleanupTesting(&(this->m_info));
		if (temphr != S_OK)
		{
			DPL(0, "Module's CleanupTesting callback failed!", 0);
			
			// Only overwrite error if it was success previously.
			if (hr == S_OK)
				hr = temphr;
		} // end if (app's callback failed)

		fInitTestingCalled = FALSE;
	} // end if (the module has an init testing callback)

#ifndef _XBOX // no file logging supported
	if (this->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		FileWriteLine(this->m_hDocFile, ""); // double space
		FileWriteLine(this->m_hDocFile,
					"//==================================================================================");
		FileWriteLine(this->m_hDocFile, "// Documentation build listing complete");
		FileWriteLine(this->m_hDocFile,
					"//==================================================================================");

		CloseHandle(this->m_hDocFile);
		this->m_hDocFile = INVALID_HANDLE_VALUE;
	} // end if (have doc file)
#else // ! XBOX
#pragma TODO(tristanj, "What to do about documenation logging?")
#endif // XBOX

#ifndef _XBOX // no file logging supported
	if (this->m_hErrToSrcFile != INVALID_HANDLE_VALUE)
	{
#pragma BUGBUG(vanceo, "do this right")
		StringGetCurrentDateStr(szTemp);
		StringPrepend(szTemp, "// ErrToSrc complete at ");


		FileWriteLine(this->m_hErrToSrcFile, ""); // double space
		FileWriteLine(this->m_hErrToSrcFile,
					"//==================================================================================");
		FileWriteLine(this->m_hErrToSrcFile, szTemp);
		FileWriteLine(this->m_hErrToSrcFile,
					"//==================================================================================");

		CloseHandle(this->m_hErrToSrcFile);
		this->m_hErrToSrcFile = INVALID_HANDLE_VALUE;


		if (this->m_pszErrToSrcPathSearch != NULL)
		{
			LocalFree(this->m_pszErrToSrcPathSearch);
			this->m_pszErrToSrcPathSearch = NULL;
		} // end if (allocated string)

		if (this->m_pszErrToSrcPathReplace != NULL)
		{
			LocalFree(this->m_pszErrToSrcPathReplace);
			this->m_pszErrToSrcPathReplace = NULL;
		} // end if (allocated string)
	} // end if (have errtosrc file)
#else // ! XBOX
#pragma TODO(tristanj, "What to do about ErrToSrc logging?")
#endif // XBOX

	if (hr != S_OK)
	{
		DPL(0, "%s test thread aborting!  DEBUGBREAK()-ing.  %e",
			2, ((this->m_pOwningSlave != NULL) ? "Slave" : "Leech"), hr);

		// Ignoring error
		this->SprintfLogInternal(TNLST_CRITICAL, "%s test thread aborting!  DEBUGBREAK()-ing.  %e",
			2, ((this->m_pOwningSlave != NULL) ? "Slave" : "Leech"), hr);

		DEBUGBREAK();


#pragma BUGBUG(vanceo, "Disconnect from master?")

		this->KillTestThread(TRUE); // ignore result

#ifndef _XBOX // No dumping memory logs to files
#pragma TODO(vanceo, "Implement better (do for leech, too)")
		if ((this->m_pOwningSlave != NULL) &&
			(this->m_pOwningSlave->m_pszFailureMemDumpDirPath != NULL))
		{
			char*	pszFile;
			DWORD	dwSize;


			dwSize = strlen(this->m_pOwningSlave->m_pszFailureMemDumpDirPath) + strlen("testthread_abort.txt") + 1; // + NULL termination

			if (! StringEndsWith(this->m_pOwningSlave->m_pszFailureMemDumpDirPath, "\\", TRUE))
				dwSize++; // add backslash
			
			pszFile = (char*) LocalAlloc(LPTR, dwSize);
			if (pszFile != NULL)
			{
				strcpy(pszFile, this->m_pOwningSlave->m_pszFailureMemDumpDirPath);
				if (! StringEndsWith(this->m_pOwningSlave->m_pszFailureMemDumpDirPath, "\\", TRUE))
					strcat(pszFile, "\\"); // add backslash
				strcat(pszFile, "testthread_abort.txt");

				StringGetCurrentDateStr(szTemp);
				StringPrepend(szTemp, "Test thread aborted mem log dump ");

				TNDebugDumpMemoryLogToFile(pszFile, szTemp, TRUE);

				LocalFree(pszFile);
				pszFile = NULL;
			} // end if (couldn't allocate memory)
		} // end if (we should dump the log on failures)
#endif // ! XBOX

	} // end if (quitting with a failure)

	if (fCOMInitted)
	{

#ifndef _XBOX // CoUninitialize not supported
		if (hr == S_OK)
		{
			DPL(8, "Uninitializing COM.", 0);
			CoUninitialize();
			fCOMInitted = FALSE;
		} // end if (leaving normally)
		else
		{
			DPL(0, "WARNING: Not uninitializing COM because we're exiting with an error!", 0);
		} // end else (leaving with error)
#endif // ! XBOX

	} // end if (initialized COM)

#ifndef _XBOX // OLE32.DLL doesn't exist on Xbox
	if (hOle32 != NULL)
	{
		if (hr == S_OK)
		{
			FreeLibrary(hOle32); // ignore error
			hOle32 = NULL;
		} // end if (leaving normally)
		else
		{
			DPL(0, "WARNING: Not freeing OLE32 library because we're exiting with an error!", 0);
		} // end else (leaving with error)
	} // end if (have OLE library)
#endif // ! XBOX

	if (this->m_pTest != NULL)
	{
		this->m_pTest->m_dwRefCount--;
		if (this->m_pTest->m_dwRefCount == 0)
		{
			DPL(0, "Deleting current test %x.", 1, this->m_pTest);
			delete (this->m_pTest);
		} // end if (can delete test)
		else
		{
			DPL(0, "Not deleting current test %x, it's refcount is %u.",
				2, this->m_pTest, this->m_pTest->m_dwRefCount);
		} // end else (can't delete test)
		this->m_pTest = NULL;
	} // end if (have active test)

	return (hr);
} // CTNExecutorPriv::DoTestThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::LogInternal()"
//==================================================================================
// CTNExecutorPriv::LogInternal
//----------------------------------------------------------------------------------
//
// Description: Logs the string to the slave or sends it through the leech,
//				depending on which owns the executor.
//
// Arguments:
//	DWORD dwLogStringType	What type of string this is.
//	char* szString			String to log.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::LogInternal(DWORD dwLogStringType, char* szString)
{
	HRESULT		hr = S_OK;


	if (this->m_pOwningSlave == NULL)
	{

#ifndef _XBOX // no IPC supported
#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->LogToOwner(dwLogStringType, szString, 0);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't log string to slave through leech!", 0);
		} // end if (logging to slave failed)

		this->m_fDeadlockCheck = fOldCheckStatus;
#endif // ! XBOX

	} // end if (not owned by slave)
	else
	{
#ifndef _XBOX
		// Log the string
		hr = this->m_pOwningSlave->m_pfnLogString(dwLogStringType, szString);
		if (hr != S_OK)
		{
			DPL(0, "Shell's LogString function failed!", 0);
		} // end if (shell's log string function failed)
#else // ! XBOX
#pragma TODO(tristanj, "Map this logging to Xbox's logging subsystem")
#endif // XBOX
	} // end else (owned by slave)

	return (hr);
} // CTNExecutorPriv::LogInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::SprintfLogInternal()"
//==================================================================================
// CTNExecutorPriv::SprintfLogInternal
//----------------------------------------------------------------------------------
//
// Description: Logs the string to the slave or sends it through the leech,
//				depending on which owns the executor.
//
// Arguments:
//	DWORD dwLogStringType	What type of string this is.
//	char* szFormatString	String (with optional tokens) to print.
//	DWORD dwNumParms		How many parameters are in the following variable
//							parameter list.
//	...						Variable list of parameters to parse.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::SprintfLogInternal(DWORD dwLogStringType, char* szFormatString,
										DWORD dwNumParms, ...)
{
	HRESULT		hr = S_OK;
	char*		pszBuffer = NULL;
	PVOID*		papvParms = NULL;
	va_list		currentparam;
	DWORD		dwTemp = 0;


#ifndef _XBOX // no TNsprintf functions
	if (dwNumParms > 0)
	{
		papvParms = (PVOID*) LocalAlloc(LPTR, (dwNumParms * sizeof (PVOID)));
		if (papvParms == NULL)
			return (E_OUTOFMEMORY);

		va_start(currentparam, dwNumParms);

		for(dwTemp = 0; dwTemp < dwNumParms; dwTemp++)
		{
			papvParms[dwTemp] = va_arg(currentparam, PVOID);
		} // end for (each parameter)

		va_end(currentparam);
	} // end if (there are parameters to check)


	// Print the items.
	TNsprintf_array(&pszBuffer, szFormatString, dwNumParms, papvParms);

	LocalFree(papvParms);
	papvParms = NULL;
#else // ! XBOX
#pragma TODO(tristanj, "Need to map executor logging to xLog")
#endif // XBOX

	if (this->m_pOwningSlave == NULL)
	{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->LogToOwner(dwLogStringType, pszBuffer, 0);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't log string to slave through leech!", 0);
		} // end if (logging to slave failed)

		this->m_fDeadlockCheck = fOldCheckStatus;
#endif // ! XBOX

	} // end if (not owned by slave)
	else
	{
#ifndef _XBOX
		// Log the string
		hr = this->m_pOwningSlave->m_pfnLogString(dwLogStringType, pszBuffer);
		if (hr != S_OK)
		{
			DPL(0, "Shell's LogString function failed!", 0);
		} // end if (shell's log string function failed)
#else // ! XBOX
#pragma TODO(tristanj, "Map this logging to Xbox's logging subsystem")
#endif // XBOX
	} // end else (owned by slave)

	TNsprintf_free(&pszBuffer);

	return (hr);
} // CTNExecutorPriv::SprintfLogInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::ReportInternal()"
//==================================================================================
// CTNExecutorPriv::ReportInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of test result reporting.
//
// Arguments:
//	PTNTESTINSTANCES pTest				Pointer to test instance this report
//										pertains to.
//	HRESULT hresult						Success or error code.
//	BOOL fTestComplete					Does this report mean that no more execution
//										will be performed on the test (either
//										because it completed or it encountered a
//										fatal error)?
//	BOOL fSuccess						Is this report a success (note this does not
//										necessarily mean hresult is 0)?
//	BOOL fExecCaseExitReport			Is this the report automatically generated
//										when the ExecCase function returns?
//	PVOID pvOutputData					Optional pointer to output data to send with
//										report.
//	DWORD dwOutputDataSize				Size of output data to send with report.
//	PTNOUTPUTVARSLIST pOutputVars		Optional pointer to list of output variables
//										associated with result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::ReportInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
										BOOL fTestComplete, BOOL fSuccess,
										BOOL fExecCaseExitReport,
										PVOID pvOutputData, DWORD dwOutputDataSize,
										PTNOUTPUTVARSLIST pOutputVars)
{
	HRESULT		hr;
	PTNRESULT	pResult = NULL;
	PTNRESULT	pSubResult;
	BOOL		fHaveResultsLock = FALSE;


	DPL(9, "==>(%x, %x, %B, %B, %B, %x, %u, %x)",
		8, pTest, hresult, fTestComplete, fSuccess, fExecCaseExitReport,
		pvOutputData, dwOutputDataSize, pOutputVars);

	// This really should be done at a higher level, but since it's possibly not,
	// I'm making sure it's okay to use the test while we're in here.
	pTest->m_dwRefCount++;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (object is invalid)


#pragma BUGBUG(vanceo, "does this belong here?"
	// Update the control layer to let it know we're still alive
	this->m_dwLastTestthreadPing = GetTickCount();



	// If it's an exec case exit report, we have to remove the reference to this
	// test (i.e. hide it so we can run more when the master sends us something to
	// do in response to this report).  We do this here because the sending the
	// report to the master is asynchronous, and we could be processing the reply
	// before we even exit this function.
	// Note that it couldn't have been a top level ongoing test previously because
	// exec case exit reports only happen for non-ongoing/current tests, so we only
	// have to check the top level current test, otherwise it's a subtest.
	if (fExecCaseExitReport)
	{
		if (this->m_pTest == pTest)
		{
			this->m_pTest = NULL;
		} // end if (this is the top level current test)
		else
		{
			((PTNTESTINSTANCES) pTest->m_pParentTest)->m_pSubTest = NULL;
		} // end else (this is not a top level test)

		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(0, "Refcount for test %x hit 0!?  DEBUGBREAK()-ing.",
				1, pTest);
			DEBUGBREAK();
		} // end if (refcount hit 0)
		else
		{
			DPL(9, "Refcount for test %x is %u.",
				2, pTest, pTest->m_dwRefCount);
		} // end else (refcount not at 0)


		// If the ExecCase function returned but it's not complete, move it to the
		// ongoing tests list.
		if (! fTestComplete)
		{
#pragma BUGBUG(vanceo, "Their Executor interface will be going away though!")
			// Otherwise, add it to the ongoing tests list.
			hr = this->m_ongoingtests.Add(pTest);
			if (hr != S_OK)
			{
				DPL(0, "Adding test unique ID %u to ongoing test list failed!",
					1, pTest->m_dwUniqueID);
				goto DONE;
			} // end if (failed to run the test)
		} // end if (not complete on function exit)
	} // end if (exec case exited)


	if (fTestComplete)
	{
		// If there's a completion callback, notify it.
		if (pTest->m_pfnPokeTestCompleted != NULL)
		{
			TNPOKETESTCOMPLETEDDATA		tnptcd;


			ZeroMemory(&tnptcd, sizeof (TNPOKETESTCOMPLETEDDATA));
			tnptcd.dwSize = sizeof (TNPOKETESTCOMPLETEDDATA);
			tnptcd.pTest = pTest->m_pCase;
			tnptcd.fSuccess = fSuccess;
			tnptcd.hresult = hresult;
			tnptcd.pvData = pvOutputData;
			tnptcd.dwDataSize = dwOutputDataSize;
			tnptcd.pvUserContext = pTest->m_pvUserContext;

			hr = pTest->m_pfnPokeTestCompleted(&tnptcd);
			if (hr != S_OK)
			{
				DPL(0, "Module's PokeTestCompleted callback failed!", 0);
				goto DONE;
			} // end if (module's callback failed)
		} // end if (there's a PokeTestCompleted callback)
	} // end if (the test is done)



	// Retrieve the corresponding result for this test because we may need it
	// later.
#pragma BUGBUG(vanceo, "Grab lock because refcount isn't increased for us")
	this->m_results.EnterCritSection();

	pResult = this->m_results.GetResultForTest(pTest);
	if (pResult == NULL)
	{
		DPL(0, "Couldn't get result corresponding to test %x (ID %u)!",
			2, pTest, pTest->m_dwUniqueID);

		this->m_results.LeaveCritSection();

		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get result)

	// Grab a reference so it doesn't go away while we still need it.
	pResult->m_dwRefCount++;

	this->m_results.LeaveCritSection();



	if (this->m_pOwningSlave == NULL)
	{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->ReportToOwner(pTest, hresult,
												fTestComplete, fSuccess,
												fExecCaseExitReport,
												pvOutputData, dwOutputDataSize,
												pOutputVars);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't send report to slave through leech!", 0);
			goto DONE;
		} // end if (send report failed)

		this->m_fDeadlockCheck = fOldCheckStatus;

#endif // ! XBOX

	} // end if (not owned by slave)
	else
	{
		hr = this->m_pOwningSlave->ReportInternal(pTest, hresult,
													fTestComplete, fSuccess,
													pvOutputData, dwOutputDataSize,
													pOutputVars);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't send report!", 0);
			goto DONE;
		} // end if (reporting failed)
	} // end else (owned by slave)


	// If the test is completed, we may need to throw out the results.  We do this
	// after the ReportToOwner/ReportInternal calls because the pOutputVars variable
	// we got passed in may actually belong to a result we're about to free.  We
	// crash if that's the case: bad.
	// When we get a repetition complete message, we also free results.  Because
	// there's a race condition where that message could clean out all the results
	// in the list before we get here, we added code there to ignore any tests which
	// which have the TNTCO_DONTSAVERESULTS flag or m_fUnderDontSaveTest set.
	if (fTestComplete)
	{
		// Prevent other threads from trying to do something similar while
		// we're doing it, cause that would mess us up.
		this->m_results.EnterCritSection();
		fHaveResultsLock = TRUE;

		// If we're not supposed to save results, remove the results from any
		// subtests we invoked.
		if (pTest->m_pResultsToFree != NULL)
		{
			while (pTest->m_pResultsToFree->Count() > 0)
			{
				pSubResult = (PTNRESULT) pTest->m_pResultsToFree->PopFirstItem();
				if (pSubResult == NULL)
				{
					DPL(0, "Couldn't pop first sub result to free from list!", 0);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't pop first item)


				DPL(3, "Freeing results for test ID %u (from ResultsToFree list).",
					1, pSubResult->m_pTest->m_dwUniqueID);


				// Pull it off the global list.  We're going to ignore errors,
				// because it may have been removed by some other means, like
				// the user explicitly calling a FreeResults function.
				hr = this->m_results.RemoveFirstReference(pSubResult);
				if (hr != S_OK)
				{
					DPL(4, "Couldn't remove result %x (under test %u) from results list, ignoring.  %e",
						3, pSubResult, pTest->m_dwUniqueID, hr);

					hr = S_OK;
				} // end if (remove first reference failed)


				// Free any output vars or data.
				pSubResult->DestroyOutputDataBufferAndVars();


				// Take off the ref given by PopFirstItem.
				pSubResult->m_dwRefCount--;

#ifdef DEBUG
				if (pSubResult->m_dwRefCount == 0xFFFFFFFF)
				{
					DPL(0, "Sub result %x (test %u) refcount has gone bad!  DEBUGBREAK()-ing.",
						2, pSubResult, pSubResult->m_pTest->m_dwUniqueID);
					DEBUGBREAK();
				} // end if (count got screwed)
#endif // DEBUG

				if (pSubResult->m_dwRefCount == 0)
				{
					DPL(7, "Deleting sub result %x.", 1, pSubResult);
					delete (pSubResult);
				} // end if (should delete result)
				else
				{
					DPL(7, "Not deleting sub result %x, its refcount is %u.",
						2, pSubResult, pSubResult->m_dwRefCount);
				} // end else (shouldn't delete result)
				pSubResult = NULL;
			} // end while (still more tests to free)


			// We don't need the list object any more.
			delete (pTest->m_pResultsToFree);
			pTest->m_pResultsToFree = NULL;
		} // end if (we shouldn't save results)



		// If we're not saving results from this, dump them, otherwise check
		// if parent tests should toss out our results.
		if (pTest->m_pCase->m_dwOptionFlags & TNTCO_DONTSAVERESULTS)
		{
			DPL(3, "Freeing results for test ID %u (because of TNTCO_DONTSAVERESULTS).",
				1, pTest->m_dwUniqueID);

			// Pull it off the global list.  We're going to ignore errors,
			// because it may have been removed by some other means, like
			// the user explicitly calling a FreeResults function.
			hr = this->m_results.RemoveFirstReference(pResult);
			if (hr != S_OK)
			{
				DPL(4, "Couldn't remove result %x (under test %u) from results list, ignoring.  %e",
					3, pResult, pTest->m_dwUniqueID, hr);

				hr = S_OK;
			} // end if (remove first reference failed)
			else
			{
				pResult->m_dwRefCount--;

#ifdef DEBUG
				if (pResult->m_dwRefCount == 0xFFFFFFFF)
				{
					DPL(0, "Result %x (test %u) refcount has gone bad!  DEBUGBREAK()-ing.",
						2, pResult, pTest->m_dwUniqueID);
					DEBUGBREAK();
				} // end if (count got screwed)
#endif // DEBUG

				if (pResult->m_dwRefCount == 0)
				{
					DPL(7, "Deleting result %x, its output data will die with it.",
						1, pResult);
					delete (pResult);
				} // end if (should delete test)
				else
				{
					DPL(7, "Not deleting result %x, its refcount is %u, but manually freeing output data.",
						2, pResult, pResult->m_dwRefCount);

					pResult->DestroyOutputDataBufferAndVars();
				} // end else (shouldn't delete test)

				// Forget about it, so we don't free it below.
				pResult = NULL;
			} // end if (remove first reference succeeded)
		} // end if (not saving results)
		else if (pTest->m_pParentTest != NULL)
		{
			PTNTESTINSTANCES	pParentTest;


			pParentTest = pTest->m_pParentTest;
			do
			{
				// This list will only exist if the test case has the
				// TNTCO_DONTSAVERESULTS flag.
				if (pParentTest->m_pResultsToFree != NULL)
				{
					// Add our results to that parent's list of results to free
					// when it completes.
					hr = pParentTest->m_pResultsToFree->Add(pResult);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add test %u's result to parent (%u)'s list of tests to free!",
							2, pTest->m_dwUniqueID, pParentTest->m_dwUniqueID);
						goto DONE;
					} // end if (couldn't add test)

					// Note that we've added it to a list of items to free so any
					// other automated operation that comes along won't try to free it
					// as well.
					pResult->m_fUnderDontSaveTest = TRUE;

					DPL(9, "Result %x (for test %x, ID %u) is under DONTSAVERESULTS test %x, ID %u.",
						5, pResult, pTest, pTest->m_dwUniqueID,
						pParentTest, pParentTest->m_dwUniqueID);


					// We found one, so we can stop searching.
					break;
				} // end if (parent test shouldn't save results)

				pParentTest = pParentTest->m_pParentTest;
			} // end do (while there's a parent test)
			while (pParentTest != NULL);
		} // end else if (a subtest)

		fHaveResultsLock = FALSE;
		this->m_results.LeaveCritSection();
	} // end if (test completed)


	// If it's an exec case exit report, we still have to do some more things.
	if (fExecCaseExitReport)
	{
		// Release the thread waiting for the ExecCase function to return, if any.
		if (pTest->m_hExecCaseExitEvent != NULL)
		{
			if (! SetEvent(pTest->m_hExecCaseExitEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set ExecCaseExit event (%x)!",
					1, pTest->m_hExecCaseExitEvent);
				goto DONE;
			} // end if (couldn't set event)
		} // end if (there's a thread waiting for this)


		/*
		// Note that this refcount would still be at least one if it got thrown on
		// the ongoing tests list.
		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting test %x (id %u).", 2, pTest, pTest->m_dwUniqueID);
			delete (pTest);
		} // end if (we can delete the test)
		else
		{
			DPL(7, "Not deleting test %x (id %u), its refcount = %u.",
				3, pTest, pTest->m_dwUniqueID, pTest->m_dwRefCount);
		} // end else (we can't delete the test)
		pTest = NULL;
		*/
	} // end if (exec case exited)


DONE:


	// If we still have a reference to result object for this test, drop it.
	if (pResult != NULL)
	{
		pResult->m_dwRefCount--;

#ifdef DEBUG
		if (pResult->m_dwRefCount == 0xFFFFFFFF)
		{
			DPL(0, "Result %x (test %u) refcount has gone bad!  DEBUGBREAK()-ing.",
				2, pResult, pTest->m_dwUniqueID);
			DEBUGBREAK();
		} // end if (count got screwed)
#endif // DEBUG

		if (pResult->m_dwRefCount == 0)
		{
			DPL(7, "Deleting result %x, its output data will die with it.",
				1, pResult);
			delete (pResult);
		} // end if (should delete test)
		else
		{
			DPL(7, "Not deleting result %x, its refcount is %u.",
				2, pResult, pResult->m_dwRefCount);
		} // end else (shouldn't delete test)
		pResult = NULL;
	} // end if (still have result object)

	if (fHaveResultsLock)
	{
		fHaveResultsLock = FALSE;
		this->m_results.LeaveCritSection();
	} // end if (test completed)

	// Take off the refcount we added up above.
	pTest->m_dwRefCount--;
	if (pTest->m_dwRefCount == 0)
	{
		DPL(0, "Refcount for test %x hit 0 while leaving ReportInternal!  DEBUGBREAK()-ing.",
			1, pTest);
		DEBUGBREAK();
	} // end if (refcount hit 0)
	else
	{
		DPL(7, "Refcount for test %x is %u.",
			2, pTest, pTest->m_dwRefCount);
	} // end else (refcount did not hit 0)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutorPriv::ReportInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::WarnInternal()"
//==================================================================================
// CTNExecutorPriv::WarnInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of test result warning.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test instance this warning pertains to.
//	HRESULT hresult			Warning code.
//	PVOID pvUserData		Optional pointer to data to send with warning.
//	DWORD dwUserDataSize	Size of data to send with warning.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::WarnInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
									PVOID pvUserData, DWORD dwUserDataSize)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


#pragma BUGBUG(vanceo, "does this belong here?"
	// Update the control layer to let it know we're still alive
	this->m_dwLastTestthreadPing = GetTickCount();


	if (this->m_pOwningSlave == NULL)
	{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->WarnOwner(pTest, hresult, pvUserData,
											dwUserDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't send warning to slave through leech!", 0);
		} // end if (send warning failed)

		this->m_fDeadlockCheck = fOldCheckStatus;

#endif // ! XBOX

	} // end if (not owned by slave)
	else
	{
		hr = this->m_pOwningSlave->WarnInternal(pTest, hresult, pvUserData,
												dwUserDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't send warning!", 0);
		} // end if (warning failed)
	} // end else (owned by slave)

	return (hr);
} // CTNExecutorPriv::WarnInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::SyncInternal()"
//==================================================================================
// CTNExecutorPriv::SyncInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of test syncing.
//
// Arguments:
//	PTNTESTINSTANCES pTest			Pointer to test to sync under.
//	char* szSyncName				User defined unique name for this sync
//									operation.  Must match on all machines involved.
//	PVOID pvSendData				Pointer to data to send to people to sync with.
//	DWORD dwSendDataSize			Size of data to send to people to sync with.
//	PTNSYNCDATALIST pReceiveData	Pointer to list that will hold the data received
//									from the other synchronizing testers.
//	int iNumMachines				How many testers we're syncing with (i.e. how
//									many integers there are in following array).
//	int* aiTesters					Array of integers indicating the testers to sync
//									with.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::SyncInternal(PTNTESTINSTANCES pTest,
									char* szSyncName,
									PVOID pvSendData,
									DWORD dwSendDataSize,
									PTNSYNCDATALIST pReceiveData,
									int iNumMachines,
									int* aiTesters)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


#pragma BUGBUG(vanceo, "does this belong here?"
	// Update the control layer to let it know we're still alive
	this->m_dwLastTestthreadPing = GetTickCount();


	if (this->m_pOwningSlave == NULL)
	{

#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->HaveOwnerSync(pTest, szSyncName,
												pvSendData, dwSendDataSize,
												pReceiveData,
												iNumMachines, aiTesters);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't have slave sync through leech!", 0);
		} // end if (sync failed)

		this->m_fDeadlockCheck = fOldCheckStatus;

#endif // ! XBOX
	} // end if (not owned by slave)
	else
	{
		hr = this->m_pOwningSlave->SyncInternal(pTest, szSyncName,
												pvSendData, dwSendDataSize,
												pReceiveData,
												iNumMachines, aiTesters);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't synchronize!", 0);
		} // end if (sync failed)
	} // end else (owned by slave)

	return (hr);
} // CTNExecutorPriv::SyncInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::IsTesterOnSameMachineInternal()"
//==================================================================================
// CTNExecutorPriv::IsTesterOnSameMachineInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of tester on same machine check.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to check under.
//	int iTesterNum			Tester number for which to check.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
BOOL CTNExecutorPriv::IsTesterOnSameMachineInternal(PTNTESTINSTANCES pTest,
													int iTesterNum)
{
	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (FALSE);
	} // end if (object is invalid)


#pragma BUGBUG(vanceo, "does this belong here?")
	// Update the control layer to let it know we're still alive
	this->m_dwLastTestthreadPing = GetTickCount();


	if (this->m_pOwningSlave == NULL)
	{

#ifndef _XBOX // no IPC supported
#pragma BUGBUG(vanceo, "Use hacking deadlock check turn off?")
		return (this->m_pOwningLeech->HaveOwnerCheckIfTesterOnMachine(pTest, iTesterNum));

#else // ! XBOX
		return E_FAIL; // On Xbox we aren't supporting leeches, so owner should always be a slave...
#endif // XBOX

	} // end if (not owned by slave)
	else
	{
		return (this->m_pOwningSlave->IsTesterOnSameMachineInternal(pTest, iTesterNum));
	} // end else (owned by slave)
} // CTNExecutorPriv::IsTesterOnSameMachineInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::GetTesterIPInternal()"
//==================================================================================
// CTNExecutorPriv::GetTesterIPInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of tester IP retrieval.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to retrieve IP under.
//	int iTesterNum			Tester number for which to retrieve IP address.
//	WORD wPort				IP port to verify reachability.
//	char* szIPString		String to store result in (must be 16 chars).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::GetTesterIPInternal(PTNTESTINSTANCES pTest, int iTesterNum,
											WORD wPort, char* szIPString)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


#pragma BUGBUG(vanceo, "does this belong here?"
	// Update the control layer to let it know we're still alive
	this->m_dwLastTestthreadPing = GetTickCount();


	if (this->m_pOwningSlave == NULL)
	{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->HaveOwnerGetTesterIP(pTest, iTesterNum, wPort,
														szIPString);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't have slave get tester's IP through leech!", 0);
		} // end if (getting IP failed)

		this->m_fDeadlockCheck = fOldCheckStatus;

#endif // ! XBOX

	} // end if (not owned by slave)
	else
	{
		hr = this->m_pOwningSlave->GetTestersIPForPortInternal(pTest, iTesterNum,
																wPort, szIPString);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't get tester's IP!", 0);
		} // end if (getting IP failed)
	} // end else (owned by slave)

	return (hr);
} // CTNExecutorPriv::GetTesterIPInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::GetTesterPhoneNumInternal()"
//==================================================================================
// CTNExecutorPriv::GetTesterPhoneNumInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of tester phone number retrieval.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to retrieve phone number under.
//	int iTesterNum			Tester number for which to retrieve phone number.
//	char* szIPString		String to store result in.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::GetTesterPhoneNumInternal(PTNTESTINSTANCES pTest,
												int iTesterNum, char* szPhoneNumber)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


#pragma BUGBUG(vanceo, "does this belong here?"
	// Update the control layer to let it know we're still alive
	this->m_dwLastTestthreadPing = GetTickCount();


	if (this->m_pOwningSlave == NULL)
	{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->HaveOwnerGetTesterPhoneNum(pTest, iTesterNum,
																szPhoneNumber);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't have slave get tester's phone number through leech!", 0);
		} // end if (getting phone number failed)

		this->m_fDeadlockCheck = fOldCheckStatus;

#endif // ! XBOX

	} // end if (not owned by slave)
	else
	{
		hr = this->m_pOwningSlave->GetTestersPhoneNumInternal(pTest, iTesterNum,
																szPhoneNumber);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't get tester's phone number!", 0);
		} // end if (getting phone number failed)
	} // end else (owned by slave)

	return (hr);
} // CTNExecutorPriv::GetTesterPhoneNumInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::GetTesterCOMPortInternal()"
//==================================================================================
// CTNExecutorPriv::GetTesterCOMPortInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of COM port retrieval.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to retrieve COM port under.
//	int iTesterNum			Tester number for which to retrieve COM port.
//	DWORD* pdwCOMPort		Place to store result in.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::GetTesterCOMPortInternal(PTNTESTINSTANCES pTest, int iTesterNum,
												DWORD* pdwCOMPort)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


#pragma BUGBUG(vanceo, "does this belong here?"
	// Update the control layer to let it know we're still alive
	this->m_dwLastTestthreadPing = GetTickCount();


	if (this->m_pOwningSlave == NULL)
	{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->HaveOwnerGetTesterCOMPort(pTest, iTesterNum,
															pdwCOMPort);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't have slave get tester's COM port through leech!", 0);
		} // end if (getting COM port failed)

		this->m_fDeadlockCheck = fOldCheckStatus;

#endif // ! XBOX
	} // end if (not owned by slave)
	else
	{
		hr = this->m_pOwningSlave->GetTestersCOMPortInternal(pTest, iTesterNum,
															pdwCOMPort);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't get tester's COM port!", 0);
		} // end if (getting COM port failed)
	} // end else (owned by slave)

	return (hr);
} // CTNExecutorPriv::GetTesterCOMPortInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::CreateSubTest()"
//==================================================================================
// CTNExecutorPriv::CreateSubTest
//----------------------------------------------------------------------------------
//
// Description: Creates a new subtest under the given parent test, using the given
//				information.  This gets propogated up the object chain, and
//				eventually to the master, who responds with a unique ID to use.
//				This call will block until that happens.
//
// Arguments:
//	PTNTESTINSTANCES pParentTest	Pointer to parent test.
//	PTNTESTTABLECASE pCase			Pointer to case of subtest to create.
//	int iNumMachines				Number of integers in the following array.
//	PTNCTRLMACHINEID aTesters		Array of IDs indicating the testers in their
//									respective testing positions for the new test.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::CreateSubTest(PTNTESTINSTANCES pParentTest,
									PTNTESTTABLECASE pCase,
									int iNumMachines,
									PTNCTRLMACHINEID aTesters)
{
	HRESULT		hr;


	if (pParentTest->m_pSubTest != NULL)
	{
		DPL(0, "Parent test (ID %u) already has a subtest (ID %u)!",
			2, pParentTest->m_dwUniqueID, pParentTest->m_pSubTest->m_dwUniqueID);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (this item already has a subtest)

	pParentTest->m_pSubTest = new (CTNTestInstanceS)(0xFFFFFFFF,
													pCase,
													NULL,
													iNumMachines,
													aTesters,
													//0,
													pParentTest);
	if (pParentTest->m_pSubTest == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pParentTest->m_pSubTest->m_dwRefCount++; // we're using it


	if (this->m_pOwningSlave == NULL)
	{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->HaveOwnerCreateSubTest((PTNTESTINSTANCES) pParentTest->m_pSubTest,
															iNumMachines,
															aTesters);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't have leech's owner create sub test!", 0);
		} // end if (creating subtest failed)

		this->m_fDeadlockCheck = fOldCheckStatus;

#endif // ! XBOX
	} // end if (not owned by slave)
	else
	{
		hr = this->m_pOwningSlave->AnnounceSubTest((PTNTESTINSTANCES) pParentTest->m_pSubTest,
													iNumMachines,
													aTesters);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't announce subtest!", 0);
		} // end if (announcing test failed)
	} // end else (owned by slave)


DONE:

	return (hr);
} // CTNExecutorPriv::CreateSubTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::GetTest()"
//==================================================================================
// CTNExecutorPriv::GetTest
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the test with the given top level and personal
//				unique IDs.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test the specified test is under
//								(may be same as the actual ID).
//	DWORD dwTestUniqueID		ID of actual test to retrieve.
//
// Returns: Pointer to the given test if found, NULL otherwise.
//==================================================================================
PTNTESTINSTANCES CTNExecutorPriv::GetTest(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID)
{
	PTNTESTINSTANCES	pTopLevelTest = NULL;


	// If we have a current test, see if the top level specified is that.
	if (this->m_pTest != NULL)
	{
		if (this->m_pTest->m_dwUniqueID == dwTopLevelUniqueID)
			pTopLevelTest = this->m_pTest;
	} // end if (there's a current test)

	// If we didn't get a top level test above, check all the ongoing tests to see
	// if they're the specified top level test.
	if (pTopLevelTest == NULL)
	{
		pTopLevelTest = (PTNTESTINSTANCES) this->m_ongoingtests.GetTopLevelTest(dwTopLevelUniqueID);
	} // end if (haven't found top level test yet)


	// If we still don't have a top level test, we're screwed.
	if (pTopLevelTest == NULL)
		return (NULL);

	// Try to get the specified (sub)test.
	return (pTopLevelTest->GetTest(dwTestUniqueID));
} // CTNExecutorPriv::GetTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no IPC supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::GetTest()"
//==================================================================================
// CTNExecutorPriv::GetTest
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the test with the given top level (from the
//				leech's perspective) and personal unique IDs.
//
// Arguments:
//	DWORD dwLeechTopLevelUniqueID	ID of leech's top level test the specified test
//									is under (may be same as the actual ID).
//	DWORD dwTestUniqueID			ID of actual test to retrieve.
//
// Returns: Pointer to the given test if found, NULL otherwise.
//==================================================================================
PTNTESTINSTANCES CTNExecutorPriv::GetLeechTest(DWORD dwLeechTopLevelUniqueID,
												DWORD dwTestUniqueID)
{
	PTNTESTINSTANCES	pLeechTopLevelTest = NULL;
	int					i;
	PTNTESTINSTANCES	pTest = NULL;


	// If we have a current test, see if the top level specified is that.  It
	// shouldn't be, because all of the leech top level tests should be under the
	// current test or on the ongoing tests list.
	if (this->m_pTest != NULL)
	{
#ifdef DEBUG
		if (this->m_pTest->m_dwUniqueID == dwLeechTopLevelUniqueID)
		{
			DPL(0, "Leech's top level test is our top most current test (ID %u)!?",
				1, dwLeechTopLevelUniqueID);
			return (NULL);
		} // end if (it's our top most current test)
#endif // DEBUG

		pLeechTopLevelTest = this->m_pTest->GetTest(dwLeechTopLevelUniqueID);
	} // end if (there's a current test)

	// If we didn't get a top level test above, check all the ongoing tests to see
	// if they have the specified top level test.
	if (pLeechTopLevelTest == NULL)
	{
		for(i = 0; i < this->m_ongoingtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCES) this->m_ongoingtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get ongoing test %i!", 1, i);
				return (NULL);
			} // end if (couldn't get item)

			pLeechTopLevelTest = pTest->GetTest(dwLeechTopLevelUniqueID);
			if (pLeechTopLevelTest != NULL)
				break;
		} // end for (each ongoing test)
	} // end if (haven't found top level test yet)


	// If we still don't have a top level test, we're screwed.
	if (pLeechTopLevelTest == NULL)
		return (NULL);

	// Try to get the specified (sub)test.
	return (pLeechTopLevelTest->GetTest(dwTestUniqueID));
} // CTNExecutorPriv::GetTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::RunTest()"
//==================================================================================
// CTNExecutorPriv::RunTest
//----------------------------------------------------------------------------------
//
// Description: Executes the given test.  The test pointer is set to NULL upon
//				function exit.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to pointer to test to run.
//	PVOID pvInputData			Pointer to input data to use.
//	DWORD dwInputDataSize		Size of input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::RunTest(PTNTESTINSTANCES pTest, PVOID pvInputData,
								DWORD dwInputDataSize)
{
	HRESULT				hr;
	TNEXECCASEDATA		tnecd;
	int					i;


	ZeroMemory(&tnecd, sizeof (TNEXECCASEDATA));
	tnecd.dwSize = sizeof (TNEXECCASEDATA);
	tnecd.pExecutor = new (CTNExecutor)(this, pTest);
	if (tnecd.pExecutor == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	tnecd.iTesterNum = -1;
	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
		// If the ID of this tester is our ID, then we found our tester number.
		if (memcmp(&(pTest->m_paTesterSlots[i].id), &(this->m_id), sizeof (TNCTRLMACHINEID)) == 0)
		{
#ifdef DEBUG
			if (tnecd.iTesterNum >= 0)
			{
				DPL(0, "Duplicate tester number?!  DEBUGBREAK()-ing.", 0);

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (no tester number)
#endif // DEBUG

			tnecd.iTesterNum = i;
#ifndef DEBUG
			break; // get out of the loop
#endif // ! DEBUG
		} // end if (found our ID)
	} // end for (each tester)

#ifdef DEBUG
	if (tnecd.iTesterNum < 0)
	{
		DPL(0, "No tester number?!  DEBUGBREAK()-ing.", 0);

		DEBUGBREAK();

		hr = E_FAIL;
		goto DONE;
	} // end if (no tester number)
#endif // DEBUG

	tnecd.iNumMachines = pTest->m_iNumMachines;
	tnecd.pvInputData = pvInputData;
	tnecd.dwInputDataSize = dwInputDataSize;

	tnecd.pSubResults = &(this->m_results);
	tnecd.pFinalResult = tnecd.pSubResults->NewResult(pTest);
	if (tnecd.pFinalResult == NULL)
	{
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't create new result)
	tnecd.pMachineInfo = &(this->m_info);


	DPL(1, "Running test case \"%s-%s\", unique ID %u (\"%s\"), tester num %i (%i total testers), data = %x, %u bytes.",
			8, pTest->m_pCase->m_pszID,
			pTest->m_pszInstanceID,
			pTest->m_dwUniqueID,
			pTest->m_pCase->m_pszName,
			tnecd.iTesterNum,
			pTest->m_iNumMachines,
			pvInputData,
			dwInputDataSize);

#ifndef _XBOX

#pragma BUGBUG(vanceo, "What about ongoing tests?  They'll be top level")
	// Only log if it's a top level test and we're owned by the top level slave.
	if ((pTest->m_pParentTest == NULL) && (this->m_pOwningSlave != NULL))
	{
		hr = this->m_pOwningSlave->StartDBCase(pTest);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't notify database of test case start!", 0);
			goto DONE;
		} // end if (couldn't start case in DB)
	} // end if (it's a top level slave test)


#endif // ! XBOX

#ifndef _XBOX // no snapshots supported

#pragma TODO(vanceo, "Reimplement binary swapping")
	/*
	if (pTest->m_pCase->m_dwOptions & TNTCO_SWAPSBINARIES)
	{
		if (pTest->m_pCase->m_dwOptions & TNTCO_MULTITHREADABLE)
		{
			DPL(0, "Tests that swap binaries are not multithreadable!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (the case is multithreadable)

		hr = this->TakeSnapshot();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't take snapshot of binaries!", 0);
			goto DONE;
		} // end if (couldn't take snapshot)
	} // end if (the test may swap binaries)
	*/
#endif // ! XBOX

	hr = pTest->m_pCase->m_pfnExecCase(&tnecd);

	switch (hr)
	{
		case S_OK:
			// The test succeeded fine.
		  break;

		case TNSR_USERCANCEL:
		case TNWR_USERCANCEL:
		case TNCWR_USERCANCEL:
			// Convert user cancels from system failures to test result failures.

			DPL(0, "User cancelled test %s (unique ID %u), marking as failure.",
				2, pTest->m_pCase->m_pszID,
				pTest->m_dwUniqueID);

			//Ignoring error
			this->SprintfLogInternal(TNLST_CONTROLLAYER_TESTFAILURE,
									"User cancelled test \"%s\" (unique ID %u), marking as failure.",
									2, pTest->m_pCase->m_pszID,
									pTest->m_dwUniqueID);

			// Override anything the user may have set.
			tnecd.pFinalResult->SetResultCodeAndBools(hr, TRUE, FALSE);

#pragma BUGBUG(vanceo, "doesn't stop testing completely")
			hr = S_OK;
		  break;

		case TNWR_TIMEOUT:
		case TNCWR_TIMEOUT:
			// Convert timeouts from system failures to test result failures.

			DPL(0, "Timed out during %s (unique ID %u), marking as failure.",
				2, pTest->m_pCase->m_pszID,
				pTest->m_dwUniqueID);

			//Ignoring error
			this->SprintfLogInternal(TNLST_CONTROLLAYER_TESTFAILURE,
									"Timed out during \"%s\" (unique ID %u), marking as failure.",
									2, pTest->m_pCase->m_pszID,
									pTest->m_dwUniqueID);

			// Override anything the user may have set.
			tnecd.pFinalResult->SetResultCodeAndBools(hr, TRUE, FALSE);

			hr = S_OK;
		  break;

		case TNERR_LOSTTESTER:
		case TNSR_LOSTTESTER:
		case TNWR_LOSTTESTER:
		case TNCWR_LOSTTESTER:
			// Convert lost testers from system failures to test result failures.

			DPL(0, "Lost tester during %s (unique ID %u), marking as failure.",
				2, pTest->m_pCase->m_pszID,
				pTest->m_dwUniqueID);

			//Ignoring error
			this->SprintfLogInternal(TNLST_CONTROLLAYER_TESTFAILURE,
									"Lost tester during \"%s\" (unique ID %u), marking as failure.",
									2, pTest->m_pCase->m_pszID,
									pTest->m_dwUniqueID);

			// Override anything the user may have set.
			tnecd.pFinalResult->SetResultCodeAndBools(hr, TRUE, FALSE);

			hr = S_OK;
		  break;

		default:
			// All other failures will cause the test thread to abort.

			DPL(0, "Running test unique ID %u (\"%s\", case \"%s-%s\", tester %i, %i total testers), data = %x, %u bytes failed!",
				8, pTest->m_dwUniqueID,
				pTest->m_pCase->m_pszName,
				pTest->m_pCase->m_pszID,
				pTest->m_pszInstanceID,
				tnecd.iTesterNum,
				pTest->m_iNumMachines,
				pvInputData,
				dwInputDataSize);
			goto DONE;
		  break;

	} // end switch (on return code)

	DPL(1, "Done with test function (test %u, \"%s\", case \"%s-%s\", tester %i, %i total testers), data = %x, %u bytes.",
		8, pTest->m_dwUniqueID,
		pTest->m_pCase->m_pszName,
		pTest->m_pCase->m_pszID,
		pTest->m_pszInstanceID,
		tnecd.iTesterNum,
		pTest->m_iNumMachines,
		pvInputData,
		dwInputDataSize);

	// Note that the user has to save the info from the input data if he
	// wants to keep it around in an ongoing test.  If there was no data
	// stored there, it's harmless.
	pTest->FreeInputData();

#ifndef _XBOX // no swapping supported
	/*
	if (pTest->m_pCase->m_dwOptions & TNTCO_SWAPSBINARIES)
	{
		hr = this->RestoreSnapshot();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't restore snapshot of binaries!", 0);
			goto DONE;
		} // end if (couldn't restore snapshot)
	} // end if (the test may have swapped binaries)
	*/
#endif // ! XBOX

	// If the module didn't say that this was an ongoing test, but
	// the function did not say it was complete yet, that's goofy.
	if (! tnecd.pFinalResult->m_fComplete)
	{
		if (! (pTest->m_pCase->m_dwOptionFlags & TNTCO_ONGOING))
		{
			DPL(0, "Module does not appear to be finished with a non-ongoing test (ID %u, case \"%s\")!",
				2, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID);
			hr = E_FAIL;
			goto DONE;
		} // end if (not supposed to be an ongoing test)
	} // end if (the test is not done)

	if (! this->m_fDeadlockCheck)
	{
		if (pTest->m_pParentTest != NULL)
		{
			DPL(1, "NOTE: Leaving subtest (ID %u, case \"%s\") with deadlock checking still off.  May be okay if it was turned off in a parent test.",
				2, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID);
		} // end if (a sub test)
		else
		{
			DPL(0, "Leaving top level test (ID %u, case \"%s\") with deadlock checking still off!",
				2, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID);

			hr = ERROR_CAN_NOT_COMPLETE;
			goto DONE;
		} // end else (this is a top level test)
	} // end if (leaving test case with deadlock check still off)


	// We automatically generate a report for the module because it's something
	// he would have to do anyway and it's a side effect of our output data
	// mechanism.  This report function actually updates the test and moves it
	// as appropriate.
	hr = this->ReportInternal(pTest,
							tnecd.pFinalResult->m_hresult,
							tnecd.pFinalResult->m_fComplete,
							tnecd.pFinalResult->m_fSuccess,
							TRUE,
							((tnecd.pFinalResult->m_fSuccess) ? tnecd.pFinalResult->m_pvOutputData : NULL),
							((tnecd.pFinalResult->m_fSuccess) ? tnecd.pFinalResult->m_dwOutputDataSize : 0),
							((tnecd.pFinalResult->m_fSuccess) ? &(tnecd.pFinalResult->m_vars) : NULL));
	if (hr != S_OK)
	{
		DPL(0, "Reporting results for test unique ID %u failed!",
			1, pTest->m_dwUniqueID);
		goto DONE;
	} // end if (failed to report the results)


#pragma BUGBUG(vanceo, "This is ugly, don't have ReportInternal delete test")
	// Note that ReportInternal may delete pTest!



DONE:

	if (tnecd.pExecutor != NULL)
	{
		delete (tnecd.pExecutor);
		tnecd.pExecutor = NULL;
	} // end if (an executor exists)

	// If we had an error, check to see if the test wasn't already cleared by
	// ReportInternal.  If it wasn't, we'll do it ourselves.
	if (hr != S_OK)
	{
		if ((this->m_pTest != NULL) &&
			((pTest->m_pParentTest == NULL) ||
			((pTest->m_pParentTest != NULL) && (pTest->m_pParentTest->m_pSubTest != NULL))))
		{
			if (this->m_pTest == pTest)
			{
				this->m_pTest = NULL;
			} // end if (this is the top level current test)
			else if (pTest->m_pParentTest->m_pSubTest == pTest)
			{
				pTest->m_pParentTest->m_pSubTest = NULL;
			} // end else if (this is not a top level test)
			else
			{
				DPL(0, "WARNING: Test %x location not known!", 1, pTest);
			} // end else (other)

			pTest->m_dwRefCount--;
			if (pTest->m_dwRefCount == 0)
			{
				DPL(0, "Refcount for test %x hit 0, deleting.", 1, pTest);
				delete (pTest);
			} // end if (last reference to test)
			else
			{
				DPL(7, "Not deleting test %x, its refcount is %u.",
					2, pTest, pTest->m_dwRefCount);
			} // end else (not last reference to test)
			pTest = NULL;
		} // end if (test location wasn't already cleared)
		else
		{
			DPL(0, "Test %x already cleared, assuming it was freed.", 1, pTest);
		} // end else (test location was already cleared)
	} // end if (failed)

	return (hr);
} // CTNExecutorPriv::RunTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::FreeResultsInternal()"
//==================================================================================
// CTNExecutorPriv::FreeResultsInternal
//----------------------------------------------------------------------------------
//
// Description: Frees all results matching the given criteria, if specified.  If
//				both parameters are NULL, all results are freed.
//				Note that all output data and variables are destroyed as well.
//
// Arguments:
//	char* pszCaseID						Case ID to match, or NULL for all.
//	char* pszInstanceID					Instance ID to match, or NULL for all.
//	PTNTESTINSTANCES pUserCallingTest	Pointer to test where the user called this
//										explicitly, or NULL if automatic cleanup.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::FreeResultsInternal(char* pszCaseID, char* pszInstanceID,
											PTNTESTINSTANCES pUserCallingTest)
{
	HRESULT				hr = S_OK;
	PTNRESULT			pResult;
	PTNTESTINSTANCES	pParentTest;
	int					i;



	DPL(1, "Freeing results (%s, %s).", 2, pszCaseID, pszInstanceID);

	// Take the lock to prevent other threads from doing this, too.
	this->m_results.EnterCritSection();

	// Work backwards so our count doesn't get screwed up.
	for(i = this->m_results.Count() - 1; i >= 0; i--)
	{
		pResult = (PTNRESULT) this->m_results.GetItem(i);
		if (pResult == NULL)
		{
			DPL(0, "Couldn't get result %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)


		// If we're matching case ID, make sure it does.
		if (pszCaseID != NULL)
		{
			if (pResult->IsCase(pszCaseID))
				continue;
		} // end if (should check case ID)


		// If we're matching instance ID, make sure it does.
		if (pszInstanceID != NULL)
		{
			if ((pResult->m_pTest->m_pszInstanceID == NULL) ||
				(strcmp(pResult->m_pTest->m_pszInstanceID, pszInstanceID) != 0))
			{
				continue;
			} // end if (no instance ID, or doesn't match)
		} // end if (should check instance ID)



		// Since there are race conditions where a repetition complete message
		// comes in and we try to free all results before the ReportInternal
		// call that caused the repetition to complete tries to do the same thing,
		// we will skip results for tests marked TNTCO_DONTSAVERESULTS or for
		// subtests under one with that flag.  We assume the ReportInternal code
		// will free it when it gets the chance (should be very very soon).  This
		// will only occur and be handled in the non-user-called case.
		// However, we also don't want the user freeing results for the currently
		// executing test or any of its parents, so skip those as well.
		if (pUserCallingTest == NULL)
		{
			if (pResult->m_pTest->m_pCase->m_dwOptionFlags & TNTCO_DONTSAVERESULTS)
			{
				DPL(9, "Not auto-freeing result %x (for test %x, ID %u) because it's a DONTSAVERESULTS test and should be released shortly.",
					3, pResult, pResult->m_pTest, pResult->m_pTest->m_dwUniqueID);
				continue;
			} // end if (results will not be saved)

			if (pResult->m_fUnderDontSaveTest)
			{
				DPL(9, "Not auto-freeing result %x (for test %x, ID %u) because it's a subtest of a DONTSAVERESULTS test.",
					3, pResult, pResult->m_pTest, pResult->m_pTest->m_dwUniqueID);
				continue;
			} // end if (results will not be saved)
		} // end if (not user called)
		else
		{
			if (pResult->m_pTest == pUserCallingTest)
			{
				DPL(9, "Not user-freeing result %x because its the current test (%x, ID %u).",
					3, pResult, pResult->m_pTest, pResult->m_pTest->m_dwUniqueID);
				continue;
			} // end if (results will not be saved)

			// Check parent tests, too.
			pParentTest = pUserCallingTest->m_pParentTest;
			while (pParentTest != NULL)
			{
				if (pResult->m_pTest == pParentTest)
				{
					DPL(9, "Not user-freeing result %x because its for a parent test (%x, ID %u) of the current test (%x, ID %u).",
						5, pResult, pResult->m_pTest, pResult->m_pTest->m_dwUniqueID,
						pUserCallingTest, pUserCallingTest->m_dwUniqueID);
					// Stop this while loop, we'll detect that pParentTest is not NULL.
					break;
				} // end if (results will not be saved)

				pParentTest = pParentTest->m_pParentTest;
			} // end while (more parents)

			// Detect if we did find this result's test in the parent test chain.
			if (pParentTest != NULL)
				continue;
		} // end else (is user called)

#pragma BUGBUG(vanceo, "Are these rules also happening on server?  we don't want mismatch")

		// If this result is under a DONTSAVERESULTS test, we should take it off that
		// list to be polite so that code doesn't try to remove this result from the
		// main list (which we'll do ourselves here in a second).
		if (pResult->m_fUnderDontSaveTest)
		{
			pParentTest = pResult->m_pTest->m_pParentTest;
			while (pParentTest != NULL)
			{
				if (pParentTest->m_pResultsToFree != NULL)
				{
					hr = pParentTest->m_pResultsToFree->RemoveFirstReference(pResult);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't remove result %x from parent test %x's results to free list!",
							2, pResult, pParentTest);
						goto DONE;
					} // end if (couldn't remove result)

					pResult->m_fUnderDontSaveTest = FALSE;

					// Break out of the loop.
					break;
				} // end if (there's a results to free list)

				pParentTest = pParentTest->m_pParentTest;
			} // end while (more parents)

#ifdef DEBUG
			// Detect if we failed to find the parent test which will throw out this
			// result.
			if (pParentTest == NULL)
			{
				DPL(0, "Couldn't find parent test which will throw out result %x!",
					1, pResult);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (didn't didn't find parent test)
#endif // DEBUG
		} // end if (under a dontsave test)


		// If we got here, it means we can remove this item.
		hr = this->m_results.RemoveFirstReference(pResult);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove reference to result %x!", 1, pResult);
			goto DONE;
		} // end if (couldn't remove ref)

		if (pResult->m_dwRefCount == 0)
		{
			DPL(7, "Deleting result %x (test = %x, ID %u).",
				3, pResult, pResult->m_pTest, pResult->m_pTest->m_dwUniqueID);
			delete (pResult);
		} // end if (refcount hit 0)
		else
		{
			DPL(7, "Not deleting result %x (test = %x, ID %u), it's refcount is %u.",
				4, pResult, pResult->m_pTest, pResult->m_pTest->m_dwUniqueID,
				pResult->m_dwRefCount);
		} // end else (refcount didn't hit 0)
		pResult = NULL;
	} // end for (each result)


	// If the user called this, we need to propagate this up the chain,
	// all the way to the master.
	if (pUserCallingTest != NULL)
	{
		if (this->m_pOwningSlave != NULL)
		{
			hr = this->m_pOwningSlave->SendFreeOutputVars(pszCaseID, pszInstanceID,
															NULL, NULL);
			if (hr != S_OK)
			{
				DPL(0, "Failed sending FreeOutputVars message to master!", 0);
				goto DONE;
			} // end if (sending message to master failed)
		} // end if (owned by slave)
		else
		{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
			BOOL		fOldCheckStatus;

			fOldCheckStatus = this->m_fDeadlockCheck; 
			this->m_fDeadlockCheck = FALSE;

			hr = this->m_pOwningLeech->HaveOwnerFreeResults(pUserCallingTest,
															pszCaseID,
															pszInstanceID);

			this->m_fDeadlockCheck = fOldCheckStatus;

			if (hr != S_OK)
			{
				DPL(0, "Failed having leech's owner free results!", 0);
				goto DONE;
			} // end if (having leech do stuff)
#endif // ! XBOX
		} // end else (owned by leech)
	} // end if (the user called this function)


DONE:

	this->m_results.LeaveCritSection();

	return (hr);
} // CTNExecutorPriv::FreeResultsInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::FreeOutputVarsInternal()"
//==================================================================================
// CTNExecutorPriv::FreeOutputVarsInternal
//----------------------------------------------------------------------------------
//
// Description: Frees all output variables matching the given criteria.  If a
//				parameter is not NULL, then only vars from the corresponding test,
//				with a matching name, etc. are freed.  If all parameters are NULL,
//				all output vars are freed.
//
// Arguments:
//	char* pszCaseID						Case ID to match, or NULL for all.
//	char* pszInstanceID					Instance ID to match, or NULL for all.
//	char* pszName						Output variable name to match, or NULL for
//										all.
//	char* pszType						Output variable type to match, or NULL for
//										all.
//	BOOL fFreeData						Whether the data can be freed, too, if no
//										variables are left for a given result.
//	PTNTESTINSTANCES pUserCallingTest	Pointer to test where the user called this
//										explicitly, or NULL if automatic cleanup.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::FreeOutputVarsInternal(char* pszCaseID, char* pszInstanceID,
												char* pszName, char* pszType,
												BOOL fFreeData,
												PTNTESTINSTANCES pUserCallingTest)
{
	HRESULT			hr = S_OK;
	PTNRESULT		pResult;
	PTNOUTPUTVAR	pVar;
	int				i;
	int				j;


	DPL(9, "==>", 0);

	DPL(1, "Freeing output variables (%s, %s, %s, %s, %B, %x).",
		6, pszCaseID, pszInstanceID, pszName, pszType, fFreeData, pUserCallingTest);

	this->m_results.EnterCritSection();

	for(i = 0; i < this->m_results.Count(); i++)
	{
		pResult = (PTNRESULT) this->m_results.GetItem(i);
		if (pResult == NULL)
		{
			DPL(0, "Couldn't get result %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		// If we're matching case ID, make sure it does.
		if (pszCaseID != NULL)
		{
			if (pResult->IsCase(pszCaseID))
				continue;
		} // end if (should check case ID)


		// If we're matching instance ID, make sure it does.
		if (pszInstanceID != NULL)
		{
			if ((pResult->m_pTest->m_pszInstanceID == NULL) ||
				(strcmp(pResult->m_pTest->m_pszInstanceID, pszInstanceID) != 0))
			{
				continue;
			} // end if (no instance ID, or doesn't match)
		} // end if (should check instance ID)


		// If we're matching individual variable names or types, check each one.
		if ((pszName != NULL) || (pszType != NULL))
		{
			// If there aren't any variables in this item, we don't need or want to
			// check if we can free vars and data.
			if (pResult->m_vars.Count() <= 0)
			{
				continue;
			} // end if (still variables left)


			// Loop through all the output variables (backwards so our
			// count doesn't get off).
			for(j = pResult->m_vars.Count() - 1; j >= 0; j--)
			{
				pVar = (PTNOUTPUTVAR) pResult->m_vars.GetItem(j);
				if (pVar == NULL)
				{
					DPL(0, "Couldn't get var %i!", 1, j);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get item)

				// Check for matching names and types.
				if (((pszName != NULL) &&
						(StringCmpNoCase(pVar->GetString(), pszName))) ||
					((pszType != NULL) &&
						(strcmp(pVar->m_pszType, pszType) == 0)))
				{
					// Remove it.
					hr = pResult->m_vars.Remove(j);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't remove item %i from test %u's output vars list!",
							2, j, pResult->m_pTest->m_dwUniqueID);
						goto DONE;
					} // end if (couldn't remove item)
				} // end if (matching names and it does)
			} // end for (each output variable)

			// If we didn't remove all the variables, we can't remove
			// the whole list.
			if (pResult->m_vars.Count() > 0)
			{
				continue;
			} // end if (still variables left)
		} // end if (should check names or types)


		// If we got here, it means we can remove any output variables left.
		hr = pResult->m_vars.RemoveAll();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove any remaining output vars in test %u's output vars list!",
				1, pResult->m_pTest->m_dwUniqueID);
			goto DONE;
		} // end if (couldn't remove item)

		// If we can free the data, do that now, too.   This will try to
		// remove all the variables yet again, but oh well.
		if (fFreeData)
		{
			pResult->DestroyOutputDataBufferAndVars();
		} // end if (we can free the data)
	} // end for (each result)


	// If the user called this, we need to propagate this up the chain,
	// all the way to the master.
	if (pUserCallingTest != NULL)
	{
		if (this->m_pOwningSlave != NULL)
		{
			hr = this->m_pOwningSlave->SendFreeOutputVars(pszCaseID, pszInstanceID,
															pszName, pszType);
			if (hr != S_OK)
			{
				DPL(0, "Failed sending FreeOutputVars message to master!", 0);
				goto DONE;
			} // end if (sending message to master failed)
		} // end if (owned by slave)
		else
		{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
			BOOL		fOldCheckStatus;

			fOldCheckStatus = this->m_fDeadlockCheck; 
			this->m_fDeadlockCheck = FALSE;

			hr = this->m_pOwningLeech->HaveOwnerFreeOutputVars(pUserCallingTest,
																pszCaseID,
																pszInstanceID,
																pszName,
																pszType,
																fFreeData);

			this->m_fDeadlockCheck = fOldCheckStatus;

			if (hr != S_OK)
			{
				DPL(0, "Failed having leech's owner free output vars!", 0);
				goto DONE;
			} // end if (having leech do stuff)
#endif // ! XBOX
		} // end else (owned by leech)
	} // end if (the user called this function)


DONE:

	this->m_results.LeaveCritSection();

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutorPriv::FreeOutputVarsInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::GetTestersMachineInfoInternal()"
//==================================================================================
// CTNExecutorPriv::GetTestersMachineInfoInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of machine info retrieval.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to retrieve COM port under.
//	int iTesterNum			Tester number for which to retrieve COM port.
//	PTNMACHINEINFO* ppInfo	Place to store result in.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::GetTestersMachineInfoInternal(PTNTESTINSTANCES pTest,
														int iTesterNum,
														PTNMACHINEINFO* ppInfo)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


#pragma BUGBUG(vanceo, "does this belong here?"
	// Update the control layer to let it know we're still alive
	this->m_dwLastTestthreadPing = GetTickCount();


	if (this->m_pOwningSlave == NULL)
	{
#ifndef _XBOX // no IPC supported

#pragma BUGBUG(vanceo, "This is a hack, do this right")
		BOOL		fOldCheckStatus;

		fOldCheckStatus = this->m_fDeadlockCheck; 
		this->m_fDeadlockCheck = FALSE;

		hr = this->m_pOwningLeech->HaveOwnerGetTestersMachineInfo(pTest,
																iTesterNum,
																ppInfo);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't have slave get tester's machine info through leech!", 0);
		} // end if (getting machine info failed)

		this->m_fDeadlockCheck = fOldCheckStatus;

#endif // ! XBOX
	} // end if (not owned by slave)
	else
	{
		hr = this->m_pOwningSlave->GetTestersMachineInfoInternal(pTest,
																iTesterNum,
																ppInfo);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't get tester's machine info!", 0);
		} // end if (getting machine info failed)
	} // end else (owned by slave)

	return (hr);
} // CTNExecutorPriv::GetTestersMachineInfoInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutorPriv::DoDocumentation()"
//==================================================================================
// CTNExecutorPriv::DoDocumentation
//----------------------------------------------------------------------------------
//
// Description: Performs the documentation retrieval.
//
// Arguments:
//	PTNTESTTABLEITEM pItem	Pointer to group or item to execute for documentation.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutorPriv::DoDocumentation(PTNTESTTABLEITEM pItem)
{
	HRESULT				hr = S_OK;
	PTNTESTTABLEITEM	pSubItem;
	PTNTESTINSTANCES	pTest = NULL;
	TNEXECCASEDATA		tnecd;
	int					i;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	ZeroMemory(&tnecd, sizeof (TNEXECCASEDATA));


	if (pItem->m_fGroup)
	{
#pragma TODO(vanceo, "Document the group?")

		// Get documentation on all the subitems in the group.
		for(i = 0; i < ((PTNTESTTABLEGROUP) pItem)->m_items.Count(); i++)
		{
			pSubItem = (PTNTESTTABLEITEM) ((PTNTESTTABLEGROUP) pItem)->m_items.GetItem(i);
			if (pSubItem == NULL)
			{
				DPL(0, "Couldn't get subitem %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get sub item)

			hr = this->DoDocumentation(pSubItem);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't document subitem %i!", 1, i);
				goto DONE;
			} // end if (couldn't document)
		} // end for (each item)
	} // end if (group)
	else
	{
		// Skip the built-in test cases.
		if (! (((PTNTESTTABLECASE) pItem)->m_dwOptionFlags & TNTCO_BUILTIN))
		{
			pTest = new (CTNTestInstanceS)(0xFFFFFFFF,
											(PTNTESTTABLECASE) pItem,
											NULL,
											-666, // special value
											NULL,
											//0,
											NULL);
			if (pTest == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)
			pTest->m_dwRefCount++; // we're using it

			tnecd.dwSize = sizeof (TNEXECCASEDATA);
			tnecd.pExecutor = new (CTNExecutor)(this, pTest);
			if (tnecd.pExecutor == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)

			tnecd.iTesterNum = -1;
			//tnecd.pvInputData = NULL;
			//tnecd.dwInputDataSize = 0;
			//tnecd.pSubResults = NULL;
			//tnecd.pFinalResult = NULL;
			//tnecd.pMachineInfo = NULL;

#ifndef DONT_CATCH_DOC_EXCEPTIONS
			try
			{
#endif // ! DONT_CATCH_DOC_EXCEPTIONS
				DPL(5, "Trying to document case \"%s\".", 1, pTest->m_pCase->m_pszID);

				hr = pTest->m_pCase->m_pfnExecCase(&tnecd);
				if (hr != S_OK)
				{
					DPL(0, "WARNING: Case \"%s\" didn't return S_OK for documentation!  %e",
						2, pTest->m_pCase->m_pszID, hr);

					this->SprintfLogInternal(TNLST_MODULE_IMPORTANT,
										"WARNING: Case \"%s\" didn't return S_OK for documentation!  %e",
										2, pTest->m_pCase->m_pszID, hr);
					hr = S_OK;
				} // end if (case didn't return okay)
#ifndef DONT_CATCH_DOC_EXCEPTIONS
			} // end try
			catch (...)
			{
				DPL(0, "WARNING: Case \"%s\" caused an exception, ignoring!",
					1, pTest->m_pCase->m_pszID);

				this->SprintfLogInternal(TNLST_MODULE_IMPORTANT,
									"WARNING: Case \"%s\" caused an exception, ignoring!",
									1, pTest->m_pCase->m_pszID);
				hr = S_OK;
			} // end catch (generic)
#endif // ! DONT_CATCH_DOC_EXCEPTIONS
		} // end if (not a built-in case)
	} // end else (case)


DONE:

	if (tnecd.pExecutor != NULL)
	{
		delete (tnecd.pExecutor);
		tnecd.pExecutor = NULL;
	} // end if (have executor object)

	if (pTest != NULL)
	{
		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting test %x.", 1, pTest);
			delete (pTest);
		} // end if (can delete test)
		else
		{
			DPL(0, "Not deleting test %x, it's refcount is %u!?  DEBUGBREAK()-ing.",
				2, pTest, pTest->m_dwRefCount);
			DEBUGBREAK();
		} // end else (can't delete test)
		pTest = NULL;
	} // end if (have test object)

	return (hr);
} // CTNExecutorPriv::DoDocumentation
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::CTNExecutor()"
//==================================================================================
// CTNExecutor constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNExecutor object.  Initializes the data structures.
//
// Arguments:
//	PTNEXECUTORPRIV pRealExecutor	Pointer to real executor object this interface
//									represents.
//	PTNTESTINSTANCES pTest			Pointer to current test.
//
// Returns: None (just the object).
//==================================================================================
CTNExecutor::CTNExecutor(PTNEXECUTORPRIV pRealExecutor, PTNTESTINSTANCES pTest):
	m_pRealExecutor(pRealExecutor),
	m_pTest(NULL),
	m_pszTestSectionName(NULL),
	m_pszTestSectionFilepath(NULL),
	m_iTestSectionLineNum(-1)
{
	DPL(2, "this = %x, sizeof (this) = %i, test = %x",
		3, this, sizeof (CTNExecutor), pTest);

	pTest->m_dwRefCount++;
	this->m_pTest = pTest;
} // CTNExecutor::CTNExecutor
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::~CTNExecutor()"
//==================================================================================
// CTNExecutor destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNExecutor object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNExecutor::~CTNExecutor(void)
{
	DPL(9, "this = %x, test = %x", 2, this, this->m_pTest);


	this->m_pTest->m_dwRefCount--;
	if (this->m_pTest->m_dwRefCount == 0)
	{
		DPL(2, "Deleting owned test %x.", 1, this->m_pTest);
		delete (this->m_pTest);
	} // end if (refcount hit 0)
	else
	{
		DPL(2, "Not deleting owned test %x, its refcount is %u.",
			2, this->m_pTest, this->m_pTest->m_dwRefCount);
	} // end else (refcount hasn't hit 0)

	this->m_pTest = NULL;


	if (this->m_pszTestSectionName != NULL)
	{
		LocalFree(this->m_pszTestSectionName);
		this->m_pszTestSectionName = NULL;
	} // end if (have string)

	if (this->m_pszTestSectionFilepath != NULL)
	{
		LocalFree(this->m_pszTestSectionFilepath);
		this->m_pszTestSectionFilepath = NULL;
	} // end if (have string)
} // CTNExecutor::~CTNExecutor
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::IsCase()"
//==================================================================================
// CTNExecutor::IsCase
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the currently executing test is based on the given
//				case ID, FALSE otherwise.
//
// Arguments:
//	char* szCaseID	Case ID to check.
//
// Returns: TRUE if test is from case, FALSE otherwise.
//==================================================================================
BOOL CTNExecutor::IsCase(char* szCaseID)
{
	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (FALSE);
	} // end if (bad object pointer)

	if (szCaseID == NULL)
	{
		DPL(0, "Case ID string is NULL!", 0);
		return (FALSE);
	} // end if (bad case ID)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	return ((strcmp(this->m_pTest->m_pCase->m_pszID, szCaseID) == 0) ? TRUE : FALSE);
} // CTNExecutor::IsCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::GetTestingWindow()"
//==================================================================================
// CTNExecutor::GetTestingWindow
//----------------------------------------------------------------------------------
//
// Description: Returns a handle to the window this is executing under.
//
// Arguments: None.
//
// Returns: Handle to window, or NULL if failed.
//==================================================================================
HWND CTNExecutor::GetTestingWindow(void)
{
	HRESULT		hr;
	HWND		hWnd = NULL;


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (NULL);
	} // end if (bad object pointer)


	if (this->m_pRealExecutor->m_pfnGetTestingWindow == NULL)
	{
		DPL(0, "GetTestingWindow is not supported by shell!", 0);
		return (NULL);
	} // end if (callback doesn't exist)

#ifndef _XBOX // no windowing supported

	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->m_pfnGetTestingWindow(&hWnd);

	if (hr != S_OK)
	{
		DPL(0, "Couldn't get testing window!  %e", 1, hr);
		return (NULL);
	} // end if (failed getting window)

#endif // ! XBOX

	return (hWnd);
} // CTNExecutor::GetTestingWindow
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::FirstBinIsVersion()"
//==================================================================================
// CTNExecutor::FirstBinIsVersion
//----------------------------------------------------------------------------------
//
// Description: Sets the passed in boolean to TRUE if the first occurrence of a
//				binary is the specified version, FALSE otherwise.
//
// Arguments:
//	char* szBinaryName		Binary name to examine.
//	DWORD dwHighVersion		High DWORD of file version to compare.
//	DWORD dwLowVersion		Low DWORD of file version to compare.
//	BOOL* lpfResult			Pointer to place to store result.
//
// Returns: S_OK if trying to compare was successful, error code otherwise.  Note
//			lpbResult holds the actual comparison result.
//==================================================================================
HRESULT CTNExecutor::FirstBinIsVersion(char* szBinaryName, DWORD dwHighVersion,
										DWORD dwLowVersion, BOOL* lpfResult)
{
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	return (this->m_pRealExecutor->m_info.m_binaries.FirstBinIsVersion(szBinaryName,
																		dwHighVersion,
																		dwLowVersion,
																		lpfResult));
} // CTNExecutor::FirstBinIsVersion
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::FirstBinIsAtLeastVersion()"
//==================================================================================
// CTNExecutor::FirstBinIsAtLeastVersion
//----------------------------------------------------------------------------------
//
// Description: Sets the passed in boolean to TRUE if the first occurrence of a
//				binary is the specified version or higher, FALSE otherwise.
//
// Arguments:
//	char* szBinaryName		Binary name to examine.
//	DWORD dwHighVersion		High DWORD of file version to compare.
//	DWORD dwLowVersion		Low DWORD of file version to compare.
//	BOOL* lpfResult			Pointer to place to store result.
//
// Returns: S_OK if trying to compare was successful, error code otherwise.  Note
//			lpbResult holds the actual comparison result.
//==================================================================================
HRESULT CTNExecutor::FirstBinIsAtLeastVersion(char* szBinaryName, DWORD dwHighVersion,
											  DWORD dwLowVersion, BOOL* lpfResult)
{
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	return (this->m_pRealExecutor->m_info.m_binaries.FirstBinIsAtLeastVersion(szBinaryName,
																				dwHighVersion,
																				dwLowVersion,
																				lpfResult));
} // CTNExecutor::FirstBinIsAtLeastVersion
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::Log()"
//==================================================================================
// CTNExecutor::Log
//----------------------------------------------------------------------------------
//
// Description: Logs the passed in string to the shell.  The default level is
//				TNLST_MODULE_NORMAL, but if one of TNLF_CRITICAL, TNLF_IMPORTANT, or
//				TNLF_VERBOSE is specified, the level will be adjusted.
//				The string will be parsed for special tokens using the usual
//				routine, see tncommon\sprintf.cpp for possible arguments.
//				Depending on the style flags passed in, some prefixes may be
//				prepended to the string.
//
// Arguments:
//	DWORD dwFlags			Flags describing the string (TNLF_xxx).
//	char* szFormatString	String with optional special tokens to log.
//	DWORD dwNumParms		Number of parameters in the following variable parameter
//							list.
//	...						Variable parameter list; items are interpreted as the
//							special token replacements.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutor::Log(DWORD dwFlags, char* szFormatString, DWORD dwNumParms, ...)
{
	HRESULT		hr;
	DWORD		dwNumPrefixItems = 0;
	char		szPrefixFormat[256];
	char*		pszPrefixedFormatString = NULL;
	PVOID*		papvParams = NULL;
	va_list		currentparam;
	DWORD		dwCurrentItem = 0;
	char*		pszLogString = NULL;
	DWORD		dwLogStringType = TNLST_MODULE_NORMAL;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(this->m_pRealExecutor->m_pOwningSlave->m_pfnLogString == NULL))
	{
		// If we're on the owning slave, and he doesn't implement a log string
		// function, we're done.
		hr = S_OK;
		goto DONE;
	} // end if (not owned by slave)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	// Start with no prefix
	strcpy(szPrefixFormat, "");


	// Build prefix string

	if (dwFlags & TNLF_PREFIX_CASEANDINSTANCEID)
	{
		strcat(szPrefixFormat, "Case %s-%s: ");
		dwNumPrefixItems += 2;
	} // end if (should prefix case ID)

	if (dwFlags & TNLF_PREFIX_CASENAME)
	{
		strcat(szPrefixFormat, "\"%s\": ");
		dwNumPrefixItems++;
	} // end if (should prefix case name)

	if (dwFlags & TNLF_PREFIX_TESTUNIQUEID)
	{
		strcat(szPrefixFormat, "Test %u: ");
		dwNumPrefixItems++;
	} // end if (should prefix unique ID)


	pszPrefixedFormatString = (char*) LocalAlloc(LPTR, (strlen(szPrefixFormat) + strlen(szFormatString) + 1));
	if (pszPrefixedFormatString == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	strcpy(pszPrefixedFormatString, szPrefixFormat);
	strcat(pszPrefixedFormatString, szFormatString);


	papvParams = (PVOID*) LocalAlloc(LPTR, ((dwNumPrefixItems + dwNumParms) * sizeof (PVOID)));
	if (papvParams == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)


	// Attach the prefix item(s) to the param array for passing to sprintf.

	if (dwFlags & TNLF_PREFIX_CASEANDINSTANCEID)
	{
		papvParams[dwCurrentItem] = this->m_pTest->m_pCase->m_pszID;
		dwCurrentItem++;
		papvParams[dwCurrentItem] = this->m_pTest->m_pszInstanceID;
		dwCurrentItem++;
	} // end if (should prefix case ID)

	if (dwFlags & TNLF_PREFIX_CASENAME)
	{
		papvParams[dwCurrentItem] = this->m_pTest->m_pCase->m_pszName;
		dwCurrentItem++;
	} // end if (should prefix case name)

	if (dwFlags & TNLF_PREFIX_TESTUNIQUEID)
	{
		papvParams[dwCurrentItem] = (PVOID) this->m_pTest->m_dwUniqueID;
		dwCurrentItem++;
	} // end if (should prefix unique ID)


#ifndef _XBOX // no TNsprintf functions
	// Loop through the variable arguments and put them into the array too.
	va_start(currentparam, dwNumParms);
	while(dwCurrentItem < (dwNumPrefixItems + dwNumParms))
	{
		papvParams[dwCurrentItem] = va_arg(currentparam, PVOID);
		dwCurrentItem++;
	} // end while (there are more variable parameter)
	va_end(currentparam);


	TNsprintf_array(&pszLogString, pszPrefixedFormatString,
					(dwNumPrefixItems + dwNumParms), papvParams);


	if (dwFlags & TNLF_CRITICAL)
		dwLogStringType = TNLST_CRITICAL;
	else if (dwFlags & TNLF_IMPORTANT)
		dwLogStringType = TNLST_MODULE_IMPORTANT;
	else if (dwFlags & TNLF_VERBOSE)
		dwLogStringType = TNLST_MODULE_VERBOSE;


	// Log the string
	hr = this->m_pRealExecutor->LogInternal(dwLogStringType, pszLogString);
	if (hr != S_OK)
	{
		DPL(0, "Internal logging failed!", 0);
		goto DONE;
	} // end if (log failed)
#else // ! XBOX
#pragma TODO(tristanj, "Need to map executor logging to xLog")
#endif // XBOX

DONE:

	if (pszLogString != NULL)
		TNsprintf_free(&pszLogString);

	if (papvParams != NULL)
	{
		LocalFree(papvParams);
		papvParams = NULL;
	} // end if (have item array)

	if (pszPrefixedFormatString != NULL)
	{
		LocalFree(pszPrefixedFormatString);
		pszPrefixedFormatString = NULL;
	} // end if (have prefixed format string)

	return (hr);
} // CTNExecutor::Log
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::Report()"
//==================================================================================
// CTNExecutor::Report
//----------------------------------------------------------------------------------
//
// Description: Reports checkpoint results for a test (a particular segment was a
//				success or failure, but testing isn't complete yet).
//
// Arguments:
//	HRESULT hresult		Success or error code.
//	BOOL fSuccess		Is this report a success (note this does not necessarily
//						mean hresult is 0)?
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::Report(HRESULT hresult, BOOL fSuccess)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not reporting because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->ReportInternal(this->m_pTest, hresult,
												FALSE, fSuccess, FALSE,
												NULL, 0, NULL);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't report!", 0);
	} // end if (reporting failed)

	return (hr);
} // CTNExecutor::Report
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::Warn()"
//==================================================================================
// CTNExecutor::Warn
//----------------------------------------------------------------------------------
//
// Description: Reports a non-fatal warning for a test.
//
// Arguments:
//	HRESULT hresult			Warning hresult code.
//	PVOID pvUserData		Pointer to optional user data to associate with warning.
//	DWORD dwUserDataSize	Size of user data for warning.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::Warn(HRESULT hresult, PVOID pvUserData, DWORD dwUserDataSize)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not warning because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->WarnInternal(this->m_pTest, hresult, pvUserData,
											dwUserDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't warn!", 0);
	} // end if (warning failed)

	return (hr);
} // CTNExecutor::Warn
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::WaitForEventOrCancel()"
//==================================================================================
// CTNExecutor::WaitForEventOrCancel
//----------------------------------------------------------------------------------
//
// Description: Waits for any of the passed in events to get signalled, the user to
//				cancel, or any of the passed in testers to be lost.
//				If an event got signalled, this function returns TNWR_GOTEVENT.  If
//				piItemNum is not NULL, then the integer it points to is set to the
//				zero-based index of the event that fired.
//				If pahEvents is NULL, then this function acts like a glorified
//				Sleep for the timeout given.
//				If a tester in the passed in array drops or leaves the test, this
//				function returns TNWR_LOSTTESTER.  If piItemNum is not NULL, then
//				the integer it points to is set to the tester number who was lost.
//				paiRelevantTesters can be NULL and iNumRelevantTesters be -1 to have
//				all other testers be relevant.  Specifying this slave's own tester
//				number is ignored.
//				This wait is IO Completion and TAPI friendly (it uses
//				WaitForMultipleObjectsEx and has a message pump).
//
// Arguments:
//	HANDLE* pahEvents			Array of events to wait for, or NULL to simulate a
//								Sleep.
//	int iNumEvents				Number of events in previous array.
//	int* paiRelevantTesters		Array of tester numbers that should cause this
//								function to fail if they drop, if any.
//	int iNumRelevantTesters		Number of testers in previous array, or -1 to
//								use all other testers..
//	DWORD dwTimeout				How long to wait before returning TNWR_TIMEOUT.
//	int* piItemNum				Optional place to store event signalled or tester
//								lost.
//
// Returns: TNWR_GOTEVENT if successful, or TNWR_xxx error code otherwise.
//==================================================================================
HRESULT CTNExecutor::WaitForEventOrCancel(HANDLE* pahEvents, int iNumEvents,
										int* paiRelevantTesters, int iNumRelevantTesters,
										DWORD dwTimeout, int* piItemNum)
{
	HRESULT		hr = S_OK;
	BOOL		fHaveTestMasterOpLock = FALSE;
	int			i = 0;
	int			iNumWaitObjects = 0;
	HANDLE*		pahWaitObjects = NULL;
	DWORD		dwCurrentTime = 0;
	DWORD		dwStartTime = 0;
	DWORD		dwInterval;
#ifndef _XBOX // no messaging supported
	MSG			msg;
#endif // ! XBOX

	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (slave object is invalid)

	if (iNumEvents < 0)
	{
		DPL(0, "Test ID %u called function with invalid number of handles (%i)!",
			2, this->m_pTest->m_dwUniqueID, iNumEvents);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if ((iNumRelevantTesters < -1) || (iNumRelevantTesters >= this->m_pTest->m_iNumMachines))
	{
		DPL(0, "Test ID %u called function with invalid number of relevant testers (%i is <-1 or >=%i)!",
			3, this->m_pTest->m_dwUniqueID, iNumRelevantTesters,
			this->m_pTest->m_iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if ((paiRelevantTesters != NULL) && (iNumRelevantTesters == -1))
	{
		DPL(0, "Test ID %u called function with array of relevant testers but the all-other-testers special number!",
			1, this->m_pTest->m_dwUniqueID);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if ((iNumRelevantTesters > 0) && (paiRelevantTesters == NULL))
	{
		DPL(0, "Test ID %u called function specifying %i relevant testers but no array!",
			2, this->m_pTest->m_dwUniqueID, iNumRelevantTesters);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	// Remap INFINITE and other really long timeouts to a maximum time.
	if (dwTimeout == INFINITE)
	{
		DPL(0, "WARNING: Converting WaitForEventOrCancel timeout from INFINITE to %u ms.",
			1, MAX_WAITFOREVENTORCANCEL_TIME);
		dwTimeout = MAX_WAITFOREVENTORCANCEL_TIME;
	} // end if (wait forever)
	else if (dwTimeout > MAX_WAITFOREVENTORCANCEL_TIME)
	{
		DPL(0, "WARNING: Capping specified WaitForEventOrCancel timeout (%u) at %u ms.",
			2, dwTimeout, MAX_WAITFOREVENTORCANCEL_TIME);
		dwTimeout = MAX_WAITFOREVENTORCANCEL_TIME;
	} // end if (wait forever)
#pragma TODO(vanceo, "Document this behavior.  Any situtations where we may need to wait longer?")



	EnterCriticalSection(&(this->m_pTest->m_csMasterOp));
	fHaveTestMasterOpLock = TRUE;

	// We need to set a request ID (even though we won't actually use it) so that the
	// HandleLostTester code will know to ping our event.
	this->m_pTest->m_dwRequestID = 0xFFFFFFFF;


	if (this->m_pTest->m_hResponseEvent != NULL)
	{
		DPL(0, "Test ID %u's response event already in use?!",
			1, this->m_pTest->m_dwUniqueID);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (we're already syncing)

	this->m_pTest->m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (this->m_pTest->m_hResponseEvent == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't create lost tester event for test ID %u!",
			1, this->m_pTest->m_dwUniqueID);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't create event)


	// If there's an array of relevant testers, validate it and make sure none
	// of those testers has already gone.
	if (iNumRelevantTesters > 0)
	{
		for(i = 0; i < iNumRelevantTesters; i++)
		{
			// Make sure it's in bounds.
			if ((paiRelevantTesters[i] < 0) ||
				(paiRelevantTesters[i] >= this->m_pTest->m_iNumMachines))
			{
				DPL(0, "Relevant tester at index %i is invalid (%i is <0 or >=%i)!",
					3, i, paiRelevantTesters[i], this->m_pTest->m_iNumMachines);
				hr = ERROR_INVALID_PARAMETER;
				goto DONE;
			} // end if (invalid number)

			// Make sure this tester hasn't already left.
			if (this->m_pTest->m_paTesterSlots[paiRelevantTesters[i]].fGone)
			{
				DPL(0, "Tester number %i (array index %i) is already gone.",
					2, paiRelevantTesters[i], i);

				if (piItemNum != NULL)
					(*piItemNum) = paiRelevantTesters[i];

				hr = TNWR_LOSTTESTER;
				goto DONE;
			} // end if (tester already gone)
		} // end for (each relevant tester)
	} // end if (there should be an array of relevant testers)
	else if (iNumRelevantTesters == -1)
	{
		// All testers are relevant, so make sure none are already gone.
		for(i = 0; i < this->m_pTest->m_iNumMachines; i++)
		{
			// Make sure this tester hasn't already left.
			if (this->m_pTest->m_paTesterSlots[i].fGone)
			{
				DPL(0, "Tester number %i is already gone.",
					1, i);

				if (piItemNum != NULL)
					(*piItemNum) = i;

				hr = TNWR_LOSTTESTER;
				goto DONE;
			} // end if (tester already gone)
		} // end for (each tester)
	} // end else if (all testers are relevant)
	


	i = 0;

	iNumWaitObjects = iNumEvents + 1; // + 1 for lost tester event
	if (this->m_pRealExecutor->m_hUserCancelEvent != NULL)
		iNumWaitObjects++;

	pahWaitObjects = (HANDLE*) LocalAlloc(LPTR, ((iNumWaitObjects + 1) * (sizeof (HANDLE))));
	if (pahWaitObjects == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't set it)

	pahWaitObjects[i++] = this->m_pTest->m_hResponseEvent;

	if (this->m_pRealExecutor->m_hUserCancelEvent != NULL)
		pahWaitObjects[i++] = this->m_pRealExecutor->m_hUserCancelEvent;

	// If the user specified events, add them to the array, too.
	if (pahEvents > 0)
	{
		while (i < iNumWaitObjects)
		{
			pahWaitObjects[i] = pahEvents[i - 2];
			i++;
		} // end for (each tester in the param list)
	} // end if (there are event)

	pahWaitObjects[i] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this causes kernel to rewalk array



REWAIT:
	// Make sure the test thread still looks alive
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


#ifndef _XBOX // no message functions supported
	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)
#else // !XBOX
#pragma TODO(tristanj, "Removing message pump may affect things if TAPI isn't removed")
#endif // XBOX

	if (dwTimeout == INFINITE)
	{
		dwInterval = MESSAGE_PUMP_CHECK_INTERVAL;
	} // end if (wait forever)
	else
	{
#ifndef _XBOX // timeGetTime not supported
		dwCurrentTime = timeGetTime();
#else // ! XBOX
		dwCurrentTime = GetTickCount();
#endif // XBOX
		if (dwStartTime == 0)
			dwStartTime = dwCurrentTime;

		// If we reached or went over the timeout, we have to bail.
		if ((dwCurrentTime - dwStartTime) >= dwTimeout)
		{
			DPL(2, "Test ID %u's WaitForEventOrCancel timed out.",
				1, this->m_pTest->m_dwUniqueID);

			hr = TNWR_TIMEOUT;
			goto DONE;
		} // end if (exceeded timeout)


		// If we can't fit a whole interval in, just use the remainder of the time
		// allowed by the given timeout.
		if ((dwCurrentTime - dwStartTime) + MESSAGE_PUMP_CHECK_INTERVAL > dwTimeout)
			dwInterval = dwTimeout - (dwCurrentTime - dwStartTime);
		else
			dwInterval = MESSAGE_PUMP_CHECK_INTERVAL;
	} // end else (don't wait forever)


	hr = WaitForMultipleObjectsEx(iNumWaitObjects, pahWaitObjects, FALSE,
								dwInterval, TRUE);
	switch (hr)
	{
		case WAIT_IO_COMPLETION:
			// This is ugly, but it's how you have to do it.
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			goto REWAIT;
		  break;

		case WAIT_FAILED:
			hr = GetLastError();

			DPL(0, "Wait failed!  %e", 1, hr);

			if (hr == S_OK)
				hr = E_FAIL;

			goto DONE;
		  break;

		case WAIT_OBJECT_0:
			if (this->m_pTest->m_hrResponseResult != TNERR_LOSTTESTER)
			{
				hr = this->m_pTest->m_hrResponseResult;

				DPL(0, "Got unexpected LostTester event firing!  %e",
					1, hr);

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (not a lost tester error)


			// See which tester was lost (and if we care about him).
			if (iNumRelevantTesters == -1)
			{
				for(i = 0; i < this->m_pTest->m_iNumMachines; i++)
				{
					if (this->m_pTest->m_paTesterSlots[i].fGone)
					{
						DPL(0, "Lost tester %i during WaitForEventOrCancel in test ID %u!",
							2, i, this->m_pTest->m_dwUniqueID);

						// Note the tester who was lost if the user wants it.
						if (piItemNum != NULL)
							(*piItemNum) = i;

						hr = TNWR_LOSTTESTER;
						goto DONE;
					} // end if (found a tester who's gone)
				} // end for (each tester)
			} // end if (we care about all of the other testers)
			else if (iNumRelevantTesters > 0)
			{
				for(i = 0; i < iNumRelevantTesters; i++)
				{
					if (this->m_pTest->m_paTesterSlots[paiRelevantTesters[i]].fGone)
					{
						DPL(0, "Lost tester %i (array entry %i) during WaitForEventOrCancel in test ID %u!",
							3, paiRelevantTesters[i], i,
							this->m_pTest->m_dwUniqueID);

						// Note the tester who was lost if the user wants it.
						if (piItemNum != NULL)
							(*piItemNum) = paiRelevantTesters[i];

						hr = TNWR_LOSTTESTER;
						goto DONE;
					} // end if (syncing with dead guy)
				} // end for (each relevant tester)
			} // end else if (we care about certain testers)

			// If we got here, it means doesn't care about that guy.
			goto REWAIT;
		  break;

		default:

			i = hr - (WAIT_OBJECT_0 + 1); // get the index of the item that caused this

			// Check to make sure it was a valid event
			if ((i < 0) || (i >= (iNumWaitObjects - 1)))
			{
				DPL(0, "Test ID %u got unexpected return from WaitForMultipleObjects!  %e",
					2, this->m_pTest->m_dwUniqueID, hr);
				hr = E_FAIL;
				goto DONE;
			} // end if (got wacky return)

			if (this->m_pRealExecutor->m_hUserCancelEvent != NULL)
			{
				if (i == 0)
				{
					DPL(3, "User cancelled test ID %u during WaitForEventOrCancel.",
						1, this->m_pTest->m_dwUniqueID);

					hr = TNWR_USERCANCEL;
					goto DONE;
				} // end if (it was the user cancel event)
				else
					i--; // adjust index as appropriate
			} // end if (there is a user cancel event)

			// Otherwise, note the object that signalled if the user wants it.
			if (piItemNum != NULL)
				(*piItemNum) = i;

			DPL(6, "Test ID %u's event #%i (%x) got signalled.",
				3, this->m_pTest->m_dwUniqueID, i, pahEvents[i]);

			hr = TNWR_GOTEVENT;
		  break;
	} // end switch (on wait result)



DONE:

	if (pahWaitObjects != NULL)
	{
		LocalFree(pahWaitObjects);
		pahWaitObjects = NULL;
	} // end if (allocated an array)

	if (fHaveTestMasterOpLock)
	{
		this->m_pTest->m_dwRequestID = 0;
		this->m_pTest->m_hrResponseResult = E_FAIL;

		if (this->m_pTest->m_hResponseEvent != NULL)
		{
			CloseHandle(this->m_pTest->m_hResponseEvent);
			this->m_pTest->m_hResponseEvent = NULL;
		} // end if (we have response event)

		fHaveTestMasterOpLock = FALSE;
		LeaveCriticalSection(&(this->m_pTest->m_csMasterOp));
	} // end if (have test master op lock)

	return (hr);
} // CTNExecutor::WaitForEventOrCancel
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::ExecSubTestCase()"
//==================================================================================
// CTNExecutor::ExecSubTestCase
//----------------------------------------------------------------------------------
//
// Description: Executes the specifed case as a sub-test of the current test, using
//				the specified tester number & input data, and storing the results
//				on the front of test result chain.
//
// Arguments:
//	char* szCaseModuleID		Module specified test case ID to execute.
//	PVOID pvSubInputData		Pointer to buffer to use as the input data for the
//								sub test.
//	DWORD dwSubInputDataSize	Size of the input data buffer.
//	int iNumMachines			How many testers appear in the following variable
//								parameter list, or 0 to use all the current testers
//								in the same order.
//	...							The testers from the current test who should run the
//								subtest, listed in order of their new positions for
//								execute the subtest.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::ExecSubTestCase(char* szCaseModuleID, PVOID pvSubInputData,
									DWORD dwSubInputDataSize, int iNumMachines, ...)
{
	HRESULT				hr = S_OK;
	PTNTESTTABLECASE	pCase = NULL;
	int*				paiTesterArray = NULL;
	va_list				currentparam;
	int					i;



	// Any changes to this function should go in ExecLeechTestCase too.

	DPL(9, "(%x) ==>(\"%s\", %x, %u, %i, ...)", 5, this, szCaseModuleID,
		pvSubInputData, dwSubInputDataSize, iNumMachines);

	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (object is invalid)

	if (iNumMachines < 0)
	{
		DPL(0, "Module called function without even 1 tester (%i)!",
			1, iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)



	if (iNumMachines == 0)
	{
		iNumMachines = this->m_pTest->m_iNumMachines;
		paiTesterArray = (int*) LocalAlloc(LPTR, (iNumMachines * (sizeof (int))));
		if (paiTesterArray == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		for(i = 0; i < this->m_pTest->m_iNumMachines; i++)
		{
			paiTesterArray[i] = i;
		} // end for (each tester in the param list)
	} // end if (should build a list of all testers)
	else
	{
		paiTesterArray = (int*) LocalAlloc(LPTR, (iNumMachines * (sizeof (int))));
		if (paiTesterArray == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)


		va_start(currentparam, iNumMachines);
		for(i = 0; i < iNumMachines; i++)
		{
			paiTesterArray[i] = va_arg(currentparam, int);
		} // end for (each tester in the param list)
		va_end(currentparam);
	} // end else (got passed a specific list of testers)


	hr = this->ExecSubTestCaseArray(szCaseModuleID, pvSubInputData,
									dwSubInputDataSize, iNumMachines,
									paiTesterArray);
	if (hr != S_OK)
	{
		DPL(0, "Running sub test case ID %s failed!", 1, szCaseModuleID);
		goto DONE;
	} // end if (failed to run the test)


DONE:

	if (paiTesterArray != NULL)
	{
		LocalFree(paiTesterArray);
		paiTesterArray = NULL;
	} // end if (allocated a tester array)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutor::ExecSubTestCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::ExecSubTestCaseArray()"
//==================================================================================
// CTNExecutor::ExecSubTestCaseArray
//----------------------------------------------------------------------------------
//
// Description: Executes the specifed case as a sub-test of the current test, using
//				the specified tester number & input data, and storing the results
//				on the front of test result chain.
//
// Arguments:
//	char* szCaseModuleID		Module specified test case ID to execute.
//	PVOID pvSubInputData		Pointer to buffer to use as the input data for the
//								sub test.
//	DWORD dwSubInputDataSize	Size of the input data buffer.
//	int iNumMachines			How many testers appear in the following variable
//								parameter list.
//	int* aiTesterArray			Array of testers from the current test who should
//								run the subtest, listed in order of their new
//								positions for execute the subtest.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::ExecSubTestCaseArray(char* szCaseModuleID, PVOID pvSubInputData,
										DWORD dwSubInputDataSize, int iNumMachines,
										int* aiTesterArray)
{
	HRESULT				hr = S_OK;
	PTNTESTTABLECASE	pCase = NULL;
	PTNCTRLMACHINEID	paTesters = NULL;
	int					i;



	// Any changes to this function should go in ExecLeechTestCaseArray too.

	DPL(9, "(%x) ==>(\"%s\", %x, %u, %i, %x)", 6, this, szCaseModuleID,
		pvSubInputData, dwSubInputDataSize, iNumMachines, aiTesterArray);

	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not executing sub test because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)


	if (iNumMachines < 1)
	{
		DPL(0, "Module called function without even 1 tester (%i)!",
			1, iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if (iNumMachines > this->m_pTest->m_iNumMachines)
	{
		DPL(0, "Module called function with more testers (%i) than exist in the current test (%i)!",
			2, iNumMachines, this->m_pTest->m_iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if (!((this->m_pTest->m_pCase->m_dwOptionFlags & TNTCO_SCENARIO)))
	{
		DPL(0, "Current/parent test we're running did not indicate it would run subtests!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (invalid testing setup

	pCase = this->m_pRealExecutor->m_testtable.GetTest(szCaseModuleID);
	if (pCase == NULL)
	{
		DPL(0, "Couldn't find sub test ID %s in test table!",
			1, szCaseModuleID);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CRITICAL,
												"Couldn't find sub test ID %s in test table!",
												1, szCaseModuleID);

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (couldn't get test)

	// If the test requires a fixed number of testers and we weren't given that,
	// that's an error.  Otherwise make sure it meets the minimum number required.
	if (pCase->m_iNumMachines > 0)
	{
		if (iNumMachines != pCase->m_iNumMachines)
		{
			DPL(0, "Trying to run sub test ID %s with %i testers (it requires exactly %i)!",
				3, szCaseModuleID, iNumMachines, pCase->m_iNumMachines);

			this->m_pRealExecutor->SprintfLogInternal(TNLST_CRITICAL,
													"Trying to run sub test ID %s with %i testers (it requires exactly %i)!",
													3, szCaseModuleID, iNumMachines,
													pCase->m_iNumMachines);

			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (incorrect number of machines)
	} // end if (requires exact number of machines)
#pragma BUGBUG(vanceo, "Remove if clause when everyone switches over to ADDDATA")
	else if (pCase->m_iNumMachines < 0)
	{
		if (iNumMachines < (-1 * pCase->m_iNumMachines))
		{
			DPL(0, "Trying to run sub test ID %s with %i testers (it requires at least %i)!",
				3, szCaseModuleID, iNumMachines, (-1 * pCase->m_iNumMachines));

			this->m_pRealExecutor->SprintfLogInternal(TNLST_CRITICAL,
													"Trying to run sub test ID %s with %i testers (it requires at least %i)!",
													3, szCaseModuleID, iNumMachines,
													(-1 * pCase->m_iNumMachines));

			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (incorrect number of machines)
	} // end else if (requires minimum number of machines)

	if (! (pCase->m_dwOptionFlags & TNTCO_SUBTEST))
	{
		DPL(0, "Sub test ID %s does not indicate it can be run as a subtest!",
			1, szCaseModuleID);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CRITICAL,
												"Sub test ID %s does not indicate it can be run as a subtest!",
												1, szCaseModuleID);

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (couldn't get test)


	paTesters = (PTNCTRLMACHINEID) LocalAlloc(LPTR, (iNumMachines * sizeof (TNCTRLMACHINEID)));
	if (paTesters == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	for(i = 0; i < iNumMachines; i++)
	{
		if ((aiTesterArray[i] < 0) || (aiTesterArray[i] >= this->m_pTest->m_iNumMachines))
		{
			DPL(0, "Invalid tester number (%i <0 or >=%i) at index %i!",
				3, aiTesterArray[i], this->m_pTest->m_iNumMachines, i);

			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (invalid tester number)

		CopyMemory(&(paTesters[i]),
					&(this->m_pTest->m_paTesterSlots[aiTesterArray[i]].id),
					sizeof (TNCTRLMACHINEID));
	} // end for (each subtester)


	// Update the control layer to let it know we're still alive
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();



	hr = this->m_pRealExecutor->CreateSubTest(this->m_pTest,
											pCase,
											iNumMachines,
											paTesters);
	//BUGBUG what about user cancel, etc
	if (hr != S_OK)
	{
		DPL(0, "Failed to create sub test!", 0);
		goto DONE;
	} // end if (couldn't create subtest)

#ifdef DEBUG
	if (this->m_pTest->m_pSubTest == NULL)
	{
		DPL(0, "Test returned was NULL!?", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (sub test doesn't exist)

	if (this->m_pTest->m_pSubTest->m_dwUniqueID == 0xFFFFFFFF)
	{
		DPL(0, "Test ID returned was invalid!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (sub test is bogus)

	// Just double check to make sure we got the right tests
	if (this->m_pTest->m_pSubTest->m_pCase != pCase)
	{
		DPL(0, "Got unexpected test (%s) while waiting for %s!",
			2, this->m_pTest->m_pSubTest->m_pCase->m_pszID,
			szCaseModuleID);
		hr = E_FAIL;
		goto DONE;
	} // end if (something went wrong)

	// The user should be specifying input data, not the master
	if (((PTNTESTINSTANCES) (this->m_pTest->m_pSubTest))->m_pvInputData != NULL)
	{
		DPL(0, "Subtest response received from master had input data!?", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (something went wrong)
#endif // DEBUG


	// We seem to be okay, so run it.

	hr = this->m_pRealExecutor->RunTest((PTNTESTINSTANCES) (this->m_pTest->m_pSubTest),
										pvSubInputData, dwSubInputDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Running sub test case ID %s failed!", 1, szCaseModuleID);
		goto DONE;
	} // end if (failed to run the test)

	// Note this->m_pTest->m_pSubTest may be cleared.


DONE:

	if (paTesters != NULL)
	{
		LocalFree(paTesters);
		paTesters = NULL;
	} // end if (allocated array)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutor::ExecSubTestCaseArray
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::SyncWithTesters()"
//==================================================================================
// CTNExecutor::SyncWithTesters
//----------------------------------------------------------------------------------
//
// Description:    Issues a request to the testmaster to synchronize with specific
//				other machines working on the test (designated in the variable
//				parameters section).  Data can also be sent to these machines at
//				this time.
//				   A slave is determined to be in-sync when the master has also
//				received sync requests from each of the other testers in the array
//				with the slave specified as a tester to sync with.
//				   This has a domino effect, so that each tester in a slave's sync
//				list must also have heard from all the tester's in its own sync list
//				before marking the first slave as ready.  At that point, the master
//				will fill the return data buffer with the data given by all parties
//				and return TNSR_INSYNC.
//				   Only one sync attempt is allowed to be outstanding at a time, per
//				unique test ID.  Syncing with your own tester number has no effect.
//				   If this function doesn't return TNSR_INSYNC, it is expected that
//				the test case will end as soon as possible.  Specifically, if
//				TNSR_LOSTTESTER is returned, the test case must not call any Sync
//				or Exec function that requires multiple machines.
//
// Arguments:
//	char* szSyncName				User defined unique name for this sync
//									operation.  Must match on all machines
//									involved.
//	PVOID pvSendData				Pointer to data to send to people to sync with.
//	DWORD dwSendDataSize			Size of data to send to people to sync with.
//	PTNSYNCDATALIST pReceiveData	Pointer to list that will hold the data received
//									from the other synchronizing testers.
//	int iNumMachines				How many testers we're syncing with (i.e. how
//									many additional integers there are in the
//									variable parameters list), or 0 to sync with all
//									other testers.
//	...								Integers indicating the testers to sync with.
//
// Returns: TNSR_INSYNC if successful, or TNSR_xxx error code otherwise.
//==================================================================================
HRESULT CTNExecutor::SyncWithTesters(char* szSyncName,
									PVOID pvSendData,
									DWORD dwSendDataSize,
									PTNSYNCDATALIST pReceiveData,
									int iNumMachines, ...)
{
	HRESULT		hr;
	va_list		currentparam;
	int			i;
	int			j;
	int*		paiTesters = NULL;



	if (iNumMachines < 0)
	{
		DPL(0, "Passed invalid number of testers (%i)!", 1, iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (invalid parameters)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	// If they want to just sync with everybody else, build the array for them.
	if (iNumMachines == 0)
	{
		iNumMachines = this->m_pTest->m_iNumMachines - 1;
		paiTesters = (int*) LocalAlloc(LPTR, (iNumMachines * sizeof (int)));
		if (paiTesters == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		j = 0;
		for(i = 0; i < this->m_pTest->m_iNumMachines; i++)
		{
			// Skip our tester number.
			if (memcmp(&(this->m_pTest->m_paTesterSlots[i].id), &(this->m_pRealExecutor->m_id), sizeof (TNCTRLMACHINEID)) == 0)
				continue;

			paiTesters[j] = i;
			j++;
		} // end for (each tester)
	} // end if (just syncing with everyone else)
	else
	{
		paiTesters = (int*) LocalAlloc(LPTR, (iNumMachines * sizeof (int)));
		if (paiTesters == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		// Retrieve all the variable parameter arguments
		va_start(currentparam, iNumMachines);
		for(i = 0; i < iNumMachines; i++)
		{
			paiTesters[i] = va_arg(currentparam, int);
		} // end for (each tester)
		va_end(currentparam);
	} // end else (syncing with a specific set of testers)


	hr = this->SyncWithTestersArray(szSyncName,
									pvSendData,
									dwSendDataSize,
									pReceiveData,
									iNumMachines,
									paiTesters);

DONE:

	if (paiTesters != NULL)
	{
		LocalFree(paiTesters);
		paiTesters = NULL;
	} // end if (allocated array)

	return (hr);
} // CTNExecutor::SyncWithTesters
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::SyncWithTestersArray()"
//==================================================================================
// CTNExecutor::SyncWithTestersArray
//----------------------------------------------------------------------------------
//
// Description:    Issues a request to the testmaster to synchronize with specific
//				other machines working on the test (designated in the passed in
//				array).  Data can also be sent to these machines at this time.
//				   A slave is determined to be in-sync when the master has also
//				received sync requests from each of the other testers in the array
//				with the slave specified as a tester to sync with.
//				   This has a domino effect, so that each tester in a slave's sync
//				list must also have heard from all the tester's in its own sync
//				list before marking the first slave as ready.  At that point, the
//				master will fill the return data buffer with the data given by all
//				parties and return with TNSR_INSYNC.
//				   Only one sync attempt is allowed to be outstanding at a time, per
//				unique test ID.  Syncing with your own tester number has no effect.
//				   If this function doesn't return TNSR_INSYNC, it is expected that
//				the test case will end as soon as possible.  Specifically, if
//				TNSR_LOSTTESTER is returned, the test case must not call any Sync
//				or Exec function that requires multiple machines.
//
// Arguments:
//	char* szSyncName				User defined unique name for this sync
//									operation.  Must match on all machines
//									involved.
//	PVOID pvSendData				Pointer to data to send to people to sync with.
//	DWORD dwSendDataSize			Size of data to send to people to sync with.
//	PTNSYNCDATALIST pReceiveData	Pointer to list that will hold the data received
//									from the other synchronizing testers.
//	int iNumMachines				How many testers we're syncing with (i.e. how
//									many integers there are in following array).
//	int* aiTesters					Array of integers indicating the testers to sync
//									with.
//
// Returns: TNSR_INSYNC if successful, or TNSR_xxx error code otherwise.
//==================================================================================
HRESULT CTNExecutor::SyncWithTestersArray(char* szSyncName,
										PVOID pvSendData,
										DWORD dwSendDataSize,
										PTNSYNCDATALIST pReceiveData,
										int iNumMachines,
										int* aiTesters)
{
	HRESULT		hr;
	int			iLocalTesterNum;
	int			iNumNonLocalTesters = 0;
	int*		paiNonLocalTesters = NULL;
	int			i;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (object is invalid)

	if ((szSyncName == NULL) || (iNumMachines < 1))
	{
		DPL(0, "Passed invalid test, sync name, or number of testers!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (invalid parameters)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not syncing because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)



	iLocalTesterNum = this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id));
	if (iLocalTesterNum < 0)
	{
		DPL(0, "Couldn't get this machine's tester number!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get tester number)


	// Allocate and copy only tester numbers other than this machine's current
	// tester number.
	paiNonLocalTesters = (int*) LocalAlloc(LPTR, iNumMachines * sizeof (int));
	if (paiNonLocalTesters == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)


	// Look for references to the local tester number and for invalid testers.
	for(i = 0; i < iNumMachines; i++)
	{
		if ((aiTesters[i] < 0) || (aiTesters[i] >= this->m_pTest->m_iNumMachines))
		{
			DPL(0, "Tester number at index %i is invalid (%i < 0 or >= %i)!",
				3, i, aiTesters[i], this->m_pTest->m_iNumMachines);
			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (invalid tester number)

		if (aiTesters[i] != iLocalTesterNum)
			paiNonLocalTesters[iNumNonLocalTesters++] = aiTesters[i];
	} // end for (each item in the list)


	if (iNumNonLocalTesters <= 0)
	{
		DPL(0, "No non-local testers left!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (no non-local testers people left)


#ifdef DEBUG
	if (iNumNonLocalTesters < iNumMachines)
	{
		DPL(2, "Test %u (case \"%s\") specified self in sync list %i time(s) in sync \"%s\".",
			4, this->m_pTest->m_dwUniqueID,
			this->m_pTest->m_pCase->m_pszID,
			(iNumMachines - iNumNonLocalTesters),
			szSyncName);
	} // end if (removed some items)

	{
		char	szNumber[32];
		char	szTemp[256];



		ZeroMemory(szTemp, 256);
		for(i = 0; i < iNumNonLocalTesters; i++)
		{
			wsprintf(szNumber, "%i", paiNonLocalTesters[i]);
			strcat(szTemp, szNumber);
			if (i < (iNumNonLocalTesters - 1))
				strcat(szTemp, ", ");
		} // end for (each item in the array)

		DPL(9, "Tester %i: Sync \"%s\" with {%s}, send %u bytes at %x, receive to %x.",
			6, iLocalTesterNum, szSyncName, szTemp, dwSendDataSize,
			pvSendData, pReceiveData);
	}
#endif // DEBUG

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->SyncInternal(this->m_pTest,
											szSyncName,
											pvSendData,
											dwSendDataSize,
											pReceiveData,
											iNumNonLocalTesters,
											paiNonLocalTesters);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't synchronize!", 0);
		//goto DONE;
	} // end if (sync failed)



DONE:

	SAFE_LOCALFREE(paiNonLocalTesters);

	return (hr);
} // CTNExecutor::SyncWithTestersArray
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::IsTesterOnSameMachine()"
//==================================================================================
// CTNExecutor::IsTesterOnSameMachine
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the given tester is located on this same machine,
//				FALSE if not.
//
// Arguments:
//	int iTesterNum		Tester number to check.
//
// Returns: TRUE if tester is on same machine, FALSE otherwise.
//==================================================================================
BOOL CTNExecutor::IsTesterOnSameMachine(int iTesterNum)
{
	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (FALSE);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (FALSE);
	} // end if (in documentation mode)


	if ((iTesterNum < 0) ||
		(iTesterNum >= this->m_pTest->m_iNumMachines) ||
		(iTesterNum == this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id))))
	{
		DPL(0, "Checking invalid tester number (%i must be >0, <%i and not %i)!",
			3, iTesterNum, this->m_pTest->m_iNumMachines,
			this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id)));
		return (FALSE);
	} // end if (invalid tester number)

#pragma BUGBUG(vanceo, "Only checks top level, fix in other functions too")
	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not checking if on same machine because not in a session!", 0);
		return (FALSE);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	return (this->m_pRealExecutor->IsTesterOnSameMachineInternal(this->m_pTest, iTesterNum));
} // CTNExecutor::IsTesterOnSameMachine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::GetTestersIPForPort()"
//==================================================================================
// CTNExecutor::GetTestersIPForPort
//----------------------------------------------------------------------------------
//
// Description: Retrieves the IP address of the specified tester and places it in
//				the passed in string buffer.  The buffer must be at least 15
//				characters + NULL termination long.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	int iTesterNum		Tester number for which to retrieve IP address.
//	WORD wPort			IP port used to verify reachability.
//	char* szIPString	String to store results in (must be 16 chars).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::GetTestersIPForPort(int iTesterNum, WORD wPort,
										char* szIPString)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((iTesterNum < 0) ||
		(iTesterNum >= this->m_pTest->m_iNumMachines) ||
		(iTesterNum == this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id))))
	{
		DPL(0, "Requested tester IP for invalid tester number (%i must be >0, <%i and not %i)!",
			3, iTesterNum, this->m_pTest->m_iNumMachines,
			this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id)));
		return (ERROR_INVALID_PARAMETER);
	} // end if (invalid tester number)

	if ((wPort == 0) || (szIPString == NULL))
	{
		DPL(0, "Passed invalid port or IP string!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (invalid parameters)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not getting tester's IP because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)


	// If the tester is on the same machine, then we never performed a reach
	// check.  Just return the first IP address we have.
	if (this->m_pRealExecutor->IsTesterOnSameMachineInternal(this->m_pTest, iTesterNum))
	{
		DPL(1, "Tester %i of test %u is on same machine, returning our first IP address.",
			2, iTesterNum, this->m_pTest->m_dwUniqueID);

#pragma BUGBUG(vanceo, "Won't work on leeches until they get info copies")
		hr = this->m_pRealExecutor->m_info.m_ipaddrs.GetIPString(0, szIPString);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't get our string for our first IP address!", 0);
			//goto DONE;
		} // end if (failed getting IP string)

		return (hr);
	} // end if (tester is on same machine)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->GetTesterIPInternal(this->m_pTest, iTesterNum,
													wPort, szIPString);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get tester %i's IP!", 1, iTesterNum);
	} // end if (getting IP failed)

	return (hr);
} // CTNExecutor::GetTestersIPForPort
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::GetFirstTAPIDeviceNameWithNumber()"
//==================================================================================
// CTNExecutor::GetFirstTAPIDeviceNameWithNumber
//----------------------------------------------------------------------------------
//
// Description: Sets the passed in pointer to the name of the first TAPI device
//				which has a phone number associated with it.
//				Note: this is not a copy of the string.
//
// Arguments:
//	char** lppszDeviceName		Pointer to set to point to device name string.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::GetFirstTAPIDeviceNameWithNumber(char** lppszDeviceName)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (lppszDeviceName == NULL)
	{
		DPL(0, "Passed invalid device name pointer!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (invalid parameters)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not getting TAPI device name because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->m_info.m_TAPIdevices.GetFirstTAPIDeviceNameWithNumber(lppszDeviceName);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get first TAPI device name with number!", 0);
	} // end if (getting device failed)

	return (hr);
} // CTNExecutor::GetFirstTAPIDeviceNameWithNumber
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::GetPhoneNumberForTester()"
//==================================================================================
// CTNExecutor::GetPhoneNumberForTester
//----------------------------------------------------------------------------------
//
// Description: Returns the phone number of the specified tester number in the given
//				string buffer.  It is assumed to be large enough.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	int iTesterNum			Tester number for which to retrieve phone number.
//	char* szPhoneNumber		String to store result in (must be large enough to hold
//							the entire phone number).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::GetPhoneNumberForTester(int iTesterNum, char* szPhoneNumber)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((iTesterNum < 0) ||
		(iTesterNum >= this->m_pTest->m_iNumMachines) ||
		(iTesterNum == this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id))))
	{
		DPL(0, "Requested tester phone number for invalid tester number (%i must be >0, <%i and not %i)!",
			3, iTesterNum, this->m_pTest->m_iNumMachines,
			this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id)));
		return (ERROR_INVALID_PARAMETER);
	} // end if (invalid tester number)

	if (szPhoneNumber == NULL)
	{
		DPL(0, "Passed invalid phone number string!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (invalid parameters)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not getting phone number because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)


	// If the tester is on the same machine, then we never performed a reach check.
	// Even if there are multiple modems on this machine, we don't have enough
	// information in this function to determine which phone number we should
	// return, so if a user wants to do something with this case, they'll have to
	// do it manually.  It actually would make more sense to have it be a 1 machine
	// test, though.
	if (this->m_pRealExecutor->IsTesterOnSameMachineInternal(this->m_pTest, iTesterNum))
	{
		DPL(0, "Tester %i of test %u is on same machine!",
			2, iTesterNum, this->m_pTest->m_dwUniqueID);
		return (E_FAIL);
	} // end if (tester is on same machine)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->GetTesterPhoneNumInternal(this->m_pTest, iTesterNum,
															szPhoneNumber);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get tester %i's phone number!", 1, iTesterNum);
	} // end if (getting phone number failed)

	return (hr);
} // CTNExecutor::GetPhoneNumberForTester
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::GetCOMPortConnectedToTester()"
//==================================================================================
// CTNExecutor::GetCOMPortConnectedToTester
//----------------------------------------------------------------------------------
//
// Description: Returns the COM port connected to the specified tester in the DWORD
//				pointer given.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	int iTesterNum		Tester number for which to retrieve COM port with
//						connection.
//	DWORD* lpdwCOMPort	Place to store COM port connected.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::GetCOMPortConnectedToTester(int iTesterNum, DWORD* lpdwCOMPort)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((iTesterNum < 0) ||
		(iTesterNum >= this->m_pTest->m_iNumMachines) ||
		(iTesterNum == this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id))))
	{
		DPL(0, "Requested tester IP for invalid tester number (%i must be >0, <%i and not %i)!",
			3, iTesterNum, this->m_pTest->m_iNumMachines,
			this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id)));
		return (ERROR_INVALID_PARAMETER);
	} // end if (invalid tester number)

	if (lpdwCOMPort == NULL)
	{
		DPL(0, "Passed invalid COM port destination pointer!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (invalid parameters)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not getting COM port because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)


	// If the tester is on the same machine, then we never performed a reach check.
	// Even if there are loopback serial connections on this machine, we don't have
	// enough information in this function to determine which one we should return,
	// so if a user wants to do something with this case, they'll have to do it
	// manually.  It actually would make more sense to have it be a 1 machine test,
	// though.
	if (this->m_pRealExecutor->IsTesterOnSameMachineInternal(this->m_pTest, iTesterNum))
	{
		DPL(0, "Tester %i of test %u is on same machine!",
			2, iTesterNum, this->m_pTest->m_dwUniqueID);
		return (E_FAIL);
	} // end if (tester is on same machine)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->GetTesterCOMPortInternal(this->m_pTest, iTesterNum,
														lpdwCOMPort);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get COM port connected to tester %i!", 1, iTesterNum);
	} // end if (getting COM port failed)

	return (hr);
} // CTNExecutor::GetCOMPortConnectedToTester
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no IPC supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::CreateNewLeechAttachment()"
//==================================================================================
// CTNExecutor::CreateNewLeechAttachment
//----------------------------------------------------------------------------------
//
// Description: Creates a new object and prepares it for attachment by a leeching
//				process.
//
// Arguments:
//	PTNLEECH* ppLeech				Pointer to place to store new leech.
//	PVOID pvSendConnectData			Optional pointer to data to send to other side.
//	DWORD dwSendConnectDataSize		Size of data to send to other side.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::CreateNewLeechAttachment(PTNLEECH* ppLeech,
											PVOID pvSendConnectData,
											DWORD dwSendConnectDataSize)
{
	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (ppLeech == NULL)
	{
		DPL(0, "Place to store leech pointer is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not creating new leech because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

#ifdef DEBUG
	if (this->m_pRealExecutor == NULL)
	{
		DPL(0, "Real executor pointer is NULL!?", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (something's screwed)
#endif //DEBUG

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	(*ppLeech) = this->m_pRealExecutor->m_leeches.NewLeech(&(this->m_pRealExecutor->m_moduleID),
															this->m_pRealExecutor,
															pvSendConnectData,
															dwSendConnectDataSize);
	if ((*ppLeech) == NULL)
	{
		DPL(0, "Couldn't create new leech!", 0);
		return (E_FAIL);
	} // end if (couldn't allocate object)

	return (S_OK);
} // CTNExecutor::CreateNewLeechAttachment
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


#ifndef _XBOX // no IPC supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::DetachAndReleaseLeech()"
//==================================================================================
// CTNExecutor::DetachAndReleaseLeech
//----------------------------------------------------------------------------------
//
// Description: Disconnects the leech specified by the pointer, and NULLs it.
//
// Arguments:
//	PTNLEECH* ppLeech	Pointer to leech pointer.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::DetachAndReleaseLeech(PTNLEECH* ppLeech)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (ppLeech == NULL)
	{
		DPL(0, "Place holding leech pointer is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not detaching leech because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->m_leeches.RemoveLeech(*ppLeech);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove leech %x from list!", 1, (*ppLeech));
		return (hr);
	} // end if (couldn't remove leech)

	(*ppLeech) = NULL;

	return (S_OK);
} // CTNExecutor::DetachAndReleaseLeech
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


#ifndef _XBOX // no IPC supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::AllowStaticIDAttachment()"
//==================================================================================
// CTNExecutor::AllowStaticIDAttachment
//----------------------------------------------------------------------------------
//
// Description: Lets the leech process attach using the given preplanned ID.
//				Should only be used if passing the dynamically created ID is not an
//				option.
//
// Arguments:
//	PTNLEECH pLeech			Leech object to allow.
//	char* szPreplannedID	Mutually decided upon ID that leech will connect using.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::AllowStaticIDAttachment(PTNLEECH pLeech, char* szPreplannedID)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if ((pLeech == NULL) || (szPreplannedID == NULL))
	{
		DPL(0, "Leech object or ID is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not allowing static ID attachment because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = pLeech->AllowStaticIDConnection(&(this->m_pRealExecutor->m_moduleID),
										szPreplannedID);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allow static ID (\"%s\") connection for leech %x!",
			2, szPreplannedID, pLeech);
	} // end if (couldn't allow static ID connection)

	return (hr);
} // CTNExecutor::AllowStaticIDAttachment
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


#ifndef _XBOX // no IPC supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::WaitForLeechConnection()"
//==================================================================================
// CTNExecutor::WaitForLeechConnection
//----------------------------------------------------------------------------------
//
// Description: Blocks execution until the specified leech gets connected (or some
//				other event causes testing to be halted).
//
// Arguments:
//	PTNLEECH pTNLeech		The leech to wait for.
//	DWORD dwTimeout			How long to wait for the connection until failing, in
//							milliseconds.
//
// Returns: TNLWR_WAITOK if successful, or TNLWR_xxx error code otherwise.
//==================================================================================
HRESULT CTNExecutor::WaitForLeechConnection(PTNLEECH pTNLeech, DWORD dwTimeout)
{
	HRESULT		hr;
	HANDLE*		pahWaitObjects = NULL;
	DWORD		dwNumWaitObjects;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not waiting for leech connection because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	if (pTNLeech == NULL)
	{
		DPL(0, "Leech object isn't valid!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (leech isn't valid)

#ifdef DEBUG
	if (pTNLeech->m_hConnectEvent != NULL)
	{
		DPL(0, "Leech already has a connect event (%x)!?",
			1, pTNLeech->m_hConnectEvent);
		hr = E_FAIL;
		goto DONE;
	} // end if (the leech already has a connect event)
#endif // DEBUG

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();



	pTNLeech->m_hConnectEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pTNLeech->m_hConnectEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create leech connection event!", 0);
		goto DONE;
	} // end if (the leech already has a connect event)


	dwNumWaitObjects = 1;
	if (this->m_pRealExecutor->m_hUserCancelEvent != NULL)
		dwNumWaitObjects++;

	pahWaitObjects = (HANDLE*) LocalAlloc(LPTR, ((dwNumWaitObjects + 1) * (sizeof (HANDLE))));
	if (pahWaitObjects == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't set it)

	if (! DuplicateHandle(GetCurrentProcess(), pTNLeech->m_hConnectEvent,
						GetCurrentProcess(), &(pahWaitObjects[0]),
						0, FALSE, DUPLICATE_SAME_ACCESS))
	{
		hr = GetLastError();
		DPL(0, "Couldn't duplicate connect event!", 0);
		goto DONE;
	} // end if (couldn't duplicate event)

	if (this->m_pRealExecutor->m_hUserCancelEvent != NULL)
		pahWaitObjects[1] = this->m_pRealExecutor->m_hUserCancelEvent;

	pahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this causes kernel to rewalk array

	//BUGBUG this is not particularly thread safe
	// Just double check to see if it's already connected.  If it is, don't bother
	// waiting.
	if (pTNLeech->m_fConnected)
	{
		DPL(1, "WARNING: Leech \"%s\" already connected, not waiting.",
			1, pTNLeech->GetAttachPointID());
		hr = TNCWR_CONNECTED;
		goto DONE;
	} // end if (already connected)

	DPL(7, "Test ID %u waiting for %u objects (leech \"%s\") or user cancel.",
		3, this->m_pTest->m_dwUniqueID, dwNumWaitObjects,
		pTNLeech->GetAttachPointID());

REWAIT:
	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, pahWaitObjects, FALSE,
								dwTimeout, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Got the completion signal.  Make sure we're cool.

			if (pTNLeech->m_fConnected)
			{
				DPL(1, "Leech \"%s\" connected.", 1, pTNLeech->GetAttachPointID());
				hr = TNCWR_CONNECTED;
			} // end if (connected)
			else
			{
				DPL(0, "Completion indicated leech \"%s\" failed to connect!",
					1, pTNLeech->GetAttachPointID());
				hr = TNCWR_TIMEOUT;
			} // end else (not connected)
		  break;

		case WAIT_OBJECT_0 + 1:
			// User cancelled
			hr = TNCWR_USERCANCEL;
		  break;

		case WAIT_TIMEOUT:
			DPL(5, "Test ID %u's wait for leech \"%s\" connection timed out.",
				2, this->m_pTest->m_dwUniqueID, pTNLeech->GetAttachPointID());

			hr = TNCWR_TIMEOUT;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_FAILED:
			hr = GetLastError();

			DPL(0, "Wait failed!  %e", 1, hr);

			if (hr == S_OK)
				hr = E_FAIL;
		  break;

		default:
			DPL(0, "Test ID %u got unexpected return from WaitForMultipleObjects!",
				1, this->m_pTest->m_dwUniqueID);
		  break;
	} // end switch (on wait result)


DONE:

	if (pahWaitObjects != NULL)
	{
		CloseHandle(pahWaitObjects[0]);
		pahWaitObjects[0] = NULL;

		LocalFree(pahWaitObjects);
		pahWaitObjects = NULL;
	} // end if (allocated an array)

	// Give up our time slice to hopefully make sure the receive thread had time
	// to close this handle in the success case.  It's not a huge deal, because
	// we ignore errors from CloseHandle in both places anyway.
	Sleep(0); 

	if (pTNLeech->m_hConnectEvent != NULL)
	{
		CloseHandle(pTNLeech->m_hConnectEvent);
		pTNLeech->m_hConnectEvent = NULL;
	} // end if (have event)

	return (hr);

} // CTNExecutor::WaitForLeechConnection
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no IPC supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::GetLeechConnectData()"
//==================================================================================
// CTNExecutor::GetLeechConnectData
//----------------------------------------------------------------------------------
//
// Description: Sets the pointers passed in to the data sent by the other side when
//				it connected to the given leech.
//				Note: this is not a copy of the data.
//
// Arguments:
//	PTNLEECH pTNLeech	Pointer to leech to retrieve data for.
//	PVOID* ppvData		Pointer to have set to point to data sent by other side
//						when it connected.
//	DWORD* pdwDataSize	Place to store size of data sent by other side.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutor::GetLeechConnectData(PTNLEECH pTNLeech, PVOID* ppvData,
										DWORD* pdwDataSize)
{
	if (this == NULL)
	{
		DPL(0, "This object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	return (pTNLeech->GetConnectData(ppvData, pdwDataSize));
} // CTNExecutor::GetLeechConnectData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no IPC supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::ExecLeechTestCase()"
//==================================================================================
// CTNExecutor::ExecLeechTestCase
//----------------------------------------------------------------------------------
//
// Description: Instructs the given leech to execute the specifed case, using the
//				the specified tester number & input data, and storing the results
//				on the front of test result chain.
//				This behaves similar to ExecSubTestCase, except the subtest is run
//				in the other process.
//
// Arguments:
//	PTNLEECH pLeech				Leech which should run the test.
//	char* szCaseModuleID		Module specified test case ID to execute.
//	PVOID pvSubInputData		Pointer to buffer to use as the input data for the
//								leech test.
//	DWORD dwSubInputDataSize	Size of the input data buffer.
//	int iNumMachines			How many testers appear in the following variable
//								parameter list, or 0 to use all the current
//								testers in the same order.
//	...							The testers from the current test who should run the
//								subtest, listed in order of their new positions for
//								execute the subtest.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::ExecLeechTestCase(PTNLEECH pLeech, char* szCaseModuleID,
									PVOID pvSubInputData, DWORD dwSubInputDataSize,
									int iNumMachines, ...)
{
	HRESULT				hr = S_OK;
	PTNTESTTABLECASE	pCase = NULL;
	int*				paiTesterArray = NULL;
	va_list				currentparam;
	int					i;


	// Any changes to this function should go in ExecSubTestCase too.


	DPL(9, "(%x) ==>(%x, \"%s\", %x, %u, %i, ...)", 6, this, pLeech, szCaseModuleID,
		pvSubInputData, dwSubInputDataSize, iNumMachines);

	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (object is invalid)

	if (iNumMachines < 0)
	{
		DPL(0, "Module called function without even 1 tester (%i)!",
			1, iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	if (iNumMachines == 0)
	{
		iNumMachines = this->m_pTest->m_iNumMachines;
		paiTesterArray = (int*) LocalAlloc(LPTR, (iNumMachines * (sizeof (int))));
		if (paiTesterArray == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		for(i = 0; i < this->m_pTest->m_iNumMachines; i++)
		{
			paiTesterArray[i] = i;
		} // end for (each tester in the param list)
	} // end if (should build a list of all testers)
	else
	{
		paiTesterArray = (int*) LocalAlloc(LPTR, (iNumMachines * (sizeof (int))));
		if (paiTesterArray == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)


		va_start(currentparam, iNumMachines);
		for(i = 0; i < iNumMachines; i++)
		{
			paiTesterArray[i] = va_arg(currentparam, int);
		} // end for (each tester in the param list)
		va_end(currentparam);
	} // end else (got passed a specific list of testers)


	hr = this->ExecLeechTestCaseArray(pLeech, szCaseModuleID,
									pvSubInputData, dwSubInputDataSize,
									iNumMachines, paiTesterArray);
	if (hr != S_OK)
	{
		DPL(0, "Running leech test case ID %s failed!", 1, szCaseModuleID);
		goto DONE;
	} // end if (failed to run the test)


DONE:

	if (paiTesterArray != NULL)
	{
		LocalFree(paiTesterArray);
		paiTesterArray = NULL;
	} // end if (allocated a tester array)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutor::ExecLeechTestCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#ifndef _XBOX // no IPC supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::ExecLeechTestCaseArray()"
//==================================================================================
// CTNExecutor::ExecLeechTestCaseArray
//----------------------------------------------------------------------------------
//
// Description: Instructs the given leech to execute the specifed case, using the
//				the specified tester number & input data, and storing the results
//				on the front of test result chain.
//				This behaves similar to ExecSubTestCase, except the subtest is run
//				in the other process.
//
// Arguments:
//	PTNLEECH pLeech				Leech which should run the test.
//	char* szCaseModuleID		Module specified test case ID to execute.
//	PVOID pvSubInputData		Pointer to buffer to use as the input data for the
//								leech test.
//	DWORD dwSubInputDataSize	Size of the input data buffer.
//	int iNumMachines			How many testers appear in the following variable
//								parameter list.
//	int* aiTesterArray			The testers from the current test who should run the
//								subtest, listed in order of their new positions for
//								execute the subtest.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::ExecLeechTestCaseArray(PTNLEECH pLeech, char* szCaseModuleID,
									LPVOID pvSubInputData, DWORD dwSubInputDataSize,
									int iNumMachines, int* aiTesterArray)
{
	HRESULT				hr = S_OK;
	PTNTESTTABLECASE	pCase = NULL;
	PTNCTRLMACHINEID	paTesters = NULL;
	int					i;


	// Any changes to this function should go in ExecSubTestCase too.


	DPL(9, "(%x) ==>(%x, \"%s\", %x, %u, %i, %x)", 7, this, pLeech, szCaseModuleID,
		pvSubInputData, dwSubInputDataSize, iNumMachines, aiTesterArray);

	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not executing leech test because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)

	if (iNumMachines < 1)
	{
		DPL(0, "Module called function without even 1 tester (%i)!",
			1, iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if (iNumMachines > this->m_pTest->m_iNumMachines)
	{
		DPL(0, "Module called function with more testers (%i) than exist in the current test (%i)!",
			2, iNumMachines, this->m_pTest->m_iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if (!((this->m_pTest->m_pCase->m_dwOptionFlags & TNTCO_SCENARIO)))
	{
		DPL(0, "Current/parent test we're running did not indicate it would run subtests!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (invalid testing setup

	pCase = this->m_pRealExecutor->m_testtable.GetTest(szCaseModuleID);
	if (pCase == NULL)
	{
		DPL(0, "Couldn't find sub test ID %s in test table!",
			1, szCaseModuleID);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CRITICAL,
												"Couldn't find leech test ID %s in test table!",
												1, szCaseModuleID);

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (couldn't get test)


	// If the test requires a fixed number of testers and we weren't given that,
	// that's an error.  Otherwise make sure it meets the minimum number required.
	if (pCase->m_iNumMachines > 0)
	{
		if (iNumMachines != pCase->m_iNumMachines)
		{
			DPL(0, "Trying to run sub test ID %s with %i testers (it requires exactly %i)!",
				3, szCaseModuleID, iNumMachines, pCase->m_iNumMachines);

			this->m_pRealExecutor->SprintfLogInternal(TNLST_CRITICAL,
													"Trying to run sub test ID %s with %i testers (it requires exactly %i)!",
													3, szCaseModuleID, iNumMachines,
													pCase->m_iNumMachines);

			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (incorrect number of machines)
	} // end if (requires exact number of machines)
#pragma BUGBUG(vanceo, "Remove if clause when everyone switches over to ADDDATA")
	else if (pCase->m_iNumMachines < 0)
	{
		if (iNumMachines < (-1 * pCase->m_iNumMachines))
		{
			DPL(0, "Trying to run sub test ID %s with %i testers (it requires at least %i)!",
				3, szCaseModuleID, iNumMachines, (-1 * pCase->m_iNumMachines));

			this->m_pRealExecutor->SprintfLogInternal(TNLST_CRITICAL,
													"Trying to run sub test ID %s with %i testers (it requires at least %i)!",
													3, szCaseModuleID, iNumMachines,
													(-1 * pCase->m_iNumMachines));

			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (incorrect number of machines)
	} // end else if (requires minimum number of machines)

	if (! (pCase->m_dwOptionFlags & TNTCO_SUBTEST))
	{
		DPL(0, "Leech test ID %s does not indicate it can be run as a subtest!",
			1, szCaseModuleID);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CRITICAL,
												"Sub test ID %s does not indicate it can be run as a subtest!",
												1, szCaseModuleID);

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (couldn't get test)

	paTesters = (PTNCTRLMACHINEID) LocalAlloc(LPTR, (iNumMachines * sizeof (TNCTRLMACHINEID)));
	if (paTesters == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	for(i = 0; i < iNumMachines; i++)
	{
		CopyMemory(&(paTesters[i]),
					&(this->m_pTest->m_paTesterSlots[aiTesterArray[i]].id),
					sizeof (TNCTRLMACHINEID));
	} // end for (each subtester)


	// Update the control layer to let it know we're still alive
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();



	hr = this->m_pRealExecutor->CreateSubTest(this->m_pTest,
											pCase,
											iNumMachines,
											paTesters);
	//BUGBUG what about user cancel, etc
	if (hr != S_OK)
	{
		DPL(0, "Failed to create sub test!", 0);
		goto DONE;
	} // end if (couldn't create subtest)

#ifdef DEBUG
	if (this->m_pTest->m_pSubTest == NULL)
	{
		DPL(0, "Test returned was NULL!?", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (sub test doesn't exist)

	if ((this->m_pTest->m_pSubTest->m_dwUniqueID == 0) ||
		(this->m_pTest->m_pSubTest->m_dwUniqueID == 0xFFFFFFFF))
	{
		DPL(0, "Test ID returned was invalid (%u)!",
			1, this->m_pTest->m_pSubTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (sub test is bogus)

	// Just double check to make sure we got the right tests
	if (this->m_pTest->m_pSubTest->m_pCase != pCase)
	{
		DPL(0, "Got unexpected test (%s) while waiting for %s!",
			2, this->m_pTest->m_pSubTest->m_pCase->m_pszID,
			szCaseModuleID);
		hr = E_FAIL;
		goto DONE;
	} // end if (something went wrong)

	// The user should be specifying input data, not the master
	if (((PTNTESTINSTANCES) (this->m_pTest->m_pSubTest))->m_pvInputData != NULL)
	{
		DPL(0, "Subtest response received from master had input data!?", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (something went wrong)
#endif // DEBUG


	// We seem to be okay, so have the leech run it.  First make sure deadlock
	// checking is off.
#pragma BUGBUG(vanceo, "This is a hack, do this right")
	BOOL		fOldCheckStatus;

	fOldCheckStatus = this->m_pRealExecutor->m_fDeadlockCheck; 
	this->m_pRealExecutor->m_fDeadlockCheck = FALSE;

	hr = pLeech->HaveLeechRunTest((PTNTESTINSTANCES) (this->m_pTest->m_pSubTest),
									pvSubInputData, dwSubInputDataSize);

	this->m_pRealExecutor->m_fDeadlockCheck = fOldCheckStatus;

	if (hr != S_OK)
	{
		DPL(0, "Running leech test case ID %s failed!", 1, szCaseModuleID);
		goto DONE;
	} // end if (failed to run the test)


DONE:

	if (paTesters != NULL)
	{
		LocalFree(paTesters);
		paTesters = NULL;
	} // end if (allocated array)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutor::ExecLeechTestCaseArray
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::CreateNewFaultSim()"
//==================================================================================
// CTNExecutor::CreateNewFaultSim
//----------------------------------------------------------------------------------
//
// Description: Creates a new fault simulator of the specified type and initializes
//				it with the given data.
//
// Arguments:
//	PTNFAULTSIM* ppFaultSim		Pointer to place to store new fault sim.
//	DWORD dwFaultSimID			Type of fault simulator to create.
//	PVOID pvInitData			Pointer to data to give to fault simulator when
//								initializing.  FaultSim dependant.
//	DWORD dwInitDataSize		Size of data to use when initializing.  FaultSim
//								dependant.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::CreateNewFaultSim(PTNFAULTSIM* ppFaultSim, DWORD dwFaultSimID,
										PVOID pvInitData, DWORD dwInitDataSize)
{
	HRESULT		hr;
	BOOL		fInitted = FALSE;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (object is invalid)

	if (ppFaultSim == NULL)
	{
		DPL(0, "Place to store fault sim pointer is NULL!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not creating fault sim because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (we're not in a session right now)

#ifdef DEBUG
	if (this->m_pRealExecutor == NULL)
	{
		DPL(0, "Real executor pointer is NULL!?", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (something's screwed)
#endif //DEBUG

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	switch (dwFaultSimID)
	{
		case TN_FAULTSIM_IMTEST:
			(*ppFaultSim) = new (CTNFaultSimIMTest);
		  break;

		default:
			DPL(0, "Unknown fault simulator ID %u!", 1, dwFaultSimID);
			hr = ERROR_INVALID_PARAMETER;
			goto ERROR_EXIT;
		  break;
	} // end switch (on the type of fault simulator)

	if ((*ppFaultSim) == NULL)
	{
		DPL(0, "Couldn't create new fault simulator of type %u!",
			1, dwFaultSimID);
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (couldn't allocate object)

	hr = (*ppFaultSim)->Initialize(pvInitData, dwInitDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't initialize fault simulator type %u!", 1, dwFaultSimID);
		goto ERROR_EXIT;
	} // end if (couldn't initialize fault sim)

	fInitted = TRUE;


	hr = this->m_pRealExecutor->m_faultsims.Add(*ppFaultSim);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add fault simulator object %x to list!", 1, (*ppFaultSim));
		goto ERROR_EXIT;
	} // end if (couldn't add item)


	return (S_OK);


ERROR_EXIT:

	if (fInitted)
	{
		// Ignore error.
		(*ppFaultSim)->Release();
		fInitted = FALSE;
	} // end if (initialized fault sim)

	if ((*ppFaultSim) != NULL)
	{
		delete (*ppFaultSim);
		(*ppFaultSim) = NULL;
	} // end if (have object)

	return (hr);
} // CTNExecutor::CreateNewFaultSim
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::ReleaseFaultSim()"
//==================================================================================
// CTNExecutor::ReleaseFaultSim
//----------------------------------------------------------------------------------
//
// Description: Releases the fault simulator specified by the pointer, and NULLs it.
//
// Arguments:
//	PTNFAULTSIM* ppFaultSim		Pointer to fault sim pointer.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::ReleaseFaultSim(PTNFAULTSIM* ppFaultSim)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (ppFaultSim == NULL)
	{
		DPL(0, "Place holding fault sim pointer is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not releasing fault sim because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	hr = this->m_pRealExecutor->m_faultsims.RemoveFirstReference(*ppFaultSim);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove fault sim %x from list!", 1, (*ppFaultSim));
		return (hr);
	} // end if (couldn't remove fault sim)

	hr = (*ppFaultSim)->Release();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't release fault sim %x!", 1, (*ppFaultSim));
		return (hr);
	} // end if (couldn't release fault sim)

	if ((*ppFaultSim)->m_dwRefCount == 0)
	{
		delete (*ppFaultSim);
	} // end if (can delete object)
	else
	{
		DPL(0, "WARNING: Can't delete fault simulator %x, its refcount is %u!",
			2, (*ppFaultSim), (*ppFaultSim)->m_dwRefCount);
	} // end else (can't delete object)

	(*ppFaultSim) = NULL;

	return (S_OK);
} // CTNExecutor::ReleaseFaultSim
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::SetFaultSimBandwidth()"
//==================================================================================
// CTNExecutor::SetFaultSimBandwidth
//----------------------------------------------------------------------------------
//
// Description: Sets the artificial send or receive bandwidth limit for the given
//				fault simulator.
//				Pass in zero to turn bandwidth limiting off.
//
// Arguments:
//	PTNFAULTSIM pFaultSim		Pointer to fault simulator to use.
//	BOOL fSend					TRUE to limit the send (outgoing) bandwidth, FALSE
//								to limit the receive (incoming) bandwidth.
//	DWORD dwHundredBytesPerSec	Rate to constrict the bandwidth to, or 0 for none.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::SetFaultSimBandwidth(PTNFAULTSIM pFaultSim,
										BOOL fSend, DWORD dwHundredBytesPerSec)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (pFaultSim == NULL)
	{
		DPL(0, "Fault sim pointer is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not setting bandwidth because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	if (dwHundredBytesPerSec > 0)
	{
		DPL(1, "Setting fault simulator %s bandwidth to %u00 bytes per sec.",
			2, ((fSend) ? "send" : "receive"), dwHundredBytesPerSec);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
				"Setting fault simulator %s bandwidth to %u00 bytes per sec.",
				2, ((fSend) ? "send" : "receive"), dwHundredBytesPerSec);
	} // end if (turning on bandwidth limitation)
	else
	{
		DPL(1, "Turning off fault simulator %s bandwidth limitation.",
			1, ((fSend) ? "send" : "receive"));

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
			"Turning off fault simulator %s bandwidth limitation.",
			1, ((fSend) ? "send" : "receive"));
	} // end else (turning off bandwidth limitation)

	
	hr = pFaultSim->SetBandwidth(fSend, dwHundredBytesPerSec);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't set fault sim %x's %s bandwidth to %u00 bytes per sec!",
			3, pFaultSim, ((fSend) ? "send" : "receive"), dwHundredBytesPerSec);
	} // end if (couldn't set bandwidth)

	return (hr);
} // CTNExecutor::SetFaultSimBandwidth
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::SetFaultSimLatency()"
//==================================================================================
// CTNExecutor::SetFaultSimLatency
//----------------------------------------------------------------------------------
//
// Description: Sets the artificial send or receive latency for the given fault
//				simulator.
//				Pass in zero to turn artificial latency off.
//
// Arguments:
//	PTNFAULTSIM pFaultSim	Pointer to fault simulator to use.
//	BOOL fSend				TRUE to incur the latency on sends (outgoing data),
//							FALSE to incur the latency on receives (incoming data).
//	DWORD dwMSDelay			Number of milliseconds to increase the latency by, or 0
//							for none.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::SetFaultSimLatency(PTNFAULTSIM pFaultSim,
										BOOL fSend, DWORD dwMSDelay)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (pFaultSim == NULL)
	{
		DPL(0, "Fault sim pointer is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not setting latency because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	if (dwMSDelay > 0)
	{
		DPL(1, "Setting fault simulator %s artificial latency to %u ms.",
			2, ((fSend) ? "send" : "receive"), dwMSDelay);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
				"Setting fault simulator %s artificial latency to %u ms.",
				2, ((fSend) ? "send" : "receive"), dwMSDelay);
	} // end if (turning on latency)
	else
	{
		DPL(1, "Turning off fault simulator %s artificial latency.",
			1, ((fSend) ? "send" : "receive"));

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
			"Turning off fault simulator %s artificial latency.",
			1, ((fSend) ? "send" : "receive"));
	} // end else (turning off latency)

	
	hr = pFaultSim->SetLatency(fSend, dwMSDelay);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't set fault sim %x's %s artificial latency to %u ms!",
			3, pFaultSim, ((fSend) ? "send" : "receive"), dwMSDelay);
	} // end if (couldn't set latency)

	return (hr);
} // CTNExecutor::SetFaultSimLatency
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::SetFaultSimDropPacketsPercent()"
//==================================================================================
// CTNExecutor::SetFaultSimDropPacketsPercent
//----------------------------------------------------------------------------------
//
// Description: Sets the percentage of sent or received packets which should be
//				randomly dropped.
//				Pass 0 to turn function off.
//
// Arguments:
//	PTNFAULTSIM pFaultSim	Pointer to fault simulator to use.
//	BOOL fSend				TRUE to set the drop percentage for sends (outgoing
//							data), FALSE to set the drop percentage for receives
//							(incoming data).
//	DWORD dwPercent			Percentage of packets to randomly drop, or 0 for none.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::SetFaultSimDropPacketsPercent(PTNFAULTSIM pFaultSim,
													BOOL fSend, DWORD dwPercent)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (pFaultSim == NULL)
	{
		DPL(0, "Fault sim pointer is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not setting drop packets percent because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	if (dwPercent > 0)
	{
		DPL(1, "Setting fault simulator %s packet loss to %u%.",
			2, ((fSend) ? "send" : "receive"), dwPercent);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
				"Setting fault simulator %s packet loss to %u%.",
				2, ((fSend) ? "send" : "receive"), dwPercent);
	} // end if (turning on packet loss)
	else
	{
		DPL(1, "Turning off fault simulator %s packet loss.",
			1, ((fSend) ? "send" : "receive"));

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
			"Turning off fault simulator %s packet loss.",
			1, ((fSend) ? "send" : "receive"));
	} // end else (turning off packet loss)

	
	hr = pFaultSim->SetDropPacketsPercent(fSend, dwPercent);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't set fault sim %x's %s packet loss to %u%!",
			3, pFaultSim, ((fSend) ? "send" : "receive"), dwPercent);
	} // end if (couldn't set drop percent)

	return (hr);
} // CTNExecutor::SetFaultSimDropPacketsPercent
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::FaultSimReconnect()"
//==================================================================================
// CTNExecutor::FaultSimReconnect
//----------------------------------------------------------------------------------
//
// Description: Reconnects either the send/receive link
//
// Arguments:
//	PTNFAULTSIM pFaultSim	Pointer to fault simulator to use.
//	BOOL fSend				TRUE to connect send link
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::FaultSimReconnect(PTNFAULTSIM pFaultSim,
										BOOL fSend)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (pFaultSim == NULL)
	{
		DPL(0, "Fault sim pointer is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not setting drop packets percent because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	if(fSend)
	{
		DPL(1, "Setting fault simulator reconnect for send side", 0);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
			"Setting fault simulator reconnect for send side", 0);
	} // end if (reconnecting send side)
	else
	{
		DPL(1, "Setting fault simulator reconnect for receive side", 0);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
			"Setting fault simulator reconnect for receive side", 0);
	} // end if (reconnecting receive side)
	
	
	hr = pFaultSim->Reconnect(fSend);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't reconnect!", 0);
	} // end if (couldn't reconnect)

	return (hr);
} // CTNExecutor::FaultSimReconnect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::FaultSimDisconnect()"
//==================================================================================
// CTNExecutor::FaultSimDisconnect
//----------------------------------------------------------------------------------
//
// Description: Disconnects either the send/receive link
//
// Arguments:
//	PTNFAULTSIM pFaultSim	Pointer to fault simulator to use.
//	BOOL fSend				TRUE to connect send link
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::FaultSimDisconnect(PTNFAULTSIM pFaultSim,
										BOOL fSend)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if (pFaultSim == NULL)
	{
		DPL(0, "Fault sim pointer is NULL!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (param is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	if ((this->m_pRealExecutor->m_pOwningSlave != NULL) &&
		(! this->m_pRealExecutor->m_pOwningSlave->m_fInSession))
	{
		DPL(0, "Not setting drop packets percent because not in a session!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we're not in a session right now)

	
	// The user is making a function call, so the test thread is still alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	if(fSend)
	{
		DPL(1, "Setting fault simulator disconnect for send side", 0);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
			"Setting fault simulator disconnect for send side", 0);
	} // end if (disconnecting send side)
	else
	{
		DPL(1, "Setting fault simulator disconnect for receive side", 0);

		this->m_pRealExecutor->SprintfLogInternal(TNLST_CONTROLLAYER_INFO,
			"Setting fault simulator disconnect for receive side", 0);
	} // end if (disconnecting receive side)
	
	
	hr = pFaultSim->Disconnect(fSend);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't disconnect!", 0);
	} // end if (couldn't disconnect)

	return (hr);
} // CTNExecutor::FaultSimDisconnect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::NoteTestIsStillRunning()"
//==================================================================================
// CTNExecutor::NoteTestIsStillRunning
//----------------------------------------------------------------------------------
//
// Description: Resets the deadlock check counter.  Use this function if your test
//				performs long operations without making an ITNExcutor call; to
//				prevent deadlock check from firing if your test is still active.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNExecutor::NoteTestIsStillRunning(void)
{
	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return;
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return;
	} // end if (in documentation mode)


	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();
} // CTNExecutor::NoteTestIsStillRunning
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::SetDeadlockCheck()"
//==================================================================================
// CTNExecutor::SetDeadlockCheck
//----------------------------------------------------------------------------------
//
// Description: Resets the deadlock check counter.  Use this function if your test
//				performs long operations without making an ITNExcutor call; to
//				prevent deadlock check from firing if your test is still active.
//
// Arguments:
//	BOOL fOn	Whether to turn deadlock checking on or off.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutor::SetDeadlockCheck(BOOL fOn)
{
	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	// Update the count, so the check doesn't go nuts if it's been off for a while.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();

	if (this->m_pRealExecutor->m_fDeadlockCheck == fOn)
	{
		DPL(0, "WARNING: Deadlock checking is already %s in test %u (case \"%s\").",
			3, ((fOn) ? "on" : "off"), this->m_pTest->m_dwUniqueID,
			this->m_pTest->m_pCase->m_pszID);
	} // end if (already set that way)
	else
	{
		DPL(0, "NOTE: Turning deadlock checking %s in test %u (case \"%s\").",
			3, ((fOn) ? "on" : "off"), this->m_pTest->m_dwUniqueID,
			this->m_pTest->m_pCase->m_pszID);

		this->m_pRealExecutor->m_fDeadlockCheck = fOn;
	} // end else (changing settings)

	return (S_OK);
} // CTNExecutor::SetDeadlockCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::FreeResults()"
//==================================================================================
// CTNExecutor::FreeResults
//----------------------------------------------------------------------------------
//
// Description: Frees all results matching the given criteria, if specified.  If
//				both parameters are NULL, all results are freed.
//				Note that all output data and variables are destroyed as well.
//
// Arguments:
//	char* pszCaseID			Case ID to match, or NULL for all.
//	char* pszInstanceID		Instance ID to match, or NULL for all.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutor::FreeResults(char* pszCaseID, char* pszInstanceID)
{
	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	// Update the count, so the check doesn't go nuts if it's been off for a while.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();
	
	return (this->m_pRealExecutor->FreeResultsInternal(pszCaseID, pszInstanceID,
														this->m_pTest));
} // CTNExecutor::FreeResults
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::FreeOutputVars()"
//==================================================================================
// CTNExecutor::FreeOutputVars
//----------------------------------------------------------------------------------
//
// Description: Frees all output variables matching the given criteria.  If a
//				parameter is not NULL, then only vars from the corresponding test,
//				with a matching name, etc. are freed.  If all parameters are NULL,
//				all output vars are freed.
//
// Arguments:
//	char* pszCaseID			Case ID to match, or NULL for all.
//	char* pszInstanceID		Instance ID to match, or NULL for all.
//	char* pszName			Output variable name to match, or NULL for all.
//	char* pszType			Output variable type to match, or NULL for all.
//	BOOL fFreeData			Whether the data can be freed, too, if no variables are
//							left for a given result.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutor::FreeOutputVars(char* pszCaseID, char* pszInstanceID,
									char* pszName, char* pszType, BOOL fFreeData)
{
	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


	// Update the count, so the check doesn't go nuts if it's been off for a while.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();

	return (this->m_pRealExecutor->FreeOutputVarsInternal(pszCaseID, pszInstanceID,
														pszName, pszType, fFreeData,
														this->m_pTest));
} // CTNExecutor::FreeOutputVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::PromptUser()"
//==================================================================================
// CTNExecutor::PromptUser
//----------------------------------------------------------------------------------
//
// Description: Displays a dialog box for the user, with different behaviors
//				depending on the dialog type specified.
//				The main message body string will be parsed for special tokens using
//				the usual routine, see tncommon\sprintf.cpp for possible arguments.
//				If a tester in the passed in array drops or leaves the test, this
//				function returns TNWR_LOSTTESTER.  If piResponse is not NULL, then
//				the integer it points to is set to the tester number who was lost.
//				paiRelevantTesters can be NULL and iNumRelevantTesters be -1 to have
//				all other testers be relevant.  Specifying this slave's own tester
//				number is ignored.
//
// Arguments:
//	char* szTitle				Title for the message box.
//	char* szMessageFormat		String with optional special tokens that will be
//								displayed in the body of the message box.
//	DWORD dwDialogType			Style of the message box, see TNPUDT_xxx.
//	PVOID pvDialogData			Pointer to additional data for dialog box, if any.
//	DWORD dwDialogDataSize		Size of additional data for dialog box, if any.
//	int* paiRelevantTesters		Array of tester numbers that should cause this
//								function to fail if they drop, if any.
//	int iNumRelevantTesters		Number of testers in previous array, or -1 to
//								use all other testers..
//	int* piResponse				Optional place to store what the user responded
//								with.
//	DWORD dwNumParms			Number of parameters in the following variable
//								parameter list.
//	...							Variable parameter list; items are interpreted as
//								the special token replacements in szMessageFormat
//								string.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNExecutor::PromptUser(char* szTitle, char* szMessageFormat,
								DWORD dwDialogType,
								PVOID pvDialogData, DWORD dwDialogDataSize,
								int* paiRelevantTesters, int iNumRelevantTesters,
								int* piResponse,
								DWORD dwNumParms, ...)
{
	HRESULT		hr = S_OK;
	PVOID*		papvParams = NULL;
	va_list		currentparam;
	DWORD		dwCurrentItem = 0;
	char*		pszMessage = NULL;
	BOOL		fHaveTestMasterOpLock = FALSE;
	HWND		hPromptWnd = NULL;
	int			i;
	DWORD		dwTemp;
	DWORD		dwNumWaitObjects = 0;
	HANDLE		ahWaitObjects[3];
	MSG			msg;


	if (this == NULL)
	{
		DPL(0, "Executor object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (object is invalid)

	if ((szTitle == NULL) || (szMessageFormat == NULL))
	{
		DPL(0, "Title and message format strings cannot be NULL!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (not given a title or message format)

	if ((iNumRelevantTesters < -1) || (iNumRelevantTesters >= this->m_pTest->m_iNumMachines))
	{
		DPL(0, "Test ID %u called function with invalid number of relevant testers (%i is <-1 or >=%i)!",
			3, this->m_pTest->m_dwUniqueID, iNumRelevantTesters,
			this->m_pTest->m_iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if ((paiRelevantTesters != NULL) && (iNumRelevantTesters == -1))
	{
		DPL(0, "Test ID %u called function with array of relevant testers but the all-other-testers special number!",
			1, this->m_pTest->m_dwUniqueID);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)

	if ((iNumRelevantTesters > 0) && (paiRelevantTesters == NULL))
	{
		DPL(0, "Test ID %u called function specifying %i relevant testers but no array!",
			2, this->m_pTest->m_dwUniqueID, iNumRelevantTesters);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (we got an invalid parameter)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	// If there are tokens to replace in the format string. build an array
	// and loop through the variable arguments and put them into that array.

	if (dwNumParms > 0)
	{
		papvParams = (PVOID*) LocalAlloc(LPTR, (dwNumParms * sizeof (PVOID)));
		if (papvParams == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		va_start(currentparam, dwNumParms);
		while(dwCurrentItem < dwNumParms)
		{
			papvParams[dwCurrentItem] = va_arg(currentparam, PVOID);
			dwCurrentItem++;
		} // end while (there are more variable parameter)
		va_end(currentparam);
	} // end if (there are parms)

	TNsprintf_array(&pszMessage, szMessageFormat, dwNumParms, papvParams);




	EnterCriticalSection(&(this->m_pTest->m_csMasterOp));
	fHaveTestMasterOpLock = TRUE;

	// We need to set a request ID (even though we won't actually use it) so that the
	// HandleLostTester code will know to ping our event.
	this->m_pTest->m_dwRequestID = 0xFFFFFFFF;


	if (this->m_pTest->m_hResponseEvent != NULL)
	{
		DPL(0, "Test ID %u's response event already in use?!",
			1, this->m_pTest->m_dwUniqueID);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (we're already syncing)

	this->m_pTest->m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (this->m_pTest->m_hResponseEvent == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't create lost tester event for test ID %u!",
			1, this->m_pTest->m_dwUniqueID);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't create event)


	// If there's an array of relevant testers, validate it.
	if (iNumRelevantTesters > 0)
	{
		for(i = 0; i < iNumRelevantTesters; i++)
		{
			// Make sure it's in bounds.
			if ((paiRelevantTesters[i] < 0) ||
				(paiRelevantTesters[i] >= this->m_pTest->m_iNumMachines))
			{
				DPL(0, "Relevant tester at index %i is invalid (%i is <0 or >=%i)!",
					3, i, paiRelevantTesters[i], this->m_pTest->m_iNumMachines);
				hr = ERROR_INVALID_PARAMETER;
				goto DONE;
			} // end if (invalid number)

			// Make sure this tester hasn't already left.
			if (this->m_pTest->m_paTesterSlots[paiRelevantTesters[i]].fGone)
			{
				DPL(0, "Tester number %i is already gone.",
					1, paiRelevantTesters[i]);

				if (piResponse != NULL)
					(*piResponse) = paiRelevantTesters[i];

				hr = TNWR_LOSTTESTER;
				goto DONE;
			} // end if (tester already gone)
		} // end for (each relevant tester)
	} // end if (there should be an array of relevant testers)



	switch (dwDialogType)
	{
		case TNPUDT_OK:
			if ((pvDialogData != NULL) || (dwDialogDataSize != 0))
			{
				DPL(0, "Cannot specify dialog data (%x != NULL or %u != 0) for TNPUDT_OK dialogs!",
					2, pvDialogData, dwDialogDataSize);
				hr = ERROR_INVALID_PARAMETER;
				goto DONE;
			} // end if (dialog data was specified)


			hPromptWnd = CreateDialog(s_hInstance, MAKEINTRESOURCE(IDD_PROMPT_OK),
									NULL, PromptAllDlgProc);
			if (hPromptWnd == NULL)
			{
				hr = GetLastError();

				DPL(0, "Couldn't load OK prompt dialog!  %e", 1, hr);

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't create dialog)
		  break;

		case TNPUDT_YESNO:
			if ((pvDialogData != NULL) || (dwDialogDataSize != 0))
			{
				DPL(0, "Cannot specify dialog data (%x != NULL or %u != 0) for TNPUDT_YESNO dialogs!",
					2, pvDialogData, dwDialogDataSize);
				hr = ERROR_INVALID_PARAMETER;
				goto DONE;
			} // end if (dialog data was specified)


			hPromptWnd = CreateDialog(s_hInstance, MAKEINTRESOURCE(IDD_PROMPT_YESNO),
									NULL, PromptAllDlgProc);
			if (hPromptWnd == NULL)
			{
				hr = GetLastError();

				DPL(0, "Couldn't load YesNo prompt dialog!  %e", 1, hr);

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't create dialog)
		  break;

		case TNPUDT_SELECTCOMBO:
			if ((pvDialogData == NULL) || (dwDialogDataSize < sizeof (char*)))
			{
				DPL(0, "Must specify at least one char* for dialog data (%x == NULL or %u < %u) for TNPUDT_OK dialogs!",
					3, pvDialogData, dwDialogDataSize, sizeof (char*));
				hr = ERROR_INVALID_PARAMETER;
				goto DONE;
			} // end if (dialog data wasn't specified)


			hPromptWnd = CreateDialog(s_hInstance, MAKEINTRESOURCE(IDD_PROMPT_SELECTCOMBO),
									NULL, PromptAllDlgProc);
			if (hPromptWnd == NULL)
			{
				hr = GetLastError();

				DPL(0, "Couldn't load Select Combo prompt dialog!  %e", 1, hr);

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't create dialog)

			ComboBox_AddString(GetDlgItem(hPromptWnd, IDCB_PROMPT),
							"Please select an item:");

			for(dwTemp = 0; dwTemp < (dwDialogDataSize / sizeof (char*)); dwTemp++)
			{
				ComboBox_AddString(GetDlgItem(hPromptWnd, IDCB_PROMPT),
								((char**) pvDialogData)[dwTemp]);
			} // end for (each entry)

			// Set the selection to be the "Please select" entry.
			ComboBox_SetCurSel(GetDlgItem(hPromptWnd, IDCB_PROMPT), 0);
		  break;

		default:
			DPL(0, "Unrecognized dialog type %u!", 1, dwDialogType);
			hr = E_NOTIMPL;
			goto DONE;
		  break;
	} // end switch (on dialog type)

	if (hPromptWnd == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't create user prompt window (type %u)!  %e",
			2, dwDialogType, hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't create window)


	SetWindowText(hPromptWnd, szTitle);
	SetWindowText(GetDlgItem(hPromptWnd, IDT_MESSAGE), pszMessage);

	ShowWindow(hPromptWnd, SW_SHOW);

	// Make sure all the messages in the queue are processed.
	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end while (there are messages)

	

	ahWaitObjects[dwNumWaitObjects++] = this->m_pTest->m_hResponseEvent;
	if (this->m_pRealExecutor->m_hUserCancelEvent != NULL)
	{
		ahWaitObjects[dwNumWaitObjects++] = this->m_pRealExecutor->m_hUserCancelEvent;
	} // end if (there's a user cancel event)

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this causes kernel to rewalk array



REWAIT:
	// Make sure the test thread still looks alive.
	this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();


	// Since our window needs a message pump, we want to check the Windows message
	// queue and process any messages.  If it's the message saying the window is
	// now closed, we can bail.
	// We use a while loop to make sure all messages get processed in a timely
	// fashion.
	while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		// This is our indication that EndDialog is about to be called.
		if (msg.message == WM_MYCLOSEDIALOG)
		{
			switch (dwDialogType)
			{
				case TNPUDT_SELECTCOMBO:
					// The item returned is the index into the array
					// of selections.  Since the first one is bogus,
					// skip it.

					DPL(1, "User selected item %i, \"%s\".",
						2, msg.wParam - 1,
						((char**) pvDialogData)[msg.wParam - 1]);

					if (piResponse != NULL)
						(*piResponse) = (int) msg.wParam - 1;
				  break;

				default:
					if (piResponse != NULL)
						(*piResponse) = (int) msg.wParam;
				  break;
			} // end switch (on the dialog type)

			// We'll continue processing the message, but it should
			// result in msg.message becoming zero, so we drop out
			// below.
		} // end if (end of dialog)

		TranslateMessage(&msg);
		DispatchMessage(&msg);

		// This means we're done.
		if (msg.message == 0)
		{
			hr = S_OK;
			goto DONE;
		} // end if (end of dialog)
	} // end while (there are Windows messages)


	// Now we wait for a short time (quarter second) to see if a tester was lost,
	// the user cancelled, or an I/O completion occurred.
	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								250, TRUE);
	switch (hr)
	{
		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			// Check the Windows message queue and go back to waiting.
			goto REWAIT;
		  break;

		case WAIT_FAILED:
			hr = GetLastError();

			DPL(0, "Wait failed!  %e", 1, hr);

			if (hr == S_OK)
				hr = E_FAIL;

			goto DONE;
		  break;

		case WAIT_OBJECT_0:
			if (this->m_pTest->m_hrResponseResult != TNERR_LOSTTESTER)
			{
				hr = this->m_pTest->m_hrResponseResult;

				DPL(0, "Got unexpected LostTester event firing!  %e",
					1, hr);

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (not a lost tester error)


			// See which tester was lost (and if we care about him).
			if (iNumRelevantTesters == -1)
			{
				for(i = 0; i < this->m_pTest->m_iNumMachines; i++)
				{
					if (this->m_pTest->m_paTesterSlots[i].fGone)
					{
						DPL(0, "Lost tester %i during PromptUser in test ID %u!",
							2, i, this->m_pTest->m_dwUniqueID);

						// Note the tester who was lost if the user wants it.
						if (piResponse != NULL)
							(*piResponse) = i;

						hr = TNWR_LOSTTESTER;
						goto DONE;
					} // end if (found a tester who's gone)
				} // end for (each tester)
			} // end if (we care about all of the other testers)

			for(i = 0; i < iNumRelevantTesters; i++)
			{
				if (this->m_pTest->m_paTesterSlots[paiRelevantTesters[i]].fGone)
				{
					DPL(0, "Lost tester %i (array entry %i) during PromptUser in test ID %u!",
						3, paiRelevantTesters[i], i,
						this->m_pTest->m_dwUniqueID);

					// Note the tester who was lost if the user wants it.
					if (piResponse != NULL)
						(*piResponse) = paiRelevantTesters[i];

					hr = TNWR_LOSTTESTER;
					goto DONE;
				} // end if (syncing with dead guy)
			} // end for (each relevant tester)

			// If we got here, it means doesn't care about that guy.
			goto REWAIT;
		  break;

		case WAIT_OBJECT_0 + 1:
			// If we waited on a user cancel event, then it would be seen as
			// WAIT_OBJECT_0 + 1 if it got triggered.
			DPL(3, "User cancelled test ID %u during PromptUser.",
				1, this->m_pTest->m_dwUniqueID);

			hr = TNWR_USERCANCEL;
			goto DONE;
		  break;

		default:
			DPL(0, "Test ID %u got unexpected return from WaitForMultipleObjectsEx!  %e",
				2, this->m_pTest->m_dwUniqueID, hr);
			hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on wait result)


DONE:

	if (fHaveTestMasterOpLock)
	{
		this->m_pTest->m_dwRequestID = 0;
		this->m_pTest->m_hrResponseResult = E_FAIL;

		if (this->m_pTest->m_hResponseEvent != NULL)
		{
			CloseHandle(this->m_pTest->m_hResponseEvent);
			this->m_pTest->m_hResponseEvent = NULL;
		} // end if (we have response event)

		fHaveTestMasterOpLock = FALSE;
		LeaveCriticalSection(&(this->m_pTest->m_csMasterOp));
	} // end if (have test master op lock)

	if (pszMessage != NULL)
		TNsprintf_free(&pszMessage);

	if (papvParams != NULL)
	{
		LocalFree(papvParams);
		papvParams = NULL;
	} // end if (have item array)

	return (hr);
} // CTNExecutor::PromptUser
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::GetMachineInfoForTester()"
//==================================================================================
// CTNExecutor::GetMachineInfoForTester
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the given tester's CTNMachineInfo object
//				NOTE: You must release your reference to the object returned with a
//				call to ReleaseMachineInfoForTester.
//
// Arguments:
//	int iTesterNum			Tester number whose info should be retrieved.
//	PTNMACHINEINFO* ppInfo	Place to store pointer to info of tester.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::GetMachineInfoForTester(int iTesterNum, PTNMACHINEINFO* ppInfo)
{
	HRESULT		hr = S_OK;


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)

	DPL(9, "==>(%i, %x)", 2, iTesterNum, ppInfo);

	if (ppInfo == NULL)
	{
		DPL(0, "Must pass a non-NULL place to store info pointer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (bad destination pointer)

	if ((iTesterNum < 0) || (iTesterNum > this->m_pTest->m_iNumMachines))
	{
		DPL(0, "Didn't specify a valid tester number (%i is <0 or >%i)!",
			2, iTesterNum, this->m_pTest->m_iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (invalid tester number)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	if (iTesterNum == this->m_pTest->GetSlavesTesterNum(&(this->m_pRealExecutor->m_id)))
	{
		DPL(0, "WARNING: Getting information for this machine (tester %i)!",
			1, iTesterNum);

		// The user is making a function call, so the test thread is still alive.
		this->m_pRealExecutor->m_dwLastTestthreadPing = GetTickCount();

		(*ppInfo) = &(this->m_pRealExecutor->m_info);
		goto DONE;
	} // end if (getting own info)


	// We're not getting our own info, so we have to look it up.
	hr = this->m_pRealExecutor->GetTestersMachineInfoInternal(this->m_pTest,
															iTesterNum,
															ppInfo);


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutor::GetMachineInfoForTester
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::ReleaseMachineInfoForTester()"
//==================================================================================
// CTNExecutor::ReleaseMachineInfoForTester
//----------------------------------------------------------------------------------
//
// Description: Releases a machine info object after previously retrieving it with
//				GetMachineInfoForTester.
//
// Arguments:
//	PTNMACHINEINFO* ppInfo	Pointer to info object pointer.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::ReleaseMachineInfoForTester(PTNMACHINEINFO* ppInfo)
{
	HRESULT					hr = S_OK;
	PTNOTHERMACHINEINFO		pOtherInfo = NULL;


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	DPL(9, "==>(%x)", 1, ppInfo);

	if (ppInfo == NULL)
	{
		DPL(0, "Must pass a non-NULL pointer to info pointer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (bad pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in documentation mode)


	pOtherInfo = (PTNOTHERMACHINEINFO) (*ppInfo);
	(*ppInfo) = NULL;


	pOtherInfo->m_dwRefCount--;
	if (pOtherInfo->m_dwRefCount == 0)
	{
		DPL(7, "Deleting other info object %x.",
			1, pOtherInfo);
		delete (pOtherInfo);
	} // end if (last reference)
	else
	{
		DPL(7, "Not deleting other info object %x, its refcount is %u.",
			2, pOtherInfo, pOtherInfo->m_dwRefCount);
	} // end if (last reference)
	pOtherInfo = NULL;


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNExecutor::ReleaseMachineInfoForTester
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::NoteBeginTestCase()"
//==================================================================================
// CTNExecutor::NoteBeginTestCase
//----------------------------------------------------------------------------------
//
// Description: Notes the beginning of a test case.
//
// Arguments:
//	char* szDebugModule				Debug information module (for debug printing).
//	char* szDebugSection			Debug information section (for debug printing).
//	char* szBeginTestCaseFilepath	Path to source file where beginning of test
//									case code resides.
//	int iBeginTestCaseLineNum		Line number indicating beginning of test case.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::NoteBeginTestCase(char* szDebugModule,
										char* szDebugSection,
										char* szBeginTestCaseFilepath,
										int iBeginTestCaseLineNum)
{
	char	szTemp[1024];


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)



#ifndef _XBOX // removed unnecessary logging
	wsprintf(szTemp, "Entering test case \"%s\" (ID %u).",
			this->m_pTest->m_pCase->m_pszID, this->m_pTest->m_dwUniqueID);

	// This is an expansion of the DNB macro.
	TNInternalDebugNoteBlock(szDebugModule, szDebugSection, szBeginTestCaseFilepath,
							iBeginTestCaseLineNum, szTemp);
#endif // ! XBOX


	// If we're not doing any ErrToSrc stuff, skip the rest.
	if (this->m_pRealExecutor->m_hErrToSrcFile == INVALID_HANDLE_VALUE)
		return (S_OK);


#ifdef DEBUG
	if (this->m_pszTestSectionName != NULL)
	{
		DPL(0, "Test section name already exists (\"%s\")!?  DEBUGBREAK()-ing.",
			1, this->m_pszTestSectionName);
		DEBUGBREAK();
	} // end if (have string)

	if (this->m_pszTestSectionFilepath != NULL)
	{
		DPL(0, "Test section filepath already exists (\"%s\")!?  DEBUGBREAK()-ing.",
			1, this->m_pszTestSectionFilepath);
		DEBUGBREAK();
	} // end if (have string)
#endif // DEBUG


	this->m_pszTestSectionName = (char*) LocalAlloc(LPTR, strlen(szTemp) + 1);
	if (this->m_pszTestSectionName == NULL)
	{
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate memory)
	strcpy(this->m_pszTestSectionName, szTemp);

	this->m_pszTestSectionFilepath = (char*) LocalAlloc(LPTR, strlen(szBeginTestCaseFilepath) + 1);
	if (this->m_pszTestSectionFilepath == NULL)
	{
		LocalFree(this->m_pszTestSectionName);
		this->m_pszTestSectionName = NULL;
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate memory)
	strcpy(this->m_pszTestSectionFilepath, szBeginTestCaseFilepath);

	this->m_iTestSectionLineNum = iBeginTestCaseLineNum;


	return (S_OK);
} // CTNExecutor::NoteBeginTestCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::NoteNewTestSection()"
//==================================================================================
// CTNExecutor::NoteNewTestSection
//----------------------------------------------------------------------------------
//
// Description: Notes the beginning of a new test section.
//
// Arguments:
//	char* szTestSectionName		Name/description of test section.
//	char* szDebugModule			Debug information module (for debug printing).
//	char* szDebugSection		Debug information section (for debug printing).
//	char* szTestSectionFilepath	Path to source file where section test code resides.
//	int iTestSectionLineNum		Line number indicating section test code.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::NoteNewTestSection(char* szTestSectionName,
										char* szDebugModule,
										char* szDebugSection,
										char* szTestSectionFilepath,
										int iTestSectionLineNum)
{
	unsigned int	uiSize;


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


#ifndef _XBOX // removed unnecessary logging
	// This is an expansion of the DPL macro.
	TNInternalDebugPrepLog(szDebugModule, szDebugSection);
	TNInternalDebugPrintLine(1, szTestSectionName, 0);
#endif // ! XBOX

	// Ignore error
	this->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID, szTestSectionName, 0);


#ifndef _XBOX // removed unnecessary logging
	// This is an expansion of the DNB macro.
	TNInternalDebugNoteBlock(szDebugModule, szDebugSection, szTestSectionFilepath,
							iTestSectionLineNum, szTestSectionName);
#endif // ! XBOX


	// If we're not doing any ErrToSrc stuff, skip the rest.
	if (this->m_pRealExecutor->m_hErrToSrcFile == INVALID_HANDLE_VALUE)
		return (S_OK);


#ifdef DEBUG
	if (this->m_pszTestSectionName == NULL)
	{
		DPL(0, "Test section name doesn't already exist (should have been begin test case)!?  DEBUGBREAK()-ing.", 0);
		DEBUGBREAK();
	} // end if (have string)

	if (this->m_pszTestSectionFilepath == NULL)
	{
		DPL(0, "Test section filepath doesn't already exist (should have been begin test case)!?  DEBUGBREAK()-ing.", 0);
		DEBUGBREAK();
	} // end if (have string)
#endif // DEBUG

	LocalFree(this->m_pszTestSectionName);
	this->m_pszTestSectionName = NULL;

	LocalFree(this->m_pszTestSectionFilepath);
	this->m_pszTestSectionFilepath = NULL;


	this->m_pszTestSectionName = (char*) LocalAlloc(LPTR, strlen(szTestSectionName) + 1);
	if (this->m_pszTestSectionName == NULL)
	{
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate memory)
	strcpy(this->m_pszTestSectionName, szTestSectionName);


	uiSize = strlen(szTestSectionFilepath) + 1;

	// If we're replacing filepaths, make sure we've got room to hold the modified
	// version.
	if (this->m_pRealExecutor->m_pszErrToSrcPathReplace != NULL)
		uiSize += strlen(this->m_pRealExecutor->m_pszErrToSrcPathReplace);


	this->m_pszTestSectionFilepath = (char*) LocalAlloc(LPTR, uiSize);
	if (this->m_pszTestSectionFilepath == NULL)
	{
		LocalFree(this->m_pszTestSectionName);
		this->m_pszTestSectionName = NULL;
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate memory)
	strcpy(this->m_pszTestSectionFilepath, szTestSectionFilepath);

	if (this->m_pRealExecutor->m_pszErrToSrcPathReplace != NULL)
	{
		StringReplaceAll(this->m_pszTestSectionFilepath,
						this->m_pRealExecutor->m_pszErrToSrcPathSearch,
						this->m_pRealExecutor->m_pszErrToSrcPathReplace,
						FALSE,
						0,
						uiSize);
	} // end if (modifying search paths)

	this->m_iTestSectionLineNum = iTestSectionLineNum;


	return (S_OK);
} // CTNExecutor::NoteNewTestSection
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::NoteThrowTestResult()"
//==================================================================================
// CTNExecutor::NoteThrowTestResult
//----------------------------------------------------------------------------------
//
// Description: Notes a test result throw in the ErrToSrc file.
//
// Arguments:
//	char* szThrowTestResultFilepath		Path to source file where throw test result
//										code resides.
//	int iThrowTestResultLineNum			Line number indicating throw test result.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::NoteThrowTestResult(char* szThrowTestResultFilepath,
										int iThrowTestResultLineNum)
{
	unsigned int	uiSize;
	char*			pszModifiedThrowFilePath;


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile != INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a regular build of this module but in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a regular build of this module but in documentation mode!", 0);
		return (E_FAIL);
	} // end if (in documentation mode)


#ifndef _XBOX // no ErrToSrcFile supported
	// If we're not doing any ErrToSrc stuff, there's nothing to do in here.
	if (this->m_pRealExecutor->m_hErrToSrcFile == INVALID_HANDLE_VALUE)
		return (S_OK);

	FileWriteLine(this->m_pRealExecutor->m_hErrToSrcFile, "[ThrowTestResult]");

	if ((this->m_pszTestSectionName != NULL) &&
		(this->m_pszTestSectionFilepath != NULL))
	{
		FileSprintfWriteLine(this->m_pRealExecutor->m_hErrToSrcFile,
							"LastTestSectionName=%s",
							1, this->m_pszTestSectionName);

		FileSprintfWriteLine(this->m_pRealExecutor->m_hErrToSrcFile,
							"LastTestSectionFile=%s",
							1, this->m_pszTestSectionFilepath);

		FileSprintfWriteLine(this->m_pRealExecutor->m_hErrToSrcFile,
							"LastTestSectionLine=%i",
							1, this->m_iTestSectionLineNum);
	} // end if (there's a test section)

	FileSprintfWriteLine(this->m_pRealExecutor->m_hErrToSrcFile,
						"ThrowTestID=%u",
						1, this->m_pTest->m_dwUniqueID);

	FileSprintfWriteLine(this->m_pRealExecutor->m_hErrToSrcFile,
						"ThrowTestCase=%s",
						1, this->m_pTest->m_pCase->m_pszID);

	if (this->m_pRealExecutor->m_pszErrToSrcPathReplace == NULL)
	{
		FileSprintfWriteLine(this->m_pRealExecutor->m_hErrToSrcFile,
							"ThrowFile=%s",
							1, szThrowTestResultFilepath);
	} // end if (replace path)
	else
	{
		uiSize = strlen(szThrowTestResultFilepath) + strlen(this->m_pRealExecutor->m_pszErrToSrcPathReplace) + 1;

		// Make sure we've got room to hold the modified version.
		pszModifiedThrowFilePath = (char*) LocalAlloc(LPTR, uiSize);
		if (pszModifiedThrowFilePath == NULL)
		{
			return (E_OUTOFMEMORY);
		} // end if (couldn't allocate memory)
		strcpy(pszModifiedThrowFilePath, szThrowTestResultFilepath);

		StringReplaceAll(pszModifiedThrowFilePath,
						this->m_pRealExecutor->m_pszErrToSrcPathSearch,
						this->m_pRealExecutor->m_pszErrToSrcPathReplace,
						FALSE,
						0,
						uiSize);

		FileSprintfWriteLine(this->m_pRealExecutor->m_hErrToSrcFile,
							"ThrowFile=%s",
							1, pszModifiedThrowFilePath);

		LocalFree(pszModifiedThrowFilePath);
	} // end if (modifying search paths)

	FileSprintfWriteLine(this->m_pRealExecutor->m_hErrToSrcFile,
						"ThrowLine=%i",
						1, iThrowTestResultLineNum);

	// Double space
	FileWriteLine(this->m_pRealExecutor->m_hErrToSrcFile, "");

	return (S_OK);
#else // ! XBOX
	return (S_OK);
#endif // XBOX
} // CTNExecutor::NoteThrowTestResult
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no documentation builds supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::DocBuildBeginTestCase()"
//==================================================================================
// CTNExecutor::DocBuildBeginTestCase
//----------------------------------------------------------------------------------
//
// Description: Documents the beginning of a test case.
//
// Arguments:
//	char* szBeginTestCaseFilepath	Path to source file where beginning of test
//									case code resides.
//	int iBeginTestCaseLineNum		Line number indicating beginning of test case.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::DocBuildBeginTestCase(char* szBeginTestCaseFilepath,
										int iBeginTestCaseLineNum)
{

	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile == INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a documentation-only build of this module but not in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a documentation-only build of this module but not in documentation mode!", 0);
		return (E_FAIL);
	} // end if (not in documentation mode)
	

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"[%s]", 1, this->m_pTest->m_pCase->m_pszID);

	FileWriteLine(this->m_pRealExecutor->m_hDocFile, "{BeginCase}");

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"Name=%s", 1, this->m_pTest->m_pCase->m_pszName);

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"File=%s", 1, szBeginTestCaseFilepath);

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"Line=%i", 1, iBeginTestCaseLineNum);

	return (S_OK);
} // CTNExecutor::DocBuildBeginTestCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


#ifndef _XBOX // no documentation builds supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::DocBuildEndTestCase()"
//==================================================================================
// CTNExecutor::DocBuildEndTestCase
//----------------------------------------------------------------------------------
//
// Description: Documents the end of a test case.
//
// Arguments:
//	char* szEndTestCaseFilepath		Path to source file where end of test case code
//									resides.
//	int iEndTestCaseLineNum			Line number indicating end of test case.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::DocBuildEndTestCase(char* szEndTestCaseFilepath,
										int iEndTestCaseLineNum)
{
	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile == INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a documentation-only build of this module but not in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a documentation-only build of this module but not in documentation mode!", 0);
		return (E_FAIL);
	} // end if (not in documentation mode)
	

	FileWriteLine(this->m_pRealExecutor->m_hDocFile, "{EndCase}");

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"File=%s", 1, szEndTestCaseFilepath);

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,

						"Line=%i", 1, iEndTestCaseLineNum);

	FileWriteLine(this->m_pRealExecutor->m_hDocFile, ""); // double space

	return (S_OK);
} // CTNExecutor::DocBuildEndTestCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no documentation builds supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::DocBuildNewTestSection()"
//==================================================================================
// CTNExecutor::DocBuildNewTestSection
//----------------------------------------------------------------------------------
//
// Description: Documents the beginning of a new test section.
//
// Arguments:
//	char* szTestSectionName		Name/description of test section.
//	char* szTestSectionFilepath	Path to source file where section test code resides.
//	int iTestSectionLineNum		Line number indicating section test code.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::DocBuildNewTestSection(char* szTestSectionName,
											char* szTestSectionFilepath,
											int iTestSectionLineNum)
{
	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile == INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a documentation-only build of this module but not in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a documentation-only build of this module but not in documentation mode!", 0);
		return (E_FAIL);
	} // end if (not in documentation mode)
	

	FileWriteLine(this->m_pRealExecutor->m_hDocFile, "{TestSection}");

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"Name=%s", 1, szTestSectionName);

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"File=%s", 1, szTestSectionFilepath);

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"Line=%i", 1, iTestSectionLineNum);

	return (S_OK);
} // CTNExecutor::DocBuildNewTestSection
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


#ifndef _XBOX // no documentation builds supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNExecutor::DocBuildTestSectionControl()"
//==================================================================================
// CTNExecutor::DocBuildTestSectionControl
//----------------------------------------------------------------------------------
//
// Description: Documents the beginning of a test section control statement block.
//
// Arguments:
//	char* szControl				Type of control statement.
//	char* pszControlExpression	Expression determining when block is executed, if
//								any.
//	char* szControlFilepath		Path to source file where block's test code resides.
//	int iControlLineNum			Line number indicating block's test code.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNExecutor::DocBuildTestSectionControl(char* szControl,
												char* pszControlExpression,
												char* szControlFilepath,
												int iControlLineNum)
{
	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)


	// Make sure we're in the right mode.
	if (this->m_pRealExecutor->m_hDocFile == INVALID_HANDLE_VALUE)
	{
		DPL(0, "Executing a documentation-only build of this module but not in documentation mode!", 0);
		this->Log(TNLF_CRITICAL,
					"Executing a documentation-only build of this module but not in documentation mode!", 0);
		return (E_FAIL);
	} // end if (not in documentation mode)
	

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"{%s}", 1, szControl);

	if (pszControlExpression != NULL)
	{
		FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
							"Expression=%s", 1, pszControlExpression);
	} // end if (there's an expression)

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"File=%s", 1, szControlFilepath);

	FileSprintfWriteLine(this->m_pRealExecutor->m_hDocFile,
						"Line=%i", 1, iControlLineNum);

	return (S_OK);
} // CTNExecutor::DocBuildTestSectionControl
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"ExecutorTestThreadProc()"
//==================================================================================
// ExecutorTestThreadProc
//----------------------------------------------------------------------------------
//
// Description: Simple wrapper for DoTestThread
//
// Arguments:
//	LPVOID lpvParameter		Thread data.  Cast to a CTNExecutorPriv pointer.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI ExecutorTestThreadProc(LPVOID lpvParameter)
{
	HRESULT				hr;
	PTNEXECUTORPRIV		pThisObj = (PTNEXECUTORPRIV) lpvParameter;


#ifndef _XBOX // no GetCurrentProcessId
	DPL(1, "==> Starting up (this = %x, process = %x, thread = %x/%u).",
		4, pThisObj, GetCurrentProcessId(), GetCurrentThreadId(),
		GetCurrentThreadId());
#endif

	hr = pThisObj->DoTestThread();

#ifndef _XBOX // no GetCurrentProcessId
	DPL(1, "<== Shutting down (this = %x, process = %x, thread = %x/%u).  %e",
		5, pThisObj, GetCurrentProcessId(), GetCurrentThreadId(),
		GetCurrentThreadId(), hr);
#endif

	return (hr);
} // ExecutorTestThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"PromptAllDlgProc()"
//==================================================================================
// PromptAllDlgProc
//----------------------------------------------------------------------------------
//
// Description: Prompt Ok and YesNo dialogs window procedure.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK PromptAllDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HWND	hComboBox;
	int		iSelection;


	switch (uMsg)
	{
		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDOK:
					DPL(3, "User pressed 'OK'.", 0);

					hComboBox = GetDlgItem(hWnd, IDCB_PROMPT);
					if (hComboBox != NULL)
					{
						iSelection = ComboBox_GetCurSel(hComboBox);
						PostMessage(hWnd, WM_MYCLOSEDIALOG, iSelection, 0);
					} // end if (there's a combo box)
					else
					{
						PostMessage(hWnd, WM_MYCLOSEDIALOG, TNPUR_OK, 0);
					} // end else (there's no combo box)
				  break;

				case IDYES:
					DPL(3, "User pressed 'Yes'.", 0);

					PostMessage(hWnd, WM_MYCLOSEDIALOG, TNPUR_YES, 0);
				  break;

				case IDNO:
					DPL(3, "User pressed 'No'.", 0);

					PostMessage(hWnd, WM_MYCLOSEDIALOG, TNPUR_NO, 0);
				  break;

				case IDCB_PROMPT:
					//BUGBUG figure out what this is
					if (HIWORD(wParam) == 9)
					{
						// Find out what just got selected.
						hComboBox = GetDlgItem(hWnd, LOWORD(wParam));
						iSelection = ComboBox_GetCurSel(hComboBox);

						// If the "Please select..." string was selected, then
						// the user should not be able to select OK.
						EnableWindow(GetDlgItem(hWnd, IDOK),
									((iSelection > 0) ? TRUE : FALSE));
					} // end if (?)
				  break;
			} // end switch (on the button pressed/control changed)
		  break;

		case WM_MYCLOSEDIALOG:
			EndDialog(hWnd, 0);
		  break;
	} // end switch (on the type of window message)

	return (0);
} // PromptYesNoDlgProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\faultsimimtest.h ===
#ifndef __TNCONTROL_FAULTSIMIMTEST__
#define __TNCONTROL_FAULTSIMIMTEST__
//#pragma message("Defining __TNCONTROL_FAULTSIMIMTEST__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG




//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNFaultSimIMTest:public CTNFaultSim
{
	// These are friends so that they can access the protected members
	friend CTNExecutor;
	friend CTNMachineInfo;


	protected:
		CTNFaultSimIMTest(void);
		virtual ~CTNFaultSimIMTest(void);


		// These are implementations of virtual functions.
		HRESULT Initialize(LPVOID lpvInitData, DWORD dwInitDataSize);
		HRESULT Release(void);

		// This is an implementation of a pure virtual function.
		BOOL IsInstalledAndCanBeRun(void);

		HRESULT SetBandwidth(BOOL fSend, DWORD dwHundredBytesPerSec);
		HRESULT SetLatency(BOOL fSend, DWORD dwMSDelay);
		HRESULT SetDropPacketsPercent(BOOL fSend, DWORD dwPercent);
		/*
		HRESULT SetDropPacketsPattern(BOOL fSend, char* szPatternString);
		HRESULT CorruptPackets(BOOL fSend, ?);
		HRESULT ReorderPackets(BOOL fSend, ?);
		*/

		HRESULT Reconnect(BOOL fSend);
		HRESULT Disconnect(BOOL fSend);
};







#else //__TNCONTROL_FAULTSIMIMTEST__
//#pragma message("__TNCONTROL_FAULTSIMIMTEST__ already included!")
#endif //__TNCONTROL_FAULTSIMIMTEST__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\info.h ===
#ifndef __TNCONTROL_INFO__
#define __TNCONTROL_INFO__
//#pragma message("Defining __TNCONTROL_INFO__")





//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNMachineInfo:public LLITEM
{
	// These are friends so they can access the protected members.
	friend CTNExecutor;
	friend CTNExecutorPriv;
	friend CTNSlave;
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX

#ifndef _XBOX // no IPC supported
	friend CTNLeech;
#endif // ! XBOX


	private:
		HRESULT LoadLocalWinSockInfo(void);
		HRESULT LoadLocalRASInfo(void);
		HRESULT LoadLocalTAPIInfo(char* szTestnetRootPath);
		HRESULT LoadLocalCOMPortInfo(char* szTestnetRootPath);
		HRESULT LoadLocalSoundCardInfo(void);
		HRESULT GetFaultSimCapabilities(void);


	protected:
		HRESULT PackIntoBuffer(PVOID pvBuffer, DWORD* pdwSize);
		HRESULT UnpackFromBuffer(PVOID pvBuffer, DWORD dwSize);


	public:
		// These fields propogate to other machines (get sent over the wire).  They
		// are also filled in by the control layer on startup.

		char					m_szComputerName[MAX_COMPUTERNAME_SIZE + 32]; // name of computer, + room for uniqueness identifier
		char					m_szUserName[MAX_USERNAME_SIZE]; // currently logged in user of machine
#ifndef _XBOX
		OSVERSIONINFO			m_os; // version of operation system
#else
		OSVERSIONINFOA			m_os; // version of operation system
#endif
		WORD					m_wProcessorArchitecture; // type of processor(s) this system has
		DWORD					m_dwNumberOfProcessors; // number of processors this system has
		MEMORYSTATUS			m_memstats; // memory statistics
		WORD					m_wWinSock; // WinSock version
		BOOL					m_fIPXInstalled; // whether IPX is installed
		BOOL					m_fFaultSimIMTestAvailable; // whether the IMTest fault simulator is available
		CTNIPAddressesList		m_ipaddrs; // ip addresses this machine is using
		CTNTAPIDevicesList		m_TAPIdevices; // list of TAPI devices this machine has
		CTNCOMPortsList			m_COMports; // list ofCOM ports and their connections
		CTNSoundCardsList		m_soundcards; // list of sound cards
		CTNTrackedBinaries		m_binaries; // important binaries the module wants to note

		// Pointer to user defined data.  This is local, i.e. changes are not
		// propogated between master and slave.  It is initialized to NULL by the
		// control layer.
		PVOID					m_pvUserData;



		CTNMachineInfo(void);
		virtual ~CTNMachineInfo(void);


		BOOL IsNTBasedOS(void);
		BOOL IsMillenniumOS(void);
		HRESULT GetOSString(char* szString);

		HRESULT LoadLocalMachineInfo(char* szTestnetRootPath,
									PTNADDIMPORTANTBINARIESPROC pfnAddImportantBinaries,
									int iComputerNameUniqueness);

};


class DLLEXPORT CTNOtherMachineInfo:public CTNMachineInfo
{
	// These are friends so they can access the protected members.
	friend CTNSlave;
	friend CTNOtherMachineInfosList;
	friend CTNExecutor;
	friend CTNTestInstanceS;

#ifndef _XBOX // no IPC supported
	friend CTNLeech;
#endif // ! XBOX


	protected:
		TNCTRLMACHINEID		m_id; // ID of this machine


		CTNOtherMachineInfo(PTNCTRLMACHINEID pID);
		virtual ~CTNOtherMachineInfo(void);
};

class DLLEXPORT CTNOtherMachineInfosList:public LLIST
{
	// These are friends so they can access the protected members.
	friend CTNSlave;


	protected:
		PTNOTHERMACHINEINFO GetInfoForMachine(PTNCTRLMACHINEID pID);
};




#else //__TNCONTROL_INFO__
//#pragma message("__TNCONTROL_INFO__ already included!")
#endif //__TNCONTROL_INFO__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\ipaddrs.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#ifndef _XBOX
#include <winsock.h>
#else // ! XBOX
#include <winsockx.h>		// Needed for XnetInitialize
#endif // XBOX

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
//#include "..\tncommon\linkedstr.h"
//#include "..\tncommon\strutils.h"

#include "tncontrl.h"
#include "main.h"

#include "ipaddrs.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddress::CTNIPAddress()"
//==================================================================================
// CTNIPAddress constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNIPAddress object.  Initializes the data structures.
//
// Arguments:
//	IN_ADDR* lpinaddr	Pointer to address to use for this object.
//	DWORD dwType		Type of address this is.
//
// Returns: None (just the object).
//
//  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
//
//==================================================================================
CTNIPAddress::CTNIPAddress(IN_ADDR* lpinaddr, DWORD dwType):
	m_ip(*(UNALIGNED IN_ADDR*)lpinaddr),
	m_dwType(dwType)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNIPAddress));
} // CTNIPAddress::CTNIPAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddress::~CTNIPAddress()"
//==================================================================================
// CTNIPAddress destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNIPAddress object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNIPAddress::~CTNIPAddress(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNIPAddress::~CTNIPAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddressesList::CTNIPAddressesList()"
//==================================================================================
// CTNIPAddressesList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNIPAddressesList object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNIPAddressesList::CTNIPAddressesList(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNIPAddressesList));
} // CTNIPAddressesList::CTNIPAddressesList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddressesList::~CTNIPAddressesList()"
//==================================================================================
// CTNIPAddressesList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNIPAddressesList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNIPAddressesList::~CTNIPAddressesList(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNIPAddressesList::~CTNIPAddressesList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddressesList::GetIPString()"
//==================================================================================
// CTNIPAddressesList::GetIPString
//----------------------------------------------------------------------------------
//
// Description: Retrieves the string representation of the IP address at the
//				specified index.
//
// Arguments:
//	int iIndex		Index of IP address to retrieve.
//	char* szString	String to store result in.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPAddressesList::GetIPString(int iIndex, char* szString)
{
	PTNIPADDRESS	pAddress = NULL;


	pAddress = (PTNIPADDRESS) this->GetItem(iIndex);
	if (pAddress == NULL)
	{
		DPL(0, "Couldn't get item %i!", iIndex);
		return (E_FAIL);
	} // end if (couldn't get item)
	
	strcpy(szString, inet_ntoa(pAddress->m_ip));

	return (S_OK);
} // CTNIPAddressesList::GetIPString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddressesList::AddIP()"
//==================================================================================
// CTNIPAddressesList::AddIP
//----------------------------------------------------------------------------------
//
// Description: Adds the specified IP address with the given type to the list.
//
// Arguments:
//	IN_ADDR* pinaddr	Pointer to IP address to add.
//	DWORD dwType		What type of IP address this is (TNIPADDR_xxx).
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNIPAddressesList::AddIP(IN_ADDR* pinaddr, DWORD dwType)
{
	HRESULT			hr;
	PTNIPADDRESS	pAddress = NULL;


	pAddress = new (CTNIPAddress)(pinaddr, dwType);
	if (pAddress == NULL)
	{
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate object)

	hr = this->Add(pAddress);
	if (pAddress == NULL)
	{
		DPL(0, "Couldn't add address to list!", 0);
	} // end if (couldn't add item)
	
	return (hr);
} // CTNIPAddressesList::AddIP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddressesList::LoadLocalIPs()"
//==================================================================================
// CTNIPAddressesList::LoadLocalIPs
//----------------------------------------------------------------------------------
//
// Description: Fills this list with all of this machines IP addresses.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPAddressesList::LoadLocalIPs(void)
{
	HRESULT			hr;
	char			szLocalHostName[256];
	PHOSTENT		phostent = NULL;
	int				i = 0;


	ZeroMemory(szLocalHostName, 256 * sizeof (char));
	if (gethostname(szLocalHostName, 256) != 0) 
	{
		DPL(0, "Could not get local machine's name!", 0);
		return (WSAGetLastError());
	} // end if (failed to get host name)
	
	phostent = gethostbyname(szLocalHostName);
	if (phostent == NULL)
	{
		DPL(0, "Could not get host info for name %s!  No net card?",
			1, szLocalHostName);
		return (WSAGetLastError());
	} // end if (failed to get host info from name)

	while (phostent->h_addr_list[i] != NULL)
	{
		/*
		if ((phostent->h_addrtype != IN_ADDR) ||
			(phostent->h_length != sizeof (IN_ADDR)))
		*/
		if (phostent->h_length != sizeof (IN_ADDR))
		{
			DPL(0, "Address does not appear to be an IN_ADDR!", 0);
			return (E_FAIL);
		} // end if (address not an IN_ADDR)

		hr = this->AddIP(((IN_ADDR*) (phostent->h_addr_list[i])), TNIPADDR_LOCAL);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add new address!", 0);
			return (hr);
		} // end if (address not an IN_ADDR)

		i++;
	} // end while (there's another address)
	
	return (S_OK);
} // CTNIPAddressesList::LoadLocalIPs
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddressesList::PackIntoBuffer()"
//==================================================================================
// CTNIPAddressesList::PackIntoBuffer
//----------------------------------------------------------------------------------
//
// Description: Flattens this list into a contiguous buffer for easy transmission.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required, and ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to fill in with
//							buffer size required.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNIPAddressesList::PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize)
{
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				i;
	PTNIPADDRESS	pAddress = NULL;



	(*pdwBufferSize) = 0;


	this->EnterCritSection();

	i = this->Count();

	if (i <= 0)
	{
		this->LeaveCritSection();
		return (S_OK);
	} // end if (there aren't any items in this list)


	// Make sure the unpacker knows how many addresses we have

	(*pdwBufferSize) += sizeof (int) // number of items in the list
						+ (i * (sizeof (IN_ADDR) + sizeof (DWORD))); // all the items


	if (pvBuffer == NULL)
	{
		this->LeaveCritSection();
		return (ERROR_BUFFER_TOO_SMALL);
	} // end if (just retrieving size)


	// Copy the number of items in.
	CopyAndMoveDestPointer(lpCurrent, &i, sizeof (int))

	for(i = 0; i < this->Count(); i++)
	{
		pAddress = (PTNIPADDRESS) this->GetItem(i);
		if (pAddress == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get IP address %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)

		CopyAndMoveDestPointer(lpCurrent, &(pAddress->m_ip), sizeof (IN_ADDR));
		CopyAndMoveDestPointer(lpCurrent, &(pAddress->m_dwType), sizeof (DWORD));

	} // end for (each address)
	this->LeaveCritSection();


	return (S_OK);
} // CTNIPAddressesList::PackIntoBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddressesList::UnpackFromBuffer()"
//==================================================================================
// CTNIPAddressesList::UnpackFromBuffer
//----------------------------------------------------------------------------------
//
// Description: Populates this list with the contents previously stored in a
//				contiguous buffer.
//
// Arguments:
//	PVOID pvBuffer		Pointer to buffer to use.
//	DWORD dwBufferSize	Size of buffer.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNIPAddressesList::UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize)
{
	HRESULT			hr;
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				iNumItems = 0;
	int				i;
	PTNIPADDRESS	pAddress = NULL;



	this->EnterCritSection();

	CopyAndMoveSrcPointer(&iNumItems, lpCurrent, sizeof (int));

	for(i = 0; i < iNumItems; i++)
	{
        //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		pAddress = new (CTNIPAddress)(((IN_ADDR*) lpCurrent),
										*((UNALIGNED DWORD*) (lpCurrent + sizeof (IN_ADDR))));
		if (pAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		// Move pointer to next item
		lpCurrent += sizeof (IN_ADDR) + sizeof (DWORD);			


		hr = this->Add(pAddress);
		if (hr != S_OK)
		{
			DPL(0, "Adding address %i failed!", 1, i);
			goto DONE;
		} // end if (couldn't add item)

		pAddress = NULL; // forget about it so we don't free it below
	} // end for (each binary location list)


DONE:

	this->LeaveCritSection();

	if (pAddress != NULL)
	{
		delete (pAddress);
		pAddress = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNIPAddressesList::UnpackFromBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPAddressesList::DoesIPExist()"
//==================================================================================
// CTNIPAddressesList::DoesIPExist
//----------------------------------------------------------------------------------
//
// Description: Searches the list for the given IN_ADDR, and returns TRUE if found,
//				FALSE otherwise.
//
// Arguments:
//	IN_ADDR* pinaddr	Pointer to IN_ADDR to look up.
//
// Returns: TRUE if found, FALSE otherwise.
//==================================================================================
BOOL CTNIPAddressesList::DoesIPExist(IN_ADDR* pinaddr)
{
	PTNIPADDRESS	pAddress = NULL;


	this->EnterCritSection();

	while (TRUE)
	{
		pAddress = (PTNIPADDRESS) this->GetNextItem(pAddress);
		if (pAddress == NULL)
			break;

		if (memcmp(&(pAddress->m_ip), pinaddr, sizeof (IN_ADDR)) == 0)
		{
			this->LeaveCritSection();
			return (TRUE);
		} // end if (found the IP address)

	} // end while (still have more items to look at)

	this->LeaveCritSection();
	
	// If we're here, it means we didn't find the address

	return (FALSE);
} // CTNIPAddressesList::DoesIPExist
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\ipcobj.cpp ===
#ifndef _XBOX // no IPC supported
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>


#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\sprintf.h"

#include "tncontrl.h"
#include "main.h"

#include "ipcobj.h"




//==================================================================================
// Defines
//==================================================================================
#define PREFIX_MMMUTEX					"IPCObj MemoryMappingMutex"
#define PREFIX_MMFILE					"IPCObj MemoryMappedFile"
#define PREFIX_MSGFOROWNEREVENT			"IPCObj MsgForOwnerEvent"
#define PREFIX_MSGFROMOWNEREVENT		"IPCObj MsgFromOwnerEvent"
#define PREFIX_MSGACKEVENT				"IPCObj MsgAckEvent"
#define PREFIX_REDIR_MUTEX				"IPCObj RedirMutex"
#define PREFIX_REDIR_MMMUTEX			"IPCObj RedirMemoryMappingMutex"
#define PREFIX_REDIR_MMFILE				"IPCObj RedirMemoryMappedFile"


#define MAX_REDIR_DATA_SIZE				(1024)






//==================================================================================
// Structures
//==================================================================================
typedef struct tagIPCOBJMMFILEHEADER
{
	DWORD		dwRefCount; // number of users using this memory mapped file
	DWORD		dwAPIVersion; // version of control layer this was created with
	DWORD		dwOwnerProcessID; // the owning process's process ID
	DWORD		dwSeparateProcessID; // the separate process's process ID
	DWORD		dwCommand; // command ID for message in shared memory space
	DWORD		dwSendDataSize; // size of data for message in shared memory space
	DWORD		dwReplyDataSize; // size of data for message in shared memory space
} IPCOBJMMFILEHEADER, * PIPCOBJMMFILEHEADER;

typedef struct tagIPCOBJMMREDIRECTFILEHEADER
{
	DWORD		dwSize; // size of real attach point ID, not including NULL termination
} IPCOBJMMREDIRECTFILEHEADER, * PIPCOBJMMREDIRECTFILEHEADER;




//==================================================================================
// Messages
//==================================================================================
#define IPCMSGID_CONNECT		1
/*
typedef struct tagIPCMSG_CONNECT
{
	DWORD	?; // ?
} IPCMSG_CONNECT, * PIPCMSG_CONNECT;
*/

#define IPCMSGID_DISCONNECT		2
/*
typedef struct tagIPCMSG_DISCONNECT
{
	DWORD	?; // ?
} IPCMSG_DISCONNECT, * PIPCMSG_DISCONNECT;
*/

#define IPCMSGID_PING			3
/*
typedef struct tagIPCMSG_PING
{
	DWORD	?; // ?
} IPCMSG_PING, * PIPCMSG_PING;
*/





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::CTNIPCObject()"
//==================================================================================
// CTNIPCObject constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNIPCObject object.  Initializes the data structures.
//
// Arguments:
//	PTNEXECUTORPRIV pExecutor		Pointer to the owning executor for this object.
//
// Returns: None (just the object).
//==================================================================================
CTNIPCObject::CTNIPCObject(PTNEXECUTORPRIV pExecutor):
	m_pExecutor(pExecutor),
	m_fOwnerCopy(FALSE),
	m_fConnected(FALSE),
	m_dwMMWriteLockRefCount(0),
	m_hMMWriteMutex(NULL),
	m_hMMFile(NULL),
	m_hRedirMutex(NULL),
	m_hRedirMMFile(NULL),
	m_hSendEvent(NULL),
	m_hAckEvent(NULL),
	m_hConnectEvent(NULL),
	m_hObjMsgRecvThread(NULL),
	m_hKillObjMsgRecvThreadEvent(NULL),
	m_pszAttachPointID(NULL),
	m_hReceiveEvent(NULL),
	m_dwLastMessageReceived(0)
{
	DPL(9, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNIPCObject));
} // CTNIPCObject::CTNIPCObject
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::~CTNIPCObject()"
//==================================================================================
// CTNIPCObject destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNIPCObject object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNIPCObject::~CTNIPCObject(void)
{
	HRESULT		hr;


	DPL(9, "==> this = %x", 1, this);

	if (this->m_fConnected)
	{
		hr = this->Disconnect();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't disconnect!  %e", 1, hr);
		} // end if (couldn't disconnect)
	} // end if (we're connected)


	// We must wait for the thread to die before removing anything else because
	// it may still be processing a message.
	hr = this->KillObjMsgRecvThread();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't kill message reception thread!  %e", 1, hr);
	} // end if (couldn't kill message reception thread)

	if (this->m_hMMFile)
	{
		CloseHandle(this->m_hMMFile);
		this->m_hMMFile = NULL;
	} // end if (we have the file)

	while (this->m_dwMMWriteLockRefCount > 0)
	{
		ReleaseMutex(this->m_hMMWriteMutex);
		this->m_dwMMWriteLockRefCount--;
		//DPL(9, "Dropped lock.", 0);
	} // end if (we have the lock)

	if (this->m_hMMWriteMutex)
	{
		CloseHandle(this->m_hMMWriteMutex);
		this->m_hMMWriteMutex = NULL;
	} // end if (we have the mutex)

	if (this->m_hRedirMMFile)
	{
		CloseHandle(this->m_hRedirMMFile);
		this->m_hRedirMMFile = NULL;
	} // end if (we have the file)

	// If we have this, we also therefore own it, so release it and close it.
	if (this->m_hRedirMutex)
	{
		ReleaseMutex(this->m_hRedirMutex);
		CloseHandle(this->m_hRedirMutex);
		this->m_hRedirMutex = NULL;
	} // end if (we have the lock)

	if (this->m_hSendEvent)
	{
		CloseHandle(this->m_hSendEvent);
		this->m_hSendEvent = NULL;
	} // end if (we have the event)

	if (this->m_hAckEvent)
	{
		CloseHandle(this->m_hAckEvent);
		this->m_hAckEvent = NULL;
	} // end if (we have the event)

	if (this->m_hConnectEvent)
	{
		CloseHandle(this->m_hConnectEvent);
		this->m_hConnectEvent = NULL;
	} // end if (we have the event)

	if (this->m_pszAttachPointID != NULL)
	{
		LocalFree(this->m_pszAttachPointID);
		this->m_pszAttachPointID = NULL;
	} // end if (allocated an attach point ID)

	if (this->m_hReceiveEvent)
	{
		CloseHandle(this->m_hReceiveEvent);
		this->m_hReceiveEvent = NULL;
	} // end if (we have the event)

	if (this->m_pvConnectData != NULL)
	{
		LocalFree(this->m_pvConnectData);
		this->m_pvConnectData = NULL;
	} // end if (there's connect data)

	// We don't touch this->m_pExecutor, because our owner or child class will
	// take care of it properly.

	DPL(9, "<== this = %x", 1, this);
} // CTNIPCObject::~CTNIPCObject
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::Connect()"
//==================================================================================
// CTNIPCObject::Connect
//----------------------------------------------------------------------------------
//
// Description: Connects this object using the given module and attach point IDs.
//
// Arguments:
//	BOOL fOwnerCopy					Whether this is the owner version (FALSE to be
//									process side).
//	PTNMODULEID pTNModuleID			ID of module using this object.
//	char* szAttachPointID			Identifier string shared with opposite side,
//									used to prevent collisions.
//	HANDLE hConnectEvent			Optional handle to event to set when the other
//									side connects back (may be right away, if it is
//									already set up).
//	PVOID pvSendConnectData			Optional pointer to data to send to other side.
//	DWORD dwSendConnectDataSize		Size of data to send to other side.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::Connect(BOOL fOwnerCopy, PTNMODULEID pTNModuleID,
							char* szAttachPointID, HANDLE hConnectEvent,
							PVOID pvSendConnectData, DWORD dwSendConnectDataSize)
{
	HRESULT					hr;
	char*					pszBuffer = NULL;
	PIPCOBJMMFILEHEADER		pHeader = NULL;
	HANDLE					ahWaitObjects[3];
	DWORD					dwNumWaitObjects = 0;


	if (this == NULL)
	{
		DPL(0, "This object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (bad object pointer)

	if (this->m_pszAttachPointID != NULL)
	{
		DPL(0, "Object already attached to an owner (using \"%s\")!",
			1, this->m_pszAttachPointID);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (already attached to an owner)

	if (pTNModuleID == NULL)
	{
		DPL(0, "Module ID pointer cannot be NULL!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (bad module ID pointer)

	if ((szAttachPointID == NULL) || (strcmp(szAttachPointID, "") == 0))
	{
		DPL(0, "Attach point ID cannot be NULL or just an empty string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (bad attach point ID)

	this->m_fOwnerCopy = fOwnerCopy;

	// Save the attachpoint ID
	this->m_pszAttachPointID = (char*) LocalAlloc(LPTR, strlen(szAttachPointID) + 1);
	if (this->m_pszAttachPointID == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate attach point ID)
	strcpy(this->m_pszAttachPointID, szAttachPointID);


	if (fOwnerCopy)
	{
		DPL(1, "Connecting to separate process with ID \"%s\", sending %u bytes of connect data at %x.",
			3, this->m_pszAttachPointID, dwSendConnectDataSize,
			pvSendConnectData);
	} // end if (owner side)
	else
	{
		DPL(1, "Connecting to owner with ID \"%s\", sending %u bytes of connect data at %x.",
			3, this->m_pszAttachPointID, dwSendConnectDataSize,
			pvSendConnectData);
	} // end else (process side)

	if (hConnectEvent != NULL)
	{
		if (! DuplicateHandle(GetCurrentProcess(), hConnectEvent,
								GetCurrentProcess(), &(this->m_hConnectEvent),
								0, FALSE, DUPLICATE_SAME_ACCESS))
		{
			hr = GetLastError();
			DPL(0, "Couldn't duplicate connection event handle (%x)!",
				2, hConnectEvent);
			goto ERROR_EXIT;
		} // end if (couldn't duplicate handle)
	} // end if (have connect event)
	

	// Create/open the mutex used to access the shared memory.

	TNsprintf(&pszBuffer, PREFIX_MMMUTEX " (mod %s v%u.%u) %s",
			4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
			pTNModuleID->dwMinorVersion1, this->m_pszAttachPointID);

	// We can't be the initial owner of the mutex because it may have been created
	// already, in which case the TRUE would be ignored.
	this->m_hMMWriteMutex = CreateMutex(NULL, FALSE, pszBuffer);
	if (this->m_hMMWriteMutex == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create mutex %s!", 1, pszBuffer);
		goto ERROR_EXIT;
	} // end if (couldn't create mutex)
	TNsprintf_free(&pszBuffer);


	// Create/open the actual shared memory.

	TNsprintf(&pszBuffer, PREFIX_MMFILE " (mod %s v%u.%u) %s",
			4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
			pTNModuleID->dwMinorVersion1, this->m_pszAttachPointID);

	DPL(8, "Using file mapping \"%s\" to swap memory.", 1, pszBuffer);

	this->m_hMMFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
										0, (sizeof (IPCOBJMMFILEHEADER) + MAX_MESSAGE_SIZE),
										pszBuffer);
	if (this->m_hMMFile == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create file mapping %s!", 1, pszBuffer);
		goto ERROR_EXIT;
	} // end if (couldn't create file mapping)
	TNsprintf_free(&pszBuffer);


	if (fOwnerCopy)
	{
		TNsprintf(&pszBuffer, PREFIX_MSGFROMOWNEREVENT " (mod %s v%u.%u) %s",
				4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
				pTNModuleID->dwMinorVersion1, this->m_pszAttachPointID);

		DPL(9, "Send event = \"%s\"", 1, pszBuffer);

		this->m_hSendEvent = CreateEvent(NULL, FALSE, FALSE, pszBuffer);
		if (this->m_hSendEvent == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create send event %s!", 1, pszBuffer);
			goto ERROR_EXIT;
		} // end if (couldn't create event)
		TNsprintf_free(&pszBuffer);

		TNsprintf(&pszBuffer, PREFIX_MSGFOROWNEREVENT " (mod %s v%u.%u) %s",
				4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
				pTNModuleID->dwMinorVersion1, this->m_pszAttachPointID);

		DPL(9, "Receive event = \"%s\"", 1, pszBuffer);

		this->m_hReceiveEvent = CreateEvent(NULL, FALSE, FALSE, pszBuffer);
		if (this->m_hReceiveEvent == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create receive event %s!", 1, pszBuffer);
			goto ERROR_EXIT;
		} // end if (couldn't create event)
		TNsprintf_free(&pszBuffer);
	} // end if (owner side)
	else
	{
		TNsprintf(&pszBuffer, PREFIX_MSGFOROWNEREVENT " (mod %s v%u.%u) %s",
				4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
				pTNModuleID->dwMinorVersion1, this->m_pszAttachPointID);

		DPL(9, "Send event = \"%s\"", 1, pszBuffer);

		this->m_hSendEvent = CreateEvent(NULL, FALSE, FALSE, pszBuffer);
		if (this->m_hSendEvent == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create send event %s!", 1, pszBuffer);
			goto ERROR_EXIT;
		} // end if (couldn't create event)
		TNsprintf_free(&pszBuffer);

		TNsprintf(&pszBuffer, PREFIX_MSGFROMOWNEREVENT " (mod %s v%u.%u) %s",
				4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
				pTNModuleID->dwMinorVersion1, this->m_pszAttachPointID);

		DPL(9, "Receive event = \"%s\"", 1, pszBuffer);

		this->m_hReceiveEvent = CreateEvent(NULL, FALSE, FALSE, pszBuffer);
		if (this->m_hReceiveEvent == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create receive event %s!", 1, pszBuffer);
			goto ERROR_EXIT;
		} // end if (couldn't create event)
		TNsprintf_free(&pszBuffer);
	} // end else (not owner side)

	TNsprintf(&pszBuffer, PREFIX_MSGACKEVENT " (mod %s v%u.%u) %s",
			4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
			pTNModuleID->dwMinorVersion1, this->m_pszAttachPointID);

	DPL(9, "Ack event = \"%s\"", 1, pszBuffer);

	this->m_hAckEvent = CreateEvent(NULL, FALSE, FALSE, pszBuffer);
	if (this->m_hAckEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create ack event %s!", 1, pszBuffer);
		goto ERROR_EXIT;
	} // end if (couldn't create event)
	TNsprintf_free(&pszBuffer);


	// If we're the process side, we need to start up a thread to receive messages
	// from the owner.  The owner side will have an overall thread for this already.
	if (! fOwnerCopy)
	{
		hr = this->StartObjMsgRecvThread();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't start message reception thread!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't start message reception thread)
	} // end if (not owned by the owner)


	// Grab the mutex.
	ahWaitObjects[dwNumWaitObjects++] = this->m_hMMWriteMutex;

	if (this->m_pExecutor->m_hUserCancelEvent != NULL)
	{
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;
	} // end if (owner side and have user cancel event)

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


REWAIT:

	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								INFINITE, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Got the ready signal, we're cool.

			hr = S_OK;
		  break;

		case WAIT_OBJECT_0 + 1:
			// Got user cancel event

			DPL(0, "User cancelled waiting for mutex to connect!", 0);

			hr = TNWR_USERCANCEL;
			goto ERROR_EXIT;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		default:
			// What?
			DPL(0, "Received unexpected return from WaitForMultipleObjectsEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;

			goto ERROR_EXIT;
		  break;
	} // end switch (on wait result)


	this->m_dwMMWriteLockRefCount++;
	//DPL(9, "Took lock.", 0);


	pHeader = (PIPCOBJMMFILEHEADER) MapViewOfFile(this->m_hMMFile,
													FILE_MAP_ALL_ACCESS,
													0, 0, 0);
	if (pHeader == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't map view of file)


	// If we're the first users, initialize it with our settings.  Otherwise, make
	// sure we can use what's there.
	switch (pHeader->dwRefCount)
	{
		case 0:
			// We're the first user.
			pHeader->dwRefCount++;

			DPL(3, "Other side has not connected yet.", 0);

			pHeader->dwAPIVersion = CURRENT_TNCONTROL_API_VERSION;

			// Put the connect data there so when the other side does connect it
			// can retrieve it.
			pHeader->dwCommand = IPCMSGID_CONNECT;
			if (dwSendConnectDataSize > 0)
			{
				CopyMemory((pHeader + 1), pvSendConnectData, dwSendConnectDataSize);
				pHeader->dwSendDataSize = dwSendConnectDataSize;
			} // end if (there's connect data to store)

			if (fOwnerCopy)
				pHeader->dwOwnerProcessID = GetCurrentProcessId();
			else
				pHeader->dwSeparateProcessID = GetCurrentProcessId();
		  break;

		case 1:
			// We're the second user.
			pHeader->dwRefCount++;

			if (pHeader->dwAPIVersion != CURRENT_TNCONTROL_API_VERSION)
			{
				DPL(0, "WARNING: Other side already using shared memory but it's a different API version (%i != %i), problems may occur.",
					2, pHeader->dwAPIVersion, CURRENT_TNCONTROL_API_VERSION);
			} // end if (versions don't match)

			if (fOwnerCopy)
			{
				if (pHeader->dwOwnerProcessID != 0)
				{
					DPL(0, "Shared memory is already in use by another owning process (%x)!  DEBUGBREAK()-ing.",
						1, pHeader->dwOwnerProcessID);
					DEBUGBREAK();
					pHeader->dwRefCount--; // take off the ref we added
					hr = ERROR_BAD_ENVIRONMENT;
					goto ERROR_EXIT;
				} // end if (the current user is a new process)

				if (pHeader->dwSeparateProcessID == 0)
				{
					DPL(0, "Separate process ID is 0!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					pHeader->dwRefCount--; // take off the ref we added
					hr = ERROR_BAD_ENVIRONMENT;
					goto ERROR_EXIT;
				} // end if (ID not stored)

				DPL(3, "Separate process (process ID = %x) has already established connection.",
					1, pHeader->dwSeparateProcessID);
				
				if (pHeader->dwSeparateProcessID == GetCurrentProcessId())
				{
					DPL(0, "WARNING: Process IDs are the same for both sides of the connection (%x), is this what you intended?",
						1, pHeader->dwSeparateProcessID);
				} // end if (same process)

				pHeader->dwOwnerProcessID = GetCurrentProcessId();
			} // end if (we are owner side)
			else
			{
				if (pHeader->dwSeparateProcessID != 0)
				{
					DPL(0, "Shared memory is already in use by another separate process (%x)!  DEBUGBREAK()-ing.",
						1, pHeader->dwSeparateProcessID);
					DEBUGBREAK();
					pHeader->dwRefCount--; // take off the ref we added
					hr = ERROR_BAD_ENVIRONMENT;
					goto ERROR_EXIT;
				} // end if (the current user is a new process)

				if (pHeader->dwOwnerProcessID == 0)
				{
					DPL(0, "Owner process ID is 0!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					pHeader->dwRefCount--; // take off the ref we added
					hr = ERROR_BAD_ENVIRONMENT;
					goto ERROR_EXIT;
				} // end if (ID not stored)

				DPL(3, "Owner (process ID = %x) has already established connection.",
					1, pHeader->dwOwnerProcessID);
				
				if (pHeader->dwOwnerProcessID == GetCurrentProcessId())
				{
					DPL(0, "WARNING: Process IDs are the same for both sides of the connection (%x), is this what you intended?",
						1, pHeader->dwOwnerProcessID);
				} // end if (same process)

				pHeader->dwSeparateProcessID = GetCurrentProcessId();
			} // end else (we're not owner side)



			// Retrieve any connect data there may have been
			if (pHeader->dwSendDataSize > 0)
			{
				this->m_pvConnectData = LocalAlloc(LPTR, pHeader->dwSendDataSize);
				if (this->m_pvConnectData == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto ERROR_EXIT;
				} // end if (couldn't allocate memory)

				CopyMemory(this->m_pvConnectData, (pHeader + 1),
							pHeader->dwSendDataSize);
				this->m_dwConnectDataSize = pHeader->dwSendDataSize;

				DPL(8, "Got %u byte connect data buffer at %x.",
					2, this->m_dwConnectDataSize, this->m_pvConnectData);
			} // end if (there's connect data)


			// Since the other end should already be there (his refcount is there),
			// we can call ourselves connected.
			this->m_fConnected = TRUE;


			hr = this->SendMessage(IPCMSGID_CONNECT, pvSendConnectData,
									dwSendConnectDataSize,
									IPCOBJ_ACK_WAIT_TIMEOUT);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't send connect message!", 0);
				goto ERROR_EXIT;
			} // end if (couldn't send connect message)



			if (this->m_hConnectEvent != NULL)
			{
				if (! SetEvent(this->m_hConnectEvent))
				{
					hr = GetLastError();
					DPL(0, "Couldn't set connection event (%x)!", 1, this->m_hConnectEvent);
					goto ERROR_EXIT;
				} // end if (couldn't set event)

				// We don't need the event anymore
				CloseHandle(this->m_hConnectEvent);
				this->m_hConnectEvent = NULL;
			} // end if (there's a connect event)
		  break;

		default:
			DPL(0, "Shared memory has an invalid number of users (%u)!",
				1, pHeader->dwRefCount);
			hr = ERROR_BAD_ENVIRONMENT;
			goto ERROR_EXIT;
		  break;
	} // end switch (on the current refcount)

	UnmapViewOfFile(pHeader);
	pHeader = NULL;

	ReleaseMutex(this->m_hMMWriteMutex);
	this->m_dwMMWriteLockRefCount--;
	//DPL(9, "Dropped lock.", 0);

	return (S_OK);


ERROR_EXIT:

	if (pHeader != NULL)
	{
		UnmapViewOfFile(pHeader);
		pHeader = NULL;
	} // end if (mapped view)

	if (this->m_hAckEvent != NULL)
	{
		CloseHandle(this->m_hAckEvent);
		this->m_hAckEvent = NULL;
	} // end if (have event)

	if (this->m_hReceiveEvent != NULL)
	{
		CloseHandle(this->m_hReceiveEvent);
		this->m_hReceiveEvent = NULL;
	} // end if (have event)

	if (this->m_hSendEvent != NULL)
	{
		CloseHandle(this->m_hSendEvent);
		this->m_hSendEvent = NULL;
	} // end if (have event)

	if (this->m_hMMFile)
	{
		CloseHandle(this->m_hMMFile);
		this->m_hMMFile = NULL;
	} // end if (we have the lock)

	if (this->m_dwMMWriteLockRefCount > 0)
	{
		ReleaseMutex(this->m_hMMWriteMutex);
		this->m_dwMMWriteLockRefCount--;
		//DPL(9, "Dropped lock.", 0);
	} // end if (we have the lock)

	this->KillObjMsgRecvThread(); // ignore error

	if (this->m_hMMWriteMutex)
	{
		CloseHandle(this->m_hMMWriteMutex);
		this->m_hMMWriteMutex = NULL;
	} // end if (we have the lock)

	if (this->m_hConnectEvent != NULL)
	{
		CloseHandle(this->m_hConnectEvent);
		this->m_hConnectEvent = NULL;
	} // end if (have event)

	if (this->m_pszAttachPointID != NULL)
	{
		LocalFree(this->m_pszAttachPointID);
		this->m_pszAttachPointID = NULL;
	} // end if (allocated an attach point ID)

	if (pszBuffer != NULL)
		TNsprintf_free(&pszBuffer);

	return (hr);
} // CTNIPCObject::Connect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::Disconnect()"
//==================================================================================
// CTNIPCObject::Disconnect
//----------------------------------------------------------------------------------
//
// Description: Disconnects this object from the other side.  If this is the owner's
//				copy of the object, then the object is notified that he was
//				detached.  If this is the process' copy, then the owner is notified
//				that the object detached.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::Disconnect(void)
{
	HRESULT					hr = S_OK;
	PIPCOBJMMFILEHEADER		pHeader = NULL;
	BOOL					fHaveMMWriteLock = FALSE;



	DPL(9, "==> this = %x", 1, this);

	if (this == NULL)
	{
		DPL(0, "This object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (bad object pointer)

	if (this->m_pszAttachPointID == NULL)
	{
		DPL(0, "WARNING: Object not connected!", 0);
		goto DONE;
	} // end if (don't have attach point)


	DPL(1, "%s disconnecting object %s.",
		2, ((this->m_fOwnerCopy) ? "Host" : "Process"),
		this->m_pszAttachPointID);


	// Notify the other side
	hr = this->SendMessage(IPCMSGID_DISCONNECT, NULL, 0, IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send disconnect message!", 0);
		goto DONE;
	} // end if (couldn't send disconnect message)



	// Grab the mutex, ignoring anything other than IO completion.

	while (WaitForSingleObjectEx(this->m_hMMWriteMutex, INFINITE, TRUE) == WAIT_IO_COMPLETION)
	{
		DPL(1, "I/O Completion.", 0);
	} // end while (there's an I/O completion)

	this->m_dwMMWriteLockRefCount++;
	fHaveMMWriteLock = TRUE;
	//DPL(9, "Took lock.", 0);



	pHeader = (PIPCOBJMMFILEHEADER) MapViewOfFile(this->m_hMMFile,
													FILE_MAP_ALL_ACCESS,
													0, 0, 0);
	if (pHeader == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto DONE;
	} // end if (couldn't map view of file)


	if (this->m_fOwnerCopy)
	{
		pHeader->dwOwnerProcessID = 0;
	} // end if (we are owner side)
	else
	{
		pHeader->dwSeparateProcessID = 0;
	} // end else (we're not owner side)

	pHeader->dwRefCount--;


	UnmapViewOfFile(pHeader);
	pHeader = NULL;

	ReleaseMutex(this->m_hMMWriteMutex);
	fHaveMMWriteLock = FALSE;
	this->m_dwMMWriteLockRefCount--;
	//DPL(9, "Dropped lock.", 0);


	// We must wait for the thread to die before removing anything else because
	// it may still be processing a message.
	hr = this->KillObjMsgRecvThread();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't kill message reception thread!", 0);
		goto DONE;
	} // end if (couldn't kill message reception thread)


	CloseHandle(this->m_hMMFile);
	this->m_hMMFile = NULL;

	CloseHandle(this->m_hMMWriteMutex);
	this->m_hMMWriteMutex = NULL;

	if (this->m_hConnectEvent != NULL)
	{
		CloseHandle(this->m_hConnectEvent);
		this->m_hConnectEvent = NULL;
	} // end if (have event)

	CloseHandle(this->m_hAckEvent);
	this->m_hAckEvent = NULL;

	CloseHandle(this->m_hReceiveEvent);
	this->m_hReceiveEvent = NULL;

	CloseHandle(this->m_hSendEvent);
	this->m_hSendEvent = NULL;

	LocalFree(this->m_pszAttachPointID);
	this->m_pszAttachPointID = NULL;

	this->m_dwLastMessageReceived = 0;


DONE:

	if (pHeader != NULL)
	{
		UnmapViewOfFile(pHeader);
		pHeader = NULL;
	} // end if (mapped view)

	if (fHaveMMWriteLock)
	{
		ReleaseMutex(this->m_hMMWriteMutex);
		this->m_dwMMWriteLockRefCount--;
		fHaveMMWriteLock = FALSE;
		//DPL(9, "Dropped lock.", 0);
	} // end if (we have the lock)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNIPCObject::Disconnect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::AllowStaticIDConnection()"
//==================================================================================
// CTNIPCObject::AllowStaticIDConnection
//----------------------------------------------------------------------------------
//
// Description: Alters connection behavior so that processes can still connect even
//				if they don't know the specific attachment ID to use.  The owner and
//				process must therefore agree beforehand on an string (such as the
//				name of the app) they will use to recognize each other.  This ID is
//				used to retrieve the real attachment ID.
//				Since the ID is not dynamic, only one object can use it at any one
//				time.  Fortunately, you only need the preplanned ID until you can
//				retrieve the dynamic ID.  A mutex is used to suspend other threads
//				trying to using the same ID.
//				Note, this means you may block in this call until the previous
//				object connects.  If the process never connects after you've made
//				this call, the mutex will be owned until this object is destroyed
//				(blocking all other attempts to use the same preplanned ID until
//				that time).
//				This function should only be used when retrieving the dynamic ID is
//				not feasible (such as testing an app that can't read the command
//				line) since it requires extra work and may suspend other threads.
//
// Arguments:
//	PTNMODULEID pTNModuleID		ID of module using this object.
//	char* szPrePlannedID		String used to identify expected connection and
//								retrieve dynamic ID.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::AllowStaticIDConnection(PTNMODULEID pTNModuleID,
											  char* szPrePlannedID)
{
	HRESULT							hr;
	char*							pszBuffer = NULL;
	HANDLE							hRedirMMMutex = NULL;
	PIPCOBJMMREDIRECTFILEHEADER		pHeader = NULL;
	HANDLE							ahWaitObjects[3];
	DWORD							dwNumWaitObjects = 0;


	if (this == NULL)
	{
		DPL(0, "This object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (bad object pointer)

	if (this->m_pszAttachPointID == NULL)
	{
		DPL(0, "Object not initialized (need attach point ID already set up)!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (no attach point yet)

	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Only owners can allow static ID connections!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (not owner's copy of object)

	if (this->m_hRedirMutex != NULL)
	{
		DPL(0, "Object already allowing static ID connection!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (already in use)

	if (pTNModuleID == NULL)
	{
		DPL(0, "Module ID pointer cannot be NULL!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (bad module ID pointer)

	if ((szPrePlannedID == NULL) || (strcmp(szPrePlannedID, "") == 0))
	{
		DPL(0, "Static connection ID cannot be NULL or just an empty string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (bad attach point ID)


	
	DPL(1, "Allowing static ID connection with ID = \"%s\"",
		1, szPrePlannedID);

	// Create/open the mutex used to protect the redirection.

	TNsprintf(&pszBuffer, PREFIX_REDIR_MUTEX " (mod %s v%u.%u) %s",
			4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
			pTNModuleID->dwMinorVersion1, szPrePlannedID);

	// We can't be the initial owner of the mutex because it may have been created
	// already, in which case the TRUE would be ignored.
	this->m_hRedirMutex = CreateMutex(NULL, FALSE, pszBuffer);
	if (this->m_hRedirMutex == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create mutex %s!", 1, pszBuffer);
		goto ERROR_EXIT;
	} // end if (couldn't create mutex)
	TNsprintf_free(&pszBuffer);



	// Grab the redirection mutex.
	ahWaitObjects[dwNumWaitObjects++] = this->m_hRedirMutex;

	if (this->m_pExecutor->m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


REWAIT:

	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								INFINITE, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Got the ready signal, we're cool.

			hr = S_OK;
		  break;

		case WAIT_OBJECT_0 + 1:
			// Got user cancel event

			DPL(0, "User cancelled waiting for redirection mutex!", 0);

			hr = TNWR_USERCANCEL;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		default:
			// What?
			DPL(0, "Received unexpected return from WaitForMultipleObjectsEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;
		  break;
	} // end switch (on wait result)


	// Now we have the overall lock.  We'll keep it until the other side connects or
	// this object is destroyed.




	// Create/open the mutex used to protect read/write access to the redirection
	// shared memory.

	TNsprintf(&pszBuffer, PREFIX_REDIR_MMMUTEX " (mod %s v%u.%u) %s",
			4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
			pTNModuleID->dwMinorVersion1, szPrePlannedID);

	// We can't be the initial owner of the mutex because it may have been created
	// already, in which case the TRUE would be ignored.
	hRedirMMMutex = CreateMutex(NULL, FALSE, pszBuffer);
	if (hRedirMMMutex == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create mutex %s!", 1, pszBuffer);
		goto ERROR_EXIT;
	} // end if (couldn't create mutex)
	TNsprintf_free(&pszBuffer);


	// Grab the write lock, which is just to prevent the other side from reading it
	// before we've written it.

	while (WaitForSingleObjectEx(hRedirMMMutex, INFINITE, TRUE) == WAIT_IO_COMPLETION)
	{
		DPL(1, "I/O Completion.", 0);
	} // end while (there's an I/O completion)



	// Create/open the actual shared redirection memory.

	TNsprintf(&pszBuffer, PREFIX_REDIR_MMFILE " (mod %s v%u.%u) %s",
			4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
			pTNModuleID->dwMinorVersion1, szPrePlannedID);

	DPL(8, "Opening redirect file \"%s\" to store real attach point ID (\"%s\").",
		2, pszBuffer, this->m_pszAttachPointID);

	this->m_hRedirMMFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
										0, (sizeof (IPCOBJMMREDIRECTFILEHEADER) + MAX_REDIR_DATA_SIZE),
										pszBuffer);
	if (this->m_hRedirMMFile == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create file mapping %s!", 1, pszBuffer);
		goto ERROR_EXIT;
	} // end if (couldn't create file mapping)
	TNsprintf_free(&pszBuffer);


	pHeader = (PIPCOBJMMREDIRECTFILEHEADER) MapViewOfFile(this->m_hRedirMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pHeader == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't map view of file)


	pHeader->dwSize = strlen(this->m_pszAttachPointID);
	strcpy((char*) (pHeader + 1), this->m_pszAttachPointID);



	UnmapViewOfFile(pHeader);
	pHeader = NULL;

	ReleaseMutex(hRedirMMMutex);
	CloseHandle(hRedirMMMutex);
	hRedirMMMutex = NULL;

	// We keep everything else until we are told to abort or the other side
	// connects.

	return (S_OK);


ERROR_EXIT:

	if (pHeader != NULL)
	{
		UnmapViewOfFile(pHeader);
		pHeader = NULL;
	} // end if (mapped view)

	if (this->m_hRedirMMFile)
	{
		CloseHandle(this->m_hRedirMMFile);
		this->m_hRedirMMFile = NULL;
	} // end if (we have the lock)

	if (hRedirMMMutex)
	{
		ReleaseMutex(hRedirMMMutex);
		CloseHandle(hRedirMMMutex);
		hRedirMMMutex = NULL;
	} // end if (we have the lock)

	if (this->m_hRedirMutex)
	{
		ReleaseMutex(this->m_hRedirMutex);
		CloseHandle(this->m_hRedirMutex);
		this->m_hRedirMutex = NULL;
	} // end if (we have the lock)

	if (pszBuffer != NULL)
		TNsprintf_free(&pszBuffer);

	return (hr);
} // CTNIPCObject::AllowStaticIDConnection
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::ConnectWithStaticID()"
//==================================================================================
// CTNIPCObject::ConnectWithStaticID
//----------------------------------------------------------------------------------
//
// Description: Connects this object to an owner previously expecting a connection.
//				The object finds the real attach point ID using the given preplanned
//				ID.
//				Note that the owner must previously have called
//				AllowStaticIDConnection on its copy of the object, using the same
//				ID, for this to work.
//				See AllowStaticIDConnection for more details.
//
// Arguments:
//	PTNMODULEID pTNModuleID			ID of module using this object.
//	char* szPrePlannedID			String used to identify expected connection and
//									retrieve dynamic ID.
//	HANDLE hConnectEvent			Optional handle to event to set when the other
//									side connects back (may be right away, if it is
//									already set up).
//	PVOID pvSendConnectData			Optional pointer to data to send to other side.
//	DWORD dwSendConnectDataSize		Size of data to send to other side.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::ConnectWithStaticID(PTNMODULEID pTNModuleID,
										char* szPrePlannedID,
										HANDLE hConnectEvent,
										PVOID pvSendConnectData,
										DWORD dwSendConnectDataSize)
{
	HRESULT							hr;
	char*							pszBuffer = NULL;
	HANDLE							hRedirMMMutex = NULL;
	PIPCOBJMMREDIRECTFILEHEADER		pHeader = NULL;


	if (this == NULL)
	{
		DPL(0, "This object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (bad object pointer)

	if (this->m_pszAttachPointID != NULL)
	{
		DPL(0, "Object already connected!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (no attach point yet)

	if (pTNModuleID == NULL)
	{
		DPL(0, "Module ID pointer cannot be NULL!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (bad module ID pointer)

	if ((szPrePlannedID == NULL) || (strcmp(szPrePlannedID, "") == 0))
	{
		DPL(0, "Static connection ID cannot be NULL or just an empty string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (bad attach point ID)


	// Create/open the mutex used to protect read/write access to the redirection
	// shared memory.

	TNsprintf(&pszBuffer, PREFIX_REDIR_MMMUTEX " (mod %s v%u.%u) %s",
			4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
			pTNModuleID->dwMinorVersion1, szPrePlannedID);

	// We can't be the initial owner of the mutex because it may have been created
	// already, in which case the TRUE would be ignored.
	hRedirMMMutex = CreateMutex(NULL, FALSE, pszBuffer);
	if (hRedirMMMutex == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create mutex %s!", 1, pszBuffer);
		goto ERROR_EXIT;
	} // end if (couldn't create mutex)
	TNsprintf_free(&pszBuffer);


	// Grab the write lock, which is just to prevent us from reading it before the
	// other side has written it.

#pragma TODO(vanceo, "Convert to full blown Wait, including user cancel")
	while (WaitForSingleObjectEx(hRedirMMMutex, INFINITE, TRUE) == WAIT_IO_COMPLETION)
	{
		DPL(1, "I/O Completion.", 0);
	} // end while (there's an I/O completion)



	// Create/open the actual shared redirection memory.

	TNsprintf(&pszBuffer, PREFIX_REDIR_MMFILE " (mod %s v%u.%u) %s",
			4, pTNModuleID->szBriefName, pTNModuleID->dwMajorVersion,
			pTNModuleID->dwMinorVersion1, szPrePlannedID);

	DPL(8, "Opening redirect file \"%s\" to retrieve real attach point ID.",
		1, pszBuffer);

	this->m_hRedirMMFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
										0, (sizeof (IPCOBJMMREDIRECTFILEHEADER) + MAX_REDIR_DATA_SIZE),
										pszBuffer);
	if (this->m_hRedirMMFile == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create file mapping %s!", 1, pszBuffer);
		goto ERROR_EXIT;
	} // end if (couldn't create file mapping)
	TNsprintf_free(&pszBuffer);


	pHeader = (PIPCOBJMMREDIRECTFILEHEADER) MapViewOfFile(this->m_hRedirMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pHeader == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't map view of file)


	// Connect using the given ID.
	hr = this->Connect(FALSE, pTNModuleID, ((char*) (pHeader + 1)), hConnectEvent,
						pvSendConnectData, dwSendConnectDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't connect using ID \"%s\"!", 1, (pHeader + 1));
		goto ERROR_EXIT;
	} // end if (couldn't connect)


	UnmapViewOfFile(pHeader);
	pHeader = NULL;

	CloseHandle(this->m_hRedirMMFile);
	this->m_hRedirMMFile = NULL;

	ReleaseMutex(hRedirMMMutex);
	CloseHandle(hRedirMMMutex);
	hRedirMMMutex = NULL;

	return (S_OK);


ERROR_EXIT:

	if (pHeader != NULL)
	{
		UnmapViewOfFile(pHeader);
		pHeader = NULL;
	} // end if (mapped view)

	if (this->m_hRedirMMFile)
	{
		CloseHandle(this->m_hRedirMMFile);
		this->m_hRedirMMFile = NULL;
	} // end if (we have the lock)

	if (hRedirMMMutex)
	{
		ReleaseMutex(hRedirMMMutex);
		CloseHandle(hRedirMMMutex);
		hRedirMMMutex = NULL;
	} // end if (we have the lock)

	if (pszBuffer != NULL)
		TNsprintf_free(&pszBuffer);

	return (hr);
} // CTNIPCObject::ConnectWithStaticID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::GetConnectData()"
//==================================================================================
// CTNIPCObject::GetConnectData
//----------------------------------------------------------------------------------
//
// Description: Sets the pointers passed in to the data sent by the other side when
//				it connected.
//				Note: this is not a copy of the data.
//
// Arguments:
//	PVOID* ppvData			Pointer to have set to point to data sent by other side
//							when it connected.
//	DWORD* pdwDataSize		Place to store size of data sent by other side.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::GetConnectData(PVOID* ppvData, DWORD* pdwDataSize)
{
	if (this == NULL)
	{
		DPL(0, "This object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bad object pointer)

	if (! this->m_fConnected)
	{
		DPL(0, "Object not connected!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (not connected)


	(*ppvData) = this->m_pvConnectData;
	(*pdwDataSize) = this->m_dwConnectDataSize;

	if (this->m_pvConnectData == NULL)
	{
		DPL(0, "WARNING: No connect data.", 0);
	} // end if (there's no data)

	return (S_OK);
} // CTNIPCObject::GetConnectData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::ReceiveMessage()"
//==================================================================================
// CTNIPCObject::ReceiveMessage
//----------------------------------------------------------------------------------
//
// Description: Retrieves a message for the object from the shared memory.  This
//				assumes the data there is actually for this object.  The memory lock
//				is not taken since the sending side actually still holds it.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::ReceiveMessage(void)
{
	HRESULT					hr;
	PIPCOBJMMFILEHEADER		pHeader = NULL;


	DPL(9, "==>", 0);


	pHeader = (PIPCOBJMMFILEHEADER) MapViewOfFile(this->m_hMMFile,
													FILE_MAP_ALL_ACCESS,
													0, 0, 0);
	if (pHeader == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto DONE;
	} // end if (couldn't map view of file)
	

	switch (pHeader->dwCommand)
	{
		case IPCMSGID_CONNECT:
			hr = this->HandleConnectMsg(((pHeader->dwSendDataSize > 0) ? (pHeader + 1) : NULL),
										pHeader->dwSendDataSize);
		  break;

		case IPCMSGID_DISCONNECT:
			hr = this->HandleDisconnectMsg();
		  break;

		case IPCMSGID_PING:
			// Update the count so it knows we're still alive.
			this->m_dwLastMessageReceived = GetTickCount();

			hr = S_OK;
		  break;

		default:
			// Unknown command, let the child class handle it.  First update the
			// count so it knows we're still alive.
			this->m_dwLastMessageReceived = GetTickCount();

			// Let him know how much room there is in the reply buffer.  He should
			// override this number with the actual amount he used.
			pHeader->dwReplyDataSize = MAX_MESSAGE_SIZE - pHeader->dwSendDataSize;

			hr = this->HandleMessage(pHeader->dwCommand,
									((pHeader->dwSendDataSize > 0) ? (pHeader + 1) : NULL),
									pHeader->dwSendDataSize,
									((LPBYTE) (pHeader + 1)) + pHeader->dwSendDataSize,
									&(pHeader->dwReplyDataSize));
		  break;
	} // end switch (on the command in the buffer)

	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle message (%u)!", 1, pHeader->dwCommand);
		goto DONE;
	} // end if (couldn't handle message)


	DPL(6, "Acknowledging message %u with event %x.",
		2, pHeader->dwCommand, this->m_hAckEvent);

	if (! SetEvent(this->m_hAckEvent))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set acknowledge event (%x)!", 1, this->m_hAckEvent);
		//goto DONE;
	} // end if (couldn't set event)


DONE:

	if (pHeader != NULL)
	{
		UnmapViewOfFile(pHeader);
		pHeader = NULL;
	} // end if (mapped view)
	
	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNIPCObject::ReceiveMessage
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::SendMessage()"
//==================================================================================
// CTNIPCObject::SendMessage
//----------------------------------------------------------------------------------
//
// Description: Puts a message for the other side into the shared memory.
//
// Arguments:
//	DWORD dwCommand		ID of command/message
//	PVOID pvData		Optional additional buffer with data for command.
//	DWORD dwDataSize	Size of message data.
//	DWORD dwTimeout		Maximum amount of time to allow for acknowledgement by other
//						side.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::SendMessage(DWORD dwCommand, PVOID pvData, DWORD dwDataSize,
								DWORD dwTimeout)
{
	HRESULT					hr = S_OK;
	PIPCOBJMMFILEHEADER		pHeader = NULL;
	HANDLE					ahWaitObjects[3];
	DWORD					dwNumWaitObjects = 0;
	DWORD					dwTimeElapsed = 0;
	DWORD					dwInterval;
	MSG						msg;
	BOOL					fHaveMMWriteLock = FALSE;



	DPL(9, "==> (%u, %x, %u)", 3, dwCommand, pvData, dwDataSize);

	if (! this->m_fConnected)
	{
		DPL(0, "IPC Object not connected, can't send message!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not connected)


	if (dwDataSize > MAX_MESSAGE_SIZE)
	{
		DPL(0, "Can't send message because %u is larger than max message size (%u)!",
			2, dwDataSize, MAX_MESSAGE_SIZE);
		hr = ERROR_BUFFER_TOO_SMALL;
		goto DONE;
	} // end if (message too large)



	DPL(4, "Waiting for lock to send message %u to %s...",
		3, dwCommand,
		((this->m_fOwnerCopy) ? "separate process" : "owner"));


	// Grab the mutex.
	ahWaitObjects[dwNumWaitObjects++] = this->m_hMMWriteMutex;

	if ((this->m_pExecutor->m_hUserCancelEvent != NULL) &&
		(dwCommand != IPCMSGID_DISCONNECT))
	{
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;
	} // end if (owner side and there's a cancel event and not disconnect)

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


REWAIT_MUTEX:

	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)


	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								MESSAGE_PUMP_CHECK_INTERVAL, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Got the lock, we're cool.

			hr = S_OK;
		  break;

		case WAIT_OBJECT_0 + 1:
			// Got user cancel event

			DPL(0, "User cancelled waiting for mutex to send message!", 0);

			hr = TNWR_USERCANCEL;
			goto DONE;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT_MUTEX;
		  break;

		case WAIT_TIMEOUT:
			// Interval elapsed.  Poll the message queue and rewait.
			goto REWAIT_MUTEX;
		  break;

		default:
			// What?
			DPL(0, "Received unexpected return from WaitForMultipleObjectsEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;

			goto DONE;
		  break;
	} // end switch (on wait result)


	this->m_dwMMWriteLockRefCount++;
	fHaveMMWriteLock = TRUE;
	//DPL(9, "Took lock.", 0);


	pHeader = (PIPCOBJMMFILEHEADER) MapViewOfFile(this->m_hMMFile,
													FILE_MAP_ALL_ACCESS,
													0, 0, 0);
	if (pHeader == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto DONE;
	} // end if (couldn't map view of file)


	pHeader->dwCommand = dwCommand;

	if ((pvData != NULL) && (dwDataSize > 0))
		pHeader->dwSendDataSize = dwDataSize;
	else
		pHeader->dwSendDataSize = 0;


	if ((pvData != NULL) && (dwDataSize > 0))
		CopyMemory((pHeader + 1), pvData, dwDataSize);



	DPL(9, "Setting send event %x.", 1, this->m_hSendEvent);


	// This send event corresponds to what the other side sees as a receive event.
	if (! SetEvent(this->m_hSendEvent))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set send event (%x)!", 1, this->m_hSendEvent);
		goto DONE;
	} // end if (couldn't set event)


	// Wait for the other side to acknowledge.

	DPL(4, "Waiting for %s acknowledgement of message %u...",
		2, ((this->m_fOwnerCopy) ? "separate process'" : "owner's"),
		dwCommand);

	dwNumWaitObjects = 0; // need to reset it, since it got used above
	ahWaitObjects[dwNumWaitObjects++] = this->m_hAckEvent;

	if ((this->m_pExecutor->m_hUserCancelEvent != NULL) &&
		(dwCommand != IPCMSGID_DISCONNECT))
	{
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;
	} // end if (owner side and there's a cancel event and not disconnect)

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

REWAIT_ACK:

	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)


	// If we can't fit a whole interval in, just use the remainder of the time
	// allowed by the given timeout.
	if ((dwTimeout != INFINITE) &&
		(dwTimeElapsed + MESSAGE_PUMP_CHECK_INTERVAL > dwTimeout))
	{
		dwInterval = dwTimeout - dwTimeElapsed;
	} // end if (there's a timeout and there's less than a full chunk left)
	else
		dwInterval = MESSAGE_PUMP_CHECK_INTERVAL;


	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								dwInterval, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// The event fired.

			DPL(4, "%s acknowledged message %u.",
				2, ((this->m_fOwnerCopy) ? "Separate process" : "Owner"),
				dwCommand); 

			hr = S_OK;
		  break;

		case WAIT_OBJECT_0 + 1:
			// User cancelled

			DPL(0, "User cancelled wait for acknowledgement for command %u!",
				1, dwCommand);

			hr = TNWR_USERCANCEL;
			goto DONE;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT_ACK;
		  break;

		case WAIT_TIMEOUT:
			dwTimeElapsed += dwInterval;

			// If there's still some time remaining, go back to waiting.
			if ((dwTimeout == INFINITE) ||
				(dwTimeElapsed < dwTimeout))
			{
				goto REWAIT_ACK;
			} // end if (no timeout, or we haven't hit it yet)


			DPL(1, "Timed out waiting for %s to acknowledge message, are you sure it's connected?",
				1, ((this->m_fOwnerCopy) ? "separate process" : "owner"));

			this->m_fConnected = FALSE;

			hr = TNWR_TIMEOUT;
			goto DONE;
		  break;

		default:
			DPL(0, "Got unexpected return from WaitForSingleObjectEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on wait result)


	// Just for completeness, let's erase the message.
	pHeader->dwCommand = 0;
	pHeader->dwSendDataSize = 0;
	pHeader->dwReplyDataSize = 0;


DONE:

	if (pHeader != NULL)
	{
		UnmapViewOfFile(pHeader);
		pHeader = NULL;
	} // end if (mapped view)

	if (fHaveMMWriteLock)
	{
		ReleaseMutex(this->m_hMMWriteMutex);
		fHaveMMWriteLock = FALSE;
		this->m_dwMMWriteLockRefCount--;
		//DPL(9, "Dropped lock.", 0);
	} // end if (we have the write lock)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNIPCObject::SendMessage
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::PrepareSendBuffer()"
//==================================================================================
// CTNIPCObject::PrepareSendBuffer
//----------------------------------------------------------------------------------
//
// Description: Creates a buffer of the given size in preparation for sending the
//				buffer as message data.  This call should be followed by writing the
//				data, then a send buffer call.
//				IMPORTANT: This takes the write lock, so you may block until you can
//				own it, and you must release the buffer with ReleaseBuffers when
//				done.
//
// Arguments:
//	DWORD dwCommand			Command to send.
//	PVOID* ppvSendBuffer	Pointer to place to store send data buffer.
//	DWORD dwSendBufferSize	Size of send data buffer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::PrepareSendBuffer(DWORD dwCommand, PVOID* ppvSendBuffer,
										DWORD dwSendBufferSize)
{
	HRESULT					hr = S_OK;
	PIPCOBJMMFILEHEADER		pHeader = NULL;
	HANDLE					ahWaitObjects[3];
	DWORD					dwNumWaitObjects = 0;
	MSG						msg;


	if (! this->m_fConnected)
	{
		DPL(0, "IPC Object not connected, can't prepare send buffer!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not connected)


	if (dwSendBufferSize > MAX_MESSAGE_SIZE)
	{
		DPL(0, "Can't send message because %u is larger than max message size (%u)!",
			2, dwSendBufferSize, MAX_MESSAGE_SIZE);
		hr = ERROR_BUFFER_TOO_SMALL;
		goto DONE;
	} // end if (message too large)


	DPL(9, "++", 0);


	DPL(4, "Waiting for lock to send message %u to %s...",
		3, dwCommand,
		((this->m_fOwnerCopy) ? "separate process" : "owner"));


	// Grab the mutex.
	ahWaitObjects[dwNumWaitObjects++] = this->m_hMMWriteMutex;

	if ((this->m_pExecutor->m_hUserCancelEvent != NULL) &&
		(dwCommand != IPCMSGID_DISCONNECT))
	{
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;
	} // end if (owner side and there's a cancel event and not disconnect)

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


REWAIT:

	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)


	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								MESSAGE_PUMP_CHECK_INTERVAL, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Got the lock, we're cool.

			hr = S_OK;
		  break;

		case WAIT_OBJECT_0 + 1:
			// Got user cancel event

			DPL(0, "User cancelled waiting for mutex for message buffer!", 0);

			hr = TNWR_USERCANCEL;
			goto DONE;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			// Interval elapsed.  Poll the message queue and rewait.
			goto REWAIT;
		  break;

		default:
			// What?
			DPL(0, "Received unexpected return from WaitForMultipleObjectsEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;

			goto DONE;
		  break;
	} // end switch (on wait result)


	this->m_dwMMWriteLockRefCount++;
	//DPL(9, "Took lock.", 0);


	pHeader = (PIPCOBJMMFILEHEADER) MapViewOfFile(this->m_hMMFile,
													FILE_MAP_ALL_ACCESS,
													0, 0, 0);
	if (pHeader == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto DONE;
	} // end if (couldn't map view of file)


	pHeader->dwCommand = dwCommand;

	if ((ppvSendBuffer != NULL) && (dwSendBufferSize > 0))
		pHeader->dwSendDataSize = dwSendBufferSize;
	else
		pHeader->dwSendDataSize = 0;


	if (ppvSendBuffer != NULL)
		(*ppvSendBuffer) = (pHeader + 1);


DONE:

	return (hr);
} // CTNIPCObject::PrepareSendBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::SendBuffer()"
//==================================================================================
// CTNIPCObject::SendBuffer
//----------------------------------------------------------------------------------
//
// Description: Sends the current send buffer to the other side.
//
// Arguments:
//	PVOID pvSendBuffer		Pointer to send data buffer.
//	DWORD dwSendBufferSize	Size of send data buffer.
//	DWORD dwTimeout			Maximum amount of time to allow for acknowledgement by
//							other side.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::SendBuffer(PVOID pvSendBuffer, DWORD dwSendBufferSize,
								DWORD dwTimeout)
{
	HRESULT		hr = S_OK;
	HANDLE		ahWaitObjects[3];
	DWORD		dwNumWaitObjects = 0;
	DWORD		dwTimeElapsed = 0;
	DWORD		dwInterval;
	MSG			msg;


	if (! this->m_fConnected)
	{
		DPL(0, "IPC Object not connected, can't send message!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not connected)

	if (this->m_dwMMWriteLockRefCount == 0)
	{
		DPL(0, "Don't have write lock!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (don't have write lock)


	// This send event corresponds to what the other side sees as a receive event.
	if (! SetEvent(this->m_hSendEvent))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set send event (%x)!", 1, this->m_hSendEvent);
		goto DONE;
	} // end if (couldn't set event)



	// Wait for the other side to acknowledge.

	DPL(4, "Waiting for %s acknowledgement of message %u...",
		2, ((this->m_fOwnerCopy) ? "separate process'" : "owner's"),
		(((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1)->dwCommand);

	ahWaitObjects[dwNumWaitObjects++] = this->m_hAckEvent;

	if (this->m_pExecutor->m_hUserCancelEvent != NULL)
	{
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;
	} // end if (owner side and there's a cancel event)

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

REWAIT:

	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)


	// If we can't fit a whole interval in, just use the remainder of the time
	// allowed by the given timeout.
	if ((dwTimeout != INFINITE) &&
		(dwTimeElapsed + MESSAGE_PUMP_CHECK_INTERVAL > dwTimeout))
	{
		dwInterval = dwTimeout - dwTimeElapsed;
	} // end if (there's a timeout and there's less than a full chunk left)
	else
		dwInterval = MESSAGE_PUMP_CHECK_INTERVAL;


	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
									dwInterval, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// The event fired.

			DPL(4, "%s acknowledged message %u.",
				2, ((this->m_fOwnerCopy) ? "Separate process" : "Owner"),
				(((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1)->dwCommand); 

			hr = S_OK;
		  break;

		case WAIT_OBJECT_0 + 1:
			// User cancelled

			DPL(0, "User cancelled wait for acknowledgement for command %u!",
				1, (((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1)->dwCommand);
			hr = TNWR_USERCANCEL;
			goto DONE;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			dwTimeElapsed += dwInterval;

			// If there's still some time remaining, go back to waiting.
			if ((dwTimeout == INFINITE) ||
				(dwTimeElapsed < dwTimeout))
			{
				goto REWAIT;
			} // end if (no timeout, or we haven't hit it yet)


			DPL(1, "Timed out waiting for %s to acknowledge message %u, are you sure it's connected?",
				2, ((this->m_fOwnerCopy) ? "separate process" : "owner"),
				(((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1)->dwCommand);

			this->m_fConnected = FALSE;

			hr = TNWR_TIMEOUT;
			goto DONE;
		  break;

		default:
			DPL(0, "Got unexpected return from WaitForSingleObjectEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on wait result)


DONE:

	return (hr);
} // CTNIPCObject::SendBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::SendBufferAndGetReply()"
//==================================================================================
// CTNIPCObject::SendBufferAndGetReply
//----------------------------------------------------------------------------------
//
// Description: Sends the current send buffer to the other side, and retrieves
//				pointers to the reply.
//
// Arguments:
//	PVOID pvSendBuffer			Pointer to send data buffer.
//	DWORD dwSendBufferSize		Size of send data buffer.
//	PVOID* ppvReplyBuffer		Place to store pointer to reply data buffer.
//	DWORD* pdwReplyBufferSize	Place to store size of reply data buffer.
//	DWORD dwTimeout				Maximum amount of time to allow for acknowledgement
//								by other side.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::SendBufferAndGetReply(PVOID pvSendBuffer, DWORD dwSendBufferSize,
										PVOID* ppvReplyBuffer, DWORD* pdwReplyBufferSize,
										DWORD dwTimeout)
{
	HRESULT					hr = S_OK;
	PIPCOBJMMFILEHEADER		pHeader = NULL;
	HANDLE					ahWaitObjects[3];
	DWORD					dwNumWaitObjects = 0;
	DWORD					dwTimeElapsed = 0;
	DWORD					dwInterval;
	MSG						msg;


	if (this == NULL)
	{
		DPL(0, "IPCObject pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not a valid object)

	if (! this->m_fConnected)
	{
		DPL(0, "IPC Object not connected, can't send message!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not connected)

	if (this->m_dwMMWriteLockRefCount == 0)
	{
		DPL(0, "Don't have write lock!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (don't have write lock)


	// This send event corresponds to what the other side sees as a receive event.
	if (! SetEvent(this->m_hSendEvent))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set send event (%x)!", 1, this->m_hSendEvent);
		goto DONE;
	} // end if (couldn't set event)


	// Wait for the other side to acknowledge.

	DPL(4, "Waiting for %s acknowledgement of message %u...",
		2, ((this->m_fOwnerCopy) ? "separate process'" : "owner's"),
		(((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1)->dwCommand);

	ahWaitObjects[dwNumWaitObjects++] = this->m_hAckEvent;

	if (this->m_pExecutor->m_hUserCancelEvent != NULL)
	{
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;
	} // end if (owner side and there's a cancel event)

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

REWAIT:

	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)


	// If we can't fit a whole interval in, just use the remainder of the time
	// allowed by the given timeout.
	if ((dwTimeout != INFINITE) &&
		(dwTimeElapsed + MESSAGE_PUMP_CHECK_INTERVAL > dwTimeout))
	{
		dwInterval = dwTimeout - dwTimeElapsed;
	} // end if (there's a timeout and there's less than a full chunk left)
	else
		dwInterval = MESSAGE_PUMP_CHECK_INTERVAL;


	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
									dwInterval, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// The event fired.

			DPL(4, "%s acknowledged message %u.",
				2, ((this->m_fOwnerCopy) ? "Separate process" : "Owner"),
				(((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1)->dwCommand); 

			hr = S_OK;
		  break;

		case WAIT_OBJECT_0 + 1:
			// User cancelled

			DPL(0, "User cancelled wait for acknowledgement for command %u!",
				1, (((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1)->dwCommand);
			hr = TNWR_USERCANCEL;
			goto DONE;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			dwTimeElapsed += dwInterval;

			// If there's still some time remaining, go back to waiting.
			if ((dwTimeout == INFINITE) ||
				(dwTimeElapsed < dwTimeout))
			{
				goto REWAIT;
			} // end if (no timeout, or we haven't hit it yet)


			DPL(1, "Timed out waiting for %s to acknowledge message %u, are you sure it's connected?",
				2, ((this->m_fOwnerCopy) ? "separate process" : "owner"),
				(((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1)->dwCommand);

			this->m_fConnected = FALSE;

			hr = TNWR_TIMEOUT;
			goto DONE;
		  break;

		default:
			DPL(0, "Got unexpected return from WaitForSingleObjectEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;

			goto DONE;
		  break;
	} // end switch (on wait result)


	// Back up to the real header based on the send buffer pointer
	pHeader = ((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1;


	(*pdwReplyBufferSize) = pHeader->dwReplyDataSize;

	if (pHeader->dwReplyDataSize > 0)
		(*ppvReplyBuffer) = ((LPBYTE) (pHeader + 1)) + pHeader->dwSendDataSize;
	else
		(*ppvReplyBuffer) = NULL;



DONE:

	return (hr);
} // CTNIPCObject::SendBufferAndGetReply
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::ReturnMessageBuffers()"
//==================================================================================
// CTNIPCObject::ReturnMessageBuffers
//----------------------------------------------------------------------------------
//
// Description: Recycles the send and reply buffers previously allocated.
//
// Arguments:
//	PVOID pvSendBuffer			Pointer to send data buffer.
//	DWORD dwSendBufferSize		Size of send data buffer.
//	PVOID pvReplyBuffer			Pointer to reply data buffer.
//	DWORD dwReplyBufferSize		Size of reply data buffer.
//
// Returns: None.
//==================================================================================
void CTNIPCObject::ReturnMessageBuffers(PVOID pvSendBuffer, DWORD dwSendBufferSize,
										PVOID pvReplyBuffer, DWORD dwReplyBufferSize)
{
	PIPCOBJMMFILEHEADER		pHeader = NULL;


	if (this == NULL)
	{
		DPL(0, "IPCObject pointer is NULL!", 0);
		return;
	} // end if (not a valid object)

	if (this->m_dwMMWriteLockRefCount == 0)
	{
		DPL(0, "Don't have write lock!", 0);
		return;
	} // end if (don't have write lock)

	// Back up to the real header based on the send buffer pointer
	pHeader = ((PIPCOBJMMFILEHEADER) pvSendBuffer) - 1;

	// Just for completeness, let's erase the message.
	pHeader->dwCommand = 0;
	pHeader->dwSendDataSize = 0;
	pHeader->dwReplyDataSize = 0;


	UnmapViewOfFile(pHeader);
	pHeader = NULL;

	ReleaseMutex(this->m_hMMWriteMutex);
	this->m_dwMMWriteLockRefCount--;
	//DPL(9, "Dropped lock.", 0);


	DPL(9, "--", 0);
} // CTNIPCObject::ReturnMessageBuffers
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::PingOwner()"
//==================================================================================
// CTNIPCObject::PingOwner
//----------------------------------------------------------------------------------
//
// Description: Alerts the owning object that we're still alive.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::PingOwner(void)
{
	HRESULT		hr;


	DPL(9, "==>", 0);


#ifdef DEBUG
	if (this->m_fOwnerCopy)
	{
		DPL(0, "Object is slave owned (not process-side)?!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (this object is not connected)

	if (! this->m_fConnected)
	{
		DPL(0, "Object is not connected?!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (this object is not connected)
#endif // DEBUG

	hr = this->SendMessage(IPCMSGID_PING, NULL, 0, IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Failed sending ping message!", 0);
		goto DONE;
	} // end if (failed sending ping message)


DONE:
	
	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNIPCObject::PingOwner
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::StartObjMsgRecvThread()"
//==================================================================================
// CTNIPCObject::StartObjMsgRecvThread
//----------------------------------------------------------------------------------
//
// Description: Creates the event and thread used for receving messages from the
//				owner.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::StartObjMsgRecvThread(void)
{
	HRESULT		hr = S_OK;
	DWORD		dwThreadID;


	DPL(9, "==>", 0);

	// If the thread already exists, then we're done.
	if (this->m_hObjMsgRecvThread != NULL)
		goto DONE;

	// Create kill thread manual reset event
	this->m_hKillObjMsgRecvThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (this->m_hKillObjMsgRecvThreadEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create event!", 0);
		goto DONE;
	} // end if (couldn't create event)

	this->m_hObjMsgRecvThread = CreateThread(NULL, 0, IPCObjMsgRecvThreadProc,
											this, 0, &dwThreadID);
	if (this->m_hObjMsgRecvThread == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create thread!", 0);
		goto DONE;
	} // end if (couldn't create thread)


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} //  // CTNIPCObject::StartObjMsgRecvThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::KillObjMsgRecvThread()"
//==================================================================================
// CTNIPCObject::KillObjMsgRecvThread
//----------------------------------------------------------------------------------
//
// Description: Stops the thread that monitors incoming communication from the
//				owner.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::KillObjMsgRecvThread(void)
{
	HRESULT		hr = S_OK;


	DPL(9, "==>", 0);

	// Close all items associated with the thread
	if (this->m_hObjMsgRecvThread != NULL)
	{
		if (this->m_hKillObjMsgRecvThreadEvent == NULL) // ack, we won't be able to tell it to die
		{
			DPL(0, "Kill thread event doesn't exist!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (no kill event)

		if (! SetEvent(this->m_hKillObjMsgRecvThreadEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set kill thread event (%x)!",
				1, this->m_hKillObjMsgRecvThreadEvent);
			goto DONE;
		} // end if (no kill event)

		switch (WaitForSingleObject(this->m_hObjMsgRecvThread, TIMEOUT_DIE_OBJMSGRECVTHREAD))
		{
			case WAIT_OBJECT_0:
				// what we want
			  break;

			case WAIT_TIMEOUT:
				DPL(0, "Waited %i ms for object thread to die but it didn't!",
					1, TIMEOUT_DIE_OBJMSGRECVTHREAD);


#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
				DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT

			  break;

			default:
				DPL(0, "Got unexpected return code from WaitForSingleObject on the object thread!", 0);
			  break;
		} // end switch (on result of waiting for thread to die)

		CloseHandle(this->m_hObjMsgRecvThread);
		this->m_hObjMsgRecvThread = NULL;
	} // end if (the send thread exists)

	if (this->m_hKillObjMsgRecvThreadEvent != NULL)
	{
		CloseHandle(this->m_hKillObjMsgRecvThreadEvent);
		this->m_hKillObjMsgRecvThreadEvent = NULL;
	} // end if (have event)


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNIPCObject::KillObjMsgRecvThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::HandleConnectMsg()"
//==================================================================================
// CTNIPCObject::HandleConnectMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a connection message from the other side.
//
// Arguments:
//	LPVOID lpvData		Pointer to data sent by other side.
//	DWORD dwDataSize	Size of data sent by other side.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::HandleConnectMsg(LPVOID lpvData, DWORD dwDataSize)
{
	HRESULT		hr = S_OK;


	DPL(1, "%s connected to object %x (\"%s\").",
		3, ((this->m_fOwnerCopy) ? "Separate process" : "Owner"),
		this, this->m_pszAttachPointID);


	if (dwDataSize > 0)
	{
		this->m_pvConnectData = LocalAlloc(LPTR, dwDataSize);
		if (this->m_pvConnectData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		CopyMemory(this->m_pvConnectData, lpvData, dwDataSize);
		this->m_dwConnectDataSize = dwDataSize;

		DPL(8, "Got %u byte connect data buffer at %x.",
			2, this->m_dwConnectDataSize, this->m_pvConnectData);
	} // end if (there's connect data)


	// If we're owner side and we allowed a static ID, we can release it now.
	if ((this->m_fOwnerCopy) && (this->m_hRedirMutex != NULL))
	{
		DPL(7, "Closing redirection file.", 0);

		if (! CloseHandle(this->m_hRedirMMFile))
		{
			hr = GetLastError();
			DPL(0, "Couldn't close redirection MM file!", 0);
			goto DONE;
		} // end if (couldn't close handle)
		this->m_hRedirMMFile = NULL;

		ReleaseMutex(this->m_hRedirMutex);
		if (! CloseHandle(this->m_hRedirMutex))
		{
			hr = GetLastError();
			DPL(0, "Couldn't close redirection mutex!", 0);
			goto DONE;
		} // end if (couldn't close handle)
		this->m_hRedirMutex = NULL;
	} // end if (we're owner side)


	// Update this info so we can detect problems while connected.
	this->m_dwLastMessageReceived = GetTickCount();

	this->m_fConnected = TRUE;

	if (this->m_hConnectEvent != NULL)
	{
		if (! SetEvent(this->m_hConnectEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set connection event (%x)!", 1, this->m_hConnectEvent);
			goto DONE;
		} // end if (couldn't set event)

		// We don't need the event anymore
		CloseHandle(this->m_hConnectEvent);
		this->m_hConnectEvent = NULL;
	} // end if (there's an event to set)


DONE:

	return (hr);
} // CTNIPCObject::HandleConnectMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObject::HandleDisconnectMsg()"
//==================================================================================
// CTNIPCObject::HandleDisconnectMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a disconnection message from the other side.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObject::HandleDisconnectMsg(void)
{
	HRESULT		hr = S_OK;


	this->m_fConnected = FALSE;


	DPL(1, "Object %x (\"%s\") was disconnected by the %s.",
		3, this, this->m_pszAttachPointID,
		((this->m_fOwnerCopy) ? "separate process" : "owner"));


#pragma BUGBUG(vanceo, "Make sure we want to do this!")
	if ((this->m_pExecutor->m_hUserCancelEvent != NULL) &&
		(! SetEvent(this->m_pExecutor->m_hUserCancelEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set user cancel event (%x)!",
			1, this->m_pExecutor->m_hUserCancelEvent);
		goto DONE;
	} // end if (owner side and cancel event which failed)

	// Just in case there was a connect event, we need to release the person who
	// was waiting on this.
	if (this->m_hConnectEvent != NULL)
	{
		DPL(0, "WARNING: Disconnecting while still waiting to connect!", 0);

		if (! SetEvent(this->m_hConnectEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set connection event (%x)!", 1, this->m_hConnectEvent);
			goto DONE;
		} // end if (couldn't set event)

		// We don't need the event anymore
		CloseHandle(this->m_hConnectEvent);
		this->m_hConnectEvent = NULL;

		// We're not going to allow our child class to handle this because we
		// shouldn't actually have been connected.  If we did, it would probably
		// cause problems because their Connect() type call would fail plus they
		// would have their quit code called (usually causes all sorts of double
		// frees and shutdown races).

	} // end if (there's a connect event)
	else
	{
		DPL(9, "No connect event, allowing child class to handle disconnect.", 0);

		// Allows the derived class a chance to do anything it needs to.
		hr = this->HandleDisconnect();
		if (hr != S_OK)
		{
			DPL(0, "Derived classes HandleDisconnect function failed!", 0);
		} // end if (derived class' function failed)
	} // end else (there's no connect event)


DONE:

	return (hr);
} // CTNIPCObject::HandleDisconnectMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObjectsList::CTNIPCObjectsList()"
//==================================================================================
// CTNIPCObjectsList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNIPCObjectsList object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNIPCObjectsList::CTNIPCObjectsList(void):
	m_hObjMonitorThread(NULL),
	m_hKillObjMonitorThreadEvent(NULL),
	m_hObjListChangedEvent(NULL)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNIPCObjectsList));
	} // CTNIPCObjectsList::CTNIPCObjectsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObjectsList::~CTNIPCObjectsList()"
//==================================================================================
// CTNIPCObjectsList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNIPCObjectsList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNIPCObjectsList::~CTNIPCObjectsList(void)
{
	HRESULT		hr;


	//DPL(0, "this = %x", 1, this);


#pragma TODO(vanceo, "Detach all the objects")

	hr = this->KillObjMonitorThread();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't kill object monitor thread!  %e", 1, hr);
	} // end if (couldn't kill thread)
} // CTNIPCObjectsList::~CTNIPCObjectsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObjectsList::AddObject()"
//==================================================================================
// CTNIPCObjectsList::AddObject
//----------------------------------------------------------------------------------
//
// Description: Prepares and adds an IPC object to this list.
//
// Arguments:
//	PTNIPCOBJECT pObject	Pointer to object to add.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObjectsList::AddObject(PTNIPCOBJECT pObject)
{
	HRESULT		hr;


	this->EnterCritSection();

	if (pObject->m_hReceiveEvent == NULL)
	{
		DPL(0, "Object %x doesn't have a receive event yet (make sure Connect was called)!",
			1, pObject);
		hr = E_FAIL;
		goto DONE;
	} // end if (the object doesn't have a receive event yet)


	hr = this->Add(pObject);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add object to list!", 0);
		goto DONE;
	} // end if (couldn't add object to list)


	// Notify the thread of the change (starting it up if necessary).  It won't
	// actually be able to do much about it until we drop the list lock below.

	hr = this->StartObjMonitorThread();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't start object monitor thread!", 0);
		goto DONE;
	} // end if (couldn't start thread)

	if (! SetEvent(this->m_hObjListChangedEvent))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set object list changed event (%x)!",
			1, this->m_hObjListChangedEvent);
		goto DONE;
	} // end if (couldn't set the list changed event)


DONE:

	this->LeaveCritSection();

	return (hr);
} // CTNIPCObjectsList::AddObject
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObjectsList::RemoveObject()"
//==================================================================================
// CTNIPCObjectsList::RemoveObject
//----------------------------------------------------------------------------------
//
// Description: Removes an IPC object from this list.
//
// Arguments:
//	PTNIPCOBJECT pObject	Pointer to object to add.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObjectsList::RemoveObject(PTNIPCOBJECT pObject)
{
	HRESULT		hr;


	this->EnterCritSection();

	hr = this->RemoveFirstReference(pObject);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove object from list!", 0);
		goto DONE;
	} // end if (couldn't add object to list)

	if (pObject->m_dwRefCount == 0)
	{
		DPL(7, "Deleting IPC object %x.", 1, pObject);
		delete (pObject);
		pObject = NULL;
	} // end if (can delete object)
	else
	{
		DPL(7, "Not deleting IPC object %x, its refcount = %u.",
			1, pObject, pObject->m_dwRefCount);
	} // end else (can't delete object)


	// Notify the thread of the change.  It won't actually be able to do much about
	// it until we drop the list lock below.

	if (! SetEvent(this->m_hObjListChangedEvent))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set object list changed event (%x)!",
			1, this->m_hObjListChangedEvent);
		goto DONE;
	} // end if (couldn't set the list changed event)



	// This code is too problematic.  We'll have an extra unused thread lying
	// around if we remove all IPC objects, but at least we won't deadlock.
	/*
	if (this->Count() <= 0)
	{
		// HACKHACK: We drop the lock because if the last object got a message
		// while we were trying to remove it or it was already rebuilding the array
		// or something, then it's going to be stuck trying to take the list lock.
		// By sleeping here we hopefully allow it time to take the lock so we will
		// block trying to retake it until the obj monitor thread is done figuring
		// out that the object which was to receive a message is now gone.
		this->LeaveCritSection();

		Sleep(500);

		this->EnterCritSection();

		// Make sure nobody added an object while we dropped the lock.
		if (this->Count() <= 0)
		{
			// Tell the thread to die.
			hr = this->KillObjMonitorThread();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't tell object monitor thread to die!", 0);
				goto DONE;
			} // end if (couldn't tell thread to die)
		} // end if (nobody added an object)
	} // end if (that was the last object)
	*/


DONE:

	this->LeaveCritSection();

	return (hr);
} // CTNIPCObjectsList::RemoveObject
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObjectsList::StartObjMonitorThread()"
//==================================================================================
// CTNIPCObjectsList::StartObjMonitorThread
//----------------------------------------------------------------------------------
//
// Description: Creates the events and thread used for monitoring incoming messages
//				from objects.
//				If the thread was already started, then we return S_OK.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObjectsList::StartObjMonitorThread(void)
{
	HRESULT		hr = S_OK;
	DWORD		dwThreadID;


	DPL(9, "==>", 0);

	// If the thread already exists, then we're done.
	if (this->m_hObjMonitorThread != NULL)
		goto DONE;


	// Create kill thread manual reset event
	this->m_hKillObjMonitorThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (this->m_hKillObjMonitorThreadEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create kill event!", 0);
		goto DONE;
	} // end if (couldn't create event)

	// Create new object auto reset event
	this->m_hObjListChangedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (this->m_hObjListChangedEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create list changed event!", 0);
		goto DONE;
	} // end if (couldn't create event)

	this->m_hObjMonitorThread = CreateThread(NULL, 0, IPCObjMonitorThreadProc,
											this, 0, &dwThreadID);
	if (this->m_hObjMonitorThread == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create thread!", 0);
		goto DONE;
	} // end if (couldn't create thread)

DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNIPCObjectsList::StartObjMonitorThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNIPCObjectsList::KillObjMonitorThread()"
//==================================================================================
// CTNIPCObjectsList::KillObjMonitorThread
//----------------------------------------------------------------------------------
//
// Description: Kills the thread that monitors messages from objects.
//				If the thread is already gone, it returns S_OK.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNIPCObjectsList::KillObjMonitorThread(void)
{
	HRESULT		hr = S_OK;


	DPL(9, "==>", 0);


	// Close all items associated with the thread
	if (this->m_hObjMonitorThread != NULL)
	{
		if (this->m_hKillObjMonitorThreadEvent == NULL) // ack, we won't be able to tell it to die
		{
			DPL(0, "Kill thread event doesn't exist!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (no kill event)

		if (! SetEvent(this->m_hKillObjMonitorThreadEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set kill thread event (%x)!",
				1, this->m_hKillObjMonitorThreadEvent);
			goto DONE;
		} // end if (no kill event)


		switch (WaitForSingleObject(this->m_hObjMonitorThread, TIMEOUT_DIE_OBJMONITORTHREAD))
		{
			case WAIT_OBJECT_0:
				// what we want
			  break;
			case WAIT_TIMEOUT:
				DPL(0, "Waited %i ms for object monitor thread to die but it didn't!",
					1, TIMEOUT_DIE_OBJMONITORTHREAD);


#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
				DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT

			  break;
			default:
				DPL(0, "Got unexpected return code from WaitForSingleObject on the object monitor thread!", 0);
			  break;
		} // end switch (on result of waiting for thread to die)

		CloseHandle(this->m_hObjMonitorThread);
		this->m_hObjMonitorThread = NULL;
	} // end if (the object monitor thread exists)

	if (this->m_hKillObjMonitorThreadEvent != NULL)
	{
		CloseHandle(this->m_hKillObjMonitorThreadEvent);
		this->m_hKillObjMonitorThreadEvent = NULL;
	} // end if (have event)

	if (this->m_hObjListChangedEvent != NULL)
	{
		CloseHandle(this->m_hObjListChangedEvent);
		this->m_hObjListChangedEvent = NULL;
	} // end if (have event)


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNIPCObjectsList::KillObjMonitorThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#undef DEBUG_SECTION
#define DEBUG_SECTION	"IPCObjMsgRecvThreadProc()"
//==================================================================================
// IPCObjMsgRecvThreadProc
//----------------------------------------------------------------------------------
//
// Description: Waits for messages from the owner and handles them.
//
// Arguments:
//	LPVOID lpvParameter	Thread data.  Cast to a LPCTNIPCObject object.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI IPCObjMsgRecvThreadProc(LPVOID lpvParameter)
{
	HRESULT			hr = S_OK;
	PTNIPCOBJECT	pObject = (PTNIPCOBJECT) lpvParameter;
	HANDLE			ahWaitObjects[3];
	DWORD			dwNonConnectedTimeouts = 0;


	DPL(1, "Starting up.", 0);

	if (pObject->m_hKillObjMsgRecvThreadEvent == NULL)
	{
		DPL(0, "Kill thread event doesn't exist!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (event doesn't exist)

#if DEBUG
	if (pObject->m_fOwnerCopy)
	{
		DPL(0, "Starting IPCObjMsgRecvThread on owner copy of leech!  DEBUGBREAK()-ing.", 0);
		DEBUGBREAK();
		hr = E_FAIL;
		goto DONE;
	} // end if (owner copy)
#endif // DEBUG

	ahWaitObjects[0] = pObject->m_hKillObjMsgRecvThreadEvent;
	ahWaitObjects[1] = pObject->m_hReceiveEvent;
	ahWaitObjects[2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	do
	{
		DPL(9, "Waiting for object request.", 0);

		hr = WaitForMultipleObjects(2, ahWaitObjects, FALSE,
									OBJMSGRECVTHREAD_PING_INTERVAL);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// Time to die.

				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// We've got an incoming message

				hr = pObject->ReceiveMessage();
				if (hr != S_OK)
				{
					DPL(0, "WARNING: Receiving message failed!  %e", 1, hr);
					hr = S_OK;
				} // end if (couldn't receive message)
			  break;

			case WAIT_TIMEOUT:
				if (pObject->m_fConnected)
				{
					hr = pObject->PingOwner();
					if (hr != S_OK)
					{
						DPL(0, "Failed pinging owner!", 0);
						goto DONE;
					} // end if (failed pinging owner)
				} // end if (received at least one message)
				else
				{
					dwNonConnectedTimeouts++;

					if (dwNonConnectedTimeouts > OWNERNOTCONNECTED_WARNING_NUMINTERVALS)
					{
						if (dwNonConnectedTimeouts > OWNERNOTCONNECTED_ABORT_NUMINTERVALS)
						{
							DPL(0, "Owner has not connected in %u ms, failing!",
								1, (OBJMSGRECVTHREAD_PING_INTERVAL * dwNonConnectedTimeouts));

							// Pretend a disconnect message came in
							hr = pObject->HandleDisconnectMsg();
							if (hr != S_OK)
							{
								DPL(0, "Pretending to receive disconnect message failed!", 0);
								goto DONE;
							} // end if (disconnect failed)

							break; // stop looping
						} // end if (above abort threshold)
						else
						{
							DPL(0, "WARNING: Owner has not connected in %u ms.",
								1, (OBJMSGRECVTHREAD_PING_INTERVAL * dwNonConnectedTimeouts));
						} // end else (below abort threshold)
					} // end if (above warning threshold)
				} // end else (haven't received a message yet)
			  break;

			default:
				DPL(0, "Got unexpected return from WaitForMultipleObjects!", 0);
				goto DONE;
			  break;
		} // end switch (on wait return)
	} // end do
	while (TRUE);


DONE:

	if (hr != S_OK)
	{
		DPL(0, "%e", 1, hr);
	} // end if (quitting with a failure)


	DPL(1, "Exiting.", 0);

	return (hr);
} // IPCObjMsgRecvThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"IPCObjMonitorThreadProc()"
//==================================================================================
// IPCObjMonitorThreadProc
//----------------------------------------------------------------------------------
//
// Description: Waits for incoming messages from the objects, and handles them.
//
// Arguments:
//	LPVOID lpvParameter	Thread data.  Cast to an LPCTNIPCObjectsList object.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI IPCObjMonitorThreadProc(LPVOID lpvParameter)
{
	HRESULT					hr = S_OK;
	PTNIPCOBJECTSLIST		pObjectList = (PTNIPCOBJECTSLIST) lpvParameter;
	BOOL					fRebuildArray = TRUE;
	BOOL					fInCritSect = FALSE;
	int						iNumObjects = 0;
	HANDLE*					pahWaitObjects = NULL;
	int						i;
	PTNIPCOBJECT			pObject = NULL;
	PIPCOBJMMFILEHEADER		pHeader = NULL;


	DPL(1, "Starting up.", 0);

	if (pObjectList->m_hKillObjMonitorThreadEvent == NULL)
	{
		DPL(0, "Kill thread event doesn't exist!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (event doesn't exist)

	if (pObjectList->m_hObjListChangedEvent == NULL)
	{
		DPL(0, "Object list change event doesn't exist!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (event doesn't exist)

	do
	{
		if (fRebuildArray)
		{
			DPL(9, "Rebuilding object list array.", 0);

			fRebuildArray = FALSE; // reset this

			// If the array already existed, clear it out (closing references).
			if (pahWaitObjects != NULL)
			{
				for(i = 2; i < iNumObjects + 2; i++)
				{
					// Close our reference to the item, ignoring errors
					CloseHandle(pahWaitObjects[i]);
					pahWaitObjects[i] = NULL;
				} // end for (each item already in the array)

				LocalFree(pahWaitObjects);
				pahWaitObjects = NULL;
			} // end if (there was an array already)

			pObjectList->EnterCritSection();
			fInCritSect = TRUE;


			// Reset the event just in case it got fired again to prevent needless
			// rebuilding of the array.
			if (! ResetEvent(pObjectList->m_hObjListChangedEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't reset the list changed event (%x)!",
					1, pObjectList->m_hObjListChangedEvent);
				goto DONE;
			} // end if (couldn't reset the event)


			iNumObjects = pObjectList->Count();

			pahWaitObjects = (HANDLE*) LocalAlloc(LPTR, ((iNumObjects + 3) * (sizeof (HANDLE))));
			if (pahWaitObjects == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			pahWaitObjects[0] = pObjectList->m_hKillObjMonitorThreadEvent;
			pahWaitObjects[1] = pObjectList->m_hObjListChangedEvent;

			for(i = 0; i < iNumObjects; i++)
			{
				pObject = (PTNIPCOBJECT) pObjectList->GetItem(i);
				if (pObject == NULL)
				{
					DPL(0, "Couldn't get object item %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't allocate memory)

				DPL(9, "Got object %i (%x)", 2, i, pObject);

				pObject->m_dwRefCount++;


#ifdef DEBUG
				if (! pObject->m_fOwnerCopy)
				{
					DPL(0, "Working with separate process side copy of leech!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (not owner copy)
#endif // DEBUG


				// We need a handle to the object, but we can't just use the
				// other handle because another thread might close it and we'd
				// have a bogus handle.
				if (! DuplicateHandle(GetCurrentProcess(), pObject->m_hReceiveEvent,
										GetCurrentProcess(), &(pahWaitObjects[i + 2]),
										0, FALSE, DUPLICATE_SAME_ACCESS))
				{
					hr = GetLastError();
					DPL(0, "Couldn't duplicate object receive event handle %i (%x)!",
						2, i, pObject->m_hReceiveEvent);
					goto DONE;
				} // end if (couldn't duplicate handle)


				pObject->m_dwRefCount--;
				if (pObject->m_dwRefCount == 0)
				{
					DPL(0, "Deleting object %x!?  DEBUGBREAK()-ing.",
						1, pObject);
					DEBUGBREAK();
				} // end if (refcount hit 0)
				else
				{
					DPL(7, "Not deleting object %x, its refcount is %u.",
						2, pObject, pObject->m_dwRefCount);
				} // end if (refcount hit 0)
				pObject = NULL;
			} // end for (each object in the array)

			pahWaitObjects[iNumObjects + 2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

			fInCritSect = FALSE;
			pObjectList->LeaveCritSection();
		} // end if (we should rebuild the array)


		DPL(9, "Waiting for message from %i objects.", 1, iNumObjects);

		hr = WaitForMultipleObjects(iNumObjects + 2, pahWaitObjects, FALSE,
									INFINITE);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// Time to die.

				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// The object list changed, rebuild it

				fRebuildArray = TRUE;
			  break;

			case WAIT_FAILED:
				// Something was goofy.

				hr = GetLastError();
				DPL(0, "Wait failed!", 0);
				goto DONE;
			  break;

			default:
#pragma BUGBUG(vanceo, "This mechanism doesn't handle list changes very well (could try Receiving on non-signalled object)")

				i = hr - WAIT_OBJECT_0 - 2; // get the index of the item that caused this

				pObjectList->EnterCritSection();
				fInCritSect = TRUE;

				if (iNumObjects != pObjectList->Count())
				{
					DPL(0, "List appears to have changed (%i != %i) but we haven't been told yet, forcing array rebuild and reactivating item %i!",
						3, iNumObjects, pObjectList->Count(), i);
					fRebuildArray = TRUE;

					// Otherwise, refire the event that triggered this so we can retry,
					// if we can.
					if ((i >= 0) && (i < iNumObjects))
					{
						if (! SetEvent(pahWaitObjects[i + 2]))
						{
							DPL(0, "WARNING: Couldn't refire event %x!  %e",
								2, pahWaitObjects[i + 2], GetLastError());
						} // end if (couldn't refire event)
					} // end if (have a valid index to try refiring)
					else
					{
						DPL(0, "WARNING: Item %i was not a valid object before, not trying to refire anything!",
							1, i);
					} // end else (no object to refire)

					fInCritSect = FALSE;
					pObjectList->LeaveCritSection();
					break;
				} // end if (list changed but we didn't see it yet)

				// Check to make sure it was a valid event
				if ((i < 0) || (i >= iNumObjects))
				{
					DPL(0, "Got unexpected return from WaitForMultipleObjects!", 0);
					hr = E_FAIL;
					goto DONE;
				} // end if (got wacky return)

				// Otherwise, grab the object that signalled
				pObject = (PTNIPCOBJECT) pObjectList->GetItem(i);
				if (pObject == NULL)
				{
					//BUGBUG figure out why it's actually doing this
					/*
					DPL(0, "Couldn't get activated object item %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
					*/
					DPL(0, "WARNING: Couldn't get activated object item %i, forcing array rebuild!", 1, i);
					fRebuildArray = TRUE;

					fInCritSect = FALSE;
					pObjectList->LeaveCritSection();
					break;
				} // end if (couldn't get item)

				pObject->m_dwRefCount++;

				fInCritSect = FALSE;
				pObjectList->LeaveCritSection();



				//DPL(1, "Object %i received a message.", 1, i);

				hr = pObject->ReceiveMessage();
				if (hr != S_OK)
				{
					DPL(0, "WARNING: Object %i failed receiving message!  %e",
						2, i, hr);
					hr = S_OK;
				} // end if (failed receiving message)


				// We're done with the object.
				pObject->m_dwRefCount--;
				if (pObject->m_dwRefCount == 0)
				{
					DPL(1, "Deleting IPC object %x (post receive).", 1, pObject);
					delete (pObject);

					// If we do that, we need to make damn sure we rebuild
					// the array.
					fRebuildArray = TRUE;
				} // end if (refcount hit 0)
				else
				{
					DPL(7, "Not deleting IPC object %x (post receive), its refcount is %u.",
						2, pObject, pObject->m_dwRefCount);
				} // end if (refcount hit 0)
				pObject = NULL;


				hr = S_OK;
			  break;
		} // end switch (on wait return)
	} // end do
	while (true);


DONE:

	if (hr != S_OK)
	{
		DPL(0, "%e", 1, hr);
	} // end if (quitting with a failure)

	if (pObject != NULL)
	{
		pObject->m_dwRefCount--;
		if (pObject->m_dwRefCount == 0)
		{
			DPL(7, "Deleting object %x.", 1, pObject);
			delete (pObject);
		} // end if (refcount hit 0)
		else
		{
			DPL(7, "Not deleting object %x, its refcount is %u.",
				2, pObject, pObject->m_dwRefCount);
		} // end if (refcount hit 0)
		pObject = NULL;
	} // end if (still have object pointer)

	if (fInCritSect)
	{
		pObjectList->LeaveCritSection();
		fInCritSect = FALSE;
	} // end if (in critical section)

	if (pahWaitObjects != NULL)
	{
		for(i = 2; i < iNumObjects + 2; i++)
		{
			// Close our reference to the item, ignoring errors
			CloseHandle(pahWaitObjects[i]);
			pahWaitObjects[i] = NULL;
		} // end for (each item already in the array)

		LocalFree(pahWaitObjects);
		pahWaitObjects = NULL;
	} // end if (we had an object array)

	if (pHeader != NULL)
	{
		UnmapViewOfFile(pHeader);
		pHeader = NULL;
	} // end if (have file view)


	DPL(1, "Exiting.", 0);

	return (hr);
} // IPCObjMonitorThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\ipcobj.h ===
#ifndef _XBOX // no IPC supported
#ifndef __TNCONTROL_IPC_OBJECT__
#define __TNCONTROL_IPC_OBJECT__
//#pragma message("Defining __TNCONTROL_IPC_OBJECT__")






//==================================================================================
// Common Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG




//==================================================================================
// Defines
//==================================================================================
#define MAX_MESSAGE_SIZE						(1024 * 1024) // in bytes, = 1 MB

#define TIMEOUT_DIE_OBJMSGRECVTHREAD			4000 // in milliseconds
#define TIMEOUT_DIE_OBJMONITORTHREAD			5000 // in milliseconds

#define OBJMSGRECVTHREAD_PING_INTERVAL			5000 // in milliseconds

#define IPCOBJ_ACK_WAIT_TIMEOUT					45000 // in milliseconds



#define OWNERNOTCONNECTED_WARNING_NUMINTERVALS	5 // how many ping intervals before warning about not connected

#define OWNERNOTCONNECTED_ABORT_NUMINTERVALS	10 // how many ping intervals before failing when not connected




//==================================================================================
// Internal prototypes
//==================================================================================
DWORD WINAPI IPCObjMsgRecvThreadProc(LPVOID lpvParameter);
DWORD WINAPI IPCObjMonitorThreadProc(LPVOID lpvParameter);




//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNIPCObject:public LLITEM
{
	// These are friends so they can access the protected members.
	friend CTNIPCObjectsList;
	friend CTNLeech;
	friend CTNLeechesList;
	friend CTNExecutor;
	friend DWORD WINAPI IPCObjMsgRecvThreadProc(LPVOID lpvParameter);
	friend DWORD WINAPI IPCObjMonitorThreadProc(LPVOID lpvParameter);


	private:
		PTNEXECUTORPRIV		m_pExecutor; // pointer to executor which owns this object
		BOOL				m_fOwnerCopy; // whether this is an owner copy or not
		BOOL				m_fConnected; // whether the other side has connected yet
		DWORD				m_dwMMWriteLockRefCount; // how many times we've taken the shared memory write lock
		HANDLE				m_hMMWriteMutex; // the shared memory write lock
		HANDLE				m_hMMFile; // handle to the shared memory
		HANDLE				m_hRedirMutex; // mutex to protect the redirection memory
		HANDLE				m_hRedirMMFile; // handle to the redirection shared memory
		HANDLE				m_hSendEvent; // event that will be set when a message is outgoing
		HANDLE				m_hAckEvent; // event that will be set when a message is acknowledge being received
		HANDLE				m_hConnectEvent; // event to set when the other side connects
		PVOID				m_pvConnectData; // pointer to data sent by other side upon connection
		DWORD				m_dwConnectDataSize; // size of data sent by other side upon connection

		HANDLE				m_hObjMsgRecvThread; // process side only; handle to thread used to receive messages from slave
		HANDLE				m_hKillObjMsgRecvThreadEvent; // process side only; event to set when the receive thread should be killed


		HRESULT StartObjMsgRecvThread(void);
		HRESULT KillObjMsgRecvThread(void);
		HRESULT HandleConnectMsg(PVOID pvData, DWORD dwDataSize);
		HRESULT HandleDisconnectMsg(void);

		// These are pure virtual functions, derived classes must implement them
		// because we sure don't.
		virtual HRESULT HandleMessage(DWORD dwCommand,
									PVOID pvSentData, DWORD dwSentDataSize,
									PVOID pvReplyData, DWORD* pdwReplyDataSize) = 0;
		virtual HRESULT HandleDisconnect(void) = 0;


	protected:
		char*				m_pszAttachPointID; // string that identifies this specific object connection pair
		HANDLE				m_hReceiveEvent; // event that will be set when a message comes in
		DWORD				m_dwLastMessageReceived; // time to update when message was last received


		CTNIPCObject(PTNEXECUTORPRIV pExecutor);
		virtual ~CTNIPCObject(void);
		
		HRESULT Connect(BOOL fOwnerCopy, PTNMODULEID pTNModuleID,
						char* szAttachPointID, HANDLE hConnectEvent,
						PVOID pvSendConnectData, DWORD dwSendConnectDataSize);
		HRESULT Disconnect(void);

		HRESULT AllowStaticIDConnection(PTNMODULEID pTNModuleID, char* szPrePlannedID);
		HRESULT ConnectWithStaticID(PTNMODULEID pTNModuleID, char* szPrePlannedID,
									HANDLE hConnectEvent, PVOID pvSendConnectData,
									DWORD dwSendConnectDataSize);

		HRESULT GetConnectData(PVOID* ppvData, DWORD* pdwDataSize);

		HRESULT ReceiveMessage(void);

		HRESULT SendMessage(DWORD dwCommand, PVOID pvData, DWORD dwDataSize,
							DWORD dwTimeout);

		HRESULT PrepareSendBuffer(DWORD dwCommand, PVOID* ppvSendBuffer,
								DWORD dwSendBufferSize);
		HRESULT SendBuffer(PVOID pvSendBuffer, DWORD dwSendBufferSize,
						DWORD dwTimeout);
		HRESULT SendBufferAndGetReply(PVOID pvSendBuffer, DWORD dwSendBufferSize,
									PVOID* ppvReplyBuffer, DWORD* pdwReplyBufferSize,
									DWORD dwTimeout);
		void ReturnMessageBuffers(PVOID pvSendBuffer, DWORD dwSendBufferSize,
								PVOID pvReplyBuffer, DWORD dwReplyBufferSize);

		HRESULT PingOwner(void);
};


class DLLEXPORT CTNIPCObjectsList:public LLIST
{
	// These are friends so they can access the protected members.
	friend DWORD WINAPI IPCObjMonitorThreadProc(LPVOID lpvParameter);


	private:
		HANDLE		m_hObjMonitorThread; // handle to thread the watches the objects for incoming events


		HRESULT StartObjMonitorThread(void);
		HRESULT KillObjMonitorThread(void);


	protected:
		HANDLE		m_hKillObjMonitorThreadEvent; // handle to event to set when monitor thread should die
		HANDLE		m_hObjListChangedEvent;  // handle to event to set when list changes


		CTNIPCObjectsList(void);
		virtual ~CTNIPCObjectsList(void);

		HRESULT AddObject(PTNIPCOBJECT pObject);
		HRESULT RemoveObject(PTNIPCOBJECT pObject);


	//public:
};



#else //__TNCONTROL_IPC_OBJECT__
//#pragma message("__TNCONTROL_IPC_OBJECT__ already included!")
#endif //__TNCONTROL_IPC_OBJECT__
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\jobq.h ===
#ifndef __TNCONTROL_JOBQUEUE__
#define __TNCONTROL_JOBQUEUE__
//#pragma message("Defining __TNCONTROL_JOBQUEUE__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG




//==================================================================================
// Master jobs
//==================================================================================
// Handle a report from the specified slave.
#define TNMJ_HANDLEREPORT		1

// Get the next command for the specified slave.
#define TNMJ_GETNEXTCMD			2

// Ping all the slaves currently in the session to make sure they're alive.
#define TNMJ_PINGSLAVES			3

// Indicate the specified slave is now ready to test.
#define TNMJ_READYTOTEST		4

// Close the session to prevent new joiners.
#define TNMJ_CLOSESESSION		5




//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNJob:public LLITEM
{
	public:
		DWORD				m_dwOperation; // ID of work to be performed
		DWORD				m_dwTime; // time the job should be performed
		TNCTRLMACHINEID		m_idSlave; // ID of slave to perform operation on, if any
		PVOID				m_pvContext; // job specific context for operation


		CTNJob(DWORD dwOperation, DWORD dwTime, PTNCTRLMACHINEID pSlaveID, PVOID pvContext);
		virtual ~CTNJob(void);
};

class DLLEXPORT CTNJobQueue:public LLIST
{
	// These are friends so they can access the protected members.
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend DWORD WINAPI MasterJobThread(LPVOID lpvParameter);


	protected:
		HANDLE		m_hNewJobEvent; // there is something new in the queue


		CTNJobQueue(void);
		virtual ~CTNJobQueue(void);

		HRESULT AddJob(DWORD dwOperation, DWORD dwDelay,
						PTNCTRLMACHINEID pSlaveID, PVOID pvContext);
};






#else //__TNCONTROL_JOBQUEUE__
//#pragma message("__TNCONTROL_JOBQUEUE__ already included!")
#endif //__TNCONTROL_JOBQUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\ipaddrs.h ===
#ifndef __TNCONTROL_IPADDRESSES__
#define __TNCONTROL_IPADDRESSES__
//#pragma message("Defining __TNCONTROL_IPADDRESSES__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG


#define TNIPADDR_LOCAL	1 // WinSock reported this IP address
#define TNIPADDR_NAT	2 // This IP address was determined via the NAT detection routines




//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNIPAddress:public LLITEM
{
	// These are friends so they can access the protected member
	friend CTNIPAddressesList;
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend DWORD WINAPI SlavePeriodicSendThreadProc(LPVOID lpParameter); // see slave.h


	protected:
		IN_ADDR		m_ip; // IP address this item represents
		DWORD		m_dwType; // type of IP address this is


	public:
		CTNIPAddress(IN_ADDR* pinaddr, DWORD dwType);
		virtual ~CTNIPAddress(void);
};

class DLLEXPORT CTNIPAddressesList:public LLIST
{
	// These are friends so they can access the protected members
	friend CTNMachineInfo;
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNSlave;


	protected:
		HRESULT AddIP(IN_ADDR* pinaddr, DWORD dwType);
		HRESULT LoadLocalIPs(void);

		HRESULT PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize);
		HRESULT UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize);

		BOOL DoesIPExist(IN_ADDR* pinaddr);


	public:
		CTNIPAddressesList(void);
		virtual ~CTNIPAddressesList(void);


		HRESULT GetIPString(int iIndex, char* szString);
};





#else //__TNCONTROL_IPADDRESSES__
//#pragma message("__TNCONTROL_IPADDRESSES__ already included!")
#endif //__TNCONTROL_IPADDRESSES__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\jobq.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
//#include "..\tncommon\stack.h"

#include "tncontrl.h"
#include "main.h"

#include "slaveinfo.h"
#include "jobq.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNJob::CTNJob()"
//==================================================================================
// CTNJob constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNJob object.  Initializes the data
//				structures.
//
// Arguments:
//	DWORD dwOperation			Operation to this job represents.
//	DWORD dwTime				Time this job should be run.
//	PTNCTRLMACHINEID pSlaveID	ID of slave this job should be run on, if any.
//	PVOID pvContext				Job specific context for this operation.
//
// Returns: None (just the object).
//==================================================================================
CTNJob::CTNJob(DWORD dwOperation, DWORD dwTime, PTNCTRLMACHINEID pSlaveID, PVOID pvContext)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNJob));

	this->m_dwOperation = dwOperation;
	this->m_dwTime = dwTime;

	if (pSlaveID == NULL)
	{
		ZeroMemory(&(this->m_idSlave), sizeof (TNCTRLMACHINEID));
	} // end if (there's no ID)
	else
	{
		CopyMemory(&(this->m_idSlave), pSlaveID, sizeof (TNCTRLMACHINEID));
	} // end else (there's a slave ID)

	this->m_pvContext = pvContext;
} // CTNJob::CTNJob
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNJob::~CTNJob()"
//==================================================================================
// CTNJob destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNJob object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNJob::~CTNJob(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNJob::~CTNJob
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNJobQueue::CTNJobQueue()"
//==================================================================================
// CTNJobQueue constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNJobQueue object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNJobQueue::CTNJobQueue(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNJobQueue));

	// Auto reset event
	this->m_hNewJobEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (this->m_hNewJobEvent == NULL)
	{
		HRESULT		hr;


		hr = GetLastError();
		DPL(0, "Failed to create send data event!  %e", 1, hr);
	} // end if (failed to create event)
} // CTNJobQueue::CTNJobQueue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNJobQueue::~CTNJobQueue()"
//==================================================================================
// CTNJobQueue destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNJobQueue object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNJobQueue::~CTNJobQueue(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_hNewJobEvent != NULL)
	{
		CloseHandle(this->m_hNewJobEvent);
		this->m_hNewJobEvent = NULL;
	} // end if (have event)
} // CTNJobQueue::~CTNJobQueue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNJobQueue::AddJob()"
//==================================================================================
// CTNJobQueue::AddJob
//----------------------------------------------------------------------------------
//
// Description: Adds a new job for the thread to perform.
//
// Arguments:
//	DWORD dwOperation			ID of work to be performed.
//	DWORD dwDelay				How far into the future this operation should be
//								performed, or 0 for as soon as possible.
//	PTNCTRLMACHINEID pSlaveID	ID of slave to perform operation on, if any.
//	PVOID pvContext				Job specific context for this operation.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNJobQueue::AddJob(DWORD dwOperation, DWORD dwDelay,
							PTNCTRLMACHINEID pSlaveID, PVOID pvContext)
{
	HRESULT		hr;
	PTNJOB		pJob = NULL;
	BOOL		fInCritSect = FALSE;
	int			i;
	PTNJOB		pOtherJob = NULL;
	//PVOID		pvCallersCaller;


	/*
	// Save the address of the function calling us for debugging purposes.
	TNStackGetCallersAddress(&(pNewSendData->m_pvSubmittersAddress),
							&pvCallersCaller);

	DPL(9, "Data %x submitted by %X, %X",
		3, pNewSendData->m_pvData, pNewSendData->m_pvSubmittersAddress, pvCallersCaller);
	*/

	pJob = new (CTNJob)(dwOperation, ((dwDelay == 0) ? 0 : (GetTickCount() + dwDelay)),
						pSlaveID, pvContext);
	if (pJob == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	DPL(8, "Queueing job %x (op %u, to be run at %u).",
		3, pJob , pJob->m_dwOperation, pJob->m_dwTime);

	this->EnterCritSection();
	fInCritSect = TRUE;

	for(i = 0; i < this->Count(); i++)
	{
		pOtherJob = (PTNJOB) this->GetItem(i);
		if (pOtherJob == NULL)
		{
			DPL(0, "Couldn't get job %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		if (pOtherJob->m_dwTime > pJob->m_dwTime)
		{
			hr = this->InsertBeforeIndex(pJob, i);
			if (hr != S_OK)
			{
				DPL(0, "Failed to insert job before item %i!", 1, i);
				goto DONE;
			} // end if (failed to add item)

			pJob = NULL; // so we don't readd it to the list

			// We're done here
			break;
		} // end if (the current job is after the new job)
	} // end for (each job already in the queue)

	// If we didn't insert it into the list above, just add it to the end.
	if (pJob != NULL)
	{
		hr = this->Add(pJob);
		if (hr != S_OK)
		{
			DPL(0, "Failed to add job to end of list!", 0);
			goto DONE;
		} // end if (failed to add item)

		// Forget about it so we don't free it below, in case we didn't do it
		// above.
		pJob = NULL;
	} // end if (didn't add job above)


	if (! SetEvent(this->m_hNewJobEvent))
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't set new job event %x!", 1, this->m_hNewJobEvent);

		goto DONE;
	} // end if (couldn't set event)


DONE:

	if (fInCritSect)
	{
		fInCritSect = FALSE;
		this->LeaveCritSection();
	} // end if (in critical section)

	if (pJob != NULL)
	{
		delete (pJob);
		pJob = NULL;
	} // end if (still have object)

	return (hr);
} // CTNJobQueue::AddJob
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\leech.cpp ===
#ifndef _XBOX // no IPC supported
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <mmsystem.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\sprintf.h"

#include "tncontrl.h"
#include "main.h"

#include "leech.h"



//==================================================================================
// Structures
//==================================================================================
typedef struct tagLEECHCONNECTDATAHEADER
{
	TNCTRLMACHINEID		idSlave; // machine ID of the top slave
	DWORD				dwRealConnectDataSize; // size of real connect data

	// Anything after this is part of the real connection data.
} LEECHCONNECTDATAHEADER, * PLEECHCONNECTDATAHEADER;



//==================================================================================
// Messages
//==================================================================================
#define LEECHMSGID_LOGSTRING			101

typedef struct tagLEECHMSG_LOGSTRING
{
	DWORD		dwLogStringType; // reason/type of string to log

	// Anything after this is part of the string to log.
} LEECHMSG_LOGSTRING, * PLEECHMSG_LOGSTRING;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_REPORT				102

typedef struct tagLEECHMSG_REPORT
{
	DWORD		dwTopLevelUniqueID; // top level test ID for report
	DWORD		dwTestUniqueID; // test ID which generated this report
	HRESULT		hresult; // result code for report
	BOOL		fTestComplete; // whether it's a completion report or not
	BOOL		fSuccess; // whether it's a success report or not
	BOOL		fExecCaseExitReport; // whether it's the report generated when the ExecCase function returns
	DWORD		dwOutputDataSize; // size of output data in buffer
	DWORD		dwOutputVarsSize; // size of output variables in buffer

	// Anything after this is part of the output data and vars.
} LEECHMSG_REPORT, * PLEECHMSG_REPORT;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_WARNING				103

typedef struct tagLEECHMSG_WARNING
{
	DWORD		dwTopLevelUniqueID; // top level test ID for warning
	DWORD		dwTestUniqueID; // test ID which generated this warning
	HRESULT		hresult; // result code for warning
	DWORD		dwUserDataSize; // size of user data

	// Anything after this is part of the user data.
} LEECHMSG_WARNING, * PLEECHMSG_WARNING;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_CREATESUBTEST		104

typedef struct tagLEECHMSG_CREATESUBTEST
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwParentUniqueID; // ID of parent test
	int			iNumMachines; // number of testers in tester array

	// Anything after this is part of the case ID string and testers array blob
} LEECHMSG_CREATESUBTEST, * PLEECHMSG_CREATESUBTEST;

// The reply for this is just a DWORD with the unique ID assigned to the test.

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_SYNC					105

typedef struct tagLEECHMSG_SYNC
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of syncing test
	int			iNumMachines; // number of testers in tester array
	DWORD		dwSendDataSize; // size of outgoing sync data

	// Anything after this is part of the testers array and send data blob
} LEECHMSG_SYNC, * PLEECHMSG_SYNC;

typedef struct tagLEECHMSG_SYNCREPLY
{
	HRESULT		hrResult; // result code of operation
	DWORD		dwSyncDataSize; // size of sync data, if any
	
	// Anything after this is the sync data, if any
} LEECHMSG_SYNCREPLY, * PLEECHMSG_SYNCREPLY;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_ISTESTERONMACHINE	106

typedef struct tagLEECHMSG_ISTESTERONMACHINE
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of checking test
	int			iTesterNum; // tester number to check
} LEECHMSG_ISTESTERONMACHINE, * PLEECHMSG_ISTESTERONMACHINE;

// The reply for this is a pointer to BOOL result.

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_GETTESTERIP			107

typedef struct tagLEECHMSG_GETTESTERIP
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of retrieving test
	int			iTesterNum; // tester number to retrieve
	WORD		wPort; // port to retrieve IP on
} LEECHMSG_GETTESTERIP, * PLEECHMSG_GETTESTERIP;

// The reply for this is a pointer to the IP string.

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_GETTESTERPHONENUM	108

typedef struct tagLEECHMSG_GETTESTERPHONENUM
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of retrieving test
	int			iTesterNum; // tester number to retrieve
} LEECHMSG_GETTESTERPHONENUM, * PLEECHMSG_GETTESTERPHONENUM;

typedef struct tagLEECHMSG_GETTESTERPHONENUMREPLY
{
	HRESULT		hrResult; // result code of operation
	
	// Anything after this is the phone number, if successful
} LEECHMSG_GETTESTERPHONENUMREPLY, * PLEECHMSG_GETTESTERPHONENUMREPLY;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_GETTESTERCOMPORT		109

typedef struct tagLEECHMSG_GETTESTERCOMPORT
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of retrieving test
	int			iTesterNum; // tester number to retrieve
} LEECHMSG_GETTESTERCOMPORT, * PLEECHMSG_GETTESTERCOMPORT;

typedef struct tagLEECHMSG_GETTESTERCOMPORTREPLY
{
	HRESULT		hrResult; // result code of operation
	DWORD		dwCOMPort; // COM port found, if successful
} LEECHMSG_GETTESTERCOMPORTREPLY, * PLEECHMSG_GETTESTERCOMPORTREPLY;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_FREERESULTS			110

typedef struct tagLEECHMSG_FREERESULTS
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of freein test
	DWORD		dwCaseIDSize; // size of ID of case to match, if any
	DWORD		dwInstanceIDSize; // size of ID of case to match, if any

	// Anything after this is part of the case and instance ID strings.
} LEECHMSG_FREERESULTS, * PLEECHMSG_FREERESULTS;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_FREEOUTPUTVARS		111

typedef struct tagLEECHMSG_FREEOUTPUTVARS
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of freein test
	DWORD		dwCaseIDSize; // size of ID of case to match, if any
	DWORD		dwInstanceIDSize; // size of ID of case to match, if any
	DWORD		dwNameSize; // size of variable name to match, if any
	DWORD		dwTypeSize; // size of variable type to match, if any
	BOOL		fFreeData; // whether to free data if no more vars

	// Anything after this is part of the case ID, instance ID, name, and type
	// strings.
} LEECHMSG_FREEOUTPUTVARS, * PLEECHMSG_FREEOUTPUTVARS;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_RUNTEST				112

typedef struct tagLEECHMSG_RUNTEST
{
	DWORD		dwTestUniqueID; // ID of test
	int			iNumMachines; // total number of testers running the test
	DWORD		dwInputDataSize; // size of input data for test, if any

	// Anything after this is part of the case ID string, tester array, and input
	// data blob
} LEECHMSG_RUNTEST, * PLEECHMSG_RUNTEST;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_GETMACHINEINFO		113

typedef struct tagLEECHMSG_GETMACHINEINFO
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of retrieving test
	int			iTesterNum; // tester number to retrieve
} LEECHMSG_GETMACHINEINFO, * PLEECHMSG_GETMACHINEINFO;

typedef struct tagLEECHMSG_GETMACHINEINFOREPLY
{
	HRESULT		hrResult; // result code of operation
	DWORD		dwMachineInfoSize; // size of machine info buffer
} LEECHMSG_GETMACHINEINFOREPLY, * PLEECHMSG_GETMACHINEINFOREPLY;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LEECHMSGID_LOSTTESTER			114

typedef struct tagLEECHMSG_LOSTTESTER
{
	DWORD		dwTopLevelUniqueID; // ID of top level test
	DWORD		dwTestUniqueID; // ID of test that lost tester
	int			iLostTesterNum; // tester number that was lost
} LEECHMSG_LOSTTESTER, * PLEECHMSG_LOSTTESTER;




//==================================================================================
// Globals
//==================================================================================
// This is a somewhat hacky way to ensure uniqueness, for a single process anyway.
DWORD		g_dwUniquenessValue = 0;





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::CTNLeech()"
//==================================================================================
// Overloaded function
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNLeech object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNLeech::CTNLeech(void):
	CTNIPCObject(NULL)
{
	DPL(9, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNLeech));
} // CTNLeech::CTNLeech
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::~CTNLeech()"
//==================================================================================
// CTNLeech destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNLeech object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNLeech::~CTNLeech(void)
{
	DPL(9, "this = %x", 1, this);

	// If we allocated the executor, delete it.
	if ((this->m_pExecutor != NULL) &&
		(this->m_pExecutor->m_pOwningLeech == this))
	{
		delete (this->m_pExecutor);
		this->m_pExecutor = NULL;
	} // end if (have local executor)
} // CTNLeech::~CTNLeech
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::PerformLeechTesting()"
//==================================================================================
// CTNLeech::PerformLeechTesting
//----------------------------------------------------------------------------------
//
// Description: Attaches this leech object to a slave previously expecting a
//				connection, and waits to perform the testing it requests.
//
// Arguments:
//	PTNPERFORMLEECHTESTINGDATA pTNpltd	Pointer to parameter block to use when
//										initializing and using the leech.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::PerformLeechTesting(PTNPERFORMLEECHTESTINGDATA pTNpltd)
{
	HRESULT						hr;
	HANDLE						ahWaitObjects[3];
	DWORD						dwNumWaitObjects = 0;
	DWORD						dwTemp;
	PLEECHCONNECTDATAHEADER		pConnectData = NULL;
	DWORD						dwConnectDataSize = 0;


	ZeroMemory(ahWaitObjects, 3 * sizeof (HANDLE));


	DPL(9, "==>(%x)", 1, pTNpltd);

	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (we got passed a bad pointer)

	if (pTNpltd == NULL)
	{
		DPL(0, "Must pass a valid structure pointer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNpltd->dwSize != sizeof (TNPERFORMLEECHTESTINGDATA))
	{
		DPL(0, "Must pass a structure of correct size!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNpltd->dwAPIVersion != CURRENT_TNCONTROL_API_VERSION)
	{
		DPL(0, "WARNING: Caller requesting different API version (%i != %i), problems may occur.",
			2, pTNpltd->dwAPIVersion, CURRENT_TNCONTROL_API_VERSION);
	} // end if (got passed an invalid parameter)

	if ((pTNpltd->apfnLoadTestTable == NULL) ||
		(pTNpltd->dwNumLoadTestTables < 1) ||
		(pTNpltd->apfnLoadTestTable[0] == NULL) ||
		(pTNpltd->pszAttachmentID == NULL))
	{
		DPL(0, "Must pass a valid LoadTestTable callback array and attachment ID!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (no test table function or attachment ID)

	this->m_pExecutor = new (CTNExecutorPriv);
	if (this->m_pExecutor == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't create executor)

#pragma TODO(vanceo, "Don't do this manually here, have an init function like slave does")

	this->m_pExecutor->m_pOwningLeech = this;

	CopyMemory(&(this->m_pExecutor->m_moduleID), pTNpltd->pModuleID,
				sizeof (TNMODULEID));

	if (pTNpltd->hUserCancelEvent != NULL)
	{
		if (! DuplicateHandle(GetCurrentProcess(), pTNpltd->hUserCancelEvent,
								GetCurrentProcess(), &(this->m_pExecutor->m_hUserCancelEvent),
								0, FALSE, DUPLICATE_SAME_ACCESS))
		{
			hr = GetLastError();
			DPL(0, "Couldn't duplicate user cancel event handle (%x)!",
				2, pTNpltd->hUserCancelEvent);
			goto ERROR_EXIT;
		} // end if (couldn't duplicate handle)
	} // end if (there's a user cancel event)

	this->m_pExecutor->m_pfnInitializeTesting = pTNpltd->pfnInitializeTesting;
	this->m_pExecutor->m_pfnCleanupTesting = pTNpltd->pfnCleanupTesting;
	this->m_pExecutor->m_pfnGetTestingWindow = pTNpltd->pfnGetTestingWindow;
	this->m_pExecutor->m_fInitCOMForTestThread = pTNpltd->fInitializeCOMInTestThread;


	for(dwTemp = 0; dwTemp < pTNpltd->dwNumLoadTestTables; dwTemp++)
	{
		hr = pTNpltd->apfnLoadTestTable[dwTemp](&(this->m_pExecutor->m_testtable));
		if (hr != S_OK)
		{
			DPL(0, "Module's LoadTestTable callback %u failed!", 1, dwTemp);
			goto ERROR_EXIT;
		} // end if (module's callback failed)
	} // end for (each LoadTestTable callback)


	// We need this running before we notify the slave that we're here.  If we did
	// it after Connect(), we might get preempted and the slave could tell us to run
	// something before we got it ready, and it the message handler would fail.
	hr = this->m_pExecutor->StartTestThread();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't start test thread!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't start test thread)



	ahWaitObjects[0] = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (ahWaitObjects[0] == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create connection event!", 0);
		goto ERROR_EXIT;
	} // end if (module's callback failed)

	dwNumWaitObjects++;


	if (pTNpltd->fStaticAttachmentID)
	{
		hr = ((PTNIPCOBJECT) this)->ConnectWithStaticID(pTNpltd->pModuleID,
														pTNpltd->pszAttachmentID,
														ahWaitObjects[0],
														pTNpltd->pvSendConnectData,
														pTNpltd->dwSendConnectDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't attach leech with static ID \"%s\"!",
				1, pTNpltd->pszAttachmentID);
			goto ERROR_EXIT;
		} // end if (couldn't attach leech)
	} // end if (using static attachment ID)
	else
	{
		hr = ((PTNIPCOBJECT) this)->Connect(FALSE,
											pTNpltd->pModuleID,
											pTNpltd->pszAttachmentID,
											ahWaitObjects[0],
											pTNpltd->pvSendConnectData,
											pTNpltd->dwSendConnectDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't attach leech with ID \"%s\"!",
				1, pTNpltd->pszAttachmentID);
			goto ERROR_EXIT;
		} // end if (couldn't attach leech)
	} // end else (not using static attachment ID)


	// Wait for the other side to connect back, if it's not there already
	DPL(6, "Waiting for slave connection...", 0);


	if (this->m_pExecutor->m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


REWAIT:

	// Make sure the thread has started up and copied the necessary parameters so we
	// can let the context variable go out of scope.
	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								INFINITE, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Got the completion signal.  Make sure we're cool.

			if (this->m_fConnected)
			{
				DPL(5, "Completion indicated we are connected.", 0);
				hr = S_OK;

				// Continue...

			} // end if (connected)
			else
			{
				DPL(0, "Completion indicated we failed to connect!", 0);
				hr = TNCWR_TIMEOUT;
				goto ERROR_EXIT;
			} // end else (not connected)
		  break;

		case WAIT_OBJECT_0 + 1:
			// Got user cancel event

			DPL(0, "User cancelled waiting for slave connection!", 0);

			hr = TNCWR_USERCANCEL;
			goto ERROR_EXIT;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		/*
		case WAIT_TIMEOUT:
			DPL(0, "Timed out waiting %i milliseconds for slave connection!",
				1, PERIODICSENDTHREAD_STARTUP_TIMEOUT);

			hr = TNCWR_TIMEOUT;
			goto ERROR_EXIT;
		  break;
		*/

		default:
			// What?
			DPL(0, "Received unexpected return from WaitForMultipleObjectsEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;

			goto ERROR_EXIT;
		  break;
	} // end switch (on wait result)


	// Get the machine ID from the slave.
	hr = this->GetConnectData((PVOID*) &pConnectData, &dwConnectDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get connect data!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't get connect data)

	if ((pConnectData == NULL) || (dwConnectDataSize < sizeof (LEECHCONNECTDATAHEADER)))
	{
		DPL(0, "Didn't get expected connect data from slave (%x is NULL, or size %u < %u)!",
			3, pConnectData, dwConnectDataSize, sizeof (LEECHCONNECTDATAHEADER));
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (didn't get expected connect data)

	CopyMemory(&(this->m_pExecutor->m_id), &(pConnectData->idSlave),
				sizeof (TNCTRLMACHINEID));


#pragma BUGBUG(vanceo, "This is such a huge hack, need to do this right")

	// We still have the pConnectData pointer, so we can overwrite the
	// this->m_xx versions.
	if (pConnectData->dwRealConnectDataSize == 0)
	{
		this->m_pvConnectData = NULL;
		this->m_dwConnectDataSize = 0;
	} // end if (no real connect data)
	else
	{
		this->m_pvConnectData = LocalAlloc(LPTR, pConnectData->dwRealConnectDataSize);
		if (this->m_pvConnectData == NULL)
		{
			LocalFree(pConnectData);
			pConnectData = NULL;

			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)
		CopyMemory(this->m_pvConnectData, (pConnectData + 1), pConnectData->dwRealConnectDataSize);
		this->m_dwConnectDataSize = pConnectData->dwRealConnectDataSize;
	} // end else (real connect data)

	LocalFree(pConnectData);
	pConnectData = NULL;




	DPL(6, "Now connected to slave, his control machine ID = %u.",
		1, this->m_pExecutor->m_id.dwTime);

	// We don't need the event anymore.
	CloseHandle(ahWaitObjects[0]);
	ahWaitObjects[0] = NULL;


#pragma TODO(vanceo, "Do UI?")

	DPL(9, "<== S_OK", 0);

	return (S_OK);


ERROR_EXIT:

	this->Disconnect(); // ignore errors

	if (this->m_pExecutor != NULL)
	{
		delete (this->m_pExecutor);
		this->m_pExecutor = NULL;
	} // end if (created executor object)

	if (ahWaitObjects[0] != NULL)
	{
		CloseHandle(ahWaitObjects[0]);
		ahWaitObjects[0] = NULL;
	} // end if (have event)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNLeech::PerformLeechTesting
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::GetAttachPointID()"
//==================================================================================
// CTNLeech::GetAttachPointID
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the dynamically generated attach point ID
//				string for this object.
//				Note: this is not a copy of the string.
//
// Arguments: None.
//
// Returns: A pointer to the leeches attach point ID string.
//==================================================================================
char* CTNLeech::GetAttachPointID(void)
{
	return (this->m_pszAttachPointID);
} // CTNLeech::GetAttachPointID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::GetOwnerConnectData()"
//==================================================================================
// CTNLeech::GetOwnerConnectData
//----------------------------------------------------------------------------------
//
// Description: Sets the pointers passed in to the data sent by the owner when it
//				created the leech attachment.
//				Note: this is not a copy of the data.
//
// Arguments:
//	PVOID* ppvData			Pointer to have set to point to data sent by owner when
//							it created the leech attachment.
//	DWORD* pdwDataSize		Place to store size of data sent by owner.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::GetOwnerConnectData(PVOID* ppvData, DWORD* pdwDataSize)
{


#pragma TODO(vanceo, "Parameter validation")




	return (this->GetConnectData(ppvData, pdwDataSize));
} // CTNLeech::GetOwnerConnectData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::LogToOwner()"
//==================================================================================
// CTNLeech::LogToOwner
//----------------------------------------------------------------------------------
//
// Description: Logs the given string (parsing for special tokens) one level up the
//				object heirarchy.  Eventually the top level slave will receive it
//				and print it to its window.
//
// Arguments:
//	DWORD dwLogStringType	Type of string this is.
//	char* szFormatString	String (with optional tokens) to print.
//	DWORD dwNumParms		How many parameters are in the following variable
//							parameter list.
//	...						Variable list of parameters to parse.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::LogToOwner(DWORD dwLogStringType, char* szFormatString,
							DWORD dwNumParms, ...)
{
	HRESULT					hr;
	char*					pszBuffer = NULL;
	PVOID*					papvParms = NULL;
	va_list					currentparam;
	DWORD					dwTemp = 0;
	PLEECHMSG_LOGSTRING		pLogStringMsg = NULL;
	DWORD					dwLogStringMsgSize = 0;


	if (dwNumParms > 0)
	{
		papvParms = (PVOID*) LocalAlloc(LPTR, (dwNumParms * sizeof (PVOID)));
		if (papvParms == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		va_start(currentparam, dwNumParms);

		for(dwTemp = 0; dwTemp < dwNumParms; dwTemp++)
		{
			papvParms[dwTemp] = va_arg(currentparam, LPVOID);
		} // end for (each parameter)

		va_end(currentparam);
	} // end if (there are parameters to check)


	// Print the items.
	TNsprintf_array(&pszBuffer, szFormatString, dwNumParms, papvParms);

	LocalFree(papvParms);
	papvParms = NULL;


	dwLogStringMsgSize = sizeof (LEECHMSG_LOGSTRING)
						+ strlen(pszBuffer) + 1;

	hr = this->PrepareSendBuffer(LEECHMSGID_LOGSTRING,
								(PVOID*) &pLogStringMsg,
								dwLogStringMsgSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pLogStringMsg->dwLogStringType = dwLogStringType;
	strcpy((char*) (pLogStringMsg + 1), pszBuffer);



	// Send the log string message to the other side.
	hr = this->SendBuffer(pLogStringMsg, dwLogStringMsgSize, IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send log string message!", 0);
	} // end if (couldn't send message)


DONE:

	this->ReturnMessageBuffers(pLogStringMsg, dwLogStringMsgSize, NULL, 0);

	TNsprintf_free(&pszBuffer);

	if (papvParms != NULL)
	{
		LocalFree(papvParms);
		papvParms = NULL;
	} // end if (allocated array)

	return (hr);
} // CTNLeech::LogToOwner
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::ReportToOwner()"
//==================================================================================
// CTNLeech::ReportToOwner
//----------------------------------------------------------------------------------
//
// Description: Reports test results to the owner.  This will continue up the object
//				heirarchy until the top level slave sends this to the master.
//
//
// Arguments:
//	PTNTESTINSTANCES pTest				Pointer to test instance this report
//										pertains to.
//	HRESULT hresult						Success or error code.
//	BOOL fTestComplete					Does this report mean that no more execution
//										will be performed on the test (either
//										because it completed or it encountered a
//										fatal error)?
//	BOOL fSuccess						Is this report a success (note this does not
//										necessarily mean hresult is 0)?
//	BOOL fExecCaseExitReport			Is this the report automatically generated
//										when the ExecCase function returns?
//	PVOID pvOutputData					Optional pointer to output data to send with
//										report.
//	DWORD dwOutputDataSize				Size of output data to send with report.
//	PTNOUTPUTVARSLIST pOutputVars	Optional pointer to list of output variables
//										associated with result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::ReportToOwner(PTNTESTINSTANCES pTest, HRESULT hresult,
								BOOL fTestComplete, BOOL fSuccess,
								BOOL fExecCaseExitReport,
								PVOID pvOutputData, DWORD dwOutputDataSize,
								PTNOUTPUTVARSLIST pOutputVars)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTopLevelTest;
	PLEECHMSG_REPORT	pReportMsg = NULL;
	DWORD				dwReportMsgSize = 0;
	DWORD				dwOutputVarsSize = 0;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	dwReportMsgSize = sizeof (LEECHMSG_REPORT)
					+ dwOutputDataSize;
	if (pOutputVars != NULL)
	{
		// Ignore error, assume BUFFER_TOO_SMALL
		pOutputVars->PackIntoBuffer(NULL, &dwOutputVarsSize);
		dwReportMsgSize += dwOutputVarsSize;
	} // end if (theres a vars list)


	hr = this->PrepareSendBuffer(LEECHMSGID_REPORT,
								(PVOID*) &pReportMsg,
								dwReportMsgSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pReportMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pReportMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pReportMsg->hresult = hresult;
	pReportMsg->fTestComplete = fTestComplete;
	pReportMsg->fSuccess = fSuccess;
	pReportMsg->fExecCaseExitReport = fExecCaseExitReport;
	pReportMsg->dwOutputDataSize = dwOutputDataSize;
	pReportMsg->dwOutputVarsSize = dwOutputVarsSize;

	if (pvOutputData != NULL)
		CopyMemory((pReportMsg + 1), pvOutputData, dwOutputDataSize);

	if (dwOutputVarsSize > 0)
	{
		hr = pOutputVars->PackIntoBuffer(((LPBYTE) (pReportMsg + 1)) + dwOutputDataSize,
											&dwOutputVarsSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't pack output vars into a buffer!", 0);
			goto DONE;
		} // end if (couldn't pack into buffer)
	} // end if (output vars to copy)

	// Send the report message to the other side.
	hr = this->SendBuffer(pReportMsg, dwReportMsgSize, IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send report message!", 0);
	} // end if (couldn't send message)


DONE:

	this->ReturnMessageBuffers(pReportMsg, dwReportMsgSize, NULL, 0);

	return (hr);
} // CTNLeech::ReportToOwner
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::WarnOwner()"
//==================================================================================
// CTNLeech::WarnOwner
//----------------------------------------------------------------------------------
//
// Description: Sends a warning to the owner.  This will continue up the object
//				heirarchy until the top level slave sends this to the master.
//
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test instance this warning pertains to.
//	HRESULT hresult			Warning code.
//	PVOID pvUserData		Optional pointer to data to send with warning.
//	DWORD dwUserDataSize	Size of data to send with warning.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::WarnOwner(PTNTESTINSTANCES pTest, HRESULT hresult,
							PVOID pvUserData, DWORD dwUserDataSize)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTopLevelTest;
	PLEECHMSG_WARNING	pWarningMsg = NULL;
	DWORD				dwWarningMsgSize = 0;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	dwWarningMsgSize = sizeof (LEECHMSG_WARNING)
					+ dwUserDataSize;

	hr = this->PrepareSendBuffer(LEECHMSGID_WARNING,
								(PVOID*) &pWarningMsg,
								dwWarningMsgSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pWarningMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pWarningMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pWarningMsg->hresult = hresult;
	pWarningMsg->dwUserDataSize = dwUserDataSize;

	if (pvUserData != NULL)
		CopyMemory((pWarningMsg + 1), pvUserData, dwUserDataSize);


	// Send the warning message to the other side.
	hr = this->SendBuffer(pWarningMsg, dwWarningMsgSize, IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send warning message!", 0);
	} // end if (couldn't send message)


DONE:

	this->ReturnMessageBuffers(pWarningMsg, dwWarningMsgSize, NULL, 0);

	return (hr);
} // CTNLeech::WarnOwner
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerCreateSubTest()"
//==================================================================================
// CTNLeech::HaveOwnerCreateSubTest
//----------------------------------------------------------------------------------
//
// Description: Requests that the owner create the given subtest (to maintain
//				parity) and assign it an ID.
//				This function blocks until the top level slave has announced this
//				test to the master and received a reply.
//				The ID will be filled out upon successful function exit.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to subtest to have owner create.
//	int iNumMachines			Number of integers in the following array.
//	PTNCTRLMACHINEID aTesters	Array of IDs indicating the testers in their
//								respective testing positions for the new test.
//
// Returns: None.
//==================================================================================
HRESULT CTNLeech::HaveOwnerCreateSubTest(PTNTESTINSTANCES pTest, int iNumMachines,
										PTNCTRLMACHINEID aTesters)
{
	HRESULT						hr;
	PTNTESTINSTANCES			pTopLevelTest = NULL;
	PTNTESTINSTANCES			pParentTest = NULL;
	DWORD						dwCreateSubTestMsgSize = 0;
	PLEECHMSG_CREATESUBTEST		pCreateSubTestMsg = NULL;
	DWORD*						pdwReplyBuffer = NULL;
	DWORD						dwReplyBufferSize = 0;
	LPBYTE						lpCurrent;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!", 1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)

	//BUGBUG what about poke mode?  will they have parent tests?
	pParentTest = (PTNTESTINSTANCES) pTest->m_pParentTest;
	if (pParentTest == NULL)
	{
		DPL(0, "No parent test for test ID %u!", 1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (no parent test)


	dwCreateSubTestMsgSize = sizeof (LEECHMSG_CREATESUBTEST)
							+ strlen(pTest->m_pCase->m_pszID) + 1
							+ (iNumMachines * sizeof (TNCTRLMACHINEID));

	DPL(7, "Requesting new test ID for case \"%s\".", 1, pTest->m_pCase->m_pszID);

	hr = this->PrepareSendBuffer(LEECHMSGID_CREATESUBTEST,
								(PVOID*) &pCreateSubTestMsg,
								dwCreateSubTestMsgSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pCreateSubTestMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pCreateSubTestMsg->dwParentUniqueID = pParentTest->m_dwUniqueID;
	pCreateSubTestMsg->iNumMachines = iNumMachines;


	lpCurrent = (LPBYTE) (pCreateSubTestMsg + 1);

	CopyAndMoveDestPointer(lpCurrent, pTest->m_pCase->m_pszID, (strlen(pTest->m_pCase->m_pszID) + 1));

	//CopyAndMoveDestPointer(lpCurrent, aTesters, (iNumMachines * sizeof (TNCTRLMACHINEID)));
	CopyMemory(lpCurrent, aTesters, (iNumMachines * sizeof (TNCTRLMACHINEID)));


	// Send the create subtest message to the other side.
	hr = this->SendBufferAndGetReply(pCreateSubTestMsg,
									dwCreateSubTestMsgSize,
									(PVOID*) &pdwReplyBuffer,
									&dwReplyBufferSize,
									INFINITE);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send create subtest message!", 0);
		goto DONE;
	} // end if (couldn't send message)


	if ((pdwReplyBuffer == NULL) || (dwReplyBufferSize != sizeof (DWORD)))
	{
		DPL(0, "Didn't get valid reply data (expected DWORD, got %x, %u)!",
			2, pdwReplyBuffer, dwReplyBufferSize);
		hr = E_FAIL;
		goto DONE;
	} // end if (didn't get valid reply data)

	pTest->m_dwUniqueID = (*pdwReplyBuffer);

	DPL(7, "Got test ID of %u.", 1, pTest->m_dwUniqueID);


DONE:

	this->ReturnMessageBuffers(pCreateSubTestMsg, dwCreateSubTestMsgSize,
								pdwReplyBuffer, dwReplyBufferSize);

	return (hr);
} // CTNLeech::HaveOwnerCreateSubTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerSync()"
//==================================================================================
// CTNLeech::HaveOwnerSync
//----------------------------------------------------------------------------------
//
// Description:    Issues a request to the testmaster to synchronize with specific
//				other machines working on the test (designated in the passed in
//				array).  Data can also be sent to these machines at this time.
//				   A slave is determined to be in-sync when the master has also
//				received sync requests from each of the other testers in the array
//				with the slave specified as a tester to sync with.
//				   This has a domino effect, so that each tester in a slave's sync
//				list must also have heard from all the tester's in its own sync
//				list before marking the first slave as ready.  At that point, the
//				master will fill the return data buffer with the data given by all
//				parties and return with TNSR_INSYNC.
//				   Only one sync attempt is allowed to be outstanding at a time, per
//				unique test ID.  Syncing with your own tester number has no effect.
//				   If this function doesn't return TNSR_INSYNC, it is expected that
//				the test case will end as soon as possible.  Specifically, if
//				TNSR_LOSTTESTER is returned, the test case must not call any Sync
//				or Exec function that requires multiple machines.
//
// Arguments:
//	PTNTESTINSTANCES pTest			Pointer to test to sync under.
//	char* szSyncName				User defined unique name for this sync
//									operation.  Must match on all machines involved.
//	PVOID pvSendData				Pointer to data to send to people to sync with.
//	DWORD dwSendDataSize			Size of data to send to people to sync with.
//	PTNSYNCDATALIST pReceiveData	Pointer to list that will hold the data received
//									from the other synchronizing testers.
//	int iNumMachines				How many testers we're syncing with (i.e. how
//									many integers there are in following array).
//	int* aiTesters					Array of integers indicating the testers to sync
//									with.
//
// Returns: TNSR_INSYNC if successful, or TNSR_xxx error code otherwise.
//==================================================================================
HRESULT CTNLeech::HaveOwnerSync(PTNTESTINSTANCES pTest,
								char* szSyncName,
								PVOID pvSendData,
								DWORD dwSendDataSize,
								PTNSYNCDATALIST pReceiveData,
								int iNumMachines,
								int* aiTesters)
{
	HRESULT					hr;
	PTNTESTINSTANCES		pTopLevelTest;
	DWORD					dwNameSize = 0;
	PLEECHMSG_SYNC			pSyncMsg = NULL;
	DWORD					dwSyncMsgSize = 0;
	PLEECHMSG_SYNCREPLY		pSyncReplyMsg = NULL;
	DWORD					dwSyncReplyMsgSize = 0;
	LPBYTE					lpCurrent;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	dwNameSize = strlen(szSyncName) + 1;

	dwSyncMsgSize = sizeof (LEECHMSG_SYNC)
					+ dwNameSize
					+ (iNumMachines * (sizeof (int)))
					+ dwSendDataSize;

	hr = this->PrepareSendBuffer(LEECHMSGID_SYNC, (PVOID*) &pSyncMsg,
								dwSyncMsgSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pSyncMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pSyncMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pSyncMsg->iNumMachines = iNumMachines;
	pSyncMsg->dwSendDataSize = dwSendDataSize;

	lpCurrent = (LPBYTE) (pSyncMsg + 1);

	CopyAndMoveDestPointer(lpCurrent, szSyncName, dwNameSize);
	CopyAndMoveDestPointer(lpCurrent, aiTesters, (iNumMachines * (sizeof (int))));

	if (pvSendData != NULL)
	{
		//CopyAndMoveDestPointer(lpCurrent, pvSendData, dwSendDataSize);
		CopyMemory(lpCurrent, pvSendData, dwSendDataSize);
	} // end if (there's send data)


	// Send the sync message to the other side.
	hr = this->SendBufferAndGetReply(pSyncMsg,
									dwSyncMsgSize,
									(PVOID*) &pSyncReplyMsg,
									&dwSyncReplyMsgSize,
									INFINITE);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send sync message and get reply!", 0);
		goto DONE;
	} // end if (couldn't send message)

	if (dwSyncReplyMsgSize < sizeof (LEECHMSG_SYNCREPLY))
	{
		DPL(0, "Reply isn't large enough to be a SyncReply message!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (not valid reply)

	// Try to unpack the results, if any.
	if (pSyncReplyMsg->dwSyncDataSize > 0)
	{
		hr = pReceiveData->UnpackFromBuffer((pSyncReplyMsg + 1),
											pSyncReplyMsg->dwSyncDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack received sync data buffer!", 0);
			goto DONE;
		} // end if (couldn't unpack buffer)
	} // end if (there's sync reply data)

	// Now return the result that was generated by the call.
	hr = pSyncReplyMsg->hrResult;


DONE:

	this->ReturnMessageBuffers(pSyncMsg, dwSyncMsgSize,
								pSyncReplyMsg, dwSyncReplyMsgSize);

	return (hr);
} // CTNLeech::HaveOwnerSync
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerCheckIfTesterOnMachine()"
//==================================================================================
// CTNLeech::HaveOwnerCheckIfTesterOnMachine
//----------------------------------------------------------------------------------
//
// Description: Checks if the specified tester is located on the same machine.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test requesting info.
//	int iTesterNum				Tester number for which to retrieve IP address.
//	WORD wPort					IP port to verify reachability.
//	char* szIPString			String to store results in (must be 16 chars).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
BOOL CTNLeech::HaveOwnerCheckIfTesterOnMachine(PTNTESTINSTANCES pTest,
												int iTesterNum)
{
	BOOL							fResult = FALSE;
	HRESULT							hr;
	PTNTESTINSTANCES				pTopLevelTest;
	PLEECHMSG_ISTESTERONMACHINE		pIsTesterOnMachineMsg = NULL;
	BOOL*							pfBool = NULL;
	DWORD							dwBoolSize = 0;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		goto DONE;
	} // end if (couldn't get top level test)


	hr = this->PrepareSendBuffer(LEECHMSGID_ISTESTERONMACHINE,
								(PVOID*) &pIsTesterOnMachineMsg,
								sizeof (LEECHMSG_ISTESTERONMACHINE));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!  %e", 1, hr);
		goto DONE;
	} // end if (couldn't allocate memory)

	pIsTesterOnMachineMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pIsTesterOnMachineMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pIsTesterOnMachineMsg->iTesterNum = iTesterNum;

	// Send the GetTesterIP message to the other side.
	hr = this->SendBufferAndGetReply(pIsTesterOnMachineMsg,
									sizeof (LEECHMSG_ISTESTERONMACHINE),
									(PVOID*) &pfBool,
									&dwBoolSize,
									INFINITE);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send IsTesterOnMachine message and get reply!", 0);
		goto DONE;
	} // end if (couldn't send message)

	// Make sure it's a valid reply.
	if ((pfBool == NULL) || (dwBoolSize != sizeof (BOOL)))
	{
		DPL(0, "Didn't get valid reply data (%x is NULL, %u != %u)!",
			3, pfBool, dwBoolSize, sizeof (BOOL));
		goto DONE;
	} // end if (didn't get valid reply data)
	
	fResult = (*pfBool);


DONE:

	this->ReturnMessageBuffers(pIsTesterOnMachineMsg,
								sizeof (LEECHMSG_ISTESTERONMACHINE),
								pfBool,
								dwBoolSize);

	return (fResult);
} // CTNLeech::HaveOwnerCheckIfTesterOnMachine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerGetTesterIP()"
//==================================================================================
// CTNLeech::HaveOwnerGetTesterIP
//----------------------------------------------------------------------------------
//
// Description: Retrieves the IP address of the specified tester and places it in
//				the passed in string buffer.  The buffer must be at least 15
//				characters + NULL termination long.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test requesting info.
//	int iTesterNum				Tester number for which to retrieve IP address.
//	WORD wPort					IP port to verify reachability.
//	char* szIPString			String to store results in (must be 16 chars).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::HaveOwnerGetTesterIP(PTNTESTINSTANCES pTest,
									int iTesterNum, WORD wPort,
									char* szIPString)
{
	HRESULT					hr;
	PTNTESTINSTANCES		pTopLevelTest;
	PLEECHMSG_GETTESTERIP	pGetTesterIPMsg = NULL;
	char*					pszIPString = NULL;
	DWORD					dwIPStringSize = 0;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	hr = this->PrepareSendBuffer(LEECHMSGID_GETTESTERIP, (PVOID*) &pGetTesterIPMsg,
								sizeof (LEECHMSG_GETTESTERIP));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pGetTesterIPMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pGetTesterIPMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pGetTesterIPMsg->iTesterNum = iTesterNum;
	pGetTesterIPMsg->wPort = wPort;

	// Send the GetTesterIP message to the other side.
	hr = this->SendBufferAndGetReply(pGetTesterIPMsg,
									sizeof (LEECHMSG_GETTESTERIP),
									(PVOID*) &pszIPString,
									&dwIPStringSize,
									INFINITE);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send GetTesterIP message and get reply!", 0);
		goto DONE;
	} // end if (couldn't send message)

	// Make sure it's a valid reply.
	// 8 = 0.0.0.0 + NULL termination, 16 = 255.255.255.255 + NULL termination.
	if ((pszIPString == NULL) || (dwIPStringSize < 8) || (dwIPStringSize > 16))
	{
		DPL(0, "Didn't get valid reply data (%x is NULL, %u <8 or >16)!",
			2, pszIPString, dwIPStringSize);
		hr = E_FAIL;
		goto DONE;
	} // end if (didn't get valid reply data)
	
	CopyMemory(szIPString, pszIPString, dwIPStringSize);


DONE:

	this->ReturnMessageBuffers(pGetTesterIPMsg, sizeof (LEECHMSG_GETTESTERIP),
								pszIPString, dwIPStringSize);

	return (hr);
} // CTNLeech::HaveOwnerGetTesterIP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerGetTesterPhoneNum()"
//==================================================================================
// CTNLeech::HaveOwnerGetTesterPhoneNum
//----------------------------------------------------------------------------------
//
// Description: Requests the phone number for the specified tester, and returns
//				the result in the string buffer given.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test requesting info.
//	int iTesterNum				Tester number for which to retrieve COM port.
//	char* szPhoneNumber			Place to store result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::HaveOwnerGetTesterPhoneNum(PTNTESTINSTANCES pTest,
											int iTesterNum, char* szPhoneNumber)
{
	HRESULT								hr;
	PTNTESTINSTANCES					pTopLevelTest;
	PLEECHMSG_GETTESTERPHONENUM			pGetTesterPhoneNumMsg = NULL;
	PLEECHMSG_GETTESTERPHONENUMREPLY	pReplyMsg = NULL;
	DWORD								dwReplyMsgSize = 0;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	hr = this->PrepareSendBuffer(LEECHMSGID_GETTESTERPHONENUM,
								(PVOID*) &pGetTesterPhoneNumMsg,
								sizeof (LEECHMSG_GETTESTERPHONENUM));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pGetTesterPhoneNumMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pGetTesterPhoneNumMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pGetTesterPhoneNumMsg->iTesterNum = iTesterNum;

	// Send the GetTesterPhoneNum message to the other side.
	hr = this->SendBufferAndGetReply(pGetTesterPhoneNumMsg,
									sizeof (LEECHMSG_GETTESTERPHONENUM),
									(PVOID*) &pReplyMsg,
									&dwReplyMsgSize,
									INFINITE);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send GetTesterCOMPort message and get reply!", 0);
		goto DONE;
	} // end if (couldn't send message)

	// Make sure it's a valid reply.
	if ((pReplyMsg == NULL) || (dwReplyMsgSize < sizeof (LEECHMSG_GETTESTERPHONENUMREPLY)))
	{
		DPL(0, "Didn't get valid reply data (%x is NULL, %u < %u)!",
			3, pReplyMsg, dwReplyMsgSize,
			sizeof (LEECHMSG_GETTESTERPHONENUMREPLY));
		hr = E_FAIL;
		goto DONE;
	} // end if (didn't get valid reply data)
	
	hr = pReplyMsg->hrResult;
	if (hr == S_OK)
		strcpy(szPhoneNumber, (char*) (pReplyMsg + 1));


DONE:

	this->ReturnMessageBuffers(pGetTesterPhoneNumMsg,
								sizeof (LEECHMSG_GETTESTERPHONENUM),
								pReplyMsg, dwReplyMsgSize);

	return (hr);
} // CTNLeech::HaveOwnerGetTesterPhoneNum
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerGetTesterCOMPort()"
//==================================================================================
// CTNLeech::HaveOwnerGetTesterCOMPort
//----------------------------------------------------------------------------------
//
// Description: Requests the COM port connected to the specified tester, and returns
//				the result in the DWORD pointer given.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve COM port.
//	DWORD* pdwCOMPort		Place to store result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::HaveOwnerGetTesterCOMPort(PTNTESTINSTANCES pTest,
											int iTesterNum, DWORD* pdwCOMPort)
{
	HRESULT								hr;
	PTNTESTINSTANCES					pTopLevelTest;
	PLEECHMSG_GETTESTERCOMPORT			pGetTesterCOMPortMsg = NULL;
	PLEECHMSG_GETTESTERCOMPORTREPLY		pReplyMsg = NULL;
	DWORD								dwReplyMsgSize = 0;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	hr = this->PrepareSendBuffer(LEECHMSGID_GETTESTERCOMPORT,
								(PVOID*) &pGetTesterCOMPortMsg,
								sizeof (LEECHMSG_GETTESTERCOMPORT));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pGetTesterCOMPortMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pGetTesterCOMPortMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pGetTesterCOMPortMsg->iTesterNum = iTesterNum;

	// Send the GetTesterCOMPort message to the other side.
	hr = this->SendBufferAndGetReply(pGetTesterCOMPortMsg,
									sizeof (LEECHMSG_GETTESTERCOMPORT),
									(PVOID*) &pReplyMsg,
									&dwReplyMsgSize,
									INFINITE);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send GetTesterCOMPort message and get reply!", 0);
		goto DONE;
	} // end if (couldn't send message)

	// Make sure it's a valid reply.
	if ((pReplyMsg == NULL) || (dwReplyMsgSize != sizeof (LEECHMSG_GETTESTERCOMPORTREPLY)))
	{
		DPL(0, "Didn't get valid reply data (%x is NULL, %u != %u)!",
			3, pReplyMsg, dwReplyMsgSize,
			sizeof (LEECHMSG_GETTESTERCOMPORTREPLY));
		hr = E_FAIL;
		goto DONE;
	} // end if (didn't get valid reply data)
	
	hr = pReplyMsg->hrResult;
	(*pdwCOMPort) = pReplyMsg->dwCOMPort;


DONE:

	this->ReturnMessageBuffers(pGetTesterCOMPortMsg,
								sizeof (LEECHMSG_GETTESTERCOMPORT),
								pReplyMsg, dwReplyMsgSize);

	return (hr);
} // CTNLeech::HaveOwnerGetTesterCOMPort
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerFreeResults()"
//==================================================================================
// CTNLeech::HaveOwnerFreeResults
//----------------------------------------------------------------------------------
//
// Description: Has the owner free results matching the given criteria.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test freeing results.
//	char* pszCaseID			Case ID to match, or NULL for all.
//	char* pszInstanceID		Instance ID to match, or NULL for all.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::HaveOwnerFreeResults(PTNTESTINSTANCES pTest, char* pszCaseID,
										char* pszInstanceID)
{
	HRESULT					hr;
	PTNTESTINSTANCES		pTopLevelTest;
	PLEECHMSG_FREERESULTS	pFreeResultsMsg = NULL;
	DWORD					dwMsgSize = 0;
	LPBYTE					lpCurrent;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	dwMsgSize = sizeof (LEECHMSG_FREERESULTS);
	if (pszCaseID != NULL)
		dwMsgSize += strlen(pszCaseID) + 1;
	if (pszInstanceID != NULL)
		dwMsgSize += strlen(pszInstanceID) + 1;

	hr = this->PrepareSendBuffer(LEECHMSGID_FREERESULTS,
								(PVOID*) &pFreeResultsMsg,
								dwMsgSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)


	pFreeResultsMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pFreeResultsMsg->dwTestUniqueID = pTest->m_dwUniqueID;

	lpCurrent = (LPBYTE) (pFreeResultsMsg + 1);

	if (pszCaseID != NULL)
	{
		pFreeResultsMsg->dwCaseIDSize = strlen(pszCaseID) + 1;
		CopyAndMoveDestPointer(lpCurrent, pszCaseID,
								pFreeResultsMsg->dwCaseIDSize);
	} // end if (there's a case ID)

	if (pszInstanceID != NULL)
	{
		pFreeResultsMsg->dwInstanceIDSize = strlen(pszInstanceID) + 1;
		CopyAndMoveDestPointer(lpCurrent, pszInstanceID,
								pFreeResultsMsg->dwInstanceIDSize);
	} // end if (there's an instance ID)

	// Send the FreeResults message to the other side.
	hr = this->SendBuffer(pFreeResultsMsg, dwMsgSize, IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send FreeResults message!", 0);
		goto DONE;
	} // end if (couldn't send message)


DONE:

	this->ReturnMessageBuffers(pFreeResultsMsg, dwMsgSize, NULL, NULL);

	return (hr);
} // CTNLeech::HaveOwnerFreeResults
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerFreeOutputVars()"
//==================================================================================
// CTNLeech::HaveOwnerFreeOutputVars
//----------------------------------------------------------------------------------
//
// Description: Has the owner free output vars matching the given criteria.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test freeing output vars.
//	char* pszCaseID			Case ID to match, or NULL for all.
//	char* pszInstanceID		Instance ID to match, or NULL for all.
//	char* pszName			Output variable name to match, or NULL for all.
//	char* pszType			Output variable type to match, or NULL for all.
//	BOOL fFreeData			Whether to free the output data, if no vars.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::HaveOwnerFreeOutputVars(PTNTESTINSTANCES pTest, char* pszCaseID,
										char* pszInstanceID, char* pszName,
										char* pszType, BOOL fFreeData)
{
	HRESULT						hr;
	PTNTESTINSTANCES			pTopLevelTest;
	PLEECHMSG_FREEOUTPUTVARS	pFreeOutputVarsMsg = NULL;
	DWORD						dwMsgSize = 0;
	LPBYTE						lpCurrent;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	dwMsgSize = sizeof (LEECHMSG_FREEOUTPUTVARS);
	if (pszCaseID != NULL)
		dwMsgSize += strlen(pszCaseID) + 1;
	if (pszInstanceID != NULL)
		dwMsgSize += strlen(pszInstanceID) + 1;
	if (pszName != NULL)
		dwMsgSize += strlen(pszName) + 1;
	if (pszType != NULL)
		dwMsgSize += strlen(pszType) + 1;

	hr = this->PrepareSendBuffer(LEECHMSGID_FREEOUTPUTVARS,
								(PVOID*) &pFreeOutputVarsMsg,
								dwMsgSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pFreeOutputVarsMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pFreeOutputVarsMsg->dwTestUniqueID = pTest->m_dwUniqueID;

	lpCurrent = (LPBYTE) (pFreeOutputVarsMsg + 1);

	if (pszCaseID != NULL)
	{
		pFreeOutputVarsMsg->dwCaseIDSize = strlen(pszCaseID) + 1;
		CopyAndMoveDestPointer(lpCurrent, pszCaseID,
								pFreeOutputVarsMsg->dwCaseIDSize);
	} // end if (there's a case ID)

	if (pszInstanceID != NULL)
	{
		pFreeOutputVarsMsg->dwInstanceIDSize = strlen(pszInstanceID) + 1;
		CopyAndMoveDestPointer(lpCurrent, pszInstanceID,
								pFreeOutputVarsMsg->dwInstanceIDSize);
	} // end if (there's an instance ID)

	if (pszName != NULL)
	{
		pFreeOutputVarsMsg->dwNameSize = strlen(pszName) + 1;
		CopyAndMoveDestPointer(lpCurrent, pszName,
								pFreeOutputVarsMsg->dwNameSize);
	} // end if (there's a name)

	if (pszType != NULL)
	{
		pFreeOutputVarsMsg->dwTypeSize = strlen(pszType) + 1;
		CopyAndMoveDestPointer(lpCurrent, pszType,
								pFreeOutputVarsMsg->dwTypeSize);
	} // end if (there's a type)

	pFreeOutputVarsMsg->fFreeData = fFreeData;

	// Send the FreeOutputVars message to the other side.
	hr = this->SendBuffer(pFreeOutputVarsMsg, dwMsgSize, IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send FreeOutputVars message!", 0);
		goto DONE;
	} // end if (couldn't send message)


DONE:

	this->ReturnMessageBuffers(pFreeOutputVarsMsg, dwMsgSize, NULL, NULL);

	return (hr);
} // CTNLeech::HaveOwnerFreeOutputVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveOwnerGetTestersMachineInfo()"
//==================================================================================
// CTNLeech::HaveOwnerGetTestersMachineInfo
//----------------------------------------------------------------------------------
//
// Description: Requests the COM port connected to the specified tester, and returns
//				the result in the DWORD pointer given.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve COM port.
//	DWORD* pdwCOMPort		Place to store result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::HaveOwnerGetTestersMachineInfo(PTNTESTINSTANCES pTest,
												int iTesterNum,
												PTNMACHINEINFO* ppInfo)
{
	HRESULT							hr;
	PTNTESTINSTANCES				pTopLevelTest;
	PLEECHMSG_GETMACHINEINFO		pGetMachineInfoMsg = NULL;
	PLEECHMSG_GETMACHINEINFOREPLY	pReplyMsg = NULL;
	DWORD							dwReplyMsgSize = 0;
	PTNOTHERMACHINEINFO				pInfo = NULL;


	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we got passed a bad pointer)


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!",
			1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	hr = this->PrepareSendBuffer(LEECHMSGID_GETMACHINEINFO,
								(PVOID*) &pGetMachineInfoMsg,
								sizeof (LEECHMSG_GETMACHINEINFO));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto DONE;
	} // end if (couldn't allocate memory)

	pGetMachineInfoMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pGetMachineInfoMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pGetMachineInfoMsg->iTesterNum = iTesterNum;

	// Send the GetMachineInfo message to the other side.
	hr = this->SendBufferAndGetReply(pGetMachineInfoMsg,
									sizeof (LEECHMSG_GETMACHINEINFO),
									(PVOID*) &pReplyMsg,
									&dwReplyMsgSize,
									INFINITE);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send GetMachineInfo message and get reply!", 0);
		goto DONE;
	} // end if (couldn't send message)

	// Make sure it's a valid reply.
	if ((pReplyMsg == NULL) || (dwReplyMsgSize < sizeof (LEECHMSG_GETMACHINEINFOREPLY)))
	{
		DPL(0, "Didn't get valid reply data (%x is NULL, %u < %u)!",
			3, pReplyMsg, dwReplyMsgSize,
			sizeof (LEECHMSG_GETMACHINEINFOREPLY));
		hr = E_FAIL;
		goto DONE;
	} // end if (didn't get valid reply data)
	
	hr = pReplyMsg->hrResult;
	
	if (hr == S_OK)
	{
		pInfo = new (CTNOtherMachineInfo)(&(pTest->m_paTesterSlots[iTesterNum].id));
		if (pInfo == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		hr = pInfo->UnpackFromBuffer((pReplyMsg + 1), pReplyMsg->dwMachineInfoSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unpack machine info!", 0);

			delete (pInfo);
			pInfo = NULL;

			goto DONE;
		} // end if (couldn't unpack machine info)

		// One reference for our caller.
		pInfo->m_dwRefCount++;

		(*ppInfo) = pInfo;
		pInfo = NULL;
	} // end if (succeeded)


DONE:

	this->ReturnMessageBuffers(pGetMachineInfoMsg,
								sizeof (LEECHMSG_GETMACHINEINFO),
								pReplyMsg, dwReplyMsgSize);

	return (hr);
} // CTNLeech::HaveOwnerGetTestersMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HaveLeechRunTest()"
//==================================================================================
// CTNLeech::HaveLeechRunTest
//----------------------------------------------------------------------------------
//
// Description: Requests that the leech on the other side run the given test with
//				the specified input data.  This will block until the leech returns
//				from its ExecCase function.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to run.
//	PVOID pvInputData		Pointer to input data for test.
//	DWORD dwInputDataSize	Size of input data.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::HaveLeechRunTest(PTNTESTINSTANCES pTest, PVOID pvInputData,
								DWORD dwInputDataSize)
{
	HRESULT				hr;
	DWORD				dwCaseIDSize = 0;
	PLEECHMSG_RUNTEST	pRunTestMsg = NULL;
	DWORD				dwRunTestMsgSize = 0;
	LPBYTE				lpCurrent;
	int					i;
	HANDLE				ahWaitObjects[3];
	DWORD				dwNumWaitObjects = 0;


	DPL(9, "==>(%x  [%u], %x, %u)",
		4, pTest, pTest->m_dwUniqueID, pvInputData, dwInputDataSize);

	pTest->m_dwRefCount++; // we're using it

	if (this == NULL)
	{
		DPL(0, "Leech object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (we got passed a bad pointer)

	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Can't use this function with standalone leech!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (not owned by an executor object)


	dwCaseIDSize = strlen(pTest->m_pCase->m_pszID) + 1;

	dwRunTestMsgSize = sizeof (LEECHMSG_RUNTEST)
					+ dwCaseIDSize
					+ (pTest->m_iNumMachines * sizeof (TNCTRLMACHINEID))
					+ dwInputDataSize;

	hr = this->PrepareSendBuffer(LEECHMSGID_RUNTEST, (PVOID*) &pRunTestMsg,
								dwRunTestMsgSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't allocate send buffer!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	pRunTestMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pRunTestMsg->iNumMachines = pTest->m_iNumMachines;
	pRunTestMsg->dwInputDataSize = dwInputDataSize;

	lpCurrent = (LPBYTE) (pRunTestMsg + 1);

	CopyAndMoveDestPointer(lpCurrent, pTest->m_pCase->m_pszID, dwCaseIDSize);

	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
		CopyAndMoveDestPointer(lpCurrent, &(pTest->m_paTesterSlots[i].id),
								sizeof (TNCTRLMACHINEID));
	} // end for (each tester)

	if (dwInputDataSize > 0)
	{
		//CopyAndMoveDestPointer(lpCurrent, pvInputData, dwInputDataSize);
		CopyMemory(lpCurrent, pvInputData, dwInputDataSize);
	} // end if (there's an instance ID)



	// Create an event so we can block until the leech returns from ExecCase.
	pTest->m_hExecCaseExitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pTest->m_hExecCaseExitEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create exec case exit event!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't create event)



	// Send the RunTest message to the other side.
	hr = this->SendBuffer(pRunTestMsg, dwRunTestMsgSize, IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send RunTest message!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't send message)

	this->ReturnMessageBuffers(pRunTestMsg, dwRunTestMsgSize, NULL, 0);



	// Now wait for the leech to return from ExecCase.

	ahWaitObjects[dwNumWaitObjects++] = pTest->m_hExecCaseExitEvent;

	if (this->m_pExecutor->m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_pExecutor->m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


REWAIT:

	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								INFINITE, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Got the ready signal, we're cool.

			hr = S_OK;
		  break;

		case WAIT_OBJECT_0 + 1:
			// Got user cancel event

			DPL(0, "User cancelled waiting for leech to run test!", 0);

			hr = TNWR_USERCANCEL;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		/*
		case WAIT_TIMEOUT:
			DPL(0, "Timed out waiting %i milliseconds for leech to run test!",
				1, PERIODICSENDTHREAD_STARTUP_TIMEOUT);

			hr = TNWR_TIMEOUT;
		  break;
		*/

		default:
			// What?
			DPL(0, "Received unexpected return from WaitForMultipleObjectsEx!", 0);

			if (hr == S_OK)
				hr = E_FAIL;
		  break;
	} // end switch (on wait result)


	CloseHandle(pTest->m_hExecCaseExitEvent);
	pTest->m_hExecCaseExitEvent = NULL;


	pTest->m_dwRefCount--;
	if (pTest->m_dwRefCount == 0)
	{
		DPL(7, "Deleting test %x.", 1, pTest);
		delete (pTest);
		pTest = NULL;
	} // end if (can delete object)
	else
	{
		DPL(7, "Not deleting test %x, its refcount = %u.",
			2, pTest, pTest->m_dwRefCount);
	} // end else (can't delete object)

	DPL(9, "<== %e", 1, hr);

	return (hr);


ERROR_EXIT:

	if (pTest->m_hExecCaseExitEvent != NULL)
	{
		CloseHandle(pTest->m_hExecCaseExitEvent);
		pTest->m_hExecCaseExitEvent = NULL;
	} // end if (have event)

	// If these are NULL, then it's still cool.
	this->ReturnMessageBuffers(pRunTestMsg, dwRunTestMsgSize, NULL, 0);

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNLeech::HaveLeechRunTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::SendLostTesterMsgToOtherSide()"
//==================================================================================
// CTNLeech::SendLostTesterMsgToOtherSide
//----------------------------------------------------------------------------------
//
// Description: Sends a lost tester message to the other side.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test under which a tester was lost.
//	DWORD dwTestUniqueID		ID of test with problem.
//	int iLostTesterNum			Tester number who was lost.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNLeech::SendLostTesterMsgToOtherSide(DWORD dwTopLevelUniqueID,
											DWORD dwTestUniqueID,
											int iLostTesterNum)
{
	HRESULT					hr;
	LEECHMSG_LOSTTESTER		losttestermsg;


	ZeroMemory(&losttestermsg, sizeof (LEECHMSG_LOSTTESTER));
	losttestermsg.dwTopLevelUniqueID = dwTopLevelUniqueID;
	losttestermsg.dwTestUniqueID = dwTestUniqueID;
	losttestermsg.iLostTesterNum = iLostTesterNum;

	hr = this->SendMessage(LEECHMSGID_LOSTTESTER,
							&losttestermsg, sizeof (LEECHMSG_LOSTTESTER),
							IPCOBJ_ACK_WAIT_TIMEOUT);
	if (hr != S_OK)
	{
		DPL(0, "Failed sending LostTester message!", 0);
	} // end if (failed sending message)

	return (hr);
} // CTNLeech::SendLostTesterMsgToOtherSide
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleMessage()"
//==================================================================================
// CTNLeech::HandleMessage
//----------------------------------------------------------------------------------
//
// Description: Handles a non-standard message from the other end of the connection.
//
// Arguments:
//	DWORD dwCommand				ID of command.
//	PVOID pvSentData			Pointer to sent command data, if any.
//	DWORD dwSentDataSize		Size of sent data, if any.
//	PVOID pvReplyData			Pointer to room for reply data.
//	DWORD* pdwReplyDataSize		Pointer to size of reply data buffer.  Should be set
//								to the size used (including 0, if not used) on exit.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleMessage(DWORD dwCommand,
								PVOID pvSentData, DWORD dwSentDataSize,
								PVOID pvReplyData, DWORD* pdwReplyDataSize)
{
	HRESULT		hr;


	switch (dwCommand)
	{
		case LEECHMSGID_LOGSTRING:
			if (dwSentDataSize <= sizeof (LEECHMSG_LOGSTRING))
			{
				DPL(0, "Message too small to be valid LogString message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_LOGSTRING));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleLogStringMsg(((PLEECHMSG_LOGSTRING) pvSentData)->dwLogStringType,
												(char*) (((PLEECHMSG_LOGSTRING) pvSentData) + 1));
				(*pdwReplyDataSize) = 0;
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_REPORT:
			if (dwSentDataSize < sizeof (LEECHMSG_REPORT))
			{
				DPL(0, "Message too small to be valid Report message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_REPORT));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleReportMsg(((PLEECHMSG_REPORT) pvSentData)->dwTopLevelUniqueID,
											((PLEECHMSG_REPORT) pvSentData)->dwTestUniqueID,
											((PLEECHMSG_REPORT) pvSentData)->hresult,
											((PLEECHMSG_REPORT) pvSentData)->fTestComplete,
											((PLEECHMSG_REPORT) pvSentData)->fSuccess,
											((PLEECHMSG_REPORT) pvSentData)->fExecCaseExitReport,
											((PLEECHMSG_REPORT) pvSentData)->dwOutputDataSize,
											((PLEECHMSG_REPORT) pvSentData)->dwOutputVarsSize,
											(((PLEECHMSG_REPORT) pvSentData) + 1));
				(*pdwReplyDataSize) = 0;
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_WARNING:
			if (dwSentDataSize < sizeof (LEECHMSG_WARNING))
			{
				DPL(0, "Message too small to be valid Warning message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_WARNING));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleWarningMsg(((PLEECHMSG_WARNING) pvSentData)->dwTopLevelUniqueID,
											((PLEECHMSG_WARNING) pvSentData)->dwTestUniqueID,
											((PLEECHMSG_WARNING) pvSentData)->hresult,
											((((PLEECHMSG_WARNING) pvSentData)->dwUserDataSize > 0) ? (((PLEECHMSG_WARNING) pvSentData) + 1) : NULL),
											((PLEECHMSG_WARNING) pvSentData)->dwUserDataSize);
				(*pdwReplyDataSize) = 0;
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_CREATESUBTEST:
			if (dwSentDataSize < sizeof (LEECHMSG_CREATESUBTEST))
			{
				DPL(0, "Message too small to be valid CreateSubTest message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_CREATESUBTEST));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleCreateSubTestMsg(((PLEECHMSG_CREATESUBTEST) pvSentData)->dwTopLevelUniqueID,
												((PLEECHMSG_CREATESUBTEST) pvSentData)->dwParentUniqueID,
												((PLEECHMSG_CREATESUBTEST) pvSentData)->iNumMachines,													
												(((PLEECHMSG_CREATESUBTEST) pvSentData) + 1),
												(DWORD*) pvReplyData);

				(*pdwReplyDataSize) = sizeof (DWORD);
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_SYNC:
			if (dwSentDataSize < sizeof (LEECHMSG_SYNC))
			{
				DPL(0, "Message too small to be valid Sync message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_SYNC));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleSyncMsg(((PLEECHMSG_SYNC) pvSentData)->dwTopLevelUniqueID,
										((PLEECHMSG_SYNC) pvSentData)->dwTestUniqueID,
										((PLEECHMSG_SYNC) pvSentData)->iNumMachines,													
										((PLEECHMSG_SYNC) pvSentData)->dwSendDataSize,													
										(((PLEECHMSG_SYNC) pvSentData) + 1),
										pvReplyData,
										pdwReplyDataSize);
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_ISTESTERONMACHINE:
			if (dwSentDataSize < sizeof (LEECHMSG_ISTESTERONMACHINE))
			{
				DPL(0, "Message too small to be valid IsTesterOnMachine message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_ISTESTERONMACHINE));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleIsTesterOnMachineMsg(((PLEECHMSG_ISTESTERONMACHINE) pvSentData)->dwTopLevelUniqueID,
													((PLEECHMSG_ISTESTERONMACHINE) pvSentData)->dwTestUniqueID,
													((PLEECHMSG_ISTESTERONMACHINE) pvSentData)->iTesterNum,													
													(BOOL*) pvReplyData);
				(*pdwReplyDataSize) = sizeof (BOOL);
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_GETTESTERIP:
			if (dwSentDataSize < sizeof (LEECHMSG_GETTESTERIP))
			{
				DPL(0, "Message too small to be valid GetTesterIP message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_GETTESTERIP));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleGetTesterIPMsg(((PLEECHMSG_GETTESTERIP) pvSentData)->dwTopLevelUniqueID,
												((PLEECHMSG_GETTESTERIP) pvSentData)->dwTestUniqueID,
												((PLEECHMSG_GETTESTERIP) pvSentData)->iTesterNum,													
												((PLEECHMSG_GETTESTERIP) pvSentData)->wPort,													
												(char*) pvReplyData,
												pdwReplyDataSize);
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_GETTESTERPHONENUM:
			if (dwSentDataSize < sizeof (LEECHMSG_GETTESTERPHONENUM))
			{
				DPL(0, "Message too small to be valid GetTesterPhoneNum message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_GETTESTERPHONENUM));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleGetTesterPhoneNumMsg(((PLEECHMSG_GETTESTERPHONENUM) pvSentData)->dwTopLevelUniqueID,
													((PLEECHMSG_GETTESTERPHONENUM) pvSentData)->dwTestUniqueID,
													((PLEECHMSG_GETTESTERPHONENUM) pvSentData)->iTesterNum,													
													(char*) pvReplyData,
													pdwReplyDataSize);
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_GETTESTERCOMPORT:
			if (dwSentDataSize < sizeof (LEECHMSG_GETTESTERCOMPORT))
			{
				DPL(0, "Message too small to be valid GetTesterCOMPort message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_GETTESTERCOMPORT));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleGetTesterCOMPortMsg(((PLEECHMSG_GETTESTERCOMPORT) pvSentData)->dwTopLevelUniqueID,
													((PLEECHMSG_GETTESTERCOMPORT) pvSentData)->dwTestUniqueID,
													((PLEECHMSG_GETTESTERCOMPORT) pvSentData)->iTesterNum,													
													pvReplyData);
				(*pdwReplyDataSize) = sizeof (LEECHMSG_GETTESTERCOMPORTREPLY);
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_FREERESULTS:
			if (dwSentDataSize < sizeof (LEECHMSG_FREERESULTS))
			{
				DPL(0, "Message too small to be valid FreeResults message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_FREERESULTS));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleFreeResultsMsg(((PLEECHMSG_FREERESULTS) pvSentData)->dwTopLevelUniqueID,
												((PLEECHMSG_FREERESULTS) pvSentData)->dwTestUniqueID,
												((PLEECHMSG_FREERESULTS) pvSentData)->dwCaseIDSize,
												((PLEECHMSG_FREERESULTS) pvSentData)->dwInstanceIDSize,
												((LPBYTE) pvSentData) + sizeof (LEECHMSG_FREERESULTS));
				(*pdwReplyDataSize) = 0;
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_FREEOUTPUTVARS:
			if (dwSentDataSize < sizeof (LEECHMSG_FREEOUTPUTVARS))
			{
				DPL(0, "Message too small to be valid FreeOutputVars message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_FREEOUTPUTVARS));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleFreeOutputVarsMsg(((PLEECHMSG_FREEOUTPUTVARS) pvSentData)->dwTopLevelUniqueID,
													((PLEECHMSG_FREEOUTPUTVARS) pvSentData)->dwTestUniqueID,
													((PLEECHMSG_FREEOUTPUTVARS) pvSentData)->dwCaseIDSize,
													((PLEECHMSG_FREEOUTPUTVARS) pvSentData)->dwInstanceIDSize,
													((PLEECHMSG_FREEOUTPUTVARS) pvSentData)->dwNameSize,
													((PLEECHMSG_FREEOUTPUTVARS) pvSentData)->dwTypeSize,
													((PLEECHMSG_FREEOUTPUTVARS) pvSentData)->fFreeData,
													((LPBYTE) pvSentData) + sizeof (LEECHMSG_FREEOUTPUTVARS));
				(*pdwReplyDataSize) = 0;
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_RUNTEST:
			if (dwSentDataSize < sizeof (LEECHMSG_RUNTEST))
			{
				DPL(0, "Message too small to be valid RunTest message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_RUNTEST));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleRunTestMsg(((PLEECHMSG_RUNTEST) pvSentData)->dwTestUniqueID,
											((PLEECHMSG_RUNTEST) pvSentData)->iNumMachines,
											((PLEECHMSG_RUNTEST) pvSentData)->dwInputDataSize,													
											(((PLEECHMSG_RUNTEST) pvSentData) + 1));
				(*pdwReplyDataSize) = 0;
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_GETMACHINEINFO:
			if (dwSentDataSize < sizeof (LEECHMSG_GETMACHINEINFO))
			{
				DPL(0, "Message too small to be valid GetMachineInfo message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_GETMACHINEINFO));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleGetMachineInfoMsg(((PLEECHMSG_GETMACHINEINFO) pvSentData)->dwTopLevelUniqueID,
													((PLEECHMSG_GETMACHINEINFO) pvSentData)->dwTestUniqueID,
													((PLEECHMSG_GETMACHINEINFO) pvSentData)->iTesterNum,													
													pvReplyData,
													pdwReplyDataSize);
			} // end else (message appears to be valid)
		  break;

		case LEECHMSGID_LOSTTESTER:
			if (dwSentDataSize < sizeof (LEECHMSG_LOSTTESTER))
			{
				DPL(0, "Message too small to be valid LostTester message (%u <= %u)!",
					2, dwSentDataSize, sizeof (LEECHMSG_LOSTTESTER));
				hr = E_FAIL;
			} // end if (message too small)
			else
			{
				hr = this->HandleLostTesterMsg(((PLEECHMSG_LOSTTESTER) pvSentData)->dwTopLevelUniqueID,
												((PLEECHMSG_LOSTTESTER) pvSentData)->dwTestUniqueID,
												((PLEECHMSG_LOSTTESTER) pvSentData)->iLostTesterNum);
				(*pdwReplyDataSize) = 0;
			} // end else (message appears to be valid)
		  break;

		default:
			DPL(0, "Unrecognized message type %u!", 1, dwCommand);
			hr = E_FAIL;

			(*pdwReplyDataSize) = 0;
		  break;
	} // end switch (on command)

	return (hr);
} // CTNLeech::HandleMessage
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleDisconnect()"
//==================================================================================
// CTNLeech::HandleDisconnect
//----------------------------------------------------------------------------------
//
// Description: Handles a disconnection by the other side.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleDisconnect(void)
{
	HRESULT		hr = S_OK;
	HWND		hWnd = NULL;


	// Make sure the test thread is going down.
	if (this->m_fOwnerCopy)
	{
		DPL(0, "WARNING: Got disconnect message on owner side!", 0);

#pragma TODO(vanceo, "handle issues")
	} // end if (this is owner side)
	else
	{
		hr = this->m_pExecutor->KillTestThread(FALSE);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't kill test thread!  %e", 1, hr);

			// Note: continuing...
			//goto DONE;

		} // end if (couldn't kill test thread)

		if (this->m_pExecutor->m_pfnGetTestingWindow != NULL)
		{
			hr = this->m_pExecutor->m_pfnGetTestingWindow(&hWnd);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't get testing window!  %e", 1, hr);

				// Note: continuing...
				//goto DONE;

			} // end if (couldn't get window)
			else
			{
				DPL(1, "Closing window %x because leech %x (\"%s\") was disconnected.",
					3, hWnd, this, this->m_pszAttachPointID);

				if (! PostMessage(hWnd, WM_CLOSE, 0, 0))
				{
					hr = GetLastError();
					DPL(0, "Couldn't post Close message to %x!", 1, hWnd);
				} // end if (couldn't post close message)
			} // end else (did get window)
		} // end if (have window to post)
	} // end else (this is process side)

	return (hr);
} // CTNLeech::HandleDisconnect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleLogStringMsg()"
//==================================================================================
// CTNLeech::HandleLogStringMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request to log a string.
//
// Arguments:
//	DWORD dwCommand		ID of command.
//	LPVOID lpvData		Pointer to command data, if any.
//	DWORD dwDataSize	Size of data, if any.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleLogStringMsg(DWORD dwLogStringType, char* szString)
{
	HRESULT		hr;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to log a string?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	hr = this->m_pExecutor->LogInternal(dwLogStringType, szString);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't log string?", 0);
	} // end if (failed logging)

	return (hr);
} // CTNLeech::HandleLogStringMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleReportMsg()"
//==================================================================================
// CTNLeech::HandleReportMsg
//----------------------------------------------------------------------------------
//
// Description: Handles an incoming report.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test for report.
//	DWORD dwTestUniqueID		ID of test generating report.
//	HRESULT hresult				Result code of report.
//	BOOL fTestComplete			Whether the report indicates completion or not.
//	BOOL fSuccess				Whether the report indicates sucess or not.
//	BOOL fExecCaseExitReport	Is this the report automatically generated when the
//								ExecCase function returns?
//	DWORD dwOutputDataSize		Size of output data, if any.
//	DWORD dwOutputVarsSize		Size of output variables, if any.
//	PVOID pvRemainingData		Pointer to output data & vars buffers, if any.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleReportMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID, 
									HRESULT hresult, BOOL fTestComplete,
									BOOL fSuccess, BOOL fExecCaseExitReport,
									DWORD dwOutputDataSize, DWORD dwOutputVarsSize,
									PVOID pvRemainingData)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTest = NULL;
	PTNRESULT			pResult = NULL;
	PVOID				pvOutputData = NULL;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a report?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't find leech test corresponding to ID %u:%u!",
			2, dwTopLevelUniqueID, dwTestUniqueID);
		return (ERROR_INVALID_PARAMETER);
	} // end if (we don't know about this test)


	// Intercept this report, and duplicate it in our owner's list.

	// Create the report object.
	pResult = this->m_pExecutor->m_results.NewResult(pTest);
	if (pResult == NULL)
	{
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate object)

	// Store the results
	hr = pResult->SetResultCodeAndBools(hresult, fTestComplete, fSuccess);
	if (pResult == NULL)
	{
		DPL(0, "Couldn't set result code and booleans!", 0);
		return (hr);
	} // end if (couldn't allocate object))

	// Store the output data and output variables
	if (dwOutputDataSize > 0)
	{
		pvOutputData = pResult->CreateOutputDataBuffer(dwOutputDataSize);
		if (pvOutputData == NULL)
		{
			return (E_OUTOFMEMORY);
		} // end if (couldn't allocate memory)

		CopyMemory(pvOutputData, pvRemainingData, dwOutputDataSize);

		if (dwOutputVarsSize > 0)
		{
			hr = pResult->m_vars.UnpackFromBuffer(((LPBYTE) pvRemainingData) + dwOutputDataSize,
													dwOutputVarsSize);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't unpack output variables!", 0);
				return (hr);
			} // end if (couldn't unpack temp vars from buffer)
		} // end if (there are output vars)
	} // end if (there is output data)

	hr = this->m_pExecutor->ReportInternal(pTest, hresult, fTestComplete,
											fSuccess, fExecCaseExitReport,
											pvOutputData, dwOutputDataSize,
											((dwOutputVarsSize > 0) ? (&pResult->m_vars) : NULL));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send report!", 0);
	} // end if (failed reporting)

	return (hr);
} // CTNLeech::HandleReportMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleWarningMsg()"
//==================================================================================
// CTNLeech::HandleWarningMsg
//----------------------------------------------------------------------------------
//
// Description: Handles an incoming warning.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test for warning.
//	DWORD dwTestUniqueID		ID of test generating warning.
//	HRESULT hresult				Result code of warning.
//	PVOID pvUserData			Pointer to user data, if any.
//	DWORD dwUserDataSize		Size of user data, if any.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleWarningMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID, 
									HRESULT hresult, PVOID pvUserData,
									DWORD dwUserDataSize)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTest = NULL;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a warning?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't find leech test corresponding to ID %u:%u!",
			2, dwTopLevelUniqueID, dwTestUniqueID);
		return (ERROR_INVALID_PARAMETER);
	} // end if (we don't know about this test)


	hr = this->m_pExecutor->WarnInternal(pTest, hresult, pvUserData, dwUserDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't send warning!", 0);
	} // end if (failed warning)

	return (hr);
} // CTNLeech::HandleWarningMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleCreateSubTestMsg()"
//==================================================================================
// CTNLeech::HandleCreateSubTestMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request to create a subtest.
//
// Arguments:
//	DWORD dwTopLevelUniqueID		ID of top level test to create under.
//	DWORD dwParentUniqueID			ID of parent test to create under.
//	int iNumMachines				Number of testers in tester array.
//	PVOID pvRemainingData			Pointer to case string and tester array data.
//	DWORD* pdwAssignedUniqueID		Pointer to place to store ID assigned to new
//									test.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleCreateSubTestMsg(DWORD dwTopLevelUniqueID,
										DWORD dwParentUniqueID,
										int iNumMachines,													
										PVOID pvRemainingData,
										DWORD* pdwAssignedUniqueID)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pParentTest = NULL;
	char*				pszCaseID = NULL;
	PTNTESTTABLECASE	pCase = NULL;
	PTNCTRLMACHINEID	paTesters = NULL;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to create a subtest?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pParentTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID,
													dwParentUniqueID);
	if (pParentTest == NULL)
	{
		DPL(0, "Couldn't get parent leech test ID %u (under ID %u)!",
			2, dwParentUniqueID, dwTopLevelUniqueID);
		return (E_FAIL);
	} // end if (couldn't find parent test with given ID)

	pszCaseID = (char*) pvRemainingData;

	pCase = this->m_pExecutor->m_testtable.GetTest(pszCaseID);
	if (pCase == NULL)
	{
		DPL(0, "Couldn't get test case %s!", 1, pszCaseID);
		return (E_FAIL);
	} // end if (couldn't get case)

	paTesters = (PTNCTRLMACHINEID) (pszCaseID + strlen(pszCaseID) + 1);

	hr = this->m_pExecutor->CreateSubTest(pParentTest, pCase, iNumMachines,
										paTesters);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't create subtest!", 0);
	} // end if (creating subtest failed)

	(*pdwAssignedUniqueID) = pParentTest->m_pSubTest->m_dwUniqueID;

	return (hr);
} // CTNLeech::HandleCreateSubTestMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleSyncMsg()"
//==================================================================================
// CTNLeech::HandleSyncMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request to synchronize under the given test.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test syncing.
//	DWORD dwTestUniqueID		ID of test actually syncing.
//	int iNumMachines			Number of testers in tester array.
//	DWORD dwSendDataSize		Size of send data.
//	PVOID pvRemainingData		Pointer to tester array and send data.
//	PVOID pvReplyData			Pointer to buffer that can hold reply data.
//	DWORD* pdwReplyDataSize		Pointer to place to store size of reply data.
//								Initially holds the max size of the buffer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleSyncMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
								int iNumMachines, DWORD dwSendDataSize,
								PVOID pvRemainingData, PVOID pvReplyData,
								DWORD* pdwReplyDataSize)
{
	HRESULT				hr;
	HRESULT				hrSyncResult;
	PTNTESTINSTANCES	pTest = NULL;
	char*				pszSyncName = NULL;
	int*				paiTesterArray = NULL;
	LPVOID				pvSendData = NULL;
	CTNSyncDataList		receivedata;
	DWORD				dwSyncDataSize;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to sync?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get syncing leech test ID %u (under ID %u)!", 2, dwTestUniqueID,
			dwTopLevelUniqueID);
		return (E_FAIL);
	} // end if (couldn't find parent test with given ID)

	pszSyncName = (char*) pvRemainingData;
	paiTesterArray = (int*) (pszSyncName + strlen(pszSyncName) + 1);

	if (dwSendDataSize > 0)
		pvSendData = ((LPBYTE) paiTesterArray) + (iNumMachines * sizeof (int));

	hrSyncResult = this->m_pExecutor->SyncInternal(pTest,
													pszSyncName,
													pvSendData,
													dwSendDataSize,
													&receivedata,
													iNumMachines,
													paiTesterArray);
	if (hrSyncResult != S_OK)
	{
		DPL(0, "WARNING: Couldn't internally sync!  Returning result via reply buffer.  %e",
			1, hrSyncResult);
	} // end if (syncing failed)


#pragma TODO(vanceo, "It would be nice not to have to unpack and repack every time")

	// Ignore error, assume BUFFER_TOO_SMALL
	receivedata.PackDataForTesterIntoBuffer(-1, NULL, &dwSyncDataSize);

	if (dwSyncDataSize > ((*pdwReplyDataSize) - sizeof (LEECHMSG_SYNCREPLY)))
	{
		DPL(0, "Can't fit sync data into reply buffer!", 0);
		return (ERROR_BUFFER_TOO_SMALL);
	} // end if (can't fit data into buffer)


	((PLEECHMSG_SYNCREPLY) pvReplyData)->hrResult = hrSyncResult;
	((PLEECHMSG_SYNCREPLY) pvReplyData)->dwSyncDataSize = dwSyncDataSize;


	hr = receivedata.PackDataForTesterIntoBuffer(-1,
												(((LPBYTE) pvReplyData) + sizeof (LEECHMSG_SYNCREPLY)),
												&dwSyncDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack sync data into buffer!", 0);
		return (hr);
	} // end if (syncing failed)

	(*pdwReplyDataSize) = sizeof (LEECHMSG_SYNCREPLY) + dwSyncDataSize;

	return (hr);
} // CTNLeech::HandleSyncMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleIsTesterOnMachineMsg()"
//==================================================================================
// CTNLeech::HandleIsTesterOnMachineMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a check if a given tester is on the same machine.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test checking.
//	DWORD dwTestUniqueID		ID of test actually checking.
//	int iTesterNum				Tester number whose IP is to be retrieved.
//	WORD wPort					Port to use when retrieving ID.
//	char* pszReplyString		Pointer to buffer to hold resulting IP string.
//	DWORD* pdwReplyStringSize	Pointer to place to store size of IP string.
//								Initially holds the max size of the buffer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleIsTesterOnMachineMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
											int iTesterNum, BOOL* pfResult)
{
	PTNTESTINSTANCES	pTest = NULL;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to check tester?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get requesting leech test ID %u (under ID %u)!",
			2, dwTestUniqueID, dwTopLevelUniqueID);
		return (E_FAIL);
	} // end if (couldn't find parent test with given ID)

	(*pfResult) = this->m_pExecutor->IsTesterOnSameMachineInternal(pTest, iTesterNum);
	return (S_OK);
} // CTNLeech::HandleIsTesterOnMachineMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleGetTesterIPMsg()"
//==================================================================================
// CTNLeech::HandleGetTesterIPMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request for a tester's IP address under the given test.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test getting the IP address.
//	DWORD dwTestUniqueID		ID of test actually retrieving.
//	int iTesterNum				Tester number whose IP is to be retrieved.
//	WORD wPort					Port to use when retrieving ID.
//	char* pszReplyString		Pointer to buffer to hold resulting IP string.
//	DWORD* pdwReplyStringSize	Pointer to place to store size of IP string.
//								Initially holds the max size of the buffer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleGetTesterIPMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
										int iTesterNum, WORD wPort,
										char* pszReplyString, DWORD* pdwReplyStringSize)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTest = NULL;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to retrieve a tester IP?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get requesting leech test ID %u (under ID %u)!",
			2, dwTestUniqueID, dwTopLevelUniqueID);
		return (E_FAIL);
	} // end if (couldn't find parent test with given ID)

	hr = this->m_pExecutor->GetTesterIPInternal(pTest, iTesterNum, wPort,
												pszReplyString);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get tester IP!", 0);
		return (hr);
	} // end if (getting IP failed)

	(*pdwReplyStringSize) = strlen(pszReplyString) + 1;

	return (hr);
} // CTNLeech::HandleGetTesterIPMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleGetTesterPhoneNumMsg()"
//==================================================================================
// CTNLeech::HandleGetTesterPhoneNumMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request for a tester's phone number under the given test.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test getting the phone number.
//	DWORD dwTestUniqueID		ID of test actually retrieving.
//	int iTesterNum				Tester number whose COM port is to be retrieved.
//	PVOID pvReplyMsg			Pointer to message for reply.  Cast to a
//								LEECHMSG_GETTESTERPHONENUMREPLY pointer.
//	DWORD* pdwReplyMsgSize		Pointer to place to store size of reply message.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleGetTesterPhoneNumMsg(DWORD dwTopLevelUniqueID,
											DWORD dwTestUniqueID,
											int iTesterNum, PVOID pvReplyMsg,
											DWORD* pdwReplyMsgSize)
{
	HRESULT								hr;
	PTNTESTINSTANCES					pTest = NULL;
	PLEECHMSG_GETTESTERPHONENUMREPLY	pReplyMsg = (PLEECHMSG_GETTESTERPHONENUMREPLY) pvReplyMsg;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to retrieve a tester phone number?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get requesting leech test ID %u (under ID %u)!",
			2, dwTestUniqueID, dwTopLevelUniqueID);
		return (E_FAIL);
	} // end if (couldn't find parent test with given ID)

#pragma BUGBUG(vanceo, "Mapping essentially dynamic string to static")

	hr = this->m_pExecutor->GetTesterPhoneNumInternal(pTest, iTesterNum,
													(char*) (pReplyMsg + 1));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get tester phone number!", 0);
		return (hr);
	} // end if (getting phone number failed)

#pragma BUGBUG(vanceo, "Actually use this correctly")
	/*
	if (lpReplyMsg->? == 0)
		lpReplyMsg->hrResult = E_FAIL;
	else
	*/
	{
		pReplyMsg->hrResult = S_OK;
		(*pdwReplyMsgSize) = sizeof (LEECHMSG_GETTESTERPHONENUMREPLY)
							+ strlen((char*) (pReplyMsg + 1)) + 1;
	} // end else (successfull)

	return (hr);
} // CTNLeech::HandleGetTesterPhoneNumMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleGetTesterCOMPortMsg()"
//==================================================================================
// CTNLeech::HandleGetTesterCOMPortMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request for a tester's COM port under the given test.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test getting the COM port.
//	DWORD dwTestUniqueID		ID of test actually retrieving.
//	int iTesterNum				Tester number whose COM port is to be retrieved.
//	PVOID pvReplyMsg			Pointer to message for reply.  Cast to a
//								LEECHMSG_GETTESTERCOMPORTREPLY pointer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleGetTesterCOMPortMsg(DWORD dwTopLevelUniqueID,
											DWORD dwTestUniqueID,
											int iTesterNum, PVOID pvReplyMsg)
{
	HRESULT								hr;
	PTNTESTINSTANCES					pTest = NULL;
	PLEECHMSG_GETTESTERCOMPORTREPLY		pReplyMsg = (PLEECHMSG_GETTESTERCOMPORTREPLY) pvReplyMsg;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to retrieve a tester COM port?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get requesting leech test ID %u (under ID %u)!",
			2, dwTestUniqueID, dwTopLevelUniqueID);
		return (E_FAIL);
	} // end if (couldn't find parent test with given ID)


	hr = this->m_pExecutor->GetTesterCOMPortInternal(pTest, iTesterNum,
													&(pReplyMsg->dwCOMPort));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get tester COM port!", 0);
		return (hr);
	} // end if (getting COM port failed)

#pragma BUGBUG(vanceo, "Actually use this correctly")
	if (pReplyMsg->dwCOMPort == 0)
		pReplyMsg->hrResult = E_FAIL;
	else
		pReplyMsg->hrResult = S_OK;

	return (hr);
} // CTNLeech::HandleGetTesterCOMPortMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleFreeResultsMsg()"
//==================================================================================
// CTNLeech::HandleFreeResultsMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request to free results.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test requesting the freeresults.
//	DWORD dwTestUniqueID		ID of test actually freeing results.
//	DWORD dwCaseIDSize			Size of case ID string, if any.
//	DWORD dwInstanceIDSize		Size of instance ID string, if any.
//	PVOID pvRemainingData		Data buffer containing remaining data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleFreeResultsMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
									DWORD dwCaseIDSize, DWORD dwInstanceIDSize,
									PVOID pvRemainingData)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTest = NULL;
	LPBYTE				lpCurrent;
	char*				pszCaseID = NULL;
	char*				pszInstanceID = NULL;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to free results?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get requesting leech test ID %u (under ID %u)!",
			2, dwTestUniqueID, dwTopLevelUniqueID);
		return (E_FAIL);
	} // end if (couldn't find parent test with given ID)


	lpCurrent = (LPBYTE) pvRemainingData;

	if (dwCaseIDSize > 0)
	{
		pszCaseID = (char*) lpCurrent;
		lpCurrent += dwCaseIDSize;
	} // end if (there's a case ID)

	if (dwInstanceIDSize > 0)
	{
		pszInstanceID = (char*) lpCurrent;
		lpCurrent += dwInstanceIDSize;
	} // end if (there's a case ID)


	// We know it's user called, or else we wouldn't be here.  Pass the specified
	// test in.
	hr = this->m_pExecutor->FreeResultsInternal(pszCaseID, pszInstanceID,
												pTest);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't free results!", 0);
		//return (hr);
	} // end if (freeing results failed)

	return (hr);
} // CTNLeech::HandleFreeResultsMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleFreeOutputVarsMsg()"
//==================================================================================
// CTNLeech::HandleFreeOutputVarsMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request to free output vars.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test requesting the freeoutputvars.
//	DWORD dwTestUniqueID		ID of test actually freeing output vars.
//	DWORD dwCaseIDSize			Size of case ID string, if any.
//	DWORD dwInstanceIDSize		Size of instance ID string, if any.
//	DWORD dwNameSize			Size of variable name string, if any.
//	DWORD dwTypeSize			Size of variable type string, if any.
//	BOOL fFreeData				Whether to remove output data, if no vars.
//	PVOID pvRemainingData		Data buffer containing remaining data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleFreeOutputVarsMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
										DWORD dwCaseIDSize, DWORD dwInstanceIDSize,
										DWORD dwNameSize, DWORD dwTypeSize,
										BOOL fFreeData, PVOID pvRemainingData)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTest = NULL;
	LPBYTE				lpCurrent;
	char*				pszCaseID = NULL;
	char*				pszInstanceID = NULL;
	char*				pszName = NULL;
	char*				pszType = NULL;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to free output vars?", 0);
		return (E_FAIL);
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get requesting leech test ID %u (under ID %u)!",
			2, dwTestUniqueID, dwTopLevelUniqueID);
		return (E_FAIL);
	} // end if (couldn't find parent test with given ID)


	lpCurrent = (LPBYTE) pvRemainingData;

	if (dwCaseIDSize > 0)
	{
		pszCaseID = (char*) lpCurrent;
		lpCurrent += dwCaseIDSize;
	} // end if (there's a case ID)

	if (dwInstanceIDSize > 0)
	{
		pszInstanceID = (char*) lpCurrent;
		lpCurrent += dwInstanceIDSize;
	} // end if (there's a case ID)

	if (dwNameSize > 0)
	{
		pszName = (char*) lpCurrent;
		lpCurrent += dwNameSize;
	} // end if (there's a case ID)

	if (dwTypeSize > 0)
	{
		pszType = (char*) lpCurrent;
		lpCurrent += dwTypeSize;
	} // end if (there's a case ID)


	// We know it's user called, or else we wouldn't be here.  Pass TRUE in.
	hr = this->m_pExecutor->FreeOutputVarsInternal(pszCaseID, pszInstanceID,
													pszName, pszType, fFreeData,
													pTest);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't free output vars!", 0);
		//return (hr);
	} // end if (freeing output vars failed)

	return (hr);
} // CTNLeech::HandleFreeOutputVarsMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleRunTestMsg()"
//==================================================================================
// CTNLeech::HandleRunTestMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request to run a test.
//
// Arguments:
//	DWORD dwTestUniqueID		Unique ID of test to run.
//	int iNumMachines			Number of testers running the instance.
//	DWORD dwInputDataSize		Size of input data buffer.
//	PVOID pvRemainingData		Pointer to buffer containing case ID and input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleRunTestMsg(DWORD dwTestUniqueID, int iNumMachines,
									DWORD dwInputDataSize, PVOID pvRemainingData)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTest = NULL;
	char*				pszCaseID = NULL;
	PTNCTRLMACHINEID	paTesters = NULL;
	PVOID				pvInputData = NULL;


	if (this->m_fOwnerCopy)
	{
		DPL(0, "Not leech side but getting a request to run a test?", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (not leech side)

	pszCaseID = (char*) pvRemainingData;

	paTesters = (PTNCTRLMACHINEID) (pszCaseID + strlen(pszCaseID) + 1);

	if (dwInputDataSize > 0)
		pvInputData = paTesters + iNumMachines;


	hr = this->m_pExecutor->HandleNewTest(dwTestUniqueID, pszCaseID, NULL,
										iNumMachines, paTesters,
										pvInputData, dwInputDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle new test (ID %u)!", 1, dwTestUniqueID);
		goto DONE;
	} // end if (couldn't handle new test)


DONE:

	return (hr);
} // CTNLeech::HandleRunTestMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleGetMachineInfoMsg()"
//==================================================================================
// CTNLeech::HandleGetMachineInfoMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a request for a tester's machine info under the given test.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test to for GetTesterMachineInfo.
//	DWORD dwTestUniqueID		ID of test actually retrieving.
//	int iTesterNum				Tester number whose info is to be retrieved.
//	PVOID pvReplyMsg			Pointer to buffer for reply.  Cast as a
//								PLEECHMSG_GETMACHINEINFOREPLY.
//	DWORD* pdwReplyMsgSize		Pointer to size of reply buffer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleGetMachineInfoMsg(DWORD dwTopLevelUniqueID,
										DWORD dwTestUniqueID,
										int iTesterNum,
										PVOID pvReplyMsg,
										DWORD* pdwReplyMsgSize)
{
	HRESULT							hr;
	HRESULT							hrGetResult;
	PTNTESTINSTANCES				pTest = NULL;
	PTNOTHERMACHINEINFO				pInfo = NULL;
	PLEECHMSG_GETMACHINEINFOREPLY	pReplyMsg = (PLEECHMSG_GETMACHINEINFOREPLY) pvReplyMsg;
	DWORD							dwMachineInfoSize = 0;


	if (! this->m_fOwnerCopy)
	{
		DPL(0, "Not owner side but getting a request to retrieve a tester's info?", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (not owner side)


	pTest = this->m_pExecutor->GetLeechTest(dwTopLevelUniqueID, dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get requesting leech test ID %u (under ID %u)!",
			2, dwTestUniqueID, dwTopLevelUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find parent test with given ID)


	hrGetResult = this->m_pExecutor->GetTestersMachineInfoInternal(pTest,
																	iTesterNum,
																	(PTNMACHINEINFO*) (&pInfo));
	if (hrGetResult != S_OK)
	{
		DPL(0, "WARNING: Couldn't get tester's machine info!  Passing error to other side.  %e",
			1, hrGetResult);
	} // end if (getting COM port failed)



#pragma TODO(vanceo, "It would be nice not to have to unpack and repack every time")

	// Ignore error
	pInfo->PackIntoBuffer(NULL, &dwMachineInfoSize);


	// Just make sure there's enough room for message in reply buffer
	if ((dwMachineInfoSize + sizeof (LEECHMSG_GETMACHINEINFOREPLY)) > (*pdwReplyMsgSize))
	{
		DPL(0, "Not enough room in reply buffer (%u > %u)!",
			2, dwMachineInfoSize + sizeof (LEECHMSG_GETMACHINEINFOREPLY),
			(*pdwReplyMsgSize));
		hr = E_FAIL;
		goto DONE;
	} // end if (not enough room for message)

	pReplyMsg->hrResult = hrGetResult;
	pReplyMsg->dwMachineInfoSize = dwMachineInfoSize;


	hr = pInfo->PackIntoBuffer((pReplyMsg + 1), &dwMachineInfoSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't repack machine info into buffer!", 0);
		goto DONE;
	} // end if (packing machine info failed)

	(*pdwReplyMsgSize) = dwMachineInfoSize + sizeof (LEECHMSG_GETMACHINEINFOREPLY);


DONE:


	// If we have an info object, we don't need the object reference any more.
	if (pInfo != NULL)
	{
		pInfo->m_dwRefCount--;
		if (pInfo->m_dwRefCount == 0)
		{
			DPL(0, "Info object %x refcount hit 0!?  DEBUGBREAK()-ing.", 1, pInfo);
			DEBUGBREAK();
		} // end if (info refcount hit 0)
		else
		{
			DPL(7, "Not deleting info object %x, refcount is %u.",
				2, pInfo, pInfo->m_dwRefCount);
		} // end else (refcount is fine)
	} // end if (have info object)

	return (hr);
} // CTNLeech::HandleGetMachineInfoMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeech::HandleLostTesterMsg()"
//==================================================================================
// CTNLeech::HandleLostTesterMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a lost tester.  If we're already done with that test, or
//				minding our own business, we ignore it.  If we're doing something
//				involving that tester right now, though, then we have to abort it.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test under which a tester was lost.
//	DWORD dwTestUniqueID		ID of test with problem.
//	int iLostTesterNum			Tester number who was lost.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeech::HandleLostTesterMsg(DWORD dwTopLevelUniqueID,
										DWORD dwTestUniqueID,
										int iLostTesterNum)
{
	HRESULT		hr;


	if (this->m_fOwnerCopy)
	{
		DPL(0, "Not leech side but getting lost tester message?", 0);
		return (E_FAIL);
	} // end if (not leech side)

	hr = this->m_pExecutor->HandleLostTester(dwTopLevelUniqueID, dwTestUniqueID,
											iLostTesterNum);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle lost tester message!", 0);
	} // end if (couldn't handle message)

	return (hr);
} // CTNLeech::HandleLostTesterMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeechesList::CTNLeechesList()"
//==================================================================================
// CTNLeechesList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNLeechesList object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNLeechesList::CTNLeechesList(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNLeechesList));
} // CTNLeechesList::CTNLeechesList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeechesList::~CTNLeechesList()"
//==================================================================================
// CTNLeechesList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNLeechesList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNLeechesList::~CTNLeechesList(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNLeechesList::~CTNLeechesList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeechesList::NewLeech()"
//==================================================================================
// CTNLeechesList::NewLeech
//----------------------------------------------------------------------------------
//
// Description: Creates a new leech object and returns a pointer to it, or returns
//				NULL if an error occurred.
//
// Arguments:
//	LPTNMODULEID lpTNModuleID			Pointer to module ID for object.
//	PTNEXECUTORPRIV pOwningExecutor		Pointer to executor object that will own the
//										leech.
//	PVOID pvSendConnectData				Optional pointer to data to send to other
//										side.
//	DWORD dwSendConnectDataSize			Size of data to send to other side.
//
// Returns: Pointer to the new leech object, or NULL if an error occurred.
//==================================================================================
PTNLEECH CTNLeechesList::NewLeech(PTNMODULEID pTNModuleID,
								PTNEXECUTORPRIV pOwningExecutor,
								PVOID pvSendConnectData,
								DWORD dwSendConnectDataSize)
{
	HRESULT						hr;
	PTNLEECH					pNewItem = NULL;
	PLEECHCONNECTDATAHEADER		pConnectData = NULL;
	char						szNumber[32];



#pragma BUGBUG(vanceo, "Hack, see above")
	pConnectData = (PLEECHCONNECTDATAHEADER) LocalAlloc(LPTR, sizeof (LEECHCONNECTDATAHEADER) + dwSendConnectDataSize);
	if (pConnectData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	CopyMemory(&(pConnectData->idSlave), &(pOwningExecutor->m_id),
				sizeof (TNCTRLMACHINEID));
	pConnectData->dwRealConnectDataSize = dwSendConnectDataSize;

	if (pvSendConnectData != NULL)
	{
		CopyMemory((pConnectData + 1), pvSendConnectData,
					dwSendConnectDataSize);
	} // end if (there's connect data)


	pNewItem = new (CTNLeech);
	if (pNewItem == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pNewItem->m_pExecutor = pOwningExecutor;


	// Generate a (hopefully) unique ID to use for connecting.
#ifndef _XBOX // timeGetTime not supported
	wsprintf(szNumber, "%u-%u", timeGetTime(), g_dwUniquenessValue++);
#else // ! XBOX
	wsprintf(szNumber, "%u-%u", GetTickCount(), g_dwUniquenessValue++);
#endif // XBOX

	hr = pNewItem->Connect(TRUE, pTNModuleID, szNumber, NULL, pConnectData,
							sizeof (LEECHCONNECTDATAHEADER) + dwSendConnectDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't connect leech %x using \"%s\"!", 2, pNewItem, szNumber);
		delete (pNewItem);
		pNewItem = NULL;
		goto DONE;
	} // end if (couldn't connect)


	// Add the item to the list
	hr = this->AddObject(pNewItem);

	if (hr != S_OK)
	{
		DPL(0, "Couldn't add IPC object!  %e", 1, hr);
		delete (pNewItem);
		pNewItem = NULL;
		//goto DONE;
	} // end if (couldn't add object)


DONE:

	if (pConnectData != NULL)
	{
		LocalFree(pConnectData);
		pConnectData = NULL;
	} // end if (there's a connect data header)

	return (pNewItem);
} // CTNLeechesList::NewLeech
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNLeechesList::RemoveLeech()"
//==================================================================================
// CTNLeechesList::RemoveLeech
//----------------------------------------------------------------------------------
//
// Description: Detaches the specified leech from the list and destroys it.  Note
//				that the pointer passed in becomes invalid.
//
// Arguments:
//	PTNLEECH pTNLeech	Pointer to leech to remove.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNLeechesList::RemoveLeech(PTNLEECH pTNLeech)
{
	return (this->RemoveObject(pTNLeech));
} // CTNLeechesList::RemoveLeech
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\leech.h ===
#ifndef _XBOX // no IPC supported
#ifndef __TNCONTROL_LEECH__
#define __TNCONTROL_LEECH__
//#pragma message("Defining __TNCONTROL_LEECH__")






//==================================================================================
// Common Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG



//==================================================================================
// Prototypes
//==================================================================================
DWORD WINAPI LeechTestThreadProc(LPVOID lpvParameter);





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNLeech:public CTNIPCObject
{
	// These are friends so that they can access the protected members
	friend CTNExecutor;
	friend CTNExecutorPriv;


	private:
		// These are implementations of the virtual functions.
		virtual HRESULT HandleMessage(DWORD dwCommand,
									PVOID pvSentData, DWORD dwSentDataSize,
									PVOID pvReplyData, DWORD* pdwReplyDataSize);

		virtual HRESULT HandleDisconnect(void);



		HRESULT HandleLogStringMsg(DWORD dwLogStringType, char* szString);

		HRESULT HandleReportMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID, 
								HRESULT hresult, BOOL fTestComplete,
								BOOL fSuccess, BOOL fExecCaseExitReport,
								DWORD dwOutputDataSize, DWORD dwOutputVarsSize,
								PVOID pvRemainingData);

		HRESULT HandleWarningMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID, 
								HRESULT hresult, PVOID pvUserData,
								DWORD dwUserDataSize);

		HRESULT HandleCreateSubTestMsg(DWORD dwTopLevelUniqueID,
										DWORD dwParentUniqueID,
										int iNumMachines,													
										PVOID pvRemainingData,
										DWORD* pdwAssignedUniqueID);

		HRESULT HandleSyncMsg(DWORD dwTopLevelUniqueID,
							DWORD dwTestUniqueID,
							int iNumMachines,
							DWORD dwSendDataSize,
							PVOID pvRemainingData,
							PVOID pvReplyData,
							DWORD* pdwReplyDataSize);

		HRESULT HandleIsTesterOnMachineMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
										int iTesterNum, BOOL* pfResult);

		HRESULT HandleGetTesterIPMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
									int iTesterNum, WORD wPort,
									char* pszReplyString, DWORD* pdwReplyStringSize);

		HRESULT HandleGetTesterPhoneNumMsg(DWORD dwTopLevelUniqueID,
										DWORD dwTestUniqueID,
										int iTesterNum,
										PVOID pvReplyMsg, // PVOID is actually a PLEECHMSG_GETTESTERPHONENUMREPLY
										DWORD* pdwReplyMsgSize);

		HRESULT HandleGetTesterCOMPortMsg(DWORD dwTopLevelUniqueID,
										DWORD dwTestUniqueID,
										int iTesterNum, PVOID pvReplyMsg); // PVOID is actually a PLEECHMSG_GETTESTERCOMPORTREPLY

		HRESULT HandleFreeResultsMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
									DWORD dwCaseIDSize, DWORD dwInstanceIDSize,
									PVOID pvRemainingData);

		HRESULT HandleFreeOutputVarsMsg(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID,
										DWORD dwCaseIDSize, DWORD dwInstanceIDSize,
										DWORD dwNameSize, DWORD dwTypeSize,
										BOOL fFreeData, PVOID pvRemainingData);

		HRESULT HandleRunTestMsg(DWORD dwTestUniqueID, int iNumMachines,
								DWORD dwInputDataSize, PVOID pvRemainingData);

		HRESULT HandleGetMachineInfoMsg(DWORD dwTopLevelUniqueID,
										DWORD dwTestUniqueID,
										int iTesterNum,
										PVOID pvReplyMsg, // PVOID is actually a PLEECHMSG_GETMACHINEINFOREPLY
										DWORD* pdwReplyMsgSize);

		HRESULT HandleLostTesterMsg(DWORD dwTopLevelUniqueID,
									DWORD dwTestUniqueID,
									int iLostTesterNum);


	protected:
		HRESULT LogToOwner(DWORD dwLogStringType, char* szFormatString, DWORD dwNumParms, ...);

		HRESULT ReportToOwner(PTNTESTINSTANCES pTest, HRESULT hresult,
							BOOL fTestComplete, BOOL fSuccess,
							BOOL fExecCaseExitReport,
							PVOID pvOutputData, DWORD dwOutputDataSize,
							PTNOUTPUTVARSLIST pOutputVars);

		HRESULT WarnOwner(PTNTESTINSTANCES pTest, HRESULT hresult,
							PVOID pvUserData, DWORD dwUserDataSize);

		HRESULT HaveOwnerCreateSubTest(PTNTESTINSTANCES pTest, int iNumMachines,
										PTNCTRLMACHINEID aTesters);

		HRESULT HaveOwnerSync(PTNTESTINSTANCES pTest,
							char* szSyncName,
							PVOID pvSendData,
							DWORD dwSendDataSize,
							PTNSYNCDATALIST pReceiveData,
							int iNumMachines,
							int* aiTesters);

		BOOL HaveOwnerCheckIfTesterOnMachine(PTNTESTINSTANCES pTest,
											int iTesterNum);

		HRESULT HaveOwnerGetTesterIP(PTNTESTINSTANCES pTest,
									int iTesterNum, WORD wPort,
									char* szIPString);

		HRESULT HaveOwnerGetTesterPhoneNum(PTNTESTINSTANCES pTest,
										int iTesterNum, char* szPhoneNumber);

		HRESULT HaveOwnerGetTesterCOMPort(PTNTESTINSTANCES pTest,
										int iTesterNum, DWORD* pdwCOMPort);

		HRESULT HaveOwnerFreeResults(PTNTESTINSTANCES pTest, char* pszCaseID,
									char* pszInstanceID);

		HRESULT HaveOwnerFreeOutputVars(PTNTESTINSTANCES pTest, char* pszCaseID,
										char* pszInstanceID, char* pszName,
										char* pszType, BOOL fFreeData);

		HRESULT HaveOwnerGetTestersMachineInfo(PTNTESTINSTANCES pTest,
												int iTesterNum,
												PTNMACHINEINFO* ppInfo);

		HRESULT HaveLeechRunTest(PTNTESTINSTANCES pTest, PVOID pvInputData,
								DWORD dwInputDataSize);

		HRESULT SendLostTesterMsgToOtherSide(DWORD dwTopLevelUniqueID,
											DWORD dwTestUniqueID,
											int iLostTesterNum);


	public:
		CTNLeech(void);
		virtual ~CTNLeech(void);


		HRESULT PerformLeechTesting(PTNPERFORMLEECHTESTINGDATA pTNpltd);

		char* GetAttachPointID(void);

		HRESULT GetOwnerConnectData(PVOID* ppvData, DWORD* pdwDataSize);
};

class DLLEXPORT CTNLeechesList:public CTNIPCObjectsList
{
	// These are friends so that they can access the protected members
	friend CTNExecutor;
	friend CTNExecutorPriv;


	protected:
		PTNLEECH NewLeech(PTNMODULEID pTNModuleID,
							PTNEXECUTORPRIV pOwningExecutor,
							PVOID pvSendConnectData,
							DWORD dwSendConnectDataSize);
		HRESULT RemoveLeech(PTNLEECH pTNLeech);


	public:
		CTNLeechesList(void);
		virtual ~CTNLeechesList(void);
};






#else //__TNCONTROL_LEECH__
//#pragma message("__TNCONTROL_LEECH__ already included!")
#endif //__TNCONTROL_LEECH__
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\main.h ===
#ifndef __TNCONTROL_MAIN__
#define __TNCONTROL_MAIN__
//#pragma message("Defining __TNCONTROL_MAIN__")




//==================================================================================
// Common Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG


#undef DEBUG_MODULE
#define DEBUG_MODULE	"TNCONTROL"



//==================================================================================
// Defines
//==================================================================================
#define CURRENT_METAMASTER_API_VERSION		3



#define TIMEOUT_DIE_CONTROLSENDTHREAD		20000 // in milliseconds
#define TIMEOUT_DIE_CONTROLRECEIVETHREAD	5000 // in milliseconds


#define MESSAGE_PUMP_CHECK_INTERVAL			500 // in milliseconds




//----------------------------------------------------------------------------------
// Private testcase options, should not be used by user
//----------------------------------------------------------------------------------

// Means the script should not be included in the various case table access
// functions.
#define TNTCO_BUILTIN	0x0001




//----------------------------------------------------------------------------------
// Private control method flags and data, should not be used by user
//----------------------------------------------------------------------------------

// Means the control object being created is solely for the purpose of doing some
// NAT detection/analysis stuff.
#define TN_CTRLMETHODFLAG_TCPIP_NATDETECT	0x0001


//----------------------------------------------------------------------------------
// Reach check method types
//----------------------------------------------------------------------------------

#define TNRCM_CANCEL			1
#define TNRCM_UDPBROADCAST		2
#define TNRCM_UDP				3
#define TNRCM_TCP				4
#define TNRCM_IPX				5
#define TNRCM_MODEM				6
#define TNRCM_SERIAL			7





//==================================================================================
// Structs
//==================================================================================
typedef struct tagCOMMDATA
{
	//HANDLE		hStatusEvent; // event to set when the ctrl comm status has changed
	BOOL		fDropped; // has the connection to this machine been removed for any reason?
	PVOID		pvAddress; // pointer to data buffer holding address
	DWORD		dwAddressSize; // size of address buffer
} COMMDATA, * PCOMMDATA;

typedef struct tagUSERRESPONSEDATA
{
	DWORD	dwSize; // size of this structure
	DWORD	dwResponse; // user defined response ID or command
	DWORD	dwResponseDataSize; // size of the following extra response data buffer

	// Anything after this is part of the response data blob
} USERRESPONSEDATA, * PUSERRESPONSEDATA;






//==================================================================================
// External Statics
//==================================================================================
extern HINSTANCE			s_hInstance;







#else //__TNCONTROL_MAIN__
//#pragma message("__TNCONTROL_MAIN__ already included!")
#endif //__TNCONTROL_MAIN__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\main.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include <objbase.h>
#include <cguid.h>
#include <windows.h>
#include <initguid.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"

#include "tncontrl.h"
#include "main.h"

#include "version.h"




//==================================================================================
// Debugging help
//==================================================================================
char	g_szTNCONTRLVersion[] = TNCONTRL_VERSION_STRING;	



//==================================================================================
// External Statics
//==================================================================================
HINSTANCE			s_hInstance = NULL;






#undef DEBUG_SECTION
#define DEBUG_SECTION	"DllMain()"
//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry point.
//
// Arguments:
//	HINSTANCE hmod		Handle to this DLL module.
//	DWORD dwReason		Reason for calling this function.
//	LPVOID lpvReserved	Reserved.
//
// Returns: TRUE if all goes well.
//==================================================================================
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			TNDebugInitialize();

#ifndef _XBOX // No GetCurrentProcessId
			DPL(1, "v%02u.%02u.%02u.%04u: attaching to process %x, hinstance = %x.",
				6, TNCONTRL_VERSION_MAJOR, TNCONTRL_VERSION_MINOR1,
				TNCONTRL_VERSION_MINOR2, TNCONTRL_VERSION_BUILD,
				GetCurrentProcessId(), hmod);
#endif // ! XBOX

			s_hInstance = hmod;
		  break;

		case DLL_PROCESS_DETACH:
#ifndef _XBOX // No get current process ID
			DPL(1, "Detaching from process %x, hinstance = %x.",
				2, GetCurrentProcessId(), hmod);
#endif // ! XBOX

			TNDebugCleanup();
		  break;
	} // end switch (on the reason we're being called here)

	return (TRUE);
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\macros.h ===
#ifndef __TESTNET_MACROS__
#define __TESTNET_MACROS__
//#pragma message("Defining __TESTNET_MACROS__")







//==================================================================================
// Common Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG







//==================================================================================
// Macros
//==================================================================================
#ifndef _XBOX // CopyMemory not supported
#define CopyAndMoveDestPointer(pPointer, pSource, dwSize)\
												{ CopyMemory(pPointer, pSource, dwSize);\
												  pPointer += dwSize; }

#define CopyAndMoveSrcPointer(pDest, pPointer, dwSize)\
												{ CopyMemory(pDest, pPointer, dwSize);\
												  pPointer += dwSize; }
#else // ! XBOX
#define CopyAndMoveDestPointer(pPointer, pSource, dwSize)\
												{ memcpy(pPointer, pSource, dwSize);\
												  pPointer += dwSize; }

#define CopyAndMoveSrcPointer(pDest, pPointer, dwSize)\
												{ memcpy(pDest, pPointer, dwSize);\
												  pPointer += dwSize; }
#endif // XBOX

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define OVERWRITE_SR_IF_OK(hresult)		{\
											if (sr == S_OK)\
												sr = hresult;\
										}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define CREATEOUTPUTBUFFER_OR_THROW(type, ptr, size)\
											{\
												ptr = (type) pTNecd->pFinalResult->CreateOutputDataBuffer(size);\
												if (ptr == NULL)\
												{\
													SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);\
												}\
											}

#define SETOUTPUTVARIABLE_OR_THROW(szName, szType, ptr, size)\
											{\
												sr = pTNecd->pFinalResult->SetOutputVariable(szName, szType, ptr, size);\
												if (sr != S_OK)\
												{\
													DPL(0, "Couldn't set output variable \"%s\"!", 1, szName);\
													THROW_SYSTEMRESULT;\
												}\
											}


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


#define DO_FINAL_REPORT(success)	{\
										sr = pTNecd->pFinalResult->SetResultCodeAndBools(tr, TRUE, success);\
										if (sr != S_OK)\
										{\
											DPL(0, "Setting final test result failed!", 0);\
										}\
									}

#define FINAL_SUCCESS				DO_FINAL_REPORT(TRUE)

#define FINAL_FAILURE				DO_FINAL_REPORT(FALSE)


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#ifdef DEBUG

#define REQUIRE_INPUT_DATA(size)			{\
												if ((pTNecd->pvInputData == NULL) || (pTNecd->dwInputDataSize != (size)))\
												{\
													DPL(0, "Didn't get expected input data (%x is NULL or size %i != %i)!", 3, pTNecd->pvInputData, pTNecd->dwInputDataSize, (size));\
													SETTHROW_SYSTEMRESULT(E_FAIL);\
												}\
											}

#define REQUIRE_MINIMUM_INPUT_DATA(size)	{\
												if ((pTNecd->pvInputData == NULL) || (pTNecd->dwInputDataSize < (size)))\
												{\
													DPL(0, "Didn't get expected initial data (%x is NULL or size %i < %i)!", 3, pTNecd->pvInputData, pTNecd->dwInputDataSize, (size));\
													SETTHROW_SYSTEMRESULT(E_FAIL);\
												}\
											}

#define REQUIRE_ASSIGNREPORT_DATA(size)		{\
												if (pTNwd->dwDataSize != (size))\
												{\
													DPL(0, "Assignment report data is wrong size (%i != %i)!", 2, pTNwd->dwDataSize, (size));\
													return (E_FAIL);\
												}\
											}

#define REQUIRE_SUCCESSREPORT_DATA(size)	{\
												if (pTNwd->dwDataSize != (size))\
												{\
													DPL(0, "Success report data is wrong size (%i != %i)!", 2, pTNwd->dwDataSize, (size));\
													return (E_FAIL);\
												}\
											}
#else // ! DEBUG

#define REQUIRE_INPUT_DATA(size)

#define REQUIRE_MINIMUM_INPUT_DATA(size)

#define REQUIRE_ASSIGNREPORT_DATA(size)

#define REQUIRE_SUCCESSREPORT_DATA(size)

#endif // ! DEBUG

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define GETSUBRESULT_AND_FAILIFFAILED(pSubResult, szCaseID, szFailString)\
												{\
													pSubResult = pTNecd->pSubResults->GetMostRecentResult(szCaseID);\
													if (pSubResult == NULL)\
													{\
														DPL(0, "Couldn't get result for %s!", 1, szCaseID);\
														SETTHROW_SYSTEMRESULT(E_FAIL);\
													}\
													\
													if (! pSubResult->IsSuccess())\
													{\
														DPL(0, szFailString, 0);\
														SETTHROW_TESTRESULT(pSubResult->GetResultCode());\
													}\
												}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define CHECKANDGET_SUBOUTPUTDATA(pSubResult, pvSubOutputData, dwSubOutputDataSize, dwExpectedSize)\
												{\
													sr = pSubResult->GetOutputData(((PVOID*) (&pvSubOutputData)), &dwSubOutputDataSize);\
													if ((sr != S_OK) || (dwSubOutputDataSize != dwExpectedSize))\
													{\
														DPL(0, "Couldn't get sub test output data (%x is NULL), or it's the wrong size (%u != %u)!", 3, pvSubOutputData, dwSubOutputDataSize, dwExpectedSize);\
														\
														if (sr == S_OK)\
															sr = E_FAIL;\
														\
														THROW_SYSTEMRESULT;\
													}\
												}

#define CHECKANDGET_MINIMUM_SUBOUTPUTDATA(pSubResult, pvSubOutputData, dwSubOutputDataSize, dwExpectedSize)\
												{\
													sr = pSubResult->GetOutputData(((PVOID*) (&pvSubOutputData)), &dwSubOutputDataSize);\
													if ((sr != S_OK) || (dwSubOutputDataSize < dwExpectedSize))\
													{\
														DPL(0, "Couldn't get sub test output data (%x is NULL), or it's not large enough (%u < %u)!", 3, pvSubOutputData, dwSubOutputDataSize, dwExpectedSize);\
														\
														if (sr == S_OK)\
															sr = E_FAIL;\
														\
														THROW_SYSTEMRESULT;\
													}\
												}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define CHECKANDGET_SYNCDATA(syncdata, iTesterNum, pvSyncData, dwSyncDataSize, dwExpectedSize)\
												{\
													sr = syncdata.GetDataFromTester(iTesterNum, (PVOID*) &pvSyncData, &dwSyncDataSize);\
													if (sr != S_OK)\
													{\
														DPL(0, "Couldn't get sync data from tester %i!", 1, iTesterNum);\
														THROW_SYSTEMRESULT;\
													}\
													\
													if ((pvSyncData == NULL) || (dwSyncDataSize != dwExpectedSize))\
													{\
														DPL(0, "Got unexpected sync data from tester %i (%x is NULL or size %u != %u)!", 4, iTesterNum, pvSyncData, dwSyncDataSize, dwExpectedSize);\
														SETTHROW_SYSTEMRESULT(E_FAIL);\
													}\
												}

#define CHECKANDGET_MINIMUM_SYNCDATA(syncdata, iTesterNum, pvSyncData, dwSyncDataSize, dwExpectedSize)\
												{\
													sr = syncdata.GetDataFromTester(iTesterNum, (PVOID*) &pvSyncData, &dwSyncDataSize);\
													if (sr != S_OK)\
													{\
														DPL(0, "Couldn't get sync data from tester %i!", 1, iTesterNum);\
														THROW_SYSTEMRESULT;\
													}\
													\
													if ((pvSyncData == NULL) || (dwSyncDataSize < dwExpectedSize))\
													{\
														DPL(0, "Got unexpected sync data from tester %i (%x is NULL or size %u < %u)!", 4, iTesterNum, pvSyncData, dwSyncDataSize, dwExpectedSize);\
														SETTHROW_SYSTEMRESULT(E_FAIL);\
													}\
												}


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


// This should only be defined for the special documentation builds.
#ifndef TNDOCBUILD


#ifdef USE_TRY_CATCH

#ifndef DONT_SPEW_ON_THROW
#define THROW_ANY_SYSTEMRESULT(hr)	{\
										DPL(0, "Throwing system result %x; %s, line %i", 3, ((HRESULT) hr), __FILE__, __LINE__);\
										throw (hr);\
									}

#define THROW_ANY_TESTRESULT(hr)	{\
										DPL(0, "Throwing test result %x; %s, line %i", 3, ((HRESULT) hr), __FILE__, __LINE__);\
										pTNecd->pExecutor->NoteThrowTestResult(__FILE__, __LINE__);\
										throw (hr);\
									}
#else // ! DONT_SPEW_ON_THROW
#define THROW_ANY_SYSTEMRESULT(hr)	throw (hr)
#define THROW_ANY_TESTRESULT(hr)	throw (hr)
#endif // ! DONT_SPEW_ON_THROW


#define BEGIN_TESTCASE				pTNecd->pExecutor->NoteBeginTestCase(DEBUG_MODULE, DEBUG_SECTION, __FILE__, __LINE__);\
									try


#define CATCH_TESTRESULT			catch (CTNTestResult trCaught)\
									{\
										tr = (HRESULT) trCaught;\
										DPL(0, "Test result catch!  %e.", 1, ((HRESULT) tr));\
										FINAL_FAILURE;\
									}

#define CATCH_SYSTEMRESULT			catch (CTNSystemResult srCaught)\
									{\
										sr = (HRESULT) srCaught;\
										DPL(0, "System result catch!  %e.", 1, ((HRESULT) sr));\
										\
										if (sr == S_OK)\
										{\
											DPL(0, "WARNING: Caught a system result of S_OK, converting to E_FAIL!", 0);\
											sr = E_FAIL;\
										}\
									}

#ifndef _XBOX // this macro doesn't seem to be used, and we don't support GetModuleFileName
#define CATCH_EXCEPTIONLIST			catch (LPCTNExceptionList lpExceptions)\
									{\
										DPL(0, "LPCTNExceptionList catch!", 0);\
										\
										sr = TNHandleCatchExceptionList(lpExceptions, &tr);\
										if (sr != S_OK)\
										{\
											DPL(0, "Couldn't handle ExceptionList catch!", 0);\
										}\
										else\
										{\
											FINAL_FAILURE;\
										}\
									}
#endif // ! XBOX

#ifndef _XBOX // this macro doesn't seem to be used, and we don't support GetModuleFileName
#define CATCH_GENERIC				catch (...)\
									{\
										DPL(0, "Generic catch!", 0);\
										\
										sr = TNHandleCatchGeneric();\
										if (sr != S_OK)\
										{\
											DPL(0, "Couldn't handle generic catch!", 0);\
										}\
										else\
										{\
											sr = E_UNEXPECTED;\
										}\
									}
#endif // ! XBOX


#define END_TESTCASE				CATCH_TESTRESULT\
									CATCH_SYSTEMRESULT\
									CATCH_EXCEPTIONLIST\
									CATCH_GENERIC\
									DNB("Leaving testcase.");
								
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else // ! USE_TRY_CATCH
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


#ifndef DONT_SPEW_ON_THROW
#define THROW_ANY_SYSTEMRESULT(hr)	{\
										DPL(0, "Fake throwing system result %x; %s, line %i", 3, ((HRESULT) hr), __FILE__, __LINE__);\
										srThrown = hr;\
										goto SYSTEMFAILURE;\
									}

#define THROW_ANY_TESTRESULT(hr)	{\
										DPL(0, "Fake throwing test result %x; %s, line %i", 3, ((HRESULT) hr), __FILE__, __LINE__);\
										pTNecd->pExecutor->NoteThrowTestResult(__FILE__, __LINE__);\
										trThrown = hr;\
										goto TESTFAILURE;\
									}
#else // ! DONT_SPEW_ON_THROW
#define THROW_ANY_SYSTEMRESULT(hr)	goto SYSTEMFAILURE
#define THROW_ANY_TESTRESULT(hr)	goto TESTFAILURE
#endif // ! DONT_SPEW_ON_THROW


#define BEGIN_TESTCASE				pTNecd->pExecutor->NoteBeginTestCase(DEBUG_MODULE, DEBUG_SECTION, __FILE__, __LINE__);\
									{\
										HRESULT		srThrown;\
										HRESULT		trThrown;


#define HANDLE_TESTFAILURE			{\
										TESTFAILURE:\
										\
										tr = trThrown;\
										DPL(0, "Test result failure!  %e.", 1, ((HRESULT) tr));\
										FINAL_FAILURE;\
										\
										goto ENDTESTCASE;\
									}

#define HANDLE_SYSTEMFAILURE		{\
										SYSTEMFAILURE:\
										\
										sr = srThrown;\
										DPL(0, "System result failure!  %e.", 1, ((HRESULT) sr));\
										\
										if (sr == S_OK)\
										{\
											DPL(0, "WARNING: Got a system result failure of S_OK, converting to E_FAIL!", 0);\
											sr = E_FAIL;\
										}\
										\
										goto ENDTESTCASE;\
									}


#define END_TESTCASE					goto ENDTESTCASE;\
										\
										HANDLE_TESTFAILURE\
										HANDLE_SYSTEMFAILURE\
										\
										ENDTESTCASE:\
										\
										DNB("Leaving testcase.");\
									}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#endif // ! USE_TRY_CATCH
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


#define TEST_SECTION(name)						pTNecd->pExecutor->NoteNewTestSection(name, DEBUG_MODULE, DEBUG_SECTION, __FILE__, __LINE__);

#define TESTSECTION_IF(expression)				if (expression)
#define TESTSECTION_ELSE						else
#define TESTSECTION_ELSEIF(expression)			else if (expression)
#define TESTSECTION_ENDIF
#define TESTSECTION_FOR(expression)				for(expression)
#define TESTSECTION_ENDFOR
#define TESTSECTION_DO							do
#define TESTSECTION_DOWHILE(expression)			while (expression)
#define TESTSECTION_WHILE(expression)			while (expression)
#define TESTSECTION_ENDWHILE
#define TESTSECTION_SWITCH(expression)			switch (expression)
#define TESTSECTION_ENDSWITCH
#define TESTSECTION_CASE(expression)			case (expression):
#define TESTSECTION_ENDCASE
#define TESTSECTION_BREAK						break



#ifdef DEBUG

#define LOCALALLOC_OR_THROW(type, ptr, size)	{\
													if (ptr != NULL)\
													{\
														DPL(0, "WARNING: Pointer %X is not NULL at line %i, DEBUGBREAK()-ing.", 2, ptr, __LINE__);\
														DEBUGBREAK();\
													}\
													ptr = (type) LocalAlloc(LPTR, size);\
													if (ptr == NULL)\
													{\
														SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);\
													}\
												}
#else // ! DEBUG

#define LOCALALLOC_OR_THROW(type, ptr, size)	{\
													ptr = (type) LocalAlloc(LPTR, size);\
													if (ptr == NULL)\
													{\
														SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);\
													}\
												}
#endif // ! DEBUG



// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else // TNDOCBUILD
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifndef _XBOX // documentation builds not supported

#define THROW_ANY_SYSTEMRESULT(hr)				return (hr)
#define THROW_ANY_TESTRESULT(hr)				return (hr)


#define BEGIN_TESTCASE							pTNecd->pExecutor->DocBuildBeginTestCase(__FILE__, __LINE__);\
												if (FALSE)

#define END_TESTCASE							pTNecd->pExecutor->DocBuildEndTestCase(__FILE__, __LINE__);

#define TEST_SECTION(name)						;}\
												pTNecd->pExecutor->DocBuildNewTestSection(name, __FILE__, __LINE__);\
												if (FALSE)\
												{

#define TESTSECTION_IF(expression)				;}\
												pTNecd->pExecutor->DocBuildTestSectionControl("If", #expression, __FILE__, __LINE__);\
												if (FALSE)

#define TESTSECTION_ELSE						pTNecd->pExecutor->DocBuildTestSectionControl("Else", NULL, __FILE__, __LINE__);\
												if (FALSE)

#define TESTSECTION_ELSEIF(expression)			pTNecd->pExecutor->DocBuildTestSectionControl("ElseIf", #expression, __FILE__, __LINE__);\
												if (FALSE)

#define TESTSECTION_ENDIF						pTNecd->pExecutor->DocBuildTestSectionControl("EndIf", NULL, __FILE__, __LINE__);\
												if (FALSE)\
												{

#define TESTSECTION_FOR(expression)				;}\
												pTNecd->pExecutor->DocBuildTestSectionControl("For", #expression, __FILE__, __LINE__);\
												if (FALSE)

#define TESTSECTION_ENDFOR						pTNecd->pExecutor->DocBuildTestSectionControl("EndFor", NULL, __FILE__, __LINE__);\
												if (FALSE)\
												{

#define TESTSECTION_DO							;}\
												pTNecd->pExecutor->DocBuildTestSectionControl("Do", NULL, __FILE__, __LINE__);\
												if (FALSE)

#define TESTSECTION_DOWHILE(expression)			pTNecd->pExecutor->DocBuildTestSectionControl("DoWhile", #expression, __FILE__, __LINE__);\
												if (FALSE)\
												{

#define TESTSECTION_WHILE(expression)			;}\
												pTNecd->pExecutor->DocBuildTestSectionControl("While", #expression, __FILE__, __LINE__);\
												if (FALSE)

#define TESTSECTION_ENDWHILE					pTNecd->pExecutor->DocBuildTestSectionControl("EndWhile", NULL, __FILE__, __LINE__);\
												if (FALSE)\
												{

#define TESTSECTION_SWITCH(expression)			;}\
												pTNecd->pExecutor->DocBuildTestSectionControl("Switch", #expression, __FILE__, __LINE__);\
												if (FALSE)

#define TESTSECTION_ENDSWITCH					pTNecd->pExecutor->DocBuildTestSectionControl("EndSwitch", NULL, __FILE__, __LINE__);\
												if (FALSE)\
												{

#define TESTSECTION_CASE(expression)			;}\
												pTNecd->pExecutor->DocBuildTestSectionControl("Case", #expression, __FILE__, __LINE__);\
												if (FALSE)

#define TESTSECTION_ENDCASE						pTNecd->pExecutor->DocBuildTestSectionControl("EndCase", NULL, __FILE__, __LINE__);\
												if (FALSE)\
												{

#define TESTSECTION_BREAK						;}\
												pTNecd->pExecutor->DocBuildTestSectionControl("Break", NULL, __FILE__, __LINE__);\
												if (FALSE)\
												{



#define LOCALALLOC_OR_THROW(type, ptr, size)	ptr = NULL

#endif // ! XBOX
#endif // TNDOCBUILD



// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


#define SETTHROW_ANY_SYSTEMRESULT(hr, value)	{\
													hr = (HRESULT) value;\
													THROW_ANY_SYSTEMRESULT(hr);\
												}
#define SETTHROW_ANY_TESTRESULT(hr, value)		{\
													hr = (HRESULT) value;\
													THROW_ANY_TESTRESULT(hr);\
												}

#define THROW_SYSTEMRESULT						THROW_ANY_SYSTEMRESULT(sr)
#define THROW_TESTRESULT						THROW_ANY_TESTRESULT(tr)

#define SETTHROW_SYSTEMRESULT(value)			SETTHROW_ANY_SYSTEMRESULT(sr, value)
#define SETTHROW_TESTRESULT(value)				SETTHROW_ANY_TESTRESULT(tr, value)




// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define SAFE_LOCALFREE(ptr)						{\
													if (ptr != NULL)\
													{\
														LocalFree(ptr);\
														ptr = NULL;\
													}\
												}

#define IS_VALID_HANDLE(x)      				(x && (INVALID_HANDLE_VALUE != x))

#define SAFE_CLOSEHANDLE(h)						{\
													if (IS_VALID_HANDLE(h))\
													{\
														CloseHandle(h);\
														h = NULL;\
													}\
												}												

#define SAFE_RELEASE(p)						    {\
													if (p)\
													{\
														p->Release();\
														p = NULL;\
													}\
												}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// All errors are thrown.
#define HANDLE_SYNC_RESULT				{\
											if (sr == ((HRESULT) TNSR_INSYNC))\
												sr = (HRESULT) S_OK;\
											else\
											{\
												pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID, "Had problem syncing!  %e", 1, (HRESULT) sr);\
												DPL(0, "Had problem syncing!  %e", 1, (HRESULT) sr);\
												THROW_SYSTEMRESULT;\
											}\
										}

// All errors are thrown.
#define HANDLE_WAIT_RESULT				{\
											if (sr == ((HRESULT) TNWR_GOTEVENT))\
												sr = (HRESULT) S_OK;\
											else\
											{\
												pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID, "Had problem waiting for event or cancel!  %e", 1, (HRESULT) sr);\
												DPL(0, "Had problem waiting for event or cancel!  %e", 1, (HRESULT) sr);\
												THROW_SYSTEMRESULT;\
											}\
										}

// TIMEOUT just drops through, all other errors are thrown.
#define HANDLE_WAIT_RESULT_NOT_TIMEOUT	{\
											if (sr == ((HRESULT) TNWR_GOTEVENT))\
												sr = (HRESULT) S_OK;\
											else if (sr != ((HRESULT) TNWR_TIMEOUT))\
											{\
												pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID, "Had problem waiting for event or cancel!  %e", 1, (HRESULT) sr);\
												DPL(0, "Had problem waiting for event or cancel!  %e", 1, (HRESULT) sr);\
												THROW_SYSTEMRESULT;\
											}\
										}

// All errors are thrown.
#define HANDLE_CONNECTWAIT_RESULT\
										{\
											if (sr == ((HRESULT) TNCWR_CONNECTED))\
												sr = (HRESULT) S_OK;\
											else\
											{\
												pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID, "Had problem waiting for leech connection!  %e", 1, (HRESULT) sr);\
												DPL(0, "Had problem waiting for leech connection!  %e", 1, (HRESULT) sr);\
												THROW_SYSTEMRESULT;\
											}\
										}

// TIMEOUT just drops through, all other errors are thrown.
#define HANDLE_CONNECTWAIT_RESULT_NOT_TIMEOUT\
										{\
											if (sr == ((HRESULT) TNCWR_CONNECTED))\
												sr = (HRESULT) S_OK;\
											else if (sr != ((HRESULT) TNCWR_TIMEOUT))\
											{\
												pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID, "Had problem waiting for leech connection!  %e", 1, (HRESULT) sr);\
												DPL(0, "Had problem waiting for leech connection!  %e", 1, (HRESULT) sr);\
												THROW_SYSTEMRESULT;\
											}\
										}

// All errors are thrown.
#define HANDLE_PROMPTUSER_RESULT		{\
											if (sr != (HRESULT) S_OK)\
											{\
												pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID, "Had problem prompting user!  %e", 1, (HRESULT) sr);\
												DPL(0, "Had problem prompting user!  %e", 1, (HRESULT) sr);\
												THROW_SYSTEMRESULT;\
											}\
										}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define EXPANDSLAVEVARS(szString, pszGrowableBuffer, dwBufferSize, dwTemp)\
		{\
			pTNgid->pMaster->ExpandSlaveStringVars(szString, pTNgid->pMachine, NULL, &dwTemp);\
			if (dwTemp > dwBufferSize)\
			{\
				SAFE_LOCALFREE(pszGrowableBuffer);\
				\
				dwBufferSize = dwTemp;\
				pszGrowableBuffer = (char*) LocalAlloc(LPTR, dwBufferSize);\
				if (pszGrowableBuffer == NULL)\
				{\
					hr = E_OUTOFMEMORY;\
					goto DONE;\
				}\
			}\
			\
			hr = pTNgid->pMaster->ExpandSlaveStringVars(szString, pTNgid->pMachine, pszGrowableBuffer, &dwTemp);\
			if (hr != S_OK)\
			{\
				DPL(0, "Failed expanding string variables!", 0);\
				goto DONE;\
			}\
		}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// This is like a Sleep, except it allows TestNet to do its thing.
// The "NULL, 0" means no items, "NULL, -1" means all the testers are important.
#define TNSLEEP(dwTimeout)				{\
											sr = pTNecd->pExecutor->WaitForEventOrCancel(NULL, 0, NULL, -1, dwTimeout, NULL);\
											HANDLE_WAIT_RESULT_NOT_TIMEOUT;\
											sr = S_OK;\
										}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define NEWSUBGROUP(pParentGroup, pszID, pszName, ppNewSubGroup)\
										{\
											HRESULT		hr;\
											\
											\
											hr = pParentGroup->NewSubGroup(pszID, pszName, ppNewSubGroup);\
											if (hr != S_OK)\
											{\
												DPL(0, "Couldn't create new subgroup \"%s\" under group \"%s\"!", 2, pszID, pParentGroup->m_pszID);\
												return (hr);\
											}\
										}

#define ADDTESTTOGROUP(pAddTestData, pGroup)\
										{\
											HRESULT		hr;\
											\
											\
											hr = pGroup->AddTest(pAddTestData);\
											if (hr != S_OK)\
											{\
												DPL(0, "Couldn't add test \"%s\" to group \"%s\"!", 2, (pAddTestData)->pszCaseID, pGroup->m_pszID);\
												return (hr);\
											}\
										}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define WRITEDATA(szFormatString, item, pszTempPtr)\
										{\
											TNsprintf(&pszTempPtr, szFormatString, 1, (item));\
											pTNwd->pWriteStoredData->AddString(pszTempPtr);\
											TNsprintf_free(&pszTempPtr);\
										}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

inline BOOL IsZero(PVOID pvPointer, DWORD dwSize)
{
	LPBYTE	lpCurrent = (LPBYTE) pvPointer;
	LPBYTE	lpEnd = lpCurrent + dwSize;
	

	while (lpCurrent < lpEnd)
	{
		if ((*lpCurrent) != 0)
			return (FALSE);

		lpCurrent++;
	} // end while (haven't hit end of buffer)

	return (TRUE);
};

inline void FillWithDWord(PVOID pvPointer, DWORD dwSize, DWORD dwPattern)
{
	LPBYTE	lpCurrent = (LPBYTE) pvPointer;
	DWORD	dwPatternByteIndex = 0;
	LPBYTE	lpEnd = lpCurrent + dwSize;
	

	while (lpCurrent < lpEnd)
	{
		(*lpCurrent) = ((LPBYTE) (&dwPattern))[dwPatternByteIndex];

		lpCurrent++;
		dwPatternByteIndex++;
		if (dwPatternByteIndex >= sizeof (DWORD))
			dwPatternByteIndex = 0;
	} // end while (haven't hit end of buffer)
};

inline BOOL IsFilledWithDWord(PVOID pvPointer, DWORD dwSize, DWORD dwPattern)
{
	LPBYTE	lpCurrent = (LPBYTE) pvPointer;
	DWORD	dwPatternByteIndex = 0;
	LPBYTE	lpEnd = lpCurrent + dwSize;
	

	while (lpCurrent < lpEnd)
	{
		if ((*lpCurrent) != ((LPBYTE) (&dwPattern))[dwPatternByteIndex])
			return (FALSE);

		lpCurrent++;
		dwPatternByteIndex++;
		if (dwPatternByteIndex >= sizeof (DWORD))
			dwPatternByteIndex = 0;
	} // end while (haven't hit end of buffer)

	return (TRUE);
};




#else //__TESTNET_MACROS__
//#pragma message("__TESTNET_MACROS__ already included!")
#endif //__TESTNET_MACROS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\masterinfo.cpp ===
#ifndef _XBOX // ! no master supported
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"

#include "masterinfo.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMasterInfo::CTNMasterInfo()"
//==================================================================================
// CTNMasterInfo constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNMasterInfo object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNMasterInfo::CTNMasterInfo(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNMasterInfo));

	ZeroMemory(&(this->m_id), sizeof (TNCTRLMACHINEID));
	this->m_dwControlVersion = 0;
	this->m_dwSessionID = 0;
	ZeroMemory(&(this->m_moduleID), sizeof (TNMODULEID));
	this->m_dwMode = 0;
	this->m_pszSessionFilter = NULL;
	ZeroMemory(&(this->m_commdata), sizeof (COMMDATA));
	this->m_pszAddress = NULL;
	this->m_iNumSlaves = 0;
	this->m_fJoinersAllowed = TRUE;
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMasterInfo::~CTNMasterInfo()"
//==================================================================================
// CTNMasterInfo destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNMasterInfo object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNMasterInfo::~CTNMasterInfo(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pszSessionFilter != NULL)
	{
		LocalFree(this->m_pszSessionFilter);
		this->m_pszSessionFilter = NULL;
	} // end if (allocated a session ID)

	if (this->m_commdata.pvAddress != NULL)
	{
		LocalFree(this->m_commdata.pvAddress);
		this->m_pszAddress = NULL;
	} // end if (we have a control comm address structure)

	if (this->m_pszAddress != NULL)
	{
		LocalFree(this->m_pszAddress);
		this->m_pszAddress = NULL;
	} // end if (allocated an address string)
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\masterinfo.h ===
#ifndef _XBOX // ! no master supported
#ifndef __TNCONTROL_MASTERINFO__
#define __TNCONTROL_MASTERINFO__
//#pragma message("Defining __TNCONTROL_MASTERINFO__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG







//==================================================================================
// Classes
//==================================================================================
class DLLEXPORT CTNMasterInfo:public LLITEM
{
	// These are friends so they can access the protected members
	friend class CTNMastersList;
	friend class CTNMetaMaster;


	protected:
		TNCTRLMACHINEID		m_id; // ID of this slave
		DWORD				m_dwControlVersion; // version of control layer API master has
		DWORD				m_dwSessionID; // self described session ID of this master
		TNMODULEID			m_moduleID; // ID of module the master is using
		DWORD				m_dwMode; // mode the master is in
		char*				m_pszSessionFilter; // user specified session filter string
		COMMDATA			m_commdata; // structure with ctrl comm related data in it
		char*				m_pszAddress; // string address for slaves to use to reach the master
		int					m_iNumSlaves; // number of slaves connected to it
		BOOL				m_fJoinersAllowed; // whether this master is currently accepting new joiners


	public:
		CTNMasterInfo(void);
		virtual ~CTNMasterInfo(void);
};






#else //__TNCONTROL_MASTERINFO__
//#pragma message("__TNCONTROL_MASTERINFO__ already included!")
#endif //__TNCONTROL_MASTERINFO__
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\master.cpp ===
#ifndef _XBOX // no master supported
//==================================================================================
// Includes
//==================================================================================
#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock2 fn proto's, for getprocaddress
#ifndef _XBOX
#include <winsock2.h>
#else // ! XBOX
#include <winsockx.h>		// Needed for XnetInitialize
#endif // XBOX
#include <windows.h>

#include <stdlib.h>
#include <time.h>
#include <mmsystem.h>


#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\sprintf.h"
#include "..\tncommon\fileutils.h"

#include "tncontrl.h"
#include "main.h"
#include "sendq.h"
#include "comm.h"
#include "commtcp.h"
#include "reportitem.h"
#include "slaveinfo.h"
#include "script.h"

#include "master.h"







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CTNMaster()"
//==================================================================================
// CTNMaster constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNMaster object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNMaster::CTNMaster(void)
{
	DPL(9, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNMaster));


	// Any changes here should go in CloseControlSession as well.
	this->m_hKillJobThreadEvent = NULL; 

	this->m_dwMode = 0;
	ZeroMemory(&(this->m_moduleID), sizeof (TNMODULEID));
	this->m_pszSessionFilter = NULL;
	this->m_pszClosingReportPath = NULL;
	this->m_pszSiblingFailuresMemDumpDirPath = NULL;
	this->m_pszSkippedTestsPath = NULL;
	this->m_pFailureBreakRules = NULL;

	this->m_pfnGetStartupData = NULL;
	this->m_pfnLoadStartupData = NULL;
	this->m_pfnWriteStartupData = NULL;
	this->m_pfnHandleUserQuery = NULL;

	this->m_dwSessionID = 0;
	ZeroMemory(&this->m_testChecksum, sizeof (CHECKSUM));
	//this->m_hAllSlavesCommStatusEvent = NULL;
	this->m_dwCurrentUniqueID = 1;
	this->m_dwStartupTicks = 0;
	ZeroMemory(&(this->m_tStartupTime), sizeof (time_t));
	this->m_dwTimelimit = 0;
	this->m_dwAllowJoinersTime = 0;
	this->m_fJoinersAllowed = FALSE;
	this->m_fTestingComplete = FALSE;

	this->m_pvMetaMasterAddress = NULL;
	this->m_dwMetaMasterAddressSize = 0;
	ZeroMemory(&(this->m_id), sizeof (TNCTRLMACHINEID));
	this->m_fRegistered = FALSE;

	this->m_fPingSlaves = FALSE;
	this->m_hJobThread = NULL;

	this->m_dwAutoReportHeaders = 0;
	this->m_dwAutoReportBodyStyle = 0;
	this->m_dwAutoReportFlags = 0;
	this->m_iAutoReportNumReports = -1;
	this->m_pszAutoReportDirpath = NULL;
	this->m_fAutoReportDeleteNonPrinted = FALSE;

	this->m_iTotalNumSlaves = 0;

	this->m_fReportInBVTFormat = FALSE;
} // CTNMaster::CTNMaster
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::~CTNMaster()"
//==================================================================================
// CTNMaster destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNMaster object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNMaster::~CTNMaster(void)
{
	HRESULT				hr;


	DPL(9, "this = %x", 1, this);

	hr = this->DestroyControlSession();
	if (hr != S_OK)
	{
		DPL(0, "Destroying control layer session failed!  %e", 1, hr);
	} // end if (destroying session failed)
} // CTNMaster::~CTNMaster
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CreateControlSession()"
//==================================================================================
// CTNMaster::CreateControlSession
//----------------------------------------------------------------------------------
//
// Description: Starts up the control session and begins hosting.
//
// Arguments:
//	PTNCREATECONTROLSESSIONDATA pTNccsd		Parameter block.  See header file for
//											information.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::CreateControlSession(PTNCREATECONTROLSESSIONDATA pTNccsd)
{

	HRESULT					hr;
	CONTROLCOMMINITPBLOCK	ctrlcomminitparams;
	DWORD					dwTemp;


	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (we got passed a bad pointer)

	if (pTNccsd == NULL)
	{
		DPL(0, "Must pass a valid structure pointer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNccsd->dwSize != sizeof (TNCREATECONTROLSESSIONDATA))
	{
		DPL(0, "Must pass a structure of correct size!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNccsd->dwAPIVersion != CURRENT_TNCONTROL_API_VERSION)
	{
		DPL(0, "WARNING: Caller requesting different API version (%i != %i), problems may occur.",
			2, pTNccsd->dwAPIVersion, CURRENT_TNCONTROL_API_VERSION);
	} // end if (got passed an invalid parameter)

	if ((pTNccsd->dwMode != TNMODE_API) &&
		(pTNccsd->dwMode != TNMODE_STRESS) &&
		(pTNccsd->dwMode != TNMODE_PICKY) &&
		(pTNccsd->dwMode != TNMODE_POKE))
	{
		DPL(0, "Must pass a valid mode (%u is invalid)!", 1, pTNccsd->dwMode);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNccsd->dwControlMethodID != TN_CTRLMETHOD_TCPIP_OPTIMAL) &&
			(pTNccsd->dwControlMethodID != TN_CTRLMETHOD_TCPIP_WINSOCK1))
	{
		DPL(0, "Must pass a control method ID (%u is invalid)!",
			1, pTNccsd->dwControlMethodID);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNccsd->pModuleID == NULL) ||
		(pTNccsd->apfnLoadTestTable == NULL) ||
			(pTNccsd->dwNumLoadTestTables < 1) ||
			(pTNccsd->apfnLoadTestTable[0] == NULL))
	{
		DPL(0, "Must pass a valid module ID and LoadTestTable callbacks array!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNccsd->pszTestlistFilepath == NULL) &&
		(pTNccsd->dwMode != TNMODE_POKE))
	{
		DPL(0, "Must pass a valid path to a script in modes other than poke mode!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNccsd->iNumSlaves < 0)
	{
		DPL(0, "Must pass a valid number of slaves expected, or 0 for a free join session (%i is invalid)!",
			1, pTNccsd->iNumSlaves);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNccsd->dwMode != TNMODE_API) &&
		(pTNccsd->iNumSlaves == 0) && (pTNccsd->dwAllowAdditionalJoinersTime == 0))
	{
		DPL(0, "API mode requires the session to be closed before testing can begin, so you must pass an expected number of slaves or allow joiners time limit!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (API mode and no slave or time session close specified)

	switch (pTNccsd->dwMode)
	{
		case TNMODE_API:
			DPL(0, "Using API mode.", 0);
		break;

		case TNMODE_STRESS:
			DPL(0, "Using stress mode.", 0);
		  break;

		case TNMODE_POKE:
			DPL(0, "Using poke watcher mode.", 0);
		  break;

		case TNMODE_PICKY:
			DPL(0, "Using picky mode.", 0);
		  break;
	} // end switch (on mode)
	this->m_dwMode = pTNccsd->dwMode;

	/*
	this->m_hAllSlavesCommStatusEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (this->m_hAllSlavesCommStatusEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Failed to create comm status event!", 0);
		goto ERROR_EXIT;
	} // end if (failed to create event)
	*/


	ZeroMemory(&ctrlcomminitparams, sizeof (CONTROLCOMMINITPBLOCK));
	ctrlcomminitparams.dwSize = sizeof (CONTROLCOMMINITPBLOCK);
	ctrlcomminitparams.dwControlMethodID = pTNccsd->dwControlMethodID;
	ctrlcomminitparams.pControlLayerObj = this;
	ctrlcomminitparams.fMaster = TRUE;
	ctrlcomminitparams.dwFlags = pTNccsd->dwMethodFlags;
	ctrlcomminitparams.pvData = pTNccsd->pvMethodData;
	ctrlcomminitparams.dwDataSize = pTNccsd->dwMethodDataSize;

	// Initialize desired control method
	switch (pTNccsd->dwControlMethodID)
	{
		case TN_CTRLMETHOD_TCPIP_OPTIMAL:
			hr = CtrlCommTCPLoadOptimal(&ctrlcomminitparams, &(this->m_pCtrlComm));
			if (hr != S_OK)
			{
				DPL(0, "Initializing TCP/IP optimal control method failed!", 0);
				goto ERROR_EXIT;
			} // end if (initting TCP/IP optimal control method failed)
		break;

		case TN_CTRLMETHOD_TCPIP_WINSOCK1:
			hr = CtrlCommTCPLoadWinSock1(&ctrlcomminitparams, &(this->m_pCtrlComm));
			if (hr != S_OK)
			{
				DPL(0, "Initializing TCP/IP WinSock1 control method failed!", 0);
				goto ERROR_EXIT;
			} // end if (initting TCP/IP WinSock1 control method failed)
		  break;
	} // end switch (on control method ID)


	// Initialize our data
	CopyMemory(&(this->m_moduleID), pTNccsd->pModuleID, sizeof (TNMODULEID));

	if (pTNccsd->pszSessionFilter != NULL)
	{
		this->m_pszSessionFilter = (char*) LocalAlloc(LPTR, (strlen(pTNccsd->pszSessionFilter) + 1));
		if (this->m_pszSessionFilter == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszSessionFilter, pTNccsd->pszSessionFilter);
	} // end if (theres a user session ID)

	if (pTNccsd->pszSiblingFailuresMemDumpDirPath != NULL)
	{
		this->m_pszSiblingFailuresMemDumpDirPath = (char*) LocalAlloc(LPTR, (strlen(pTNccsd->pszSiblingFailuresMemDumpDirPath) + 1));
		if (this->m_pszSiblingFailuresMemDumpDirPath == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszSiblingFailuresMemDumpDirPath, pTNccsd->pszSiblingFailuresMemDumpDirPath);
	} // end if (theres a sibling failure dump dir)

	if (pTNccsd->pszSkippedTestsPath != NULL)
	{
		this->m_pszSkippedTestsPath = (char*) LocalAlloc(LPTR, (strlen(pTNccsd->pszSkippedTestsPath) + 1));
		if (this->m_pszSkippedTestsPath == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszSkippedTestsPath, pTNccsd->pszSkippedTestsPath);
	} // end if (theres a skipped test path)
	
	
	this->m_pfnLogString = pTNccsd->pfnLogString;
	if (pTNccsd->hCompletionOrUpdateEvent != NULL)
	{
		if (! DuplicateHandle(GetCurrentProcess(), pTNccsd->hCompletionOrUpdateEvent,
								GetCurrentProcess(), &(this->m_hCompletionOrUpdateEvent),
								0, FALSE, DUPLICATE_SAME_ACCESS))
		{
			hr = GetLastError();
			DPL(0, "Couldn't duplicate user's completion or update event handle (%x)!",
				2, pTNccsd->hCompletionOrUpdateEvent);
			goto ERROR_EXIT;
		} // end if (couldn't duplicate handle)
	} // end if (there's an event)

	this->m_pfnGetStartupData = pTNccsd->pfnGetStartupData;
	this->m_pfnLoadStartupData = pTNccsd->pfnLoadStartupData;
	this->m_pfnWriteStartupData = pTNccsd->pfnWriteStartupData;
	this->m_dwTimelimit = pTNccsd->dwTimelimit;
	this->m_iSlaveNumLimit = pTNccsd->iNumSlaves;
	this->m_dwAllowJoinersTime = pTNccsd->dwAllowAdditionalJoinersTime;
	this->m_pFailureBreakRules = pTNccsd->pFailureBreakRules;
	this->m_fPingSlaves = pTNccsd->fPingSlaves;
	this->m_fReportInBVTFormat = pTNccsd->fReportInBVTFormat;


	if (! this->m_fPingSlaves)
	{
		DPL(0, "WARNING: Not pinging slaves!", 0);
		// Ignoring error
		this->Log(TNLST_CONTROLLAYER_INFO, "WARNING: Not pinging slaves!", 0);
	} // end if (not pinging)


	hr = ScriptLoadTestTable(&(this->m_testtable));
	if (hr != S_OK)
	{
		DPL(0, "Loading built-in script functions failed!", 0);
		goto ERROR_EXIT;
	} // end if (loading built-in script functions failed)

	for(dwTemp = 0; dwTemp < pTNccsd->dwNumLoadTestTables; dwTemp++)
	{
		hr = pTNccsd->apfnLoadTestTable[dwTemp](&(this->m_testtable));
		if (hr != S_OK)
		{
			DPL(0, "Module's LoadTestTable callback %u failed!", 1, dwTemp);
		goto ERROR_EXIT;
		} // end if (module's callback failed)
	} // end for (each LoadTestTable callback)

	hr = this->m_testtable.CalculateChecksum(&(this->m_testChecksum));
	if (hr != S_OK)
	{
		DPL(0, "Failed calculating checksum!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't calculate checksum)


	// If not in Poke mode, read the tests to run from a file.
	if (this->m_dwMode != TNMODE_POKE)
	{
		hr = this->ReadFromFile(pTNccsd->pszTestlistFilepath,
								pTNccsd->dwReps);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't read tests from file %s!",
				1, pTNccsd->pszTestlistFilepath);
			goto ERROR_EXIT;
		} // end if (module's callback failed)


		DPL(1, "Loaded list containing %i test(s) from file %s, %u rep(s).",
			3, this->m_loadedtests.Count(), pTNccsd->pszTestlistFilepath,
			pTNccsd->dwReps);

		// Ignore error
		this->Log(TNLST_CONTROLLAYER_INFO,
				"Loaded list containing %i tes%s from file %s, set for %i repetitio%s.",
				5,
				this->m_loadedtests.Count(),
				((this->m_loadedtests.Count() != 1) ? "ts" : "t"),
				pTNccsd->pszTestlistFilepath,
				pTNccsd->dwReps,
				((pTNccsd->dwReps != 1) ? "ns" : "n"));
	} // end if (not in poke mode)


	// Initialize control communication method
	hr = this->m_pCtrlComm->Initialize();
	if (hr != S_OK)
	{
		DPL(0, "Initializing control communications method failed!", 0);
		goto ERROR_EXIT;
	} // end if (initting ctrl comm failed)


	// If we're using a TCP/IP control method, we can gather some cool NAT related
	// info during the client join sequence.   To do that we need to gather the IP
	// addresses we think we're using.  WinSock will just have been initialized above
	// so we can grab them now. 
	if ((pTNccsd->dwControlMethodID == TN_CTRLMETHOD_TCPIP_OPTIMAL) ||
		(pTNccsd->dwControlMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK1))
	{
		hr = this->m_ipaddrs.LoadLocalIPs();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't load local machine IPs!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't load local IPs)
	} // end if (using a TCP/IP control method)


	// If we're supposed to register with a meta-master, do that.
	if (pTNccsd->pszMetaMasterAddress != NULL)
	{
		// Ignore error, assume BUFFER_TOO_SMALL
		this->m_pCtrlComm->ConvertStringToAddress(pTNccsd->pszMetaMasterAddress,
													NULL,
													0,
													NULL,
													&(this->m_dwMetaMasterAddressSize));
		this->m_pvMetaMasterAddress = LocalAlloc(LPTR, this->m_dwMetaMasterAddressSize);
		if (this->m_pvMetaMasterAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		hr = this->m_pCtrlComm->ConvertStringToAddress(pTNccsd->pszMetaMasterAddress,
														NULL,
														0,
														this->m_pvMetaMasterAddress,
														&(this->m_dwMetaMasterAddressSize));
		if (hr != S_OK)
		{
			DPL(0, "Converting \"%s\" into meta-master address failed!",
				1, pTNccsd->pszMetaMasterAddress);
			goto ERROR_EXIT;
		} // end if (initting ctrl comm failed)

		// Actually send the register request.
		hr = this->RegisterWithMetaMaster();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't register with meta-master!", 0);
			goto ERROR_EXIT;
		} // end if (initting ctrl comm failed)
	} // end if (a meta master was specified)


	// BUGBUG use a better method of getting the session ID?
#ifndef _XBOX // timeGetTime not supported
	this->m_dwSessionID = timeGetTime();
#else // ! XBOX
	this->m_dwSessionID = GetTickCount();
#endif // XBOX

	if (pTNccsd->pszClosingReportDirPath != NULL)
	{
		char	szTemp[64];
		DWORD	dwSize;


		wsprintf(szTemp, "final_%010u.txt", this->m_dwSessionID);

		dwSize = strlen(pTNccsd->pszClosingReportDirPath) + strlen(szTemp) + 1;
		// Make sure it ends with a backslash
		if (! StringEndsWith(pTNccsd->pszClosingReportDirPath, "\\", TRUE))
			dwSize++;

		this->m_pszClosingReportPath = (char*) LocalAlloc(LPTR, dwSize);
		if (this->m_pszClosingReportPath == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszClosingReportPath, pTNccsd->pszClosingReportDirPath);
		if (! StringEndsWith(pTNccsd->pszClosingReportDirPath, "\\", TRUE))
			strcat(this->m_pszClosingReportPath, "\\");
		strcat(this->m_pszClosingReportPath, szTemp);
	} // end if (there's a report dir)


	this->m_dwStartupTicks = GetTickCount();
	time(&(this->m_tStartupTime));
	this->m_fJoinersAllowed = TRUE;


	// Kick off the job thread
	hr = this->StartJobThread();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't start Job thread!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't start the job thread)



	// Ping the event to let the app know the session is ready.
	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto ERROR_EXIT;
	} // end if (couldn't set the user's update event)

	return (S_OK);


ERROR_EXIT:

	// Ignore error
	this->DestroyControlSession();

	return (hr);
} // CTNMaster::CreateControlSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::DestroyControlSession()"
//==================================================================================
// CTNMaster::DestroyControlSession
//----------------------------------------------------------------------------------
//
// Description: Closes the control session and releases the ctrl comm object if
//				they existed.
//				Note that errors will probably be masked.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::DestroyControlSession(void)
{
	HRESULT			hr;
	PTNSLAVEINFO	pSlave = NULL;



	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we got passed a bad pointer)


	DPL(9, "==>", 0);


	if (this->m_fRegistered)
	{
		hr = this->UnregisterWithMetaMaster();
		if (hr != S_OK)
		{
			DPL(0, "WARNING: Unregistering with meta-master failed!  %e", 1, hr);
		} // end if (failed unregistering)

		ZeroMemory(&(this->m_id), sizeof (TNCTRLMACHINEID));
		this->m_fRegistered = FALSE;
	} // end if (we were registered with the meta-master)
	

	// Print out all reports still in the buffer now that we're closing if the user
	// wants us to do that.
	if (this->m_pszClosingReportPath != NULL)
	{
		DPL(2, "Printing all remaining reports to \"%s\".",
			1, this->m_pszClosingReportPath);

		hr = this->PrintReports((TNRH_SESSIONINFO | TNRH_MACHINELIST | TNRH_ACTIVETESTS | TNRH_REMAININGTESTS | TNRH_SKIPPEDTESTS),
								TNRBS_PLAIN,
								TNREPORT_ALL,
								this->m_pszClosingReportPath,
								TRUE,
								FALSE);
		if (hr != S_OK)
		{
			DPL(0, "WARNING: Couldn't print remaining reports to \"%s\"!  %e",
				2, this->m_pszClosingReportPath, hr);
		} // end if (failed printing reports)

		LocalFree(m_pszClosingReportPath);
		this->m_pszClosingReportPath = NULL;
	} // end if (there's a report dir path)


	// Stop pinging slaves and all that.
	hr = this->KillJobThread();
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Killing the Job thread failed!  %e", 1, hr);
	} // end if (killing thread failed)

	hr = this->m_jobs.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Removing all remaining jobs failed!  %e", 1, hr);
	} // end if (removing jobs failed)


	// Empty out the loaded tests list.
	hr = this->m_loadedtests.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Removing all loaded tests failed!  %e", 1, hr);
	} // end if (failed removing all tests)

	// Empty out the skipped tests list.
	hr = this->m_skippedtests.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Removing all skipped tests failed!  %e", 1, hr);
	} // end if (failed removing all tests)

	// Empty out the remaining tests list.
	hr = this->m_remainingtests.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Removing all remaining tests failed!  %e", 1, hr);
	} // end if (failed removing all tests)

	// Empty out the reports list.
	hr = this->m_reports.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Removing all reports failed!  %e", 1, hr);
	} // end if (failed removing all reports)

	// Empty out the vars list.
	hr = this->m_builtinvars.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Removing all built-in vars failed!  %e", 1, hr);
	} // end if (failed removing all vars)

	// Empty out the tests with vars list.
	hr = this->m_testswithvars.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Removing all tests with vars failed!  %e", 1, hr);
	} // end if (failed removing all ests)

	if (this->m_pCtrlComm != NULL)
	{
		// Flush the send queue
		hr = this->m_pCtrlComm->FlushSendQueue();
		if (hr != S_OK)
		{
			DPL(0, "WARNING: Flushing control method send queue failed!  %e", 1, hr);
		} // end if (flushing send queue failed)
	} // end if (there's a control method)

	// Now remove all the slaves
	this->m_slaves.EnterCritSection();
	while (this->m_slaves.Count() > 0)
	{
		pSlave = (PTNSLAVEINFO) this->m_slaves.PopFirstItem();
		if (pSlave == NULL)
		{
			DPL(0, "Couldn't pop first slave in list!", 0);
			break;
		} // end if (couldn't pop item)

		// Disconnect him (if he wasn't already).
		hr = this->m_pCtrlComm->UnbindDataFromAddress(&(pSlave->m_commdata));
		if (hr != S_OK)
		{
			DPL(0, "WARNING: Unbinding slave's comm data failed!  %e", 1, hr);
		} // end if (undbinding data failed)

		// Get rid of its current test, if it has one.
		if (pSlave->m_pCurrentTest != NULL)
		{
			pSlave->m_pCurrentTest->m_dwRefCount--;
			if (pSlave->m_pCurrentTest->m_dwRefCount == 0)
			{
				DPL(7, "Deleting slave %x's current test %x.",
					2, pSlave, pSlave->m_pCurrentTest);
				delete (pSlave->m_pCurrentTest);
			} // end if (refcount hit 0)
			else
			{
				DPL(7, "Not deleting slave %x's current test %x, it's refcount is %u.",
					3, pSlave, pSlave->m_pCurrentTest,
					pSlave->m_pCurrentTest->m_dwRefCount);
			} // end else (refcount didn't hit 0)
			pSlave->m_pCurrentTest = NULL;
		} // end if (slave has current test)

		pSlave->m_dwRefCount--;
		if (pSlave->m_dwRefCount == 0)
		{
			DPL(7, "Deleting slave %x.", 1, pSlave);
			delete (pSlave);
			pSlave = NULL;
		} // end if (deleting slave failed)
		else
		{
			DPL(1, "Can't delete slave %x, it's refcount is %u.",
				2, pSlave, pSlave->m_dwRefCount);
		} // end if (deleting slave failed)
	} // end for (each slave)
	this->m_slaves.LeaveCritSection();

	// Now remove all the dropped slaves.
	this->m_droppedslaves.EnterCritSection();
	while (this->m_droppedslaves.Count() > 0)
	{
		pSlave = (PTNSLAVEINFO) this->m_droppedslaves.PopFirstItem();
		if (pSlave == NULL)
		{
			DPL(0, "Couldn't pop first slave in list!", 0);
			break;
		} // end if (couldn't pop item)

		// Disconnect him (if he wasn't already).
		hr = this->m_pCtrlComm->UnbindDataFromAddress(&(pSlave->m_commdata));
		if (hr != S_OK)
		{
			DPL(0, "WARNING: Unbinding dropped slave's comm data failed!  %e", 1, hr);
		} // end if (undbinding data failed)

		// Get rid of its current test, if it has one.
		if (pSlave->m_pCurrentTest != NULL)
		{
			pSlave->m_pCurrentTest->m_dwRefCount--;
			if (pSlave->m_pCurrentTest->m_dwRefCount == 0)
			{
				DPL(7, "Deleting slave %x's current test %x.",
					2, pSlave, pSlave->m_pCurrentTest);
				delete (pSlave->m_pCurrentTest);
			} // end if (refcount hit 0)
			else
			{
				DPL(7, "Not deleting slave %x's current test %x, it's refcount is %u.",
					3, pSlave, pSlave->m_pCurrentTest,
					pSlave->m_pCurrentTest->m_dwRefCount);
			} // end else (refcount didn't hit 0)
			pSlave->m_pCurrentTest = NULL;
		} // end if (slave has current test)

		pSlave->m_dwRefCount--;
		if (pSlave->m_dwRefCount == 0)
		{
			DPL(7, "Deleting slave %x.", 1, pSlave);
			delete (pSlave);
			pSlave = NULL;
		} // end if (deleting slave failed)
		else
		{
			DPL(1, "Can't delete slave %x, it's refcount is %u.",
				2, pSlave, pSlave->m_dwRefCount);
		} // end if (deleting slave failed)
	} // end for (each slave)
	this->m_droppedslaves.LeaveCritSection();

	if (this->m_pCtrlComm != NULL)
	{
		this->m_pCtrlComm->m_dwRefCount--;
		if (this->m_pCtrlComm->m_dwRefCount == 0)
		{
			DPL(7, "Releasing and deleting control comm object %x.",
				1, this->m_pCtrlComm);

			hr = this->m_pCtrlComm->Release();
			if (hr != S_OK)
			{
				DPL(0, "WARNING: Releasing control communication method failed!  %e", 1, hr);
			} // end if (releasing control method failed)

			delete (this->m_pCtrlComm);
		} // end if (last reference)
		else
		{
			DPL(0, "WARNING: Not releasing and deleting control comm object %x, its refcount is %u!",
				2, this->m_pCtrlComm, this->m_pCtrlComm->m_dwRefCount);
		} // end else (not last reference)

		this->m_pCtrlComm = NULL;
	} // end if (we're still validly connected to the control method)

	/*
	if (this->m_hAllSlavesCommStatusEvent != NULL)
	{
		CloseHandle(this->m_hAllSlavesCommStatusEvent);
		this->m_hAllSlavesCommStatusEvent = NULL;
	} // end if (we created a comm status event)
	*/

	// Dump any dynamic variables we may have created
	hr = this->m_builtinvars.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "Removing all dynamic variables from list failed!  %e", 1, hr);
	} // end if (emptying variable list failed)


	// Reset the members, just like in the constructor

	this->m_dwMode = 0;
	ZeroMemory(&(this->m_moduleID), sizeof (TNMODULEID));
	if (this->m_pszSessionFilter != NULL)
	{
		LocalFree(this->m_pszSessionFilter);
		this->m_pszSessionFilter = NULL;
	} // end if (allocated a session user ID)

	if (this->m_pszSiblingFailuresMemDumpDirPath != NULL)
	{
		LocalFree(this->m_pszSiblingFailuresMemDumpDirPath);
		this->m_pszSiblingFailuresMemDumpDirPath = NULL;
	} // end if (allocated a dump dir path)

	if (this->m_pszSkippedTestsPath != NULL)
	{
		LocalFree(this->m_pszSkippedTestsPath);
		this->m_pszSkippedTestsPath = NULL;
	} // end if (allocated a dump dir path)

	if (this->m_hCompletionOrUpdateEvent != NULL)
	{
		CloseHandle(this->m_hCompletionOrUpdateEvent);
		this->m_hCompletionOrUpdateEvent = NULL;
	} // end if (have event)

	this->m_pFailureBreakRules = NULL;

	this->m_pfnGetStartupData = NULL;
	this->m_pfnLoadStartupData = NULL;
	this->m_pfnWriteStartupData = NULL;
	this->m_pfnHandleUserQuery = NULL;

	this->m_dwSessionID = 0;
	ZeroMemory(&this->m_testChecksum, sizeof (CHECKSUM));
	//this->m_hAllSlavesCommStatusEvent = NULL;
	this->m_dwCurrentUniqueID = 1;
	this->m_dwStartupTicks = 0;
	ZeroMemory(&(this->m_tStartupTime), sizeof (time_t));
	this->m_dwTimelimit = 0;
	this->m_dwAllowJoinersTime = 0;
	this->m_fJoinersAllowed = FALSE;
	this->m_fTestingComplete = FALSE;

	this->m_dwAutoReportHeaders = 0;
	this->m_dwAutoReportBodyStyle = 0;
	this->m_dwAutoReportFlags = 0;
	this->m_iAutoReportNumReports = -1;
	if (this->m_pszAutoReportDirpath != NULL)
	{
		LocalFree(this->m_pszAutoReportDirpath);
		this->m_pszAutoReportDirpath = NULL;
	} // end if (there's an autoreport dirpath)
	this->m_fAutoReportDeleteNonPrinted = FALSE;

	this->m_iTotalNumSlaves = 0;


	if (this->m_pvMetaMasterAddress != NULL)
	{
		LocalFree(this->m_pvMetaMasterAddress);
		this->m_pvMetaMasterAddress = NULL;
	} // end if (allocated a metamaster address)


	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNMaster::DestroyControlSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetSessionID()"
//==================================================================================
// CTNMaster::GetSessionID
//----------------------------------------------------------------------------------
//
// Description: Returns the identifier of the current session.
//
// Arguments: None.
//
// Returns: ID of current session.
//==================================================================================
DWORD CTNMaster::GetSessionID(void)
{
	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (0);
	} // end if (slave object is invalid)

	if (this->m_dwStartupTicks == 0)
	{
		DPL(0, "Session not started up, no ID yet.", 0);
		return (0);
	} // end if (we haven't fully started up yet)
	
	return (this->m_dwSessionID);
} // CTNMaster::GetSessionID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetModuleString()"
//==================================================================================
// CTNMaster::GetModuleString
//----------------------------------------------------------------------------------
//
// Description: Returns a string describing the currently loaded module.
//
// Arguments:
//	char* szString	String buffer to copy results in.  Should be able to hold 64
//					characters.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::GetModuleString(char* szString)
{
	/*
	if (! this->m_fInSession)
	{
		DPL(0, "Not in session yet, can't determine module ID!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (not in a session)
	*/
	
	wsprintf(szString, "%s v%02u.%02u.%02u.%04u", this->m_moduleID.szBriefName,
			this->m_moduleID.dwMajorVersion, this->m_moduleID.dwMinorVersion1,
			this->m_moduleID.dwMinorVersion2, this->m_moduleID.dwBuildVersion);
	
	return (S_OK);
} // CTNMaster::GetModuleString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetIndexedMachineInfo()"
//==================================================================================
// CTNMaster::GetIndexedMachineInfo
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the TNMachineInfo object for the machine
//				at the index specified if it exists, or NULL otherwise.
//
// Arguments:
//	int iMachineNum		The machine number in list to retrieve.
//
// Returns: Pointer to object or NULL if an error occurred.
//==================================================================================
PTNMACHINEINFO CTNMaster::GetIndexedMachineInfo(int iMachineNum)
{
	PTNSLAVEINFO	pSlave;


	pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(iMachineNum);

	if (pSlave == NULL)
		return (NULL);

	if (pSlave->m_commdata.fDropped)
		return (NULL);

	return ((PTNMACHINEINFO) pSlave);
} // CTNMaster::GetIndexedMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetTotalStats()"
//==================================================================================
// CTNMaster::GetTotalStats
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the total test table stats object.
//
// Arguments: None.
//
// Returns: Pointer to stats object, or NULL if an error occurred.
//==================================================================================
PTNTESTSTATS CTNMaster::GetTotalStats(void)
{
	return (&(this->m_totalstats));
} // CTNMaster::GetTotalStats
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetNumberOfCases()"
//==================================================================================
// CTNMaster::GetNumberOfCases
//----------------------------------------------------------------------------------
//
// Description: Returns the number of test cases loaded.
//
// Arguments: None.
//
// Returns: The number of test cases loaded, or -1 if an error occurred.
//==================================================================================
int CTNMaster::GetNumberOfCases(void)
{
	HRESULT		hr;
	int			iNumCases = 0;


	hr = this->m_testtable.GetNumberOfCases(&iNumCases);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get number of cases!  %e", 1, hr);
		return (-1);
	} // end if (couldn't get number of cases in the testtable)

	return (iNumCases);
} // CTNMaster::GetNumberOfCases
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetNumberOfActiveAndRemainingTests()"
//==================================================================================
// CTNMaster::GetNumberOfActiveAndRemainingTests
//----------------------------------------------------------------------------------
//
// Description: Returns the number of test instances left to run in the current
//				repetition.
//
// Arguments: None.
//
// Returns: The number of test instances left to run, or -1 if an error occurred.
//==================================================================================
int CTNMaster::GetNumberOfActiveAndRemainingTests(void)
{
	HRESULT			hr;
	int				iTotal;
	CTNTestMsList	usedtests;
	int				i;
	PTNSLAVEINFO	pSlave;


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (-1);
	} // end if (invalid object)

	iTotal = this->m_remainingtests.Count();
	if (iTotal < 0)
	{
		DPL(0, "Failed getting total number of tests in list!", 0);
		return (-1);
	} // end if (couldn't get total)


	this->m_slaves.EnterCritSection();
	for(i = 0; i < this->m_slaves.Count(); i++)
	{
		pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
		if (pSlave == NULL)
		{
			DPL(0, "Couldn't get slave %i!", 1, i);
			this->m_slaves.LeaveCritSection();
			return (-1);
		} // end if (couldn't get item)

		// If the slave has a current test
		if (pSlave->m_pCurrentTest != NULL)
		{
			// If we haven't seen this test before
			if (usedtests.GetFirstIndex(pSlave->m_pCurrentTest) < 0)
			{
				hr = usedtests.Add(pSlave->m_pCurrentTest);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add test %x to temp list!  %e",
						2, pSlave->m_pCurrentTest, hr);
					this->m_slaves.LeaveCritSection();
					return (-1);
				} // end if (couldn't get item)
			} // end if (haven't already added the test)
		} // end if (slave is currently working on a test)
	} // end for (each slave)

	// Add the number of unique tests all the slaves are currently running
	iTotal += usedtests.Count();

	this->m_slaves.LeaveCritSection();


	return (iTotal);
} // CTNMaster::GetNumberOfActiveAndRemainingTests
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetNumTestsSkipped()"
//==================================================================================
// CTNMaster::GetNumTestsSkipped
//----------------------------------------------------------------------------------
//
// Description: Returns the number of test instances that had to be skipped.
//
// Arguments: None.
//
// Returns: The number of test instances skipped, or -1 if an error occurred.
//==================================================================================
int CTNMaster::GetNumTestsSkipped(void)
{
	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (-1);
	} // end if (invalid object)

	return (this->m_skippedtests.Count());
} // CTNMaster::GetNumTestsSkipped
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::IsSessionClosed()"
//==================================================================================
// CTNMaster::IsSessionClosed
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if no more joiners are allowed, FALSE otherwise.
//
// Arguments: None.
//
// Returns: TRUE if no joiners allowed, FALSE otherwise.
//==================================================================================
BOOL CTNMaster::IsSessionClosed(void)
{
	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (FALSE);
	} // end if (invalid object)

	return ((this->m_fJoinersAllowed) ? FALSE : TRUE);
} // CTNMaster::IsSessionClosed
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::IsTestingComplete()"
//==================================================================================
// CTNMaster::IsTestingComplete
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if all tests intended to be run have actually been.
//
// Arguments: None.
//
// Returns: TRUE if all tests are run, FALSE otherwise.
//==================================================================================
BOOL CTNMaster::IsTestingComplete(void)
{
	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (FALSE);
	} // end if (invalid object)

	return (this->m_fTestingComplete);
} // CTNMaster::IsTestingComplete
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetCaseIndex()"
//==================================================================================
// CTNMaster::GetCaseIndex
//----------------------------------------------------------------------------------
//
// Description: Returns pointers to the ID, name, and stats for the case at the
//				given index.  If NULL is passed in for an argument, then that
//				item is not returned.
//
// Arguments:
//	int iIndex				Zero based index of case to retrieve.
//	char** ppszID,			Pointer to place to store pointer to the case ID string,
//							or NULL if not wanted.
//	char** ppszName			Pointer to place to store pointer to the case name
//							string, or NULL if not wanted.
//	PTNTESTSTATS* ppStats	Pointer to place to store pointer to the case stats, or
//							NULL if not wanted.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::GetCaseIndex(int iIndex, char** ppszID, char** ppszName,
								PTNTESTSTATS* ppStats)
{
	HRESULT				hr;
	int					iNumItemsLeft = iIndex;
	PTNTESTTABLECASE	pItem = NULL;


	hr = this->m_testtable.GetCaseIndex(&iNumItemsLeft, &pItem);
	if (hr != S_OK)
	{
		DPL(0, "Failed getting case index %i!", 1, iIndex);
		return (hr);
	} // end if (couldn't get that item)

	if (pItem == NULL)
	{
		DPL(0, "Couldn't find case index %i!", 1, iIndex);
		return (ERROR_INVALID_PARAMETER);
	} // end if (couldn't get that item)


	// Otherwise, we found it so return what we need to.

	if (ppszID != NULL)
		(*ppszID) = pItem->m_pszID;

	if (ppszName != NULL)
		(*ppszName) = pItem->m_pszName;

	if (ppStats != NULL)
		(*ppStats) = &(pItem->m_stats);

	return (S_OK);
} // CTNMaster::GetCaseIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SearchStringForDynamicVars()"
//==================================================================================
// CTNMaster::SearchStringForDynamicVars
//----------------------------------------------------------------------------------
//
// Description: Searches the given string for the first dynamic variable (string
//				surrounded by @ signs).  ppszNameFound is set to point to name (past
//				the first @ sign) and pdwNameLength is set to the length of the name
//				(not including the trailing @ sign, and no NULL termination
//				obviously).
//				The two output parameters will be set to NULL and zero if none was
//				found.
//
// Arguments:
//	char* szString				String to search.
//	char** ppszNameFound		Pointer to set to start of variable name found.
//	DWORD* pdwNameLength		Pointer to set to length of name string.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::SearchStringForDynamicVars(char* szString, char** ppszNameFound,
											DWORD* pdwNameLength)
{
	int		iStartPos;
	int		iEndPos;


	if ((szString == NULL) || (ppszNameFound == NULL) || (pdwNameLength == NULL))
	{
		DPL(0, "Must pass non-NULL parameters!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (got passed a bad parameter)


	(*ppszNameFound) = NULL;
	(*pdwNameLength) = 0;


	//BUGBUG we don't handle escaping

	iStartPos = StringContainsChar(szString, '@', TRUE, 0);
	if (iStartPos < 0)
	{
		return (S_OK);
	} // end if (didn't find a start token)

	iStartPos++; // skip token

	iEndPos = StringContainsChar(szString, '@', TRUE, iStartPos);
	if (iEndPos < 0)
	{
		return (S_OK);
	} // end if (didn't find an end token)

	(*ppszNameFound) = szString + iStartPos;
	(*pdwNameLength) = iEndPos - iStartPos;

	return (S_OK);
} // CTNMaster::SearchStringForDynamicVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::ExpandBuiltinStringVars()"
//==================================================================================
// CTNMaster::ExpandBuiltinStringVars
//----------------------------------------------------------------------------------
//
// Description: Expands all built-in dynamic variables of type "STRING" found in the
//				given string.  If the buffer pointer is NULL, the size need to hold
//				the new string is placed in pdwBufferSize, and
//				ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	char* szString			String to expand.
//	char* pszBuffer			Pointer to buffer to place results, or NULL to retrieve
//							size required.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::ExpandBuiltinStringVars(char* szString, char* pszBuffer,
											DWORD* pdwBufferSize)
{
	PTNOUTPUTVARSLIST	pList;


	if ((szString == NULL) || (pdwBufferSize == NULL))
	{
		DPL(0, "Must pass non-NULL parameters except for buffer!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (got passed a bad parameter)

	pList = &(this->m_builtinvars);
	return (this->InternalExpandStringVars(szString, pszBuffer, pdwBufferSize,
											&pList, 1));
} // CTNMaster::ExpandBuiltinStringVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::ExpandSlaveStringVars()"
//==================================================================================
// CTNMaster::ExpandSlaveStringVars
//----------------------------------------------------------------------------------
//
// Description: Expands all dynamic variables set by the slave and ones built-in of
//				type "STRING" found in the given string.  If the buffer pointer is
//				NULL, the size need to hold the new string is placed in
//				pdwBufferSize, and ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	char* szString			String to expand.
//	PTNMACHINEINFO pSlave	Pointer to slave to check.
//	char* pszBuffer			Pointer to buffer to place results, or NULL to retrieve
//							size required.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::ExpandSlaveStringVars(char* szString, PTNMACHINEINFO pSlave,
										char* pszBuffer, DWORD* pdwBufferSize)
{
	HRESULT				hr;
	PTNTESTINSTANCEM	pTest;
	int					iTesterNum;
	PTNOUTPUTVARSLIST*	papLists = NULL;
	DWORD				dwNumItems = 0;
	int					i;


	this->m_testswithvars.EnterCritSection();

	if ((szString == NULL) || (pSlave == NULL) || (pdwBufferSize == NULL))
	{
		DPL(0, "Must pass non-NULL parameters except for buffer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed a bad parameter)

	// Allocate enough room for all the tests in the list, plus 1 for the
	// built in vars list.
	papLists = (PTNOUTPUTVARSLIST*) LocalAlloc(LPTR, ((this->m_testswithvars.Count() + 1) * sizeof (PTNOUTPUTVARSLIST)));
	if (papLists == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Loop through all the tests with output variables.
	for(i = 0; i < this->m_testswithvars.Count(); i++)
	{
		pTest = (PTNTESTINSTANCEM) this->m_testswithvars.GetItem(i);
		if (pTest == NULL)
		{
			DPL(0, "Couldn't get test with data %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		// If the specified slave was assigned to this test and he generated output
		// variables, add his list into the array.
		iTesterNum = pTest->GetSlavesTesterNum((PTNSLAVEINFO) pSlave);

		if ((iTesterNum >= 0) &&
			(pTest->m_paTesterSlots[iTesterNum].pVars != NULL))
		{
			papLists[dwNumItems++] = pTest->m_paTesterSlots[iTesterNum].pVars;
		} // end if (this tester was assigned to the test)
	} // end for (each test with data)

	papLists[dwNumItems++] = &(this->m_builtinvars);

	hr = this->InternalExpandStringVars(szString, pszBuffer, pdwBufferSize,
										papLists, dwNumItems);

DONE:

	this->m_testswithvars.LeaveCritSection();

	SAFE_LOCALFREE(papLists);

	return (hr);
} // CTNMaster::ExpandSlaveStringVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::ExpandTestersStringVars()"
//==================================================================================
// CTNMaster::ExpandTestersStringVars
//----------------------------------------------------------------------------------
//
// Description: Expands all dynamic variables set by any of the currently assigned
//				testers or one of the ones built-in of type "STRING" found in the
//				given string.  If the buffer pointer is NULL, the size need to hold
//				the new string is placed in pdwBufferSize, and
//				ERROR_BUFFER_TOO_SMALL is returned.
//				IMPORTANT: If there are no testers assigned to a particular tester
//				number, that slot is skipped.  This means that you cannot assume you
//				will get the variable you expect if you designated the test as
//				TNTCO_ALLOWHEADSTART. 
//
// Arguments:
//	char* szString			String to expand.
//	PTNTESTINSTANCEM pTest	Pointer to test with slaves to check.
//	char* pszBuffer			Pointer to buffer to place results, or NULL to retrieve
//							size required.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::ExpandTestersStringVars(char* szString, PTNTESTINSTANCEM pTest,
										char* pszBuffer, DWORD* pdwBufferSize)
{
	HRESULT				hr;
	PTNOUTPUTVARSLIST*	papLists = NULL;
	int					i;
	DWORD				dwNumItems = 0;



	if ((szString == NULL) || (pTest == NULL) || (pdwBufferSize == NULL))
	{
		DPL(0, "Must pass non-NULL parameters except for buffer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed a bad parameter)


	// Allocate enough room for all the machines for the test, plus 1 for the
	// built in vars list.
	papLists = (PTNOUTPUTVARSLIST*) LocalAlloc(LPTR, ((pTest->m_iNumMachines + 1) * sizeof (PTNOUTPUTVARSLIST)));
	if (papLists == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	for(i = 0; i < pTest->m_iNumMachines; i++);
	{
		// If there variables in this slot, add the vars list.
		if (pTest->m_paTesterSlots[i].pVars != NULL)
		{
			papLists[dwNumItems++] = pTest->m_paTesterSlots[i].pVars;
		} // end if (there's actually a slave here)
	} // end for (each variable)

	papLists[dwNumItems++] = &(this->m_builtinvars);

	hr = this->InternalExpandStringVars(szString, pszBuffer, pdwBufferSize,
										papLists, dwNumItems);

DONE:

	SAFE_LOCALFREE(papLists);

	return (hr);
} // CTNMaster::ExpandTestersStringVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::IsBuiltinVarOfType()"
//==================================================================================
// CTNMaster::IsBuiltinVarOfType
//----------------------------------------------------------------------------------
//
// Description: Checks if the given string is a builtin dynamic variable of the
//				given type.  If it is, then a pointer to its value and its size are
//				returned.  Otherwise they are set to NULL and 0.
//
// Arguments:
//	char* szString				String to check.
//	char* szType				Type of variable expected.
//	PVOID* ppvValueLocation		Pointer to set to value.
//	DWORD* pdwValueSize			Place to store size of the value.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::IsBuiltinVarOfType(char* szString, char* szType,
									PVOID* ppvValueLocation,
									DWORD* pdwValueSize)
{
	PTNOUTPUTVARSLIST	pList;


	if ((szString == NULL) || (szType == NULL) || (ppvValueLocation == NULL) ||
		(pdwValueSize == NULL))
	{
		DPL(0, "Must pass non-NULL parameters!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (got passed a bad parameter)

	pList = &(this->m_builtinvars);
	return (this->InternalIsVarOfType(szString, szType, ppvValueLocation,
									pdwValueSize, &pList, 1));
} // CTNMaster::IsBuiltinVarOfType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::IsSlavesVarOfType()"
//==================================================================================
// CTNMaster::IsSlavesVarOfType
//----------------------------------------------------------------------------------
//
// Description: Checks if the given string is a dynamic variable set by the slave
//				or one of the ones built-in.  It must match the type given.  If one
//				is found, then a pointer to its value and its size are returned.
//				Otherwise they are set to NULL and 0.
//
// Arguments:
//	char* szString				String to check.
//	char* szType				Type of variable expected.
//	PTNMACHINEINFO pSlave		Pointer to slave to use.
//	PVOID* ppvValueLocation		Pointer to set to value.
//	DWORD* pdwValueSize			Place to store size of the value.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::IsSlavesVarOfType(char* szString, char* szType,
									PTNMACHINEINFO pSlave,
									PVOID* ppvValueLocation,
									DWORD* pdwValueSize)
{
	HRESULT				hr;
	PTNTESTINSTANCEM	pTest;
	int					iTesterNum;
	PTNOUTPUTVARSLIST*	papLists = NULL;
	DWORD				dwNumItems = 0;
	int					i;


	this->m_testswithvars.EnterCritSection();

	if ((szString == NULL) || (szType == NULL) || (pSlave == NULL) ||
		(ppvValueLocation == NULL) || (pdwValueSize == NULL))
	{
		DPL(0, "Must pass non-NULL parameters!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed a bad parameter)

	// Allocate enough room for all the tests in the list, plus 1 for the
	// built in vars list.
	papLists = (PTNOUTPUTVARSLIST*) LocalAlloc(LPTR, ((this->m_testswithvars.Count() + 1) * sizeof (PTNOUTPUTVARSLIST)));
	if (papLists == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Loop through all the tests with output variables.
	for(i = 0; i < this->m_testswithvars.Count(); i++)
	{
		pTest = (PTNTESTINSTANCEM) this->m_testswithvars.GetItem(i);
		if (pTest == NULL)
		{
			DPL(0, "Couldn't get test with data %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		// If the specified slave was assigned to this test and he generated output
		// variables, add his list into the array.
		iTesterNum = pTest->GetSlavesTesterNum((PTNSLAVEINFO) pSlave);

		if ((iTesterNum >= 0) &&
			(pTest->m_paTesterSlots[iTesterNum].pVars != NULL))
		{
			papLists[dwNumItems++] = pTest->m_paTesterSlots[iTesterNum].pVars;
		} // end if (this tester was assigned to the test)
	} // end for (each test with data)

	papLists[dwNumItems++] = &(this->m_builtinvars);

	hr = this->InternalIsVarOfType(szString, szType, ppvValueLocation,
									pdwValueSize, papLists, dwNumItems);

DONE:

	this->m_testswithvars.LeaveCritSection();

	SAFE_LOCALFREE(papLists);

	return (hr);
} // CTNMaster::IsSlavesVarOfType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::IsTestersVarOfType()"
//==================================================================================
// CTNMaster::IsTestersVarOfType
//----------------------------------------------------------------------------------
//
// Description: Checks if the given string is a dynamic variable set by any of the
//				currently assigned testers or one of the ones built-in.  It must
//				match the type given.  If it is, then a pointer to its value and its
//				size are returned.  Otherwise they are set to NULL and 0.
//				IMPORTANT: If there are no testers assigned to a particular tester
//				number, that slot is skipped.  This means that you cannot assume you
//				will get the variable you expect if you designated the test as
//				TNTCO_ALLOWHEADSTART. 
//
// Arguments:
//	char* szString				String to check.
//	char* szType				Type of variable required.
//	PTNTESTINSTANCEM pTest		Pointer to test with slaves to check.
//	PVOID* ppvValueLocation		Pointer to set to value.
//	DWORD* pdwValueSize			Place to store size of the value.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::IsTestersVarOfType(char* szString, char* szType,
									PTNTESTINSTANCEM pTest,
									LPVOID* ppvValueLocation,
									DWORD* pdwValueSize)
{
	HRESULT				hr;
	PTNOUTPUTVARSLIST*	papLists = NULL;
	int					i;
	DWORD				dwNumItems = 0;


	if ((szString == NULL) || (szType == NULL) || (pTest == NULL) ||
		(ppvValueLocation == NULL) || (pdwValueSize == NULL))
	{
		DPL(0, "Must pass non-NULL parameters!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed a bad parameter)

	// Allocate enough room for all the machines for the test, plus 1 for the
	// built in vars list.
	papLists = (PTNOUTPUTVARSLIST*) LocalAlloc(LPTR, ((pTest->m_iNumMachines + 1) * sizeof (PTNOUTPUTVARSLIST)));
	if (papLists == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	for(i = 0; i < pTest->m_iNumMachines; i++);
	{
		// If there's a slave assigned to this slot, add his vars list
		if (pTest->m_paTesterSlots[i].pVars != NULL)
		{
			papLists[dwNumItems++] = pTest->m_paTesterSlots[i].pVars;
			dwNumItems++;
		} // end if (there's actually a slave here)
	} // end for (each variable)

	papLists[dwNumItems++] = &(this->m_builtinvars);

	hr = this->InternalIsVarOfType(szString, szType, ppvValueLocation,
									pdwValueSize, papLists, dwNumItems);

DONE:

	SAFE_LOCALFREE(papLists);

	return (hr);
} // CTNMaster::IsTestersVarOfType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::PrintTestTableToFile()"
//==================================================================================
// CTNMaster::PrintTestTableToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the table of all tests loaded to the specified file path.
//
// Arguments:
//	char* szFilepath	Filepath to print to.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::PrintTestTableToFile(char* szFilepath)
{
	HRESULT		hr;
	HANDLE		hFile = INVALID_HANDLE_VALUE;


	hr = FileCreateAndOpenFile(szFilepath, FALSE, FALSE, FALSE, &hFile);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't open file \"%s\"!", 1, szFilepath);
		goto DONE;
	} // end if (couldn't open file)

	this->Log(TNLST_CONTROLLAYER_INFO, "Printing test table to file %s",
			1, szFilepath);


	// Ignoring error
	FileWriteLine(hFile, "ID\tName");
	FileWriteLine(hFile, "--\t----");

	hr = this->m_testtable.PrintToFile(hFile, TNTTPO_BUILTIN | TNTTPO_GROUPS);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't print test table to file \"%s\"!", 1, szFilepath);
	} // end if (couldn't open file)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opened file)

	return (hr);
} // CTNMaster::PrintTestTableToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::PrintResultsToFile()"
//==================================================================================
// CTNMaster::PrintResultsToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the current success/failure results for all tests loaded to
//				the specified file.
//
// Arguments:
//	char* szFilepath	Filepath to print to.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::PrintResultsToFile(char* szFilepath)
{
	HRESULT		hr;
	HANDLE		hFile = INVALID_HANDLE_VALUE;


	hr = FileCreateAndOpenFile(szFilepath, FALSE, FALSE, FALSE, &hFile);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't open \"%s\" for writing!", 1, szFilepath);
		goto DONE;
	} // end if (couldn't open file)

	this->Log(TNLST_CONTROLLAYER_INFO, "Printing test results to file %s",
			1, szFilepath);

	// Ignoring error
	FileWriteLine(hFile, " ID \t Name \t Successes \t Failures \t Total Run \t Warnings ");
	FileWriteLine(hFile, "----\t------\t-----------\t----------\t-----------\t----------");

	hr = this->m_testtable.PrintToFile(hFile, TNTTPO_SUCCESSES | TNTTPO_FAILURES | TNTTPO_TOTAL | TNTTPO_WARNINGS);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't print test results to file \"%s\"!", 1, szFilepath);
	} // end if (couldn't open file)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opened file)

	return (hr);
} // CTNMaster::PrintResultsToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::PrintReports()"
//==================================================================================
// CTNMaster::PrintReports
//----------------------------------------------------------------------------------
//
// Description: Prints the contents of the report log to the file specified (or
//				depending on the style, to individual files in the directory
//				specified).
//
// Arguments:
//	DWORD dwHeaders			Which headers should be printed.
//	DWORD dwBodyStyle		How the report log body should be printed.
//	DWORD dwFlags			What in the report log should be printed.
//	char* szFilepath		Where the report log should be printed.
//	BOOL fAppend			Should we add to (instead of overwrite) the file if it exists?
//	BOOL fDeletePrinted		Should the reports that were printed be removed from the
//							report log?
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::PrintReports(DWORD dwHeaders, DWORD dwBodyStyle, DWORD dwFlags,
								char* szFilepath, BOOL fAppend, BOOL fDeletePrinted)
{
	HRESULT				hr = S_OK;
	int					i;
	PTNREPORT			pReport = NULL;
	PTNSLAVEINFO		pSlave = NULL;
	PTNTESTINSTANCEM	pTest = NULL;
	HANDLE				hFile = INVALID_HANDLE_VALUE;
	CTNSlavesList		machinelist;
	CTNTestMsList		currenttotaltestlist;
	CTNTestMsList		testlist;


	DPL(5, "Printing reports to \"%s\".", 1, szFilepath);


	hr = FileCreateAndOpenFile(szFilepath, FALSE, fAppend, FALSE, &hFile);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't create the report file %s!", 1, szFilepath);
		goto DONE;
	} // end if (couldn't create file)

	this->Log(TNLST_CONTROLLAYER_INFO, "Printing reports to file \"%s\".",
			1, szFilepath);


	hr = this->DoBeginReport(hFile, dwHeaders);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't print beginning report items!", 0);
		goto DONE;
	} // end if (failed to print beginning report stuff)


	// Now print the reports requested.  Start by getting the first machine
	// or test if we're organizing them those ways

	this->m_slaves.EnterCritSection();
	this->m_reports.EnterCritSection();


	// Just for coolness, print a comment with how many reports are being printed
	// and how many there are in the log total.

	i = this->CountMatchingReports(dwFlags, NULL, NULL);

	DPL(1, "Printing %i reports out of %i total.",
		2, i, this->m_reports.Count());

	// Skip this when using the BVT format, though.
	if (! this->m_fReportInBVTFormat)
	{
		//FileWriteLine(hFile, ""); // double space
		FileSprintfWriteLine(hFile, "// Printing %i reports out of %i total.",
							2, i, this->m_reports.Count());
		FileWriteLine(hFile, ""); // double space
	} // end if (not BVT format)


	pReport = NULL;

	do
	{
		pReport = this->m_reports.GetNextMatchingReport(pReport, dwFlags,
														&machinelist, &testlist,
														fDeletePrinted);
		if (pReport == NULL)
		{
			// We're done.
			break;
		} // end if (no more matching reports)

		// BUGBUG always printing description for now

		if (dwBodyStyle == TNRBS_PLAIN_VERBOSE)
		{
			hr = pReport->PrintToFile(hFile, TRUE, this->m_fReportInBVTFormat);
		} // end if (we're printing verbosely)
		else
		{
			hr = pReport->PrintToFile(hFile, FALSE, this->m_fReportInBVTFormat);
		} // end else (we're not printing verbosely)

		if (hr != S_OK)
		{
			DPL(0, "Failed to print report to file!", 0);
			break;
		} // end if (failed to print report)

		// Double space
		FileWriteLine(hFile, "");
		FileWriteLine(hFile, "");
	} // end do
	while (TRUE); // while we found a matching item

	this->m_reports.LeaveCritSection();
	this->m_slaves.LeaveCritSection();


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opened file)

	return (hr);
} // CTNMaster::PrintReports
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SetMaxNumberReports()"
//==================================================================================
// CTNMaster::SetMaxNumberReports
//----------------------------------------------------------------------------------
//
// Description: Sets the maximum number of reports the report log will store before
//				throwing out old reports to make room for new ones.
//
// Arguments:
//	int iNumReports		How many reports to keep.
//
// Returns: None.
//==================================================================================
void CTNMaster::SetMaxNumberReports(int iNumReports)
{
	this->m_reports.SetMaxNumberReports(iNumReports);
} // CTNMaster::SetMaxNumberReports
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::AutoPrintReports()"
//==================================================================================
// CTNMaster::AutoPrintReports
//----------------------------------------------------------------------------------
//
// Description: This enables automatic printing of the report log when it reaches a
//				certain size.  Pass -1 for iNumReports to disable.
//				Note that all printed items are automatically removed from the log,
//				and if fDeleteNonPrinted is TRUE, everything is removed from the
//				report log.
//
// Arguments:
//	DWORD dwHeaders			Which headers should be printed.
//	DWORD dwBodyStyle		How the report log body should be counted and printed.
//	DWORD dwFlags			What in the report log should be counted and printed.
//	int iNumReports			How often should the log be printed (when the log is
//							this big, the report log will be auto printed).  If
//							this is -1, auto-printing is disabled.
//	char* szDirpath			Directory where the report logs should be printed.
//	BOOL fDeleteNonPrinted	Should the reports that weren't printed also be removed
//							from the report log?
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::AutoPrintReports(DWORD dwHeaders, DWORD dwBodyStyle, DWORD dwFlags,
									int iNumReports, char* szDirpath, BOOL fDeleteNonPrinted)
{
	HRESULT		hr = S_OK;
	DWORD		dwSize;


	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got bad pointer)


	DPL(7, "Setting autoprint reports options (flags = %x, num reports = %i, path = \"%s\").",
		3, dwFlags, iNumReports, szDirpath);

	// Take lock
	this->m_reports.EnterCritSection();

	if (iNumReports < 0)
		goto DISABLE;


	this->m_dwAutoReportHeaders = dwHeaders;
	this->m_dwAutoReportBodyStyle = dwBodyStyle;
	this->m_dwAutoReportFlags = dwFlags;
	this->m_iAutoReportNumReports = iNumReports;

	if (this->m_pszAutoReportDirpath != NULL)
	{
		LocalFree(this->m_pszAutoReportDirpath);
		this->m_pszAutoReportDirpath = NULL;
	} // end if (there was a dirpath)

	// Make sure the path ends in a backslash.
	dwSize = strlen(szDirpath) + 1;
	if (! StringEndsWith(szDirpath, "\\", TRUE))
		dwSize++;

	this->m_pszAutoReportDirpath = (char*) LocalAlloc(LPTR, dwSize);
	if (this->m_pszAutoReportDirpath == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DISABLE;
	} // end if (couldn't allocate memory)

	strcpy(this->m_pszAutoReportDirpath, szDirpath);
	if (! StringEndsWith(szDirpath, "\\", TRUE))
		strcat(this->m_pszAutoReportDirpath, "\\");

	this->m_fAutoReportDeleteNonPrinted = fDeleteNonPrinted;

	// Drop lock
	this->m_reports.LeaveCritSection();


	return (S_OK);


DISABLE:

	this->m_dwAutoReportHeaders = 0;
	this->m_dwAutoReportBodyStyle = 0;
	this->m_dwAutoReportFlags = 0;
	this->m_iAutoReportNumReports = -1;

	if (this->m_pszAutoReportDirpath != NULL)
	{
		LocalFree(this->m_pszAutoReportDirpath);
		this->m_pszAutoReportDirpath = NULL;
	} // end if (there was a dirpath)

	this->m_fAutoReportDeleteNonPrinted = FALSE;

	// Drop lock
	this->m_reports.LeaveCritSection();

	return (hr);
} // CTNMaster::AutoPrintReports
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::AreOnSameMachine()"
//==================================================================================
// CTNMaster::AreOnSameMachine
//----------------------------------------------------------------------------------
//
// Description: Checks whether the two given slaves are located on the same machine
//				and returns TRUE if so, FALSE if not.
//
// Arguments:
//	PTNMACHINEINFO pFirstSlave		Pointer to first machine to check.
//	PTNMACHINEINFO pSecondSlave		Pointer to other machine to check.
//
// Returns: TRUE if slaves are on same machine, FALSE otherwise.
//==================================================================================
BOOL CTNMaster::AreOnSameMachine(PTNMACHINEINFO pFirstSlave,
								PTNMACHINEINFO pSecondSlave)
{
	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (FALSE);
	} // end if (got bad pointer)

	if ((pFirstSlave == NULL) || (pSecondSlave == NULL))
	{
		DPL(0, "One or both of the two machine pointers (%x, %x) machine is NULL!",
			2, pFirstSlave, pSecondSlave);
		return (FALSE);
	} // end if (source or target are NULL)


	// If their multi-instance keys are different, they can't be on the same machine.
	if (((PTNSLAVEINFO) pFirstSlave)->m_dwMultiInstanceKey != ((PTNSLAVEINFO) pSecondSlave)->m_dwMultiInstanceKey)
	{
		return (FALSE);
	} // end if (keys are different)


	return (TRUE);
} // CTNMaster::AreOnSameMachine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CanReachViaIP()"
//==================================================================================
// CTNMaster::CanReachViaIP
//----------------------------------------------------------------------------------
//
// Description: Checks whether the given connector can reach the given listener via
//				the TCP/IP methods specified.  If so pfReachable is set to TRUE,
//				otherwise it is set to FALSE.
//				This should only be called from within a module's CanRun callback
//				because the slave list lock is assumed to be held with only one
//				level of recursion.
//
// Arguments:
//	PTNMACHINEINFO pConnector	Pointer to machine doing the connecting.
//	PTNMACHINEINFO pListener	Pointer to machine whose address is to be retrieved.
//	WORD wPort					Port to attempt the communication on.
//	DWORD dwMethodFlags			What type of communication is required.  Any
//								combination of TNCR_IP_xxx flags.
//	BOOL* pfReachable			Pointer to boolean to fill with TRUE if the
//								specified communication is possible, FALSE if not.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::CanReachViaIP(PTNMACHINEINFO pConnector,
								PTNMACHINEINFO pListener,
								WORD wPort,
								DWORD dwMethodFlags,
								BOOL* pfReachable)
{
	HRESULT					hr = S_OK;
	PTNSLAVEINFO			pSource = (PTNSLAVEINFO) pConnector;
	PTNSLAVEINFO			pTarget = (PTNSLAVEINFO) pListener;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	DWORD					dwRemainingFlags = dwMethodFlags;
	DWORD					dwMethod = 0;
	PTNREACHCHECK			pReachCheck = NULL;
	PVOID					pvAddresses = NULL;
	DWORD					dwAddressesSize = 0;
	CTNIPAddressesList		acceptips;
	PTNIPADDRESS			pAddress = NULL;


	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got bad pointer)

	if ((pSource == NULL) || (pTarget == NULL))
	{
		DPL(0, "Either the source (%x) or the target (%x) machine is NULL, both must exist!",
			2, pSource, pTarget);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (source or target are NULL)

	if (pSource == pTarget)
	{
		DPL(0, "The source and the target machines specified are the same (%x)!",
			1, pSource);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (source and target are same)

	if (wPort == 0)
	{
		DPL(0, "Must specify a valid port to use!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (there's no port)

	if (dwMethodFlags & (~(TNCR_IP_UDPBROADCAST | TNCR_IP_UDP | TNCR_IP_TCP)))
	{
		DPL(0, "Invalid flags specified (%x)!", 1, dwMethodFlags);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (invalid flags specified)

	if (pfReachable == NULL)
	{
		DPL(0, "Must specify a pointer to a boolean to store result in!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (no boolean specified)

	// Start by assuming it can't be reached.
	(*pfReachable) = FALSE;


	// If the slaves are actually 2 instances on the same machine, it's always
	// going to fail (both can't have the same port open).
	if (this->AreOnSameMachine(pSource, pTarget))
	{
		DPL(1, "Source and target slaves (IDs %u and %u) are on same machine (%s).",
			3, pSource->m_id.dwTime, pTarget->m_id.dwTime,
			pSource->m_szComputerName);
		goto DONE;
	} // end if (on same machine)


	// Look if we've already run this check before.

	pReachCheckTarget = pSource->m_reachchecktargets.GetTarget(&(pTarget->m_id));
	if (pReachCheckTarget != NULL)
	{
		for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
		{
			pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
			if (pReachCheck == NULL)
			{
				DPL(0, "Couldn't get reach check %i!", i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)


			// If we're still looking for a UDP broadcast check and this is one,
			// we've got a result.
			if ((dwRemainingFlags & TNCR_IP_UDPBROADCAST) &&
				(pReachCheck->m_dwMethod == TNRCM_UDPBROADCAST) &&
				(*((WORD*) pReachCheck->m_pvMethodData) == wPort))
			{
				// We've found a UDP broadcast check, we can stop looking for it.
				dwRemainingFlags = dwRemainingFlags & (~ TNCR_IP_UDPBROADCAST);

				// If the check failed, we can stop searching.
				if (! pReachCheck->m_fResult)
				{
					DPL(3, "%s couldn't reach %s via UDP broadcast on port %u earlier.",
						3, pSource->m_szComputerName,
						pTarget->m_szComputerName, wPort);
					goto DONE;
				} // end if (check failed)
			} // end if (found UDP broadcast)
			else if ((dwRemainingFlags & TNCR_IP_UDP) &&
					(pReachCheck->m_dwMethod == TNRCM_UDP) &&
					(*((WORD*) pReachCheck->m_pvMethodData) == wPort))
			{
				// We've found a UDP check, we can stop looking for it.
				dwRemainingFlags = dwRemainingFlags & (~ TNCR_IP_UDP);

				// If the check failed, we can stop searching.
				if (! pReachCheck->m_fResult)
				{
					DPL(3, "%s couldn't reach %s via directed UDP on port %u earlier.",
						3, pSource->m_szComputerName,
						pTarget->m_szComputerName, wPort);
					goto DONE;
				} // end if (check failed)
			} // end if (found UDP)
			else if ((dwRemainingFlags & TNCR_IP_TCP) &&
					(pReachCheck->m_dwMethod == TNRCM_TCP) &&
					(*((WORD*) pReachCheck->m_pvMethodData) == wPort))
			{
				// We've found a TCP check, we can stop looking for it.
				dwRemainingFlags = dwRemainingFlags & (~ TNCR_IP_TCP);

				// If the check failed, we can stop searching.
				if (! pReachCheck->m_fResult)
				{
					DPL(3, "%s couldn't reach %s via directed TCP on port %u earlier.",
						3, pSource->m_szComputerName,
						pTarget->m_szComputerName, wPort);
					goto DONE;
				} // end if (check failed)
			} // end if (found TCP)


			// If we found all the checks we need, and they were all successful,
			// we're done here.
			if (dwRemainingFlags == 0)
			{
				DPL(3, "%s successfully reached %s with the method(s) specified (flags = %x) earlier.",
					3, pSource->m_szComputerName, pTarget->m_szComputerName,
					dwMethodFlags);

				(*pfReachable) = TRUE;

				goto DONE;
			} // end if (found all checks we need)
		} // end for (each check)
	} // end if (source had tried to reach target before in some way)


	// If we're here, it means that either the source has never tried to reach the
	// target, or at least not in all of the IP ways requested.  We have to perform
	// the checks now.

	// Build a list of possible IPs for the connector to try.  Start with all the IP
	// addresses associated with the accepting slave.
	pTarget->m_ipaddrs.EnterCritSection();

	DPL(8, "Target %s has %i IP addresses.",
		2, pTarget->m_szComputerName, pTarget->m_ipaddrs.Count());

	for (i = 0; i < pTarget->m_ipaddrs.Count(); i++)
	{
		pAddress = (PTNIPADDRESS) pTarget->m_ipaddrs.GetItem(i);
		if (pAddress == NULL)
		{
			pTarget->m_ipaddrs.LeaveCritSection();
			DPL(0, "Couldn't get our IP item %i!", 1, i);
			goto DONE;
		} // end if (couldn't get item)

		// Add it (actually an alias to it) to the list we're building.
		hr = acceptips.Add(pAddress);
		if (hr != S_OK)
		{
			pTarget->m_ipaddrs.LeaveCritSection();
			DPL(0, "Couldn't add alias to acceptor's IP address to temporary list!", 0);
			goto DONE;
		} // end if (couldn't add alias)
	} // end for (each IP in the list)
	pTarget->m_ipaddrs.LeaveCritSection();


	// If we (the master) are considered behind a NAT by some slaves, it's
	// possible this particular acceptor slave is behind the same NAT.  Have
	// the connector try any of those IPs, too.
	// BUGBUG it would be best to only pass in the one NAT IP if this particular
	// connector sees one.
	this->m_ipaddrs.EnterCritSection();
	for (i = 0; i < this->m_ipaddrs.Count(); i++)
	{
		pAddress = (PTNIPADDRESS) this->m_ipaddrs.GetItem(i);
		if (pAddress == NULL)
		{
			this->m_ipaddrs.LeaveCritSection();
			DPL(0, "Couldn't get our IP item %i!", 1, i);
			goto DONE;
		} // end if (couldn't get item)

		// If it's not a NAT address, skip it
		if (pAddress->m_dwType != TNIPADDR_NAT)
			continue;

		// Add it (actually an alias to it) to the list we're building.
		hr = acceptips.Add(pAddress);
		if (hr != S_OK)
		{
			this->m_ipaddrs.LeaveCritSection();
			DPL(0, "Couldn't add alias to one of our NAT IP address to temporary list!", 0);
			goto DONE;
		} // end if (couldn't add alias)
	} // end for (each IP in the list)
	this->m_ipaddrs.LeaveCritSection();



	//Ignore error, assume BUFFER_TOO_SMALL
	acceptips.PackIntoBuffer(NULL, &dwAddressesSize);

	pvAddresses = LocalAlloc(LPTR, dwAddressesSize);
	if (pvAddresses == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	hr = acceptips.PackIntoBuffer(pvAddresses, &dwAddressesSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack accept IP addresses into a buffer!", 0);
		goto DONE;
	} // end if (couldn't pack into buffer)


	DPL(5, "Packed %i IP addresses for %s to try reaching %s with into %u byte buffer (at %x).",
		5, acceptips.Count(), pSource->m_szComputerName,
		pTarget->m_szComputerName, dwAddressesSize, pvAddresses);


	do
	{
		if (dwRemainingFlags & TNCR_IP_UDPBROADCAST)
		{
			// Turn off the UDP broadcast flag, since we're doing it now.
			dwRemainingFlags = dwRemainingFlags & (~ TNCR_IP_UDPBROADCAST);

			dwMethod = TNRCM_UDPBROADCAST;

			DPL(1, "Having %s try to reach %s via UDP broadcast on port %u.",
				3, pSource->m_szComputerName, pTarget->m_szComputerName, wPort);
		} // end if (need to do UDP broadcast still)
		else if (dwRemainingFlags & TNCR_IP_UDP)
		{
			// Turn off the UDP flag, since we're doing it now.
			dwRemainingFlags = dwRemainingFlags & (~ TNCR_IP_UDP);

			dwMethod = TNRCM_UDP;

			DPL(1, "Having %s try to reach %s via directed UDP sends on port %u.",
				3, pSource->m_szComputerName, pTarget->m_szComputerName, wPort);
		} // end else if (need to do UDP still)
		else if (dwRemainingFlags & TNCR_IP_TCP)
		{
			// Turn off the TCP flag, since we're doing it now.
			dwRemainingFlags = dwRemainingFlags & (~ TNCR_IP_TCP);

			dwMethod = TNRCM_TCP;

			DPL(1, "Having %s try to reach %s via directed TCP sends on port %u.",
				3, pSource->m_szComputerName, pTarget->m_szComputerName, wPort);
		} // end else if (need to do TCP still)
#ifdef DEBUG
		else
		{
			DPL(0, "Got into a wierd state!  dwRemainingFlags=%x  DEBUGBREAK()-ing.",
				1, dwRemainingFlags);

			DEBUGBREAK();

			hr = E_FAIL;
			goto DONE;
		} // end else (something wierd)
#endif // DEBUG


		hr = this->PerformReachCheck(dwMethod,
									pSource,
									&wPort,
									sizeof (WORD),
									((dwMethod == TNRCM_UDPBROADCAST) ? NULL : pvAddresses),
									((dwMethod == TNRCM_UDPBROADCAST) ? 0 : dwAddressesSize),
									pTarget,
									&wPort,
									sizeof (WORD),
									pfReachable);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't have %s perform IP reachability test via port %u to %s!",
				3, pSource->m_szComputerName, wPort, pTarget->m_szComputerName);
			goto DONE;
		} // end if (couldn't perform reach test)

		if ((*pfReachable) == FALSE)
		{
			DPL(0, "WARNING: %s can't reach %s via %s on port %u.",
				4, pSource->m_szComputerName, pTarget->m_szComputerName,
				((dwMethod == TNRCM_UDPBROADCAST) ? "UDP broadcast" : ((dwMethod == TNRCM_UDP) ? "UDP" : "TCP")),
				wPort);

			this->Log(TNLST_CRITICAL,
					"WARNING: %s can't reach %s via %s on port %u!",
					4, pSource->m_szComputerName, pTarget->m_szComputerName,
					((dwMethod == TNRCM_UDPBROADCAST) ? "UDP broadcast" : ((dwMethod == TNRCM_UDP) ? "UDP" : "TCP")),
					wPort);

			goto DONE;
		} // end if (source couldn't reach target)
	} // end do (while still methods left to check)
	while (dwRemainingFlags != 0);


DONE:

	if (pvAddresses != NULL)
	{
		LocalFree(pvAddresses);
		pvAddresses = NULL;
	} // end if (allocated buffer)

	return (hr);
} // CTNMaster::CanReachViaIP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CanReachViaIPX()"
//==================================================================================
// CTNMaster::CanReachViaIPX
//----------------------------------------------------------------------------------
//
// Description: Checks whether the first given machine can send data to and get a
//				reply from the second machine via IPX.  If so pfReachable is set to
//				TRUE, otherwise it is set to FALSE.
//				This should only be called from within a module's CanRun callback
//				because the slave list lock is assumed to be held with only one
//				level of recursion.
//
// Arguments:
//	PTNMACHINEINFO pSender		Pointer to machine doing the initial sending.
//	PTNMACHINEINFO pReceiver	Pointer to machine doing the initial receiving.
//	BOOL* pfReachable			Pointer to boolean to fill with TRUE if the
//								specified communication is possible, FALSE if not.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::CanReachViaIPX(PTNMACHINEINFO pSender,
									PTNMACHINEINFO pReceiver,
									BOOL* pfReachable)
{
	HRESULT					hr = S_OK;
	PTNSLAVEINFO			pSource = (PTNSLAVEINFO) pSender;
	PTNSLAVEINFO			pTarget = (PTNSLAVEINFO) pReceiver;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;


	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got bad pointer)

	if ((pSource == NULL) || (pTarget == NULL))
	{
		DPL(0, "Either the source (%x) or the target (%x) machine is NULL, both must exist!",
			2, pSource, pTarget);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (source or target are NULL)

	if (pSource == pTarget)
	{
		DPL(0, "The source and the target machines specified are the same (%x)!",
			1, pSource);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (source and target are same)

	if (pfReachable == NULL)
	{
		DPL(0, "Must specify a pointer to a boolean to store result in!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (no boolean specified)

	// Start by assuming it can't be reached.
	(*pfReachable) = FALSE;


	// If the slaves are actually 2 instances on the same machine, it's always
	// going to fail.
	if (this->AreOnSameMachine(pSource, pTarget))
	{
		DPL(1, "Source and target slaves (IDs %u and %u) are on same machine (%s).",
			3, pSource->m_id.dwTime, pTarget->m_id.dwTime,
			pSource->m_szComputerName);
		goto DONE;
	} // end if (on same machine)


	// Look if we've already run this check before.

	pReachCheckTarget = pSource->m_reachchecktargets.GetTarget(&(pTarget->m_id));
	if (pReachCheckTarget != NULL)
	{
		for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
		{
			pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
			if (pReachCheck == NULL)
			{
				DPL(0, "Couldn't get reach check %i!", i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)


			// If we're found an IPX check already existing, we've got the
			// result we need.
			if (pReachCheck->m_dwMethod == TNRCM_IPX)
			{
				if (pReachCheck->m_fResult)
				{
					DPL(3, "%s already successfully sent to %s earlier.",
						2, pSource->m_szComputerName,
						pTarget->m_szComputerName);
				} // end if (check succeeded)
				else
				{
					DPL(3, "%s couldn't send to %s earlier.",
						2, pSource->m_szComputerName,
						pTarget->m_szComputerName);
				} // end else (check failed)

				(*pfReachable) = pReachCheck->m_fResult;

				goto DONE;
			} // end if (found IPX check)
		} // end for (each check)
	} // end if (source had tried to reach target before in some way)


	// If we're here, it means that either the source has never tried to reach the
	// target via IPX.  We have to perform the check now.


	if (! pSource->m_fIPXInstalled)
	{
		DPL(0, "Source %s doesn't have IPX installed, can't connect to %s.",
			2, pSource->m_szComputerName, pTarget->m_szComputerName);
		goto DONE;
	} // end if (couldn't get object)

	if (! pTarget->m_fIPXInstalled)
	{
		DPL(0, "Target %s doesn't have IPX installed, can't be connected to by %s.",
			2, pTarget->m_szComputerName, pSource->m_szComputerName);
		goto DONE;
	} // end if (couldn't get object)


	hr = this->PerformReachCheck(TNRCM_IPX,
								pSource,
								NULL,
								0,
								NULL,
								0,
								pTarget,
								NULL,
								0,
								pfReachable);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't have %s perform IPX reachability test to %s!",
			2, pSource->m_szComputerName, pTarget->m_szComputerName);
		goto DONE;
	} // end if (couldn't perform reach test)

	if ((*pfReachable) == FALSE)
	{
		DPL(0, "WARNING: %s can't reach %s via IPX!",
			2, pSource->m_szComputerName, pTarget->m_szComputerName);

		this->Log(TNLST_CRITICAL,
				"WARNING: %s can't reach %s via IPX!",
				2, pSource->m_szComputerName, pTarget->m_szComputerName);

		goto DONE;
	} // end if (source couldn't reach target)


DONE:

	return (hr);
} // CTNMaster::CanReachViaIPX
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CanReachViaModem()"
//==================================================================================
// CTNMaster::CanReachViaModem
//----------------------------------------------------------------------------------
//
// Description: Checks whether the given caller can connect to the given answerer
//				via a modem.  If so pfReachable is set to TRUE, otherwise it is set
//				to FALSE.
//				This should only be called from within a module's CanRun callback
//				because the slave list lock is assumed to be held with only one
//				level of recursion.
//
// Arguments:
//	PTNMACHINEINFO pCaller		Pointer to machine doing the calling.
//	PTNMACHINEINFO pAnswerer	Pointer to machine whose modem is to be called.
//	BOOL* pfReachable			Pointer to boolean to fill with TRUE if the
//								specified communication is possible, FALSE if not.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::CanReachViaModem(PTNMACHINEINFO pCaller,
									PTNMACHINEINFO pAnswerer,
									BOOL* pfReachable)
{
	HRESULT					hr = S_OK;
	PTNSLAVEINFO			pSource = (PTNSLAVEINFO) pCaller;
	PTNSLAVEINFO			pTarget = (PTNSLAVEINFO) pAnswerer;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;
	char*					pszSourceDeviceNumber = NULL;
	char*					pszTargetDeviceNumber = NULL;


	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got bad pointer)

	if ((pSource == NULL) || (pTarget == NULL))
	{
		DPL(0, "Either the source (%x) or the target (%x) machine is NULL, both must exist!",
			2, pSource, pTarget);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (source or target are NULL)

	if (pSource == pTarget)
	{
		DPL(0, "The source and the target machines specified are the same (%x)!",
			1, pSource);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (source and target are same)

	if (pfReachable == NULL)
	{
		DPL(0, "Must specify a pointer to a boolean to store result in!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (no boolean specified)

	// Start by assuming it can't be reached.
	(*pfReachable) = FALSE;


	// If the slaves are actually 2 instances on the same machine, it's always
	// going to fail.
	if (this->AreOnSameMachine(pSource, pTarget))
	{
		DPL(1, "Source and target slaves (IDs %u and %u) are on same machine (%s).",
			3, pSource->m_id.dwTime, pTarget->m_id.dwTime,
			pSource->m_szComputerName);
		goto DONE;
	} // end if (on same machine)


	// Look if we've already run this check before.

	pReachCheckTarget = pSource->m_reachchecktargets.GetTarget(&(pTarget->m_id));
	if (pReachCheckTarget != NULL)
	{
		for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
		{
			pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
			if (pReachCheck == NULL)
			{
				DPL(0, "Couldn't get reach check %i!", i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)


			// If we're found a modem check already existing, we've got the
			// result we need.
			if (pReachCheck->m_dwMethod == TNRCM_MODEM)
			{
				if (pReachCheck->m_fResult)
				{
					DPL(3, "%s already successfully called %s earlier.",
						2, pSource->m_szComputerName,
						pTarget->m_szComputerName);
				} // end if (check succeeded)
				else
				{
					DPL(3, "%s couldn't connect to %s earlier.",
						2, pSource->m_szComputerName,
						pTarget->m_szComputerName);
				} // end else (check failed)

				(*pfReachable) = pReachCheck->m_fResult;

				goto DONE;
			} // end if (found modem check)
		} // end for (each check)
	} // end if (source had tried to reach target before in some way)


	// If we're here, it means that either the source has never tried to reach the
	// target via modem.  We have to perform the check now.


#pragma BUGBUG(vanceo, "Check specific modems")
	hr = pSource->m_TAPIdevices.GetFirstTAPIDeviceNumber(&pszSourceDeviceNumber);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get source %s's first TAPI device number.  %e",
			2, pSource->m_szComputerName, hr);

		// We'll assume that means there is no modem device.
		hr = S_OK;

		goto DONE;
	} // end if (couldn't get device number)

	hr = pTarget->m_TAPIdevices.GetFirstTAPIDeviceNumber(&pszTargetDeviceNumber);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get target %s's first TAPI device number.  %e",
			2, pTarget->m_szComputerName, hr);

		// We'll assume that means there is no modem device.
		hr = S_OK;

		goto DONE;
	} // end if (couldn't get device number)


	DPL(5, "Got \"%s\" as number for %s when trying to reach %s (calling from \"%s\").",
		4, pszTargetDeviceNumber, pSource->m_szComputerName,
		pTarget->m_szComputerName, pszTargetDeviceNumber);


	hr = this->PerformReachCheck(TNRCM_MODEM,
								pSource,
								NULL,
								0,
								pszTargetDeviceNumber,
								(strlen(pszTargetDeviceNumber) + 1),
								pTarget,
								NULL,
								0,
								pfReachable);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't have %s perform modem reachability test to %s (number = \"%s\")!",
			3, pSource->m_szComputerName, pTarget->m_szComputerName,
			pszTargetDeviceNumber);
		goto DONE;
	} // end if (couldn't perform reach test)

	if ((*pfReachable) == FALSE)
	{
		DPL(0, "WARNING: %s can't reach %s via modem (number = \"%s\")!",
			3, pSource->m_szComputerName, pTarget->m_szComputerName,
			pszTargetDeviceNumber);

		this->Log(TNLST_CRITICAL,
				"WARNING: %s can't reach %s via modem (number = \"%s\")!",
				3, pSource->m_szComputerName, pTarget->m_szComputerName,
				pszTargetDeviceNumber);

		goto DONE;
	} // end if (source couldn't reach target)


DONE:

	return (hr);
} // CTNMaster::CanReachViaModem
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CanReachViaSerial()"
//==================================================================================
// CTNMaster::CanReachViaSerial
//----------------------------------------------------------------------------------
//
// Description: Checks whether the first given machine can send data to and get a
//				reply from the second machine via a serial connection.  If so
//				pfReachable is set to TRUE, otherwise it is set to FALSE.
//				This should only be called from within a module's CanRun callback
//				because the slave list lock is assumed to be held with only one
//				level of recursion.
//
// Arguments:
//	PTNMACHINEINFO pSender		Pointer to machine doing the initial sending.
//	PTNMACHINEINFO pReceiver	Pointer to machine doing the initial receiving.
//	BOOL* pfReachable			Pointer to boolean to fill with TRUE if the
//								specified communication is possible, FALSE if not.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::CanReachViaSerial(PTNMACHINEINFO pSender,
									PTNMACHINEINFO pReceiver,
									BOOL* pfReachable)
{
	HRESULT					hr = S_OK;
	PTNSLAVEINFO			pSource = (PTNSLAVEINFO) pSender;
	PTNSLAVEINFO			pTarget = (PTNSLAVEINFO) pReceiver;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;
	PTNCOMPORT				pCOMPortSource = NULL;
	PTNCOMPORT				pCOMPortTarget = NULL;
	DWORD					dwCOMPortSource;
	DWORD					dwCOMPortTarget;


	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got bad pointer)

	if ((pSource == NULL) || (pTarget == NULL))
	{
		DPL(0, "Either the source (%x) or the target (%x) machine is NULL, both must exist!",
			2, pSource, pTarget);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (source or target are NULL)

	if (pSource == pTarget)
	{
		DPL(0, "The source and the target machines specified are the same (%x)!",
			1, pSource);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (source and target are same)

	if (pfReachable == NULL)
	{
		DPL(0, "Must specify a pointer to a boolean to store result in!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (no boolean specified)

	// Start by assuming it can't be reached.
	(*pfReachable) = FALSE;


	// If the slaves are actually 2 instances on the same machine, it's always
	// going to fail.
	if (this->AreOnSameMachine(pSource, pTarget))
	{
		DPL(1, "Source and target slaves (IDs %u and %u) are on same machine (%s).",
			3, pSource->m_id.dwTime, pTarget->m_id.dwTime,
			pSource->m_szComputerName);
		goto DONE;
	} // end if (on same machine)


	// Look if we've already run this check before.

	pReachCheckTarget = pSource->m_reachchecktargets.GetTarget(&(pTarget->m_id));
	if (pReachCheckTarget != NULL)
	{
		for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
		{
			pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
			if (pReachCheck == NULL)
			{
				DPL(0, "Couldn't get reach check %i!", i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)


			// If we're found a serial check already existing, we've got the
			// result we need.
			if (pReachCheck->m_dwMethod == TNRCM_SERIAL)
			{
				if (pReachCheck->m_fResult)
				{
					DPL(3, "%s already successfully sent to %s earlier.",
						2, pSource->m_szComputerName,
						pTarget->m_szComputerName);
				} // end if (check succeeded)
				else
				{
					DPL(3, "%s couldn't send to %s earlier.",
						2, pSource->m_szComputerName,
						pTarget->m_szComputerName);
				} // end else (check failed)

				(*pfReachable) = pReachCheck->m_fResult;

				goto DONE;
			} // end if (found serial check)
		} // end for (each check)
	} // end if (source had tried to reach target before in some way)


	// If we're here, it means that either the source has never tried to reach the
	// target via serial.  We have to perform the check now.


#pragma BUGBUG(vanceo, "More features?")
	pCOMPortSource = (PTNCOMPORT) pSource->m_COMports.GetStringObject(pTarget->m_szComputerName, 0, FALSE);
	if (pCOMPortSource == NULL)
	{
		DPL(0, "Source %s doesn't have any COM ports connected to %s.",
			2, pSource->m_szComputerName, pTarget->m_szComputerName);

		// Assume that's not because of some wacky error.
		hr = S_OK;

		goto DONE;
	} // end if (couldn't get object)


	// Just double check that the target has a mirror image connection.

	pCOMPortTarget = (PTNCOMPORT) pTarget->m_COMports.GetStringObject(pSource->m_szComputerName, 0, FALSE);
	if (pCOMPortTarget == NULL)
	{
		DPL(0, "Target %s doesn't have a mirror image COM port connected to %s!",
			2, pTarget->m_szComputerName, pSource->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get object)


	dwCOMPortSource = pCOMPortSource->GetCOMPort();
	dwCOMPortTarget = pCOMPortTarget->GetCOMPort();

	DPL(5, "%s should use COM port %u when trying to reach %s (whose COM port should be %u).",
		4, pSource->m_szComputerName, dwCOMPortSource,
		pTarget->m_szComputerName, dwCOMPortTarget);


	hr = this->PerformReachCheck(TNRCM_SERIAL,
								pSource,
								NULL,
								0,
								&dwCOMPortSource,
								sizeof (DWORD),
								pTarget,
								NULL,
								0,
								pfReachable);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't have %s perform serial reachability test to %s (COM port = \"%s\")!",
			3, pSource->m_szComputerName, pTarget->m_szComputerName,
			dwCOMPortSource);
		goto DONE;
	} // end if (couldn't perform reach test)

	if ((*pfReachable) == FALSE)
	{
		DPL(0, "WARNING: %s can't reach %s via COM port %u!",
			3, pSource->m_szComputerName, pTarget->m_szComputerName,
			dwCOMPortSource);

		this->Log(TNLST_CRITICAL,
				"WARNING: %s can't reach %s via COM port %u!",
				3, pSource->m_szComputerName, pTarget->m_szComputerName,
				dwCOMPortSource);

		goto DONE;
	} // end if (source couldn't reach target)


DONE:

	return (hr);
} // CTNMaster::CanReachViaSerial
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetPlannedInputData()"
//==================================================================================
// CTNMaster::GetPlannedInputData
//----------------------------------------------------------------------------------
//
// Description: Called by CanRun functions to retrieve the input data that will be
//				used by the given tester if the permutation is actually run.  The
//				case's GetInputData function is called to do the conversion, so
//				naturally the module must implement that function as well.
//				If pvInputData is NULL, the size required is stored in pdwInputData
//				and ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	int iTesterNum				Tester number whose input data should be retrieved.
//	PTNCANRUNDATA pTNcrd		Pointer to TNCANRUNDATA structure passed in to
//								CanRun function calling this procedure.
//	PVOID pvInputData			Pointer to buffer to retrieve input data, or NULL to
//								retrieve size.
//	DWORD* pdwInputDataSize		Pointer to size of input data buffer, or place to
//								store size required.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::GetPlannedInputData(int iTesterNum, PTNCANRUNDATA pTNcrd,
										PVOID pvInputData, DWORD* pdwInputDataSize)
{
	HRESULT			hr = S_OK;
	TNGETINPUTDATA	tngid;


	if (this == NULL)
	{
		DPL(0, "Master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got bad pointer)

	if (pTNcrd == NULL)
	{
		DPL(0, "Must pass valid TNCANRUNDATA!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (pointer is NULL)

	if (pdwInputDataSize == NULL)
	{
		DPL(0, "Must pass valid input data size pointer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (pointer is NULL)

	if (pTNcrd->dwSize != sizeof (TNCANRUNDATA))
	{
		DPL(0, "TNCANRUNDATA structure is invalid (%u != %u)!",
			2, pTNcrd->dwSize, sizeof (TNCANRUNDATA));
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (structure is invalid)

	if ((iTesterNum < 0) || (iTesterNum >= pTNcrd->iNumMachines))
	{
		DPL(0, "Tester number %i is invalid (<0 or >%i)!",
			2, iTesterNum, pTNcrd->iNumMachines);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (tester number is invalid)

	if (pTNcrd->pTest->m_pfnGetInputData == NULL)
	{
		DPL(0, "Test case \"%s\" does not have a GetInputData function!",
			1, pTNcrd->pTest->m_pszID);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (no GetInputData function implemented)


	ZeroMemory(&tngid, sizeof (TNGETINPUTDATA));
	tngid.dwSize = sizeof (TNGETINPUTDATA);
	tngid.pMaster = this;
	tngid.pMachine = pTNcrd->apTesters[iTesterNum];
	tngid.iTesterNum = iTesterNum;
	tngid.pTest = pTNcrd->pTest;
	tngid.pStringData = pTNcrd->pStringData;
	tngid.pvData = pvInputData;
	tngid.dwDataSize = (*pdwInputDataSize);

	hr = pTNcrd->pTest->m_pfnGetInputData(&tngid);
	if ((hr != S_OK) && (hr != ERROR_BUFFER_TOO_SMALL))
	{
		DPL(0, "Module's GetInputData callback for case \"%s\" failed!  %e",
			1, pTNcrd->pTest->m_pszID);
		//goto DONE;
	} // end if (module's callback failed)


DONE:

	return (hr);
} // CTNMaster::GetPlannedInputData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::ProcessJobQueue()"
//==================================================================================
// CTNMaster::ProcessJobQueue
//----------------------------------------------------------------------------------
//
// Description: Performs all jobs in the queue that are ready to be processed.
//				This function assumes the slave and job locks are taken.
//
// Arguments:
//	DWORD* pdwTimeToNextJob		How long to wait until the next job should be
//								performed.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::ProcessJobQueue(DWORD* pdwTimeToNextJob)
{
	HRESULT			hr = S_OK;
	BOOL			fHaveJobQueueLock = FALSE;
	PTNJOB			pJob = NULL;
	PTNSLAVEINFO	pSlave;
	DWORD			dwCurrentTime = 0;


	DPL(9, "==>", 0);


	// Take the locks.
	// We take it here because we don't want folks adding to the queue while we
	// trying to determine how long to sleep.
	// We take the slave lock here because:
	// 1) all of our job operations require it
	// 2) some other threads already have the slave lock and try to add a job
	//    to the queue which requires the job lock.  If we take the job lock
	//    first here, we will deadlock with that thread.
	this->m_slaves.EnterCritSection();
	this->m_jobs.EnterCritSection();
	fHaveJobQueueLock = TRUE;



	// Start by assuming we'll wait forever
	(*pdwTimeToNextJob) = INFINITE;


	// Keep looping until all the jobs are done or we find a job that's
	// not ready to be run yet.
	while (this->m_jobs.Count() > 0)
	{
		// Reset the event to reduce the times where it fires but we already
		// handled it in here.
		if (! ResetEvent(this->m_jobs.m_hNewJobEvent))
		{
			hr = GetLastError();

			DPL(0, "Couldn't reset new job event %x!",
				1, this->m_jobs.m_hNewJobEvent);

			if (hr != S_OK)
				hr = E_FAIL;

			goto DONE;
		} // end if (couldn't reset event)

		dwCurrentTime = GetTickCount();


		pJob = (PTNJOB) this->m_jobs.GetItem(0);
		if (pJob == NULL)
		{
			DPL(0, "Couldn't get first job!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get job)


		// If the job shouldn't be run right now, and it's not past
		// the time, we're done.
		if ((pJob->m_dwTime != 0) &&
			(pJob->m_dwTime > dwCurrentTime))
		{
			(*pdwTimeToNextJob) = pJob->m_dwTime - dwCurrentTime;

			DPL(9, "Next job (%x, op = %u) in %u ms.",
				3, pJob, pJob->m_dwOperation, (*pdwTimeToNextJob));

			pJob = NULL; // forget about it, so we don't free it below
			goto DONE;
		} // end if (this job shouldn't be run yet)


		hr = this->m_jobs.RemoveFirstReference(pJob);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove job %x from list!", 1, pJob);
			goto DONE;
		} // end if (couldn't take job off list)


		// Drop the job lock so other jobs can be added to the queue while
		// we're working on this one.
		this->m_jobs.LeaveCritSection();
		fHaveJobQueueLock = FALSE;


		DPL(9, "++Processing job %x (op %u, time after trigger time %u).",
			3, pJob, pJob->m_dwOperation,
			((pJob->m_dwTime == 0) ? 0 : dwCurrentTime - pJob->m_dwTime));



		// Actually perform the operation.
		switch (pJob->m_dwOperation)
		{
			case TNMJ_HANDLEREPORT:
				pSlave = this->m_slaves.GetSlaveByID(&(pJob->m_idSlave));
				if (pSlave == NULL)
				{
					DPL(0, "Couldn't find slave (%u) in list!  Ignoring HandleReport.",
						1, pJob->m_idSlave.dwTime);

					// BUGBUG Fail?
					goto DONE;
				} // end if (couldn't get slaveinfo object)

				hr = this->DoHandleReport(pSlave, ((PCTRLMSG_REPORT) pJob->m_pvContext));
				if (hr != S_OK)
				{
					DPL(0, "Couldn't handle report for %s!",
						1, pSlave->m_szComputerName);
					goto DONE;
				} // end if (couldn't handle report)
			  break;

			case TNMJ_GETNEXTCMD:
				pSlave = this->m_slaves.GetSlaveByID(&(pJob->m_idSlave));
				if (pSlave == NULL)
				{
					DPL(0, "Couldn't find slave (%u) in list!  Ignoring GetNextCmd request.",
						1, pJob->m_idSlave.dwTime);

					// BUGBUG Fail?
					goto DONE;
				} // end if (couldn't get slaveinfo object)

				hr = this->GetNextCmdForMachine(pSlave);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't get next command for %s!",
						1, pSlave->m_szComputerName);
					goto DONE;
				} // end if (couldn't get next command)
			  break;

			case TNMJ_PINGSLAVES:
				hr = this->DoPingCheck();
				if (hr != S_OK)
				{
					DPL(0, "Couldn't do ping check!", 0);
					goto DONE;
				} // end if (couldn't do ping check)

				// If there are still slaves in the session, re-add this
				// job so we can check again.
				if (this->m_slaves.Count() > 0)
				{
					hr = this->m_jobs.AddJob(TNMJ_PINGSLAVES, SLAVE_CHECK_INTERVAL,
											NULL, NULL);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't readd ping check job!", 0);
						goto DONE;
					} // end if (couldn't re-add job)
				} // end if (there are slaves)
			  break;

			case TNMJ_READYTOTEST:
				hr = this->DoSlaveReadyToTest(&(pJob->m_idSlave));
				if (hr != S_OK)
				{
					DPL(0, "Couldn't mark slave (%u) as ready to test!",
						1, pJob->m_idSlave.dwTime);
					goto DONE;
				} // end if (couldn't mark slave as ready to test)
			  break;

			case TNMJ_CLOSESESSION:
				hr = this->CloseSession();
				if (hr != S_OK)
				{
					DPL(0, "Couldn't close session!", 0);
					goto DONE;
				} // end if (couldn't close session)
			  break;

			default:
				DPL(0, "Unrecognized job type (%u)!", 1, pJob->m_dwOperation);
				hr = E_FAIL;
				goto DONE;
			  break;
		} // end switch (on job type)


		DPL(9, "--Done processing job %x, remaining = %i.",
			2, pJob, this->m_jobs.Count());


		if (pJob->m_dwRefCount == 0)
		{
			DPL(7, "Deleting job %x.", 1, pJob);
			delete (pJob);
		} // end if (last job reference)
		else
		{
			DPL(7, "Not deleting job %x, its refcount is %u.",
				2, pJob, pJob->m_dwRefCount);
		} // end else (shouldn't delete job)
		pJob = NULL;


		// Take the job lock again so we can check for more jobs.
		this->m_jobs.EnterCritSection();
		fHaveJobQueueLock = TRUE;
	} // end while (there are still jobs)

	DPL(9, "No next job.", 0);


DONE:

	if (fHaveJobQueueLock)
	{
		this->m_jobs.LeaveCritSection();
		fHaveJobQueueLock = FALSE;
	} // end if (have job queue lock)

	this->m_slaves.LeaveCritSection();

	if (pJob != NULL)
	{
		if (pJob->m_dwRefCount == 0)
		{
			DPL(7, "Deleting job %x.", 1, pJob);
			delete (pJob);
		} // end if (last job reference)
		else
		{
			DPL(7, "Not deleting job %x, its refcount is %u.",
				2, pJob, pJob->m_dwRefCount);
		} // end else (shouldn't delete job)
		pJob = NULL;
	} // end if (still have job pointer)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNMaster::ProcessJobQueue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleMessage()"
//==================================================================================
// CTNMaster::HandleMessage
//----------------------------------------------------------------------------------
//
// Description: Handles an incoming control session message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm
//								from address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PVOID pvData				Pointer to data received by ctrl comm.
//	DWORD dwDataSize			Size of data.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleMessage(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								  PVOID pvData, DWORD dwDataSize)
{
	PCTRLMSG_GENERIC	pGenericMsg = NULL;


	if (this->m_dwStartupTicks == 0)
	{
		DPL(0, "Received message before started up!  Ignoring.", 0);
		return (S_OK);
	} // end if (we haven't fully started up yet)

	if ((*ppvFromAddress) == NULL)
	{
		DPL(0, "WARNING!  No from address!", 0);
	} // end if (no from address info)

	if (dwDataSize < sizeof (CTRLMSG_GENERIC))
	{
		DPL(0, "Data too small to be valid message!  Ignoring.", 0);
		return (S_OK);
	} // end if (smaller than the smallest valid message)

	pGenericMsg = (PCTRLMSG_GENERIC) pvData;
	
	if (pGenericMsg->dwSize != dwDataSize)
	{
		DPL(0, "Incomplete or invalid message (expected size %i bytes differs from actual size %i bytes)!  Ignoring.",
			2, pGenericMsg->dwSize, dwDataSize);
		return (S_OK);
	} // end if (didn't get complete/valid message)

	switch(pGenericMsg->dwType)
	{
		case CTRLMSGID_ENUM:
			if (dwDataSize < sizeof (CTRLMSG_ENUM))
			{
				DPL(0, "Data too small to be valid Enum message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid enum message)

			return (this->HandleEnumMsg(ppvFromAddress, dwFromAddressSize,
										(PCTRLMSG_ENUM) pGenericMsg));
		  break;

		case CTRLMSGID_HANDSHAKE:
			if (dwDataSize < sizeof (CTRLMSG_HANDSHAKE))
			{
				DPL(0, "Data too small to be valid Handshake message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid handshake message)

			return (this->HandleHandshakeMsg(ppvFromAddress, dwFromAddressSize,
										(PCTRLMSG_HANDSHAKE) pGenericMsg));
		  break;

		case CTRLMSGID_JOIN:
			if (dwDataSize < sizeof (CTRLMSG_JOIN))
			{
				DPL(0, "Data too small to be valid Join message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid join message)

			return (this->HandleJoinMsg(ppvFromAddress, dwFromAddressSize,
										(PCTRLMSG_JOIN) pGenericMsg));
		  break;

		case CTRLMSGID_READYTOTEST:
			if (dwDataSize < sizeof (CTRLMSG_READYTOTEST))
			{
				DPL(0, "Data too small to be valid ReadyToTest message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid readytotest message)

			return (this->HandleReadyToTestMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_READYTOTEST) pGenericMsg));
		  break;

		case CTRLMSGID_ANNOUNCESUBTEST:
			if (dwDataSize < sizeof (CTRLMSG_ANNOUNCESUBTEST))
			{
				DPL(0, "Data too small to be valid AnnounceSubTest message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid announcesubtest message)

			return (this->HandleAnnounceSubTestMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_ANNOUNCESUBTEST) pGenericMsg));
		  break;

		case CTRLMSGID_REPORT:
			if (dwDataSize < (sizeof (CTRLMSG_REPORT)))
			{
				DPL(0, "Data too small to be valid Report message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid report message)

			return (this->HandleReportMsg(ppvFromAddress, dwFromAddressSize,
										(PCTRLMSG_REPORT) pGenericMsg));
		  break;

		case CTRLMSGID_WARNING:
			if (dwDataSize < (sizeof (CTRLMSG_WARNING)))
			{
				DPL(0, "Data too small to be valid Warning message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid report message)

			return (this->HandleWarningMsg(ppvFromAddress, dwFromAddressSize,
										(PCTRLMSG_WARNING) pGenericMsg));
		  break;

		case CTRLMSGID_REQUESTSYNC:
			if (dwDataSize < (sizeof (CTRLMSG_REQUESTSYNC)))
			{
				DPL(0, "Data too small to be valid RequestSync message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid requestsync message)

			return (this->HandleRequestSyncMsg(ppvFromAddress, dwFromAddressSize,
										(PCTRLMSG_REQUESTSYNC) pGenericMsg));
		  break;

		case CTRLMSGID_USERQUERY:
			if (dwDataSize < (sizeof (CTRLMSG_USERQUERY)))
			{
				DPL(0, "Data too small to be valid UserQuery message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid userquery message)

			return (this->HandleUserQueryMsg(ppvFromAddress, dwFromAddressSize,
										(PCTRLMSG_USERQUERY) pGenericMsg));
		  break;

		case CTRLMSGID_IDLE:
			if (dwDataSize < (sizeof (CTRLMSG_IDLE)))
			{
				DPL(0, "Data too small to be valid Idle message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid idle message)

			return (this->HandleIdleMsg(ppvFromAddress, dwFromAddressSize,
										(PCTRLMSG_IDLE) pGenericMsg));
		  break;

		case CTRLMSGID_REGISTERMASTERREPLY:
			if (dwDataSize < (sizeof (CTRLMSG_REGISTERMASTERREPLY)))
			{
				DPL(0, "Data too small to be valid RegisterMasterReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid registermasterreply message)

			return (this->HandleRegisterMasterReplyMsg(ppvFromAddress, dwFromAddressSize,
														(PCTRLMSG_REGISTERMASTERREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_MASTERPINGSLAVEREPLY:
			if (dwDataSize < (sizeof (CTRLMSG_MASTERPINGSLAVEREPLY)))
			{
				DPL(0, "Data too small to be valid MasterPingSlaveReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid masterpingslavereply message)

			return (this->HandleMasterPingReplyMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_MASTERPINGSLAVEREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_REQUESTPOKETEST:
			if (dwDataSize < (sizeof (CTRLMSG_REQUESTPOKETEST)))
			{
				DPL(0, "Data too small to be valid RequestPokeTest message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid requestpoketest message)

			return (this->HandleRequestPokeTestMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_REQUESTPOKETEST) pGenericMsg));
		  break;

		case CTRLMSGID_ACCEPTREACHCHECKREPLY:
			if (dwDataSize < (sizeof (CTRLMSG_ACCEPTREACHCHECKREPLY)))
			{
				DPL(0, "Data too small to be valid AcceptReachCheckReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid acceptreachcheckreply message)

			return (this->HandleAcceptReachCheckReplyMsg(ppvFromAddress, dwFromAddressSize,
														(PCTRLMSG_ACCEPTREACHCHECKREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_CONNECTREACHCHECKREPLY:
			if (dwDataSize < (sizeof (CTRLMSG_CONNECTREACHCHECKREPLY)))
			{
				DPL(0, "Data too small to be valid ConnectReachCheckReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid connectreachcheckreply message)

			return (this->HandleConnectReachCheckReplyMsg(ppvFromAddress, dwFromAddressSize,
														(PCTRLMSG_CONNECTREACHCHECKREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_FREEOUTPUTVARS:
			if (dwDataSize < (sizeof (CTRLMSG_FREEOUTPUTVARS)))
			{
				DPL(0, "Data too small to be valid FreeOutputVars message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid freeoutputvars message)

			return (this->HandleFreeOutputVarsMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_FREEOUTPUTVARS) pGenericMsg));
		  break;

		case CTRLMSGID_GETMACHINEINFO:
			if (dwDataSize < (sizeof (CTRLMSG_GETMACHINEINFO)))
			{
				DPL(0, "Data too small to be valid GetMachineInfo message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid getmachineinfo message)

			return (this->HandleGetMachineInfoMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_GETMACHINEINFO) pGenericMsg));
		  break;

		default:
			DPL(0, "Message of invalid/unknown type (%u)!  Ignoring.", 1, pGenericMsg->dwType);
		  break;
	} // end switch (on message type)

	return (S_OK);
} // CTNMaster::HandleMessage
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleEnumMsg()"
//==================================================================================
// CTNMaster::HandleEnumMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session enum message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm
//								from address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PCTRLMSG_ENUM pEnumMsg		The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleEnumMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_ENUM pEnumMsg)
{
	HRESULT					hr = S_OK;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_ENUMREPLY		pEnumReplyMsg = NULL;


	//DPL(0, "Got Enum message.", 0);


	if (! this->m_fJoinersAllowed)
	{
		DPL(0, "Joiners are not currently allowed, ignoring.", 0);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Ignoring enumeration, joiners are not currently allowed.", 0);

		goto DONE;
	} // end if (joiners aren't allowed)


	// Compare shell versions
	if (pEnumMsg->dwVersion != CURRENT_TNCONTROL_API_VERSION)
	{
		DPL(0, "Enum request control version (%u) is different from ours (%u), ignoring.",
			2, pEnumMsg->dwVersion, CURRENT_TNCONTROL_API_VERSION);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Ignoring enumeration, control version is different.", 0);

		goto DONE;
	} // end if (version isn't the same)


	// Compare app IDs
	if ((strcmp(pEnumMsg->moduleID.szBriefName, this->m_moduleID.szBriefName) != 0) ||
		(pEnumMsg->moduleID.dwMajorVersion != this->m_moduleID.dwMajorVersion) ||
		(pEnumMsg->moduleID.dwMinorVersion1 != this->m_moduleID.dwMinorVersion1))
	{
		DPL(0, "Enum request module ID (_%s v%u.%u_.%u.%u) doesn't match ours (_%s v%u.%u_.%u.%u), ignoring.",
			10,
			pEnumMsg->moduleID.szBriefName,
			pEnumMsg->moduleID.dwMajorVersion,
			pEnumMsg->moduleID.dwMinorVersion1,
			pEnumMsg->moduleID.dwMinorVersion2,
			pEnumMsg->moduleID.dwBuildVersion,
			this->m_moduleID.szBriefName,
			this->m_moduleID.dwMajorVersion,
			this->m_moduleID.dwMinorVersion1,
			this->m_moduleID.dwMinorVersion2,
			this->m_moduleID.dwBuildVersion);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Ignoring enumeration, module ID doesn't match.", 0);

		goto DONE;
	} // end if (failed to match our app id)


	// Compare user specified session IDs

	if (this->m_pszSessionFilter == NULL)
	{
		if (strcmp((char*) (pEnumMsg + 1), "") != 0)
		{
			DPL(0, "Request looking for session ID (\"%s\"), but we don't have one specified.  Ignoring.",
				1, (pEnumMsg + 1));

			this->Log(TNLST_CONTROLLAYER_INFO,
					"Ignoring enumeration, specified session ID/key but we don't have one.", 0);

			goto DONE;
		} // end if (the enum request is for a specific session)
	} // end if (we are not a specific session)
	else
	{
		if (strcmp((char*) (pEnumMsg + 1), this->m_pszSessionFilter) != 0)
		{
			DPL(0, "Request looking for different session ID (\"%s\" != \"%s\"), ignoring.",
				2, (pEnumMsg + 1), this->m_pszSessionFilter);

			this->Log(TNLST_CONTROLLAYER_INFO,
					"Ignoring enumeration, specified different session ID/key.", 0);

			goto DONE;
		} // end if (the enum request is for a different/no session)
	} // end else (we are a specific session)



	if (pEnumMsg->dwMode != this->m_dwMode)
	{
		char	szTemp1[32];
		char	szTemp2[32];


		switch (pEnumMsg->dwMode)
		{
			case TNMODE_API:
				strcpy(szTemp1, "an API");
			  break;

			case TNMODE_STRESS:
				strcpy(szTemp1, "a stress");
			  break;

			case TNMODE_POKE:
				strcpy(szTemp1, "a poke");
			  break;

			case TNMODE_PICKY:
				strcpy(szTemp1, "a picky");
			  break;

			default:
				wsprintf(szTemp1, "a wierd (type %i)", pEnumMsg->dwMode);
			  break;
		} // end switch (on enum mode type)

		switch (this->m_dwMode)
		{
			case TNMODE_API:
				strcpy(szTemp2, "API");
			  break;

			case TNMODE_STRESS:
				strcpy(szTemp2, "stress");
			  break;

			case TNMODE_POKE:
				strcpy(szTemp2, "poke");
			  break;

			case TNMODE_PICKY:
				strcpy(szTemp2, "picky");
			  break;
		} // end switch (on our mode type)

		DPL(0, "Enum requestor is looking for %s session but we are in %s mode, ignoring.",
			2, szTemp1, szTemp2);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Ignoring enumeration, wrong mode.", 0);

		goto DONE;
	} // end if (modes don't match)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = FALSE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_ENUMREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pEnumReplyMsg = (PCTRLMSG_ENUMREPLY) pSendData->m_pvData;
	pEnumReplyMsg->dwSize = pSendData->m_dwDataSize;
	pEnumReplyMsg->dwType = CTRLMSGID_ENUMREPLY;

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNMaster::HandleEnumMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleHandshakeMsg()"
//==================================================================================
// CTNMaster::HandleHandshakeMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session handshake message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_HANDSHAKE pHandshakeMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleHandshakeMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_HANDSHAKE pHandshakeMsg)
{
	HRESULT						hr = S_OK;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_HANDSHAKEREPLY		pHandshakeReplyMsg = NULL;
	DWORD						dwStartupDataSize = 0;


	//DPL(0, "Got Handshake message.", 0);


	//BUGBUG if we refuse the connection, we need to shutdown the link and/or notify
	//		 the other side

	if (! this->m_fJoinersAllowed)
	{
		DPL(0, "Joiners are not currently allowed, ignoring.", 0);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Ignoring join attempt, not currently allowed.", 0);

		goto DONE;
	} // end if (joiners aren't allowed)

	// Compare shell versions
	if (pHandshakeMsg->dwVersion != CURRENT_TNCONTROL_API_VERSION)
	{
		DPL(0, "Handshake request control version (%u) is different from ours (%u), ignoring.",
			2, pHandshakeMsg->dwVersion, CURRENT_TNCONTROL_API_VERSION);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Ignoring join attempt, control version is different.", 0);

		goto DONE;
	} // end if (version isn't the same)


	// Compare app IDs
	if ((strcmp(pHandshakeMsg->moduleID.szBriefName, this->m_moduleID.szBriefName) != 0) ||
		(pHandshakeMsg->moduleID.dwMajorVersion != this->m_moduleID.dwMajorVersion) ||
		(pHandshakeMsg->moduleID.dwMinorVersion1 != this->m_moduleID.dwMinorVersion1))
	{
		DPL(0, "Handshake request module ID (_%s v%u.%u_.%u.%u) doesn't match ours (_%s v%u.%u_.%u.%u), ignoring.",
			10,
			pHandshakeMsg->moduleID.szBriefName,
			pHandshakeMsg->moduleID.dwMajorVersion,
			pHandshakeMsg->moduleID.dwMinorVersion1,
			pHandshakeMsg->moduleID.dwMinorVersion2,
			pHandshakeMsg->moduleID.dwBuildVersion,
			this->m_moduleID.szBriefName,
			this->m_moduleID.dwMajorVersion,
			this->m_moduleID.dwMinorVersion1,
			this->m_moduleID.dwMinorVersion2,
			this->m_moduleID.dwBuildVersion);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Ignoring join attempt, module ID doesn't match.", 0);

		goto DONE;
	} // end if (failed to match our app id)


	// Compare user specified session IDs

	if (this->m_pszSessionFilter == NULL)
	{
		if (strcmp((char*) (pHandshakeMsg + 1), "") != 0)
		{
			DPL(0, "Request looking for specified session ID (\"%s\"), but we don't have one specified.  Ignoring.",
				1, (pHandshakeMsg + 1));

			this->Log(TNLST_CONTROLLAYER_INFO,
					"Ignoring join attempt, specified session ID/key but we don't have one.", 0);

			goto DONE;
		} // end if (the enum request is for a specific session)
	} // end if (we are not a specific session)
	else
	{
		if (strcmp((char*) (pHandshakeMsg + 1), this->m_pszSessionFilter) != 0)
		{
			DPL(0, "Request looking for different session ID (\"%s\" != \"%s\"), ignoring.",
				2, (pHandshakeMsg + 1), this->m_pszSessionFilter);

			this->Log(TNLST_CONTROLLAYER_INFO,
					"Ignoring join attempt, specified different session ID/key.", 0);

			goto DONE;
		} // end if (the enum request is for a different/no session)
	} // end else (we are a specific session)



	if (pHandshakeMsg->dwMode != this->m_dwMode)
	{
		char	szTemp1[32];
		char	szTemp2[32];


		switch (pHandshakeMsg->dwMode)
		{
			case TNMODE_API:
				strcpy(szTemp1, "an API");
			  break;

			case TNMODE_STRESS:
				strcpy(szTemp1, "a stress");
			  break;

			case TNMODE_POKE:
				strcpy(szTemp1, "a poke");
			  break;

			case TNMODE_PICKY:
				strcpy(szTemp1, "a picky");
			  break;

			default:
				wsprintf(szTemp1, "a wierd (type %i)", pHandshakeMsg->dwMode);
			  break;
		} // end switch (on handshake mode type)

		switch (this->m_dwMode)
		{
			case TNMODE_API:
				strcpy(szTemp2, "API");
			  break;

			case TNMODE_STRESS:
				strcpy(szTemp2, "stress");
			  break;

			case TNMODE_POKE:
				strcpy(szTemp2, "poke");
			  break;

			case TNMODE_PICKY:
				strcpy(szTemp2, "picky");
			  break;
		} // end switch (on our mode type)

		DPL(0, "Handshaker is looking for %s session but we are in %s mode, ignoring.",
			2, szTemp1, szTemp2);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Ignoring join attempt, wrong mode.", 0);

		goto DONE;
	} // end if (modes don't match)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed


	// If the module has startup data, get its size
	if (this->m_pfnGetStartupData != NULL)
		this->m_pfnGetStartupData(NULL, &dwStartupDataSize); // ignoring error


	pSendData->m_dwDataSize = sizeof (CTRLMSG_HANDSHAKEREPLY)
							+ dwStartupDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		(*ppvFromAddress) = NULL;
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pHandshakeReplyMsg = (PCTRLMSG_HANDSHAKEREPLY) pSendData->m_pvData;
	pHandshakeReplyMsg->dwSize = pSendData->m_dwDataSize;
	pHandshakeReplyMsg->dwType = CTRLMSGID_HANDSHAKEREPLY;

	pHandshakeReplyMsg->dwSessionID = this->m_dwSessionID;
	pHandshakeReplyMsg->dwStartupDataSize = dwStartupDataSize;

	if ((this->m_pfnGetStartupData != NULL) && (dwStartupDataSize > 0))
	{
		hr = this->m_pfnGetStartupData((pHandshakeReplyMsg + 1), &dwStartupDataSize);
		if (hr != S_OK)
		{
			DPL(0, "User's GetStartupData function failed!", 0);
			goto DONE;
		} // end if (getting startup data failed)
	} // end if (the user has startup data)


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
		delete (pSendData);

	return (hr);
} // CTNMaster::HandleHandshakeMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleJoinMsg()"
//==================================================================================
// CTNMaster::HandleJoinMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session join message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm
//								from address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PCTRLMSG_JOIN pJoinMsg		The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleJoinMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_JOIN pJoinMsg)
{
	HRESULT					hr = S_OK;
	PTNSLAVEINFO			pNewMachine = NULL;
	PTNSLAVEINFO			pOtherSlave = NULL;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_JOINREPLY		pJoinReplyMsg = NULL;
	DWORD					dwPingSlaveThreadId = 0;
	char					szVar[1024];
	int						i;
	BOOL					fHaveSlaveListLock = FALSE;
	BOOL					fCloseSessionNow = FALSE;
	BOOL					fCloseSessionLater = FALSE;


	//DPL(0, "Got Join message.", 0);

	// Compare test checksums
	if (memcmp(&(pJoinMsg->testChecksum), &(this->m_testChecksum), sizeof (CHECKSUM)) != 0)
	{
		DPL(0, "Slave's test checksum doesn't match ours ({%v} != {%v})!  Ignoring.",
			4, &(pJoinMsg->testChecksum), sizeof (CHECKSUM),
			&(this->m_testChecksum),  sizeof (CHECKSUM));
		goto DONE;
	} // end if (failed to match test checksum)

	pNewMachine = new (CTNSlaveInfo);
	if (pNewMachine == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pNewMachine->m_dwRefCount++; // we're using it


	hr = pNewMachine->UnpackFromBuffer((pJoinMsg + 1), pJoinMsg->dwInfoSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't unpack machine info from join message!", 0);
		goto DONE;
	} // end if (couldn't unpack machine info item from buffer)

	// Assign it an ID
#ifndef _XBOX // timeGetTime not supported
	pNewMachine->m_id.dwTime = timeGetTime();
#else // ! XBOX
	pNewMachine->m_id.dwTime = GetTickCount();
#endif // XBOX

	//HACKHACK Make sure no 2 machines can get the same ID (by sleeping for well over
	//		   the timeGetTime resolution).  We need a real uniqueness ID though.
	Sleep(100);

	// Save the multi-instance key he's telling us about.
	pNewMachine->m_dwMultiInstanceKey = pJoinMsg->dwMultiInstanceKey;


	//pNewMachine->commdata.hStatusEvent = this->m_hAllSlavesCommStatusEvent;
	pNewMachine->m_commdata.fDropped = FALSE;
	pNewMachine->m_commdata.pvAddress = (*ppvFromAddress);
	pNewMachine->m_commdata.dwAddressSize = dwFromAddressSize;

	hr = this->m_pCtrlComm->BindDataToAddress(&(pNewMachine->m_commdata));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't bind new machine's control comm data!", 0);
		goto DONE;
	} // end if (couldn't bind ctrl comm address)


	// If we're using a TCP/IP control method, then we can do some extra
	// processing with regards to NAT stuff.
	if ((this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_OPTIMAL) ||
		(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK1))
	{
		SOCKADDR_IN*	pSockAddr;


		// Since we know the control method we can crack the address the slave
		// spit back at us to find out what IP the slave is talking to us on. See
		// the commtcp file.

		pSockAddr = (SOCKADDR_IN*) (((LPBYTE) (pJoinMsg + 1)) + pJoinMsg->dwInfoSize);

		// If the slave is sending to us at a different IP address from the ones
		// WinSock told us we were using, then add it with the note that it's an
		// inbound NAT IP.  If multiple slaves tell us the same thing, the address
		// will only be added the first time.
		if (! (this->m_ipaddrs.DoesIPExist(&(pSockAddr->sin_addr))))
		{
			DPL(0, "Slave is talking to a different IP address from ones we know about (%o).",
				1, pSockAddr);

			hr = this->m_ipaddrs.AddIP(&(pSockAddr->sin_addr), TNIPADDR_NAT);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add new IP to our list!", 0);
				goto DONE;
			} // end if (couldn't add IP)
		} // end if (couldn't find the specified IP address in the list)


		// We can do the same for the slave, too: if we're getting data from a
		// different IP from the ones he knows about, make of a note of it.
		
		pSockAddr = (SOCKADDR_IN*) (*ppvFromAddress);

		if (! (pNewMachine->m_ipaddrs.DoesIPExist(&(pSockAddr->sin_addr))))
		{
			DPL(0, "Slave is connected via a different IP address from ones he knows about (%o).",
				1, pSockAddr);

			hr = this->m_ipaddrs.AddIP(&(pSockAddr->sin_addr), TNIPADDR_NAT);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add NAT IP to slave's list!", 0);
				goto DONE;
			} // end if (couldn't add IP)
		} // end if (couldn't find the actual IP in the slave's known list)

	} // end if (using a TCP/IP control method)


	this->m_slaves.EnterCritSection();
	fHaveSlaveListLock = TRUE;


	// Increase our total slave count
	this->m_iTotalNumSlaves++;


	// Create a dynamic variable for this machine
	wsprintf(szVar, "SLAVENAME%i", this->m_iTotalNumSlaves);
	hr = this->m_builtinvars.AddVariable(szVar, "STRING",
										pNewMachine->m_szComputerName,
										(strlen(pNewMachine->m_szComputerName) + 1));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add variable \"%s\" for slave %s!",
			2, szVar, pNewMachine->m_szComputerName);
		goto DONE;
	} // end if (failed adding a variable)

	// Update the slave count item.  This will replace the previous NUMSLAVES
	// item, if we had one.
	wsprintf(szVar, "%i", this->m_slaves.Count());
	hr = this->m_builtinvars.AddVariable("NUMSLAVES", "STRING",
										szVar, (strlen(szVar) + 1));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't (re)add \"NUMSLAVES\" variable!", 0);
		goto DONE;
	} // end if (failed adding a variable)


	// If that slave wants a timelimit, or if our user wants one for all slaves,
	// then set that limit as appropriate.
	if (pJoinMsg->dwTimelimit != 0)
		pNewMachine->m_dwEndtime = GetTickCount() + (pJoinMsg->dwTimelimit * 60000);
	else if (this->m_dwTimelimit != 0)
		pNewMachine->m_dwEndtime = GetTickCount() + (this->m_dwTimelimit * 60000);

	// If this is the first slave and there's a time limit for additional joiners,
	// start that timer.  The PeriodicCheck thread will do the closing.
	if (this->m_dwAllowJoinersTime != 0)
	{
		if (this->m_iSlaveNumLimit > 1)
		{
			DPL(0, "Will close session in %u seconds, unless %i slaves join first.",
				2, this->m_dwAllowJoinersTime, this->m_iSlaveNumLimit);

			this->Log(TNLST_CONTROLLAYER_INFO,
					"Will close session in %u seconds, unless %i slaves join first.",
					2, this->m_dwAllowJoinersTime, this->m_iSlaveNumLimit);
		} // end if (slave limit)
		else if (this->m_iSlaveNumLimit == 0)
		{
			DPL(0, "Will close session in %u seconds.", 1, this->m_dwAllowJoinersTime);

			this->Log(TNLST_CONTROLLAYER_INFO, "Will close session in %u seconds.",
					1, this->m_dwAllowJoinersTime);
		} // end else (no slave limit)


		// Have the job thread close the session when the time is right.
		hr = this->m_jobs.AddJob(TNMJ_CLOSESESSION, this->m_dwAllowJoinersTime * 1000,
								NULL, NULL);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't readd ping check job!", 0);
			goto DONE;
		} // end if (couldn't re-add job)

		this->m_dwAllowJoinersTime = 0; // reset it so we don't try again
		fCloseSessionLater = TRUE;
	} // end if (there's a join time limit)


	// If there's a slave limit, check if we've reached it.
	if (this->m_iSlaveNumLimit != 0)
	{
		// -1 because it won't actually be in the list until below.
		if (this->m_slaves.Count() == (this->m_iSlaveNumLimit - 1))
		{
			DPL(0, "%s joining triggers the slave limit of %i, will close session.",
				2, pNewMachine->m_szComputerName, this->m_iSlaveNumLimit);

			// We won't actually close the session now.  First, we have to close
			// it in the Job thread so that we don't hold up this receive thread
			// we're in.  Besides being bad form, it can also deadlock because some
			// operations inside CloseSession require communication with slaves,
			// and if the receive thread isn't moving, we'll never get their
			// responses.
			// We don't even add the job to close session until later, so if the
			// Job thread fires really quickly, it won't spew "Closing session"
			// before we've spewed "Slave added" (makes the spew looks more
			// natural).
			fCloseSessionNow = TRUE;
		} // end if (that's the last slave we should accept)
	} // end if (there's a slave number limit)



	// Let's spew some feedback for this join event.

	DPL(1, "Slave %s joined session.", 1, pNewMachine->m_szComputerName);

	this->Log(TNLST_CONTROLLAYER_INFO, "Slave %s joined session.",
				1, pNewMachine->m_szComputerName);



	// Print a note if this slave is another instance on a machine that has already
	// joined the session.  No need to check the last slave because that's the one
	// we just added.
	for(i = 0; i < this->m_slaves.Count(); i++)
	{
		pOtherSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
		if (pOtherSlave == NULL)
		{
			DPL(0, "Couldn't get existing slave %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get slave)

		if (this->AreOnSameMachine(pOtherSlave, pNewMachine))
		{
			// Make note of the fact that there are multiple instances.
			pOtherSlave->m_iNumOtherInstancesInSession++;
			pNewMachine->m_iNumOtherInstancesInSession++;
		} // end if (they're on the same machine)
	} // end for (each slave)

	if (pNewMachine->m_iNumOtherInstancesInSession > 0)
	{
		DPL(0, "WARNING: There are already %i TestNet slave instances from the same machine as %s in this session!",
			2, pNewMachine->m_iNumOtherInstancesInSession,
			pNewMachine->m_szComputerName);

		this->Log(TNLST_CRITICAL, 
					"WARNING: There %s already %u TestNet slave instance%sfrom the same machine as %s in this session!",
					4, ((pNewMachine->m_iNumOtherInstancesInSession == 1) ? "is" : "are"),
					pNewMachine->m_iNumOtherInstancesInSession,
					((pNewMachine->m_iNumOtherInstancesInSession == 1) ? " " : "s "),
					pNewMachine->m_szComputerName);
	} // end if (multiple instances on same machine)


	// Initialize our record of the last time we heard from this guy so we don't
	// kill him right away...
	hr = pNewMachine->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't initialize slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't init receive time)


	// Add it to the list
	hr = this->m_slaves.Add(pNewMachine);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add new machine to our list!", 0);
		goto DONE;
	} // end if (couldn't add machine to list)



	// Add a work item to remind us to ping, if the user wants pings and this is the
	// first slave in a previously empty session.  It will continually readd a job
	// as long as there are slaves in the session.  It won't be able to do anything
	// until we drop the slave list lock below, though.
	if ((this->m_fPingSlaves) && (this->m_slaves.Count() == 1))
	{
		hr = this->m_jobs.AddJob(TNMJ_PINGSLAVES, SLAVE_CHECK_INTERVAL, NULL, NULL);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add ping check job!", 0);
			goto DONE;
		} // end if (couldn't add job)
	} // end if (we should ping the slaves)



	fHaveSlaveListLock = FALSE;
	this->m_slaves.LeaveCritSection();



	hr = this->m_reports.AddReport(RT_ADDMACHINE,
								1, &pNewMachine,
								NULL, 0, NULL, 0);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add report to list!", 0);
		goto DONE;
	} // end if (failed add report)


	// If we are doing the auto-report thing, and the report we just added is one
	// of the ones we are counting, check to see if that pushed us over the limit.
	if ((this->m_iAutoReportNumReports > 0) &&
		(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
	{
		hr = this->DoAutoReport();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-report!", 0);
			goto DONE;
		} // end if (couldn't print reports)
	} // end if (auto reporting is on and this was a matching report type)

	
	// Ping the event to let the app know about the new slave.
	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update event)


	// Send a reply to the joining slave.
	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, dwFromAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	CopyMemory(pSendData->m_pvAddress, (*ppvFromAddress), dwFromAddressSize);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_JOINREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pJoinReplyMsg = (PCTRLMSG_JOINREPLY) pSendData->m_pvData;
	pJoinReplyMsg->dwSize = pSendData->m_dwDataSize;
	pJoinReplyMsg->dwType = CTRLMSGID_JOINREPLY;

	CopyMemory(&(pJoinReplyMsg->id), &(pNewMachine->m_id), sizeof (TNCTRLMACHINEID));

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)
	
	pSendData = NULL; // forget about it so it doesn't get freed below


	// Add a work item to close the session, if we're supposed to now.
	if (fCloseSessionNow)
	{
		// Make sure no one can join between now and the time the job thread
		// actually closes the session.
		this->m_fJoinersAllowed = FALSE;

		hr = this->m_jobs.AddJob(TNMJ_CLOSESESSION, 0, NULL, NULL);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add close session job!", 0);
			goto DONE;
		} // end if (couldn't add job)

		//fCloseSession = FALSE;
	} // end if (should close session)
	else
	{
		// If there's a slave limit but no close time, print how close
		// we are to that limit.
		if ((this->m_iSlaveNumLimit != 0) && (fCloseSessionLater))
		{
			DPL(0, "Will close session when %i more slaves join.",
				1, (this->m_iSlaveNumLimit - this->m_slaves.Count()));

			this->Log(TNLST_CONTROLLAYER_INFO,
					"Will close session when %i more slave%s.",
					2, (this->m_iSlaveNumLimit - this->m_slaves.Count()),
					(((this->m_iSlaveNumLimit - this->m_slaves.Count()) == 1) ? " joins" : "s join"));
		} // end if (there's slave limit and no close time)
	} // end else (shouldn't close session)



	// Update the meta master if we're registered.
	if (this->m_fRegistered)
	{
		hr = this->SendMasterUpdate();
		if (hr != S_OK)
		{
			DPL(0, "Failed to send master update to meta-master!", 0);
			goto DONE;
		} // end if (failed send master update)
	} // end if (we're registered with a metamaster)


DONE:

	if (pNewMachine != NULL)
	{
		pNewMachine->m_dwRefCount--;
		if (pNewMachine->m_dwRefCount == 0)
		{
			DPL(1, "Deleting machine object %x (%s).",
				2, pNewMachine, pNewMachine->m_szComputerName);
			delete (pNewMachine);
			pNewMachine = NULL;
		} // end if (should delete object)
		else
		{
			DPL(7, "Not deleting machine object %x (%s), its refcount is %u.",
				3, pNewMachine, pNewMachine->m_szComputerName,
				pNewMachine->m_dwRefCount);
		} // end else (shouldn't delete object)
	} // end if (have machine object)

	if (fHaveSlaveListLock)
	{
		fHaveSlaveListLock = FALSE;
		this->m_slaves.LeaveCritSection();
	} // end if (still have lock)

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have a left over send data object)

	return (hr);
} // CTNMaster::HandleJoinMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleReadyToTestMsg()"
//==================================================================================
// CTNMaster::HandleReadyToTestMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session request command message.
//
// Arguments:
//	PVOID* ppvFromAddress					Pointer to pointer to data describing
//											ctrl comm from address.
//	DWORD dwFromAddressSize					Size of from address data.
//	PCTRLMSG_READYTOTEST pReadyToTestMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleReadyToTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_READYTOTEST pReadyToTestMsg)
{
	HRESULT		hr;


	DPL(0, "Got ReadyToTest message.", 0);


	hr = this->m_jobs.AddJob(TNMJ_READYTOTEST, 0, &(pReadyToTestMsg->id), NULL);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add ReadyToTest job for slave ID %u!",
			1, pReadyToTestMsg->id.dwTime);
		//goto DONE;
	} // end if (couldn't add job)

	return (hr);
} // CTNMaster::HandleReadyToTestMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleAnnounceSubTestMsg()"
//==================================================================================
// CTNMaster::HandleAnnounceSubTestMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session announce subtest message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_ANNOUNCESUBTEST pAnnounceSubTestMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleAnnounceSubTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_ANNOUNCESUBTEST pAnnounceSubTestMsg)
{
	HRESULT				hr = S_OK;
	PTNSLAVEINFO		pSlave = NULL;
	PTNTESTINSTANCEM	pParentTest = NULL;
	DWORD				dwModuleIDSize = 0;
	char*				pszModuleID = NULL;
	TNCTRLMACHINEID*	paTesters = NULL;
	int					iTesterNum = -1;
	int					i;
	int					j;
	PTNTESTINSTANCEM	pSubTest = NULL;
	PTNSLAVEINFO		pParentTester = NULL;
	PTNSLAVEINFO		pExistingSubTester = NULL;



	DPL(3, "Got AnnounceSubTest message.", 0);


	// Take the slave list lock.
	this->m_slaves.EnterCritSection();


	pSlave = this->m_slaves.GetSlaveByID(&(pAnnounceSubTestMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find announcing slave (%u) in list!",
			1, pAnnounceSubTestMsg->id.dwTime);

		// BUGBUG Fail?
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get slaveinfo object)


	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


	// Find the test with the specified parent ID
	pParentTest = pSlave->GetTest(pAnnounceSubTestMsg->dwTopLevelUniqueID,
									pAnnounceSubTestMsg->dwParentUniqueID);
	if (pParentTest == NULL)
	{
		DPL(0, "Couldn't get parent test ID %u (under ID %u)!",
			2, pAnnounceSubTestMsg->dwParentUniqueID,
			pAnnounceSubTestMsg->dwTopLevelUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find parent test with given ID)


#pragma TODO(vanceo, "All of this is duplicated in HandleRequestPokeTestMsg")

	dwModuleIDSize = strlen((char*) (pAnnounceSubTestMsg + 1)) + 1;

	// Get the case ID string for the subtest
	pszModuleID = (char*) LocalAlloc(LPTR, dwModuleIDSize);
	if (pszModuleID == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	CopyMemory(pszModuleID, (pAnnounceSubTestMsg + 1), dwModuleIDSize);

	paTesters = (TNCTRLMACHINEID*) (((LPBYTE) (pAnnounceSubTestMsg + 1)) + dwModuleIDSize);


	// Quick validate the passed in tester array to make sure the announcer isn't
	// trying anything naive, like using an invalid tester, or not including
	// himself.
	for(i = 0; i < pAnnounceSubTestMsg->iNumMachines; i++)
	{
		pParentTester = this->m_slaves.GetSlaveByID(&(paTesters[i]));
		if (pParentTester == NULL)
		{
#pragma BUGBUG(vanceo, "This workaround doesn't work for poke tests")
			// The slave may be dead, but we might recognize him from the parent
			// test.  If so, it means the slave should get a lost tester message
			// regarding that guy.
			for(j = 0; j < pParentTest->m_iNumMachines; j++)
			{
				if (memcmp(&(pParentTest->m_paTesterSlots[j].pSlave->m_id), &(paTesters[i]), sizeof (TNCTRLMACHINEID)) == 0)
				{
					DPL(0, "%s is trying to announce a subtest \"%s\" with a slave (%s, tester %i) who has left!  Assuming LostTester message is on its way.",
						3, pSlave->m_szComputerName, pszModuleID,
						pParentTest->m_paTesterSlots[j].pSlave->m_szComputerName,
						j);

#ifdef DEBUG
					// Double check to make sure the slot looks complete like it
					// should be after a slave dies.
					if (! pParentTest->m_paTesterSlots[j].fComplete)
					{
						DPL(0, "Gone slave %s's slot (%i) in test %u isn't marked as complete!?  DEBUGBREAK()-ing.",
							3, pParentTest->m_paTesterSlots[j].pSlave->m_szComputerName,
							j, pParentTest->m_dwUniqueID);

						DEBUGBREAK();
					} // end if (slot isn't complete
#endif // DEBUG

					goto DONE;
				} // end if (this is the desired tester)
			} // end for (each parent test tester)


			DPL(0, "%s is trying to announce a subtest \"%s\" with an invalid slave ID (%u, index %i)!",
				4, pSlave->m_szComputerName, pszModuleID,
				paTesters[i].dwTime, i);

			this->Log(TNLST_CRITICAL,
					"%s is trying to announce a subtest \"%s\" with an invalid slave ID (%u, index %i)!",
					4, pSlave->m_szComputerName, pszModuleID,
					paTesters[i].dwTime, i);

			hr = E_FAIL;
			goto DONE;
		} // end if (tester is out of range)

		// Check to see if it's the announcer.
		if (pParentTester == pSlave)
		{
			if (iTesterNum >= 0)
			{
				DPL(0, "%s is trying to announce subtest \"%s\" with itself as more than one of the testers (indicees %i and %i)!",
					4, pSlave->m_szComputerName, pszModuleID, iTesterNum, i);

				this->Log(TNLST_CRITICAL,
						"%s is trying to announce subtest \"%s\" with itself as more than one of the testers (indicees %i and %i)!",
						4, pSlave->m_szComputerName, pszModuleID, iTesterNum, i);

				hr = E_FAIL;
				goto DONE;
			} // end if (already found the announcer)

			iTesterNum = i;
		} // end if (it's the announcer)
		else
		{
			j = pParentTest->GetSlavesTesterNum(pParentTester);
			if (j < 0)
			{
				DPL(0, "%s is trying to announce subtest \"%s\" using a slave (%s) who isn't testing the parent test!",
					3, pSlave->m_szComputerName, pszModuleID,
					pParentTester->m_szComputerName);

				this->Log(TNLST_CRITICAL,
						"%s is trying to announce subtest \"%s\" using a slave (%s) who isn't testing the parent test!",
						3, pSlave->m_szComputerName, pszModuleID,
						pParentTester->m_szComputerName);

				hr = E_FAIL;
				goto DONE;
			} // end if (slave isn't working on parent test)

			// Make sure the person hasn't already completed the test.
			if (pParentTest->m_paTesterSlots[j].fComplete)
			{
				DPL(0, "%s is trying to announce subtest \"%s\" using a tester (%i, %s) who already completed the parent test!",
					4, pSlave->m_szComputerName, pszModuleID, j,
					pParentTester->m_szComputerName);

				this->Log(TNLST_CRITICAL,
						"%s is trying to announce subtest \"%s\" using a tester (%i, %s) who already completed the parent test!",
						4, pSlave->m_szComputerName, pszModuleID, j,
						pParentTester->m_szComputerName);

				hr = E_FAIL;
				goto DONE;
			} // end if (parent tester already completed test)
		} // end else (it's not the announcer)
	} // end for (each sub tester)

	if (iTesterNum < 0)
	{
		DPL(0, "%s is trying to announce subtest \"%s\" without itself as one of the testers!",
			2, pSlave->m_szComputerName, pszModuleID);

		this->Log(TNLST_CRITICAL,
				"%s is trying to announce subtest \"%s\" without itself as one of the testers!",
				2, pSlave->m_szComputerName, pszModuleID);

		hr = E_FAIL;
		goto DONE;
	} // end if (the slave did not include itself in the array)


	pSubTest = this->GetActiveTest(pParentTest,
									pszModuleID,
									pAnnounceSubTestMsg->iNumMachines,
									paTesters);

	// If we didn't find one, create it.
	if (pSubTest == NULL)
	{
		PTNTESTTABLECASE	pCase;


		pCase = this->m_testtable.GetTest(pszModuleID);
		if (pCase == NULL)
		{
			DPL(0, "Couldn't find test with module case ID %s!",
				1, pszModuleID);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't find test with given case ID)
		
		if (pCase->m_iNumMachines > 0)
		{
			if (pAnnounceSubTestMsg->iNumMachines != pCase->m_iNumMachines)
			{
				DPL(0, "Announcing slave doesn't list the correct number of testers for case ID %s (he says %i but it requires exactly %i)!",
					3, pszModuleID, pAnnounceSubTestMsg->iNumMachines,
					pCase->m_iNumMachines);
				hr = E_FAIL;
				goto DONE;
			} // end if (announcer is working with the wrong number of machines)
		} // end if (exact number of machines required)
#pragma BUGBUG(vanceo, "Remove if clause when all tests switch to ADDTESTDATA")
		else if (pCase->m_iNumMachines < 0)
		{
			if (pAnnounceSubTestMsg->iNumMachines < (-1 * pCase->m_iNumMachines))
			{
				DPL(0, "Announcing slave doesn't list the correct number of testers for case ID %s (he says %i but it requires at least %i)!",
					3, pszModuleID, pAnnounceSubTestMsg->iNumMachines,
					(-1 * pCase->m_iNumMachines));
				hr = E_FAIL;
				goto DONE;
			} // end if (announcer is working with the wrong number of machines)
		} // end else if (minimum number of machines required)

		pSubTest = new (CTNTestInstanceM)(this->m_dwCurrentUniqueID++,
											NULL,
											pCase,
											pAnnounceSubTestMsg->iNumMachines,
											//0,
											pParentTest);
		if (pSubTest == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)


		DPL(2, "No active subtest \"%s\" (%i machines) found, created test %u for %s.",
			4, pszModuleID, pAnnounceSubTestMsg->iNumMachines,
			pSubTest->m_dwUniqueID, pSlave->m_szComputerName);


		// Loop through each of the testers in the list the slave wants to assign,
		// and attach a placeholder for them to the subtest.
		// We won't notify anyone right now.
		for(i = 0; i < pAnnounceSubTestMsg->iNumMachines; i++)
		{
			// We're not checking the validity, it should have been caught above.
			pParentTester = this->m_slaves.GetSlaveByID(&(paTesters[i]));

			hr = this->AssignSlaveToTest(pParentTester, pSubTest, i, TRUE,
										FALSE, NULL, 0);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't assign placeholder for slave %s (tester %i) to test %s (unique ID %u)!",
					4, pParentTester->m_szComputerName, i,
					pSubTest->m_pCase->m_pszID, pSubTest->m_dwUniqueID);
				goto DONE;
			} // end if (couldn't assign slave to test)
		} // end for (each tester in the list)

		hr = pParentTest->m_subtests.Add(pSubTest);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add test (unique ID %u) to parent test (unique ID %u)!",
				2, pSubTest->m_dwUniqueID, pParentTest->m_dwUniqueID);
			delete (pSubTest);
			pSubTest = NULL;
			goto DONE;
		} // end if (couldn't add the test to the list)
	} // end if (the test doesn't already exist)
	else
	{
		DPL(4, "Active subtest \"%s\" (%i machines) for %s found, ID = %u.",
			4, pszModuleID, pAnnounceSubTestMsg->iNumMachines,
			pSlave->m_szComputerName, pSubTest->m_dwUniqueID);
	} // end else (the test already exists)


	// Make sure the announcer isn't sending something messed up.
	if (pAnnounceSubTestMsg->dwRequestID == 0)
	{
		DPL(0, "%s's announcement request ID is 0!",
			1, pSlave->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (no announce ID)


	// Make sure his announcement request ID isn't already filled...
	if (pSubTest->m_paTesterSlots[iTesterNum].dwAnnounceRequestID != 0)
	{
		DPL(0, "Announcement request ID already filled with %u (is %s announcing twice?)!",
			2, pSubTest->m_paTesterSlots[iTesterNum].dwAnnounceRequestID,
			pSlave->m_szComputerName);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (announce ID filled already)



	// Otherwise, store it so it can be echoed back to user when notifying
	// him.
	pSubTest->m_paTesterSlots[iTesterNum].dwAnnounceRequestID = pAnnounceSubTestMsg->dwRequestID;


	// Assign a non-placeholder for ourselves.  This may kick off the testing if
	// we're the last ones.
#pragma BUGBUG(vanceo, "Announce subtest data, too? see announcepoke")
	hr = this->AssignSlaveToTest(pSlave,
								pSubTest,
								iTesterNum,
								FALSE,
								FALSE,
								NULL,
								0);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't assign non-placeholder for %s (tester %i) to test %s (unique ID %i)!",
			4, pSlave->m_szComputerName, iTesterNum,
			pSubTest->m_pCase->m_pszID, pSubTest->m_dwUniqueID);
		goto DONE;
	} // end if (couldn't assign slave to test)


DONE:

	if (pszModuleID != NULL)
	{
		LocalFree(pszModuleID);
		pszModuleID = NULL;
	} // end if (we allocated a module ID)

	// Drop the slave list lock.
	this->m_slaves.LeaveCritSection();

	return (hr);
} // CTNMaster::HandleAnnounceSubTestMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleReportMsg()"
//==================================================================================
// CTNMaster::HandleReportMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session report message.
//
// Arguments:
//	PVOID* ppvFromAddress			Pointer to pointer to data describing ctrl comm
//									from address.
//	DWORD dwFromAddressSize			Size of from address data.
//	PCTRLMSG_REPORT pReportMsg		The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleReportMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_REPORT pReportMsg)
{
	HRESULT				hr;
	PVOID				pvReportMsgCopy = NULL;
	PTNSLAVEINFO		pSlave = NULL;


	DPL(9, "==>(%x, %u, %x)",
		3, ppvFromAddress, dwFromAddressSize, pReportMsg);


	this->m_slaves.EnterCritSection();

	pSlave = this->m_slaves.GetSlaveByID(&(pReportMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find reporting slave!", 0);

		this->m_slaves.LeaveCritSection();

		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find that slave in the list)


	DPL(1, "Got Report message from %s.", 1, pSlave->m_szComputerName);


	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)

	this->m_slaves.LeaveCritSection();



	// Copy the info of this message for delayed processing.
	pvReportMsgCopy = LocalAlloc(LPTR, (sizeof (CTRLMSG_REPORT) + pReportMsg->dwOutputDataSize + pReportMsg->dwVarsSize));
	if (pvReportMsgCopy == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	CopyMemory(pvReportMsgCopy, pReportMsg,
				(sizeof (CTRLMSG_REPORT) + pReportMsg->dwOutputDataSize + pReportMsg->dwVarsSize));

	// Pass the handling of this message off to the job thread.
	hr = this->m_jobs.AddJob(TNMJ_HANDLEREPORT, 0, &(pReportMsg->id),
							pvReportMsgCopy);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add HandleReportMsg job!", 0);

		LocalFree(pvReportMsgCopy);
		pvReportMsgCopy = NULL;

		goto DONE;
	} // end if (couldn't add job)

	// We successfully added the job, so forget about the memory we allocated, it will
	// be freed when the job is processed.
	pvReportMsgCopy = NULL;


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNMaster::HandleReportMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleWarningMsg()"
//==================================================================================
// CTNMaster::HandleWarningMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session warning message.
//
// Arguments:
//	PVOID* ppvFromAddress			Pointer to pointer to data describing ctrl comm
//									from address.
//	DWORD dwFromAddressSize			Size of from address data.
//	PCTRLMSG_WARNING pWarningMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleWarningMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_WARNING pWarningMsg)
{
	HRESULT				hr;
	PTNTESTINSTANCEM	pTest = NULL;
	PTNSLAVEINFO		pSlave = NULL;
	int					iTesterNum;
	DWORD				dwReportType = RT_WARNING;

	
	//DPL(0, "Got Warning message.", 0);

	// BUGBUG Validate machine ID

	pSlave = this->m_slaves.GetSlaveByID(&(pWarningMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find warning slave!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find that slave in the list)


	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


	pTest = pSlave->GetTest(pWarningMsg->dwTopLevelUniqueID, pWarningMsg->dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get test %u:%u %s is warning for!",
			3, pWarningMsg->dwTopLevelUniqueID, pWarningMsg->dwTestUniqueID,
			pSlave->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get test ID)


	DPL(0, "Test with unique ID %u:%u, hr = %x, data size = %u, data = %x.",
		4, pWarningMsg->dwTopLevelUniqueID, pWarningMsg->dwTestUniqueID,
		pWarningMsg->hresult, pWarningMsg->dwUserDataSize,
		((pWarningMsg->dwUserDataSize > 0) ? (pWarningMsg + 1) : NULL));

	this->Log(TNLST_CONTROLLAYER_TESTWARNING,
				"%s warns for test unique ID %u",
				2, pSlave->m_szComputerName,
				pWarningMsg->dwTestUniqueID);
	this->Log(TNLST_CONTROLLAYER_TESTWARNING,
			"Warning code = %e",
			1, pWarningMsg->hresult);


	hr = this->m_reports.AddReport(dwReportType,
								1, &pSlave,
								pTest,
								pWarningMsg->hresult,
								((pWarningMsg->dwUserDataSize > 0) ? (pWarningMsg + 1) : NULL),
								pWarningMsg->dwUserDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add report to list!", 0);
		goto DONE;
	} // end if (failed add report)


	// If we are doing the auto-report thing, and the report we just added is one
	// of the ones we are counting, check to see if that pushed us over the limit.
	if ((this->m_iAutoReportNumReports > 0) &&
		(this->m_dwAutoReportFlags & (TNREPORT_DURINGTESTWARNINGS | TNREPORT_TESTASSIGNMENTSTESTWARNED | TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTWARNED)))
	{
		hr = this->DoAutoReport();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-report!", 0);
			goto DONE;
		} // end if (couldn't print reports)
	} // end if (auto reporting is on and this was a matching report type)


	iTesterNum = pTest->GetSlavesTesterNum(pSlave);
	if (iTesterNum < 0)
	{
		DPL(0, "Couldn't slave %s's tester number in test %u!",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get tester number)


	// Make sure the test is cookin'.
	if (! pTest->m_fStarted)
	{
		DPL(0, "%s is trying to warn with a test (ID %u) which hasn't started yet?!",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (the test hasn't started)

	// Make sure the dude hasn't already claimed he finished it.
	if (pTest->m_paTesterSlots[iTesterNum].fComplete)
	{
		DPL(0, "%s is trying to warn during a test (ID %u) he already said he finished?!",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (he already finished the test)


	pTest->m_paTesterSlots[iTesterNum].iNumWarnings++;

	this->m_totalstats.IncrementWarnings();
	pTest->m_pCase->m_stats.IncrementWarnings();

	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update stats event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update stats event)


DONE:

	return (hr);
} // CTNMaster::HandleWarningMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleRequestSyncMsg()"
//==================================================================================
// CTNMaster::HandleRequestSyncMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session request sync message.
//
// Arguments:
//	PVOID* ppvFromAddress					Pointer to pointer to data describing
//											ctrl comm from address.
//	DWORD dwFromAddressSize					Size of from address data.
//	PCTRLMSG_REQUESTSYNC pRequestSyncMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleRequestSyncMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_REQUESTSYNC pRequestSyncMsg)
{
	HRESULT					hr = S_OK;
	PTNSLAVEINFO			pSlave = NULL;
	PTNTESTINSTANCEM		pTest = NULL;
	int						iTesterNum = -1;
	int						i;
	char*					pszSyncName = NULL;
	int*					piTempTesterNum = NULL;
	PTNSLAVEINFO			pTempSlave = NULL;
	CTNSyncDataList			insynclist;
	BOOL					fInSync = FALSE;
	PTNSYNCDATA				pSyncData = NULL;
	CTNSendDataQueue		tempsendqueue;
	DWORD					dwSyncDataBufferSize = 0;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_SYNCREPLY		pSyncReplyMsg = NULL;



	//DPL(0, "Got RequestSync message.", 0);

	pSlave = this->m_slaves.GetSlaveByID(&(pRequestSyncMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Received invalid slave ID!  Ignoring.", 0);
		hr = S_OK;
		goto DONE;
	} // end if (invalid ID)


	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


	pTest = pSlave->GetTest(pRequestSyncMsg->dwTopLevelUniqueID,
							pRequestSyncMsg->dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get test %u:%u %s is syncing in!",
			3, pRequestSyncMsg->dwTopLevelUniqueID, pRequestSyncMsg->dwTestUniqueID,
			pSlave->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get test ID)


	iTesterNum = pTest->GetSlavesTesterNum(pSlave);

	// If we didn't find it, then bail.
	if (iTesterNum < 0)
	{
		DPL(0, "Couldn't find the syncing slave (%s) in %i's tester list!",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find the syncing tester in the list)


	// Create the test's sync list if it doesn't exist

	if (pTest->m_pSyncDataList == NULL)
	{
		pTest->m_pSyncDataList = new (CTNSyncDataList);
		if (pTest->m_pSyncDataList == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)
	} // end if (the list doesn't exist)

	pszSyncName = (char*) (pRequestSyncMsg + 1);

	piTempTesterNum = (int*) (((LPBYTE) (pRequestSyncMsg + 1)) + pRequestSyncMsg->dwNameSize);
	// Validate the syncers target list (and make sure the target hasn't already
	// completed the test).
	for (i = 0; i < pRequestSyncMsg->iNumMachines; i++)
	{
        //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		if (((*(UNALIGNED int*)piTempTesterNum) < 0) || ((*(UNALIGNED int*)piTempTesterNum) >= pTest->m_iNumMachines))
		{
			DPL(0, "%s (tester %i) is trying to sync with out-of-range tester %i (its <0 or >=%i)!",
				4, pSlave->m_szComputerName, iTesterNum,
				(*(UNALIGNED int*)piTempTesterNum), pTest->m_iNumMachines);

			this->Log(TNLST_CRITICAL,
					"%s (tester %i) is trying to sync with out-of-range tester %i (its <0 or >%i)!",
					4, pSlave->m_szComputerName, iTesterNum,
					(*(UNALIGNED int*)piTempTesterNum), pTest->m_iNumMachines);

			hr = E_FAIL;
			goto DONE;
		} // end if (syncer is out of range)

		pTempSlave = pTest->m_paTesterSlots[(*(UNALIGNED int*)piTempTesterNum)].pSlave;

		if (pTempSlave == NULL)
		{
			DPL(0, "Sync target slot (%i) has not been filled yet.  Continuing.",
				1, (*(UNALIGNED int*)piTempTesterNum));
			//hr = E_FAIL;
			//goto DONE;
			piTempTesterNum++;
			continue;
		} // end if (target is invalid)

		if (pTempSlave == pSlave)
		{
			DPL(0, "%s (tester %i) is trying to sync with self in test %u!",
				3, pSlave->m_szComputerName, iTesterNum,
				pTest->m_dwUniqueID);

			this->Log(TNLST_CRITICAL,
					"%s (tester %i) is trying to sync with self in test %u!",
					3, pSlave->m_szComputerName, iTesterNum,
					pTest->m_dwUniqueID);

			hr = E_FAIL;
			goto DONE;
		} // end if (trying to sync with self)


		// If this slave already finished the test for this sync, then syncs
		// obviously can't be triggered, so send a tester lost message.
        //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		if (pTest->m_paTesterSlots[(*(UNALIGNED int*)piTempTesterNum)].fComplete)
		{
			DPL(0, "%s (tester %i) has already completed test %u, aborting %s (tester %i)'s sync.",
				5, pTempSlave->m_szComputerName,
				((int*) (pRequestSyncMsg + 1))[i],
				pTest->m_dwUniqueID,
				pSlave->m_szComputerName,
				iTesterNum);

			hr = this->SendLostTesterTo(pSlave, pTest, (*(UNALIGNED int*)piTempTesterNum));
			if (hr != S_OK)
			{
				if (hr != TNERR_CONNECTIONDROPPED)
				{
					DPL(0, "Couldn't send lost tester to %s!",
						1, pSlave->m_szComputerName);
					goto DONE;
				} // end if (not connectiondropped)
				else
				{
					DPL(0, "WARNING: Not sending LostTester message to %s because he's gone!",
						1, pSlave->m_szComputerName);
					hr = S_OK;
				} // end else (connection dropped)
			} // end if (couldn't send lost tester message)

			goto DONE;
		} // end if (the target already finished the test)

		piTempTesterNum++;
	} // end for (each sync target)


	hr = pTest->m_pSyncDataList->AddAndDoSyncCheck(pRequestSyncMsg->dwRequestID,
													pszSyncName,
													iTesterNum,
													pRequestSyncMsg->iNumMachines,
													(int*) (((LPBYTE) (pRequestSyncMsg + 1))
																	+ pRequestSyncMsg->dwNameSize),
													((pRequestSyncMsg->dwDataSize == 0) ? NULL :
														(((LPBYTE) (pRequestSyncMsg + 1))
															+ pRequestSyncMsg->dwNameSize
															+ pRequestSyncMsg->iNumMachines * sizeof (int))),
													pRequestSyncMsg->dwDataSize,
													&insynclist,
													&fInSync);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add %s (tester %i) to test %u's \"%s\" sync list!",
			4, pSlave->m_szComputerName, iTesterNum,
			pTest->m_dwUniqueID, pszSyncName);
		goto DONE;
	} // end if (couldn't add syncer to list)


	// If adding him did not change anybody's sync status (i.e. release them
	// from the sync block), then we're done.

	if (! fInSync)
	{
		DPL(8, "Adding %s (tester %u) to test %u's \"%s\" sync has not released everyone yet, continuing to wait.",
			4, pSlave->m_szComputerName, iTesterNum,
			pTest->m_dwUniqueID, pszSyncName);
		goto DONE;
	} // end if (not in sync yet)


	// Loop through everyone who became in sync and notify them.

	for(i = 0; i < insynclist.Count(); i++)
	{
		pSyncData = (PTNSYNCDATA) insynclist.GetItem(i);
		if (pSyncData == NULL)
		{
			DPL(0, "Couldn't get in-sync person %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)


		pSlave = pTest->m_paTesterSlots[pSyncData->m_iTesterNum].pSlave;
		if (pSlave == NULL)
		{
			DPL(0, "Couldn't get now in-sync tester %i!", 1, pSyncData->m_iTesterNum);
			hr = E_FAIL;
			goto DONE;
		} // end if (tester number isn't valid)


		DPL(5, "Releasing %s (tester %i) from sync \"%s\" in test %u.",
			4, pSlave->m_szComputerName, pSyncData->m_iTesterNum,
			pSyncData->m_pszSyncName, pTest->m_dwUniqueID);


		if (pSyncData->m_dwRequestID == 0)
		{
			DPL(0, "No request ID given for item (%s's sync \"%s\" in test %u)!",
				3, pSlave->m_szComputerName, pSyncData->m_pszSyncName,
				pTest->m_dwUniqueID);
			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (no request ID)


		// Build the "release" message to this person, it's buffered so we won't
		// actually send it right away.

		pSendData = new (CTNSendData);
		if (pSendData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (out of memory)

		pSendData->m_fGuaranteed = TRUE;
		pSendData->m_dwAddressSize = pSlave->m_commdata.dwAddressSize;
		pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
		if (pSendData->m_pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (out of memory)
		CopyMemory(pSendData->m_pvAddress, pSlave->m_commdata.pvAddress,
				pSendData->m_dwAddressSize);

		// ignore error
		insynclist.PackDataForTesterIntoBuffer(pSyncData->m_iTesterNum,
												NULL, &dwSyncDataBufferSize);

		pSendData->m_dwDataSize = sizeof (CTRLMSG_SYNCREPLY)
								+ dwSyncDataBufferSize;

		pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
		if (pSendData->m_pvData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		pSyncReplyMsg = (PCTRLMSG_SYNCREPLY) pSendData->m_pvData;
		pSyncReplyMsg->dwSize = pSendData->m_dwDataSize;
		pSyncReplyMsg->dwType = CTRLMSGID_SYNCREPLY;
		pSyncReplyMsg->dwResponseID = pSyncData->m_dwRequestID;
		pSyncReplyMsg->dwDataSize = dwSyncDataBufferSize;

		if (dwSyncDataBufferSize > 0)
		{
			hr = insynclist.PackDataForTesterIntoBuffer(pSyncData->m_iTesterNum,
														(pSyncReplyMsg + 1),
														&dwSyncDataBufferSize);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't pack sync data list for tester %i into buffer!",
					1, pSyncData->m_iTesterNum);
				goto DONE;
			} // end if (failed to pack sync data list into buffer)
		} // end if (there's actually sync data)
		

		// Add the item to our temporary send queue.  We don't add it to
		// the real one because if it went out before we had a chance to
		// reset the synchronization, the slave might continue on with
		// the test, try to sync again, and we might get goofy because
		// we'd have stale data.  So hold off on sending the items until
		// everybody is ready.

		hr = tempsendqueue.Add(pSendData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add send item to temporary queue!", 0);
			goto DONE;
		} // end if (failed to add item to queue)

		pSendData = NULL; // forget about it so it doesn't get freed below

	} // end for (each person now in sync)


	// Go through the loop again and clear out the syncing data for everyone
	// who became in sync so they are back to a normal state, and can sync
	// again.
	i = 0;
	do
	{
		pSyncData = (PTNSYNCDATA) insynclist.PopFirstItem();
		if (pSyncData == NULL)
		{
			DPL(0, "Couldn't pop in-sync person %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't pop item)

		// Pull it off the test's master sync list
		hr = pTest->m_pSyncDataList->RemoveFirstReference(pSyncData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove in-sync person %i from test's master sync list!",
				1, i);
			goto DONE;
		} // end if (couldn't remove item)

		// We don't need his list of schmoes he's syncing with anymore,
		// so dump it.
		delete (pSyncData->m_pSyncList);
		pSyncData->m_pSyncList = NULL;


		// Delete the object, if it's time.
		pSyncData->m_dwRefCount--;
		if (pSyncData->m_dwRefCount == 0)
		{
			DPL(7, "Deleting sync data object %x.", 1, pSyncData);

			delete (pSyncData);
			pSyncData = NULL;
		} // end if (can remove item)
		else
		{
			DPL(7, "Not deleting sync data object %x, it's refcount is %u.",
				2, pSyncData, pSyncData->m_dwRefCount);
		} // end else (can't remove item)

		i++;
	} // end do (while there are items remaining)
	while (insynclist.Count() > 0);


	// If there aren't any more people trying to sync in this test, then we can
	// free up the list.
	if (pTest->m_pSyncDataList->Count() <= 0)
	{
		delete (pTest->m_pSyncDataList);
		pTest->m_pSyncDataList = NULL;
	} // end if (there aren't any syncs pending)



	// Finally transfer everything from our temp send queue to the real one.
	while(tempsendqueue.Count() > 0)
	{
		pSendData = (PTNSENDDATA) tempsendqueue.PopFirstItem();
		if (pSendData == NULL)
		{
			DPL(0, "Couldn't pop first item from temp send queue!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't pop that item)

		hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add send item to real send queue!", 0);
			goto DONE;
		} // end if (couldn't get that item)

		pSendData->m_dwRefCount--;
		if (pSendData->m_dwRefCount == 0)
		{
			DPL(0, "Deleting send data object %x!?",
				1, pSendData);

			delete (pSendData);
		} // end if (have to delete object)
		pSendData = NULL; // forget about it so we don't free it below
	} // end while (there are still items in the temporary queue)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (there's send data)

	return (hr);
} // CTNMaster::HandleRequestSyncMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleUserQueryMsg()"
//==================================================================================
// CTNMaster::HandleUserQueryMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session user query message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_USERQUERY pUserQueryMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleUserQueryMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_USERQUERY pUserQueryMsg)
{
	HRESULT					hr = S_OK;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_USERRESPONSE	pUserResponseMsg = NULL;
	DWORD					dwResponse = 0;
	DWORD					dwResponseDataSize = 0;


	//DPL(0, "Got UserQuery message.", 0);

	if (this->m_pfnHandleUserQuery == NULL)
	{
		DPL(0, "UserQuery received but the master didn't specify a handler!  Ignoring.", 0);
		hr = S_OK;
		goto DONE;
	} // end if (the user doesn't have UserRequest handler)

	hr = this->m_pfnHandleUserQuery(pUserQueryMsg->dwQuery,
								(pUserQueryMsg + 1), pUserQueryMsg->dwDataSize,
								&dwResponse, NULL, &dwResponseDataSize);
	if (hr != S_OK)
	{
		DPL(0, "App's HandleUserRequestProc with no response data buffer failed!", 0);
		goto DONE;
	} // end if (app's proc failed)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_USERRESPONSE)
							+ dwResponseDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pUserResponseMsg = (PCTRLMSG_USERRESPONSE) pSendData->m_pvData;
	pUserResponseMsg->dwSize = pSendData->m_dwDataSize;
	pUserResponseMsg->dwType = CTRLMSGID_USERRESPONSE;

	pUserResponseMsg->dwResponse = dwResponse;
	pUserResponseMsg->dwDataSize = dwResponseDataSize;
	if (dwResponseDataSize > 0)
	{
		hr = this->m_pfnHandleUserQuery(pUserQueryMsg->dwQuery,
									(pUserQueryMsg + 1), pUserQueryMsg->dwDataSize,
									&dwResponse, (pUserResponseMsg + 1),
									&dwResponseDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Module's HandleUserQueryProc function failed!", 0);
			goto DONE;
		} // end if (module's proc failed)
	} // end if (there's actually extra response data)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNMaster::HandleUserQueryMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


	



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleIdleMsg()"
//==================================================================================
// CTNMaster::HandleIdleMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session idle message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm from
//								address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PCTRLMSG_IDLE pIdleMsg		The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleIdleMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_IDLE pIdleMsg)
{
	HRESULT				hr = S_OK;
	PTNSLAVEINFO		pSlave = NULL;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_IDLEREPLY	pIdleReplyMsg = NULL;
	DWORD				dwReturnStatus = 0;


	this->m_slaves.EnterCritSection();

	pSlave = this->m_slaves.GetSlaveByID(&(pIdleMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Received invalid slave ID!  Ignoring.", 0);
		hr = S_OK;
		goto DONE;
	} // end if (invalid ID)


	DPL(1, "Got Idle message from %s.", 1, pSlave->m_szComputerName);


	// Validate what the slave is saying
	switch (pIdleMsg->dwWaitingOp)
	{
		case CTRLIDLE_NOTHING:
		case CTRLIDLE_ANNOUNCESUBTEST:
		case CTRLIDLE_SYNC:

#pragma BUGBUG(vanceo, "Verify if he is in the state indicated.")

			dwReturnStatus = CTRLIDLEREPLY_WAITINGFOROTHERTESTERS;
		  break;

		default:
			DPL(0, "Slave %s is reporting an unrecognized op %u!",
				2, pSlave->m_szComputerName, pIdleMsg->dwWaitingOp);
			goto DONE;
		  break;
	} // end switch (on the op the slave says he's performing)


	// We're in sync, so update his time.
	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)



	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_IDLEREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pIdleReplyMsg = (PCTRLMSG_IDLEREPLY) pSendData->m_pvData;
	pIdleReplyMsg->dwSize = pSendData->m_dwDataSize;
	pIdleReplyMsg->dwType = CTRLMSGID_IDLEREPLY;
	pIdleReplyMsg->dwStatus = dwReturnStatus;

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send data object)

	this->m_slaves.LeaveCritSection();

	return (hr);
} // CTNMaster::HandleIdleMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleRegisterMasterReplyMsg()"
//==================================================================================
// CTNMaster::HandleRegisterMasterReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session register master reply message.
//
// Arguments:
//	PVOID* ppvFromAddress									Pointer to pointer to
//															data describing ctrl
//															comm from address.
//	DWORD dwFromAddressSize									Size of from address
//															data.
//	PCTRLMSG_REGISTERMASTERREPLY pRegisterMasterReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleRegisterMasterReplyMsg(PVOID* ppvFromAddress,
												DWORD dwFromAddressSize,
												PCTRLMSG_REGISTERMASTERREPLY pRegisterMasterReplyMsg)
{
	DPL(0, "Got RegisterMasterReply message.", 0);

	if (this->m_fRegistered)
	{
		DPL(0, "Received registration reply but we're already registered.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're already register)

	this->m_fRegistered = TRUE;
	CopyMemory(&(this->m_id), &(pRegisterMasterReplyMsg->id), sizeof (TNCTRLMACHINEID));

	return (S_OK);
} // CTNMaster::HandleRegisterMasterReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleMasterPingReplyMsg()"
//==================================================================================
// CTNMaster::HandleRegisterMasterPingReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a master ping reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_MASTERPINGREPLYMSG pMasterReplyMsg		Reply message from the slave.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleMasterPingReplyMsg(PVOID* ppvFromAddress,
											DWORD dwFromAddressSize,
											PCTRLMSG_MASTERPINGSLAVEREPLY pMasterReplyMsg)
{
	HRESULT			hr = S_OK;
	PTNSLAVEINFO	pSlave = NULL;
	

	DPL(8, "Got master reply ping message.", 0);


	pSlave = this->m_slaves.GetSlaveByID(&pMasterReplyMsg->id);
	if (pSlave == NULL)
	{
		DPL(0, "Received invalid slave ID!  Ignoring.", 0);
		goto DONE;
	} // end if (couldn't find slave)

	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


DONE:

	return hr;
} // CTNMaster::HandleMasterPingReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleRequestPokeTestMsg()"
//==================================================================================
// CTNMaster::HandleRequestPokeTestMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session request poke test message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_REQUESTPOKETEST pRequestPokeTestMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleRequestPokeTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_REQUESTPOKETEST pRequestPokeTestMsg)
{
	HRESULT				hr = S_OK;
	PTNSLAVEINFO		pSlave = NULL;
	PTNSLAVEINFO		pOtherSlave = NULL;
	PTNSLAVEINFO		pExistingTester = NULL;
	PTNTESTINSTANCEM	pTest = NULL;
	DWORD				dwModuleIDSize = 0;
	LPBYTE				lpCurrent;
	char*				pszModuleID = NULL;
	PTNCTRLMACHINEID	paTesterArray = NULL;
	PVOID				pvInputData;
	int					iTesterNum = -1;
	int					i;


	DPL(3, "Got RequestPokeTest message.", 0);

	// Take the slave list lock.
	this->m_slaves.EnterCritSection();

	pSlave = this->m_slaves.GetSlaveByID(&(pRequestPokeTestMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find requesting slave (%u) in list!",
			1, pRequestPokeTestMsg->id.dwTime);

		// BUGBUG Fail?
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get slaveinfo object)


	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


#pragma TODO(vanceo, "Most of this is duplicated in HandleAnnounceSubTestMsg")

	lpCurrent = (LPBYTE) (pRequestPokeTestMsg + 1);

	dwModuleIDSize = strlen((char*) lpCurrent) + 1;

	// Get the case ID string for the subtest
	pszModuleID = (char*) LocalAlloc(LPTR, dwModuleIDSize);
	if (pszModuleID == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	CopyAndMoveSrcPointer(pszModuleID, lpCurrent, dwModuleIDSize);

	paTesterArray = (PTNCTRLMACHINEID) lpCurrent;

	if (pRequestPokeTestMsg->dwInputDataSize > 0)
	{
		lpCurrent += sizeof (TNCTRLMACHINEID) * pRequestPokeTestMsg->iNumMachines;
		pvInputData = lpCurrent;
	} // end if (there's input data)
	else
	{
		pvInputData = NULL;
	} // end else (there's no input data)


	// Quick validate the passed in tester array to make sure the announcer isn't
	// trying anything naive, like using an invalid tester, or not including
	// himself.
	for(i = 0; i < pRequestPokeTestMsg->iNumMachines; i++)
	{
		pOtherSlave = this->m_slaves.GetSlaveByID(&(paTesterArray[i]));
		if (pOtherSlave == NULL)
		{
			DPL(0, "%s is trying to request a poke test \"%s\" with an invalid slave ID (%u, index %i)!",
				4, pSlave->m_szComputerName, pszModuleID,
				paTesterArray[i].dwTime, i);

			this->Log(TNLST_CRITICAL,
					"%s is trying to request a poke test \"%s\" with an invalid slave ID (%u, index %i)!",
				4, pSlave->m_szComputerName, pszModuleID,
				paTesterArray[i].dwTime, i);

			hr = E_FAIL;
			goto DONE;
		} // end if (tester is out of range)

		// Check to see if it's the requester.
		if (pOtherSlave == pSlave)
		{
			if (iTesterNum >= 0)
			{
				DPL(0, "%s is trying to request a poke test \"%s\" with itself as more than one of the testers (indices %i and %i)!",
					4, pSlave->m_szComputerName, pszModuleID, iTesterNum, i);

				this->Log(TNLST_CRITICAL,
						"%s is trying to request a poke test \"%s\" with itself as more than one of the testers (indices %i and %i)!",
						4, pSlave->m_szComputerName, pszModuleID, iTesterNum, i);

				hr = E_FAIL;
				goto DONE;
			} // end if (already found the requester)

			iTesterNum = i;
		} // end if (it's the requester)
	} // end for (each tester)

	if (iTesterNum < 0)
	{
		DPL(0, "%s is trying to request a poke test \"%s\" without itself as one of the testers!",
			2, pSlave->m_szComputerName, pszModuleID);

		this->Log(TNLST_CRITICAL,
				"%s is trying to request a poke test \"%s\" without itself as one of the testers!",
				2, pSlave->m_szComputerName, pszModuleID);

		hr = E_FAIL;
		goto DONE;
	} // end if (the slave did not include itself in the array)


	pTest = this->GetActiveTest(NULL,
								pszModuleID,
								pRequestPokeTestMsg->iNumMachines,
								paTesterArray);

	// If we didn't find one, create it.
	if (pTest == NULL)
	{
		PTNTESTTABLECASE	pCase;


		pCase = this->m_testtable.GetTest(pszModuleID);
		if (pCase == NULL)
		{
			DPL(0, "Couldn't find test with module case ID %s!",
				1, pszModuleID);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't find test with given case ID)
		
		if (pCase->m_iNumMachines > 0)
		{
			if (pRequestPokeTestMsg->iNumMachines != pCase->m_iNumMachines)
			{
				DPL(0, "Requesting slave doesn't list the correct number of testers for case ID %s (he says %i but it requires exactly %i)!",
					3, pszModuleID, pRequestPokeTestMsg->iNumMachines,
					pCase->m_iNumMachines);
				hr = E_FAIL;
				goto DONE;
			} // end if (requestor is working with the wrong number of machines)
		} // end if (exact number of machines required)
#pragma BUGBUG(vanceo, "Remove if clause when all tests switch to ADDTESTDATA")
		else if (pCase->m_iNumMachines < 0)
		{
			if (pRequestPokeTestMsg->iNumMachines < (-1 * pCase->m_iNumMachines))
			{
				DPL(0, "Requesting slave doesn't list the correct number of testers for case ID %s (he says %i but it requires at least %i)!",
					3, pszModuleID, pRequestPokeTestMsg->iNumMachines,
					(-1 * pCase->m_iNumMachines));
				hr = E_FAIL;
				goto DONE;
			} // end if (requestor is working with the wrong number of machines)
		} // end else if (minimum number of machines required)


		pTest = new (CTNTestInstanceM)(this->m_dwCurrentUniqueID++,
										NULL,
										pCase,
										pRequestPokeTestMsg->iNumMachines,
										//0,
										NULL);
		if (pTest == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)


		DPL(2, "No active test \"%s\" (%i machines) found, created test %u for %s.",
			4, pszModuleID, pRequestPokeTestMsg->iNumMachines,
			pTest->m_dwUniqueID, pSlave->m_szComputerName);


		// Loop through each of the testers in the list the slave wants to assign, and
		// attach a placeholder for them to the poke test.
		// We won't notify anyone right now.
		for(i = 0; i < pRequestPokeTestMsg->iNumMachines; i++)
		{
			// Not checking validity, it should have been caught above.
			pOtherSlave = this->m_slaves.GetSlaveByID(&(paTesterArray[i]));

			hr = this->AssignSlaveToTest(pOtherSlave, pTest, i,
										TRUE, FALSE, NULL, 0);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't assign slave %s (tester %i) to test %s (unique ID %i)!",
					4, pOtherSlave->m_szComputerName, i,
					pTest->m_pCase->m_pszID, pTest->m_dwUniqueID);
				goto DONE;
			} // end if (couldn't assign slave to test)
		} // end for (each tester in the list)
	} // end if (the test doesn't already exist)
	else
	{
		DPL(2, "Active test \"%s\" (%i machines) for %s found, ID = %u.",
			4, pszModuleID, pRequestPokeTestMsg->iNumMachines,
			pSlave->m_szComputerName, pTest->m_dwUniqueID);
	} // end else (the test already exists)


#ifdef DEBUG
	if (pSlave->m_pCurrentTest != NULL)
	{
		DPL(0, "Slave %s already has a current test (unique ID %u)!",
			2, pSlave->m_szComputerName, pSlave->m_pCurrentTest->m_dwUniqueID);
		DEBUGBREAK();
	} // end if (slave has a current test)
#endif // DEBUG

	pTest->m_dwRefCount++;
	pSlave->m_pCurrentTest = pTest;


	// Make sure his request ID isn't already filled...
	if (pTest->m_paTesterSlots[iTesterNum].dwAnnounceRequestID != 0)
	{
		DPL(0, "Announcement request ID already filled with %u (is %s requesting poke test twice?)!",
			2, pTest->m_paTesterSlots[iTesterNum].dwAnnounceRequestID,
			pSlave->m_szComputerName);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (announce ID filled already)

	// Otherwise, store it so it can be echoed back to user when notifying
	// him.
	pTest->m_paTesterSlots[iTesterNum].dwAnnounceRequestID = pRequestPokeTestMsg->dwRequestID;



	// Assign a non-placeholder for ourselves.  This may kick off the testing if
	// we're the last ones.
#pragma BUGBUG(vanceo, "See announcesubtest")
	hr = this->AssignSlaveToTest(pSlave,
								pTest,
								iTesterNum,
								FALSE,
								FALSE,
								pvInputData,
								pRequestPokeTestMsg->dwInputDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't assign non-placeholder for %s (tester %i) to test %s (unique ID %i)!",
			4, pSlave->m_szComputerName, iTesterNum,
			pTest->m_pCase->m_pszID, pTest->m_dwUniqueID);
		goto DONE;
	} // end if (couldn't assign slave to test)



DONE:

	if (pszModuleID != NULL)
	{
		LocalFree(pszModuleID);
		pszModuleID = NULL;
	} // end if (we allocated a module ID)

	// Drop the slave list lock.
	this->m_slaves.LeaveCritSection();

	return (hr);
} // CTNMaster::HandleRequestPokeTestMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleAcceptReachCheckReplyMsg()"
//==================================================================================
// CTNMaster::HandleAcceptReachCheckReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session accept reach check reply message.
//
// Arguments:
//	PVOID* ppvFromAddress						Pointer to pointer to data
//												describing ctrl comm from address.
//	DWORD dwFromAddressSize						Size of from address data.
//	PCTRLMSG_ACCEPTREACHCHECKREPLY pReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleAcceptReachCheckReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
												PCTRLMSG_ACCEPTREACHCHECKREPLY pReplyMsg)
{
	HRESULT					hr = S_OK;
	PTNSLAVEINFO			pSlave = NULL;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	PTNREACHCHECK			pReachCheck = NULL;


	DPL(1, "Got AcceptReachCheckReply message (ID %u, fReady = %B, hresult = %x).",
		3, pReplyMsg->dwID, pReplyMsg->fReady, pReplyMsg->hresult);


	this->m_slaves.EnterCritSection();

	pSlave = this->m_slaves.GetSlaveByID(&(pReplyMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find replying slave (%u) in list!",
			1, pReplyMsg->id.dwTime);

		// BUGBUG Fail?
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get slaveinfo object)


	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


	pReachCheckTarget = pSlave->m_reachchecktargets.GetTarget(&(pSlave->m_id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't get list of self targets (i.e. no outstanding accepts) for replying slave %s!",
			1, pSlave->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get target)

	pReachCheck = pReachCheckTarget->m_checks.GetCheck(pReplyMsg->dwID);
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't get reach check ID %u for replying slave %s!",
			2, pReplyMsg->dwID, pSlave->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get check)

	pReachCheck->m_fResult = pReplyMsg->fReady;
	pReachCheck->m_hresult = pReplyMsg->hresult;

	if (! SetEvent(pReachCheck->m_hEvent))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set reach check event %x!", 1, pReachCheck->m_hEvent);
		goto DONE;
	} // end if (couldn't set event)


DONE:

	this->m_slaves.LeaveCritSection();

	return (hr);
} // CTNMaster::HandleAcceptReachCheckReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleConnectReachCheckReplyMsg()"
//==================================================================================
// CTNMaster::HandleConnectReachCheckReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session connect reach check reply message.
//
// Arguments:
//	PVOID* ppvFromAddress						Pointer to pointer to data
//												describing ctrl comm from address.
//	DWORD dwFromAddressSize						Size of from address data.
//	PCTRLMSG_CONNECTREACHCHECKREPLY pReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleConnectReachCheckReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
												PCTRLMSG_CONNECTREACHCHECKREPLY pReplyMsg)
{
	HRESULT					hr = S_OK;
	PTNSLAVEINFO			pSlave = NULL;
	int						i;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	PTNREACHCHECK			pReachCheck = NULL;


	DPL(1, "Got ConnectReachCheckReply message (ID %u, fReachable = %B, hresult = %x).",
		3, pReplyMsg->dwID, pReplyMsg->fReachable, pReplyMsg->hresult);


	this->m_slaves.EnterCritSection();

	pSlave = this->m_slaves.GetSlaveByID(&(pReplyMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find replying slave (%u) in list!",
			1, pReplyMsg->id.dwTime);

		// BUGBUG Fail?
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get slaveinfo object)


	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


	for(i = 0; i < pSlave->m_reachchecktargets.Count(); i++)
	{
		pReachCheckTarget = (PTNREACHCHECKTARGET) pSlave->m_reachchecktargets.GetItem(i);
		if (pReachCheckTarget == NULL)
		{
			DPL(0, "Couldn't get %s's reach check target %i!",
				2, pSlave->m_szComputerName, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		// Skip the self accepts list, if this is it.
		if (memcmp(&(pReachCheckTarget->m_id), &(pSlave->m_id), sizeof (TNCTRLMACHINEID)) == 0)
			continue;

		pReachCheck = pReachCheckTarget->m_checks.GetCheck(pReplyMsg->dwID);
		if (pReachCheck != NULL)
		{
			pReachCheck->m_fResult = pReplyMsg->fReachable;
			pReachCheck->m_hresult = pReplyMsg->hresult;

			if (! SetEvent(pReachCheck->m_hEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set reach check event %x!",
					1, pReachCheck->m_hEvent);
			} // end if (couldn't set event)

			goto DONE;
		} // end if (found check)
	} // end for (each target)


	// If we got here, it means we couldn't find the given check.

	DPL(0, "Couldn't get reach check ID %u for replying slave %s!",
		2, pReplyMsg->dwID, pSlave->m_szComputerName);
	hr = E_FAIL;


DONE:

	this->m_slaves.LeaveCritSection();

	return (hr);
} // CTNMaster::HandleConnectReachCheckReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleFreeOutputVarsMsg()"
//==================================================================================
// CTNMaster::HandleFreeOutputVarsMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session free output vars message.
//
// Arguments:
//	PVOID* ppvFromAddress						Pointer to pointer to data
//												describing ctrl comm from address.
//	DWORD dwFromAddressSize						Size of from address data.
//	PCTRLMSG_FREEOUTPUTVARS pFreeOutputVarsMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleFreeOutputVarsMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_FREEOUTPUTVARS pFreeOutputVarsMsg)
{
	HRESULT			hr = S_OK;
	PTNSLAVEINFO	pSlave = NULL;
	LPBYTE			lpCurrent;
	char*			pszCaseID = NULL;
	char*			pszInstanceID = NULL;
	char*			pszName = NULL;
	char*			pszType = NULL;


	DPL(3, "Got FreeOutputVars message.", 0);


	this->m_slaves.EnterCritSection();

	pSlave = this->m_slaves.GetSlaveByID(&(pFreeOutputVarsMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find freeing slave (%u) in list!",
			1, pFreeOutputVarsMsg->id.dwTime);

		// BUGBUG Fail?
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get slaveinfo object)

	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


	lpCurrent = (LPBYTE) (pFreeOutputVarsMsg + 1);

	if (pFreeOutputVarsMsg->dwCaseIDSize > 0)
	{
		pszCaseID = (char*) lpCurrent;
		lpCurrent += pFreeOutputVarsMsg->dwCaseIDSize;
	} // end if (there's a case ID)

	if (pFreeOutputVarsMsg->dwInstanceIDSize > 0)
	{
		pszInstanceID = (char*) lpCurrent;
		lpCurrent += pFreeOutputVarsMsg->dwInstanceIDSize;
	} // end if (there's an instance ID)

	if (pFreeOutputVarsMsg->dwNameSize > 0)
	{
		pszName = (char*) lpCurrent;
		lpCurrent += pFreeOutputVarsMsg->dwNameSize;
	} // end if (there's a name)

	if (pFreeOutputVarsMsg->dwTypeSize > 0)
	{
		pszType = (char*) lpCurrent;
		lpCurrent += pFreeOutputVarsMsg->dwTypeSize;
	} // end if (there's a type)


	hr = this->FreeOutputVarsAndData(pszCaseID, pszInstanceID, pSlave, pszName,
									pszType);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't free %s's output variables and data!", 0);
		goto DONE;
	} // end if (couldn't free data)


DONE:

	this->m_slaves.LeaveCritSection();

	return (hr);
} // CTNMaster::HandleFreeOutputVarsMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::HandleGetMachineInfoMsg()"
//==================================================================================
// CTNMaster::HandleGetMachineInfoMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session GetMachineInfo message.
//
// Arguments:
//	PVOID* ppvFromAddress						Pointer to pointer to data
//												describing ctrl comm from address.
//	DWORD dwFromAddressSize						Size of from address data.
//	PCTRLMSG_GETMACHINEINFO pGetMachineInfoMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::HandleGetMachineInfoMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_GETMACHINEINFO pGetMachineInfoMsg)
{
	HRESULT							hr;
	PTNSLAVEINFO					pSlave = NULL;
	PTNSLAVEINFO					pInfoSlave = NULL;
	DWORD							dwMachineInfoSize = 0;
	PTNSENDDATA						pSendData = NULL;
	PCTRLMSG_GETMACHINEINFOREPLY	pReplyMsg;



	DPL(3, "Got GetMachineInfo message.", 0);

	this->m_slaves.EnterCritSection();

	pSlave = this->m_slaves.GetSlaveByID(&(pGetMachineInfoMsg->id));
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find requesting slave (%u) in list!",
			1, pGetMachineInfoMsg->id.dwTime);

		// BUGBUG Fail?
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get slaveinfo object)

	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)



	// Find the slave whose info he's trying to retrieve.
	pInfoSlave = this->m_slaves.GetSlaveByID(&(pGetMachineInfoMsg->idMachineForInfo));
	if (pInfoSlave == NULL)
	{
		DPL(0, "Couldn't find slave (%u) in list to retrieve info!",
			1, pGetMachineInfoMsg->idMachineForInfo.dwTime);

		// BUGBUG Fail?
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get slaveinfo object)


	// Ignore error, assume ERROR_BUFFER_TOO_SMALL
	pInfoSlave->PackIntoBuffer(NULL, &dwMachineInfoSize);



	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_GETMACHINEINFOREPLY)
							+ dwMachineInfoSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_GETMACHINEINFOREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_GETMACHINEINFOREPLY;
	pReplyMsg->dwResponseID = pGetMachineInfoMsg->dwRequestID; // echo back
	pReplyMsg->dwMachineInfoSize = dwMachineInfoSize;

	// Now pack the machine info into the message buffer.
	hr = pInfoSlave->PackIntoBuffer((pReplyMsg + 1), &dwMachineInfoSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack machine info into message buffer!", 0);
		goto DONE;
	} // end if (couldn't pack info into buffer)


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send data object)

	this->m_slaves.LeaveCritSection();

	return (hr);
} // CTNMaster::HandleGetMachineInfoMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetNextCmdForMachine()"
//==================================================================================
// CTNMaster::GetNextCmdForMachine
//----------------------------------------------------------------------------------
//
// Description: Gets the next test to run or command to process for the specified
//				machine.  Any notification necessary is done within this function.
//				The slave list lock is assumed to be held with only one level of
//				recursion.
//
// Arguments:
//	PTNSLAVEINFO pSlave		Machine to check command/status.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::GetNextCmdForMachine(PTNSLAVEINFO pSlave)
{
	HRESULT				hr = S_OK;
	int					i;
	BOOL				fActiveTest = FALSE;
	PTNSLAVEINFO		pOtherSlave;
	PTNTESTINSTANCEM	pTestToUse = NULL;
	PTNTESTINSTANCEM	pTest = NULL;
	int					iTesterNum = -1;
	PTNTESTFROMFILE		pLoadedTest = NULL;



	DPL(7, "Getting next command for slave %x [%s, ID %u].",
		3, pSlave, pSlave->m_szComputerName, pSlave->m_id.dwTime);


	this->m_remainingtests.EnterCritSection();


#ifdef DEBUG
	if (this->m_dwMode == TNMODE_POKE)
	{
		DPL(0, "Getting next command in Poke mode!?", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (in Poke mode)

	if (! pSlave->m_fReadyToTest)
	{
		DPL(0, "%s is not ready to test!?", 1, pSlave->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (slave not ready)
#endif // DEBUG


	// If the user specified a specific number of testers expected, but the
	// session is still open (indicating that not enough slaves have joined
	// yet), then we should hold off from running anything yet.
	if ((this->m_dwMode == TNMODE_API) && (this->m_fJoinersAllowed))
	{
		DPL(0, "Can't start testing in API mode because the session is still open!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (slave limit but not reached)


	// If this guy currently has a test assignment, that's funky.
	if (pSlave->m_pCurrentTest != NULL)
	{
		DPL(0, "Getting command for %s but he still has an active test!  DEBUGBREAK()ing.",
			1, pSlave->m_szComputerName);
		DEBUGBREAK();
		hr = E_FAIL;
		goto DONE;
	} // end if (have active test)


	// Loop through all the slaves to see if they have a test that is
	// waiting for us.  
	for(i = 0; i < this->m_slaves.Count(); i++)
	{
		pOtherSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
		if (pOtherSlave == NULL)
		{
			DPL(0, "Couldn't get slave %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		// Skip the guy passed in.
		if (pOtherSlave == pSlave)
			continue;

		if (pOtherSlave->m_pCurrentTest != NULL)
		{
			fActiveTest = TRUE;

#pragma BUGBUG(vanceo, "What about ongoing tests?")

			// If this test hasn't started yet, and the passed in slave is
			// assigned to it...
			// we haven't found a test yet or
			// this test is earlier in the sequence than the last one we found
			// might be waiting for us.
			if ((! pOtherSlave->m_pCurrentTest->m_fStarted) &&
				(pOtherSlave->m_pCurrentTest->GetSlavesTesterNum(pSlave) >= 0))
			{
				if (pTestToUse == NULL)
				{
					DPL(2, "%s's current test %u (\"%s-%s\") is waiting for %s.",
						5, pOtherSlave->m_szComputerName,
						pOtherSlave->m_pCurrentTest->m_dwUniqueID,
						pOtherSlave->m_pCurrentTest->m_pCase->m_pszID,
						pOtherSlave->m_pCurrentTest->m_pLoadedTest->m_pszInstanceID,
						pSlave->m_szComputerName);

					pOtherSlave->m_pCurrentTest->m_dwRefCount++; // we're using it
					pTestToUse = pOtherSlave->m_pCurrentTest;
				} // end if (first test found)
				else if (pOtherSlave->m_pCurrentTest->m_dwUniqueID < pTestToUse->m_dwUniqueID)
				{
					DPL(2, "%s's current test %u (\"%s-%s\") is waiting for %s, using instead of later test %u.",
						6, pOtherSlave->m_szComputerName,
						pOtherSlave->m_pCurrentTest->m_dwUniqueID,
						pOtherSlave->m_pCurrentTest->m_pCase->m_pszID,
						pOtherSlave->m_pCurrentTest->m_pLoadedTest->m_pszInstanceID,
						pSlave->m_szComputerName,
						pTestToUse->m_dwUniqueID);

					// Free up our previous reference
					pTestToUse->m_dwRefCount--;
					if (pTestToUse->m_dwRefCount == 0)
					{
						DPL(1, "Deleting test %x!?",
							1, pTestToUse->m_dwRefCount);
						delete (pTestToUse);
					} // end if (should delete object)

					pOtherSlave->m_pCurrentTest->m_dwRefCount++; // we're using it
					pTestToUse = pOtherSlave->m_pCurrentTest;
				} // end else if (earlier than current test)
				else
				{
					DPL(5, "%s's current test %u (\"%s-%s\") is waiting for %s, but it's after test %u.",
						6, pOtherSlave->m_szComputerName,
						pOtherSlave->m_pCurrentTest->m_dwUniqueID,
						pOtherSlave->m_pCurrentTest->m_pCase->m_pszID,
						pOtherSlave->m_pCurrentTest->m_pLoadedTest->m_pszInstanceID,
						pSlave->m_szComputerName,
						pTestToUse->m_dwUniqueID);
				} // end else (later than current test)
			} // end if (test hasn't started yet and uses slave)
		} // end if (he's working on something)
	} // end for (each slave)


	if ((fActiveTest) && (pTestToUse == NULL))
	{
		DPL(1, "There are active tests, but none are waiting for %s.",
			1, pSlave->m_szComputerName);
	} // end if (active tests)


	if (this->m_dwMode == TNMODE_API)
	{
RECHECK:

		// Loop through all the remaining tests to find the first one assigned
		// to us.
		for(i = 0; i < this->m_remainingtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCEM) this->m_remainingtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get test item %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)


			// If the test involves the current guy, this may be the one we want.
			if (pTest->GetSlavesTesterNum(pSlave) >= 0)
			{
				if (pTestToUse == NULL)
				{
					DPL(2, "%s is assigned to remaining test %u (\"%s-%s\").",
						4, pSlave->m_szComputerName,
						pTest->m_dwUniqueID,
						pTest->m_pCase->m_pszID,
						pTest->m_pLoadedTest->m_pszInstanceID);

					pTest->m_dwRefCount++; // we're using it
					pTestToUse = pTest;
				} // end if (first test found)
				else if (pTest->m_dwUniqueID < pTestToUse->m_dwUniqueID)
				{
					DPL(2, "%s is assigned to remaining test %u (\"%s-%s\"), using instead of later test %u.",
						5, pSlave->m_szComputerName,
						pTest->m_dwUniqueID,
						pTest->m_pCase->m_pszID,
						pTest->m_pLoadedTest->m_pszInstanceID,
						pTestToUse->m_dwUniqueID);

					// Free up our previous reference
					pTestToUse->m_dwRefCount--;
					if (pTestToUse->m_dwRefCount == 0)
					{
						DPL(1, "Deleting test %x!?",
							1, pTestToUse->m_dwRefCount);
						delete (pTestToUse);
					} // end if (should delete object)

					pTest->m_dwRefCount++; // we're using it
					pTestToUse = pTest;
				} // end else if (earlier than current test)
				else
				{
					DPL(5, "%s is assigned to remaining test %u (\"%s-%s\"), but it's after test %u.",
						5, pSlave->m_szComputerName,
						pTest->m_dwUniqueID,
						pTest->m_pCase->m_pszID,
						pTest->m_pLoadedTest->m_pszInstanceID,
						pTestToUse->m_dwUniqueID);
				} // end else (later than current test)

				// Even if it's not the lowest test, we still stop searching because
				// the remaining tests list is in test ID order, so there can't be
				// any tests assigned to this slave later in the list that have
				// earlier test IDs.
				break;
			} // end if (found one we want)

			DPL(9, "%s is not involved in remaining test %u (\"%s-%s\"), skipping.",
				4, pSlave->m_szComputerName,
				pTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID,
				pTest->m_pLoadedTest->m_pszInstanceID);
		} // end for (each test)


		// If we didn't find any more tests for this guy, he's done.
		if (pTestToUse == NULL)
		{
			DPL(0, "%s has completed all tests for him (for this pass).",
				1, pSlave->m_szComputerName);


			// Check to see if all testing for this pass is done.
			if (this->m_remainingtests.Count() == 0)
			{
				if (fActiveTest)
				{
					DPL(1, "Active tests remain, %s will wait for those to complete.",
						1, pSlave->m_szComputerName);
				} // end if (there's an active test)
				else
				{
					DPL(0, "Test list for repetition completed, notifying all slaves.", 0);

#pragma TODO(vanceo, "Think of way to prevent this from being sent when testing is just starting")

					// Loop through all the slaves and tell them that the
					// repetition is complete.
					for(i = 0; i < this->m_slaves.Count(); i++)
					{
						pOtherSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
						if (pOtherSlave == NULL)
						{
							DPL(0, "Couldn't get slave %i!", 1, i);
							hr = E_FAIL;
							goto DONE;
						} // end if (couldn't get slave)

						hr = this->SendTestingStatusMessageTo(pOtherSlave,
															CTRLTS_REPETITIONCOMPLETE);
						if (hr != S_OK)
						{
							if (hr != TNERR_CONNECTIONDROPPED)
							{
								DPL(0, "Couldn't send repetition complete message to %s!",
									1, pOtherSlave->m_szComputerName);

								goto DONE;
							} // end if (the error isn't because he's already gone)
							else
							{
								DPL(0, "Not sending repetition complete message to %s because he's gone.",
									1, pOtherSlave->m_szComputerName);
								hr = S_OK;
							} // end else (the slave is already gone)
						} // end if (couldn't get send teststatus message)
					} // end for (each slave in session)


#pragma BUGBUG(vanceo, "Make freeing output vars after repetition an option?")

					// Free any output vars we accumulated from the last repetition.
					hr = this->FreeOutputVarsAndData(NULL, NULL, NULL, NULL, NULL);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't free all output vars and data from last repetition!", 0);
						goto DONE;
					} // end if (couldn't free all output vars)



					// Check to see if all the repetitions are done, too.
					if (this->m_loadedtests.Count() == 0)
					{
						DPL(0, "No more tests or repetitions for %s to run, telling him he's complete.",
							1, pSlave->m_szComputerName);

						hr = this->SendTestingStatusMessageTo(pSlave, CTRLTS_ALLCOMPLETE);
						if (hr != S_OK)
						{
							if (hr != TNERR_CONNECTIONDROPPED)
							{
								DPL(0, "Couldn't send all testing complete message to %s!",
									1, pSlave->m_szComputerName);

								goto DONE;
							} // end if (the error isn't because he's already gone)
							else
							{
								DPL(0, "Not sending all testing complete message to %s because he's gone.",
									1, pSlave->m_szComputerName);
								hr = S_OK;
							} // end else (the slave is already gone)
						} // end if (couldn't get send teststatus message)

						goto DONE;
					} // end if (no reps left either)


					// If we got here, there are more repetitions left.  We need to
					// rebuild the test list for another pass.
					hr = this->BuildAPITestList();
					if (hr != S_OK)
					{
						DPL(0, "Couldn't rebuild API test list for another pass!", 0);
						goto DONE;
					} // end if (couldn't build test list)


					// If we tried to repopulate the list, but didn't get any valid
					// permutations, we're done.  BuildAPITestList should have also
					// noticed this and removed any additional repetitions from the
					// list.
					if (this->m_remainingtests.Count() == 0)
					{
						DPL(0, "WARNING: Didn't build any valid permutations from test list!  Telling %s he is complete.",
							1, pSlave->m_szComputerName);

#ifdef DEBUG
						if (this->m_loadedtests.Count() > 0)
						{
							DPL(0, "Still %i loaded tests in list!?  DEBUGBREAK()-ing.",
								1, this->m_loadedtests.Count());

							DEBUGBREAK();
						} // end if (still loaded tests in list)
#endif // DEBUG

						hr = this->SendTestingStatusMessageTo(pSlave, CTRLTS_ALLCOMPLETE);
						if (hr != S_OK)
						{
							if (hr != TNERR_CONNECTIONDROPPED)
							{
								DPL(0, "Couldn't send testing complete message to %s!",
									1, pSlave->m_szComputerName);

								goto DONE;
							} // end if (the error isn't because he's already gone)
							else
							{
								DPL(0, "Not sending testing complete message to %s because he's gone.",
									1, pSlave->m_szComputerName);
								hr = S_OK;
							} // end else (the slave is already gone)
						} // end if (couldn't get send teststatus message)

						goto DONE;
					} // end if (no items in list)

					// We successfully repopulated the list, so we need to recheck
					// for things to do.
					goto RECHECK;
				} // end else (there aren't any active tests)
			} // end if (nothing left in the pass)

			goto DONE;
		} // end if (didn't find any tests)
	} // end if (in API mode)
	else
	{
		CTNTestFromFilesList	untriedloadedtests;
		CTNTestMsList			permutations;
		int						iMaxNumPermutations;


#ifdef DEBUG
		if (this->m_dwMode != TNMODE_STRESS)
		{
			DPL(0, "In some wacky mode %u!", 1, this->m_dwMode);
			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (not in stress mode)
#endif // DEBUG


		if (pTestToUse == NULL)
		{
			if (this->m_loadedtests.Count() <= 0)
			{
				DPL(0, "WARNING: No more loaded tests, unable to build untried list!", 0);
			} // end if (no more loaded tests)


			// Copy the list of loaded tests.
			for(i = 0; i < this->m_loadedtests.Count(); i++)
			{
				pLoadedTest = (PTNTESTFROMFILE) this->m_loadedtests.GetItem(i);
				if (pLoadedTest == NULL)
				{
					DPL(0, "Couldn't get loaded test %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get test)

				hr = untriedloadedtests.Add(pLoadedTest);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add loaded test %i to temp list!", 1, i);
					goto DONE;
				} // end if (couldn't add loaded test to temp list)
			} // end for (each loaded test)


			// Keep looping until we've attempted every loaded test.
			while (untriedloadedtests.Count() > 0)
			{
#pragma BUGBUG(vanceo, "Need the more-random algorithm")
				i = rand() % untriedloadedtests.Count();


				DPL(8, "Picking untried loaded test index %i (%i total).",
					2, i, untriedloadedtests.Count());


				pLoadedTest = (PTNTESTFROMFILE) untriedloadedtests.GetItem(i);
				if (pLoadedTest == NULL)
				{
					DPL(0, "Couldn't get loaded test %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get item)

				pLoadedTest->m_dwRefCount++; // we're using it

				hr = untriedloadedtests.Remove(i);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't remove loaded test \"%s-%s\" from remaining untried list!",
						2, pLoadedTest->m_pCase->m_pszID,
						pLoadedTest->m_pszInstanceID);
					goto DONE;
				} // end if (couldn't remove item)


				hr = this->BuildTestPermutationsList(pLoadedTest, &permutations,
													&iMaxNumPermutations);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't build permutations of \"%s-%s\"!",
						2, pLoadedTest->m_pCase->m_pszID,
						pLoadedTest->m_pszInstanceID);
					goto DONE;
				} // end if (couldn't add loaded test to temp list)

				// If there aren't any valid permutations and the session is closed
				// skip the test, since there won't ever be any valid permutations.
				if ((permutations.Count() <= 0) && (! this->m_fJoinersAllowed))
				{
					DPL(0, "WARNING: Test \"%s-%s\" was skipped because there aren't any valid permutations and the session is closed!",
						2, pLoadedTest->m_pCase->m_pszID, pLoadedTest->m_pszInstanceID);


					// Take it out of the main list so it won't ever be tried
					// again.
					hr = this->m_loadedtests.RemoveFirstReference(pLoadedTest);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't remove loaded test %x from loadedtests list!",
							1, pLoadedTest);
						goto DONE;
					} // end if (couldn't remove test from list)


#pragma TODO(vanceo, "What if there aren't any more runnable tests?  Need to end session like in API mode")
					if (this->m_loadedtests.Count() <= 0)
					{
						DPL(0, "WARNING: No more loaded tests!", 0);
					} // end if (no more loaded tests)


					// We're going to build a fake test so we can add a report
					// without adding a whole bunch of special case code.
					// Hee hee, isn't this special case code?

					pTest = new (CTNTestInstanceM)(this->m_dwCurrentUniqueID++,
													pLoadedTest,
													pLoadedTest->m_pCase,
													1,
													//0,
													NULL);
					if (pTest == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate object)

					hr = this->m_skippedtests.Add(pTest);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add test %x to skipped list!", 1, pTest);
						goto DONE;
					} // end if (couldn't add item)


					// Add the skipped test report.
					hr = this->m_reports.AddReport(RT_TESTSKIPPED, 0, NULL,
													pTest, 0, NULL, 0);
					if (hr != S_OK)
					{
						DPL(0, "Failed to add skip report to list!", 0);
						goto DONE;
					} // end if (failed add report)


					pTest = NULL;


					// If we are doing the auto-report thing, and the report we just added is
					// one of the ones we are counting, check to see if that pushed us over the
					// limit.
					if ((this->m_iAutoReportNumReports > 0) &&
						(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
					{
						hr = this->DoAutoReport();
						if (hr != S_OK)
						{
							DPL(0, "Couldn't auto-report!", 0);
							goto DONE;
						} // end if (couldn't print reports)
					} // end if (auto reporting is on and this was a matching report type)
				} // end if (no valid permuations)


				// Keep looping until we've attempted every permutation.
				while (permutations.Count() > 0)
				{
#pragma BUGBUG(vanceo, "Need the more-random algorithm")
					i = rand() % permutations.Count();


					DPL(8, "Picking permutation index %i (%i total).",
						2, i, permutations.Count());


					pTestToUse = (PTNTESTINSTANCEM) permutations.GetItem(i);
					if (pTestToUse == NULL)
					{
						DPL(0, "Couldn't get permutation %i!", 1, i);
						hr = E_FAIL;
						goto DONE;
					} // end if (couldn't get item)

					pTestToUse->m_dwRefCount++; // we're using it

					hr = permutations.Remove(i);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't remove permutation %x from permutations list!",
							1, pTestToUse);
						goto DONE;
					} // end if (couldn't remove item)


					// If this permutation involves us, use it.
					if (pTestToUse->GetSlavesTesterNum(pSlave) >= 0)
					{
						// Assign it a unique ID.
						pTestToUse->m_dwUniqueID = this->m_dwCurrentUniqueID++;

						// Decrement the reps for the loaded test that generated
						// this permutation.  Take it off the list if necessary.
						if (pLoadedTest->m_dwRepsRemaining == 1)
						{
							hr = this->m_loadedtests.RemoveFirstReference(pLoadedTest);
							if (hr != S_OK)
							{
								DPL(0, "Couldn't remove loaded test %x (\"%s-%s\") from loaded tests list!",
									3, pLoadedTest,
									pLoadedTest->m_pCase->m_pszID,
									pLoadedTest->m_pszInstanceID);
								goto DONE;
							} // end if (couldn't add loaded test to temp list)
						} // end if (last repetition for item)
						else
						{
							// If not infinite reps, decrement the number of reps
							// remaining, but regardless, keep it in the list.
							if (pLoadedTest->m_dwRepsRemaining != 0)
								pLoadedTest->m_dwRepsRemaining--;
						} // end else (not last repetition for item)

						// Get out of the permutation while loop.
						break;
					} // end if (found permutation for us)


					// Otherwise, we don't care about this permutation.  Keep looping.
					pTestToUse->m_dwRefCount--;
					if (pTestToUse->m_dwRefCount == 0)
					{
						DPL(7, "Deleting permutation %x.", 1, pTestToUse);
						delete (pTestToUse);
					} // end if (should delete object)
					else
					{
						DPL(7, "Not deleting permutation %x, its refcount is %u.",
							2, pTestToUse, pTestToUse->m_dwRefCount);
					} // end if (should delete object)
					pTestToUse = NULL;
				} // end while (still permutations left to check)


				// We don't care about the loaded test anymore.
				pLoadedTest->m_dwRefCount--;
				if (pLoadedTest->m_dwRefCount == 0)
				{
					DPL(7, "Deleting loaded test %x.", 1, pLoadedTest);
					delete (pLoadedTest);
				} // end if (should delete object)
				else
				{
					DPL(7, "Not deleting loaded test %x, its refcount is %u.",
						2, pLoadedTest, pLoadedTest->m_dwRefCount);
				} // end if (should delete object)
				pLoadedTest = NULL;


				// If found a test to use, stop looping.
				if (pTestToUse != NULL)
					break;
			} // end while (still untried items left)
		} // end if (didn't find active test to run)


		// If we didn't find any test to run, then we're done here.  If there
		// aren't any active tests, and nobody can join the session, then this
		// slave is done.
		if (pTestToUse == NULL)
		{
			if (fActiveTest)
			{
				DPL(1, "Active tests remain, %s will wait for those to complete.",
					1, pSlave->m_szComputerName);
			} // end if (there's an active test)
			else
			{
				// If nobody else can join the session, the permutations won't
				// change, so this guy will never be able to run another test.
				if (! this->m_fJoinersAllowed)
				{
					DPL(0, "No more tests or repetitions for %s to run, telling him he's complete.",
						1, pSlave->m_szComputerName);

					hr = this->SendTestingStatusMessageTo(pSlave, CTRLTS_ALLCOMPLETE);
					if (hr != S_OK)
					{
						if (hr != TNERR_CONNECTIONDROPPED)
						{
							DPL(0, "Couldn't send testing complete message to %s!",
								1, pSlave->m_szComputerName);

							goto DONE;
						} // end if (the error isn't because he's already gone)
						else
						{
							DPL(0, "Not sending testing complete message to %s because he's gone.",
								1, pSlave->m_szComputerName);
							hr = S_OK;
						} // end else (the slave is already gone)
					} // end if (couldn't get send teststatus message)
				} // end if (no joiners allowed)
				else
				{
					DPL(1, "No more tests or repetitions for %s to run, but joiners are still allowed so he will wait.",
						1, pSlave->m_szComputerName);
				} // end else (joiners allowed)
			} // end else (no active tests)
			
			goto DONE;
		} // end if (didn't find test to run)
	} // end else (in stress mode)


	// If we got here, pTestToUse holds the test he should do next.

	iTesterNum = pTestToUse->GetSlavesTesterNum(pSlave);

	pTestToUse->m_dwRefCount++;
	pSlave->m_pCurrentTest = pTestToUse;


	hr = this->AssignSlaveToTest(pSlave, pTestToUse, iTesterNum, FALSE, TRUE, NULL, 0);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't assign non-placeholder for %s (tester %i) to test %u!",
			3, pSlave->m_szComputerName, iTesterNum, pTestToUse->m_dwUniqueID);
		goto DONE;
	} // end if (couldn't assign slave to test)



DONE:

	if (pLoadedTest != NULL)
	{
		pLoadedTest->m_dwRefCount--;
		if (pLoadedTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting still held loaded test %x.", 1, pLoadedTest);
			delete (pLoadedTest);
		} // end if (should delete object)
		else
		{
			DPL(7, "Not deleting still held loaded test %x, its refcount is %u.",
				2, pLoadedTest, pLoadedTest->m_dwRefCount);
		} // end if (should delete object)
		pLoadedTest = NULL;
	} // end if (still have loaded test)

	if (pTestToUse != NULL)
	{
		pTestToUse->m_dwRefCount--;
		if (pTestToUse->m_dwRefCount == 0)
		{
			DPL(7, "Deleting test to use %x.", 1, pTestToUse);
			delete (pTestToUse);
		} // end if (should delete object)
		else
		{
			DPL(7, "Not deleting test to use %x, its refcount is %u.",
				2, pTestToUse, pTestToUse->m_dwRefCount);
		} // end if (should delete object)
		pTestToUse = NULL;
	} // end if (have test to use)

	this->m_remainingtests.LeaveCritSection();

	return (hr);
} // CTNMaster::GetNextCmdForMachine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::AssignSlaveToTest()"
//==================================================================================
// CTNMaster::AssignSlaveToTest
//----------------------------------------------------------------------------------
//
// Description: Assigns the slave to the given test (if he wasn't already), and adds
//				a report about the assignment.
//				If that's the last assignment needed for the test, then the slave is
//				notified that he can begin testing it.
//				If fPlaceholder is TRUE, then the slave's slot is filled, but it
//				doesn't initiate any testing, 
//				If fGetInputData is TRUE, then the module's GetInputData callback
//				will be used to retrieve the input data to send to the slave, if it
//				exists.  If fGetInputData is FALSE and pvInputData is not NULL, then
//				this data will be recorded as what the slave is using for it's input
//				data.
//				The slave list lock is assumed to be held.
//
// Arguments:
//	PTNSLAVEINFO pSlave			Slave to assign.
//	PTNTESTINSTANCEM pTest		Test to assign slave to.
//	int iTesterNum				Tester slot to assign slave to.
//	BOOL fPlaceholder			TRUE if this assignment is a placeholder, FALSE if
//								slave is assigning self.
//	BOOL fGetInputData			Should we try to retrieve input data for the slave?
//	PVOID pvInputData			Pointer to input data the slave is already using, if
//								any.
//	DWORD dwInputDataSize		Size of input data the slave is already using, if
//								any.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::AssignSlaveToTest(PTNSLAVEINFO pSlave, PTNTESTINSTANCEM pTest,
									int iTesterNum, BOOL fPlaceholder,
									BOOL fGetInputData, PVOID pvInputData,
									DWORD dwInputDataSize)
{
	HRESULT				hr = S_OK;
	int					i;
	PTNSLAVEINFO*		paTempTestersArray = NULL;
	TNGETINPUTDATA		tngid;
	int					iNumSelfAssigns = 0;
	CTNSendDataQueue	bufferedsends;
	PTNSENDDATA			pSendData = NULL;


	ZeroMemory(&tngid, sizeof (TNGETINPUTDATA));


	if (pTest->m_paTesterSlots[iTesterNum].pSlave != NULL)
	{
		if (pTest->m_paTesterSlots[iTesterNum].pSlave != pSlave)
		{
			DPL(0, "Can't use %s to fill tester slot %i of test %u, it's already filled by %s!",
				4, pSlave->m_szComputerName, iTesterNum, pTest->m_dwUniqueID,
				pTest->m_paTesterSlots[iTesterNum].pSlave->m_szComputerName);
			hr = E_FAIL;
			goto DONE;
		} // end if (already complete)

		if (pTest->m_paTesterSlots[iTesterNum].fComplete)
		{
			DPL(0, "Can't refill tester slot %i of test %u with %s because it's marked as complete!",
				3, iTesterNum, pTest->m_dwUniqueID, pSlave->m_szComputerName);
			hr = E_FAIL;
			goto DONE;
		} // end if (already complete)

		DPL(6, "Refilling tester slot %i of test %u with%s%s.",
			4, iTesterNum,
			pTest->m_dwUniqueID,
			(fPlaceholder ? " placeholder for " : " "),
			pSlave->m_szComputerName);
	} // end if (slot already full)
	else
	{
		DPL(3, "Filling tester slot %i of test %u with%s%s.",
			4, iTesterNum,
			pTest->m_dwUniqueID,
			(fPlaceholder ? " placeholder for " : " "),
			pSlave->m_szComputerName);

		pSlave->m_dwRefCount++; // it's going to be in the slot
		pTest->m_paTesterSlots[iTesterNum].pSlave = pSlave;
	} // end else (slot not full)

	// If it's a placeholder, we're done.
	if (fPlaceholder)
		goto DONE;


	if (pTest->m_paTesterSlots[iTesterNum].dwAssignTime)
	{
		DPL(0, "%s is assigning self to tester %i of test %u, but it was already not a placeholder!",
			3, pSlave->m_szComputerName, iTesterNum, pTest->m_dwUniqueID);

		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (already filled self)

	pTest->m_paTesterSlots[iTesterNum].dwAssignTime = GetTickCount();


	// Loop through all the testers to see if this is the last person
	// assigning himself.
	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
		// If this slot has been "self-filled" note that.
		if (pTest->m_paTesterSlots[i].dwAssignTime != 0)
			iNumSelfAssigns++;
	} // end for (each tester)


	// If we're the only people self-filled as of now...
	if (iNumSelfAssigns == 1)
	{
		DPL(1, "%s has first self-assignment for test ID %u.",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);

		// If we're in API mode, and it's a top level test, then remove it from
		// the list of remaining items since we're starting it.
		if ((this->m_dwMode == TNMODE_API) &&
			(pTest->m_pParentTest == NULL))
		{
			hr = this->m_remainingtests.RemoveFirstReference(pTest);
			if (hr != S_OK)
			{
				DPL(0, "Failed to remove test %x from remaining tests list!",
					1, pTest);
				goto DONE;
			} // end if (failed removing references to test)
		} // end if (API mode)
	} // end if (first tester assigned)


	// If we can't retrieve input data (because we may be getting handed it),
	// we can add the assignment report now (along with the data).  If not,
	// we're going to wait until we're actually ready to retrieve and send the
	// input data to add the report.
	// The only time input data should be retrievable on the master is when
	// assigning a API or stress mode top level test.
	if (! fGetInputData)
	{
		// If there's no parent test, then it is a test, otherwise a subtest
		// report.
		hr = this->m_reports.AddReport(((pTest->m_pParentTest == NULL) ? RT_TESTASSIGNED : RT_TESTASSIGNED_SUBTEST),
									1, &(pTest->m_paTesterSlots[iTesterNum].pSlave),
									pTest,
									0,
									pvInputData,
									dwInputDataSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add test assignment report!", 0);
			this->m_remainingtests.LeaveCritSection();
			goto DONE;
		} // end if (failed to add report)


		// If we are doing the auto-report thing, and the report we just added is
		// one of the ones we are counting, check to see if that pushed us over the
		// limit.
		if ((this->m_iAutoReportNumReports > 0) &&
			(this->m_dwAutoReportFlags & TNREPORT_TESTASSIGNMENTSTESTNOTCOMPLETE))
		{
			hr = this->DoAutoReport();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't auto-report!", 0);
				goto DONE;
			} // end if (couldn't print reports)
		} // end if (auto reporting is on and this was a matching report type)
	} // end if (can't get input data)
#ifdef DEBUG
	else
	{
		if (pTest->m_pParentTest != NULL)
		{
			DPL(0, "Able to get input data for a subtest (ID %u)!?",
				1, pTest->m_dwUniqueID);

			DEBUGBREAK();

			hr = E_FAIL;
			goto DONE;
		} // end if (not a top level test)

		if (this->m_dwMode == TNMODE_POKE)
		{
			DPL(0, "Able to get input data for a test in poke mode!?", 0);

			DEBUGBREAK();

			hr = E_FAIL;
			goto DONE;
		} // end if (in Poke mode)
	} // end else (can get input data) 
#endif // DEBUG


	// If we're not the last person to self-fill, we're done.
	if (iNumSelfAssigns != pTest->m_iNumMachines)
		goto DONE;


	DPL(1, "%s has last self-assignment for test ID %u.",
		2, pSlave->m_szComputerName, pTest->m_dwUniqueID);



	if (pTest->m_fStarted)
	{
		DPL(0, "Starting test %s (unique ID %u) twice!?",
			2, pTest->m_pCase->m_pszID, pTest->m_dwUniqueID);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're starting this test twice)

	// Hey, the test is now going.
	pTest->m_fStarted = TRUE;



	// Loop through all the testers.
	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
		// If we can get input data, try to do it now.  Also add the test
		// report since we couldn't before, too.
		if (fGetInputData)
		{
			if (pTest->m_pCase->m_pfnGetInputData != NULL)
			{
				tngid.dwSize = sizeof (TNGETINPUTDATA);
				tngid.pMaster = this;
				tngid.pMachine = pTest->m_paTesterSlots[i].pSlave;
				tngid.iTesterNum = i;
				tngid.pTest = pTest->m_pCase;
				tngid.pStringData = pTest->m_pLoadedTest->m_pStoredDataList;
				//tngid.pvData = NULL;
				//tngid.dwDataSize = 0;

				hr = pTest->m_pCase->m_pfnGetInputData(&tngid);
				if (hr != ERROR_BUFFER_TOO_SMALL)
				{
					DPL(0, "Module's GetInputData function for case \"%s\" didn't return ERROR_BUFFER_TOO_SMALL!  %e",
						2, pTest->m_pCase->m_pszID, hr);

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (get input data failed)

				
				tngid.pvData = LocalAlloc(LPTR, tngid.dwDataSize);
				if (tngid.pvData == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				//tngid.dwDataSize = tngid.dwDataSize;

				hr = pTest->m_pCase->m_pfnGetInputData(&tngid);
				if (hr != S_OK)
				{
					DPL(0, "Module's GetInputData callback for case \"%s\" failed!",
						1, pTest->m_pCase->m_pszID);
					goto DONE;
				} // end if (module's callback failed)
			} // end if (the test can get input data)


			hr = this->m_reports.AddReport(RT_TESTASSIGNED,
										1, &(pTest->m_paTesterSlots[i].pSlave),
										pTest,
										0,
										tngid.pvData,
										tngid.dwDataSize);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add test assignment report!", 0);
				this->m_remainingtests.LeaveCritSection();
				goto DONE;
			} // end if (failed to add report)


			// If we are doing the auto-report thing, and the report we just added
			// is one of the ones we are counting, check to see if that pushed us
			// over the limit.
			if ((this->m_iAutoReportNumReports > 0) &&
				(this->m_dwAutoReportFlags & TNREPORT_TESTASSIGNMENTSTESTNOTCOMPLETE))
			{
				hr = this->DoAutoReport();
				if (hr != S_OK)
				{
					DPL(0, "Couldn't auto-report!", 0);
					goto DONE;
				} // end if (couldn't print reports)
			} // end if (auto reporting is on and this was a matching report type)
		} // end if (can get input data)



		// Now actually send the message out to the person.  If it's an unprompted
		// test, send the whole shebang to him.  If the slave was the one telling
		// us about the test, we only need to send a small part of the information.
		// If we retrieved any input data, we'll send that.
		if (pTest->m_paTesterSlots[i].dwAnnounceRequestID == 0)
		{
			hr = this->SendNewTestMessageTo(pTest->m_paTesterSlots[i].pSlave,
											pTest,
											tngid.pvData,
											tngid.dwDataSize,
											&bufferedsends);
			if (hr != S_OK)
			{
				if (hr != TNERR_CONNECTIONDROPPED)
				{
					DPL(0, "Couldn't get send new test message to machine %s!",
						1, pSlave->m_szComputerName);
				} // end if (the error isn't because he's already gone)
				else
				{
					DPL(0, "Not sending new test message to %s because he's gone.",
						1, pSlave->m_szComputerName);
					hr = S_OK;
				} // end else (the slave is already gone)
			} // end if (couldn't get send teststatus message)
		} // end if (not a response to a slave's request)
		else
		{
			hr = this->SendAnnounceTestReplyMessageTo(pTest->m_paTesterSlots[i].pSlave,
													pTest->m_paTesterSlots[i].dwAnnounceRequestID,
													pTest->m_dwUniqueID,
													&bufferedsends);
			if (hr != S_OK)
			{
				if (hr != TNERR_CONNECTIONDROPPED)
				{
					DPL(0, "Couldn't get send announce test reply message to machine %s!",
						1, pSlave->m_szComputerName);
					goto DONE;
				} // end if (not because connectiondropped)
				else
				{
					DPL(0, "WARNING: Connection to %s dropped, not sending announce test reply message!",
						1, pSlave->m_szComputerName);
					hr = S_OK;
				} // end else (connection dropped)
			} // end if (couldn't send announcetestreply message)

			// Clear the slot so it can be used again
			pTest->m_paTesterSlots[i].dwAnnounceRequestID = 0;
		} // end else (is a response to a slave's request)


		// If we retrieved input data, reset it.
		if (tngid.pvData != NULL)
		{
			LocalFree(tngid.pvData);
			tngid.pvData = NULL;
			tngid.dwDataSize = 0;
		} // end if (got input data)
	} // end for (each tester)


	DPL(3, "Test %u (\"%s\") has been completely assigned (%i testers).",
		3, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
		pTest->m_iNumMachines);


	paTempTestersArray = (PTNSLAVEINFO*) LocalAlloc(LPTR, (pTest->m_iNumMachines * sizeof (PTNSLAVEINFO)));
	if (paTempTestersArray == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	
	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
		paTempTestersArray[i] = pTest->m_paTesterSlots[i].pSlave;
	} // end for (each machine))

	// Add the report that that was the last person notified about the test
	hr = this->m_reports.AddReport(RT_TESTCOMPLETELYASSIGNED,
								pTest->m_iNumMachines,
								paTempTestersArray,
								pTest,
								0, NULL, 0);

	LocalFree(paTempTestersArray);
	paTempTestersArray = NULL;

	if (hr != S_OK)
	{
		DPL(0, "Couldn't add test assignment completion report!", 0);
		goto DONE;
	} // end if (failed to add report)


	// If we are doing the auto-report thing, and the report we just added is
	// one of the ones we are counting, check to see if that pushed us over the
	// limit.
	if ((this->m_iAutoReportNumReports > 0) &&
		(this->m_dwAutoReportFlags & TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTNOTCOMPLETE))
	{
		hr = this->DoAutoReport();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-report!", 0);
			goto DONE;
		} // end if (couldn't print reports)
	} // end if (auto reporting is on and this was a matching report type)


	// Now actually allow the notification messages we queued up to be sent.
	while (bufferedsends.Count() > 0)
	{
		pSendData = (PTNSENDDATA) bufferedsends.PopFirstItem();
		if (pSendData == NULL)
		{
			DPL(0, "Couldn't pop first buffered send!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't pop first item)

		// We don't actually need our refcount, but we won't delete it, we
		// just add it to the real send queue.
		pSendData->m_dwRefCount--;

#ifdef DEBUG
		if (pSendData->m_dwRefCount != 0)
		{
			DPL(0, "Refcount on buffered send %x is not 0 as expected (its %u)!",
				2, pSendData, pSendData->m_dwRefCount);

			DEBUGBREAK();
		} // end if (refcount is funky)
#endif // DEBUG

		hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add buffered send data %x to queue!", 0);

			delete (pSendData);
			pSendData = NULL;

			goto DONE;
		} // end if (couldn't add send data)
	} // end for (each item)


DONE:

	if (tngid.pvData != NULL)
	{
		LocalFree(tngid.pvData);
		tngid.pvData = NULL;
	} // end if (we allocated data)

	if (paTempTestersArray != NULL)
	{
		LocalFree(paTempTestersArray);
		paTempTestersArray = NULL;
	} // end if (we allocated an array)

	return (hr);
} // CTNMaster::AssignSlaveToTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CompleteSlavesTest()"
//==================================================================================
// CTNMaster::CompleteSlavesTest
//----------------------------------------------------------------------------------
//
// Description: Completes the given test that the slave is working on.  Logs the
//				final report if that was the last slave needed to complete.
//				If not in Poke mode, this was not a sub or ongoing test, and this is
//				the last slave to complete, then the next command for each of the
//				testers is retrieved, if it's appropriate (not Poke mode, not dead,
//				etc.).
//				If the slave is working on a subtest, then it is completed with
//				the same success parameter as well.
//				The slave lock is assumed to be held.
//
// Arguments:
//	PTNSLAVEINFO pSlave		Slave completing the test.
//	PTNTESTINSTANCEM pTest	Test being completed.
//	BOOL fSuccess			Whether its a successful completion or not.
//	BOOL fSubTest			Whether the test was a subtest.
//	BOOL fOngoing			Whether the test was ongoing.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::CompleteSlavesTest(PTNSLAVEINFO pSlave, PTNTESTINSTANCEM pTest,
									BOOL fSuccess, BOOL fSubTest, BOOL fOngoing)
{
	HRESULT					hr = S_OK;
	HRESULT					hrFinalResult = S_OK;
	PTNTESTINSTANCEM		pSubTest = NULL;
	BOOL					fFinalSuccess = FALSE;
	PTNSUCCESSFILTERITEM	paTesterResults = NULL;
	PTNSLAVEINFO*			paTempTestersArray = NULL;
	PVOID					pvFinalCompleteReportData = NULL;
	DWORD					dwFinalCompleteReportDataSize = 0;
	DWORD					dwReportType;
	int						i;
	int						j;
	int						iTesterNum;
	char*					pszTemp = NULL;
	PTNSLAVEINFO			pOtherSlave = NULL;
	BOOL					fAdded = FALSE;


	DPL(9, "==>(%x [%s], %x [%u], %B, %B, %B)",
		7, pSlave, pSlave->m_szComputerName, pTest, pTest->m_dwUniqueID,
		fSuccess, fSubTest, fOngoing);


	// Make sure we hold on to it so no one deletes it behind our backs.
	//BUGBUG doesn't completely work, since we need the lock to do this
	pTest->m_dwRefCount++;


	if (! pTest->m_fStarted)
	{
		DPL(0, "WARNING: Completing test %u for %s, even though it hasn't started.",
			2, pTest->m_dwUniqueID, pSlave->m_szComputerName);
	} // end if (test not started)


	// If there are any subtests involving the slave, complete them too.
	for(i = 0; i < pTest->m_subtests.Count(); i++)
	{
		pSubTest = (PTNTESTINSTANCEM) pTest->m_subtests.GetItem(i);
		if (pSubTest == NULL)
		{
			DPL(0, "Couldn't get subtest %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		pSubTest->m_dwRefCount++;

#pragma BUGBUG(vanceo, "How do we notify poke testers of lost top level guy during request?")
		// If the test hasn't started, we don't care about it.
		if (pSubTest->m_fStarted)
		{
			iTesterNum = pSubTest->GetSlavesTesterNum(pSlave);

			// If the slave is assigned to this subtest, and the slave hasn't
			// already completed it, force him to complete it if it started,
			// or alert the other waiting testers if it hasn't.
			if ((iTesterNum >= 0) &&
				(! pSubTest->m_paTesterSlots[iTesterNum].fComplete))
			{
				DPL(1, "Forcing completion of %s (subtester %i)'s subtest ID %u.",
					3, pSlave->m_szComputerName, iTesterNum,
					pSubTest->m_dwUniqueID);

				hr = this->CompleteSlavesTest(pSlave, pSubTest, fSuccess, TRUE, FALSE);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't complete %s's subtest ID %u!",
						2, pSlave->m_szComputerName, pSubTest->m_dwUniqueID);
					goto DONE;
				} // end if (couldn't complete subtest)
			} // end if (the slave was working on the sub test)
		} // end if (the test has started)

		pSubTest->m_dwRefCount--;
		if (pSubTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting subtest %x.", 1, pSubTest);
			delete (pSubTest);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting subtest %x, its refcount is %u.",
				2, pSubTest, pSubTest->m_dwRefCount);
		} // end else (no last reference)
		pSubTest = NULL;
	} // end for (each sub test)


	iTesterNum = pTest->GetSlavesTesterNum(pSlave);
	if (iTesterNum < 0)
	{
		DPL(0, "%s isn't working on test %u!?", 2, pSlave->m_szComputerName,
			pTest->m_dwUniqueID);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (not working on test)


	// Remove any failed sync operations started by the slave.
	if (pTest->m_pSyncDataList != NULL)
	{
		PTNSYNCDATA		pSyncData;


		pTest->m_pSyncDataList->EnterCritSection();

		for(i = 0; i < pTest->m_pSyncDataList->Count(); i++)
		{
			pSyncData = (PTNSYNCDATA) pTest->m_pSyncDataList->GetItem(i);
			if (pSyncData == NULL)
			{
				DPL(0, "Couldn't get sync data item %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)

			// If it's a non-placeholder item for the tester, remove the data.
			if ((pSyncData->m_iTesterNum == iTesterNum) &&
				(pSyncData->m_pSyncList != NULL))
			{
				delete (pSyncData->m_pSyncList);
				pSyncData->m_pSyncList = NULL;
			} // end if (it's a non-placeholder for the right tester)
		} // end for (each sync item)

		pTest->m_pSyncDataList->LeaveCritSection();
	} // end if (there are sync data items)



	// When the guy is done with a test, we need to fire LostTester messages
	// at anybody left in the test.  If they're doing something that requires
	// him to be there, they'll abort it.  Otherwise, they'll ignore it.
	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
		// Skip the current completer.
		if (i == iTesterNum)
			continue;

		// If this current tester isn't a placeholder and hasn't already
		// completed the test, notify him of the dead slave.
		if ((pTest->m_paTesterSlots[i].dwAssignTime != 0) &&
			(! pTest->m_paTesterSlots[i].fComplete))
		{
			DPL(1, "Sending LostTester message to %s because of completion for test ID %u by %s.",
				3, pTest->m_paTesterSlots[i].pSlave->m_szComputerName,
				pTest->m_dwUniqueID, pSlave->m_szComputerName);

			hr = this->SendLostTesterTo(pTest->m_paTesterSlots[i].pSlave,
										pTest, iTesterNum);
			if (hr != S_OK)
			{
				if (hr != TNERR_CONNECTIONDROPPED)
				{
					DPL(0, "Failed to send LostTester message to %s!",
						1, pTest->m_paTesterSlots[i].pSlave->m_szComputerName);
					goto DONE;
				} // end if (not connectiondropped)
				else
				{
					DPL(0, "WARNING: Not sending LostTester message to %s because he's gone!",
						1, pTest->m_paTesterSlots[i].pSlave->m_szComputerName);
					hr = S_OK;
				} // end else (connection dropped)
			} // end if (failed to send message)
		} // end if (this tester has not completed yet)
	} // end if (for each other tester)


	if (pTest->m_paTesterSlots[iTesterNum].dwAssignTime == 0)
	{
		DPL(8, "Test %u only has placeholder for %s (tester %i).",
			3, pTest->m_dwUniqueID, pSlave->m_szComputerName, iTesterNum);
		goto DONE;
	} // end if (placeholder)


	pTest->m_paTesterSlots[iTesterNum].fComplete = TRUE;
	pTest->m_paTesterSlots[iTesterNum].fSuccess = fSuccess;


	if (! fSubTest)
	{
		if (fOngoing)
		{
			hr = pSlave->m_ongoingtestslist.RemoveFirstReference(pTest);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't pull test unique ID %u from slave %s's ongoing list!",
					2, pTest->m_dwUniqueID, pSlave->m_szComputerName);
				goto DONE;
			} // end if (couldn't remove the test from the list)


			if (pTest->m_dwRefCount == 0)
			{
				DPL(0, "Ongoing test (%x) refcount hit 0?", 1, pTest);

				hr = E_FAIL;
				goto DONE;
			} // end if (should delete test)
		} // end if (this is an ongoing test)
		else
		{
			// If this was the reporter's current test, clear it.

			pSlave->m_pCurrentTest->m_dwRefCount--;
			if (pSlave->m_pCurrentTest->m_dwRefCount == 0)
			{
				DPL(0, "Current test (%x) refcount hit 0?",
					1, pSlave->m_pCurrentTest);

				hr = E_FAIL;
				goto DONE;
			} // end if (should delete test)

			pSlave->m_pCurrentTest = NULL;
		} // end if (it's not an ongoing test)
	} // end if (it's not a subtest)
	else
	{
		// We can't remove it here, only the last subtest completion can get
		// rid of it.  Otherwise, testers still working on it will get
		// unrecognized test type problems when they report, sync, etc.
	} // end else (it's a subtest)


	paTempTestersArray = (PTNSLAVEINFO*) LocalAlloc(LPTR, (pTest->m_iNumMachines * sizeof (PTNSLAVEINFO)));
	if (paTempTestersArray == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// If there's a FilterSuccess callback, build an array for it.
	if (pTest->m_pCase->m_pfnFilterSuccess != NULL)
	{
		paTesterResults = (PTNSUCCESSFILTERITEM) LocalAlloc(LPTR, (pTest->m_iNumMachines * sizeof (TNSUCCESSFILTERITEM)));
		if (paTesterResults == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
	} // end if (there's a FilterSuccess callback)


	// It only takes one failed complete to consider the test a failure.  This
	// is the default value, but the module's FilterSuccess callback may adjust
	// this.
	fFinalSuccess = TRUE;

	// Loop through all the testers.  If someone else hasn't completed the test
	// yet, we're not the last one.
	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
#ifdef DEBUG
		if (pTest->m_paTesterSlots[i].pSlave == NULL)
		{
			DPL(0, "Test slot %i for test %u hasn't been assigned yet?!",
				2, i, pTest->m_dwUniqueID);
			hr = E_FAIL;
			goto DONE;
		} // end if (slot is not assigned)
#endif // DEBUG

		if (! pTest->m_paTesterSlots[i].fComplete)
		{
			// Well, someone hasn't completed it yet, so we're finished with
			// this function.
			DPL(8, "Tester %i (%s) hasn't completed test %u yet, not final completion.",
				3, i, pTest->m_paTesterSlots[i].pSlave->m_szComputerName,
				pTest->m_dwUniqueID);
			goto DONE;
		} // end if (not done yet)

		// If even one completion was a failure, the whole thing is.
		if (! pTest->m_paTesterSlots[i].fSuccess)
			fFinalSuccess = FALSE;

		paTempTestersArray[i] = pTest->m_paTesterSlots[i].pSlave;

		// If there's a FilterSuccess callback, populate the corresponding
		// array entry.
		if (pTest->m_pCase->m_pfnFilterSuccess != NULL)
		{
			paTesterResults[i].pSlave = pTest->m_paTesterSlots[i].pSlave;
			paTesterResults[i].hresult = pTest->m_paTesterSlots[i].hresult;
			paTesterResults[i].fSuccess = pTest->m_paTesterSlots[i].fSuccess;
			paTesterResults[i].pvOutputData = pTest->m_paTesterSlots[i].pvOutputData;
			paTesterResults[i].dwOutputDataSize = pTest->m_paTesterSlots[i].dwOutputDataSize;
			paTesterResults[i].pVars = pTest->m_paTesterSlots[i].pVars;
		} // end if (there's a FilterSuccess callback)
	} // end for (each tester)



	DPL(0, "That completed %sest with unique ID %u.",
		2, ((fSubTest) ? "subt" : "t"), pTest->m_dwUniqueID);


	// If the test is a subtest, we couldn't remove it above, so we do it here.
	if (fSubTest)
	{
		hr = pTest->m_pParentTest->m_subtests.RemoveFirstReference(pTest);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't pull test unique ID %u from test %u's subtest list!",
				1, pTest->m_dwUniqueID, pTest->m_pParentTest);
			goto DONE;
		} // end if (couldn't remove the test from the list)

		if (pTest->m_dwRefCount == 0)
		{
			DPL(0, "Subtest (%x) refcount hit 0?", 1, pTest);

			hr = E_FAIL;
			goto DONE;
		} // end if (should delete test)
	} // end if (subtest)


	if (pTest->m_pCase->m_pfnFilterSuccess != NULL)
	{
		TNFILTERSUCCESSDATA		tnfsd;


		ZeroMemory(&tnfsd, sizeof (TNFILTERSUCCESSDATA));
		tnfsd.dwSize = sizeof (TNFILTERSUCCESSDATA);
		tnfsd.hresult = hrFinalResult;
		tnfsd.fSuccess = fFinalSuccess;
		tnfsd.iNumMachines = pTest->m_iNumMachines;
		tnfsd.aTesterResults = paTesterResults;
		//tnfsd.pvData = NULL;
		//tnfsd.dwDataSize = 0;

		hr = pTest->m_pCase->m_pfnFilterSuccess(&tnfsd);
		if (hr == ERROR_BUFFER_TOO_SMALL)
		{
			dwFinalCompleteReportDataSize = tnfsd.dwDataSize;
			pvFinalCompleteReportData = LocalAlloc(LPTR, dwFinalCompleteReportDataSize);
			if (pvFinalCompleteReportData == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			tnfsd.pvData = pvFinalCompleteReportData;

			// Try again with the new report data buffer.
			hr = pTest->m_pCase->m_pfnFilterSuccess(&tnfsd);
		} // end if (need to allocate a data buffer)

		if (hr != S_OK)
		{
			DPL(0, "Module's FilterSuccess callback failed!", 0);
			goto DONE;
		} // end if (module's filter success callback failed)

		if (fFinalSuccess != tnfsd.fSuccess)
		{
			if (fFinalSuccess)
			{
				DPL(0, "All testers reported success for test %u (case \"%s\"), but module's FilterSuccess callback considers it a failure.",
					2, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID);
				fFinalSuccess = FALSE;
			} // end if (it was changed from a success)
			else
			{
				DPL(0, "Module tried to change a failed test case (\"%s\", unique ID %u) into a success!",
					2, pTest->m_pCase->m_pszID, pTest->m_dwUniqueID);
				hr = E_FAIL;
				goto DONE;
			} // end else (it was changed from a failure)
		} // end if (callback changed result)

		hrFinalResult = tnfsd.hresult;
	} // end if (there's a FilterSuccess callback)



	// Free any failed syncs left in the test.
	if (pTest->m_pSyncDataList != NULL)
	{
		delete (pTest->m_pSyncDataList);
		pTest->m_pSyncDataList = NULL;
	} // end if (there are sync operations still)



	// If we're not supposed to save results, remove the results from any
	// subtests we invoked.
	// See below.
	if (pTest->m_pTestsToFree != NULL)
	{
		while (pTest->m_pTestsToFree->Count() > 0)
		{
			pSubTest = (PTNTESTINSTANCEM) pTest->m_pTestsToFree->PopFirstItem();
			if (pSubTest == NULL)
			{
				DPL(0, "Couldn't pop first subtest to free from list!", 0);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't pop first item)


			// Pull it off the vars list.  We're going to ignore errors,
			// because it may have been removed by some other means, like
			// the user explicitly calling a FreeOutputVars function.
			hr = this->m_testswithvars.RemoveFirstReference(pSubTest);
			if (hr != S_OK)
			{
				DPL(4, "Couldn't remove subtest %u (under test %u) from tests with vars list, ignoring.  %e",
					3, pSubTest->m_dwUniqueID, pTest->m_dwUniqueID,
					hr);

				hr = S_OK;
			} // end if (remove first reference failed)


			// Loop through all the slots and free any output vars or data.
			for(i = 0; i < pTest->m_iNumMachines; i++)
			{
				// If there are variables, there must be data, and there
				// should never be data but no vars.
				if (pTest->m_paTesterSlots[i].pVars != NULL)
				{
					delete (pTest->m_paTesterSlots[i].pVars);
					pTest->m_paTesterSlots[i].pVars = NULL;

					LocalFree(pTest->m_paTesterSlots[i].pvOutputData);
					pTest->m_paTesterSlots[i].pvOutputData = NULL;
					pTest->m_paTesterSlots[i].dwOutputDataSize = 0;
				} // end if (there's output vars)
			} // end for (each tester)


			// Take off the ref given by PopFirstItem.
			pSubTest->m_dwRefCount--;
			if (pSubTest->m_dwRefCount == 0)
			{
				DPL(7, "Deleting subtest %x.", 1, pSubTest);
				delete (pSubTest);
			} // end if (should delete test)
			else
			{
				DPL(7, "Not deleting subtest %x, its refcount is %u.",
					2, pSubTest, pSubTest->m_dwRefCount);
			} // end else (shouldn't delete test)
			pSubTest = NULL;
		} // end while (still more tests to free)


		// We don't need the list object any more.
		delete (pTest->m_pTestsToFree);
		pTest->m_pTestsToFree = NULL;
	} // end if (we shouldn't save results)



	// Loop through all the tester slots looking for output data.  If there's
	// output data but no variables, there's no way the module (master side)
	// can retrieve the data again, we might as well free it up.  If we're
	// not saving results for this test, we will free any data we find.
	// Otherwise, we want to save this test so the variables can be accessed
	// later.  But only save only one alias to the test.
	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
		if (pTest->m_paTesterSlots[i].pvOutputData != NULL)
		{
			if (pTest->m_paTesterSlots[i].pVars != NULL)
			{
				if (pTest->m_pCase->m_dwOptionFlags & TNTCO_DONTSAVERESULTS)
				{
					delete (pTest->m_paTesterSlots[i].pVars);
					pTest->m_paTesterSlots[i].pVars = NULL;
				} // end if (shouldn't save results)
				else if (! fAdded)
				{
					// Add this test to our list of items to save.
					hr = this->m_testswithvars.Add(pTest);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add alias to test %x to testswithvars list!",
							1, pTest);
						goto DONE;
					} // end if (couldn't add alias)

					// We only want to add it to the list once.
					fAdded = TRUE;
				} // end else if (haven't added this test already)
			} // end if (there are output vars)

			// If there weren't any variables, or we just freed them,
			// free the output data, too.
			if (pTest->m_paTesterSlots[i].pVars == NULL)
			{
				LocalFree(pTest->m_paTesterSlots[i].pvOutputData);
				pTest->m_paTesterSlots[i].pvOutputData = NULL;
				pTest->m_paTesterSlots[i].dwOutputDataSize = 0;
			} // end if (no output vars)
		} // end if (there's output data)
	} // end for (each tester)
	

	// If this test had some variables & was added to the list, and it's a
	// subtest, check to see if any of the parent tests specified that results
	// were not to be saved.  If so, we need to register with that test so it
	// can remove our results when it completes.
	// See above.
	if ((fAdded) && (fSubTest))
	{
		PTNTESTINSTANCEM	pParentTest;


		pParentTest = pTest->m_pParentTest;
		do
		{
			if (pParentTest->m_pTestsToFree != NULL)
			{
				// Add it to that parent's list of tests with data to free
				// when it completes.
				hr = pParentTest->m_pTestsToFree->Add(pTest);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add test %u to parent (%u)'s list of tests to free!",
						2, pTest->m_dwUniqueID, pParentTest->m_dwUniqueID);
					goto DONE;
				} // end if (couldn't add test)

				// We found one, so we can stop searching.
				break;
			} // end if (parent test shouldn't save results)

			pParentTest = pParentTest->m_pParentTest;
		} // end do (while there's a parent test)
		while (pParentTest != NULL);
	} // end else (possibly should save results)


	if (fFinalSuccess)
	{
		if (fSubTest)
			dwReportType = RT_SUCCESSCOMPLETE_SUBTEST;
		else
			dwReportType = RT_SUCCESSCOMPLETE;
	} // end if (there weren't any failurecompletions)
	else
	{
		if (fSubTest)
			dwReportType = RT_FAILURECOMPLETE_SUBTEST;
		else
			dwReportType = RT_FAILURECOMPLETE;
	} // end else (there was at least one failurecompletion)


	// Add the completion report.  This was originally based on whether everyone
	// succeeded or at least one person failed, but the module could have
	// overridden it with the FilterSuccess function.
	// Also pass the list of machines involved in the test and any data the
	// FilterSuccess function may have allocated.
	hr = this->m_reports.AddReport(dwReportType,
								pTest->m_iNumMachines,
								paTempTestersArray,
								pTest,
								hrFinalResult,
								pvFinalCompleteReportData,
								dwFinalCompleteReportDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add report to list!", 0);
		goto DONE;
	} // end if (failed add report)


	// If we are doing the auto-report thing, and the report we just added is one
	// of the ones we are counting, check to see if that pushed us over the limit.
	if ((this->m_iAutoReportNumReports > 0) &&
		((fFinalSuccess) &&
			(this->m_dwAutoReportFlags & (TNREPORT_TESTSUCCESSES | TNREPORT_TESTASSIGNMENTSTESTSUCCEEDED | TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTSUCCEEDED))) ||
		((! fFinalSuccess) &&
			(this->m_dwAutoReportFlags & (TNREPORT_TESTFAILURES | TNREPORT_TESTASSIGNMENTSTESTFAILED | TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTFAILED))))
	{
		hr = this->DoAutoReport();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-report!", 0);
			goto DONE;
		} // end if (couldn't print reports)
	} // end if (auto reporting is on and this was a matching report type)


	// Update statistics for the test, and the global statistics if it's
	// not a subtest.
	if (fFinalSuccess)
	{
		if (! fSubTest)
			this->m_totalstats.IncrementSuccesses();

		pTest->m_pCase->m_stats.IncrementSuccesses();
	} // end if (its a success report)
	else
	{
		if (! fSubTest)
			this->m_totalstats.IncrementFailures();

		pTest->m_pCase->m_stats.IncrementFailures();
	} // end else (its a failure report)

	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update stats event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update stats event)


	// Poke mode doesn't automatically request next command.
	if (this->m_dwMode == TNMODE_POKE)
		goto DONE;

	// Subtests and ongoing tests don't request next commands.
	if ((fSubTest) || (fOngoing))
		goto DONE;


	DPL(3, "Getting next commands for any other slaves without current tests.", 0);


	// Loop through all the slaves still in the session with nothing to do
	// and try to get them working on something.
	for(i = 0; i < this->m_slaves.Count(); i++)
	{
		pOtherSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
		if (pOtherSlave == NULL)
		{
			DPL(0, "Couldn't get slave %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		if (pOtherSlave->m_pCurrentTest != NULL)
		{
			DPL(5, "Slave %s is currently working on test %u, not retrieving next command.",
				2, pOtherSlave->m_szComputerName,
				pOtherSlave->m_pCurrentTest->m_dwUniqueID);

			continue;
		} // end if (slave is working on something)

		this->m_jobs.EnterCritSection();

		// If it's not the completing slave, we should make sure there isn't
		// a GETNEXTCMD for the slave already in the queue.  We don't bother
		// checking the current slave since there should not be one in the
		// queue (however, for DEBUG builds we'll double check to make sure
		// that's the case).
#ifdef DEBUG
		if (pOtherSlave != pSlave)
#endif // DEBUG
		{
			PTNJOB	pJob;
			BOOL	fFound;


			fFound = FALSE;

			for(j = 0; j < this->m_jobs.Count(); j++)
			{
				pJob = (PTNJOB) this->m_jobs.GetItem(j);
				if (pJob == NULL)
				{
					DPL(0, "Couldn't get job %i!", 1, j);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get item)

				// If we found a GETNEXTCMD job, and it's for this slave,
				// note that this slave should be skipped.
				if ((pJob->m_dwOperation == TNMJ_GETNEXTCMD) &&
					(memcmp(&(pJob->m_idSlave), &(pOtherSlave->m_id), sizeof (TNCTRLMACHINEID)) == 0))
				{
					DPL(2, "Found GETNEXTCMD job for %s (ID %u) already, not adding another one.",
						2, pOtherSlave->m_szComputerName,
						pOtherSlave->m_id.dwTime);
					fFound = TRUE;
					break;
				} // end if (get next command operation)
			} // end for (each job)

			if (fFound)
			{
#ifdef DEBUG
				if (pOtherSlave == pSlave)
				{
					DPL(0, "Found GETNEXTCMD job for current completing slave %s (ID %u)!?  DEBUGBREAK()-ing.",
						2, pSlave->m_szComputerName, pSlave->m_id.dwTime);
					DEBUGBREAK();
				} // end if (it's this current slave)
#endif // DEBUG

				this->m_jobs.LeaveCritSection();
				continue; // skip this slave
			} // end if (found job already)
		} // end if (current slave isn't the completer)

		hr = this->m_jobs.AddJob(TNMJ_GETNEXTCMD, 0, &(pOtherSlave->m_id), NULL);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add GetNextCmd job for %s!",
				1, pOtherSlave->m_szComputerName);

			this->m_jobs.LeaveCritSection();

			goto DONE;
		} // end if (couldn't add job)

		this->m_jobs.LeaveCritSection();
	} // end for (each tester)


DONE:

	if (pTest->m_dwRefCount == 0xFFFFFFFF)
	{
		DPL(0, "Refcount for test %x is screwed!", 1, pTest);
		DEBUGBREAK();
	} // end if (refcount is screwed)

	pTest->m_dwRefCount--;
	if (pTest->m_dwRefCount == 0)
	{
		DPL(0, "WARNING: Nuking the test object %x!?", 1, pTest);
		delete (pTest);
		pTest = NULL;
	}  // end if (that was the last reference)

	if (paTempTestersArray != NULL)
	{
		LocalFree(paTempTestersArray);
		paTempTestersArray = NULL;
	} // end if (allocated array)

	if (paTesterResults != NULL)
	{
		LocalFree(paTesterResults);
		paTesterResults = NULL;
	} // end if (allocated array)

	if (pvFinalCompleteReportData != NULL)
	{
		LocalFree(pvFinalCompleteReportData);
		pvFinalCompleteReportData = NULL;
	} // end if (allocated data)

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNMaster::CompleteSlavesTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::KillSlave()"
//==================================================================================
// CTNMaster::KillSlave
//----------------------------------------------------------------------------------
//
// Description: Kills the specified slave (adding report, completing tests, etc.).
//				The slave list lock is assumed to be held.
//				It is assumed to be called within the Job thread.
//
// Arguments:
//	PTNSLAVEINFO pSlave		Slave to kill.
//	DWORD dwKillReason		Reason slave is being killed.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::KillSlave(PTNSLAVEINFO pSlave, DWORD dwKillReason)
{
	HRESULT				hr;
	int					i;
	int					j;
	PTNSLAVEINFO		pOtherSlave = NULL;
	PTNTESTINSTANCEM	pTest;
	CTNSlavesList		affectedslaves;
	CTNTestMsList		affectedtests;



	DPL(9, "==>(%x [%s], %u)",
		3, pSlave, pSlave->m_szComputerName, dwKillReason);


	DPL(1, "Killing %s, reason = %u.",
		2, pSlave->m_szComputerName, dwKillReason);


	// Flush the send queue
	hr = this->m_pCtrlComm->FlushSendQueue();
	if (hr != S_OK)
	{
		DPL(0, "Flushing control method send queue failed!", 0);
		goto DONE;
	} // end if (flushing send queue failed)


	// Disconnect him (if he wasn't already).
	hr = this->m_pCtrlComm->UnbindDataFromAddress(&(pSlave->m_commdata));
	if (hr != S_OK)
	{
		DPL(0, "WARNING: Couldn't unbind slave %s's data/address!  Ignoring.  %e",
			2, pSlave->m_szComputerName, hr);
		//hr = S_OK;
	} // end if (couldn't unbind data from address)

	// Pull the slave from the session list.
	hr = this->m_slaves.RemoveFirstReference(pSlave);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove %s from slave list!",
			1, pSlave->m_szComputerName);
		goto DONE;
	} // end if (couldn't remove slave)

	// Add him to the list of dropped slaves.
	hr = this->m_droppedslaves.Add(pSlave);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add %s to dropped slave list!",
			1, pSlave->m_szComputerName);
		goto DONE;
	} // end if (couldn't add slave)


	// Add the report for this
	hr = this->m_reports.AddReport(RT_REMOVEMACHINE,
									1, &pSlave,
									NULL,
									dwKillReason,
									NULL, 0);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add report to list!", 0);
		goto DONE;
	} // end if (failed add report)


	// If we are doing the auto-report thing, and the report we just added
	// is one of the ones we are counting, check to see if that pushed us
	// over the limit.
	if ((this->m_iAutoReportNumReports > 0) &&
		(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
	{
		hr = this->DoAutoReport();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-report!", 0);
			goto DONE;
		} // end if (couldn't print reports)
	} // end if (auto reporting is on and this was a matching report type)



	// If in API mode, all of the tests he's scheduled to work on should
	// be marked as skipped.
	if (this->m_dwMode == TNMODE_API)
	{
		this->m_remainingtests.EnterCritSection();
		for(i = 0; i < this->m_remainingtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCEM) this->m_remainingtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get remaining test %i!", 1, i);
				hr = E_FAIL;
				this->m_remainingtests.LeaveCritSection();
				goto DONE;
			} // end if (couldn't get item)

			if (pTest->GetSlavesTesterNum(pSlave) >= 0)
			{
				DPL(0, "WARNING: Remaining test %u has to be skipped because %s is now gone!",
					2, pTest->m_dwUniqueID, pSlave->m_szComputerName);


				hr = this->m_skippedtests.Add(pTest);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add test %x to skipped list!", 1, pTest);
					this->m_remainingtests.LeaveCritSection();
					goto DONE;
				} // end if (couldn't add item)


				// Add the skipped test report.
				hr = this->m_reports.AddReport(RT_TESTSKIPPED, 0, NULL,
												pTest, 0, NULL, 0);
				if (hr != S_OK)
				{
					DPL(0, "Failed to add skip report to list!", 0);
					this->m_remainingtests.LeaveCritSection();
					goto DONE;
				} // end if (failed add report)


				// If we are doing the auto-report thing, and the report
				// we just added is one of the ones we are counting,
				// check to see if that pushed us over the limit.
				if ((this->m_iAutoReportNumReports > 0) &&
					(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
				{
					hr = this->DoAutoReport();
					if (hr != S_OK)
					{
						DPL(0, "Couldn't auto-report!", 0);
						this->m_remainingtests.LeaveCritSection();
						goto DONE;
					} // end if (couldn't print reports)
				} // end if (auto reporting is on and this was a matching report type)


				// Pull it off the list.
				hr = this->m_remainingtests.Remove(i);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't remove remaining test %i (ID %u)!",
						2, i, pTest->m_dwUniqueID);
					this->m_remainingtests.LeaveCritSection();
					goto DONE;
				} // end if (couldn't remove test)

				// Make sure our counter doesn't get out of sync with the
				// adjusted list size.
				i--;
			} // end if (the slave would be working on this test)
		} // end for (each remaining test)
		this->m_remainingtests.LeaveCritSection();
	} // end if (in API mode)



	// Complete the slave's current test, if it exists.
	if (pSlave->m_pCurrentTest != NULL)
	{
		// We're using it.
		pSlave->m_pCurrentTest->m_dwRefCount++;
		pTest = pSlave->m_pCurrentTest;


		DPL(8, "Completing %s's current test (ID = %u).",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);


		// Complete the slave's current test with a failure
		hr = this->CompleteSlavesTest(pSlave, pTest, FALSE, FALSE, FALSE);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't complete %s's current test!",
				1, pSlave->m_szComputerName);
			goto DONE;
		} // end if (couldn't complete test)

		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting current test %x.", 1, pTest);
			delete (pTest);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting current test %x, its refcount is %u.",
				2, pTest, pTest->m_dwRefCount);
		} // end else (no last reference)
		pTest = NULL;
	} // end if (the slave's current test exists)


	// Complete all the slave's ongoing tests.
	do
	{
		pTest = (PTNTESTINSTANCEM) pSlave->m_ongoingtestslist.GetItem(0);
		if (pTest == NULL)
			break;

		pTest->m_dwRefCount++; // we're using it


		DPL(8, "Completing %s's ongoing test ID %u.",
			2, pSlave->m_szComputerName,
			pTest->m_dwUniqueID);

		// Complete the slave's current test with a failure
		hr = this->CompleteSlavesTest(pSlave, pTest, FALSE, FALSE, TRUE);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't one of complete %s's ongoing tests!",
				1, pSlave->m_szComputerName);
			goto DONE;
		} // end if (couldn't complete test)


		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting ongoing test %x.", 1, pTest);
			delete (pTest);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting ongoing test %x, its refcount is %u.",
				2, pTest, pTest->m_dwRefCount);
		} // end else (no last reference)
		pTest = NULL;
	} // end do (while there are ongoing tests)
	while (pTest != NULL);


	// Now we need to check to make sure nobody is sitting in a test
	// waiting for him to join.
	for(i = 0; i < this->m_slaves.Count(); i++)
	{
		pOtherSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
		if (pOtherSlave == NULL)
		{
			DPL(0, "Couldn't get other slave %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get slave)

		// If the slave has a current test that's not started and
		// the dropped slave is supposed to test it, we gotta change
		// that.
		if ((pOtherSlave->m_pCurrentTest != NULL) &&
			(! pOtherSlave->m_pCurrentTest->m_fStarted) &&
			(pOtherSlave->m_pCurrentTest->GetSlavesTesterNum(pSlave) >= 0))
		{
			for(j = 0; j < pOtherSlave->m_pCurrentTest->m_iNumMachines; j++)
			{
				// If it's the dropped slave, skip it.
				if (pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave == pSlave)
					continue;

				// If it's the current slave, skip it.
				if (pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave == pOtherSlave)
					continue;


				if (pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].dwAssignTime > 0)
				{
#ifdef DEBUG
					// If we've already handled this guy, something's screwy.
					if (affectedslaves.GetFirstIndex(pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave) >= 0)
					{
						DPL(0, "Already handled slave %s!?",
							1, pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave->m_szComputerName);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (already handled this guy)
#endif // DEBUG

					hr = affectedslaves.Add(pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add slave %x (%s) to affect list!",
							2, pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave,
							pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave->m_szComputerName);
						goto DONE;
					} // end if (couldn't add slave to list)

					// Reset the notification
					//pOtherSlave->m_pCurrentTest->m_paTesterSlots[k].dwAssignTime = 0;

#ifdef DEBUG
					if (pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave->m_pCurrentTest != pOtherSlave->m_pCurrentTest)
					{
						DPL(0, "Slave %s is not currently working on test %x (it's %x)!?",
							3, pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave->m_szComputerName,
							pOtherSlave->m_pCurrentTest,
							pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave->m_pCurrentTest);

						DEBUGBREAK();

						hr = ERROR_BAD_ENVIRONMENT;
						goto DONE;
					} // end if (current test doesn't match)
#endif // DEBUG

					// He's not working on it anymore
					pOtherSlave->m_pCurrentTest->m_paTesterSlots[j].pSlave->m_pCurrentTest = NULL;
					pOtherSlave->m_pCurrentTest->m_dwRefCount--;

					// Assuming refcount won't hit 0
				} // end if (this is not a placeholder)
			} // end for (each tester)

#ifdef DEBUG
			// If we've already handled this test, something's screwy.
			if (affectedtests.GetFirstIndex(pOtherSlave->m_pCurrentTest) >= 0)
			{
				DPL(0, "Already handled test %u!?",
					1, pOtherSlave->m_pCurrentTest->m_dwRefCount);

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (already handled this guy)
#endif // DEBUG

			hr = affectedtests.Add(pOtherSlave->m_pCurrentTest);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add test %x (%u) to affect list!",
					2, pOtherSlave->m_pCurrentTest,
					pOtherSlave->m_pCurrentTest->m_dwRefCount);
				goto DONE;
			} // end if (couldn't add test to list)

#ifdef DEBUG
			// If we've already handled this guy, something's screwy.
			if (affectedslaves.GetFirstIndex(pOtherSlave) >= 0)
			{
				DPL(0, "Already handled slave %s!?",
					1, pOtherSlave->m_szComputerName);

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (already handled this guy)
#endif // DEBUG

			hr = affectedslaves.Add(pOtherSlave);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add slave %x (%s) to affect list!",
					2, pOtherSlave, pOtherSlave->m_szComputerName);
				goto DONE;
			} // end if (couldn't add slave to list)

			// Reset the notification
			//pOtherSlave->m_pCurrentTest->m_paTesterSlots[pOtherSlave->m_pCurrentTest->GetSlavesTesterNum(pOtherSlave)].dwAssignTime = 0;


			// We're not working on it anymore
			pOtherSlave->m_pCurrentTest->m_dwRefCount--;
			pOtherSlave->m_pCurrentTest = NULL;

			// Assuming refcount won't hit 0

		} // end if (slave has a current test)
	} // end for (each slave)


	// Loop through all the affected slaves and reassign them to
	// new tests.
	while (affectedslaves.Count() > 0)
	{
		pOtherSlave = (PTNSLAVEINFO) affectedslaves.PopFirstItem();
		if (pOtherSlave == NULL)
		{
			DPL(0, "Couldn't get other slave %i!", 1, j);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get slave)

		if (this->m_dwMode == TNMODE_POKE)
		{
#pragma BUGBUG(vanceo, "What to do?  Notify of failure somehow?")
		} // end if (not in poke mode)
		else
		{
			DPL(0, "%s was affected by %s dropping, reassigning to new test.",
				2, pOtherSlave->m_szComputerName,
				pSlave->m_szComputerName);

			// We can call this directly instead of adding a job for it because
			// this function (KillSlave) should only be being called inside the
			// Job thread itself.
			hr = this->GetNextCmdForMachine(pOtherSlave);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't get next command for %s (affected by %s dropping)!",
					2, pOtherSlave->m_szComputerName,
					pSlave->m_szComputerName);
				goto DONE;
			} // end if (couldn't get next command)
		} // end else (not in poke mode)

		pOtherSlave->m_dwRefCount--;
		if (pOtherSlave->m_dwRefCount == 0)
		{
			DPL(0, "Slave %x (%s) refcount hit 0!?",
				2, pOtherSlave, pOtherSlave->m_szComputerName);

			DEBUGBREAK();

			delete (pOtherSlave);
			pOtherSlave = NULL;
		} // end if (refcount hit 0)
	} // end while (there are affected slaves left)


	// Loop through all the affected tests and mark them as skipped.
	while (affectedtests.Count() > 0)
	{
		pTest = (PTNTESTINSTANCEM) affectedtests.PopFirstItem();
		if (pTest == NULL)
		{
			DPL(0, "Couldn't get remaining test %i!", 1, j);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)


		DPL(0, "WARNING: Active test %u was affected by %s dropping, skipping it!",
			2, pTest->m_dwUniqueID, pSlave->m_szComputerName);


		hr = this->m_skippedtests.Add(pTest);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add test %x to skipped list!", 1, pTest);
			goto DONE;
		} // end if (couldn't add item)


		// Add the skipped test report.
		hr = this->m_reports.AddReport(RT_TESTSKIPPED, 0, NULL,
										pTest, 0, NULL, 0);
		if (hr != S_OK)
		{
			DPL(0, "Failed to add skip report to list!", 0);
			goto DONE;
		} // end if (failed add report)


		// If we are doing the auto-report thing, and the report
		// we just added is one of the ones we are counting,
		// check to see if that pushed us over the limit.
		if ((this->m_iAutoReportNumReports > 0) &&
			(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
		{
			hr = this->DoAutoReport();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't auto-report!", 0);
				goto DONE;
			} // end if (couldn't print reports)
		} // end if (auto reporting is on and this was a matching report type)

		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting test %x.", 1, pTest);
			delete (pTest);
		} // end if (should delete slave)
		else
		{
			DPL(7, "Not deleting test %x, refcount is %u.",
				2, pTest, pTest->m_dwRefCount);
		} // end else (shouldn't delete slave)
		pTest = NULL;
	} // end while (there are affected tests left)


DONE:

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNMaster::KillSlave
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CompleteAllTesting()"
//==================================================================================
// CTNMaster::CompleteAllTesting
//----------------------------------------------------------------------------------
//
// Description: Moves any tests left in the remaining test list into the skipped
//				list, adds the appropriate reports, and signals the user.
//				The test list lock is assumed to be held.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::CompleteAllTesting(void)
{
	HRESULT				hr = S_OK;
	HANDLE				hFile = INVALID_HANDLE_VALUE;
	int					i;
	PTNTESTINSTANCEM	pTest;
	PTNSLAVEINFO		pSlave;
	char				szTemp[1024];


	if (this->m_fTestingComplete)
	{
		DPL(0, "Testing already complete!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (testing already complete)

	while (this->m_remainingtests.Count() > 0)
	{
		pTest = (PTNTESTINSTANCEM) this->m_remainingtests.GetItem(0);
		if (pTest == NULL)
		{
			DPL(0, "Couldn't get first remaining test!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get first item)

		hr = this->m_remainingtests.RemoveFirstReference(pTest);
		if (hr != S_OK)
		{
			DPL(0, "Failed to remove first test from list!", 0);
			goto DONE;
		} // end if (failed add report)


		DPL(0, "WARNING: Test %u (case %s) was skipped!",
			2, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID);


		hr = this->m_skippedtests.Add(pTest);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add test %x to skipped list!", 1, pTest);
			goto DONE;
		} // end if (couldn't add item)


		// Add the skipped test report.
		hr = this->m_reports.AddReport(RT_TESTSKIPPED, 0, NULL,
										pTest, 0, NULL, 0);
		if (hr != S_OK)
		{
			DPL(0, "Failed to add skip report to list!", 0);
			goto DONE;
		} // end if (failed add report)


		// If we are doing the auto-report thing, and the report we just added is
		// one of the ones we are counting, check to see if that pushed us over the
		// limit.
		if ((this->m_iAutoReportNumReports > 0) &&
			(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
		{
			hr = this->DoAutoReport();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't auto-report!", 0);
				goto DONE;
			} // end if (couldn't print reports)
		} // end if (auto reporting is on and this was a matching report type)
	} // end while (there are still tests left)


	// If we're not in stress mode, having any items still in the repetition list is
	// bad.
	if ((this->m_loadedtests.Count()) && (this->m_dwMode != TNMODE_STRESS))
	{
		DPL(0, "WARNING: All testing finished but %i tests remain in repetition list!",
			1, this->m_loadedtests.Count());

		this->Log(TNLST_CRITICAL,
				"WARNING: All testing finished but %i test%sremain in repetition list!",
				2, this->m_loadedtests.Count(),
				((this->m_loadedtests.Count() == 1) ? " " : "s "));
	} // end if (still loaded tests)


	if ((this->m_skippedtests.Count() > 0) && 
		(this->m_pszSkippedTestsPath != NULL))
	{
		DPL(0, "Writing skipped tests list to %s",
			1, this->m_pszSkippedTestsPath);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Writing skipped tests list to %s",
				1, this->m_pszSkippedTestsPath);

		hr = FileCreateAndOpenFile(this->m_pszSkippedTestsPath, FALSE, TRUE,
									FALSE, &hFile);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't create and open file \"%s\"!",
				1, this->m_pszSkippedTestsPath);
			goto DONE;
		} // end if (couldn't create skipped file path)

		FileWriteLine(hFile, "//==================================================================================");
		StringGetCurrentDateStr(szTemp);
		FileSprintfWriteLine(hFile, "// Session %010u skipped tests, %s",
							2, this->m_dwSessionID, szTemp);
		FileWriteLine(hFile, "//==================================================================================");

		// Ignoring errors
		FileWriteLine(hFile, "[Info: SkippedTestsList]");


		for (i = 0; i < this->m_skippedtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCEM) this->m_skippedtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get skipped test %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get first item)

			hr = pTest->PrintToFile(hFile, TRUE, FALSE);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't get print test %x to file!", 1, pTest);
				goto DONE;
			} // end if (couldn't print to file)
		
			// Single space
			FileWriteLine(hFile, "");
		} // end for (each skipped test)

		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (should print skipped list file)


	if (this->m_slaves.Count() > 0)
	{
		DPL(0, "WARNING: Testing is complete but %i slaves remain!",
			1, this->m_slaves.Count());

		// Let all of the slaves know that testing is done, then remove them.
		do
		{
			pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(0);
			if (pSlave == NULL)
			{
				DPL(0, "Couldn't get slave %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)


			// If the slave is still working on a test, something's busted.
			if ((pSlave->m_pCurrentTest != NULL) ||
				(pSlave->m_ongoingtestslist.Count() > 0))
			{
				DPL(0, "%s is still working on a test!?",
					1, pSlave->m_szComputerName);
				hr = E_FAIL;
				goto DONE;
			} // end if (there are still tests)


			DPL(0, "Telling %s that testing is complete.",
				1, pSlave->m_szComputerName);


			// Send the message to him.
			hr = this->SendTestingStatusMessageTo(pSlave, CTRLTS_ALLCOMPLETE);
			if (hr != S_OK)
			{
				if (hr != TNERR_CONNECTIONDROPPED)
				{
					DPL(0, "Couldn't send testing complete message to %s!",
						1, pSlave->m_szComputerName);
					goto DONE;
				} // end if (the error isn't because he's already gone)
				else
				{
					DPL(0, "Not sending testing complete message to %s because he's gone.",
						1, pSlave->m_szComputerName);
					hr = S_OK;
				} // end else (the slave is already gone)
			} // end if (couldn't get send teststatus message)


			// Flush the send queue
			hr = this->m_pCtrlComm->FlushSendQueue();
			if (hr != S_OK)
			{
				DPL(0, "Flushing control method send queue failed!", 0);
				goto DONE;
			} // end if (flushing send queue failed)


			// Disconnect him (if he wasn't already).
			hr = this->m_pCtrlComm->UnbindDataFromAddress(&(pSlave->m_commdata));
			if (hr != S_OK)
			{
				DPL(0, "WARNING: Couldn't unbind slave %s's data/address!  Ignoring.",
					2, pSlave->m_szComputerName, hr);
				//hr = S_OK;
			} // end if (couldn't unbind data from address)


			// Pull the slave from the session list.
			hr = this->m_slaves.RemoveFirstReference(pSlave);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't remove %s from slave list!",
					1, pSlave->m_szComputerName);
				goto DONE;
			} // end if (couldn't remove slave)

			// Add him to the list of dropped slaves.
			hr = this->m_droppedslaves.Add(pSlave);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add %s to dropped slave list!",
					1, pSlave->m_szComputerName);
				goto DONE;
			} // end if (couldn't add slave)


			// Add the report for this.
			hr = this->m_reports.AddReport(RT_REMOVEMACHINE,
											1, &pSlave,
											NULL,
											RRM_DONETESTING,
											NULL, 0);
			if (hr != S_OK)
			{
				DPL(0, "Failed to add report to list!", 0);
				goto DONE;
			} // end if (failed add report)


			// If we are doing the auto-report thing, and the report we just added is
			// one of the ones we are counting, check to see if that pushed us over the
			// limit.
			if ((this->m_iAutoReportNumReports > 0) &&
				(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
			{
				hr = this->DoAutoReport();
				if (hr != S_OK)
				{
					DPL(0, "Couldn't auto-report!", 0);
					goto DONE;
				} // end if (couldn't print reports)
			} // end if (auto reporting is on and this was a matching report type)


			// Double check if we have to delete him.
			if (pSlave->m_dwRefCount == 0)
			{
				DPL(0, "Deleting slave %x (%s).", 2, pSlave, pSlave->m_szComputerName);
				delete (pSlave);
			} // end if (should delete slave)
			else
			{
				DPL(7, "Not deleting slave %x (%s), refcount is %u.",
					3, pSlave, pSlave->m_szComputerName, pSlave->m_dwRefCount);
			} // end else (shouldn't deleting slave)
			pSlave = NULL;
		} // end do (while still slaves left)
		while (this->m_slaves.Count() > 0);
	} // end if (there are slaves still)


	// Add the testing completion report.
	hr = this->m_reports.AddReport(RT_ALLTESTINGCOMPLETE, 0, NULL,
									NULL, 0, NULL, 0);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add testing completion report to list!", 0);
		goto DONE;
	} // end if (failed add report)


	// If we are doing the auto-report thing, and the report we just added is one
	// of the ones we are counting, check to see if that pushed us over the limit.
	if ((this->m_iAutoReportNumReports > 0) &&
		(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
	{
		hr = this->DoAutoReport();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-report!", 0);
			goto DONE;
		} // end if (couldn't print reports)
	} // end if (auto reporting is on and this was a matching report type)


	this->m_fTestingComplete = TRUE;


	DPL(0, "All testing complete.", 0);
	// Ignore error
	this->Log(TNLST_CONTROLLAYER_INFO, "All testing complete!", 0);

	if (this->m_skippedtests.Count() > 0)
	{
		DPL(0, "IMPORTANT: %u test%s skipped!",
			2, this->m_skippedtests.Count(),
			((this->m_skippedtests.Count() == 1) ? " was" : "s were"));
		// Ignore error
		this->Log(TNLST_CRITICAL, "IMPORTANT: %u test%s skipped!",
				2, this->m_skippedtests.Count(),
				((this->m_skippedtests.Count() == 1) ? " was" : "s were"));
	} // end if (there were tests skipped)

	if (this->m_totalstats.GetFailures() > 0)
	{
		DPL(0, "IMPORTANT: %u failure%soccurred (not including subtests)!",
			2, this->m_totalstats.GetFailures(),
			((this->m_totalstats.GetFailures() == 1) ? " " : "s "));
		// Ignore error
		this->Log(TNLST_CONTROLLAYER_TESTFAILURE, "IMPORTANT: %u failure%soccurred (not including subtests)!",
				2, this->m_totalstats.GetFailures(),
				((this->m_totalstats.GetFailures() == 1) ? " " : "s "));
	} // end if (there were failures)

	if (this->m_totalstats.GetWarnings() > 0)
	{
		DPL(0, "NOTE: %u warning%soccurred.",
			2, this->m_totalstats.GetWarnings(),
			((this->m_totalstats.GetWarnings() == 1) ? " " : "s "));
		// Ignore error
		this->Log(TNLST_CONTROLLAYER_TESTWARNING, "NOTE: %u warning%soccurred.",
				2, this->m_totalstats.GetWarnings(),
				((this->m_totalstats.GetWarnings() == 1) ? " " : "s "));
	} // end if (there were warnings)

	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update stats event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update stats event)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opened file)

	return (hr);
} // CTNMaster::CompleteAllTesting
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SendTestingStatusMessageTo()"
//==================================================================================
// CTNMaster::SendTestingStatusMessageTo
//----------------------------------------------------------------------------------
//
// Description: Sends the passed in machine a testing status message of the type
//				given.
//
// Arguments:
//	PTNSLAVEINFO pSlave		Slave to send to.
//	DWORD dwStatus			Status to send.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::SendTestingStatusMessageTo(PTNSLAVEINFO pSlave, DWORD dwStatus)
{
	HRESULT						hr;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_TESTINGSTATUS		pTestingStatusMsg = NULL;


	if (pSlave->m_commdata.fDropped)
	{
		DPL(0, "Can't send msg (status = %u) to %s because his connection has been dropped!",
			2, dwStatus, pSlave->m_szComputerName);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to slave is down)

	DPL(8, "Sending testing status message (status = %u) to %s.",
		2, dwStatus, pSlave->m_szComputerName);

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = pSlave->m_commdata.dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)
	CopyMemory(pSendData->m_pvAddress, pSlave->m_commdata.pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_TESTINGSTATUS);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pTestingStatusMsg = (PCTRLMSG_TESTINGSTATUS) pSendData->m_pvData;
	pTestingStatusMsg->dwSize = pSendData->m_dwDataSize;
	pTestingStatusMsg->dwType = CTRLMSGID_TESTINGSTATUS;
	pTestingStatusMsg->dwStatus = dwStatus;

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so we don't free it below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNMaster::SendTestingStatusMessageTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SendNewTestMessageTo()"
//==================================================================================
// CTNMaster::SendNewTestMessageTo
//----------------------------------------------------------------------------------
//
// Description: Instructs the passed in machine to the run the given test.
//
// Arguments:
//	PTNSLAVEINFO pSlave				Slave to send to.
//	PTNTESTINSTANCEM pTest			New test slave is supposed to run.
//	PVOID pvInputData				Pointer to input data to use.
//	DWORD dwInputDataSize			Size of input data to use.
//	PTNSENDDATAQUEUE pSendsBuffer	Queue to use to buffer up the messages.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::SendNewTestMessageTo(PTNSLAVEINFO pSlave, PTNTESTINSTANCEM pTest,
										PVOID pvInputData, DWORD dwInputDataSize,
										PTNSENDDATAQUEUE pSendsBuffer)
{
	HRESULT				hr;
	DWORD				dwCaseIDSize;
	DWORD				dwInstanceIDSize;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_NEWTEST	pNewTestMsg = NULL;
	LPBYTE				lpCurrent;
	int					i;


	if (pSlave->m_commdata.fDropped)
	{
		DPL(0, "Can't send msg (test %u, case \"%s\", instance \"%s\") to %s because his connection has been dropped!",
			4, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
			pTest->m_pLoadedTest->m_pszInstanceID,
			pSlave->m_szComputerName);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to slave is down)

	DPL(8, "Sending testing status message (test %u, case \"%s\", instance \"%s\") to %s.",
		4, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
		pTest->m_pLoadedTest->m_pszInstanceID,
		pSlave->m_szComputerName);

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = pSlave->m_commdata.dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)
	CopyMemory(pSendData->m_pvAddress, pSlave->m_commdata.pvAddress,
			pSendData->m_dwAddressSize);


	dwCaseIDSize = strlen(pTest->m_pCase->m_pszID) + 1;
	dwInstanceIDSize = strlen(pTest->m_pLoadedTest->m_pszInstanceID) + 1;

	pSendData->m_dwDataSize = sizeof (CTRLMSG_NEWTEST)
								+ dwCaseIDSize
								+ dwInstanceIDSize
								+ (pTest->m_iNumMachines * sizeof (TNCTRLMACHINEID))
								+ dwInputDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pNewTestMsg = (PCTRLMSG_NEWTEST) pSendData->m_pvData;
	pNewTestMsg->dwSize = pSendData->m_dwDataSize;
	pNewTestMsg->dwType = CTRLMSGID_NEWTEST;
	pNewTestMsg->dwUniqueTestID = pTest->m_dwUniqueID;
	pNewTestMsg->iNumMachines = pTest->m_iNumMachines;
	pNewTestMsg->dwInputDataSize = dwInputDataSize;

	lpCurrent = (LPBYTE) (pNewTestMsg + 1);

	CopyAndMoveDestPointer(lpCurrent, pTest->m_pCase->m_pszID, dwCaseIDSize);
	CopyAndMoveDestPointer(lpCurrent, pTest->m_pLoadedTest->m_pszInstanceID,
							dwInstanceIDSize);

	// Loop through each tester and copy array of IDs into message.
	for(i = 0; i < pTest->m_iNumMachines; i++)
	{
		CopyAndMoveDestPointer(lpCurrent,
								&(pTest->m_paTesterSlots[i].pSlave->m_id),
								sizeof (TNCTRLMACHINEID));
	} // end for (each tester)

	if (dwInputDataSize > 0)
	{
		//CopyAndMoveDestPointer(lpCurrent, pvInputData, dwInputDataSize);
		CopyMemory(lpCurrent, pvInputData, dwInputDataSize);
	} // end if (there's input data)

	hr = pSendsBuffer->Add(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to buffer queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so we don't free it below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNMaster::SendNewTestMessageTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SendAnnounceTestReplyMessageTo()"
//==================================================================================
// CTNMaster::SendAnnounceTestReplyMessageTo
//----------------------------------------------------------------------------------
//
// Description: Sends the passed in machine an announce test reply message using
//				the given response and unique test IDs.
//
// Arguments:
//	PTNSLAVEINFO pSlave				Slave to send to.
//	DWORD dwResponseID				Response ID to use.
//	DWORD dwUniqueTestID			Unique ID of test generated.
//	PTNSENDDATAQUEUE pSendsBuffer	Queue to use to buffer up the messages.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::SendAnnounceTestReplyMessageTo(PTNSLAVEINFO pSlave,
													DWORD dwResponseID,
													DWORD dwUniqueTestID,
													PTNSENDDATAQUEUE pSendsBuffer)
{
	HRESULT						hr;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_ANNOUNCETESTREPLY	pAnnounceTestReplyMsg = NULL;


	if (pSlave->m_commdata.fDropped)
	{
		DPL(0, "Can't send msg (rid = %u, tid = %u) to %s because his connection has been dropped!",
			3, dwResponseID,  dwUniqueTestID, pSlave->m_szComputerName);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to slave is down)

	DPL(8, "Sending announce test reply message (rid = %u, tid = %u) to %s.",
		3, dwResponseID, dwUniqueTestID, pSlave->m_szComputerName);

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = pSlave->m_commdata.dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)
	CopyMemory(pSendData->m_pvAddress, pSlave->m_commdata.pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_ANNOUNCETESTREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pAnnounceTestReplyMsg = (PCTRLMSG_ANNOUNCETESTREPLY) pSendData->m_pvData;
	pAnnounceTestReplyMsg->dwSize = pSendData->m_dwDataSize;
	pAnnounceTestReplyMsg->dwType = CTRLMSGID_ANNOUNCETESTREPLY;
	pAnnounceTestReplyMsg->dwResponseID = dwResponseID;
	pAnnounceTestReplyMsg->dwUniqueTestID = dwUniqueTestID;

	hr = pSendsBuffer->Add(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to buffer queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so we don't free it below


DONE:

	if (pSendData != NULL)
		delete (pSendData);

	return (hr);
} // CTNMaster::SendAnnounceTestReplyMessageTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SendLostTesterTo()"
//==================================================================================
// CTNMaster::SendLostTesterTo
//----------------------------------------------------------------------------------
//
// Description: Sends a message to the given slave that one of the fellow testers
//				exited from the test.  The slave should use that information to
//				abort any syncs, etc.
//
// Arguments:
//	PTNSLAVEINFO pSlave		The slave to send a lost-tester message to.
//	PTNTESTINSTANCEM pTest	The test which lost a tester.
//	int iTesterNum			The tester who was lost.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::SendLostTesterTo(PTNSLAVEINFO pSlave, PTNTESTINSTANCEM pTest,
									int iTesterNum)
{
	HRESULT					hr;
	PTNSENDDATA				pSendData = NULL;
	PTNTESTINSTANCEM		pTopLevelTest = NULL;
	PCTRLMSG_LOSTTESTER		pLostTesterMsg = NULL;


	if (pSlave->m_commdata.fDropped)
	{
		DPL(0, "Can't send LostTester msg (test %u, number %i) to %s because his connection has been dropped!",
			3, pTest->m_dwUniqueID, iTesterNum, pSlave->m_szComputerName);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to slave is down)

	pTopLevelTest = pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test %u!", 1, pTest->m_dwUniqueID);
		goto DONE;
	} // end if (couldn't get top test)


	DPL(3, "Sending lost tester (%i, in %u:%u) to %s.",
		4, iTesterNum, pTopLevelTest->m_dwUniqueID, pTest->m_dwUniqueID,
		pSlave->m_szComputerName);

	// Send a message to this person
	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = pSlave->m_commdata.dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)
	CopyMemory(pSendData->m_pvAddress, pSlave->m_commdata.pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_LOSTTESTER);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pLostTesterMsg = (PCTRLMSG_LOSTTESTER) pSendData->m_pvData;
	pLostTesterMsg->dwSize = pSendData->m_dwDataSize;
	pLostTesterMsg->dwType = CTRLMSGID_LOSTTESTER;
	pLostTesterMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pLostTesterMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pLostTesterMsg->iTesterNum = iTesterNum;
	
	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	return (hr);
} // CTNMaster::SendLostTesterTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SendBreakMsgTo()"
//==================================================================================
// CTNMaster::SendBreakMsgTo
//----------------------------------------------------------------------------------
//
// Description: Sends a request to DEBUGBREAK() to the given slave.  The specified
//				test ID is just for debug spew, since the tester may have moved on
//				by the time he gets this message.
//
// Arguments:
//	PTNSLAVEINFO pSlave		The slave to send a lost-tester message to.
//	DWORD dwUniqueTestID	Test that lost the syncer.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::SendBreakMsgTo(PTNSLAVEINFO pSlave, DWORD dwUniqueTestID)
{
	HRESULT				hr;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_BREAK		pBreakMsg = NULL;


	if (pSlave->m_commdata.fDropped)
	{
		DPL(0, "Can't send msg (test %u) to %s because his connection has been dropped!",
			2, dwUniqueTestID, pSlave->m_szComputerName);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection is down)

	// Send a message to this person
	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = pSlave->m_commdata.dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)
	CopyMemory(pSendData->m_pvAddress, pSlave->m_commdata.pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_BREAK);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pBreakMsg = (PCTRLMSG_BREAK) pSendData->m_pvData;
	pBreakMsg->dwSize = pSendData->m_dwDataSize;
	pBreakMsg->dwType = CTRLMSGID_BREAK;
	pBreakMsg->dwUniqueTestID = dwUniqueTestID;
	
	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (there's a leftover object)

	return (hr);
} // CTNMaster::SendBreakMsgTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SendDumpLogMsgTo()"
//==================================================================================
// CTNMaster::SendDumpLogMsgTo
//----------------------------------------------------------------------------------
//
// Description: Sends a request to dump the memory log to the given slave to the
//				given path.  If the path is NULL, then the slave dumps it to his
//				default test failure log directory if he has one, or ignores the
//				request if he doesn't.
//
// Arguments:
//	PTNSLAVEINFO pSlave		The slave to send a dump log message to.
//	DWORD dwUniqueTestID	Test ID this message pertains to.
//	char* pszPath			Optional path to have slave dump to.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::SendDumpLogMsgTo(PTNSLAVEINFO pSlave, DWORD dwUniqueTestID,
									char* pszPath)
{
	HRESULT				hr;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_DUMPLOG	pDumpLogMsg = NULL;


	if (pSlave->m_commdata.fDropped)
	{
		DPL(0, "Can't send msg to %s because his connection has been dropped!",
			1, pSlave->m_szComputerName);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection is down)

	// Send a message to this person
	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = pSlave->m_commdata.dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)
	CopyMemory(pSendData->m_pvAddress, pSlave->m_commdata.pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_DUMPLOG);
	if (pszPath != NULL)
		pSendData->m_dwDataSize += strlen(pszPath);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pDumpLogMsg = (PCTRLMSG_DUMPLOG) pSendData->m_pvData;
	pDumpLogMsg->dwSize = pSendData->m_dwDataSize;
	pDumpLogMsg->dwType = CTRLMSGID_DUMPLOG;
	pDumpLogMsg->dwUniqueTestID = dwUniqueTestID;
	//pDumpLogMsg->dwPathSize = 0;
	if (pszPath != NULL)
	{
		pDumpLogMsg->dwPathSize = strlen(pszPath);

		CopyMemory((pDumpLogMsg + 1), pszPath, pDumpLogMsg->dwPathSize);
	} // end if (there's a path to use)
	
	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (there's a leftover object)

	return (hr);
} // CTNMaster::SendDumpLogMsgTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SendMasterUpdate()"
//==================================================================================
// CTNMaster::SendMasterUpdate
//----------------------------------------------------------------------------------
//
// Description: Sends an update message to the meta-master.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::SendMasterUpdate(void)
{
	HRESULT					hr;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_MASTERUPDATE	pMasterUpdateMsg;

	
	// Send a reply
	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = this->m_dwMetaMasterAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	CopyMemory(pSendData->m_pvAddress, this->m_pvMetaMasterAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_MASTERUPDATE);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pMasterUpdateMsg = (PCTRLMSG_MASTERUPDATE) pSendData->m_pvData;
	pMasterUpdateMsg->dwSize = pSendData->m_dwDataSize;
	pMasterUpdateMsg->dwType = CTRLMSGID_MASTERUPDATE;

	CopyMemory(&(pMasterUpdateMsg->id), &(this->m_id), sizeof (TNCTRLMACHINEID));
	pMasterUpdateMsg->iNumSlaves = this->m_slaves.Count();
	pMasterUpdateMsg->fJoinersAllowed = this->m_fJoinersAllowed;

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)
	
	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have a left over send data object)

	return (hr);
} // CTNMaster::SendMasterUpdate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::RegisterWithMetaMaster()"
//==================================================================================
// CTNMaster::RegisterWithMetaMaster
//----------------------------------------------------------------------------------
//
// Description: Sends a register request to the meta-master.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::RegisterWithMetaMaster(void)
{
	HRESULT						hr;
	PTNSENDDATA					pSendData = NULL;
	char*						pszSelfAddress = NULL;
	DWORD						dwSelfAddressSize = 0;
	PCTRLMSG_REGISTERMASTER		pRegisterMasterMsg = NULL;
	LPBYTE						lpCurrent = NULL;


	// Ignore error, assume ERROR_BUFFER_TOO_SMALL
	this->m_pCtrlComm->GetSelfAddressAsString(NULL, &dwSelfAddressSize);

	pszSelfAddress = (char*) LocalAlloc(LPTR, dwSelfAddressSize);
	if (pszSelfAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	hr = this->m_pCtrlComm->GetSelfAddressAsString(pszSelfAddress,
													&dwSelfAddressSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get self address as string!", 0);
		goto DONE;
	} // end if (couldn't retrieve address)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = this->m_dwMetaMasterAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	CopyMemory(pSendData->m_pvAddress, this->m_pvMetaMasterAddress,
			pSendData->m_dwAddressSize);


	pSendData->m_dwDataSize = sizeof (CTRLMSG_REGISTERMASTER)
								+ dwSelfAddressSize - 1;

	if (this->m_pszSessionFilter != NULL)
		pSendData->m_dwDataSize += strlen(this->m_pszSessionFilter);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pRegisterMasterMsg = (PCTRLMSG_REGISTERMASTER) pSendData->m_pvData;
	pRegisterMasterMsg->dwSize = pSendData->m_dwDataSize;
	pRegisterMasterMsg->dwType = CTRLMSGID_REGISTERMASTER;
	pRegisterMasterMsg->dwMetaVersion = CURRENT_METAMASTER_API_VERSION;
	pRegisterMasterMsg->dwControlVersion = CURRENT_TNCONTROL_API_VERSION;
	pRegisterMasterMsg->dwSessionID = this->m_dwSessionID;
	CopyMemory(&(pRegisterMasterMsg->moduleID), &(this->m_moduleID), sizeof (TNMODULEID));
	pRegisterMasterMsg->dwMode = this->m_dwMode;
	pRegisterMasterMsg->dwAddressSize = dwSelfAddressSize - 1;


	lpCurrent = (LPBYTE) (pRegisterMasterMsg + 1);
	CopyAndMoveDestPointer(lpCurrent, pszSelfAddress, dwSelfAddressSize - 1);
	if (this->m_pszSessionFilter != NULL)
	{
		pRegisterMasterMsg->dwSessionFilterSize = strlen(this->m_pszSessionFilter);

		CopyAndMoveDestPointer(lpCurrent, this->m_pszSessionFilter,
								pRegisterMasterMsg->dwSessionFilterSize);
	} // end if (there's a session ID)
	else
		pRegisterMasterMsg->dwSessionFilterSize = 0;	

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	if (pszSelfAddress != NULL)
	{
		LocalFree(pszSelfAddress);
		pszSelfAddress = NULL;
	} // end if (allocated memory)

	return (hr);
} // CTNMaster::RegisterWithMetaMaster
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::UnregisterWithMetaMaster()"
//==================================================================================
// CTNMaster::UnregisterWithMetaMaster
//----------------------------------------------------------------------------------
//
// Description: Sends an uregistration request to the meta-master.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::UnregisterWithMetaMaster(void)
{
	HRESULT						hr;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_UNREGISTERMASTER	pUnregisterMasterMsg = NULL;



	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = this->m_dwMetaMasterAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)
	CopyMemory(pSendData->m_pvAddress, this->m_pvMetaMasterAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_UNREGISTERMASTER);
	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pUnregisterMasterMsg = (PCTRLMSG_UNREGISTERMASTER) pSendData->m_pvData;
	pUnregisterMasterMsg->dwSize = pSendData->m_dwDataSize;
	pUnregisterMasterMsg->dwType = CTRLMSGID_UNREGISTERMASTER;
	CopyMemory(&(pUnregisterMasterMsg->id), &(this->m_id), sizeof (TNCTRLMACHINEID));
	

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	return (hr);
} // CTNMaster::UnregisterWithMetaMaster
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::DoBeginReport()"
//==================================================================================
// CTNMaster::DoBeginReport
//----------------------------------------------------------------------------------
//
// Description: Prints some generic information to the file passed in.  Only the
//				parts specified by dwStyle are printed.
//
// Arguments:
//	HANDLE hFile	Open file to print to.
//	DWORD dwStyle	Options on what to print.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::DoBeginReport(HANDLE hFile, DWORD dwStyle)
{
	HRESULT				hr;
	char				szName[MAX_COMPUTERNAME_SIZE];
	DWORD				dwNameSize = MAX_COMPUTERNAME_SIZE;
	int					i;
	PTNSLAVEINFO		pSlave = NULL;
	PTNTESTINSTANCEM	pTest = NULL;
	char				szBuffer[1024];
	time_t 				temptimet;
	tm*					pTempTime;
	CLStringList		startupstrings;
	CTNTestMsList		temptests;


	ZeroMemory(szName, MAX_COMPUTERNAME_SIZE * sizeof (char));

	// Print a comment header if we're not reporting in BVT format.
	if (! this->m_fReportInBVTFormat)
	{
		time(&temptimet);
		pTempTime = localtime(&temptimet);

		// Ignoring write errors
		FileWriteLine(hFile, "//==================================================================================");
		strftime(szBuffer, 1024, "// Report generated on %I:%M:%S%p  %m/%d/%y", pTempTime);
		FileWriteLine(hFile, szBuffer);
		FileWriteLine(hFile, "//==================================================================================");
	} // end if (not printing BVT)

	if (dwStyle & TNRH_SESSIONINFO)
	{
		FileWriteLine(hFile, "[Info: Session]"); //ignoring errors

		FileSprintfWriteLine(hFile, "SessionID=%010u", 1, this->m_dwSessionID);

		pTempTime = localtime(&(this->m_tStartupTime));
		strftime(szBuffer, 1024, "StartTime= %I:%M:%S%p  %m/%d/%y", pTempTime);
		FileWriteLine(hFile, szBuffer); //ignoring errors

		switch (this->m_dwMode)
		{
			case TNMODE_API:
				FileWriteLine(hFile, "Mode= API");
			  break;
			case TNMODE_STRESS:
				FileWriteLine(hFile, "Mode= Stress");
			  break;
			case TNMODE_POKE:
				FileWriteLine(hFile, "Mode= Poke");
			  break;
			case TNMODE_PICKY:
				FileWriteLine(hFile, "Mode= Picky");
			  break;
		} // end switch (on mode)

#ifndef _XBOX // GetComputerName not supported
		if (! GetComputerName(szName, &dwNameSize))
			strcpy(szName, "unknown");
#else // ! XBOX
#pragma TODO(tristanj, "Need to find a replacement for GetComputerName")
#endif // XBOX

		FileSprintfWriteLine(hFile, "MasterName= %s", 1, szName);

		//FileWriteLine(hFile, "ModuleName= ?");

		FileSprintfWriteLine(hFile, "ModuleID= \"%s\", %i.%i.%i.%i",
							5, this->m_moduleID.szBriefName,
							this->m_moduleID.dwMajorVersion,
							this->m_moduleID.dwMinorVersion1,
							this->m_moduleID.dwMinorVersion2,
							this->m_moduleID.dwBuildVersion);

		FileSprintfWriteLine(hFile, "Timelimit= %u", 1, this->m_dwTimelimit);

		FileSprintfWriteLine(hFile, "NewSlavesAllowed=%B",
							1, this->m_fJoinersAllowed);

		FileSprintfWriteLine(hFile, "CurrentNumMachines= %i", 1, this->m_slaves.Count());

		FileSprintfWriteLine(hFile, "NumDroppedMachines= %i",
							1, this->m_droppedslaves.Count());

		FileSprintfWriteLine(hFile, "TotalNumMachines= %i",
							1, this->m_iTotalNumSlaves);

		FileSprintfWriteLine(hFile, "TotalNumTestsRun= %u",
							1, this->m_totalstats.GetTotalComplete());

		FileSprintfWriteLine(hFile, "TotalNumRemainingTests= %i",
							1, this->m_remainingtests.Count());

		FileSprintfWriteLine(hFile, "TotalNumSucceededTests= %u",
							1, this->m_totalstats.GetSuccesses());

		FileSprintfWriteLine(hFile, "TotalNumFailedTests= %u",
							1, this->m_totalstats.GetFailures());

		FileSprintfWriteLine(hFile, "TotalNumWarnings= %u",
							1, this->m_totalstats.GetWarnings());

		FileSprintfWriteLine(hFile, "TotalNumSkipped= %u",
							1, this->m_skippedtests.Count());

		if (this->m_pfnWriteStartupData != NULL)
		{
			hr = this->m_pfnWriteStartupData(&startupstrings);
			if (hr != S_OK)
			{
				DPL(0, "Module's WriteStartupData callback failed!", 0);
				return (hr);
			} // end if (module's callback failed)

			if (startupstrings.Count() > 0)
				FileWriteLine(hFile, "{ModuleStartupData}");

			for (i = 0; i < startupstrings.Count(); i++)
			{
				FileSprintfWriteLine(hFile, "\t%s",
									1, startupstrings.GetIndexedString(i));
			} // end for (each string the module wants)
		} // end if (the module is able to load startup data)

		// The BVT format specification requires an ending block.
		if (this->m_fReportInBVTFormat)
		{
			FileWriteLine(hFile, "[/Info: Session]");
		} // end if (reporting in BVT format)

		// Double space
		FileWriteLine(hFile, "");
		FileWriteLine(hFile, "");
	} // end if (we're supposed to print the session info)

	if (dwStyle & TNRH_MACHINELIST)
	{
		FileWriteLine(hFile, "[Info: TotalMachineList]");

		this->m_slaves.EnterCritSection();
		for(i = 0; i < this->m_slaves.Count(); i++)
		{
			pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
			if (pSlave == NULL)
			{
				DPL(0, "Couldn't get slave %i!", 1, i);
				this->m_slaves.LeaveCritSection();
				return (E_FAIL);
			} // end if (couldn't get that item)

			FileSprintfWriteLine(hFile, "{%s}", 1, pSlave->m_szComputerName);

			FileWriteLine(hFile, "\tStillInSession= TRUE");

			pSlave->PrintToFile(hFile);

			// Single space
			FileWriteLine(hFile, "");
		} // end for (each slave)
		this->m_slaves.LeaveCritSection();


		this->m_droppedslaves.EnterCritSection();
		for(i = 0; i < this->m_droppedslaves.Count(); i++)
		{
			pSlave = (PTNSLAVEINFO) this->m_droppedslaves.GetItem(i);
			if (pSlave == NULL)
			{
				DPL(0, "Couldn't get slave %i!", 1, i);
				this->m_droppedslaves.LeaveCritSection();
				return (E_FAIL);
			} // end if (couldn't get that item)

			FileSprintfWriteLine(hFile, "{%s}", 1, pSlave->m_szComputerName);

			FileWriteLine(hFile, "\tStillInSession= FALSE");

			pSlave->PrintToFile(hFile);

			// Single space
			FileWriteLine(hFile, "");
		} // end for (each slave)
		this->m_droppedslaves.LeaveCritSection();


		// The BVT format specification requires an ending block.
		if (this->m_fReportInBVTFormat)
		{
			FileWriteLine(hFile, "[/Info: TotalMachineList]");
		} // end if (reporting in BVT format)


		// Single space
		FileWriteLine(hFile, "");
	} // end if (we're supposed to print the machine list)

	if (dwStyle & TNRH_ACTIVETESTS)
	{
		FileWriteLine(hFile, "[Info: ActiveTests]");

		this->m_slaves.EnterCritSection();
		for(i = 0; i < this->m_slaves.Count(); i++)
		{
			pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
			if (pSlave == NULL)
			{
				DPL(0, "Couldn't get slave %i!", 1, i);
				this->m_slaves.LeaveCritSection();
				return (E_FAIL);
			} // end if (couldn't get that item)


#pragma BUGBUG(vanceo, "What about ongoing tests?")
			if (pSlave->m_pCurrentTest != NULL)
			{
				if (temptests.GetFirstIndex(pSlave->m_pCurrentTest) < 0)
				{
					hr = pSlave->m_pCurrentTest->PrintToFile(hFile, TRUE, FALSE);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't get print slave %s's current test (%u)!",
							2, pSlave->m_szComputerName,
							pSlave->m_pCurrentTest->m_dwUniqueID);
						this->m_slaves.LeaveCritSection();
						return (hr);
					} // end if (couldn't print to file)

					// Single space
					FileWriteLine(hFile, "");


					// Add it to our used list.
					hr = temptests.Add(pSlave->m_pCurrentTest);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add slave %s's current test %u!",
							2, pSlave->m_szComputerName,
							pSlave->m_pCurrentTest->m_dwUniqueID);
						this->m_slaves.LeaveCritSection();
						return (hr);
					} // end if (couldn't add test)
				} // end if (haven't already used this test)
			} // end if (slave has a current test)
		} // end for (each slave)
		this->m_slaves.LeaveCritSection();


		// The BVT format specification requires an ending block.
		if (this->m_fReportInBVTFormat)
		{
			FileWriteLine(hFile, "[/Info: ActiveTests]");
		} // end if (reporting in BVT format)


		// Single space
		FileWriteLine(hFile, "");
	} // end if (we're supposed to print the active tests list)


	if (dwStyle & TNRH_REMAININGTESTS)
	{
		FileWriteLine(hFile, "[Info: RemainingTestsList]");

		this->m_remainingtests.EnterCritSection();
		for(i = 0; i < this->m_remainingtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCEM) this->m_remainingtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get test item %i!", 1, i);
				this->m_remainingtests.LeaveCritSection();
				return (E_FAIL);
			} // end if (couldn't get that item)

			hr = pTest->PrintToFile(hFile, TRUE, FALSE);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't get print test %i to file!", 1, i);
				this->m_remainingtests.LeaveCritSection();
				return (hr);
			} // end if (couldn't print to file)
		
			// Single space
			FileWriteLine(hFile, "");
		} // end for (each test)
		this->m_remainingtests.LeaveCritSection();

		// The BVT format specification requires an ending block.
		if (this->m_fReportInBVTFormat)
		{
			FileWriteLine(hFile, "[/Info: RemainingTestsList]");
		} // end if (reporting in BVT format)


		// Single space
		FileWriteLine(hFile, "");
	} // end if (we're supposed to print the remaining test list)

	if (dwStyle & TNRH_SKIPPEDTESTS)
	{
		FileWriteLine(hFile, "[Info: SkippedTestsList]");

		this->m_skippedtests.EnterCritSection();
		for(i = 0; i < this->m_skippedtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCEM) this->m_skippedtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get test item %i!", 1, i);
				this->m_skippedtests.LeaveCritSection();
				return (E_FAIL);
			} // end if (couldn't get that item)

			hr = pTest->PrintToFile(hFile, TRUE, FALSE);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't get print test %i to file!", 1, i);
				this->m_skippedtests.LeaveCritSection();
				return (hr);
			} // end if (couldn't print to file)
		
			// Single space
			FileWriteLine(hFile, "");
		} // end for (each test)
		this->m_skippedtests.LeaveCritSection();

		// The BVT format specification requires an ending block.
		if (this->m_fReportInBVTFormat)
		{
			FileWriteLine(hFile, "[/Info: SkippedTestsList]");
		} // end if (reporting in BVT format)


		// Single space
		FileWriteLine(hFile, "");
	} // end if (we're supposed to print the skipped test list)

	return (S_OK);
} // CTNMaster::DoBeginReport
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CountMatchingReports()"
//==================================================================================
// CTNMaster::CountMatchingReports
//----------------------------------------------------------------------------------
//
// Description: Returns the number of reports in the log that match the given flags.
//
// Arguments:
//	DWORD dwFlags				What in the report log should be counted.
//	PTNSLAVESLIST pMachineList	List of machines to filter reports by, or NULL for
//								none.
//	PTNTESTSLIST pTestList		List of tests to filter reports by, or NULL for
//								none.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
int CTNMaster::CountMatchingReports(DWORD dwFlags, PTNSLAVESLIST pMachineList,
									PTNTESTMSLIST pTestList)
{
	int			iCount = 0;
	PTNREPORT	pReport = NULL;


	pReport = NULL;
	this->m_reports.EnterCritSection();
	do
	{
		pReport = this->m_reports.GetNextMatchingReport(pReport, dwFlags,
														pMachineList, pTestList,
														FALSE);
		if (pReport == NULL)
		{
			break;
		} // end if (no more matching reports)

		iCount++;
	} // end do (while more reports)
	while (TRUE);

	this->m_reports.LeaveCritSection();


	return (iCount);
} // CTNMaster::CountMatchingReports
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::DoAutoReport()"
//==================================================================================
// CTNMaster::DoAutoReport
//----------------------------------------------------------------------------------
//
// Description: Performs the autoprinting.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::DoAutoReport(void)
{
	HRESULT		hr = S_OK;



	this->m_reports.EnterCritSection();

	// Only do the auto-reporting if it's time.
	if (this->CountMatchingReports(this->m_dwAutoReportFlags, NULL, NULL) >= this->m_iAutoReportNumReports)
	{
		char	szTemp[256];


		hr = this->PrintReports(this->m_dwAutoReportHeaders,
								this->m_dwAutoReportBodyStyle,
								this->m_dwAutoReportFlags,
								szTemp,
								TRUE,
								TRUE);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-print reports to \"%s\"!", 1, szTemp);
			goto DONE;
		} // end if (couldn't print reports)


		// If the user wants the log to be empty after a print (even if we
		// didn't print all of the items in it), clear the remaining items.
		if (this->m_fAutoReportDeleteNonPrinted)
		{
			hr = this->m_reports.RemoveAll();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't remove remaining reports!", 0);
				goto DONE;
			} // end if (couldn't print reports)
		} // end if (should delete remaining reports)
	} // end if (that report put us over the limit)


DONE:

	this->m_reports.LeaveCritSection();

	return (hr);
} // CTNMaster::DoAutoReport
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::CloseSession()"
//==================================================================================
// CTNMaster::CloseSession
//----------------------------------------------------------------------------------
//
// Description: Closes the session, and performs all the appropriate actions.
//				The slave list lock is assumed to be held with only one level of
//				recursion.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::CloseSession()
{
	HRESULT			hr;
	int				i;
	PTNJOB			pJob;
	PTNSLAVEINFO	pSlave;
	BOOL			fAllReady = TRUE;


	// Make sure no one can join, in case they currently can.
	this->m_fJoinersAllowed = FALSE;


	DPL(0, "Closing session, no additional joiners will be allowed.", 0);
	// Ignoring error

	this->Log(TNLST_CONTROLLAYER_INFO,
			"Closing session, no additional joiners will be allowed.", 0);



	// Make sure there's no duplicate CloseSession jobs pending.

	this->m_jobs.EnterCritSection();

	for(i = 0; i < this->m_jobs.Count(); i++)
	{
		pJob = (PTNJOB) this->m_jobs.GetItem(i);
		if (pJob == NULL)
		{
			DPL(0, "Couldn't get job %i!", 1, i);
			this->m_jobs.LeaveCritSection();
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		if (pJob->m_dwOperation == TNMJ_CLOSESESSION)
		{
			hr = this->m_jobs.Remove(i);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't remove job %i!", 1, i);
				this->m_jobs.LeaveCritSection();
				goto DONE;
			} // end if (couldn't remove item)

			i--; // back up so we don't screw up our index
		} // end if (it's a close session)
	} // end for (each job)

	this->m_jobs.LeaveCritSection();



	// Add the report.
	hr = this->m_reports.AddReport(RT_CLOSEDSESSION, 0, NULL,
									NULL, 0, NULL, 0);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add session close report to list!", 0);
		goto DONE;
	} // end if (failed add report)


	// If we are doing the auto-report thing, and the report we just added is
	// one of the ones we are counting, check to see if that pushed us over the
	// limit.
	if ((this->m_iAutoReportNumReports > 0) &&
		(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
	{
		hr = this->DoAutoReport();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-report!", 0);
			goto DONE;
		} // end if (couldn't print reports)
	} // end if (auto reporting is on and this was a matching report type)


	// If we're registered with a meta-master, we should send a master update
	// message.
	if (this->m_fRegistered)
	{
		hr = this->SendMasterUpdate();
		if (hr != S_OK)
		{
			DPL(0, "Failed to send master update to meta-master!", 0);
			goto DONE;
		} // end if (failed send master update)
	} // end if (we're registered with a metamaster)


	// Ping the event to let the app know our new status.
	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update event)



	// If we're in API mode, we need to kick everybody off in their tests
	// because we were waiting for the session to close.
	// If we're in stress mode, we need to see if everybody who
	// isn't already running a test actually can now that the session is closed.
	if (this->m_dwMode != TNMODE_POKE) 
	{
		if (this->m_dwMode == TNMODE_API)
		{
			for(i = 0; i < this->m_slaves.Count(); i++)
			{
				pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
				if (pSlave == NULL)
				{
					DPL(0, "Couldn't get slave %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get item)

				// If even one other guy is not ready to test, we don't want to
				// make any assumptions yet.
				if (! pSlave->m_fReadyToTest)
				{
					fAllReady = FALSE;
					break;
				} // end if (not ready)
			} // end for (each tester)
		} // end if (in API mode)

		if (fAllReady)
		{
			if (this->m_dwMode == TNMODE_API)
			{
				DPL(1, "Session closed and all slaves are currently ready, getting commands.", 0);
			} // end if (in API mode)
			else
			{
				DPL(6, "Refreshing all slaves ready to test with nothing to do currently.", 0);
			} // end else (not in API mode)

			for(i = 0; i < this->m_slaves.Count(); i++)
			{
				pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
				if (pSlave == NULL)
				{
					DPL(0, "Couldn't get slave %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get item)

				// This (sort of) races with ReadyToTest, plus in stress mode he
				// may have already started on something, so leave him alone if
				// he's already cookin'.
				if ((pSlave->m_fReadyToTest) && (pSlave->m_pCurrentTest == NULL))
				{
					hr = this->GetNextCmdForMachine(pSlave);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't get next test/command for %s!",
							1, pSlave->m_szComputerName);
						goto DONE;
					} // end if (failed to get next cmd)
				} // end if (in API mode or this guy is idle)
			} // end for (each tester)
		} // end if (all testers are ready)
	} // end if (not in Poke mode)


DONE:

	return (hr);
} // CTNMaster::CloseSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::DoPingCheck()"
//==================================================================================
// CTNMaster::DoPingCheck
//----------------------------------------------------------------------------------
//
// Description: Pings slaves to see if they are still alive, if it hasn't heard back
// 				in TIMEOUT_SLAVE_PING milliseconds.  If it hasn't heard back in
//				TIMEOUT_SLAVE_KILL milliseconds, the slave will be killed.
//				The slave list lock is assumed to be held.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::DoPingCheck(void)
{
	HRESULT				hr = S_OK;
	PTNSLAVEINFO		pSlave = NULL;
	DWORD				dwNotHeardTime;
	int					i;
	DWORD				dwKillReason;
	BOOL				fKilledSlave = FALSE;


	DPL(9, "==>", 0);


	// Go through the list of slaves and ping those not heard from
	// in SLAVE_CHECK_INTERVAL milliseconds. If we haven't heard from
	// a slave in TIMEOUT_SLAVE_PING milliseconds, kill it.

	for(i = 0; i < this->m_slaves.Count(); i++)
	{
		pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
		if (pSlave == NULL)
		{
			DPL(0, "Couldn't get slave %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)
		
		
		pSlave->m_dwRefCount++; // we're using it


		dwKillReason = 0;

		// Check if the slave has disconnected.
		if (pSlave->m_commdata.fDropped)
		{
			DPL(0, "Connection to %s dropped, removing him.",
				1, pSlave->m_szComputerName);

			// Ignoring error
			this->Log(TNLST_CONTROLLAYER_INFO,
					"Connection to %s dropped, removing him.",
					1, pSlave->m_szComputerName);

			dwKillReason = RRM_LEFT;
		} // end if (connection dropped)
		else
		{
			// If we're timing and this slave is past the time he should be done
			// testing, tell him and then remove him.
			if ((pSlave->m_dwEndtime > 0) &&
				(GetTickCount() > pSlave->m_dwEndtime))
			{
				DPL(0, "%s has passed the %i minute timelimit, removing and notifying him.",
					2, pSlave->m_szComputerName, this->m_dwTimelimit);

				// Send the message to him.
				hr = this->SendTestingStatusMessageTo(pSlave, CTRLTS_ALLCOMPLETE);
				if (hr != S_OK)
				{
					if (hr != TNERR_CONNECTIONDROPPED)
					{
						DPL(0, "Couldn't send testing complete message to %s!",
							1, pSlave->m_szComputerName);
						goto DONE;
					} // end if (the error isn't because he's already gone)
					else
					{
						DPL(0, "Not sending testing complete message to %s because he's already gone.",
							1, pSlave->m_szComputerName);
						hr = S_OK;
					} // end else (the slave is already gone)
				} // end if (couldn't get send teststatus message)

				// NOTE: If the slave also happens to be killed by lack of ping
				// replies, then this will be overwritten.  Oh well.
				dwKillReason = RRM_TIMEREXPIRED;
			} // end if (there are no tests left)


			// Get the current time and the last access time 
			// of the slave

			dwNotHeardTime = pSlave->TimeSinceLastReceive();
			if (dwNotHeardTime > TIMEOUT_SLAVE_KILL)
			{
				DPL(0, "Haven't heard from %s in %u ticks, killing him.",
					2, pSlave->m_szComputerName, dwNotHeardTime);

				// Ignoring error
				this->Log(TNLST_CONTROLLAYER_INFO,
						"Haven't heard from %s in %u ticks, killing him.",
						2, pSlave->m_szComputerName, dwNotHeardTime);

				dwKillReason = RRM_DROPPED;
			} // end if (time to kill the slave)
			else if (dwNotHeardTime > TIMEOUT_SLAVE_PING)
			{
				// If we've already sent the maximum # of pings, skip this guy
				if (pSlave->PingsSinceLastReceive() >= NUM_PINGS_TO_ATTEMPT)
				{
					DPL(5, "Still haven't heard from %s (%u ticks), but not pinging.",
						2, pSlave->m_szComputerName, dwNotHeardTime);
				} // end if (we've already sent the max number of pings)
				else
				{
					// Send a ping to the slave
					hr = this->SendPingTo(pSlave);
					if (hr != S_OK)
					{
						if (hr != TNERR_CONNECTIONDROPPED)
						{
							DPL(0, "Sending ping to slave %s failed!",
								1, pSlave->m_szComputerName);
							goto DONE;
						} // end if (the error isn't because he's already gone)
						else
						{
							DPL(0, "Not sending ping to %s because he's already gone.",
								1, pSlave->m_szComputerName);

							dwKillReason = RRM_LEFT;
							hr = S_OK;
						} // end else (the slave is already gone)
					} // end if (failed sending ping)
				} // end else (haven't sent maximum number of pings)
			} // end else if (should ping the slave)
		} // end else (the connection hasn't dropped yet)

		if (dwKillReason != 0)
		{
			// This removes him from the list.
			hr = this->KillSlave(pSlave, dwKillReason);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't kill %s!", 1, pSlave->m_szComputerName);
				goto DONE;
			} // end if (couldn't kill slave)

			// Back up so our counter doesn't get out of sync with our
			// new slave list size.
			i--;

			fKilledSlave = TRUE;


			// If the session is closed and we just killed the last slave,
			// then make sure testing is done.
			if ((! this->m_fJoinersAllowed) &&
				(this->m_slaves.Count() == 0))
			{
				hr = this->CompleteAllTesting();
				if (hr != S_OK)
				{
					DPL(0, "Couldn't complete all testing!", 0);
					goto DONE;
				} // end if (couldn't complete all testing)
			} // end if (session closed and last slave gone)
		} // end if (should kill the slave)


		// Check if we have to delete him.
		pSlave->m_dwRefCount--;
		if (pSlave->m_dwRefCount == 0)
		{
			DPL(7, "Deleting slave %x.", 1, pSlave);
			delete (pSlave);
		} // end if (should delete slave)
		else
		{
			DPL(7, "Not deleting slave %x, refcount is %u.",
				2, pSlave, pSlave->m_dwRefCount);
		} // end else (shouldn't delete slave)
		pSlave = NULL;
	} // end for (each slave)


	// If our slave list changed, we need to update the meta-master if we're
	// registered with one, and notify the app.
	if (fKilledSlave)
	{
		// If we're registered with a meta-master, we should send a master update
		// message.
		if (this->m_fRegistered)
		{
			hr = this->SendMasterUpdate();
			if (hr != S_OK)
			{
				DPL(0, "Failed to send master update to meta-master!", 0);
				goto DONE;
			} // end if (failed send master update)
		} // end if (we're registered with a metamaster)


		// Ping the event to let the app know our new status.
		if ((this->m_hCompletionOrUpdateEvent != NULL) &&
			(! SetEvent(this->m_hCompletionOrUpdateEvent)))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set the user's update event (%x)!",
				1, this->m_hCompletionOrUpdateEvent);
			goto DONE;
		} // end if (couldn't set the user's update event)
	} // end if (our status changed)


DONE:

	if (pSlave != NULL)
	{
		pSlave->m_dwRefCount--;
		if (pSlave->m_dwRefCount == 0)
		{
			DPL(7, "Deleting still held slave %x.", 1, pSlave);
			delete (pSlave);
		} // end if (should delete slave)
		else
		{
			DPL(7, "Not deleting still held slave %x, refcount is %u.",
				2, pSlave, pSlave->m_dwRefCount);
		} // end else (shouldn't delete slave)
		pSlave = NULL;
	} // end if (have slave object)


	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNMaster::DoPingCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::DoSlaveReadyToTest()"
//==================================================================================
// CTNMaster::DoSlaveReadyToTest
//----------------------------------------------------------------------------------
//
// Description: Marks the given slave as ready to test, and kicks off testing as
//				appropriate.
//				The slave list lock is assumed to be held.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::DoSlaveReadyToTest(PTNCTRLMACHINEID pSlaveID)
{
	HRESULT			hr = S_OK;
	PTNSLAVEINFO	pSlave = NULL;
	int				i;
	BOOL			fAllReady = TRUE;


	pSlave = this->m_slaves.GetSlaveByID(pSlaveID);
	if (pSlave == NULL)
	{
		DPL(0, "Couldn't find slave (%u) in list!  Ignoring ReadyToTest request.",
			1, pSlaveID->dwTime);

		// BUGBUG Fail?
		goto DONE;
	} // end if (couldn't get slaveinfo object)


#pragma BUGBUG(vanceo, "This is kinda weak (doing it here)...")
	hr = pSlave->UpdateLastReceiveTime();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't update slave's last receive time!", 0);
		goto DONE;
	} // end if (couldn't update receive time)


#ifdef DEBUG
	if (pSlave->m_fReadyToTest)
	{
		DPL(0, "%s has already indicated readiness to test!",
			1, pSlave->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (slave already marked ready to test)
#endif // DEBUG


	DPL(2, "Slave %s is now ready to test.", 1, pSlave->m_szComputerName);

	pSlave->m_fReadyToTest = TRUE;


	// If we're in Poke mode, we don't do any command retrieval.
	if (this->m_dwMode == TNMODE_POKE)
	{
		goto DONE;
	} // end if (in poke mode)


	// If the session is still open and we're in API mode, we can't do
	// any command retrieval either.
	if ((this->m_fJoinersAllowed) &&
		(this->m_dwMode == TNMODE_API))
	{
		goto DONE;
	} // end if (the session is still open)


	// If we're in API mode, we need to see if this was the last slave waiting
	// to get ready.  If so, we need to kick everybody off in their tests
	// because we were waiting for the session to close.
	// If we're in stress mode, we need to see if everybody who
	// isn't already running a test actually can now that a new slave joined.
	if (this->m_dwMode != TNMODE_POKE) 
	{
		if (this->m_dwMode == TNMODE_API)
		{
			for(i = 0; i < this->m_slaves.Count(); i++)
			{
				pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
				if (pSlave == NULL)
				{
					DPL(0, "Couldn't get slave %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get item)

				// If even one other guy is not ready to test, we don't want to
				// make any assumptions yet.
				if (! pSlave->m_fReadyToTest)
				{
					fAllReady = FALSE;
					break;
				} // end if (not ready)
			} // end for (each tester)
		} // end if (in API mode)

		if (fAllReady)
		{
			if (this->m_dwMode == TNMODE_API)
			{
				DPL(1, "Last slave to get ready, getting commands for all slaves.", 0);
			} // end if (in API mode)
			else
			{
				DPL(6, "Refreshing all slaves ready to test with nothing to do currently.", 0);
			} // end else (not in API mode)

			for(i = 0; i < this->m_slaves.Count(); i++)
			{
				pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
				if (pSlave == NULL)
				{
					DPL(0, "Couldn't get slave %i!", 1, i);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get item)


				// This (sort of) races with CloseSession, plus in stress mode he
				// may have already started on something, so leave him alone if
				// he's already cookin'.
				if ((pSlave->m_fReadyToTest) && (pSlave->m_pCurrentTest == NULL))
				{
					hr = this->GetNextCmdForMachine(pSlave);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't get next test/command for %s!",
							1, pSlave->m_szComputerName);
						goto DONE;
					} // end if (failed to get next cmd)
				} // end if (in API mode or this guy is idle)
			} // end for (each tester)
		} // end if (all testers are ready)
	} // end if (not in Poke mode)


DONE:

	return (hr);
} // CTNMaster::DoSlaveReadyToTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::DoHandleReport()"
//==================================================================================
// CTNMaster::DoHandleReport
//----------------------------------------------------------------------------------
//
// Description: Handles a report from a slave.
//				The slave list lock is assumed to be held.
//
// Arguments:
//	PTNSLAVEINFO pSlave				Slave who is reporting.
//	PCTRLMSG_REPORT pReportMsg		The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::DoHandleReport(PTNSLAVEINFO pSlave, PCTRLMSG_REPORT pReportMsg)
{
	HRESULT				hr;
	PTNTESTINSTANCEM	pTest = NULL;
	BOOL				fHaveTestRef = FALSE;
	BOOL				fSubTest = FALSE;
	int					iTesterNum = -1;
	DWORD				dwReportType = 0;
	BOOL				fOngoing = FALSE;
	int					i;
	BOOL				fDebugBreak = FALSE;


	DPL(9, "==>(%x [%s], %x)", 3, pSlave, pSlave->m_szComputerName, pReportMsg);

	pTest = pSlave->GetTest(pReportMsg->dwTopLevelUniqueID, pReportMsg->dwTestUniqueID);
	if (pTest == NULL)
	{
		DPL(0, "Couldn't get test %u:%u %s is reporting on!",
			3, pReportMsg->dwTopLevelUniqueID, pReportMsg->dwTestUniqueID,
			pSlave->m_szComputerName);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get test ID)

	if (pReportMsg->dwTopLevelUniqueID != pReportMsg->dwTestUniqueID)
		fSubTest = TRUE;

	if (pSlave->m_ongoingtestslist.GetTopLevelTest(pReportMsg->dwTopLevelUniqueID) != NULL)
		fOngoing = TRUE;


	// Make sure we hold on to it so no one deletes it behind our backs.
	pTest->m_dwRefCount++;
	fHaveTestRef = TRUE;


	iTesterNum = pTest->GetSlavesTesterNum(pSlave);

	// If we didn't find it, then bail.
	if (iTesterNum < 0)
	{
		DPL(0, "Couldn't find the reporting slave (%s) in %i's tester list!",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find the reporting tester in the list)


	// Make sure the test is cookin'.
	if (! pTest->m_fStarted)
	{
		DPL(0, "%s is trying to report on a test (ID %u) which hasn't started yet?!",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (the test hasn't started)

	// Make sure the dude hasn't already claimed he finished it.
	if (pTest->m_paTesterSlots[iTesterNum].fComplete)
	{
		DPL(0, "%s is trying to report on a test (ID %u) he already said he finished?!",
			2, pSlave->m_szComputerName, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (he already finished the test)

	

	if (pReportMsg->fSuccess)
	{
		if (fSubTest)
			dwReportType = RT_SUCCESS_SUBTEST;
		else
			dwReportType = RT_SUCCESS;
	} // end if (we're reporting a success)
	else
	{
		if (fSubTest)
			dwReportType = RT_FAILURE_SUBTEST;
		else
			dwReportType = RT_FAILURE;
	} // end else (we're reporting a failure)

	hr = this->m_reports.AddReport(dwReportType,
								1, &pSlave,
								pTest,
								pReportMsg->hresult,
								((pReportMsg->dwOutputDataSize > 0) ? (pReportMsg + 1) : NULL),
								pReportMsg->dwOutputDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add report to list!", 0);
		goto DONE;
	} // end if (failed add report)


	// If we are doing the auto-report thing, and the report we just added is one
	// of the ones we are counting, check to see if that pushed us over the limit.
	if ((this->m_iAutoReportNumReports > 0) &&
		((pReportMsg->fSuccess) &&
			(this->m_dwAutoReportFlags & (TNREPORT_DURINGTESTSUCCESSES | TNREPORT_TESTASSIGNMENTSTESTSUCCEEDED | TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTSUCCEEDED))) ||
		((! pReportMsg->fSuccess) &&
			(this->m_dwAutoReportFlags & (TNREPORT_DURINGTESTFAILURES | TNREPORT_TESTASSIGNMENTSTESTFAILED | TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTFAILED))))
	{
		hr = this->DoAutoReport();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't auto-report!", 0);
			goto DONE;
		} // end if (couldn't print reports)
	} // end if (auto reporting is on and this was a matching report type)


	DPL(0, "%s %s %sest unique ID %u:%u %s, hr = %x, data size = %u, data = %x",
		9, pSlave->m_szComputerName,
		((pReportMsg->fTestComplete) ? "completed" : "is continuing"),
		((fSubTest) ? "subt" : "t"),
		pReportMsg->dwTopLevelUniqueID,
		pReportMsg->dwTestUniqueID,
		((pReportMsg->fSuccess) ? "successfully" : "with failure"),
		pReportMsg->hresult,
		pReportMsg->dwOutputDataSize,
		((pReportMsg->dwOutputDataSize > 0) ? (pReportMsg + 1) : NULL));

	this->Log(((pReportMsg->fSuccess) ? TNLST_CONTROLLAYER_TESTSUCCESS : TNLST_CONTROLLAYER_TESTFAILURE),
					"%s %s test unique ID %u %s.",
					4, pSlave->m_szComputerName,
					((pReportMsg->fTestComplete) ? "completed" : "is continuing"),
					pReportMsg->dwTestUniqueID,
					((pReportMsg->fSuccess) ? "successfully" : "with failure"));

	this->Log(((pReportMsg->fSuccess) ? TNLST_CONTROLLAYER_TESTSUCCESS : TNLST_CONTROLLAYER_TESTFAILURE),
				"Test result = %e", 1, pReportMsg->hresult);

	if ((! pReportMsg->fSuccess) && 
		(this->m_pszSiblingFailuresMemDumpDirPath != NULL))
	{
		for(i = 0; i < pTest->m_iNumMachines; i++)
		{
			// Make sure this tester exists, and isn't the guy doing the reporting.
			if (pTest->m_paTesterSlots[i].pSlave != NULL)
			{
				if (pTest->m_paTesterSlots[i].pSlave != pSlave)
				{
					char*	pszFilepath;
					char	szTemp[256];
					DWORD	dwSize;


					// If the user specified "", then have the slaves use their default
					// directory, otherwise build a path for the slave.
					pszFilepath = NULL;
					if (strcmp(this->m_pszSiblingFailuresMemDumpDirPath, "") != 0)
					{
						wsprintf(szTemp, "req_memlog_%stest_%010u_",
								((fSubTest) ? "subt" : "t"),
								pTest->m_dwUniqueID);

						dwSize = strlen(this->m_pszSiblingFailuresMemDumpDirPath)
								+ strlen(szTemp)
								+ strlen(pTest->m_paTesterSlots[i].pSlave->m_szComputerName)
								+ 5; // ".txt" + NULL termination
						// Make sure it ends with a backslash
						if (! StringEndsWith(this->m_pszSiblingFailuresMemDumpDirPath, "\\", TRUE))
							dwSize++;

						pszFilepath = (char*) LocalAlloc(LPTR, dwSize);
						if (pszFilepath == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (couldn't allocate memory)

						strcpy(pszFilepath, this->m_pszSiblingFailuresMemDumpDirPath);
						if (! StringEndsWith(this->m_pszSiblingFailuresMemDumpDirPath, "\\", TRUE))
							strcat(pszFilepath, "\\");
						strcat(pszFilepath, szTemp);
						strcat(pszFilepath, pTest->m_paTesterSlots[i].pSlave->m_szComputerName);
						strcat(pszFilepath, ".txt");
					} // end if (should build path)

					hr = this->SendDumpLogMsgTo(pTest->m_paTesterSlots[i].pSlave,
												pTest->m_dwUniqueID,
												pszFilepath);
					if (pszFilepath != NULL)
					{
						LocalFree(pszFilepath);
						pszFilepath = NULL;
					} // end if (allocated filepath)

					if (hr != S_OK)
					{
						if (hr != TNERR_CONNECTIONDROPPED)
						{
							DPL(0, "Couldn't send dump log message to %s!",
								1, pTest->m_paTesterSlots[i].pSlave->m_szComputerName);
							goto DONE;
						} // end if (not connectiondropped)
						else
						{
							DPL(0, "WARNING: Couldn't have %s dump his log because he's gone!",
								1, pTest->m_paTesterSlots[i].pSlave->m_szComputerName);
							hr = S_OK;
						} // end else (connection dropped)
					} // end if (failed to send message)
				} // end if (it's not the reporting tester)
			} // end if (there's a tester here)
			else
			{
				DPL(0, "WARNING: Can't tell tester %i to dump the log because slot isn't filled yet!",
					1, i);
			} // end else (there's no tester assigned yet)

		} // end for (each possible tester slot)
	} // end if (it's a failure)


	// If it's a failure report, check to see if we should have all the testers
	// drop into the debugger
	if ((! pReportMsg->fSuccess) && (this->m_pFailureBreakRules != NULL))
	{
		char		szNumber[32];
		int			i;
		PLSTRING	pBreakRule;
		char*		pszTemp;
		DWORD		dwNumFields;
		

		wsprintf(szNumber, "0x%08x", pReportMsg->hresult);

		this->m_pFailureBreakRules->EnterCritSection();
		for(i = 0; i < this->m_pFailureBreakRules->Count(); i++)
		{
			pBreakRule = (PLSTRING) this->m_pFailureBreakRules->GetItem(i);
			if (pBreakRule == NULL)
			{
				DPL(0, "Couldn't get failure break rule %i!", 1, i);
				this->m_pFailureBreakRules->LeaveCritSection();
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get break rule)

			pszTemp = (char*) LocalAlloc(LPTR, strlen(pBreakRule->GetString()) + 1);
			if (pszTemp == NULL)
			{
				this->m_pFailureBreakRules->LeaveCritSection();
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't get break rule)

			// Ignoring possible return of 0.
			dwNumFields = StringSplitIntoFields(pBreakRule->GetString(), " ",
												pszTemp, NULL);

			fDebugBreak = StringMatchesWithWildcard(StringGetFieldPtr(pszTemp, 0),
													pTest->m_pCase->m_pszID,
													TRUE);
			if ((fDebugBreak) && (dwNumFields >= 2))
			{
				fDebugBreak = StringMatchesWithWildcard(StringGetFieldPtr(pszTemp, 1),
														szNumber,
														TRUE);
			} // end if (only one field)

			LocalFree(pszTemp);
			pszTemp = NULL;

			// If we matched, stop searching.
			if (fDebugBreak)
			{
				DPL(5, "\"%s %x\" matched \"%s\"", 3, pTest->m_pCase->m_pszID,
					pReportMsg->hresult, pBreakRule->GetString());
				break;
			} // end if (matched)
		} // end for (each failure break rule)
		this->m_pFailureBreakRules->LeaveCritSection();


		if (fDebugBreak)
		{
			//Ignoring error
			this->Log(TNLST_CRITICAL,
					"Failure for test %u (case %s, \"%s\", result = %x) fits break rules, telling testers to DebugBreak().",
					4, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
					pTest->m_pCase->m_pszName, pReportMsg->hresult);
			
			DPL(0, "Failure for test %u (case %s, \"%s\", result = %x) fits break rules, telling testers to DebugBreak().",
				4, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
				pTest->m_pCase->m_pszName, pReportMsg->hresult);

			for(i = 0; i < pTest->m_iNumMachines; i++)
			{
				if (pTest->m_paTesterSlots[i].pSlave != NULL)
				{
					hr = this->SendBreakMsgTo(pTest->m_paTesterSlots[i].pSlave,
												pTest->m_dwUniqueID);
					if (hr != S_OK)
					{
						if (hr != TNERR_CONNECTIONDROPPED)
						{
							DPL(0, "Couldn't send break message to %s!",
								1, pTest->m_paTesterSlots[i].pSlave->m_szComputerName);
							goto DONE;
						} // end if (not connectiondropped)
						else
						{
							DPL(0, "WARNING: Couldn't send break message to %s because he's gone!",
								1, pTest->m_paTesterSlots[i].pSlave->m_szComputerName);
							hr = S_OK;
						} // end else (connection dropped)
					} // end if (failed to send message)
				} // end if (there's a tester here)
				else
				{
					DPL(0, "WARNING: Can't tell tester %i to DEBUGBREAK() because slot isn't filled yet!",
						1, i);
				} // end else (there's no tester assigned yet)

			} // end for (each possible tester slot)
		} // end if (this matches a break rule)
	} // end if (this tester is reporting a failure and there are break rules)

	if (pReportMsg->fTestComplete)
	{
		pTest->m_paTesterSlots[iTesterNum].hresult = pReportMsg->hresult;
		pTest->m_paTesterSlots[iTesterNum].fSuccess = pReportMsg->fSuccess;

		// If there's output data, we need to duplicate it over here.
		if (pReportMsg->dwOutputDataSize > 0)
		{
			pTest->m_paTesterSlots[iTesterNum].pvOutputData = LocalAlloc(LPTR, pReportMsg->dwOutputDataSize);
			if (pTest->m_paTesterSlots[iTesterNum].pvOutputData == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
			pTest->m_paTesterSlots[iTesterNum].dwOutputDataSize = pReportMsg->dwOutputDataSize;

			CopyMemory(pTest->m_paTesterSlots[iTesterNum].pvOutputData, (pReportMsg + 1),
						pReportMsg->dwOutputDataSize);

			// If there are output variables, we need to duplicate them to.
			if (pReportMsg->dwVarsSize > 0)
			{
				pTest->m_paTesterSlots[iTesterNum].pVars = new (CTNOutputVarsList);
				if (pTest->m_paTesterSlots[iTesterNum].pVars == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate object)

				// Let the object know where the buffer is.
				pTest->m_paTesterSlots[iTesterNum].pVars->m_pvOutputDataStart = pTest->m_paTesterSlots[iTesterNum].pvOutputData;

				// Unpack the list.
				hr = pTest->m_paTesterSlots[iTesterNum].pVars->UnpackFromBuffer(((LPBYTE) (pReportMsg + 1)) + pReportMsg->dwOutputDataSize,
																					pReportMsg->dwVarsSize);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't unpack variables from buffer!", 0);
					goto DONE;
				} // end if (couldn't unpack variables from buffer)
			} // end if (there are variables)
		} // end if (there's output data)

		hr = this->CompleteSlavesTest(pSlave, pTest, pReportMsg->fSuccess,
									fSubTest, fOngoing);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't complete %s's test (ID %u)!",
				2, pSlave->m_szComputerName, pTest->m_dwUniqueID);
			goto DONE;
		} // end if (failed completing test)
	} // end if (test was completed)


DONE:

	if ((pTest != NULL) && (pTest->m_dwRefCount == 0xFFFFFFFF))
	{
		DPL(0, "Refcount for test %x is screwed!", 1, pTest);
		DEBUGBREAK();
	} // end if (refcount is screwed)

	if (fHaveTestRef)
	{
		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting test object %x.", 1, pTest);
			delete (pTest);
		}  // end if (that was the last reference)
		else
		{
			DPL(7, "Not deleting test object %x, its refcount is %u",
				2, pTest, pTest->m_dwRefCount);
		}  // end if (that was the last reference)
		pTest = NULL;
	} // end if (have test refcount)


	// We always want to free the report message passed in because it's a copy and
	// it was left to us to free it when we're done.
	LocalFree(pReportMsg);


	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNMaster::DoHandleReport
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::ReadFromFile()"
//==================================================================================
// CTNMaster::ReadFromFile
//----------------------------------------------------------------------------------
//
// Description: Reads the passed in text file and loads any tests it contains.
//
// Arguments:
//	char* szFilepath	File to use.
//	DWORD dwNumReps		Number of repetitions to use for tests in the file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::ReadFromFile(char* szFilepath, DWORD dwNumReps)
{
	HRESULT					hr;
	READSCRIPTFILECONTEXT	rsfc;
	CLStringList			startupstrings;
	PTNTESTINSTANCEM		pTest = NULL;


	if ((szFilepath == NULL) || (strcmp(szFilepath, "") == 0))
	{
		DPL(0, "Got passed an invalid filepath!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed an invalid file)

	DPL(0, "Loading tests from file: %s", 1, szFilepath);


	ZeroMemory(&rsfc, sizeof (READSCRIPTFILECONTEXT));
	rsfc.pMaster = this;
	rsfc.dwNumReps = dwNumReps;
	rsfc.pStartupStrings = &startupstrings;
	//rsfc.dwUniqueID = 0;
	//rsfc.pCase = NULL;
	//rsfc.pszInstanceID = NULL;
	//rsfc.pszFriendlyName = NULL;
	//rsfc.fNumMachinesSpecified = FALSE;
	//rsfc.iNumMachines = 0;
	//rsfc.dwPermutationMode = 0;
	////rsfc.dwTestOptions = 0;
	//rsfc.pStoredData = NULL;
	//rsfc.pTesterAssignments = NULL;
	rsfc.iTesterNum = -1;


	hr = FileReadTextFile(szFilepath, FILERTFO_EXTENDEDINIOPTIONS, MasterReadFileCB, &rsfc);
	if (hr != S_OK)
	{
		if (hr == ERROR_FILE_NOT_FOUND)
		{
			DPL(0, "Text file \"%s\" doesn't exist!", 1, szFilepath);
			this->Log(TNLST_CRITICAL, "Text file \"%s\" doesn't exist!",
					1, szFilepath);
		} // end if (couldn't find file)
		else
		{
			DPL(0, "Couldn't read text file \"%s\"!", 1, szFilepath);
			this->Log(TNLST_CRITICAL, "Couldn't read text file \"%s\"!",
					1, szFilepath);
		} // end else (some other error)

		goto DONE;
	} // end if (couldn't read text file)


	// If we hit the end of the file before getting a new section (and thus didn't
	// get to dump the current gathered data into the queue), then we have to do
	// it here (assuming its a valid test).
	hr = this->StoreReadTest(&rsfc);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't store read test!", 0);
		goto DONE;
	} // end if (couldn't store the last test)

	/*
	if (this->m_pfnLoadStartupData != NULL)
	{
		hr = this->m_pfnLoadStartupData(&startupstrings);
		if (hr != S_OK)
		{
			DPL(0, "Module's LoadStartupData callback failed!", 0);
			goto EXIT_ERROR;
		} // end if (module's callback failed)
	} // end if (the module is able to load startup data)
	*/


DONE:
	
	if (rsfc.pszInstanceID != NULL)
	{
		LocalFree(rsfc.pszInstanceID);
		rsfc.pszInstanceID = NULL;
	} // end if (allocated an instance ID)

	if (rsfc.pszFriendlyName != NULL)
	{
		LocalFree(rsfc.pszFriendlyName);
		rsfc.pszFriendlyName = NULL;
	} // end if (allocated a friendly name)

	if (rsfc.pStoredData != NULL)
	{
		delete (rsfc.pStoredData);
		rsfc.pStoredData = NULL;
	} // end if (allocated stored data)

	if (rsfc.pTesterAssignments != NULL)
	{
		delete (rsfc.pTesterAssignments);
		rsfc.pTesterAssignments = NULL;
	} // end if (allocated tester assignments)

	return (hr);
} // CTNMaster::ReadFromFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::StoreReadTest()"
//==================================================================================
// CTNMaster::StoreReadTest
//----------------------------------------------------------------------------------
//
// Description: Compiles the current information and loads a test from it, if
//				possible.
//
// Arguments:
//	PREADSCRIPTFILECONTEXT pData	Pointer to info to use when working with the
//									test.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::StoreReadTest(PREADSCRIPTFILECONTEXT pData)
{
	HRESULT				hr = S_OK;
	PTNTESTFROMFILE		pTest = NULL;


	// If there was a valid item being worked on, commit it.
	if (pData->dwUniqueID != 0)
	{
		if ((pData->pCase != NULL) && (pData->pszInstanceID != NULL))
		{
			// Make sure the mode is appropriate.
			if ((this->m_dwMode == TNMODE_API) &&
				(! (pData->pCase->m_dwOptionFlags & TNTCO_API)))
			{
				DPL(0, "Can't add test \"%s-%s\" because the case did not specify it could be run in API mode!",
					2, pData->pCase->m_pszID, pData->pszInstanceID);
				hr = E_FAIL;
				goto DONE;
			} // end if (API mode not supported)
			else if ((this->m_dwMode == TNMODE_STRESS) &&
					(! (pData->pCase->m_dwOptionFlags & TNTCO_STRESS)))
			{
				DPL(0, "Can't add test \"%s-%s\" because the case did not specify it could be run in stress mode!",
					2, pData->pCase->m_pszID, pData->pszInstanceID);
				hr = E_FAIL;
				goto DONE;
			} // end else if (stress mode not supported)


			// If it's not a test loaded from a script section, search to
			// see if we loaded this test already.

			if (pData->dwUniqueID != 0xFFFFFFFF)
			{
				pTest = (PTNTESTFROMFILE) this->m_loadedtests.GetTest(pData->dwUniqueID);
			} // end if (test ID already committed)

			if (pTest == NULL)
			{
				// If the user specified the number of machines to use...
				if (pData->fNumMachinesSpecified)
				{
					// Make sure the number is valid.
					if (pData->pCase->m_iNumMachines > 0)
					{
						if (pData->iNumMachines != pData->pCase->m_iNumMachines)
						{
							DPL(0, "Can't add test because the case \"%s\" (instance ID \"%s\") requires a different number of testers (%i) from what the user specified (%i)!",
								4, pData->pCase->m_pszID, pData->pszInstanceID,
								pData->pCase->m_iNumMachines, pData->iNumMachines);
							hr = E_FAIL;
							goto DONE;
						} // end if (requestor is working with the wrong number of machines)
					} // end if (exact number of machines required)
					else
					{
						if (pData->iNumMachines <= 0)
						{
							DPL(2, "Using all machines in session to run test case \"%s\" (instance ID \"%s\").",
								2, pData->pCase->m_pszID, pData->pszInstanceID);
						} // end if (all machines indicated)
						else
						{
#pragma BUGBUG(vanceo, "Remove if clause when all tests switch to ADDTESTDATA")
							if (pData->pCase->m_iNumMachines < 0)
							{
								if (pData->iNumMachines < (-1 * pData->pCase->m_iNumMachines))
								{
									DPL(0, "Can't add test because the case \"%s\" (instance ID \"%s\") requires a larger number of testers (%i) from what the user specified (%i)!",
										4, pData->pCase->m_pszID, pData->pszInstanceID,
										(-1 * pData->pCase->m_iNumMachines), pData->iNumMachines);
									hr = E_FAIL;
									goto DONE;
								} // end if (requestor is working with the wrong number of machines)

								pData->pCase->m_iNumMachines = pData->iNumMachines;
							} // end if (minimum number of machines required)

							DPL(2, "Using %i machines to run test case \"%s\" (instance ID \"%s\").",
								3, pData->iNumMachines, pData->pCase->m_pszID,
								pData->pszInstanceID);
						} // end else (specific number of machines indicated)
					} // end else (number of machines can vary)
				} // end if (number of machines wasn't specified)
				else
				{
					// Just use the value the case specifies.  Note that this may
					// still be a special negative token, in which case all 
					// machines will be used.
					pData->iNumMachines = pData->pCase->m_iNumMachines;
				} // end else (the number of machines wasn't specified)

				if (pData->dwUniqueID != 0xFFFFFFFF)
				{
					if (pData->dwPermutationMode != 0)
					{
						DPL(0, "WARNING: Permutation mode set to %u for test %u?  Ignoring and using ONCE.",
							2, pData->dwPermutationMode, pData->dwUniqueID);
						pData->dwPermutationMode = TNTPM_ONCE;
					} // end if (no permutation mode set)
				} // end if (not a script test)
				else
				{
					// If the permutation mode isn't set, assume ONCE.
					if (pData->dwPermutationMode == 0)
					{
						pData->dwPermutationMode = TNTPM_ONCE;
					} // end if (no permutation mode set)
					else
					{
						if (this->m_dwMode == TNMODE_STRESS)
						{
							DPL(0, "WARNING: Permutation mode set to %u for test \"%s-%s\".  Ignoring and using ONCE.",
								3, pData->dwPermutationMode,
								pData->pCase->m_pszID,
								pData->pszInstanceID);

							pData->dwPermutationMode = TNTPM_ONCE;
						} // end if (in stress mode)
					} // end else (permutation mode set)
				} // end else (a script test)

				pTest = new (CTNTestFromFile)(pData->dwUniqueID,
											pData->pCase,
											pData->pszInstanceID,
											pData->pszFriendlyName,
											pData->iNumMachines,
											pData->dwPermutationMode,
											//pData->dwOptions,
											pData->pStoredData,
											pData->pTesterAssignments,
											pData->dwNumReps);
				if (pTest == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate object)

				// The test object owns these now
				pData->pszInstanceID = NULL;
				pData->pszFriendlyName = NULL;
				pData->pStoredData = NULL;
				pData->pTesterAssignments = NULL;


				hr = this->m_loadedtests.Add(pTest);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add test to list!", 0);
					delete (pTest);
					pTest = NULL;
					goto DONE;
				} // end if (couldn't add test)
			} // end if (the test hasn't already been added to the list)
			else
			{
#pragma BUGBUG(vanceo, "Verify that the items (pCase) still match")

				if (pData->pStoredData != NULL)
				{
					if (pTest->m_pStoredDataList == NULL)
					{
						pTest->m_pStoredDataList = new (CTNStoredDataList);
						if (pTest->m_pStoredDataList == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (couldn't allocate object)
					} // end if (there wasn't a stored data list before)

					hr = pTest->m_pStoredDataList->Add(pData->pStoredData);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't load add stored data to test (unique ID = %i)!",
							1, pData->dwUniqueID);
						goto DONE;
					} // end if (couldn't add test to list)
				} // end if (there's an item)
				pData->pStoredData = NULL;

#pragma BUGBUG(vanceo, "Have additive tester assignments?")
			} // end else (it has been added to the list)
		} // end if (we got valid data on a test)
		else
		{
			DPL(0, "WARNING: Not loading test because it is partial or invalid (make sure they have case and sub-case IDs)!", 0);

			this->Log(TNLST_CONTROLLAYER_INFO,
					"WARNING: Not loading test because it is partial or invalid (make sure they have case and sub-case IDs)!", 0);
		} // end else (test data was partial or invalid)
	} // end if (we started a new test)

	
	// Reset these
	pData->dwUniqueID = 0;
	pData->pCase = NULL;

	if (pData->pszInstanceID != NULL)
	{
		LocalFree(pData->pszInstanceID);
		pData->pszInstanceID = NULL;
	} // end if (allocated an instance ID)

	if (pData->pszFriendlyName != NULL)
	{
		LocalFree(pData->pszFriendlyName);
		pData->pszFriendlyName = NULL;
	} // end if (allocated a friendly test name)

	pData->fNumMachinesSpecified = FALSE;
	pData->iNumMachines = -1;
	pData->dwPermutationMode = 0;
	//pData->dwTestOptions = 0;

	if (pData->pStoredData != NULL)
	{
		delete (pData->pStoredData);
		pData->pStoredData = NULL;
	} // end if (allocated stored data)

	if (pData->pTesterAssignments != NULL)
	{
		delete (pData->pTesterAssignments);
		pData->pTesterAssignments = NULL;
	} // end if (have tester assignments)

	pData->iTesterNum = -1; 


DONE:

	return (hr);
} // CTNMaster::StoreReadTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::BuildAPITestList()"
//==================================================================================
// CTNMaster::BuildAPITestList
//----------------------------------------------------------------------------------
//
// Description: Starts up the control session and begins hosting.
//				The slave list lock is assumed to be held with only one level of
//				recursion.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::BuildAPITestList(void)
{
#define MATRIX2D_ELEMENT(pMatrix, iSize1, iSize2, iEntry1, iEntry2)\
						(*(pMatrix + ((iEntry1 * iSize2) + iEntry2)))

#define SLAVETESTERSLOT(iSlave, iTesterNum)\
						MATRIX2D_ELEMENT(paiSlaveTesterSlots, this->m_slaves.Count(),\
										pLoadedTest->m_iNumMachines, iSlave, iTesterNum)			
	
	HRESULT				hr;
	DWORD				dwTime;
	CTNTestMsList		permutations;
	int					iNumLoadedTests;
	int					i;
	int					j;
	int					k;
	int					m;
	int					n;
	int					iBestRanking;
	int					iCurrentRanking;
	PTNTESTFROMFILE		pLoadedTest = NULL;
	PTNTESTINSTANCEM	pTest = NULL;
	PTNTESTINSTANCEM	pCompareTest = NULL;
	int*				paiSlaveTesterSlots = NULL;
	PTNTESTMSLIST*		papSlotRankings = NULL;
	int					iSlaveIndex;
	int					iCompareSlaveIndex;
	BOOL				fFoundSlaveWhoHasRun;
	BOOL				fFoundSlaveWhoHasntRun;
	int					iTimesSlaveHasRunTest;
	int					iTimesCompareSlaveHasRunTest;
	BOOL				fHandled;
	PTNSLAVEINFO		pSlave;
	int					iMaxNumPermutations;
	BOOL				fSkippedSome;


	// Double check to make sure we're not being called at an inappropriate time.
	if (this->m_remainingtests.Count() > 0)
	{
		DPL(0, "Building API test list when %i tests remain in the list!?",
			1, this->m_remainingtests.Count());
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (anything in list)


	iNumLoadedTests = this->m_loadedtests.Count();


	DPL(0, "Building API test list from %i loaded tests.", 1, iNumLoadedTests);
	//Ignore error
	this->Log(TNLST_CONTROLLAYER_INFO, "Building API test list...", 0);

#ifndef _XBOX // timeGetTime not supported
	dwTime = timeGetTime();
#else // XBOX
	dwTime = GetTickCount();
#endif // ! XBOX

	// Loop through all of the currently loaded items once.
	for(i = 0; i < iNumLoadedTests; i++)
	{
		// Pop the first item from the list.
		pLoadedTest = (PTNTESTFROMFILE) this->m_loadedtests.PopFirstItem();
		if (pLoadedTest == NULL)
		{
			DPL(0, "Couldn't pop first loaded test from list!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't pop first item)

		// If there are more repetitions of this item to run, then we need to put it
		// back on the list.  That won't mess up our current for loop because we set
		// the number of iterations in stone.
		if (pLoadedTest->m_dwRepsRemaining != 1)
		{
			// If it's not infinite repetitions, decrement it
			if (pLoadedTest->m_dwRepsRemaining != 0)
				pLoadedTest->m_dwRepsRemaining--;

			// Add it back to the end of the list.
			hr = this->m_loadedtests.Add(pLoadedTest);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't re-add loaded test %x to end of list!",
					1, pLoadedTest);
				goto DONE;
			} // end if (couldn't readd item)
		} // end if (there are repetitions remaining)


		// Build the list of valid permutations for the object
		hr = this->BuildTestPermutationsList(pLoadedTest, &permutations,
											&iMaxNumPermutations);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't build test permutations list!", 0);
			goto DONE;
		} // end if (couldn't build test permutations)


		// If there aren't any valid permutations, skip the test, since the session
		// is closed and there won't ever be any valid permutations.
		if (permutations.Count() <= 0)
		{
			DPL(0, "WARNING: Test \"%s-%s\" was skipped because there aren't any valid permutations!",
				2, pLoadedTest->m_pCase->m_pszID,
				pLoadedTest->m_pszInstanceID);

			this->Log(TNLST_CRITICAL,
					"WARNING: Test \"%s-%s\" was skipped because there aren't any valid permutations!",
					2, pLoadedTest->m_pCase->m_pszID,
					pLoadedTest->m_pszInstanceID);


			// We're going to build a fake test so we can add a report without
			// adding a whole bunch of special case code.
			// Hee hee, isn't this special case code?

			pTest = new (CTNTestInstanceM)(this->m_dwCurrentUniqueID++,
											pLoadedTest,
											pLoadedTest->m_pCase,
											1,
											//0,
											NULL);
			if (pTest == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)

			hr = this->m_skippedtests.Add(pTest);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add test %x to skipped list!", 1, pTest);
				goto DONE;
			} // end if (couldn't add item)


			// Add the skipped test report.
			hr = this->m_reports.AddReport(RT_TESTSKIPPED, 0, NULL,
											pTest, 0, NULL, 0);
			if (hr != S_OK)
			{
				DPL(0, "Failed to add skip report to list!", 0);
				goto DONE;
			} // end if (failed add report)


			pTest = NULL;


			// If we are doing the auto-report thing, and the report we just added
			// is one of the ones we are counting, check to see if that pushed us
			// over the limit.
			if ((this->m_iAutoReportNumReports > 0) &&
				(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
			{
				hr = this->DoAutoReport();
				if (hr != S_OK)
				{
					DPL(0, "Couldn't auto-report!", 0);
					goto DONE;
				} // end if (couldn't print reports)
			} // end if (auto reporting is on and this was a matching report type)
		} // end if (there aren't any permutations)
		else
		{
			// If we're not only using one permutation, we need to check to make
			// sure all the permutations necessary were used.  Otherwise, we need
			// to warn about skipping.
			if (pLoadedTest->m_dwPermutationMode != TNTPM_ONCE)
			{
				fSkippedSome = FALSE;

				if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLPOSSIBLE)
				{
					if (permutations.Count() != iMaxNumPermutations)
					{
						DPL(1, "Loaded test \"%s-%s\" didn't use all permutations (can only run %i of %i) as requested by AllPossible mode.",
							4, pLoadedTest->m_pCase->m_pszID,
							pLoadedTest->m_pszInstanceID,
							permutations.Count(), iMaxNumPermutations);

						fSkippedSome = TRUE;
					} // end if (didn't retrieve all permutations)
				} // end if (all possible)
				else
				{
					// Loop through all the slaves.
					for(j = 0; j < this->m_slaves.Count(); j++)
					{
						pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(j);
						if (pSlave == NULL)
						{
							DPL(0, "Couldn't get slave %i!", 1, j);
							hr = E_FAIL;
							goto DONE;
						} // end if (couldn't get slave)


						if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVES)
						{
							// Loop through all the permutations.
							for(m = 0; m < permutations.Count(); m++)
							{
								pTest = (PTNTESTINSTANCEM) permutations.GetItem(m);
								if (pTest == NULL)
								{
									DPL(0, "Couldn't get permutation %i from list!", 1, m);
									hr = E_FAIL;
									goto DONE;
								} // end if (couldn't get item)


								iSlaveIndex = pTest->GetSlavesTesterNum(pSlave);

								// We only need to make sure the slave ran this
								// test once.  If so, we're done here.
								if (iSlaveIndex >= 0)
									break;
							} // end for (each permutation)
						} // end if (all slaves)
						else if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVESASTESTERS0ANDNON0)
						{
							// Loop through all the permutations.
							for(m = 0; m < permutations.Count(); m++)
							{
								pTest = (PTNTESTINSTANCEM) permutations.GetItem(m);
								if (pTest == NULL)
								{
									DPL(0, "Couldn't get permutation %i from list!", 1, m);
									hr = E_FAIL;
									goto DONE;
								} // end if (couldn't get item)


								iSlaveIndex = pTest->GetSlavesTesterNum(pSlave);

								// We need to make sure the slave ran this test
								// as tester number 0 at least once.  If so, we're
								// done here.
								if (iSlaveIndex >= 0)
									break;
							} // end for (each permutation)


							// If we didn't find a permutation to our liking, we can
							// stop searching.
							if (iSlaveIndex < 0)
								break;


							// Loop through all the permutations again.
							for(m = 0; m < permutations.Count(); m++)
							{
								pTest = (PTNTESTINSTANCEM) permutations.GetItem(m);
								if (pTest == NULL)
								{
									DPL(0, "Couldn't get permutation %i from list!", 1, m);
									hr = E_FAIL;
									goto DONE;
								} // end if (couldn't get item)


								iSlaveIndex = pTest->GetSlavesTesterNum(pSlave);

								// We need to make sure the slave ran this test
								// as a tester number other than 0 at least once.
								// If so, we're done here.
								if (iSlaveIndex >= 0)
									break;
							} // end for (each permutation)
						} // end else if (all slaves as testers 0 and non 0)
						else
						{
							// Loop through all the testing positions.
							for(k = 0; k < pLoadedTest->m_iNumMachines; k++)
							{
								// Loop through all the permutations.
								for(m = 0; m < permutations.Count(); m++)
								{
									pTest = (PTNTESTINSTANCEM) permutations.GetItem(m);
									if (pTest == NULL)
									{
										DPL(0, "Couldn't get permutation %i from list!", 1, m);
										hr = E_FAIL;
										goto DONE;
									} // end if (couldn't get item)

									iSlaveIndex = pTest->GetSlavesTesterNum(pSlave);

									// We need to make sure the slave ran this test
									// once as this tester number.  If so, we're
									// done here.
									if (iSlaveIndex == k)
										break;

									// Otherwise reset this so the check below
									// works.
									iSlaveIndex = -1;
								} // end for (each permutation)

								// If we found a permutation to our liking, we can stop
								// searching.
								if (iSlaveIndex >= 0)
									break;
							} // end for (each testing position)
						} // end else (all slave as all testers)


						// If we didn't find a permutation to our liking, we can
						// stop searching.
						if (iSlaveIndex < 0)
							break;
					} // end for (each tester)


					// If we didn't find a permutation to our liking on the last
					// slave we checked, note the fact that permutations were
					// skipped.
					if (iSlaveIndex < 0)
					{
						// pSlave should still hold the slave which didn't have
						// the permutations.
						DPL(1, "Slave %s didn't have all the permutations for \"%s-%s\" requested for mode %u.",
							4, pSlave->m_szComputerName,
							pLoadedTest->m_pCase->m_pszID,
							pLoadedTest->m_pszInstanceID,
							pLoadedTest->m_dwPermutationMode);

						fSkippedSome = TRUE;
					} // end if (no permutation to our liking)
				} // end else (not all possible)

				if (fSkippedSome)
				{
					DPL(0, "WARNING: Some requested permutations of test \"%s-%s\" were skipped!",
						2, pLoadedTest->m_pCase->m_pszID,
						pLoadedTest->m_pszInstanceID);

					this->Log(TNLST_CRITICAL,
							"WARNING: Some requested permutations of test \"%s-%s\" were skipped!",
							2, pLoadedTest->m_pCase->m_pszID,
							pLoadedTest->m_pszInstanceID);


					// We're going to build a fake test so we can add a report without
					// adding a whole bunch of special case code.
					// Hee hee, isn't this special case code?

					pTest = new (CTNTestInstanceM)(this->m_dwCurrentUniqueID++,
													pLoadedTest,
													pLoadedTest->m_pCase,
													1,
													//0,
													NULL);
					if (pTest == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate object)

					hr = this->m_skippedtests.Add(pTest);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add test %x to skipped list!", 1, pTest);
						goto DONE;
					} // end if (couldn't add item)


					// Add the skipped test report.
					hr = this->m_reports.AddReport(RT_TESTSKIPPED, 0, NULL,
													pTest, 0, NULL, 0);
					if (hr != S_OK)
					{
						DPL(0, "Failed to add skip report to list!", 0);
						goto DONE;
					} // end if (failed add report)


					pTest = NULL;


					// If we are doing the auto-report thing, and the report we just added
					// is one of the ones we are counting, check to see if that pushed us
					// over the limit.
					if ((this->m_iAutoReportNumReports > 0) &&
						(this->m_dwAutoReportFlags & TNREPORT_NONTESTREPORTS))
					{
						hr = this->DoAutoReport();
						if (hr != S_OK)
						{
							DPL(0, "Couldn't auto-report!", 0);
							goto DONE;
						} // end if (couldn't print reports)
					} // end if (auto reporting is on and this was a matching report type)
				} // end if (there aren't any permutations)
			} // end if (not once permutation mode)

			// If this is a run once test, then we only need to run the first
			// permutation.  If we want to run all possible, then just copy all of
			// the permutations.
			if ((pLoadedTest->m_dwPermutationMode == TNTPM_ONCE) ||
				(pLoadedTest->m_dwPermutationMode == TNTPM_ALLPOSSIBLE))
			{
				// Loop until we've handled each permutation generated.
				do
				{
					// Pop the first item from the list.
					pTest = (PTNTESTINSTANCEM) permutations.PopFirstItem();
					if (pTest == NULL)
					{
						DPL(0, "Couldn't pop first remaining permutation from list!", 0);
						hr = E_FAIL;
						goto DONE;
					} // end if (couldn't pop first item)

					// Assign it a valid ID.
					pTest->m_dwUniqueID = this->m_dwCurrentUniqueID++;

					// Add it to the list of tests to run.
					hr = this->m_remainingtests.Add(pTest);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add first permutation to list!", 0);
						goto DONE;
					} // end if (couldn't add remaining tests)

					pTest->m_dwRefCount--;
					if (pTest->m_dwRefCount == 0)
					{
						DPL(0, "Deleting first permutation object %x!?",
							1, pTest);
						delete (pTest);
					} // end if (should delete object)
					pTest = NULL;

					// If we're only running one permutation, dump the rest.
					if (pLoadedTest->m_dwPermutationMode == TNTPM_ONCE)
					{
						DPL(1, "Removing %i extra permutations of test \"%s-%s\" because the permutation mode is TNTPM_ONCE.",
							3, permutations.Count(),
							pLoadedTest->m_pCase->m_pszID,
							pLoadedTest->m_pszInstanceID);

						// Remove all the other permutations.
						hr = permutations.RemoveAll();
						if (hr != S_OK)
						{
							DPL(0, "Couldn't remove all remaining permutations!", 0);
							goto DONE;
						} // end if (couldn't remove all)
					} // end if (only running once)
				} // end do (while there are more permutations)
				while (permutations.Count() > 0);
			} // end if (only need one permutation)
			else
			{
				// Build a two-dimensional matrix of slaves and tester slots.
				paiSlaveTesterSlots = (int*) LocalAlloc(LPTR, (this->m_slaves.Count() * pLoadedTest->m_iNumMachines * sizeof (int)));
				if (paiSlaveTesterSlots == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				// Build an array of list pointers that we'll use to rank the
				// remaining permutations by the values in the previous array.
				papSlotRankings = (PTNTESTMSLIST*) LocalAlloc(LPTR, (pLoadedTest->m_iNumMachines * sizeof (PTNTESTMSLIST)));
				if (papSlotRankings == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)


				// Loop until we've handled each permutation generated.
				do
				{
					// Reset the ranking array.
					for(j = 0; j < pLoadedTest->m_iNumMachines; j++)
					{
						// If the slot doesn't have a list, create one,
						// otherwise reset it.
						if (papSlotRankings[j] == NULL)
						{
							papSlotRankings[j] = new (CTNTestMsList);
							if (papSlotRankings[j] == NULL)
							{
								hr = E_OUTOFMEMORY;
								goto DONE;
							} // end if (couldn't allocate object)
						} // end if (need new object)
						else
						{
							hr = papSlotRankings[j]->RemoveAll();
							if (hr != S_OK)
							{
								DPL(0, "Couldn't remove all items in the list!", 0);
								goto DONE;
							} // end if (couldn't remove all items)
						} // end else (already have object)
					} // end for (each slot)

					fHandled = FALSE;


					// Loop through each permutation left.
					for(j = 0; j < permutations.Count(); j++)
					{
						pTest = (PTNTESTINSTANCEM) permutations.GetItem(j);
						if (pTest == NULL)
						{
							DPL(0, "Couldn't get permutation %i from list!", 1, j);
							hr = E_FAIL;
							goto DONE;
						} // end if (couldn't get item)

						fFoundSlaveWhoHasRun = FALSE;
						fFoundSlaveWhoHasntRun = FALSE;

						for(k = 0; k < pLoadedTest->m_iNumMachines; k++)
						{
							iSlaveIndex = this->m_slaves.GetFirstIndex(pTest->m_paTesterSlots[k].pSlave);
							if (iSlaveIndex < 0)
							{
								DPL(0, "Couldn't get slave index of %s!",
									1, pTest->m_paTesterSlots[k].pSlave->m_szComputerName);
								hr = E_FAIL;
								goto DONE;
							} // end if (couldn't get index)

							if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVES)
							{
								iTimesSlaveHasRunTest = 0;

								// Calculate how many times this slave has run this
								// test in any position.
								for(m = 0; m < pLoadedTest->m_iNumMachines; m++)
								{
									iTimesSlaveHasRunTest += SLAVETESTERSLOT(iSlaveIndex, m);
								} // end for (each testing slot)

								if (iTimesSlaveHasRunTest > 0)
									fFoundSlaveWhoHasRun = TRUE;
								else
									fFoundSlaveWhoHasntRun = TRUE;
							} // end if (in ALLSLAVES mode)
							else if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVESASTESTERS0ANDNON0)
							{
								// Note whether this slave has run the test as
								// tester 0 or tester number other than 0 yet.
								if (k == 0)
								{
									// Tester 0, so look for other tester 0 runs.

									if (SLAVETESTERSLOT(iSlaveIndex, 0) != 0)
										fFoundSlaveWhoHasRun = TRUE;
									else
										fFoundSlaveWhoHasntRun = TRUE;
								} // end if (tester 0)
								else
								{
									// Not tester 0, so look for other non-tester 0
									// runs.

									iTimesSlaveHasRunTest = 0;

									// Calculate how many times this slave has run
									// this test in a non-0 position.
									for(m = 1; m < pLoadedTest->m_iNumMachines; m++)
									{
										iTimesSlaveHasRunTest += SLAVETESTERSLOT(iSlaveIndex, m);
									} // end for (each testing slot)

									if (iTimesSlaveHasRunTest > 0)
										fFoundSlaveWhoHasRun = TRUE;
									else
										fFoundSlaveWhoHasntRun = TRUE;
								} // end else (not tester 0)
							} // end else if (in ALLSLAVESASTESTERS0ANDNON0 mode)
							else
							{
								// Note whether this slave has run the test in this
								// position yet.
								if (SLAVETESTERSLOT(iSlaveIndex, k) != 0)
									fFoundSlaveWhoHasRun = TRUE;
								else
									fFoundSlaveWhoHasntRun = TRUE;
							} // end else (in ALLSLAVESASALLTESTERS mode)
						} // end for (each tester slot)


						// If every slave in this permutation has never run this
						// test (specifically as tester 0 & non-tester 0, if in
						// ALLSLAVESASTESTERS0ANDNO0 permutation mode, or as that
						// tester number, if in ALLSLAVESASALLTESTERS permutation
						// mode), we found one we want to use.
						if (! fFoundSlaveWhoHasRun)
						{
							if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVES)
							{
								DPL(1, "Using permutation %x of test \"%s-%s\" because it has not been run by any of those slaves yet.",
									3, pTest,
									pLoadedTest->m_pCase->m_pszID,
									pLoadedTest->m_pszInstanceID);
							} // end if (all slaves)
							else if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVESASTESTERS0ANDNON0)
							{
								DPL(1, "Using permutation %x of test \"%s-%s\" because it has not been run by %s as tester 0 or by one of the other slaves in a non-tester-0 position yet.",
									4, pTest, pLoadedTest->m_pCase->m_pszID,
									pLoadedTest->m_pszInstanceID,
									pTest->m_paTesterSlots[0].pSlave->m_szComputerName);
							} // end else if (all slaves as tester 0 and non 0)
							else
							{
								DPL(1, "Using permutation %x of test \"%s-%s\" because it has not been run by any of those slaves in those tester positions yet.",
									3, pTest, pLoadedTest->m_pCase->m_pszID,
									pLoadedTest->m_pszInstanceID);
							} // end else (all slaves as all testers)


							fHandled = TRUE;

							// Stop looking at each permutation.
							break;
						} // end if (everyone has not run as tester)
						else if (! fFoundSlaveWhoHasntRun)
						{
							// If every slave in this permutation has already run
							// this test (as that tester number, if in
							// ALLSLAVESASALLTESTERS permutation mode) at least
							// once, we want to pull this permutation from the
							// list.  We don't want to bother running duplicate
							// permutations.

							if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVES)
							{
								DPL(1, "Removing extra permutation %x of test \"%s-%s\" because it has already been run by all of those slaves at least once.",
									3, pTest, pLoadedTest->m_pCase->m_pszID,
									pLoadedTest->m_pszInstanceID);
							} // end if (all slaves)
							else if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVESASTESTERS0ANDNON0)
							{
								DPL(1, "Removing extra permutation %x of test \"%s-%s\" because it has already been run as tester number 0 and non-0 by all of those slaves at least once.",
									3, pTest, pLoadedTest->m_pCase->m_pszID,
									pLoadedTest->m_pszInstanceID);
							} // end else if (all slaves as testers 0 and non 0)
							else
							{
								DPL(1, "Removing extra permutation %x of test \"%s-%s\" because it has already been run by all of those slaves in those tester positions at least once.",
									3, pTest, pLoadedTest->m_pCase->m_pszID,
									pLoadedTest->m_pszInstanceID);
							} // end else (all slaves as all testers)


							// Remove the permutation we're looking at from the
							// list of remaining ones.
							hr = permutations.Remove(j);
							if (hr != S_OK)
							{
								DPL(0, "Couldn't remove permutation %i!", 1, j);
								goto DONE;
							} // end if (couldn't remove item)

							// Have to decrement so we don't screw up our counter.
							// A little ugly, but oh well.
							j--;

							pTest = NULL; // for safety's sake
						} // end else if (not everyone has run as tester)
						else
						{
							// If we are here, some people have run the permutation
							// (as that tester number, if in ALLSLAVESASALLTESTERS
							// mode), and some haven't.  Loop back through the tester
							// slots and rank this test for each, with people running
							// the fewest times first (so we get as even a
							// distribution as possible).
							for(k = 0; k < pLoadedTest->m_iNumMachines; k++)
							{
								iSlaveIndex = this->m_slaves.GetFirstIndex(pTest->m_paTesterSlots[k].pSlave);
								if (iSlaveIndex < 0)
								{
									DPL(0, "Couldn't get slave index of %s!",
										1, pTest->m_paTesterSlots[k].pSlave->m_szComputerName);
									hr = E_FAIL;
									goto DONE;
								} // end if (couldn't get index)

								if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVES)
								{
									iTimesSlaveHasRunTest = 0;

									// Calculate how many times that slave has run the
									// test in any position.
									for(n = 0; n < pLoadedTest->m_iNumMachines; n++)
									{
										iTimesSlaveHasRunTest += SLAVETESTERSLOT(iSlaveIndex, n);
									} // end for (each testing slot)
								} // end if (in ALLSLAVES permutation mode)
								else if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVESASTESTERS0ANDNON0)
								{
									iTimesSlaveHasRunTest = 0;

									// Calculate how many times that slave has run the
									// test in a non-tester 0 position.
									for(n = 1; n < pLoadedTest->m_iNumMachines; n++)
									{
										iTimesSlaveHasRunTest += SLAVETESTERSLOT(iSlaveIndex, n);
									} // end for (each testing slot)
								} // end if (in TNTPM_ALLSLAVESASTESTERS0ANDNON0 permutation mode)


								// Loop through all the previous permutations we've
								// looked at and insert this current one in order
								// into the ranking list.
								for(m = 0; m < j; m++)
								{
									pCompareTest = (PTNTESTINSTANCEM) papSlotRankings[k]->GetItem(m);
									if (pCompareTest == NULL)
									{
										DPL(0, "Couldn't get test to compare %i from ranking list!",
											1, m);
										hr = E_FAIL;
										goto DONE;
									} // end if (couldn't get item)

									iCompareSlaveIndex = this->m_slaves.GetFirstIndex(pCompareTest->m_paTesterSlots[k].pSlave);
									if (iCompareSlaveIndex < 0)
									{
										DPL(0, "Couldn't get compare slave index of %s!",
											1, pCompareTest->m_paTesterSlots[k].pSlave->m_szComputerName);
										hr = E_FAIL;
										goto DONE;
									} // end if (couldn't get index)

									if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVES)
									{
										iTimesCompareSlaveHasRunTest = 0;

										// Calculate how many times that slave has run the
										// test in any position.
										for(n = 0; n < pLoadedTest->m_iNumMachines; n++)
										{
											iTimesCompareSlaveHasRunTest += SLAVETESTERSLOT(iCompareSlaveIndex, n);
										} // end for (each testing slot)
									} // end if (in ALLSLAVES permutation mode)
									else if (pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVESASTESTERS0ANDNON0)
									{
										iTimesCompareSlaveHasRunTest = 0;

										// Calculate how many times that slave has run the
										// test in a non-tester 0 position.
										for(n = 1; n < pLoadedTest->m_iNumMachines; n++)
										{
											iTimesCompareSlaveHasRunTest += SLAVETESTERSLOT(iCompareSlaveIndex, n);
										} // end for (each testing slot)
									} // end if (in TNTPM_ALLSLAVESASTESTERS0ANDNON0 permutation mode)


#pragma TODO(vanceo, "Double check testers 0 and non 0 logic (is it really ranking correctly?)")

									// If this previous test was run more times than our
									// current test, insert the current test before it.
									if (((pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVES) &&
											(iTimesCompareSlaveHasRunTest > iTimesSlaveHasRunTest)) ||

										((pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVESASTESTERS0ANDNON0) &&
											(SLAVETESTERSLOT(iCompareSlaveIndex, 0) > SLAVETESTERSLOT(iSlaveIndex, 0)) &&
											(iTimesCompareSlaveHasRunTest > iTimesSlaveHasRunTest)) ||

										((pLoadedTest->m_dwPermutationMode == TNTPM_ALLSLAVESASALLTESTERS) &&
											(SLAVETESTERSLOT(iCompareSlaveIndex, k) > SLAVETESTERSLOT(iSlaveIndex, k))))
									{
										hr = papSlotRankings[k]->InsertBeforeIndex(pTest, m);
										if (hr != S_OK)
										{
											DPL(0, "Couldn't insert permutation %i into ranking list before %i!",
												2, j, m);
											goto DONE;
										} // end if (couldn't add item)

										fHandled = TRUE;
										break;
									} // end if (previous test run more times than current)
								} // end for (each previous test)

								// If we found a place to insert into the ranking, just
								// reset the boolean so we don't screw up our outer
								// loop below.
								// If we didn't find a place, just add it at the end.
								if (fHandled)
								{
									fHandled = FALSE;
								} // end if (inserted test)
								else
								{
									hr = papSlotRankings[k]->Add(pTest);
									if (hr != S_OK)
									{
										DPL(0, "Couldn't add permutation %i (%x) to end of ranking list!",
											2, j, pTest);
										goto DONE;
									} // end if (couldn't add item)
								} // end else (didn't insert test)
							} // end for (each tester slot)

							pTest = NULL; // for safety's sake
						} // end else (it's a mixed bag)
					} // end for (each permutation)


					// If all of the permutations left were removed, then it
					// looks like we're done.  Get out of the do-while loop.
					if (permutations.Count() <= 0)
						break;


					// If we looped through all the permutations but didn't find
					// an easy one with all 0 usages, we need to use the best
					// possible permutation (most slaves with the fewest times in
					// each position).  We generated the rankings above as we went
					// along.
					if (! fHandled)
					{
						// Reset our current champion and his rating.
						pCompareTest = NULL;
						iBestRanking = 0;

						// Loop through each remaining permutation.
						for(j = 0; j < permutations.Count(); j++)
						{
							pTest = (PTNTESTINSTANCEM) permutations.GetItem(j);
							if (pTest == NULL)
							{
								DPL(0, "Couldn't get permutation %i from list!", 1, j);
								hr = E_FAIL;
								goto DONE;
							} // end if (couldn't get item)

							iCurrentRanking = 0;

							// Loop through each tester slot.
							for(k = 0; k < pLoadedTest->m_iNumMachines; k++)
							{
								m = papSlotRankings[k]->GetFirstIndex(pTest);
								if (m < 0)
								{
									DPL(0, "Couldn't find test %x (%u) in slot %i rankings!?",
										3, pTest, pTest->m_dwUniqueID, k);

									DEBUGBREAK();

									hr = E_FAIL;
									goto DONE;
								} // end if (couldn't find test)

								// Increase the ranking based on its order for
								// this slot.
								iCurrentRanking += m;

								// If the ranking is now over the best so far,
								// there's no point in continuing, it already
								// lost.  If this is the first item, then skip
								// this check.
								if ((pCompareTest != NULL) &&
									(iCurrentRanking > iBestRanking))
								{
									break;
								} // end if (started ranking and this is worse)
							} // end for (each tester slot)

							// If this is the first item, or the total ranking is
							// the best so far, save it.
							if ((pCompareTest == NULL) ||
								(iCurrentRanking < iBestRanking))
							{
								pCompareTest = pTest;
								iBestRanking = iCurrentRanking;
							} // end if (started ranking and this is worse)
						} // end for (each permutation)


						pTest = pCompareTest;

						DPL(7, "Permutation %x has the best ranking (%i).",
							2, pTest, iBestRanking);
					} // end if (didn't find an easy one)


					// pTest should now hold the one we want to use


					// Assign it a valid ID.
					pTest->m_dwUniqueID = this->m_dwCurrentUniqueID++;

					// Add it to the list of tests to run.
					hr = this->m_remainingtests.Add(pTest);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add permutation %x to list!",
							1, pTest);
						goto DONE;
					} // end if (couldn't add remaining tests)

					// Update the array of slave & slot usage.
					for(j = 0; j < pLoadedTest->m_iNumMachines; j++)
					{
						iSlaveIndex = this->m_slaves.GetFirstIndex(pTest->m_paTesterSlots[j].pSlave);
						if (iSlaveIndex < 0)
						{
							DPL(0, "Couldn't get slave index of %s!",
								1, pTest->m_paTesterSlots[j].pSlave->m_szComputerName);
							hr = E_FAIL;
							goto DONE;
						} // end if (couldn't get index)

						SLAVETESTERSLOT(iSlaveIndex, j)++;
					} // end for (each tester slot)

					// Remove it from the list of remaining ones.
					hr = permutations.RemoveFirstReference(pTest);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't remove permutation %x from remaining permutations list!",
							1, pTest);
						goto DONE;
					} // end if (couldn't remove item)

#ifdef DEBUG
					if (pTest->m_dwRefCount == 0)
					{
						DPL(0, "Deleting permutation %x because it has a refcount of 0!?",
							1, pTest);

						DEBUGBREAK();

						delete (pTest);
						pTest = NULL;
					} // end if (should delete item)
#endif // DEBUG
				} // end do (while there are more permutations)
				while (permutations.Count() > 0);


				// Cleanup

				LocalFree(paiSlaveTesterSlots);
				paiSlaveTesterSlots = NULL;

				// Delete the slot ranking lists.
				for(j = 0; j < pLoadedTest->m_iNumMachines; j++)
				{
					if (papSlotRankings[j] != NULL)
					{
						delete (papSlotRankings[j]);
						papSlotRankings[j] = NULL;
					} // end if (there's a list pointer there)
				} // end for (each tester slot)

				LocalFree(papSlotRankings);
				papSlotRankings = NULL;
			} // end else (other permutation mode)
		} // end else (there are permutations)


		// Take off our ref.
		pLoadedTest->m_dwRefCount--;
		if (pLoadedTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting loaded test %x.", 1, pLoadedTest);
			delete (pLoadedTest);
		} // end if (should delete object)
		else
		{
			DPL(7, "Not deleting loaded test %x, its refcount is %u.",
				2, pLoadedTest, pLoadedTest->m_dwRefCount);
		} // end else (shouldn't delete object)

		pLoadedTest = NULL;
	} // end for (each loaded test)


#ifndef _XBOX // timeGetTime not supported
	DPL(1, "Built API test list containing %i total test permutation(s) from %i loaded test(s), %u ms elapsed.",
		3, this->m_remainingtests.Count(), iNumLoadedTests,
		timeGetTime() - dwTime);
#else // ! XBOX
	DPL(1, "Built API test list containing %i total test permutation(s) from %i loaded test(s), %u ms elapsed.",
		3, this->m_remainingtests.Count(), iNumLoadedTests,
		GetTickCount() - dwTime);
#endif // XBOX

	// Ignore error
	this->Log(TNLST_CONTROLLAYER_INFO,
			"...Built API test list containing %i total test permutatio%s from %i loaded tes%s.",
			4, this->m_remainingtests.Count(),
			((this->m_remainingtests.Count() != 1) ? "ns" : "n"),
			iNumLoadedTests,
			((iNumLoadedTests != 1) ? "ts" : "t"));


	// If there aren't any valid permutations this time around, nobody will
	// be able to run any further repetitions either, so might as remove
	// all remaining repetitions (they would have already been marked as
	// skipped above).
	if (this->m_remainingtests.Count() == 0)
	{
		DPL(0, "WARNING: Removing all %i loaded tests from list.",
			1, this->m_loadedtests.Count());

		hr = this->m_loadedtests.RemoveAll();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove all remaining loaded tests from list!", 0);
			goto DONE;
		} // end if (couldn't get first item)
	} // end if (didn't get any permutations)
#if 0
#pragma BUGBUG(vanceo, "               DISABLE THIS WHEN DONE DEBUGGING")
	else
	{
		for(i = 0; i < this->m_remainingtests.Count(); i++)
		{
			pTest = (PTNTESTINSTANCEM) this->m_remainingtests.GetItem(i);

			DPL(0, "Test %u (%x, \"%s-%s\", %i machines):",
				5, pTest->m_dwUniqueID,
				pTest,
				pTest->m_pCase->m_pszID,
				pTest->m_pLoadedTest->m_pszInstanceID,
				pTest->m_iNumMachines);

			for(j = 0; j < pTest->m_iNumMachines; j++)
			{
				DPL(0, "     %i=%s (%x, ID %u, refcount %u)",
					5, j,
					pTest->m_paTesterSlots[j].pSlave->m_szComputerName,
					pTest->m_paTesterSlots[j].pSlave,
					pTest->m_paTesterSlots[j].pSlave->m_id.dwTime,
					pTest->m_paTesterSlots[j].pSlave->m_dwRefCount);
			} // end for (each tester slot)
		} // end for (each test)
	} // end else (did get permutations)
#endif



DONE:

	if (paiSlaveTesterSlots != NULL)
	{
		LocalFree(paiSlaveTesterSlots);
		paiSlaveTesterSlots = NULL;
	} // end if (allocated array)

	if (papSlotRankings != NULL)
	{
		if (pLoadedTest == NULL)
		{
			DPL(0, "WARNING: Loaded test pointer is NULL!  Assuming no slot ranking lists!", 0);
		} // end if (no loaded test pointer)
		else
		{
			// Delete the slot ranking lists.
			for(i = 0; i < pLoadedTest->m_iNumMachines; i++)
			{
				if (papSlotRankings[i] != NULL)
				{
					delete (papSlotRankings[i]);
					papSlotRankings[i] = NULL;
				} // end if (there's a list pointer there)
			} // end for (each tester slot)
		} // end else (loaded test pointer)

		LocalFree(papSlotRankings);
		papSlotRankings = NULL;
	} // end if (allocated array)


	// If we still have the popped test object, take off our ref.
	if (pLoadedTest != NULL)
	{
		pLoadedTest->m_dwRefCount--;
		if (pLoadedTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting loaded test %x.", 1, pLoadedTest);
			delete (pLoadedTest);
		} // end if (should delete object)
		else
		{
			DPL(7, "Not deleting loaded test %x, its refcount is %u.",
				2, pLoadedTest, pLoadedTest->m_dwRefCount);
		} // end else (shouldn't delete object)

		pLoadedTest = NULL;
	} // end if (still have loaded test object)

	return (hr);


#undef SLAVETESTERSLOT
#undef MATRIX2D_ELEMENT

} // CTNMaster::BuildAPITestList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::BuildTestPermutationsList()"
//==================================================================================
// CTNMaster::BuildTestPermutationsList
//----------------------------------------------------------------------------------
//
// Description: Fills the passed in list with all the valid permutations of the
//				given test.  All slaves currently in the session are used.  The
//				module's CanRun function is called, if it exists, to weed out any
//				possibilities that won't work.
//				It's important to note that the tests in the list will NOT have
//				valid test IDs, and that value stored in piMaxNumPermutations will
//				not be valid for TNTPM_ONCE tests.
//				The slave list lock is assumed to be held with only one level of
//				recursion.
//
// Arguments:
//	PTNTESTFROMFILE pBaseTest	Pointer to test to permute.
//	PTNTESTMSLIST pTestList		List to place results in.
//	int* piMaxNumPermutations	Place to store maximum number of permutations that
//								could be used (not necessarily number of items
//								actually in built test list).
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::BuildTestPermutationsList(PTNTESTFROMFILE pBaseTest,
											PTNTESTMSLIST pTestList,
											int* piMaxNumPermutations)
{
	HRESULT				hr = S_OK;
	BOOL				fUsingMaxNumSlaves = FALSE;
	PTNSLAVESLIST*		papPossibleSlaves = NULL;
	PTNSLAVEINFO*		papTesters = NULL;
	PTNSLAVEINFO		pSlave = NULL;
	int					i;
	int					j;
	int					k;
	int					iTesterNum;
	PLSTRING			pAssignString;
	char*				pszTemp = NULL;
	char*				pszValue;
	BOOL				fInvertAssign;
	DWORD				dwTempSize;
	DWORD				dwNumFields;


	// Start by resetting the count.
	(*piMaxNumPermutations) = 0;


	// If the loaded test wants to use all slaves in the session, we want to note
	// that.
	if (pBaseTest->m_iNumMachines <= 0)
	{
		fUsingMaxNumSlaves = TRUE;
		pBaseTest->m_iNumMachines = this->m_slaves.Count();

#ifdef DEBUG
		if (pBaseTest->m_pCase->m_iNumMachines > 0)
		{
			// This case should have been caught when test was loaded.
			DPL(0, "Arbitrary number of machines specified when case requires specific number (%i)!?  DEBUGBREAK()-ing.",
				1, pBaseTest->m_pCase->m_iNumMachines);
			DEBUGBREAK();
		} // end if (specific number of machines required)
		else
		{
#endif // DEBUG
#pragma BUGBUG(vanceo, "Remove first if part when all tests switch to ADDTESTDATA")
			if ((pBaseTest->m_pCase->m_iNumMachines < 0) &&
				(pBaseTest->m_iNumMachines < (-1 * pBaseTest->m_pCase->m_iNumMachines)))
			{
				DPL(1, "Not enough machines to even run \"%s-%s\" (requires at least %i, there are %i slaves), not permuting.",
					4, pBaseTest->m_pCase->m_pszID, pBaseTest->m_pszInstanceID,
					pBaseTest->m_pCase->m_iNumMachines, pBaseTest->m_iNumMachines);
				goto DONE;
			} // end if (minimum number of machines required)
#ifdef DEBUG
		} // end else (not specific number of machines required)
#endif // DEBUG

		DPL(8, "Loaded test \"%s-%s\" will be permutated with all %i slaves currently in session.",
			3, pBaseTest->m_pCase->m_pszID, pBaseTest->m_pszInstanceID,
			pBaseTest->m_iNumMachines);
	} // end if (should use max num slaves)
	else
	{
		if (this->m_slaves.Count() < pBaseTest->m_iNumMachines)
		{
			DPL(1, "Not enough machines to even run \"%s-%s\" (requires exactly %i, there are %i slaves), not permuting.",
				4, pBaseTest->m_pCase->m_pszID, pBaseTest->m_pszInstanceID,
				pBaseTest->m_iNumMachines, this->m_slaves.Count());
			goto DONE;
		} // end if (not enough machines)
	} // end else (number of machines specified)


	// Array of lists of slave possibilities for each testing slot.
	papPossibleSlaves = (PTNSLAVESLIST*) LocalAlloc(LPTR, (pBaseTest->m_iNumMachines * sizeof (PTNSLAVESLIST)));
	if (papPossibleSlaves == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Storage space for particular permutation setup array.
	papTesters = (PTNSLAVEINFO*) LocalAlloc(LPTR, (pBaseTest->m_iNumMachines * sizeof (PTNSLAVEINFO)));
	if (papTesters == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	
	for(i = 0; i < pBaseTest->m_iNumMachines; i++)
	{
		papPossibleSlaves[i] = new (CTNSlavesList);
		if (papPossibleSlaves[i] == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)


		// If the user specified specific testing assignments for this test,
		// we need to take those into consideration.  Otherwise, just copy all
		// the possible slaves into the list.

		// Set this to NULL.  We use this to key off of whether we found an
		// assignment for this tester slot or not.  Somewhat obscure, but I'm
		// documenting it here, okay?
		pszValue = NULL;

		if (pBaseTest->m_pTesterAssignments != NULL)
		{
			for (j = 0; j < pBaseTest->m_pTesterAssignments->Count(); j++)
			{
				pAssignString = (PLSTRING) pBaseTest->m_pTesterAssignments->GetItem(j);
				if (pAssignString == NULL)
				{
					DPL(0, "Couldn't get tester assignment string %i!", 1, j);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get an item)


				// Allocate a string with plenty of room for the key (it can't
				// be larger than the entire string, so use that size).
				pszTemp = (char*) LocalAlloc(LPTR, (strlen(pAssignString->GetString()) + 1));
				if (pszTemp == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				StringGetKey(pAssignString->GetString(), pszTemp);
				if (strcmp(pszTemp, "") == 0)
				{
					DPL(0, "Tester number for tester assignment string %i (\"%s\") is invalid!",
						2, i, pAssignString->GetString());
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get strings key value)

				if (StringStartsWith(pszTemp, "~", TRUE))
				{
					// Skip the tilde
					iTesterNum = StringToInt(pszTemp + 1);
					fInvertAssign = TRUE;
				} // end if (it's a negative assignment)
				else
				{
					iTesterNum = StringToInt(pszTemp);
					fInvertAssign = FALSE;
				} // end else (it's a positive assignment)

				LocalFree(pszTemp);
				pszTemp = NULL;


				// If this assignment string refers to some other slot, skip it.
				if (iTesterNum != i)
					continue;


				pszValue = pAssignString->GetKeyValue();
				if (pszValue == NULL)
				{
					DPL(0, "Couldn't get slave name for tester assignment string %i (\"%s\")!",
						2, i, pAssignString->GetString());
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't get strings key value)

				//Ignore error, assume BUFFER_TOO_SMALL
				this->ExpandBuiltinStringVars(pszValue, NULL, &dwTempSize);

				pszTemp = (char*) LocalAlloc(LPTR, dwTempSize);
				if (pszTemp == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				hr = this->ExpandBuiltinStringVars(pszValue, pszTemp, &dwTempSize);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't expand built-in string vars in \"%s\"!",
						1, pszValue);
					goto DONE;
				} // end if (couldn't expand built-in vars)


				// This destroys the original string, but we don't care since
				// it's a temp buffer anyway.
				dwNumFields = StringSplitIntoFields(pszTemp, "; ", pszTemp, &dwTempSize);

				// If it's inverted, we want to build a list with everyone but
				// the specified slaves.  If it's normal, build a list with only
				// the specified slaves.
				for(k = 0; k < this->m_slaves.Count(); k++)
				{
					pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(k);
					if (pSlave == NULL)
					{
						DPL(0, "Couldn't get slave %i!", 1, k);
						hr = E_FAIL;
						goto DONE;
					} // end if (the other slave doesn't exist)

					// Reuse the temp size variable
					for(dwTempSize = 0; dwTempSize < dwNumFields; dwTempSize++)
					{
						// We xor here:
						// if we're not invert assigning and we matched the name,
						// or we are invert assigning but we didn't match the name,
						// then we want to add the slave to the list.
						if ((fInvertAssign) ^
							(StringCmpNoCase(StringGetFieldPtr(pszTemp, dwTempSize), pSlave->m_szComputerName)))
						{
							hr = papPossibleSlaves[i]->Add(pSlave);
							if (hr != S_OK)
							{
								DPL(0, "Couldn't add slave %s to list!",
									1, pSlave->m_szComputerName);
								goto DONE;
							} // end if (couldn't allocate object)
						} // end if (should copy slave)
					} // end for (each name)
				} // end for (each slave currently in the session)

				// We only handle 1 assignment string for each tester slot,
				// so stop looping since we've got one.
				break;
			} // end for (each testing assignment)
		} // end if (there are testing assignments)


		// pszValue will still be NULL if we didn't have any tester assignments
		// to check, or we did but didn't find anything pertaining to this tester
		// slot, so we have to build the generic list of usual suspects (i.e.
		// everybody).
		if (pszValue == NULL)
		{
			for(j = 0; j < this->m_slaves.Count(); j++)
			{
				pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(j);
				if (pSlave == NULL)
				{
					DPL(0, "Couldn't get slave %i!", j);
					hr = E_FAIL;
					goto DONE;
				} // end if (the other slave doesn't exist)

				// Just add the slave.
				hr = papPossibleSlaves[i]->Add(pSlave);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add slave %s to list!",
						1, pSlave->m_szComputerName);
					goto DONE;
				} // end if (couldn't allocate object)
			} // end for (each slave currently in the session)
		} // end else (there aren't related testing assignments)

		// If we didn't find any potential slaves for this tester slot, we
		// can't permute this test.  Bail.
		if (papPossibleSlaves[i]->Count() <= 0)
		{
			DPL(1, "No potential slaves for tester slot %i.", 1, i);
			goto DONE;
		} // end if (we didn't find any slaves for this list)
	} // end for (each testing slot)


	// If we got here, then all the slots had some possibilities.  Kick off
	// the recursion at slot 0.
	hr = this->PermuteRemainingSlots(pBaseTest, 0, papTesters,
									papPossibleSlaves, pTestList,
									piMaxNumPermutations);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't permute the slots!", 0);
		goto DONE;
	} // end if (couldn't permute remaining slots)


	DPL(1, "Built %i permutations for test \"%s-%s\".",
		3, pTestList->Count(), pBaseTest->m_pCase->m_pszID,
		pBaseTest->m_pszInstanceID);


DONE:

	if (papPossibleSlaves != NULL)
	{
		for(i = 0; i < pBaseTest->m_iNumMachines; i++)
		{
			if (papPossibleSlaves[i] != NULL)
			{
				delete (papPossibleSlaves[i]);
				papPossibleSlaves[i] = NULL;
			} // end if (allocated list for slot)
		} // end for (each tester slot)

		LocalFree(papPossibleSlaves);
		papPossibleSlaves = NULL;
	} // end if (allocated memory)

	if (papTesters != NULL)
	{
		LocalFree(papTesters);
		papTesters = NULL;
	} // end if (allocated memory)

	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (allocated string)

	if (fUsingMaxNumSlaves)
	{
		pBaseTest->m_iNumMachines = 0;
		fUsingMaxNumSlaves = FALSE;
	} // end if (used max num slaves)

	return (hr);
} // CTNMaster::BuildTestPermutationsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::PermuteRemainingSlots()"
//==================================================================================
// CTNMaster::PermuteRemainingSlots
//----------------------------------------------------------------------------------
//
// Description: Recursive function that builds all the possible valid test instances
//				for each configuration of tester assignments.  If the module doesn't
//				deny it (via the optional CanRun callback), then each is added to
//				the test list passed in.
//				The passed in arrays will be used for recursion.  The PTNSLAVEINFO
//				array must be NULLed out, and the PTNSLAVESLIST array must be
//				populated with lists of valid testers at the first call to this
//				function.  Both must be iNumMachines long at the start, although
//				papRemainingPossibleLists will be bumped further and further down
//				at each recursion level.
//				It's important to note that the tests in the list will NOT have
//				valid test IDs.
//				The slave list lock is assumed to be held with only one level of
//				recursion.
//
// Arguments:
//	PTNTESTFROMFILE pBaseTest					Test to use.
//	int iTestingSlot							Which slot this recursive call
//												should begin at, initialize to 0.
//	PTNSLAVEINFO* apTesters						Current tester list configuration.
//	PTNSLAVESLIST* papRemainingPossibleLists	Array of lists of slaves for each of
//												the remaining tester slots.
//	PTNTESTMSLIST pResults						List to add valid configurations to.
//	int* piMaxNumPermutations					Place to store maximum number of
//												permutations that could be used (not
//												necessarily number of items actually
//												in built test list).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::PermuteRemainingSlots(PTNTESTFROMFILE pBaseTest,
										int iTestingSlot,
										PTNSLAVEINFO* apTesters,
										PTNSLAVESLIST* papRemainingPossibleLists,
										PTNTESTMSLIST pResults,
										int* piMaxNumPermutations)
{
	HRESULT				hr = S_OK;
	int					iRemainingSlots;
	PTNSLAVESLIST*		papSubRemainingPossibleLists = NULL;
	int					i;
	int					j;
	int					k;
	BOOL				fSkip;
	PTNSLAVEINFO		pSlave;
	PTNSLAVEINFO		pOtherSlave;


	iRemainingSlots = pBaseTest->m_iNumMachines - iTestingSlot - 1;

	// We need to use a temporary duplicate array for each remaining slot.
	papSubRemainingPossibleLists = (PTNSLAVESLIST*) LocalAlloc(LPTR, (iRemainingSlots * sizeof (PTNSLAVESLIST)));
	if (papSubRemainingPossibleLists == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Loop through all the possible slaves that can be in this slot (the first
	// list in the remaining lists array).  
	for(i = 0; i < papRemainingPossibleLists[0]->Count(); i++)
	{
		pSlave = (PTNSLAVEINFO) papRemainingPossibleLists[0]->GetItem(i);
		if (pSlave == NULL)
		{
			DPL(0, "Couldn't get possible slave %i for slot %i",
				2, i, iTestingSlot);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't allocate memory)

		apTesters[iTestingSlot] = pSlave;

		fSkip = FALSE;

		// Rebuild the remaining lists without the current slave.
		for(j = 0; j < iRemainingSlots; j++)
		{
			papSubRemainingPossibleLists[j] = new (CTNSlavesList);
			if (papSubRemainingPossibleLists[j] == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)

			for(k = 0; k < papRemainingPossibleLists[j + 1]->Count(); k++)
			{
				pOtherSlave = (PTNSLAVEINFO) papRemainingPossibleLists[j + 1]->GetItem(k);
				if (pOtherSlave == NULL)
				{
					DPL(0, "Couldn't get slave %i for remaining list %i",
						2, k, j);
					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't allocate memory)

				// Only copy the item if it's not the current slave we're working
				// with.
				if (pOtherSlave != pSlave)
				{
					hr = papSubRemainingPossibleLists[j]->Add(pOtherSlave);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add slave %s to sub list!",
							1, pOtherSlave->m_szComputerName);
						goto DONE;
					} // end if (couldn't allocate object)
				} // end if (it's not the current guy)
			} // end for (each item in the list)

			// If nothing was copied in the sub possibilities list, its obviously an
			// invalid configuration, so skip it.
			if (papSubRemainingPossibleLists[j]->Count() <= 0)
			{
				fSkip = TRUE;
				break;
			} // end if (nothing was copied)
		} // end for (each remaining list)

		// If this is still a valid permutation, continue.  If we're the last slot to
		// check, let the module accept or reject it, otherwise, recursively call
		// ourselves to get to that last slot.
		if (! fSkip)
		{
			if (iRemainingSlots == 0)
			{
				// Here's a possible configuration, increase the count.
				(*piMaxNumPermutations)++;

				if (pBaseTest->m_pCase->m_pfnCanRun != NULL)
				{
					TNCANRUNDATA	tncrd;


					ZeroMemory(&tncrd, sizeof (TNCANRUNDATA));
					tncrd.dwSize = sizeof (TNCANRUNDATA);
					tncrd.pMaster = this;
					tncrd.pTest = pBaseTest->m_pCase;
					tncrd.iNumMachines = pBaseTest->m_iNumMachines;
					tncrd.apTesters = (PTNMACHINEINFO*) apTesters;
					tncrd.pStringData = pBaseTest->m_pStoredDataList;
					// tncrd.fCanRun = FALSE;

					hr = pBaseTest->m_pCase->m_pfnCanRun(&tncrd);
					if (hr != S_OK)
					{
						DPL(0, "Module's CanRun callback failed!", 0);
						goto DONE;
					} // end if (app's callback failed)

					fSkip = ! (tncrd.fCanRun);
				} // end if (the module wants to verify the machine can run the test)
				else
				{
					// Since the module doesn't care, then they must allow this
					// configuration.  fSkip will be FALSE.
				} // end else (module doesn't care)


				// If the module didn't deny this permutation, create a test instance
				// object for it, and add it to the list
				if (! fSkip)
				{
					PTNTESTINSTANCEM	pPermutation;


					pPermutation = new (CTNTestInstanceM)(0xFFFFFFFF,
														pBaseTest,
														pBaseTest->m_pCase,
														pBaseTest->m_iNumMachines,
														//0,
														NULL);
					if (pPermutation == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate object)

					// Copy the list of people in this permutation over to the
					// testing slots.
					for(j = 0; j < pBaseTest->m_iNumMachines; j++)
					{
						apTesters[j]->m_dwRefCount++; // it's in the slot now
						pPermutation->m_paTesterSlots[j].pSlave = apTesters[j];
					} // end for (each permutation)


					hr = pResults->Add(pPermutation);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't add permutation %x to list!",
							1, pPermutation);

						delete (pPermutation);
						pPermutation = NULL;

						goto DONE;
					} // end if (couldn't add)
				} // end if (can run this permutation)
			} // end if (we're the last slot)
			else
			{
				hr = this->PermuteRemainingSlots(pBaseTest,
												iTestingSlot + 1,
												apTesters,
												papSubRemainingPossibleLists,
												pResults,
												piMaxNumPermutations);
				if (hr != S_OK)
				{
					DPL(0, "Recursively filling remaining slots failed!", 0);
					goto DONE;
				} // end if (couldn't fill remaining test slots)
			} // end else (there are more slots)
		} // end if (a valid permutation)


		for(j = 0; j < iRemainingSlots; j++)
		{
			if (papSubRemainingPossibleLists[j] != NULL)
			{
				delete (papSubRemainingPossibleLists[j]);
				papSubRemainingPossibleLists[j] = NULL;
			} // end if (allocated list)
		} // end for (each array entry)

		// Reset this back to how it was before
		apTesters[iTestingSlot] = NULL;


		// If we only need one permutation, and we now have it, we can bail early.
		if ((pBaseTest->m_dwPermutationMode == TNTPM_ONCE) &&
			(pResults->Count() > 0))
		{
			break;
		} // end if (already have once permutation needed)
	} // end for (each possible slave for this slot)


DONE:

	if (papSubRemainingPossibleLists != NULL)
	{
		for(i = 0; i < iRemainingSlots; i++)
		{
			if (papSubRemainingPossibleLists[i] != NULL)
			{
				delete (papSubRemainingPossibleLists[i]);
				papSubRemainingPossibleLists[i] = NULL;
			} // end if (allocated list)
		} // end for (each array entry)

		LocalFree(papSubRemainingPossibleLists);
		papSubRemainingPossibleLists = NULL;
	} // end if (allocated array)

	return (hr);
} // CTNMaster::PermuteRemainingSlots
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::GetActiveTest()"
//==================================================================================
// CTNMaster::GetActiveTest
//----------------------------------------------------------------------------------
//
// Description: Searches for an already active test that matches the given case ID
//				and tester array.  The test is then returned.  If no matching test
//				exists, NULL is returned.
//				The slave lock is assumed to be held.
//
// Arguments:
//	PTNTESTINSTANCEM pParentTest	Parent test to search under, if any.
//	char* szCaseID					Module defined case ID of test.
//	int iNumMachines				Number of machines in the test.
//	TNCTRLMACHINEID* aTestersArray	Array of machine IDs in tester number order.
//
// Returns: Pointer to test, or NULL if not found.
//==================================================================================
PTNTESTINSTANCEM CTNMaster::GetActiveTest(PTNTESTINSTANCEM pParentTest,
										char* szCaseID,
										int iNumMachines,
										TNCTRLMACHINEID* aTestersArray)
{
	PTNTESTINSTANCEM	pTest = NULL;
	int					i;
	int					j;
	PTNSLAVEINFO		pSlave = NULL;
	PTNSLAVEINFO		pRequestedTester = NULL;
	PTNSLAVEINFO		pExistingTester = NULL;


	// If there's a parent test look through all subtests of that parent test.  If
	// not, look through all the slaves current tests for an unfinished test with
	// the same case ID and testerlist.  pTest will point to it if we find it.
	
	for(i = 0; i < ((pParentTest != NULL) ? pParentTest->m_subtests.Count() : this->m_slaves.Count()); i++)
	{
		if (pParentTest != NULL)
		{
			pTest = (PTNTESTINSTANCEM) pParentTest->m_subtests.GetItem(i);
			if (pTest == NULL)
			{
				DPL(0, "Couldn't get subtest %i!", 1, i);
				goto DONE;
			} // end if (couldn't get slave)
		} // end if (there's a parent test)
		else
		{
			pSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
			if (pSlave == NULL)
			{
				DPL(0, "Couldn't get slave %i!", 1, i);
				goto DONE;
			} // end if (couldn't get slave)

			// If the slave isn't currently working, skip him.
			if (pSlave->m_pCurrentTest == NULL)
				continue;

			pTest = pSlave->m_pCurrentTest;

#pragma BUGBUG(vanceo, "What about ongoing tests?")
		} // end else (there's no parent test)

		// Make sure the test we're looking at is the right case and hasn't
		// already started.
		if ((strcmp(pTest->m_pCase->m_pszID, szCaseID) == 0) &&
			(! pTest->m_fStarted))
		{
#ifdef DEBUG
			if (pTest->m_iNumMachines != iNumMachines)
			{
				DPL(0, "A test \"%s\" exists (with %i testers) but the slave announced it needs %i testers!?",
					3, pTest->m_pCase->m_pszID, pTest->m_iNumMachines,
					iNumMachines);

				DEBUGBREAK();

				pTest = NULL;

				goto DONE;
			} // end if (there's a disparate number of testers)
#endif // DEBUG

			// For this loop, we go through to see if the list of people
			// assigned to the test match what the caller is specifying as its
			// requested list.  We need to assume we found the test, so that if
			// we find even one person who differs, we can refute this.
			for(j = 0; j < iNumMachines; j++)
			{
				pRequestedTester = this->m_slaves.GetSlaveByID(&(aTestersArray[j]));
				pExistingTester = pTest->m_paTesterSlots[j].pSlave;

#ifdef DEBUG
				if (pExistingTester == NULL)
				{
					DPL(0, "Active test found (ID %u) but a testing slot (%i) is empty!?",
						2, pTest->m_dwUniqueID, j);

					DEBUGBREAK();

					pTest = NULL;
					goto DONE;
				} // end if (nobody)
#endif // DEBUG

				// It only takes one person being in a different position to
				// determine we found a different subtest (that happens to have
				// the same case ID).
				if (pRequestedTester != pExistingTester)
				{
					DPL(1, "Requested tester for slot %i (%s) is not the same as existing tester in slot %i (%s) of test %u, not using test.",
						5, j, pRequestedTester->m_szComputerName, j,
						pExistingTester->m_szComputerName,
						pSlave->m_pCurrentTest->m_dwUniqueID);

					pTest = NULL;
					break;
				} // end if (the testers don't match)
			} // end for (each subtest tester)

			// If it did match, we're done.
			if (pTest != NULL)
				break;
		} // end if (the test we found looks correct)
		else
		{
			pTest = NULL;
		} // end else (the test we found is not correct)
	} // end for (each slave)


DONE:

	return (pTest);
} // CTNMaster::GetActiveTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::StartJobThread()"
//==================================================================================
// CTNMaster::StartJobThread
//----------------------------------------------------------------------------------
//
// Description: Starts the Job thread if it wasn't already running.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::StartJobThread(void)
{
	HRESULT		hr;
	DWORD		dwThreadID;


	// Create kill thread manual reset event if it doesn't exist
	if (this->m_hKillJobThreadEvent == NULL)
	{
		this->m_hKillJobThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		if (this->m_hKillJobThreadEvent == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create kill Job thread event!", 0);
			return (hr);
		} // end if (couldn't create kill thread event)
	} // end if (kill event doesn't exist)

	// Create the actual thread if it doesn't exist
	if (this->m_hJobThread == NULL)
	{
		this->m_hJobThread = CreateThread(NULL, 0, MasterJobThread,
										this, 0, &dwThreadID);
		if (this->m_hJobThread == NULL)
		{
			hr = GetLastError();
			DPL(0, "Couldn't create Job thread!", 0);
			return (hr);
		} // end if (couldn't create thread)
	} // end if (thread doesn't exist)

	return (S_OK);
} // CTNMaster::StartJobThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::KillJobThread()"
//==================================================================================
// CTNMaster::KillJobThread
//----------------------------------------------------------------------------------
//
// Description: Shuts down the Job thread.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::KillJobThread(void)
{
	HRESULT		hr = S_OK;
	DWORD		dwExitCode;


	// Close all items associated with the thread
	if (this->m_hJobThread != NULL)
	{
		// First check to see if it already died on its own
		if (! GetExitCodeThread(this->m_hJobThread, &dwExitCode))
		{
			hr = GetLastError();
			DPL(0, "Couldn't get thread exit code!", 0);
			goto DONE;
		} // end if (couldn't get the thread's exit code)

		if (dwExitCode != STILL_ACTIVE)
		{
			DPL(0, "Job thread killed itself!  %e", 1, dwExitCode);

			// Note: hr == S_OK
			goto DONE;
		} // end if (the thread must have killed itself)

		if (this->m_hKillJobThreadEvent == NULL) // ack, we won't be able to tell it to die
		{
			DPL(0, "Kill thread event doesn't exist, can't tell it to die!", 0);
			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (kill event doesn't exist)

		if (! SetEvent(this->m_hKillJobThreadEvent))
		{
			hr = GetLastError();
			DPL(0, "Couldn't set kill thread event!", 0);
			goto DONE;
		} // end if (couldn't set kill event)

		hr = WaitForSingleObject(this->m_hJobThread, TIMEOUT_DIE_PERIODICCHECKTHREAD);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// what we want
				hr = S_OK;
			  break;

			case WAIT_TIMEOUT:
				// Hmm, let's try getting the exit code again
				if (! GetExitCodeThread(this->m_hJobThread, &dwExitCode))
				{
					hr = GetLastError();
					DPL(0, "Couldn't get thread exit code!", 0);
					goto DONE;
				} // end if (couldn't get the thread's exit code)

				if (dwExitCode != STILL_ACTIVE)
				{
					DPL(0, "Job thread died in unusual way!  %e", 1, dwExitCode);

					// Note: hr == S_OK
					goto DONE;
				} // end if (the thread must have killed itself)


				DPL(0, "Waited %i ms for job thread to die but it didn't!",
					1, TIMEOUT_DIE_PERIODICCHECKTHREAD);


#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
				DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT

			  break;

			default:
				DPL(0, "Got unexpected return code (%i) from WaitForSingleObject on the test thread!",
					1, hr);
			  break;
		} // end switch (on result of waiting for thread to die)

	} // end if (the ping thread exists)


DONE:

	if (this->m_hJobThread != NULL)
	{
		CloseHandle(this->m_hJobThread);
		this->m_hJobThread = NULL;
	} // end if (the slave ping thread existed)

	if (this->m_hKillJobThreadEvent != NULL)
	{
		CloseHandle(this->m_hKillJobThreadEvent);
		this->m_hKillJobThreadEvent = NULL;
	} // end if (the kill ping thread event existed)


	return (hr);
} // CTNMaster::KillJobThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::SendPingTo()"
//==================================================================================
// CTNMaster::SendPingTo
//----------------------------------------------------------------------------------
//
// Description: Sends a ping to the specific slave,
//
// Arguments:
//	PTNSLAVEINFO pSlave		Pointer to the slave info object.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::SendPingTo(PTNSLAVEINFO pSlave)
{
	HRESULT						hr = S_OK;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_MASTERPINGSLAVE	pPingMsg = NULL;
	LPVOID						pvAddress = NULL;
	DWORD						dwAddressSize = pSlave->m_commdata.dwAddressSize;


	
	if (pSlave->m_commdata.fDropped)
	{
		DPL(0, "Can't send ping to %s because his connection has been dropped!",
			1, pSlave->m_szComputerName);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to slave is down)

	// Update the number of pings we've transmitted
	pSlave->m_dwNumPingsSinceReceive++;


	if (NUM_PINGS_TO_ATTEMPT == 1)
	{
		DPL(0, "Sending a ping to %s", 1, pSlave->m_szComputerName);
	} // end if (we'll only try sending one ping)
	else
	{
		DPL(0, "Sending ping #%u to %s",
			2, pSlave->m_dwNumPingsSinceReceive,
			pSlave->m_szComputerName);
	} // end else (we'll try pinging multiple times)


	pSendData = new CTNSendData;
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pSendData->m_fGuaranteed = TRUE;


	// The Send object deletes the address in its destructor so we work
	// around this by copying the address

	pvAddress = LocalAlloc(LPTR, dwAddressSize);
	if (pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Copy address to pvAddress
	CopyMemory(pvAddress, pSlave->m_commdata.pvAddress, dwAddressSize);
	
	pSendData->m_dwAddressSize = dwAddressSize; 		
	pSendData->m_pvAddress = pvAddress;
	pvAddress = NULL;
	pSendData->m_dwDataSize = sizeof(CTRLMSG_MASTERPINGSLAVE);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)	

	// Copy the master ping slave data back
	// This consists mainly of the slave ID so that the master can use
	// it for reference
	
	ZeroMemory(pSendData->m_pvData, pSendData->m_dwDataSize);

	pPingMsg = (PCTRLMSG_MASTERPINGSLAVE) pSendData->m_pvData;
	pPingMsg->dwSize = pSendData->m_dwDataSize;
	pPingMsg->dwType = CTRLMSGID_MASTERPINGSLAVE;

	// Queue the send
	
	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	}

	pSendData = NULL;
	

DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have object)

	if (pvAddress != NULL)
	{
		LocalFree(pvAddress);
		pvAddress = NULL;
	} // end if (allocated memory)

	return hr;
} // CTNMaster::SendPingTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::InternalExpandStringVars()"
//==================================================================================
// CTNMaster::InternalExpandStringVars
//----------------------------------------------------------------------------------
//
// Description: Expands all variables of type "STRING" found in the lists passed in
//				contained in the given string.  If the buffer pointer is NULL, the
//				size need to hold the new string is placed in pdwBufferSize, and
//				ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	char* szString					String to expand.
//	char* pszBuffer					Pointer to buffer to place results, or NULL to
//									retrieve size required.
//	DWORD* pdwBufferSize			Pointer to size of buffer, or place to store
//									size required.
//	PTNOUTPUTVARSLIST* apLists		Array of pointers to lists to search, in
//									priority order.
//	DWORD dwNumLists				Number of lists in preceding array.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::InternalExpandStringVars(char* szString, char* pszBuffer,
											DWORD* pdwBufferSize,
											PTNOUTPUTVARSLIST* apLists,
											DWORD dwNumLists)
{
#define VARNAME_BUFFER_INCREMENT	50

	HRESULT		hr;
	char*		pszTemp = NULL;
	DWORD		dwTempSize = 0;
	char*		pszName;
	DWORD		dwNameLen;
	char*		pszCurrentSrc;
	char*		pszCurrentDest;
	DWORD		dwTemp;
	PVOID		pvValue;
	DWORD		dwValueSize;


	pszCurrentSrc = szString;
	pszCurrentDest = pszBuffer;
	(*pdwBufferSize) = 0;
	do
	{
		hr = this->SearchStringForDynamicVars(pszCurrentSrc, &pszName, &dwNameLen);
		if (hr != S_OK)
		{
			DPL(0, "Failed searching string for dynamic variables!", 0);
			goto DONE;
		} // end if (failed searching string)

		// If we didn't find any more variables, finish off the size required and
		// we're done.
		if (pszName == NULL)
		{
			// Include room for rest of string plus NULL termination.
			(*pdwBufferSize) += strlen(pszCurrentSrc) + 1;

			// Actually copy rest of string if there's a buffer.
			if (pszBuffer != NULL)
				strcpy(pszCurrentDest, pszCurrentSrc);

			break;
		} // end if (no more dynamic variables)

		// Move the current source pointer past the found item + the trailing @
		pszCurrentSrc = pszName + dwNameLen + 1;


		// Make sure the temp buffer can hold the variable name
		if (dwNameLen >= dwTempSize)
		{
			SAFE_LOCALFREE(pszTemp);

			dwTempSize += VARNAME_BUFFER_INCREMENT;
			pszTemp = (char*) LocalAlloc(LPTR, dwTempSize);
			if (pszTemp == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
		} // end if (need to increase buffer)

		CopyMemory(pszTemp, pszName, dwNameLen);
		pszTemp[dwNameLen] = '\0'; // make sure it's NULL terminated

		for (dwTemp = 0; dwTemp < dwNumLists; dwTemp++)
		{
			hr = apLists[dwTemp]->GetVariable(pszTemp, "STRING", &pvValue, &dwValueSize);

			//BUGBUG is this what we want?

			// If it's a real variable, just not a "STRING" type, then we want to
			// skip over it.
			if (hr == ERROR_INVALID_DATA)
				hr = ERROR_NOT_FOUND;

			if (hr == S_OK)
			{
				(*pdwBufferSize) += dwValueSize;

				if (pszBuffer != NULL)
				{
					CopyMemory(pszCurrentDest, pvValue, dwValueSize);
					pszCurrentDest += dwValueSize;
				} // end if (there's a buffer)

				// Stop looking through the lists
				break;
			} // end if (found variable)
			else if (hr != ERROR_NOT_FOUND)
			{
				DPL(0, "Couldn't get variable \"%s\" from list %u!",
					2, pszTemp, dwTemp);
				goto DONE;
			} // end if (wacky error)
		} // end for (each list to search)


		// If we didn't find the item in any list, just copy what we thought was
		// a variable, including the @ tokens.
		if (hr == ERROR_NOT_FOUND)
		{
			(*pdwBufferSize) += dwNameLen + 2; // + 2 for @ tokens

			if (pszBuffer != NULL)
			{
				CopyMemory(pszCurrentDest, pszName - 1, dwNameLen + 2);
				pszCurrentDest += dwNameLen + 2;
			} // end if (there's a buffer)

			hr = S_OK;
		} // end if (didn't find variable)
	} // end do (while still more dynamic variables)
	while (TRUE);

	if (pszBuffer == NULL)
		hr = ERROR_BUFFER_TOO_SMALL;
	else
		hr = S_OK;


DONE:

	SAFE_LOCALFREE(pszTemp);

	return (hr);
} // CTNMaster::InternalExpandStringVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::InternalIsVarOfType()"
//==================================================================================
// CTNMaster::InternalIsVarOfType
//----------------------------------------------------------------------------------
//
// Description: Checks if the given string is a dynamic variable of the given type
//				contained in one of the lists passed in.  If it is, then a pointer
//				to its value and its size are returned.  Otherwise they are set to
//				NULL and 0.
//
// Arguments:
//	char* szString				String to check.
//	char* szType				Type of variable required.
//	PVOID* ppvValueLocation		Pointer to set to value.
//	DWORD* pdwValueSize			Place to store size of the value.
//	PTNOUTPUTVARSLIST* apLists	Array of pointers to lists to search, in priority
//								order.
//	DWORD dwNumLists			Number of lists in preceding array.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::InternalIsVarOfType(char* szString, char* szType,
									PVOID* ppvValueLocation,
									DWORD* pdwValueSize,
									PTNOUTPUTVARSLIST* apLists,
									DWORD dwNumLists)
{
	HRESULT		hr;
	char*		pszTemp = NULL;
	char*		pszName;
	DWORD		dwNameLen;
	DWORD		dwTemp;


	(*ppvValueLocation) = NULL;
	(*pdwValueSize) = 0;

	hr = this->SearchStringForDynamicVars(szString, &pszName, &dwNameLen);
	if (hr != S_OK)
	{
		DPL(0, "Failed searching string for dynamic variables!", 0);
		goto DONE;
	} // end if (failed searching string)

	// If it doesn't contain a dynamic variable, we're done
	if (pszName == NULL)
		goto DONE;


	// Grab the variable name

	pszTemp = (char*) LocalAlloc(LPTR, dwNameLen + 1);
	if (pszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory))

	CopyMemory(pszTemp, pszName, dwNameLen);


	// Loop through the lists, looking for the variable
	for (dwTemp = 0; dwTemp < dwNumLists; dwTemp++)
	{
		hr = apLists[dwTemp]->GetVariable(pszTemp, szType, ppvValueLocation,
											pdwValueSize);
		if (hr == S_OK)
		{
			// Stop looking through the lists
			break;
		} // end if (found variable)
		else if (hr != ERROR_NOT_FOUND)
		{
			DPL(0, "Couldn't get variable \"%s\" from list %u!",
				2, pszTemp, dwTemp);
			goto DONE;
		} // end if (wacky error)
	} // end for (each list to search)


	// If we didn't find it in any list, oh well.
	if (hr == ERROR_NOT_FOUND)
		hr = S_OK;


DONE:

	SAFE_LOCALFREE(pszTemp);

	return (hr);
} // CTNMaster::InternalIsVarOfType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::FreeOutputVarsAndData()"
//==================================================================================
// CTNMaster::FreeOutputVarsAndData
//----------------------------------------------------------------------------------
//
// Description: Frees all output variables matching the given criteria.  If a
//				parameter is not NULL, then only vars from the corresponding test,
//				with a matching name, etc. are freed.  If all parameters are NULL,
//				all output vars are freed.
//
// Arguments:
//	char* pszCaseID			Case ID to match, or NULL for all.
//	char* pszInstanceID		Instance ID to match, or NULL for all.
//	PTNSLAVEINFO pSlave		Slave to match, or NULL for all.
//	char* pszName			Output variable name to match, or NULL for all.
//	char* pszType			Output variable type to match, or NULL for all.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNMaster::FreeOutputVarsAndData(char* pszCaseID, char* pszInstanceID,
										PTNSLAVEINFO pSlave, char* pszName,
										char* pszType)
{
	HRESULT				hr = S_OK;
	PTNTESTINSTANCEM	pTest;
	DWORD				dwNumSlotsWithData;
	PTNOUTPUTVAR		pVar;
	int					i;
	int					j;
	int					k;



	DPL(1, "Freeing output variables and data (%s, %s, %x, %s, %s).",
		5, pszCaseID, pszInstanceID, pSlave, pszName, pszType);

	this->m_testswithvars.EnterCritSection();


	// Loop backwards (so our counter doesn't get off) through all the output vars
	// in the list.
	for(i = this->m_testswithvars.Count() - 1; i >= 0; i--)
	{
		pTest = (PTNTESTINSTANCEM) this->m_testswithvars.GetItem(i);
		if (pTest == NULL)
		{
			DPL(0, "Couldn't get item %i of test with vars list!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)


		// If we're matching case ID, make sure it does.
		if (pszCaseID != NULL)
		{
			if (strcmp(pTest->m_pCase->m_pszID, pszCaseID) != 0)
				continue;
		} // end if (should check case ID)

		// If we're matching instance ID, make sure it does.
		if (pszInstanceID != NULL)
		{
			if ((pTest->m_pLoadedTest == NULL) ||
				(strcmp(pTest->m_pLoadedTest->m_pszInstanceID, pszInstanceID) != 0))
			{
				continue;
			} // end if (no loaded test, or doesn't match instance ID)
		} // end if (should check instance ID)



		dwNumSlotsWithData = 0;


		// Loop through all the tester slots for this test.
		for(j = 0; j < pTest->m_iNumMachines; j++)
		{
#ifdef DEBUG
			// There should never be no output data but have vars, or output data
			// but no vars, because we only keep the data if vars existed.
			if (((pTest->m_paTesterSlots[j].pvOutputData == NULL) &&
				(pTest->m_paTesterSlots[j].pVars != NULL)) ||
				((pTest->m_paTesterSlots[j].pvOutputData != NULL) &&
				(pTest->m_paTesterSlots[j].pVars == NULL)))
			{
				DPL(0, "Tester slot %i of test %u output data = %x but vars list = %x!  DEBUGBREAK()-ing.",
					4, j, pTest->m_dwUniqueID,
					pTest->m_paTesterSlots[j].pvOutputData,
					pTest->m_paTesterSlots[j].pVars);

				DEBUGBREAK();
			} // end if (no output data but vars, or vice versa)
#endif // DEBUG

			if (pTest->m_paTesterSlots[j].pVars != NULL)
			{
				// This slot has data, so note it.
				dwNumSlotsWithData++;


				// If we're matching case ID, make sure it does.
				if (pszCaseID != NULL)
				{
					if (strcmp(pTest->m_pCase->m_pszID, pszCaseID) != 0)
						continue;
				} // end if (should check case ID)

				// If we're matching instance ID, make sure it does.
				if (pszInstanceID != NULL)
				{
					if ((pTest->m_pLoadedTest == NULL) ||
						(strcmp(pTest->m_pLoadedTest->m_pszInstanceID, pszInstanceID) != 0))
					{
						continue;
					} // end if (no loaded test, or doesn't match instance ID)
				} // end if (should check instance ID)

				// If we're matching slaves, make sure it does.
				if (pSlave != NULL)
				{
					if (pTest->m_paTesterSlots[j].pSlave != pSlave)
						continue;
				} // end if (should check slave)

				// If we're matching individual variable names or types, check
				// each one.
				if ((pszName != NULL) || (pszType != NULL))
				{
					// Loop through all the output variables (backwards so our
					// count doesn't get off).
					for(k = pTest->m_paTesterSlots[j].pVars->Count() - 1; k >= 0; k--)
					{
						pVar = (PTNOUTPUTVAR) pTest->m_paTesterSlots[j].pVars->GetItem(k);
						if (pVar == NULL)
						{
							DPL(0, "Couldn't get var %i!", 1, k);
							hr = E_FAIL;
							goto DONE;
						} // end if (couldn't get item)

						// Check for matching names and types.
						if (((pszName != NULL) &&
								(StringCmpNoCase(pVar->GetString(), pszName))) ||
							((pszType != NULL) &&
								(strcmp(pVar->m_pszType, pszType) == 0)))
						{
							// Remove it.
							hr = pTest->m_paTesterSlots[j].pVars->Remove(k);
							if (hr != S_OK)
							{
								DPL(0, "Couldn't remove item %i from test %u's tester %i output vars list!",
									3, k, pTest->m_dwUniqueID, j);
								goto DONE;
							} // end if (couldn't remove item)
						} // end if (matching names and it does)
					} // end for (each output variable)

					// If we didn't remove all the variables, we can't remove
					// the whole list.
					if (pTest->m_paTesterSlots[j].pVars->Count() > 0)
					{
						continue;
					} // end if (still variables left)
				} // end if (should check names or types)


				// If we got here, it means we can remove all the variables left
				// plus the output data.
				delete (pTest->m_paTesterSlots[j].pVars);
				pTest->m_paTesterSlots[j].pVars = NULL;

				LocalFree(pTest->m_paTesterSlots[j].pvOutputData);
				pTest->m_paTesterSlots[j].pvOutputData = NULL;

				pTest->m_paTesterSlots[j].dwOutputDataSize = 0;


				// We deleted the data, so decrement the count.
				dwNumSlotsWithData--;
			} // end if (there are vars)
		} // end for (each tester slot)


		// If we removed all the slots with data, there's no sense in keeping
		// the test in the list.
		if (dwNumSlotsWithData == 0)
		{
			hr = this->m_testswithvars.Remove(i);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't remove item %i from test with vars list!", 1, i);
				goto DONE;
			} // end if (couldn't remove item)
		} // end if (no more data)
	} // end for (each test)


DONE:

	this->m_testswithvars.LeaveCritSection();

	return (hr);
} // CTNMaster::FreeOutputVarsAndData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMaster::PerformReachCheck()"
//==================================================================================
// CTNMaster::PerformReachCheck
//----------------------------------------------------------------------------------
//
// Description: Has the source slave try to contact the target slave using the given
//				method.
//				The slave list lock is assumed to be held once (i.e. no levels of
//				recursion).  It will be dropped during the course of this call.
//
// Arguments:
//	DWORD dwMethod					Method of communication to try.
//	PTNSLAVEINFO pSource			Slave who will try to connect.
//	PVOID pvSourceMethodData		Pointer to additional data for source slave to
//									use when contacting, if any.
//	DWORD dwSourceMethodDataSize	Size of additional source method data, if any.
//	PVOID pvAddressesToTry			Pointer to buffer with addresses for source to
//									try.
//	DWORD dwAddressesToTrySize		Size of addresses buffer.
//	PTNSLAVEINFO pTarget			Slave who will be contacted.
//	PVOID pvTargetMethodData		Pointer to additional data for target slave to
//									use when preparing to be contacted, if any.
//	DWORD dwTargetMethodDataSize	Size of additional target method data, if any.
//	BOOL* pfResult					Pointer to boolean to fill with result (success or
//									failure).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMaster::PerformReachCheck(DWORD dwMethod,
									PTNSLAVEINFO pSource,							
									PVOID pvSourceMethodData,
									DWORD dwSourceMethodDataSize,
									PVOID pvAddressesToTry,
									DWORD dwAddressesToTrySize,
									PTNSLAVEINFO pTarget,
									PVOID pvTargetMethodData,
									DWORD dwTargetMethodDataSize,
									BOOL* pfResult)
{
	HRESULT						hr;
	int							i;
	PTNSLAVEINFO				pOtherSlave = NULL;
	TNCTRLMACHINEID				idPreviousTarget;
	BOOL						fDroppedSlaveLock = FALSE;
	PTNREACHCHECK				pReachCheck = NULL;
	PTNREACHCHECKTARGET			pReachCheckTarget = NULL;
	PTNSENDDATA					pSendData = NULL;
	LPBYTE						lpCurrent;
	PCTRLMSG_ACCEPTREACHCHECK	pAcceptReachCheckMsg;
	PCTRLMSG_CONNECTREACHCHECK	pConnectReachCheckMsg;


	DPL(9, "==>(%u, %x [%s], %x, %u, %x, %u, %x [%s], %x, %u, %x)",
		12,
		dwMethod,
		pSource,
		pSource->m_szComputerName,
		pvSourceMethodData,
		dwSourceMethodDataSize,
		pvAddressesToTry,
		dwAddressesToTrySize,
		pTarget,
		pTarget->m_szComputerName,
		pvTargetMethodData,
		dwTargetMethodDataSize,
		pfResult);

	(*pfResult) = FALSE;


	// We want to make sure they don't get deleted when we drop the lock.  It should
	// never happen, because we should only be called from within the job thread,
	// and slaves can only be killed within the job thread, but I'm being paranoid.
	pSource->m_dwRefCount++;
	pTarget->m_dwRefCount++;


	// If there are multiple slave instances on the target machine in this session,
	// we may have already performed a reach check for the machine.  If so, we still
	// tell the slave about this reach check so he can copy the information he
	// gathered from the other instance.
	// Start by assuming we won't find this handy shortcut.
	ZeroMemory(&idPreviousTarget, sizeof (TNCTRLMACHINEID));
	if (pTarget->m_iNumOtherInstancesInSession > 0)
	{
		for(i = 0; i < this->m_slaves.Count(); i++)
		{
			pOtherSlave = (PTNSLAVEINFO) this->m_slaves.GetItem(i);
			if (pOtherSlave == NULL)
			{
				DPL(0, "Couldn't get existing slave %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get slave)

			if (this->AreOnSameMachine(pOtherSlave, pTarget))
			{
				// Has this exact reach check been performed already?
				pReachCheckTarget = pSource->m_reachchecktargets.GetTarget(&(pOtherSlave->m_id));
				if (pReachCheckTarget != NULL)
				{
					for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
					{
						pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
						if (pReachCheck == NULL)
						{
							DPL(0, "Couldn't get reach check %i!", i);
							hr = E_FAIL;
							goto DONE;
						} // end if (couldn't get item)


						// If we're found a check already existing, we have
						// the result we need.
						if ((pReachCheck->m_dwMethod == dwMethod) &&
							(pReachCheck->m_dwMethodDataSize == dwSourceMethodDataSize) &&
							((dwSourceMethodDataSize == 0) || (memcmp(pReachCheck->m_pvMethodData, pvSourceMethodData, dwSourceMethodDataSize) == 0)))
						{
							if (pReachCheck->m_fResult)
							{
								DPL(3, "%s already successfully reached another slave instance on %s earlier.",
									2, pSource->m_szComputerName,
									pTarget->m_szComputerName);
							} // end if (check succeeded)
							else
							{
								DPL(3, "%s couldn't reached another slave instance on %s earlier.",
									2, pSource->m_szComputerName,
									pTarget->m_szComputerName);
							} // end else (check failed)

							// Save this ID
							memcpy(&idPreviousTarget, &(pOtherSlave->m_id),
									sizeof (TNCTRLMACHINEID));

							// Stop searching.
							break;
						} // end if (found serial check)
					} // end for (each target)
				} // end if (found any reach check targets)
			} // end if (they're on the same machine)

			// If we found a reach check, we can stop looping.
			if (! IsZero(&idPreviousTarget, sizeof (TNCTRLMACHINEID)))
				break;
		} // end for (each slave)
	} // end if (multiple machines on same machine)



#pragma BUGBUG(vanceo, "No way to store target method data")

	// Build a reach test object for the source
	pReachCheck = new (CTNReachCheck)(this->m_dwCurrentUniqueID++, dwMethod,
									pvSourceMethodData, dwSourceMethodDataSize);
	if (pReachCheck == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pReachCheck->m_dwRefCount++; // we're using it


	// Make sure there's an item in the source's list for the target.

	pReachCheckTarget = pSource->m_reachchecktargets.GetTarget(&(pTarget->m_id));
	if (pReachCheckTarget == NULL)
	{
		pReachCheckTarget = new (CTNReachCheckTarget)(&(pTarget->m_id));
		if (pReachCheckTarget == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		hr = pSource->m_reachchecktargets.Add(pReachCheckTarget);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add reach check target (%s) to source's list!",
				1, pTarget->m_szComputerName);

			delete (pReachCheckTarget);
			pReachCheckTarget = NULL;

			goto DONE;
		} // end if (couldn't add item)
	} // end if (we haven't checked anything for target yet)

	// Add this check to the source's list for the target.
	hr = pReachCheckTarget->m_checks.Add(pReachCheck);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add reach check to source's list for target %s!",
			1, pTarget->m_szComputerName);
		goto DONE;
	} // end if (couldn't add item)




	// Create an event so we can be signalled when the acceptor (and also the
	// connector later) is ready
	pReachCheck->m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pReachCheck->m_hEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create accept/connect reach check event!", 0);
		goto DONE;
	} // end if (couldn't create event)


	// If we didn't find a reach check result for a different instance on the target
	// machine already, we need to perform one.
	if (IsZero(&idPreviousTarget, sizeof (TNCTRLMACHINEID)))
	{
		// Make sure there's a temp self list for the target.

		pReachCheckTarget = pTarget->m_reachchecktargets.GetTarget(&(pTarget->m_id));
		if (pReachCheckTarget == NULL)
		{
			pReachCheckTarget = new (CTNReachCheckTarget)(&(pTarget->m_id));
			if (pReachCheckTarget == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)

			hr = pTarget->m_reachchecktargets.Add(pReachCheckTarget);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add self target list for %s!",
					1, pTarget->m_szComputerName);

				delete (pReachCheckTarget);
				pReachCheckTarget = NULL;

				goto DONE;
			} // end if (couldn't add item)
		} // end if (we haven't had anything checked for target yet)

		// Add this check to the target's self list.
		hr = pReachCheckTarget->m_checks.Add(pReachCheck);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add reach check to target's self list (target = %s)!",
				1, pTarget->m_szComputerName);
			goto DONE;
		} // end if (couldn't add item)


		// Tell the target to start accepting communication from the source.

		pSendData = new (CTNSendData);
		if (pSendData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		pSendData->m_fGuaranteed = TRUE;
		pSendData->m_dwAddressSize = pTarget->m_commdata.dwAddressSize;
		pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
		if (pSendData->m_pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (out of memory)
		CopyMemory(pSendData->m_pvAddress, pTarget->m_commdata.pvAddress,
				pSendData->m_dwAddressSize);

		pSendData->m_dwDataSize = sizeof (CTRLMSG_ACCEPTREACHCHECK)
								+ dwTargetMethodDataSize;
		pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
		if (pSendData->m_pvData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		pAcceptReachCheckMsg = (PCTRLMSG_ACCEPTREACHCHECK) pSendData->m_pvData;
		pAcceptReachCheckMsg->dwSize = pSendData->m_dwDataSize;
		pAcceptReachCheckMsg->dwType = CTRLMSGID_ACCEPTREACHCHECK;
		pAcceptReachCheckMsg->dwID = pReachCheck->m_dwID;
		pAcceptReachCheckMsg->dwMethod = dwMethod;
		pAcceptReachCheckMsg->dwMethodDataSize = dwTargetMethodDataSize;

		if (dwTargetMethodDataSize > 0)
		{
			CopyMemory((pAcceptReachCheckMsg + 1), pvTargetMethodData,
						dwTargetMethodDataSize);
		} // end if (there's method data)
		

		hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add send item to queue!", 0);
			goto DONE;
		} // end if (failed to add item to queue)

		pSendData = NULL; // forget about it so it doesn't get freed below


		// Wait for his response (successfully got ready to accept, or failed to do
		// the same).  We need to drop the slave list lock (which is assumed to be
		// held with only one level of recursion) so the receive thread can actually
		// do something with the replies.

		DPL(8, "Waiting for %s to get ready for connections by %s (method %u, reach check %u)...",
			4, pTarget->m_szComputerName, pSource->m_szComputerName,
			dwMethod, pReachCheck->m_dwID);

		fDroppedSlaveLock = TRUE;
		this->m_slaves.LeaveCritSection();


#pragma BUGBUG(vanceo, "No way to user cancel")
		hr = WaitForSingleObject(pReachCheck->m_hEvent, INFINITE);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// If the acceptor failed getting ready, we have to bail.
				if (! pReachCheck->m_fResult)
				{
					DPL(0, "%s was unable to start accepting a reach check by %s, error code is %e",
						3, pTarget->m_szComputerName, pSource->m_szComputerName,
						pReachCheck->m_hresult);
					goto DONE;
				} // end if (failed starting up)
			  break;

			default:
				// What?
				DPL(0, "Unexpected result from WaitForSingleObject!", 0);
				goto DONE;
			  break;
		} // end switch (on the wait result)

		this->m_slaves.EnterCritSection();
		fDroppedSlaveLock = FALSE;
	} // end if (didn't already contact the machine)


	// Tell the source to try contacting the target, include what addresses are
	// available.

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = pSource->m_commdata.dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)
	CopyMemory(pSendData->m_pvAddress, pSource->m_commdata.pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_CONNECTREACHCHECK)
							+ dwSourceMethodDataSize
							+ dwAddressesToTrySize;
	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pConnectReachCheckMsg = (PCTRLMSG_CONNECTREACHCHECK) pSendData->m_pvData;
	pConnectReachCheckMsg->dwSize = pSendData->m_dwDataSize;
	pConnectReachCheckMsg->dwType = CTRLMSGID_CONNECTREACHCHECK;
	pConnectReachCheckMsg->dwID = pReachCheck->m_dwID;
	CopyMemory(&(pConnectReachCheckMsg->idTarget), &(pTarget->m_id),
				sizeof (TNCTRLMACHINEID));
	pConnectReachCheckMsg->dwMethod = dwMethod;
	pConnectReachCheckMsg->dwMethodDataSize = dwSourceMethodDataSize;
	pConnectReachCheckMsg->dwAddressesSize = dwAddressesToTrySize;
	CopyMemory(&(pConnectReachCheckMsg->idPreviousTarget), &idPreviousTarget,
				sizeof (TNCTRLMACHINEID));

	lpCurrent = (LPBYTE) (pConnectReachCheckMsg + 1);

	if (dwSourceMethodDataSize > 0)
	{
		CopyAndMoveDestPointer(lpCurrent, pvSourceMethodData,
								dwSourceMethodDataSize);
	} // end if (there's method data)

	if (dwAddressesToTrySize > 0)
	{
		//CopyAndMoveDestPointer(lpCurrent, pvAddressesToTry, dwAddressesToTrySize);
		CopyMemory(lpCurrent, pvAddressesToTry, dwAddressesToTrySize);
	} // end if (there's address data)
	

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


	// Wait for his response (successfully got connected to the target, or failed
	// to do the same).  We need to drop the slave list lock (which is assumed to
	// be held with only one level of recursion) so the receive thread can
	// actually do something with the replies.

	DPL(8, "Waiting for %s to try connecting to %s (method %u, reach check %u)...",
		4, pSource->m_szComputerName, pTarget->m_szComputerName,
		dwMethod, pReachCheck->m_dwID);


	fDroppedSlaveLock = TRUE;
	this->m_slaves.LeaveCritSection();


#pragma BUGBUG(vanceo, "No way to user cancel")
	hr = WaitForSingleObject(pReachCheck->m_hEvent, INFINITE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Note if the connector succeeded or not.
			if (! pReachCheck->m_fResult)
			{
				DPL(0, "%s was unable to reach %s, error code is %e",
					3, pSource->m_szComputerName, pTarget->m_szComputerName,
					pReachCheck->m_hresult);
			} // end if (failed connecting)
		  break;

		default:
			// What?
			DPL(0, "Unexpected result from WaitForSingleObject!", 0);
			goto DONE;
		  break;
	} // end switch (on the wait result)

	this->m_slaves.EnterCritSection();
	fDroppedSlaveLock = FALSE;


	CloseHandle(pReachCheck->m_hEvent);
	pReachCheck->m_hEvent = NULL;



	// Tell the target that he can stop accepting communication from the source
	// (if we even told him to start in the first place).
	if (IsZero(&idPreviousTarget, sizeof (TNCTRLMACHINEID)))
	{
		pSendData = new (CTNSendData);
		if (pSendData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		pSendData->m_fGuaranteed = TRUE;
		pSendData->m_dwAddressSize = pTarget->m_commdata.dwAddressSize;
		pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
		if (pSendData->m_pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (out of memory)
		CopyMemory(pSendData->m_pvAddress, pTarget->m_commdata.pvAddress,
				pSendData->m_dwAddressSize);

		pSendData->m_dwDataSize = sizeof (CTRLMSG_ACCEPTREACHCHECK);
		pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
		if (pSendData->m_pvData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		pAcceptReachCheckMsg = (PCTRLMSG_ACCEPTREACHCHECK) pSendData->m_pvData;
		pAcceptReachCheckMsg->dwSize = pSendData->m_dwDataSize;
		pAcceptReachCheckMsg->dwType = CTRLMSGID_ACCEPTREACHCHECK;
		pAcceptReachCheckMsg->dwID = pReachCheck->m_dwID;
		pAcceptReachCheckMsg->dwMethod = TNRCM_CANCEL;
		pAcceptReachCheckMsg->dwMethodDataSize = 0;

		hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add send item to queue!", 0);
			goto DONE;
		} // end if (failed to add item to queue)

		pSendData = NULL; // forget about it so it doesn't get freed below
	} // end if (didn't already contact the machine)



	(*pfResult) = pReachCheck->m_fResult;



DONE:

	if (fDroppedSlaveLock)
	{
		this->m_slaves.EnterCritSection();
		fDroppedSlaveLock = FALSE;
	} // end if (dropped slave lock)

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	if (pReachCheck != NULL)
	{
		if (pReachCheck->m_hEvent != NULL)
		{
			CloseHandle(pReachCheck->m_hEvent);
			pReachCheck->m_hEvent = NULL;
		} // end if (have accept event)

		pReachCheckTarget = pTarget->m_reachchecktargets.GetTarget(&(pTarget->m_id));
		if (pReachCheckTarget != NULL)
		{
			// Ignore error (we don't care if it actually made it on the
			// list or not).  We had a refcount to it anyway.
			pReachCheckTarget->m_checks.RemoveFirstReference(pReachCheck);
		} // end if (target has a self list)

		pReachCheck->m_dwRefCount--;
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(7, "Deleting reach test %x.", 1, pReachCheck);
			delete (pReachCheck);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting reach test %x, its refcount is %u.",
				2, pReachCheck, pReachCheck->m_dwRefCount);
		} // end else (shouldn't delete object)

		pReachCheck = NULL;
	} // end if (have reach test object)


	pSource->m_dwRefCount--;
	if (pSource->m_dwRefCount == 0)
	{
		DPL(7, "Deleting source slave %x.", 1, pSource);
		delete (pSource);
	} // end if (last reference)
	else
	{
		DPL(7, "Not deleting source slave %x, its refcount is %u.",
			2, pSource, pSource->m_dwRefCount);
	} // end else (shouldn't delete object)

	pTarget->m_dwRefCount--;
	if (pTarget->m_dwRefCount == 0)
	{
		DPL(7, "Deleting target slave %x.", 1, pTarget);
		delete (pTarget);
	} // end if (last reference)
	else
	{
		DPL(7, "Not deleting target slave %x, its refcount is %u.",
			2, pTarget, pTarget->m_dwRefCount);
	} // end else (shouldn't delete object)


	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNMaster::PerformReachCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"MasterReadFileCB()"
//==================================================================================
// MasterReadFileCB
//----------------------------------------------------------------------------------
//
// Description: Callback that handles a line read from a text file.
//
// Arguments:
//	char* szLine			Line that was read.
//	PFILELINEINFO pInfo		Line that was read.
//	PVOID pvContext			Pointer to context.  Cast as a READSCRIPTFILECONTEXT
//							pointer.
//	BOOL* pfStopReading		Pointer to boolean to set to TRUE to discontinue reading
//							from the file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT MasterReadFileCB(char* szLine, PFILELINEINFO pInfo, PVOID pvContext,
						BOOL* pfStopReading)
{
	HRESULT						hr = S_OK;
	PREADSCRIPTFILECONTEXT		pContext = (PREADSCRIPTFILECONTEXT) pvContext;



	//DPL(0, "Parsing: %s", 1, szLine);

	switch (pInfo->dwType)
	{
		case FILERTFT_SECTION:
			// Commit the previous test, if it exists.
			hr = pContext->pMaster->StoreReadTest(pContext);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't store read test!", 0);
				goto DONE;
			} // end if (couldn't store the last test)


			if ((TRUE) &&
				(StringStartsWith(szLine, "Exec: ", FALSE)))
			{
				int		iPos;


				iPos = StringContainsChar(szLine, '-', TRUE, 0);
				if (iPos >= 0)
				{
					//BUGBUG should treat string as read only
					szLine[iPos] = '\0';

					if (pContext->pszInstanceID != NULL)
					{
						DPL(0, "WARNING: Replacing old test instance ID \"%s\" with a later one within the same section!",
							1, pContext->pszInstanceID);
						LocalFree(pContext->pszInstanceID);
						pContext->pszInstanceID = NULL;
					} // end if (instance ID already exists)

					// Duplicate the instance ID
					pContext->pszInstanceID = (char*) LocalAlloc(LPTR, (strlen(szLine + iPos + 1) + 1));
					if (pContext->pszInstanceID == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)
					strcpy(pContext->pszInstanceID, (szLine + iPos + 1));

					// Find the matching case
					pContext->pCase = pContext->pMaster->m_testtable.GetTest(szLine + strlen("Exec: "));
					if (pContext->pCase == NULL)
					{
						DPL(0, "Couldn't find test ID \"%s\" in table, skipping!",
							1, szLine + strlen("Exec: "));

						// Ignore error
						pContext->pMaster->Log(TNLST_CRITICAL,
												"Couldn't find test ID \"%s\" in table, skipping!",
												1, szLine + strlen("Exec: "));


						// Note we continue anyway, we just skip this case.
					} // end if (couldn't get test from table)
					else
						pContext->dwUniqueID = 0xFFFFFFFF; // all tests get reassigned real IDs later

					// Restore the dash.  Not really necessary, but I'm doing it anyway.
					szLine[iPos] = '-';
				} // end if (found a valid instance ID)
				else
				{
					DPL(0, "WARNING: Didn't find a test instance ID in \"%s\"!",
						1, szLine);

					pContext->pMaster->Log(TNLST_CONTROLLAYER_INFO,
											"WARNING: Didn't find a test instance ID in \"%s\"!",
											1, szLine);
				} // end else (didn't find a valid instance ID)
			} // end if (it's in a readable script section)
		  break;

		case FILERTFT_SUBSECTION:
			if (StringStartsWith(szLine, "Tester: ", FALSE))
			{
				pContext->iTesterNum = StringToInt(szLine + strlen("Tester: "));
			} // end if (this is a tester description block)
		  break;
		
		default:
			// If we're not in a section, don't bother checking anything
			if (pInfo->pszCurrentSection == NULL)
				break;

			if (StringStartsWith(pInfo->pszCurrentSection, "Info: ", FALSE))
			{
				//BUGBUG add flags to adjust this behavior
				if (
					((TRUE) &&
					StringEndsWith(pInfo->pszCurrentSection, "Session", FALSE))
				   )
				{
					if (pInfo->pszCurrentSubsection != NULL) 
					{
						//BUGBUG add flags to adjust this behavior
						if (
							((TRUE) &&
							(strcmp(pInfo->pszCurrentSubsection, "ModuleStartupData") == 0))
						   )
						{
							hr = pContext->pStartupStrings->AddString(szLine);
							if (hr != S_OK)
							{
								DPL(0, "Couldn't add string to startup data!", 0);
								goto DONE;
							} // end if (couldn't add startup data string)
						} // end if (we're in the startup data block)
					} // end if (we're in a block)

				} // end if (this is the session info section)
			} // end if (this is an info section)

			else if (StringStartsWith(pInfo->pszCurrentSection, "Report: ", FALSE))
			{
				//BUGBUG add flags to adjust this behavior
				if (
					((TRUE) &&
					StringEndsWith(pInfo->pszCurrentSection, "Assigned", FALSE))
						||
					((TRUE) &&
					StringEndsWith(pInfo->pszCurrentSection, "Success", FALSE))
						||
					((TRUE) &&
					StringEndsWith(pInfo->pszCurrentSection, "Failure", FALSE))
						||
					((TRUE) &&
					StringEndsWith(pInfo->pszCurrentSection, "Warning", FALSE))
						||
					((TRUE) &&
					StringEndsWith(pInfo->pszCurrentSection, "CompleteSuccessfully", FALSE))
						||
					((TRUE) &&
					StringEndsWith(pInfo->pszCurrentSection, "CompleteWithFailure", FALSE))
				   )
				{
					if (pInfo->pszCurrentSubsection == NULL)
					{
						if (StringIsKey(szLine, "UniqueTestID"))
						{
							if (pContext->dwUniqueID != 0)
							{
								DPL(0, "Overwriting unique test ID %u with a later one within the same section!",
									1, pContext->dwUniqueID);
							} // end if (we already have a unique test ID for this)

							pContext->dwUniqueID = StringToDWord(StringGetKeyValue(szLine));

							if (pContext->dwUniqueID == 0)
							{
								DPL(0, "Unique test ID specified on line %u is 0!",
									1, pInfo->dwLineNumber);
							} // end if (didn't get valid ID)
						} // end if (this is a unique test ID line)
						else if (StringIsKey(szLine, "ModuleCaseID"))
						{
							if (pContext->pCase != NULL)
							{
								DPL(0, "Overwriting module test ID %s with a later one within the same section!",
									1, pContext->pCase->m_pszID);
							} // end if (we already have an app test ID for this)

							pContext->pCase = pContext->pMaster->m_testtable.GetTest(StringGetKeyValue(szLine));
							if (pContext->pCase == NULL)
							{
								DPL(0, "Couldn't find test ID \"%s\" in table, skipping!",
									1, szLine + strlen("Exec: "));

								// Ignore error
								pContext->pMaster->Log(TNLST_CRITICAL,
														"Couldn't find test ID \"%s\" in table, skipping!",
														1, szLine + strlen("Exec: "));


								// Note we continue anyway.
							} // end if (couldn't get test from table)
						} // end else if (this is an app test ID line)
						else if (StringIsKey(szLine, "TestInstanceID"))
						{
							if (pContext->pszInstanceID != NULL)
							{
								DPL(0, "Overwriting test instance ID %s with a later one within the same section!",
									1, pContext->pszInstanceID);
								LocalFree(pContext->pszInstanceID);
								pContext->pszInstanceID = NULL;
							} // end if (we already have an instance ID for this)

							pContext->pszInstanceID = (char*) LocalAlloc(LPTR, (strlen(StringGetKeyValue(szLine)) + 1));
							if (pContext->pszInstanceID == NULL)
							{
								hr = E_OUTOFMEMORY;
								goto DONE;
							} // end if (couldn't allocate memory)
							strcpy(pContext->pszInstanceID, StringGetKeyValue(szLine));
						} // end else if (this is an instance ID line)
						else if (StringIsKey(szLine, "FriendlyName"))
						{
							if (pContext->pszFriendlyName != NULL)
							{
								DPL(0, "WARNING: Replacing previous test friendly name \"%s\" with a later one within the same section!",
									1, pContext->pszFriendlyName);
								LocalFree(pContext->pszFriendlyName);
								pContext->pszFriendlyName = NULL;
							} // end if (test name already exists)

							pContext->pszFriendlyName = (char*) LocalAlloc(LPTR, (strlen(StringGetKeyValue(szLine)) + 1));
							if (pContext->pszFriendlyName == NULL)
							{
								hr = E_OUTOFMEMORY;
								goto DONE;
							} // end if (couldn't allocate memory)

							strcpy(pContext->pszFriendlyName, StringGetKeyValue(szLine));
						} // end else if (this is an app test ID line)
						else if (StringIsKey(szLine, "NumMachines"))
						{
							if (pContext->fNumMachinesSpecified)
							{
								DPL(0, "WARNING: Replacing previous number of machines (%i) with a later one within the same section!",
									1, pContext->iNumMachines);
							} // end if (test name already exists)

							pContext->iNumMachines = StringToInt(StringGetKeyValue(szLine));
							pContext->fNumMachinesSpecified = TRUE;
						} // end else if (this is an app test ID line)
						else if (StringIsKey(szLine, "Subtest"))
						{
							if (StringIsTrue(StringGetKeyValue(szLine)))
							{
								if (pContext->dwUniqueID != 0)
								{
									DPL(2, "Ignoring test %u because it is marked as a subtest.",
										1, pContext->dwUniqueID);

									// Setting this to zero makes sure that no data gets
									// committed when we come around to the next
									// StoreReadTest call.
									pContext->dwUniqueID = 0;
								} // end if (had a test going)
							} // end if (it's a subtest indicator)
						} // end else if (this is a subtest indicator line)

						//BUGBUG do we want to use this option when reading in a script?  probably not
						/*
						else if (strcmp(szLine, "EveryoneMustRun= true") == 0)
						{
							dwTestOptions |= TNTIO_EVERYONEMUSTRUN;
						} // end else if (everyone must run this test)
						*/

					} // end if (we're not in a block)
					else
					{
						if (
							((TRUE) &&
							(StringCmpNoCase(pInfo->pszCurrentSubsection, "ModuleData")))
						   )
						{
							if (pContext->pStoredData == NULL)
							{
								pContext->pStoredData = new (CTNStoredData);
								if (pContext->pStoredData == NULL)
								{
									hr = E_OUTOFMEMORY;
									goto DONE;
								} // end if (couldn't create object)

								if (StringEndsWith(pInfo->pszCurrentSection, "TestAssigned", FALSE))
									pContext->pStoredData->m_dwLocation = TNTSDL_REPORTASSIGN;
								else if (StringEndsWith(pInfo->pszCurrentSection, "Success", FALSE))
									pContext->pStoredData->m_dwLocation = TNTSDL_REPORTSUCCESS;
								else if (StringEndsWith(pInfo->pszCurrentSection, "Failure", FALSE))
									pContext->pStoredData->m_dwLocation = TNTSDL_REPORTFAILURE;
								else if (StringEndsWith(pInfo->pszCurrentSection, "Warning", FALSE))
									pContext->pStoredData->m_dwLocation = TNTSDL_REPORTWARNING;

								pContext->pStoredData->m_iTesterNum = pContext->iTesterNum;
							} // end if (we haven't created a stored data object)

							hr = pContext->pStoredData->m_strings.AddString(szLine);
							if (hr != S_OK)
							{
								DPL(0, "Couldn't add string to stored data!", 0);
								goto DONE;
							} // end if (couldn't get test from table)
						} // end else if (we're in the module data block)

					} // end else (we're in a block)

				} // end if (we should parse this report type)
			} // end else if (we're working within a report section)

			//BUGBUG add flags to change this
			else if ((TRUE) &&
					(StringStartsWith(pInfo->pszCurrentSection, "Exec: ", FALSE)))
			{
				if (pInfo->pszCurrentSubsection == NULL)
				{
					// hmm, nothing to do here yet

				} // end if (we're not in a block)
				else
				{
					//BUGBUG add flags to change this
					if (
						((TRUE) &&
						(StringCmpNoCase(pInfo->pszCurrentSubsection, "TesterList")))
					   )
					{
						if (pContext->pTesterAssignments == NULL)
						{
							pContext->pTesterAssignments = new (CLStringList);
							if (pContext->pTesterAssignments == NULL)
							{
								hr = E_OUTOFMEMORY;
								goto DONE;
							} // end if (couldn't create object)
						} // end if (we haven't created a stored data object)

						hr = pContext->pTesterAssignments->AddString(szLine);
						if (hr != S_OK)
						{
							DPL(0, "Couldn't add string to tester assignments!", 0);
							goto DONE;
						} // end if (couldn't add string to list)
					} // end if (we're in the tester list block)

					else if (
							 ((TRUE) &&
							 (StringCmpNoCase(pInfo->pszCurrentSubsection, "Options")))
							)
					{
						if (StringIsKey(szLine, "NumMachines"))
						{
							if (pContext->iNumMachines >= 0)
							{
								DPL(0, "WARNING: Replacing previous number of machines (%i) with a later one within the same section!",
									1, pContext->iNumMachines);
							} // end if (test name already exists)

							pContext->iNumMachines = StringToInt(StringGetKeyValue(szLine));
							pContext->fNumMachinesSpecified = TRUE;
						} // end if (this is an app test ID line)
						else if (StringIsKey(szLine, "FriendlyName"))
						{
							if (pContext->pszFriendlyName != NULL)
							{
								DPL(0, "WARNING: Replacing old test friendly name \"%s\" with a later one within the same section!",
									1, pContext->pszFriendlyName);
								LocalFree(pContext->pszFriendlyName);
								pContext->pszFriendlyName = NULL;
							} // end if (test name already exists)

							pContext->pszFriendlyName = (char*) LocalAlloc(LPTR, (strlen(StringGetKeyValue(szLine)) + 1));
							if (pContext->pszFriendlyName == NULL)
							{
								hr = E_OUTOFMEMORY;
								goto DONE;
							} // end if (couldn't allocate memory)

							strcpy(pContext->pszFriendlyName,
									StringGetKeyValue(szLine));
						} // end else if (it's a friendly name)
						else if (StringIsKey(szLine, "PermutationMode"))
						{
							char*	pszValue;


							if (pContext->dwPermutationMode != 0)
							{
								DPL(0, "WARNING: Replacing old permutations mode %u with a later one within the same section!",
									1, pContext->dwPermutationMode);
								//pContext->dwPermutations = 0;
							} // end if (test name already exists)

							pszValue = (char*) LocalAlloc(LPTR, strlen(StringGetKeyValue(szLine)) + 1);
							if (pszValue == NULL)
							{
								hr = E_OUTOFMEMORY;
								goto DONE;
							} // end if (couldn't allocate memory)

							strcpy(pszValue, StringGetKeyValue(szLine));
							_strlwr(pszValue); // need underscore for NT BUILD
							StringPopTrailingChars(pszValue, " \t", TRUE);

							if (strcmp(pszValue, "allslaves") == 0)
								pContext->dwPermutationMode |= TNTPM_ALLSLAVES;
							else if (strcmp(pszValue, "allslavesastesters0andnon0") == 0)
								pContext->dwPermutationMode |= TNTPM_ALLSLAVESASTESTERS0ANDNON0;
							else if (strcmp(pszValue, "allslavesasalltesters") == 0)
								pContext->dwPermutationMode |= TNTPM_ALLSLAVESASALLTESTERS;
							else if (strcmp(pszValue, "allpossible") == 0)
								pContext->dwPermutationMode |= TNTPM_ALLPOSSIBLE;
							else
								pContext->dwPermutationMode = TNTPM_ONCE;

							LocalFree(pszValue);
							pszValue = NULL;
						} // end else if (it's everyone must run)
					} // end else if (we're in the options block)

					else if (
							 ((TRUE) &&
							 (StringCmpNoCase(pInfo->pszCurrentSubsection, "InputData")))
							)
					{
						if (pContext->pStoredData == NULL)
						{
							pContext->pStoredData = new (CTNStoredData);
							if (pContext->pStoredData == NULL)
							{
								hr = E_OUTOFMEMORY;
								goto DONE;
							} // end if (couldn't create object)

							pContext->pStoredData->m_dwLocation = TNTSDL_SCRIPTSECTION;
						} // end if (we haven't created a stored data object)

						hr = pContext->pStoredData->m_strings.AddString(szLine);
						if (hr != S_OK)
						{
							DPL(0, "Couldn't add string to stored data!", 0);
							goto DONE;
						} // end if (couldn't add string to list)
					} // end else if (we're in the initial data block)

				} // end else (we're in a block)

			} // end else if (we're working within a script section)
		  break;
	} // end switch (on line type)


DONE:

	return (hr);
} // MasterReadFileCB
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"MasterJobThread()"
//==================================================================================
// MasterJobThread
//----------------------------------------------------------------------------------
//
// Description: This thread periodically wakes up and performs the maintenance
//				functions from the job queue.
//
// Arguments:
//	LPVOID lpvParameter		Thread startup parameter.  Cast to a pointer to a master
//							object.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
DWORD WINAPI MasterJobThread(LPVOID lpvParameter)
{
	HRESULT		hr = S_OK;
	PTNMASTER	pMaster = (PTNMASTER) lpvParameter;
	HANDLE		ahWaitObjects[3];
	DWORD		dwInterval;


	DPL(8, "Starting up.", 0);


	ahWaitObjects[0] = pMaster->m_hKillJobThreadEvent;
	ahWaitObjects[1] = pMaster->m_jobs.m_hNewJobEvent;
	ahWaitObjects[2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	
	do
	{
		hr = pMaster->ProcessJobQueue(&dwInterval);
		if (hr != S_OK)
		{
			DPL(0, "Failed processing job queue!", 0);
			goto DONE;
		} // end if (failed processing job queue)

		hr = WaitForMultipleObjects(2, ahWaitObjects, FALSE, dwInterval);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// Time for this thread to die
				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// The job list changed.  Repeat loop.
			  break;

			case WAIT_TIMEOUT:
				// Time to do some work.  Repeat loop.
			  break;

			default:
				DPL(0, "Got unexpected return from WaitForMultipleObjects!", 0);
				goto DONE;
			  break;
		} // end switch (on wait result)
	} // end do (while haven't been told to die)
	while (TRUE);


DONE:

	if (hr != S_OK)
	{
		DPL(0, "Master job thread aborting!  DEBUGBREAK()-ing.  %e", 1, hr);

		// Ignoring error
		pMaster->Log(TNLST_CRITICAL,
					"Master job thread aborting!  DEBUGBREAK()-ing.  %e",
					1, hr);

		DEBUGBREAK();
	} // end if (quitting with a failure)

	DPL(8, "Exiting.", 0);

	return (hr);
} // MasterJobThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\master.h ===
#ifndef _XBOX // no master supported
#ifndef __TESTNET_MASTER__
#define __TESTNET_MASTER__
//#pragma message("Defining __TESTNET_MASTER__")






//==================================================================================
// Common Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG



//==================================================================================
// Defines
//==================================================================================
// How long to wait for the PeriodicCheck thread to terminate.
#define TIMEOUT_DIE_PERIODICCHECKTHREAD		10000 // in milliseconds

// How often to traverse the list, looking for slaves we haven't heard from in a
// while, in milliseconds.
#define SLAVE_CHECK_INTERVAL				4000

// These pings will occur every SLAVE_CHECK_INTERVAL ms.  If the transport layer/
// control method is reliable, then there should be no need to send multiple pings.
// In fact, the only reason we ping at all is because the control method's timeout
// period may be longer than we want/non-existent.
#define NUM_PINGS_TO_ATTEMPT				1 

// How long to go without hearing from a slave before trying to ping him, in ticks.
#define TIMEOUT_SLAVE_PING					15000

// How long to go without hearing from a slave before killing him, in ticks.
#define TIMEOUT_SLAVE_KILL					(TIMEOUT_SLAVE_PING + 20000)



//==================================================================================
// Internal Prototypes
//==================================================================================
DWORD WINAPI MasterJobThread(LPVOID lpvParameter);
HRESULT MasterReadFileCB(char* szLine, PFILELINEINFO pInfo, PVOID pvContext,
						BOOL* pfStopReading);



//==================================================================================
// Internal structures
//==================================================================================
typedef struct tagREADSCRIPTFILECONTEXT
{
	PTNMASTER			pMaster; // pointer to master object
	DWORD				dwNumReps; // number of repetitions for tests found in the file
	PLSTRINGLIST		pStartupStrings; // pointer to list currently holding module startup strings
	DWORD				dwUniqueID; // unique ID of current test
	PTNTESTTABLECASE	pCase; // pointer to case of current test
	char*				pszInstanceID; // pointer to string with current test instance ID
	char*				pszFriendlyName; // pointer to optional friendly name for current test
	BOOL				fNumMachinesSpecified; // whether the number of machines has been specified or not
	int					iNumMachines; // total number of testers running the instance
	DWORD				dwPermutationMode; // permutation mode to run this test in
	//DWORD				dwOptions; // pointer to options for current test
	PTNSTOREDDATA		pStoredData; // pointer to object holding stored data for test
	PLSTRINGLIST		pTesterAssignments; // pointer to tester assignments for test
	int					iTesterNum; // current tester number
} READSCRIPTFILECONTEXT, * PREADSCRIPTFILECONTEXT;




//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNMaster:public CTNControlLayer
{
	// This is a friend so it can access the protected members
	friend DWORD WINAPI MasterJobThread(LPVOID lpvParameter);
	friend HRESULT MasterReadFileCB(char* szLine, PFILELINEINFO pInfo,
									PVOID pvContext, BOOL* pfStopReading);


	private:
		DWORD						m_dwMode; // what mode this object is in (TNMODE_xxx)
		TNMODULEID					m_moduleID; // ID of module using us
		char*						m_pszSessionFilter; // user specified session filter string
		char*						m_pszClosingReportPath; // path to file to dump report of all tests on close
		char*						m_pszSiblingFailuresMemDumpDirPath; // directory to have siblings of slaves reporting failures dump their memlog
		char*						m_pszSkippedTestsPath; // path to file to use when printing list of all the tests skipped
		CTNTestTableGroup			m_testtable; // table of tests generated from the module
		CTNTestStats				m_totalstats; // statistics maintained on all tests
		PLSTRINGLIST				m_pFailureBreakRules; // pointer to list of cases to DebugBreak() on

		PTNGETSTARTUPDATAPROC		m_pfnGetStartupData; // callback to retrieve startup data for new joiners
		PTNLOADSTARTUPDATAPROC		m_pfnLoadStartupData; // callback to load startup data from strings
		PTNWRITESTARTUPDATAPROC		m_pfnWriteStartupData; // callback to write startup data to strings
		PTNHANDLEUSERQUERYPROC		m_pfnHandleUserQuery; // callback to use when a UserQuery is received

		DWORD						m_dwSessionID; // ID of current session
		CHECKSUM					m_testChecksum; // checksum generated for tests
		//HANDLE					m_hAllSlavesCommStatusEvent; // handle to event ctrl comm fires when a slaves status changes
		DWORD						m_dwCurrentUniqueID; // incremented counter used to identify instances of given tests
		DWORD						m_dwStartupTicks; // ticks when session started
		time_t						m_tStartupTime; // clock time when session started
		DWORD						m_dwTimelimit; // how long to let slaves run, in ticks
		int							m_iSlaveNumLimit; // total number of slaves that will be running tests
		DWORD						m_dwAllowJoinersTime; // how long after the first joiner to allow additional joiners, in minutes
		BOOL						m_fJoinersAllowed; // whether new slaves are allowed to join
		BOOL						m_fTestingComplete; // is all testing finished?
		CTNTestFromFilesList		m_loadedtests; // list of all the tests loaded from the file
		CTNTestMsList				m_remainingtests; // remaining tests list object
		CTNTestMsList				m_skippedtests; // list of tests that had to be skipped
		CTNIPAddressesList			m_ipaddrs; // ip addresses this machine is using and/or ones slaves see
		PVOID						m_pvMetaMasterAddress; // pointer to buffer with meta-master's address
		DWORD						m_dwMetaMasterAddressSize; // size of meta-master's address
		TNCTRLMACHINEID				m_id; // ID given to us by meta-master
		BOOL						m_fRegistered; // whether we're registered with the meta-master or not
		BOOL						m_fPingSlaves; // whether to ping slaves or not
		HANDLE						m_hJobThread; // worker thread handle
		CTNSlavesList				m_slaves; // machines attached to the current session
		CTNSlavesList				m_droppedslaves; // machines no longer in the current session
		int							m_iTotalNumSlaves; // total number of machines that have ever been in the session
		CTNReportsList				m_reports; // test log object
		CTNOutputVarsList			m_builtinvars; // built in dynamic variables
		CTNTestMsList				m_testswithvars; // list of tests with output data and output variables
		BOOL						m_fReportInBVTFormat; // whether to print report files in BVT format or not

		DWORD						m_dwAutoReportHeaders; // report headers to print
		DWORD						m_dwAutoReportBodyStyle; // style of report body
		DWORD						m_dwAutoReportFlags; // what types of reports to count and print
		int							m_iAutoReportNumReports; // limit to report on
		char*						m_pszAutoReportDirpath; // path to directory to report to
		BOOL						m_fAutoReportDeleteNonPrinted; // whether to delete reports that weren't printed



		HRESULT HandleEnumMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_ENUM pEnumMsg);

		HRESULT HandleHandshakeMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_HANDSHAKE pHandshakeMsg);

		HRESULT HandleJoinMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_JOIN pJoinMsg);

		HRESULT HandleReadyToTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_READYTOTEST pReadyToTestMsg);

		HRESULT HandleAnnounceSubTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_ANNOUNCESUBTEST pAnnounceSubTestMsg);

		HRESULT HandleReportMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_REPORT pReportMsg);

		HRESULT HandleWarningMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_WARNING pWarningMsg);

		HRESULT HandleRequestSyncMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_REQUESTSYNC pRequestSyncMsg);

		HRESULT HandleUserQueryMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_USERQUERY pUserQueryMsg);

		HRESULT HandleIdleMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
							PCTRLMSG_IDLE pIdleMsg);

		HRESULT HandleRegisterMasterReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_REGISTERMASTERREPLY pRegisterMasterReplyMsg);

		HRESULT HandleMasterPingReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_MASTERPINGSLAVEREPLY pMasterReplyMsg);

		HRESULT HandleRequestPokeTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_REQUESTPOKETEST pRequestPokeTestMsg);

		HRESULT HandleAcceptReachCheckReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
												PCTRLMSG_ACCEPTREACHCHECKREPLY pReplyMsg);

		HRESULT HandleConnectReachCheckReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
												PCTRLMSG_CONNECTREACHCHECKREPLY pReplyMsg);

		HRESULT HandleFreeOutputVarsMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_FREEOUTPUTVARS pFreeOutputVarsMsg);

		HRESULT HandleGetMachineInfoMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_GETMACHINEINFO pGetMachineInfoMsg);


		HRESULT GetNextCmdForMachine(PTNSLAVEINFO pSlave);

		HRESULT AssignSlaveToTest(PTNSLAVEINFO pSlave, PTNTESTINSTANCEM pTest,
									int iTesterNum, BOOL fPlaceholder,
									BOOL fGetInputData, PVOID pvInputData,
									DWORD dwInputDataSize);

		HRESULT CompleteSlavesTest(PTNSLAVEINFO pSlave, PTNTESTINSTANCEM pTest,
									BOOL fSuccess, BOOL fSubTest, BOOL fOngoing);

		HRESULT KillSlave(PTNSLAVEINFO pSlave, DWORD dwKillReason);

		HRESULT CompleteAllTesting(void);

		HRESULT SendTestingStatusMessageTo(PTNSLAVEINFO pSlave, DWORD dwStatus);

		HRESULT SendNewTestMessageTo(PTNSLAVEINFO pSlave, PTNTESTINSTANCEM pTest,
									PVOID pvInputData, DWORD dwInputDataSize,
									PTNSENDDATAQUEUE pSendsBuffer);

		HRESULT SendAnnounceTestReplyMessageTo(PTNSLAVEINFO pSlave,
												DWORD dwResponseID,
												DWORD dwUniqueTestID,
												PTNSENDDATAQUEUE pSendsBuffer);

		HRESULT SendLostTesterTo(PTNSLAVEINFO pSlave, PTNTESTINSTANCEM pTest,
								int iTesterNum);

		HRESULT SendBreakMsgTo(PTNSLAVEINFO pSlave, DWORD dwUniqueTestID);

		HRESULT SendDumpLogMsgTo(PTNSLAVEINFO pSlave, DWORD dwUniqueTestID,
								char* pszPath);

		HRESULT SendMasterUpdate(void);

		HRESULT RegisterWithMetaMaster(void);

		HRESULT UnregisterWithMetaMaster(void);

		HRESULT DoBeginReport(HANDLE hFile, DWORD dwStyle);

		int CountMatchingReports(DWORD dwFlags, PTNSLAVESLIST pMachineList,
								PTNTESTMSLIST pTestList);

		HRESULT DoAutoReport(void);

		HRESULT CloseSession(void);

		HRESULT DoPingCheck(void);

		HRESULT DoSlaveReadyToTest(PTNCTRLMACHINEID pSlaveID);

		HRESULT DoHandleReport(PTNSLAVEINFO pSlave, PCTRLMSG_REPORT pReportMsg);

		HRESULT ReadFromFile(char* szFilepath, DWORD dwNumReps);

		HRESULT StoreReadTest(PREADSCRIPTFILECONTEXT pData);

		HRESULT BuildAPITestList(void);

		HRESULT BuildTestPermutationsList(PTNTESTFROMFILE pBaseTest,
										PTNTESTMSLIST pTestList,
										int* piMaxNumPermutations);

		HRESULT PermuteRemainingSlots(PTNTESTFROMFILE pBaseTest,
									int iTestingSlot,
									PTNSLAVEINFO* papTesters,
									PTNSLAVESLIST* papRemainingPossibleLists,
									PTNTESTMSLIST pResults,
									int* piMaxNumPermutations);

		PTNTESTINSTANCEM GetActiveTest(PTNTESTINSTANCEM pParentTest,
										char* szCaseID,
										int iNumMachines,
										TNCTRLMACHINEID* aTestersArray);

		HRESULT StartJobThread(void);

		HRESULT KillJobThread(void);
		
		HRESULT SendPingTo(PTNSLAVEINFO pSlave);

		HRESULT InternalExpandStringVars(char* szString, char* pszBuffer,
										DWORD* pdwBufferSize,
										PTNOUTPUTVARSLIST* apLists,
										DWORD dwNumLists);

		HRESULT InternalIsVarOfType(char* szString, char* szType,
									PVOID* ppvValueLocation,
									DWORD* pdwValueSize,
									PTNOUTPUTVARSLIST* apLists,
									DWORD dwNumLists);

		HRESULT FreeOutputVarsAndData(char* pszCaseID, char* pszInstanceID,
									PTNSLAVEINFO pSlave, char* pszName,
									char* pszType);

		HRESULT PerformReachCheck(DWORD dwMethod,
								PTNSLAVEINFO pSource,							
								PVOID pvSourceMethodData,
								DWORD dwSourceMethodDataSize,
								PVOID pvAddressesToTry,
								DWORD dwAddressesToTrySize,
								PTNSLAVEINFO pTarget,
								PVOID pvTargetMethodData,
								DWORD dwTargetMethodDataSize,
								BOOL* pfResult);



	protected:
		HANDLE			m_hKillJobThreadEvent; // event to set to gracefully exit the thread
		CTNJobQueue		m_jobs; // job queue for worker thread


		HRESULT ProcessJobQueue(DWORD* pdwTimeToNextJob);

		// Virtual implementations
		HRESULT HandleMessage(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
							  PVOID pvData, DWORD dwDataSize);



	public:
		CTNMaster(void);
		virtual ~CTNMaster(void);


		HRESULT CreateControlSession(PTNCREATECONTROLSESSIONDATA pTNccsd);

		HRESULT DestroyControlSession(void);

		DWORD GetSessionID(void);
		
		HRESULT GetModuleString(char* szString);

		PTNMACHINEINFO GetIndexedMachineInfo(int iMachineNum);

		PTNTESTSTATS GetTotalStats(void);

		int GetNumberOfCases(void);

		int GetNumberOfActiveAndRemainingTests(void);

		int GetNumTestsSkipped(void);

		BOOL IsSessionClosed(void);

		BOOL IsTestingComplete(void);

		HRESULT GetCaseIndex(int iIndex, char** ppszID, char** ppszName,
							PTNTESTSTATS* ppStats);

		HRESULT SearchStringForDynamicVars(char* szString, char** ppszNameFound,
											DWORD* pdwNameLength);

		HRESULT ExpandBuiltinStringVars(char* szString, char* pszBuffer,
										DWORD* pdwBufferSize);

		HRESULT ExpandSlaveStringVars(char* szString, PTNMACHINEINFO pSlave,
										char* pszBuffer, DWORD* pdwBufferSize);

		HRESULT ExpandTestersStringVars(char* szString, PTNTESTINSTANCEM pTest,
										char* pszBuffer, DWORD* pdwBufferSize);

		HRESULT IsBuiltinVarOfType(char* szString, char* szType,
									PVOID* ppvValueLocation,
									DWORD* pdwValueSize);

		HRESULT IsSlavesVarOfType(char* szString, char* szType,
									PTNMACHINEINFO pSlave,
									PVOID* ppvValueLocation,
									DWORD* pdwValueSize);

		HRESULT IsTestersVarOfType(char* szString, char* szType,
									PTNTESTINSTANCEM pTest,
									PVOID* ppvValueLocation,
									DWORD* pdwValueSize);

		HRESULT PrintTestTableToFile(char* szFilepath);

		HRESULT PrintResultsToFile(char* szFilepath);

		HRESULT PrintReports(DWORD dwHeaders, DWORD dwBodyStyle, DWORD dwFlags,
							char* szFilepath, BOOL fAppend, BOOL fDeletePrinted);

		void SetMaxNumberReports(int iNumReports);

		HRESULT AutoPrintReports(DWORD dwHeaders, DWORD dwBodyStyle, DWORD dwFlags,
								int iNumReports, char* szDirpath, BOOL fDeleteNonPrinted);

		BOOL AreOnSameMachine(PTNMACHINEINFO pFirstSlave,
							PTNMACHINEINFO pSecondSlave);

		HRESULT CanReachViaIP(PTNMACHINEINFO pConnector,
								PTNMACHINEINFO pListener,
								WORD wPort,
								DWORD dwMethodFlags,
								BOOL* pfReachable);

		HRESULT CanReachViaIPX(PTNMACHINEINFO pSender,
								PTNMACHINEINFO pReceiver,
								BOOL* pfReachable);

		HRESULT CanReachViaModem(PTNMACHINEINFO pCaller,
								PTNMACHINEINFO pAnswerer,
								BOOL* pfReachable);

		HRESULT CanReachViaSerial(PTNMACHINEINFO pSender,
								PTNMACHINEINFO pReceiver,
								BOOL* pfReachable);

		HRESULT GetPlannedInputData(int iTesterNum, PTNCANRUNDATA pTNcrd,
									PVOID pvInputData, DWORD* pdwInputDataSize);
};







#else //__TESTNET_MASTER__
//#pragma message("__TESTNET_MASTER__ already included!")
#endif //__TESTNET_MASTER__
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\masterlist.h ===
#ifndef _XBOX // ! no master supported
#ifndef __TNCONTRL_MASTERLIST__
#define __TNCONTRL_MASTERLIST__
//#pragma message("Defining __TNCONTRL_MASTERLIST__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// Classes
//==================================================================================
class DLLEXPORT CTNMastersList:public LLIST
{
	public:
		/*
		CTNMastersList(void);
		virtual ~CTNMastersList(void);
		*/

		PTNMASTERINFO GetMasterByID(PTNCTRLMACHINEID pID);
};






#else //__TNCONTRL_MASTERLIST__
//#pragma message("__TNCONTRL_MASTERLIST__ already included!")
#endif //__TNCONTRL_MASTERLIST__
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\masterlist.cpp ===
#ifndef _XBOX // ! no master supported
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"

#include "masterinfo.h"
#include "masterlist.h"






/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMastersList::CTNMastersList()"
//==================================================================================
// CTNMastersList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNMastersList object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNMastersList::CTNMastersList(void)
{
	DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNMastersList));
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMastersList::~CTNMastersList()"
//==================================================================================
// CTNMastersList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNMastersList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNMastersList::~CTNMastersList(void)
{
	DPL(0, "this = %x", 1, this);
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMastersList::GetMasterByID()"
//==================================================================================
// CTNMastersList::GetMasterByID
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the CTNMasterInfo object identified by the
//				passed in ID.
//
// Arguments:
//	PTNCTRLMACHINEID pID	Pointer to machine to look up.
//
// Returns: Pointer to object or NULL if couldn't find it.
//==================================================================================
PTNMASTERINFO CTNMastersList::GetMasterByID(PTNCTRLMACHINEID pID)
{
	int				i;
	PTNMASTERINFO	pItem = NULL;


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNMASTERINFO) this->GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve master %i!", 1, i);
			this->LeaveCritSection();
			return (NULL);
		} // end if (couldn't get that item)

		if (pItem->m_id.dwTime == pID->dwTime)
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (we found the tester)
	} // end for (each tester)

	this->LeaveCritSection();

	return (NULL);
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\periodicq.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\stack.h"

#include "tncontrl.h"
#include "main.h"

#include "comm.h"
#include "periodicq.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNPeriodicSend::CTNPeriodicSend()"
//==================================================================================
// CTNPeriodicSend constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNPeriodicSend object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNPeriodicSend::CTNPeriodicSend(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNPeriodicSend));

	this->m_pCtrlComm = NULL;
	this->m_dwInterval = 0;
	this->m_dwFirstSent = 0;
	this->m_dwLastSent = 0;
	this->m_dwTimeout = 0;
} // CTNPeriodicSend::CTNPeriodicSend
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNPeriodicSend::~CTNPeriodicSend()"
//==================================================================================
// CTNPeriodicSend destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNPeriodicSend object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNPeriodicSend::~CTNPeriodicSend(void)
{
	HRESULT		hr;


	//DPL(0, "this = %x", 1, this);

	if (this->m_pCtrlComm != NULL)
	{
		this->m_pCtrlComm->m_dwRefCount--;
		if (this->m_pCtrlComm->m_dwRefCount == 0)
		{
			DPL(7, "Releasing and deleting control comm object %x.",
				1, this->m_pCtrlComm);

			hr = this->m_pCtrlComm->Release();
			if (hr != S_OK)
			{
				DPL(0, "Releasing control communication method failed!  %e", 1, hr);
			} // end if (releasing control method failed)

			delete (this->m_pCtrlComm);
		} // end if (last reference)
		else
		{
			DPL(7, "Not releasing and deleting control comm object %x, its refcount is %u.",
				2, this->m_pCtrlComm, this->m_pCtrlComm->m_dwRefCount);
		} // end else (not last reference)

		this->m_pCtrlComm = NULL;
	} // end if (an address was allocated)
} // CTNPeriodicSend::~CTNPeriodicSend
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\msgs.h ===
#ifndef __TNCONTROL_MESSAGES__
#define __TNCONTROL_MESSAGES__
//#pragma message("Defining __TNCONTROL_MESSAGES__")




//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// Message IDs
//==================================================================================
//#define CTRLMSGID_GENERIC						0
#define CTRLMSGID_ENUM							1
#define CTRLMSGID_ENUMREPLY						2
#define CTRLMSGID_HANDSHAKE						3
#define CTRLMSGID_HANDSHAKEREPLY				4
#define CTRLMSGID_JOIN							5
#define CTRLMSGID_JOINREPLY						6
#define CTRLMSGID_READYTOTEST					7
#define CTRLMSGID_TESTINGSTATUS					8
#define CTRLMSGID_NEWTEST						9
#define CTRLMSGID_ANNOUNCESUBTEST				10
#define CTRLMSGID_ANNOUNCETESTREPLY				11
#define CTRLMSGID_REPORT						12
#define CTRLMSGID_WARNING						13
#define CTRLMSGID_REQUESTSYNC					14
#define CTRLMSGID_SYNCREPLY						15
#define CTRLMSGID_USERQUERY						16
#define CTRLMSGID_USERRESPONSE					17
#define CTRLMSGID_IDLE							18
#define CTRLMSGID_IDLEREPLY						19
#define CTRLMSGID_BREAK							20
#define CTRLMSGID_QUERYMETAMASTER				21
#define CTRLMSGID_METAMASTERREPLY				22
#define CTRLMSGID_REGISTERMASTER				23
#define CTRLMSGID_REGISTERMASTERREPLY			24
#define CTRLMSGID_REQUESTMASTERUPDATE			25
#define CTRLMSGID_MASTERUPDATE					26
#define CTRLMSGID_UNREGISTERMASTER				27
#define CTRLMSGID_MASTERPINGSLAVE				28
#define CTRLMSGID_MASTERPINGSLAVEREPLY			29
#define CTRLMSGID_DUMPLOG						30
#define CTRLMSGID_REQUESTPOKETEST				31
#define CTRLMSGID_LOSTTESTER					32
#define CTRLMSGID_ACCEPTREACHCHECK				33
#define CTRLMSGID_ACCEPTREACHCHECKREPLY			34
#define CTRLMSGID_CONNECTREACHCHECK				35
#define CTRLMSGID_CONNECTREACHCHECKREPLY		36
#define CTRLMSGID_INTERSLAVEREACHCHECK			37
#define CTRLMSGID_INTERSLAVEREACHCHECKREPLY		38
#define CTRLMSGID_FREEOUTPUTVARS				39
#define CTRLMSGID_GETMACHINEINFO				40
#define CTRLMSGID_GETMACHINEINFOREPLY			41



//==================================================================================
// Message structures
//==================================================================================
typedef struct tagCTRLMSG_GENERIC
{
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values
} CTRLMSG_GENERIC, * PCTRLMSG_GENERIC;

typedef struct tagCTRLMSG_ENUM
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwVersion; // version of control layer we're using (and want to connect to)
	TNMODULEID			moduleID; // structure that identifies the type of session we're looking for
	DWORD				dwMode; // session mode we are looking for

	// Anything after this is part of the user specified session ID string.
} CTRLMSG_ENUM, * PCTRLMSG_ENUM;

typedef struct tagCTRLMSG_ENUMREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
} CTRLMSG_ENUMREPLY, * PCTRLMSG_ENUMREPLY;

typedef struct tagCTRLMSG_HANDSHAKE
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwVersion; // version of control layer we're using (and want to connect to)
	TNMODULEID			moduleID; // structure that identifies the type of session we're looking for
	DWORD				dwMode; // session mode we are looking for

	// Anything after this is part of the user specified session ID string.
} CTRLMSG_HANDSHAKE, * PCTRLMSG_HANDSHAKE;

typedef struct tagCTRLMSG_HANDSHAKEREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwSessionID; // ID of this session
	DWORD				dwStartupDataSize; // size of data for use in slave's startup routine

	// Anything after this is part of the startup data blob
} CTRLMSG_HANDSHAKEREPLY, * PCTRLMSG_HANDSHAKEREPLY;

typedef struct tagCTRLMSG_JOIN
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	CHECKSUM			testChecksum; // checksum for the test preparation, to make sure everyone's "on the same page"
	DWORD				dwMultiInstanceKey; // key generated to help detect multiple slave instances on the same machine
	DWORD				dwTimelimit; // allows slave to override master's testing time limit
	DWORD				dwInfoSize; // size of machine info buffer
	DWORD				dwMasterAddrSize; // size of master's address

	// Anything after this is part of the machine info and master's address blob
} CTRLMSG_JOIN, * PCTRLMSG_JOIN;

typedef struct tagCTRLMSG_JOINREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the joining slave
} CTRLMSG_JOINREPLY, * PCTRLMSG_JOINREPLY;


typedef struct tagCTRLMSG_READYTOTEST
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the slave
} CTRLMSG_READYTOTEST, * PCTRLMSG_READYTOTEST;


// All testing is completely finished, you are all done.
#define CTRLTS_ALLCOMPLETE				1
// The current pass is finished, reset yourself for the next pass.
#define CTRLTS_REPETITIONCOMPLETE		2

typedef struct tagCTRLMSG_TESTINGSTATUS
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwStatus; // the new status of testing
} CTRLMSG_TESTINGSTATUS, * PCTRLMSG_TESTINGSTATUS;


typedef struct tagCTRLMSG_NEWTEST
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwUniqueTestID; // ID of this test
	int					iNumMachines; // total number of testers running the instance
	DWORD				dwInputDataSize; // size of input data in msg data blob

	// Anything after this is part of the case string, instance string, slave
	// ID array, and input data blob
} CTRLMSG_NEWTEST, * PCTRLMSG_NEWTEST;


typedef struct tagCTRLMSG_ANNOUNCESUBTEST
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the announcer
	DWORD				dwRequestID; // ID used to correlate response to this request
	DWORD				dwTopLevelUniqueID; // ID of the top most test in the heirarchy
	DWORD				dwParentUniqueID; // ID of the parent test
	int					iNumMachines; // number of testers in the tester index list

	// Anything after this is part of the test ID string and tester index list
	// data blob
} CTRLMSG_ANNOUNCESUBTEST, * PCTRLMSG_ANNOUNCESUBTEST;

typedef struct tagCTRLMSG_ANNOUNCETESTREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwResponseID; // Response ID used to correlate this response to the instigating AnnounceSubTest or RequestPokeTest command
	DWORD				dwUniqueTestID; // Unique ID of the test
} CTRLMSG_ANNOUNCETESTREPLY, * PCTRLMSG_ANNOUNCETESTREPLY;

typedef struct tagCTRLMSG_REPORT
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the reporter
	DWORD				dwTopLevelUniqueID; // top level control defined test ID for report
	DWORD				dwTestUniqueID; // control defined test ID this pertains to
	HRESULT				hresult; // success or error code
	BOOL				fTestComplete; // does this stop the test?
	BOOL				fSuccess; // is this a success (duh)?
	DWORD				dwOutputDataSize; // size of output data
	DWORD				dwVarsSize; // size of variables list data

	// Anything after this is part of the output data and variables blob
} CTRLMSG_REPORT, * PCTRLMSG_REPORT;

typedef struct tagCTRLMSG_WARNING
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the reporter
	DWORD				dwTopLevelUniqueID; // top level control defined test ID for report
	DWORD				dwTestUniqueID; // control defined test ID this pertains to
	HRESULT				hresult; // warning hresult code
	DWORD				dwUserDataSize; // size of user data

	// Anything after this is part of the warning data blob
} CTRLMSG_WARNING, * PCTRLMSG_WARNING;

typedef struct tagCTRLMSG_REQUESTSYNC
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the requestor
	DWORD				dwRequestID; // ID used to correlate response to this request
	DWORD				dwTopLevelUniqueID; // top level control defined test ID for sync
	DWORD				dwTestUniqueID; // control defined test ID that's trying to sync
	DWORD				dwNameSize; // size of name of sync
	int					iNumMachines; // how many tester IDs
	DWORD				dwDataSize; // size of data to send to sync-ers

	// Anything after this is part of the sync name and data blob
} CTRLMSG_REQUESTSYNC, * PCTRLMSG_REQUESTSYNC;

typedef struct tagCTRLMSG_SYNCREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwResponseID; // ID used to correllate this response to the request
	DWORD				dwDataSize; // size of data received from sync-ers

	// Anything after this is part of the sync data blob
} CTRLMSG_SYNCREPLY, * PCTRLMSG_SYNCREPLY;

typedef struct tagCTRLMSG_USERQUERY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwQuery; // user defined query ID or command
	DWORD				dwDataSize; // size of extra query data

	// Anything after this is part of the query data blob
} CTRLMSG_USERQUERY, * PCTRLMSG_USERQUERY;

typedef struct tagCTRLMSG_USERRESPONSE
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwResponse; // user defined response ID or command
	DWORD				dwDataSize; // size of extra response data

	// Anything after this is part of the response data blob
} CTRLMSG_USERRESPONSE, * PCTRLMSG_USERRESPONSE;


#define CTRLIDLE_NOTHING			1
#define CTRLIDLE_ANNOUNCESUBTEST	2
#define CTRLIDLE_SYNC				3

typedef struct tagCTRLMSG_IDLE
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the sender
	DWORD				dwWaitingOp; // one of the above current operations that is waiting
} CTRLMSG_IDLE, * PCTRLMSG_IDLE;


#define CTRLIDLEREPLY_WAITINGFOROTHERTESTERS	1

typedef struct tagCTRLMSG_IDLEREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwStatus; // one of the above possible status codes
} CTRLMSG_IDLEREPLY, * PCTRLMSG_IDLEREPLY;


typedef struct tagCTRLMSG_BREAK
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwUniqueTestID; // ID of test this break request pertains to
} CTRLMSG_BREAK, * PCTRLMSG_BREAK;


typedef struct tagCTRLMSG_QUERYMETAMASTER
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwMetaVersion; // version of the meta-master control layer API 
	DWORD				dwControlVersion; // version of the main control layer API 
	TNMODULEID			moduleID; // structure that identifies the type of session we're looking for
	DWORD				dwMode; // session mode we are looking for

	// Anything after this is part of the user specified session ID string.
} CTRLMSG_QUERYMETAMASTER, * PCTRLMSG_QUERYMETAMASTER;


#define CTRLMETAMASTERREPLY_NOMASTERSAVAILABLE		1
#define CTRLMETAMASTERREPLY_FOUNDMASTER				2

typedef struct tagCTRLMSG_METAMASTERREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwStatus; // what type of status this is

	// Anything after this is part of the master's address string.
} CTRLMSG_METAMASTERREPLY, * PCTRLMSG_METAMASTERREPLY;


typedef struct tagCTRLMSG_REGISTERMASTER
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwMetaVersion; // version of the meta-master control layer API
	DWORD				dwControlVersion; // version of the main control layer API
	DWORD				dwSessionID; // self-described ID of the session
	TNMODULEID			moduleID; // structure that identifies the type of session we're looking for
	DWORD				dwMode; // session mode we are looking for
	DWORD				dwAddressSize; // size of address string
	DWORD				dwSessionFilterSize; // size of session filter string

	// Anything after this is part of the address and user specified session
	// filter strings.
} CTRLMSG_REGISTERMASTER, * PCTRLMSG_REGISTERMASTER;

typedef struct tagCTRLMSG_REGISTERMASTERREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the registered master
} CTRLMSG_REGISTERMASTERREPLY, * PCTRLMSG_REGISTERMASTERREPLY;

typedef struct tagCTRLMSG_REQUESTMASTERUPDATE
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
} CTRLMSG_REQUESTMASTERUPDATE, * PCTRLMSG_REQUESTMASTERUPDATE;

typedef struct tagCTRLMSG_MASTERUPDATE
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the registered master
	int					iNumSlaves; // how many slaves are currently in the session
	BOOL				fJoinersAllowed; // whether new joiners are currently allowed
} CTRLMSG_MASTERUPDATE, * PCTRLMSG_MASTERUPDATE;

typedef struct tagCTRLMSG_UNREGISTERMASTER
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the registered master
} CTRLMSG_UNREGISTERMASTER, * PCTRLMSG_UNREGISTERMASTER;

typedef struct tagCTRLMSG_MASTERPINGSLAVE
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

} CTRLMSG_MASTERPINGSLAVE, * PCTRLMSG_MASTERPINGSLAVE;

typedef struct tagCTRLMSG_MASTERPINGSLAVEREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the joining slave
} CTRLMSG_MASTERPINGSLAVEREPLY, * PCTRLMSG_MASTERPINGSLAVEREPLY;


typedef struct tagCTRLMSG_DUMPLOG
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwUniqueTestID; // test ID (basically the reason) that this was generated from
	DWORD				dwPathSize; // size of path to dump memory log to

	// Anything after this is part of the path to dump to.
} CTRLMSG_DUMPLOG, * PCTRLMSG_DUMPLOG;

typedef struct tagCTRLMSG_REQUESTPOKETEST
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the announcer
	DWORD				dwRequestID; // ID used to correlate response to this request
	int					iNumMachines; // number of slave IDs in the tester list
	DWORD				dwInputDataSize; // size of input data being used

	// Anything after this is part of the test ID string, slave ID list and input
	// data blob.
} CTRLMSG_REQUESTPOKETEST, * PCTRLMSG_REQUESTPOKETEST;

typedef struct tagCTRLMSG_LOSTTESTER
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwTopLevelUniqueID; // top level control defined test ID for test
	DWORD				dwTestUniqueID; // control defined test ID for test
	int					iTesterNum; // tester who was lost
} CTRLMSG_LOSTTESTER, * PCTRLMSG_LOSTTESTER;

typedef struct tagCTRLMSG_ACCEPTREACHCHECK
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwID; // ID of this reach check
	DWORD				dwMethod; // type of communication that should be accepted
	DWORD				dwMethodDataSize; // size of extra method data, if any

	// Anything after this is part of the method data.
} CTRLMSG_ACCEPTREACHCHECK, * PCTRLMSG_ACCEPTREACHCHECK;

typedef struct tagCTRLMSG_ACCEPTREACHCHECKREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the machine replying
	DWORD				dwID; // ID of this reach check
	BOOL				fReady; // whether the slave can accept communication or not
	HRESULT				hresult; // failure code of the operation, if not ready
} CTRLMSG_ACCEPTREACHCHECKREPLY, * PCTRLMSG_ACCEPTREACHCHECKREPLY;

typedef struct tagCTRLMSG_CONNECTREACHCHECK
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwID; // ID of this reach check
	TNCTRLMACHINEID		idTarget; // ID of the target to reach
	DWORD				dwMethod; // type of communication that should be accepted
	DWORD				dwMethodDataSize; // size of extra method data, if any
	DWORD				dwAddressesSize; // size of addresses to use buffer
	TNCTRLMACHINEID		idPreviousTarget; // ID of target on same machine already checked, if any

	// Anything after this is part of the method data and addresses buffer.
} CTRLMSG_CONNECTREACHCHECK, * PCTRLMSG_CONNECTREACHCHECK;

typedef struct tagCTRLMSG_CONNECTREACHCHECKREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the machine replying
	DWORD				dwID; // ID of this reach check
	BOOL				fReachable; // whether the slave can reach the target or not
	HRESULT				hresult; // failure code of the operation, if unreachable
} CTRLMSG_CONNECTREACHCHECKREPLY, * PCTRLMSG_CONNECTREACHCHECKREPLY;

typedef struct tagCTRLMSG_INTERSLAVEREACHCHECK
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the machine sending
	DWORD				dwID; // ID of reach check the message is being sent for
	BOOL				fGuaranteed; // whether this item is being sent guaranteed or not
	DWORD				dwUsedAddressSize; // size of address data this message is being sent to

	// Anything after this is part of the address data.
} CTRLMSG_INTERSLAVEREACHCHECK, * PCTRLMSG_INTERSLAVEREACHCHECK;

typedef struct tagCTRLMSG_INTERSLAVEREACHCHECKREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the machine replying
	DWORD				dwID; // ID of reach check the message was received for
	DWORD				dwUsedAddressSize; // size of echoed data from message being replied to

	// Anything after this is part of the address data.
} CTRLMSG_INTERSLAVEREACHCHECKREPLY, * PCTRLMSG_INTERSLAVEREACHCHECKREPLY;

typedef struct tagCTRLMSG_FREEOUTPUTVARS
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the machine replying
	DWORD				dwCaseIDSize; // size of the case ID string to match, if any
	DWORD				dwInstanceIDSize; // size of the instance ID string to match, if any
	DWORD				dwNameSize; // size of the output variable name string to match, if any
	DWORD				dwTypeSize; // size of the output variable type string to match, if any

	// Anything after this is part of the case ID, instance ID, name and type
	// strings.
} CTRLMSG_FREEOUTPUTVARS, * PCTRLMSG_FREEOUTPUTVARS;

typedef struct tagCTRLMSG_GETMACHINEINFO
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	TNCTRLMACHINEID		id; // the ID of the machine sending
	DWORD				dwRequestID; // ID used to correlate response to this request
	TNCTRLMACHINEID		idMachineForInfo; // the ID of the machine whose info is to be retrieved
} CTRLMSG_GETMACHINEINFO, * PCTRLMSG_GETMACHINEINFO;

typedef struct tagCTRLMSG_GETMACHINEINFOREPLY
{
	// These fields must be the same as the ones in CTRLMSG_GENERIC
	DWORD				dwSize; // how big is this message
	DWORD				dwType; // ID of this message, see CTRLMSGID defines for values

	// These fields are unique to this message
	DWORD				dwResponseID; // echo of ID of request that generated this response
	DWORD				dwMachineInfoSize; // size of machine info

	// Anything after this is part of the machine info data.
} CTRLMSG_GETMACHINEINFOREPLY, * PCTRLMSG_GETMACHINEINFOREPLY;







#else //__TNCONTROL_MESSAGES__
//#pragma message("__TNCONTROL_MESSAGES__ already included!")
#endif //__TNCONTROL_MESSAGES__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\meta.h ===
#ifndef _XBOX // ! no master supported
#ifndef __TNCONTROL_META__
#define __TNCONTROL_META__
//#pragma message("Defining __TNCONTROL_META__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNMetaMaster:public CTNControlLayer
{
	private:
		CTNMastersList	m_masters;



		HRESULT HandleQueryMetaMasterMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_QUERYMETAMASTER pQueryMetaMasterMsg);

		HRESULT HandleRegisterMasterMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_REGISTERMASTER pRegisterMasterMsg);

		HRESULT HandleMasterUpdateMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_MASTERUPDATE pMasterUpdateMsg);

		HRESULT HandleUnregisterMasterMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_UNREGISTERMASTER pUnregisterMasterMsg);


	public:
		CTNMetaMaster(void);
		virtual ~CTNMetaMaster(void);


		HRESULT StartupMetaMaster(PTNSTARTUPMETAMASTERDATA pStartupMetaMasterData);
		HRESULT CleanupMetaMaster(void);

		// Virtual implementations
		HRESULT HandleMessage(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
							  PVOID pvData, DWORD dwDataSize);
};







#else //__TNCONTROL_META__
//#pragma message("__TNCONTROL_META__ already included!")
#endif //__TNCONTROL_META__
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\meta.cpp ===
#ifndef _XBOX // ! no master supported
//==================================================================================
// Includes
//==================================================================================
#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock2 fn proto's, for getprocaddress
#ifndef _XBOX
#include <winsock2.h>
#else // ! XBOX
#include <winsockx.h>		// Needed for XnetInitialize
#endif // XBOX
#include <windows.h>

#include <time.h>


#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\errors.h"

#include "tncontrl.h"
#include "main.h"
#include "sendq.h"
#include "comm.h"
#include "commtcp.h"
#include "masterinfo.h"
#include "meta.h"







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::CTNMetaMaster()"
//==================================================================================
// CTNMetaMaster constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNMetaMaster object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNMetaMaster::CTNMetaMaster(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNMetaMaster));
} // CTNMetaMaster::CTNMetaMaster
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::~CTNMetaMaster()"
//==================================================================================
// CTNMetaMaster destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNMetaMaster object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNMetaMaster::~CTNMetaMaster(void)
{
	HRESULT				hr;


	//DPL(0, "this = %x", 1, this);

	hr = this->CleanupMetaMaster();
	if (hr != S_OK)
	{
		DPL(0, "Cleaning up failed!  %e", 1, hr);
	} // end if (cleaning up failed)
} // CTNMetaMaster::~CTNMetaMaster
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::StartupMetaMaster()"
//==================================================================================
// CTNMetaMaster::StartupMetaMaster
//----------------------------------------------------------------------------------
//
// Description: Starts up the meta master and prepares it for its job.
//
// Arguments:
//	PTNSTARTUPMETAMASTERDATA pStartupMetaMasterData		Parameter block.  See header
//														file for information.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMetaMaster::StartupMetaMaster(PTNSTARTUPMETAMASTERDATA pStartupMetaMasterData)
{
	HRESULT					hr;
	CONTROLCOMMINITPBLOCK	ctrlcomminitparams;


	if (this == NULL)
	{
		DPL(0, "Meta-master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we got passed a bad pointer)

	if (pStartupMetaMasterData->dwSize != sizeof (TNSTARTUPMETAMASTERDATA))
	{
		DPL(0, "Must pass a structure of correct size!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (got passed an invalid parameter)

	if (pStartupMetaMasterData->dwAPIVersion != CURRENT_TNCONTROL_API_VERSION)
	{
		DPL(0, "WARNING: Caller requesting different API version (%i != %i), problems may occur.",
			2, pStartupMetaMasterData->dwAPIVersion, CURRENT_TNCONTROL_API_VERSION);
	} // end if (got passed an invalid parameter)

	if ((pStartupMetaMasterData->dwControlMethodID != TN_CTRLMETHOD_TCPIP_OPTIMAL) &&
		(pStartupMetaMasterData->dwControlMethodID != TN_CTRLMETHOD_TCPIP_WINSOCK1))
	{
		DPL(0, "Must pass a control method ID!", 0);
		return (ERROR_INVALID_PARAMETER);
	} // end if (got passed an invalid parameter)

	/*
	this->m_hAllSlavesCommStatusEvent = CreateEvent(NULL, false, false, NULL);
	if (this->m_hAllSlavesCommStatusEvent == NULL)
	{
		DPL(0, "Failed to create comm status event!", 0);
		return (GetLastError());
	} // end if (failed to create event)
	*/

	ZeroMemory(&ctrlcomminitparams, sizeof (CONTROLCOMMINITPBLOCK));
	ctrlcomminitparams.dwSize = sizeof (CONTROLCOMMINITPBLOCK);
	ctrlcomminitparams.dwControlMethodID = pStartupMetaMasterData->dwControlMethodID;
	ctrlcomminitparams.pControlLayerObj = this;
	ctrlcomminitparams.fMaster = TRUE; // we're accepting data, so we're considered a master
	ctrlcomminitparams.dwFlags = pStartupMetaMasterData->dwMethodFlags;
	ctrlcomminitparams.pvData = pStartupMetaMasterData->pvMethodData;
	ctrlcomminitparams.dwDataSize = pStartupMetaMasterData->dwMethodDataSize;

	// Initialize desired control method
	switch (pStartupMetaMasterData->dwControlMethodID)
	{
		case TN_CTRLMETHOD_TCPIP_OPTIMAL:
			hr = CtrlCommTCPLoadOptimal(&ctrlcomminitparams, &(this->m_pCtrlComm));
			if (hr != S_OK)
			{
				DPL(0, "Initializing TCP/IP optimal control method failed!", 0);
				return (hr);
			} // end if (initting TCP/IP optimal control method failed)
		break;

		case TN_CTRLMETHOD_TCPIP_WINSOCK1:
			hr = CtrlCommTCPLoadWinSock1(&ctrlcomminitparams, &(this->m_pCtrlComm));
			if (hr != S_OK)
			{
				DPL(0, "Initializing TCP/IP WinSock1 control method failed!", 0);
				return (hr);
			} // end if (initting TCP/IP WinSock1 control method failed)
		  break;
	} // end switch (on control method ID)

	this->m_pfnLogString = pStartupMetaMasterData->pfnLogString;
	if (pStartupMetaMasterData->hCompletionOrUpdateEvent != NULL)
	{
		if (! DuplicateHandle(GetCurrentProcess(), pStartupMetaMasterData->hCompletionOrUpdateEvent,
								GetCurrentProcess(), &(this->m_hCompletionOrUpdateEvent),
								0, FALSE, DUPLICATE_SAME_ACCESS))
		{
			hr = GetLastError();
			DPL(0, "Couldn't duplicate user's completion or update event handle (%x)!",
				2, pStartupMetaMasterData->hCompletionOrUpdateEvent);
			return (hr);
		} // end if (couldn't duplicate handle)
	} // end if (there's an event)

	// Initialize control communication method
	hr = this->m_pCtrlComm->Initialize();
	if (hr != S_OK)
	{
		DPL(0, "Initializing control communications method failed!", 0);
		return (hr);
	} // end if (initting ctrl comm failed)


	// Do a stats refresh, even though we don't keep any stats there.  This is used
	// to let the app know the meta-master is ready.
	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		return (hr);
	} // end if (couldn't set the user's update event)

	return (S_OK);
} // CTNMetaMaster::StartupMetaMaster
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::CleanupMetaMaster()"
//==================================================================================
// CTNMetaMaster::CleanupMetaMaster
//----------------------------------------------------------------------------------
//
// Description: Shuts down this meta master and releases the ctrl comm object if
//				it existed.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMetaMaster::CleanupMetaMaster(void)
{
	HRESULT			hr = S_OK;
	PTNMASTERINFO	pMaster = NULL;

	
	if (this == NULL)
	{
		DPL(0, "Meta-master object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we got passed a bad pointer)

	this->m_masters.EnterCritSection();
	while (this->m_masters.Count() > 0)
	{
		pMaster = (PTNMASTERINFO) this->m_masters.GetItem(0);
		if (pMaster == NULL)
		{
			DPL(0, "Couldn't get first master in list!", 0);
			break;
		} // end if (couldn't get item)

		hr = this->m_pCtrlComm->UnbindDataFromAddress(&(pMaster->m_commdata));
		if (hr != S_OK)
		{
			DPL(0, "Unbinding master's comm data failed!  %e", 1, hr);
		} // end if (releasing control method failed)

		hr = this->m_masters.Remove(0);
		if (hr != S_OK)
		{
			DPL(0, "Removing master from list failed!  %e", 1, hr);
		} // end if (releasing control method failed)
	} // end for (each master)
	this->m_masters.LeaveCritSection();

	if (this->m_pCtrlComm != NULL)
	{
		hr = this->m_pCtrlComm->Release();
		if (hr != S_OK)
		{
			DPL(0, "Releasing control communication method failed!  %e", 1, hr);
		} // end if (releasing control method failed)

		delete (this->m_pCtrlComm);
		this->m_pCtrlComm = NULL;
	} // end if (we're still validly connected to the control method)

	/*
	if (this->m_hAllSlavesCommStatusEvent != NULL)
	{
		CloseHandle(this->m_hAllSlavesCommStatusEvent);
		this->m_hAllSlavesCommStatusEvent = NULL;
	} // end if (we created a comm status event)
	*/

	if (this->m_hCompletionOrUpdateEvent != NULL)
	{
		CloseHandle(this->m_hCompletionOrUpdateEvent);
		this->m_hCompletionOrUpdateEvent = NULL;
	} // end if (have event)

	return (hr);
} // CTNMetaMaster::CleanupMetaMaster
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::HandleMessage()"
//==================================================================================
// CTNMetaMaster::HandleMessage
//----------------------------------------------------------------------------------
//
// Description: Handles an incoming control session message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm
//								from address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PVOID pvData				Pointer to data received by ctrl comm.
//	DWORD dwDataSize			Size of data.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMetaMaster::HandleMessage(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PVOID pvData, DWORD dwDataSize)
{
	PCTRLMSG_GENERIC	pGenericMsg = NULL;


	if ((*ppvFromAddress) == NULL)
	{
		DPL(0, "WARNING!  No from address!", 0);
	} // end if (no from address info)

	if (dwDataSize < sizeof (CTRLMSG_GENERIC))
	{
		DPL(0, "Data too small to be valid message!  Ignoring.", 0);
		return (S_OK);
	} // end if (smaller than the smallest valid message)

	pGenericMsg = (PCTRLMSG_GENERIC) pvData;
	
	if (pGenericMsg->dwSize != dwDataSize)
	{
		DPL(0, "Incomplete or invalid message (expected size %i bytes differs from actual size %i bytes)!  Ignoring.",
			2, pGenericMsg->dwSize, dwDataSize);
		return (S_OK);
	} // end if (didn't get complete/valid message)

	switch(pGenericMsg->dwType)
	{
		case CTRLMSGID_QUERYMETAMASTER:
			if (dwDataSize < sizeof (CTRLMSG_QUERYMETAMASTER))
			{
				DPL(0, "Data too small to be valid QueryMetaMaster message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid querymetamaster message)

			return (this->HandleQueryMetaMasterMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_QUERYMETAMASTER) pGenericMsg));
		  break;

		case CTRLMSGID_REGISTERMASTER:
			if (dwDataSize < sizeof (CTRLMSG_REGISTERMASTER))
			{
				DPL(0, "Data too small to be valid RegisterMaster message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid registermaster message)

			return (this->HandleRegisterMasterMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_REGISTERMASTER) pGenericMsg));
		  break;

		case CTRLMSGID_MASTERUPDATE:
			if (dwDataSize < sizeof (CTRLMSG_MASTERUPDATE))
			{
				DPL(0, "Data too small to be valid MasterUpdate message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid masterupdate message)

			return (this->HandleMasterUpdateMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_MASTERUPDATE) pGenericMsg));
		  break;

		case CTRLMSGID_UNREGISTERMASTER:
			if (dwDataSize < sizeof (CTRLMSG_UNREGISTERMASTER))
			{
				DPL(0, "Data too small to be valid UnregisterMaster message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid unregistermaster message)

			return (this->HandleUnregisterMasterMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_UNREGISTERMASTER) pGenericMsg));
		  break;

		default:
			DPL(0, "Message of invalid/unknown type (%i)!  Ignoring.", 1, pGenericMsg->dwType);
		  break;
	} // end switch (on message type)

	return (S_OK);
} // CTNMetaMaster::HandleMessage
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::HandleQueryMetaMasterMsg()"
//==================================================================================
// CTNMetaMaster::HandleQueryMetaMasterMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session query meta master message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_QUERYMETAMASTER pQueryMetaMasterMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMetaMaster::HandleQueryMetaMasterMsg(PVOID* ppvFromAddress,
												DWORD dwFromAddressSize,
												PCTRLMSG_QUERYMETAMASTER pQueryMetaMasterMsg)
{
	HRESULT						hr = S_OK;
	DWORD						dwStatus = CTRLMETAMASTERREPLY_NOMASTERSAVAILABLE;
	int							i;
	PTNMASTERINFO				pMaster = NULL;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_METAMASTERREPLY	pReplyMsg = NULL;


	DPL(0, "Got QueryMetaMaster message.", 0);


	// Compare meta-master API versions
	if (pQueryMetaMasterMsg->dwMetaVersion != CURRENT_METAMASTER_API_VERSION)
	{
		DPL(0, "Meta-master control version (%i) is different from ours (%i), ignoring.",
			2, pQueryMetaMasterMsg->dwMetaVersion, CURRENT_METAMASTER_API_VERSION);
		goto DONE;
	} // end if (version isn't the same)


	// Search through our list of masters for one fitting the description this slave
	// is looking for.

	this->m_masters.EnterCritSection();
	for(i = 0; i < this->m_masters.Count(); i++)
	{
		pMaster = (PTNMASTERINFO) this->m_masters.GetItem(i);
		if (pMaster == NULL)
		{
			DPL(0, "Couldn't get master %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		// If the master isn't allowing joiners, don't even bother.
		if (! pMaster->m_fJoinersAllowed)
			continue;

		// Compare app IDs
		if ((strcmp(pMaster->m_moduleID.szBriefName, pQueryMetaMasterMsg->moduleID.szBriefName) != 0) ||
			(pMaster->m_moduleID.dwMajorVersion != pQueryMetaMasterMsg->moduleID.dwMajorVersion) ||
			(pMaster->m_moduleID.dwMinorVersion1 != pQueryMetaMasterMsg->moduleID.dwMinorVersion1))
		{
			// Skip it if it didn't match
			continue;
		} // end if (failed to match the requested module id)


		// Compare user specified session IDs
		if (pMaster->m_pszSessionFilter == NULL)
		{
			if (strcmp((char*) (pQueryMetaMasterMsg + 1), "") != 0)
			{
				// Skip it if it didn't match
				continue;
			} // end if (the enum request is for a specific session)
		} // end if (we are not a specific session)
		else
		{
			if (strcmp(pMaster->m_pszSessionFilter, (char*) (pQueryMetaMasterMsg + 1)) != 0)
			{
				// Skip it if it didn't match
				continue;
			} // end if (the query is for a different/no session)
		} // end else (we are a specific session)

		// Make sure it's not overloaded with slaves already
		if (pMaster->m_iNumSlaves >= 5)
		{
			// Skip it.
			continue;
		} // end if (master has at least 5 slaves already)

		// If we got here, we found a master that matches the requirements.
		dwStatus = CTRLMETAMASTERREPLY_FOUNDMASTER;


		DPL(0, "Having slave try joining master with address \"%s\".",
			1, pMaster->m_pszAddress);

		this->Log(TNLST_CONTROLLAYER_INFO,
				"Having slave try joining master with address \"%s\".",
				1, pMaster->m_pszAddress);
		
		break;
	} // end for each master we know about)
	this->m_masters.LeaveCritSection();


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_METAMASTERREPLY);
	if (dwStatus == CTRLMETAMASTERREPLY_FOUNDMASTER)
		pSendData->m_dwDataSize += strlen(pMaster->m_pszAddress) + 1;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_METAMASTERREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_METAMASTERREPLY;
	pReplyMsg->dwStatus = dwStatus;
	if (dwStatus == CTRLMETAMASTERREPLY_FOUNDMASTER)
	{
		strcpy((char*) (pReplyMsg + 1), pMaster->m_pszAddress);
	} // end if (found master)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNMetaMaster::HandleQueryMetaMasterMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::HandleRegisterMasterMsg()"
//==================================================================================
// CTNMetaMaster::HandleRegisterMasterMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session register master message.
//
// Arguments:
//	PVOID* ppvFromAddress						Pointer to pointer to data
//												describing ctrl comm from
//												address.
//	DWORD dwFromAddressSize						Size of from address data.
//	PCTRLMSG_REGISTERMASTER pRegisterMasterMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMetaMaster::HandleRegisterMasterMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
												PCTRLMSG_REGISTERMASTER pRegisterMasterMsg)
{
	HRESULT							hr = S_OK;
	PTNMASTERINFO					pNewMachine = NULL;
	PTNSENDDATA						pSendData = NULL;
	PCTRLMSG_REGISTERMASTERREPLY	pReplyMsg = NULL;


	DPL(0, "Got RegisterMaster message.", 0);

	// Compare meta-master API versions
	if (pRegisterMasterMsg->dwMetaVersion != CURRENT_METAMASTER_API_VERSION)
	{
		DPL(0, "Meta-master control version (%i) is different from ours (%i), ignoring.",
			2, pRegisterMasterMsg->dwMetaVersion, CURRENT_METAMASTER_API_VERSION);
		goto DONE;
	} // end if (version isn't the same)

	pNewMachine = new (CTNMasterInfo);
	if (pNewMachine == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pNewMachine->m_dwControlVersion = pRegisterMasterMsg->dwControlVersion;
	pNewMachine->m_dwSessionID = pRegisterMasterMsg->dwSessionID;
	CopyMemory(&(pNewMachine->m_moduleID), &(pRegisterMasterMsg->moduleID), sizeof (TNMODULEID));
	pNewMachine->m_dwMode = pRegisterMasterMsg->dwMode;

	pNewMachine->m_pszAddress = (char*) LocalAlloc(LPTR, (pRegisterMasterMsg->dwAddressSize + 1));
	if (pNewMachine->m_pszAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	CopyMemory(pNewMachine->m_pszAddress, (pRegisterMasterMsg + 1),
			pRegisterMasterMsg->dwAddressSize);
	pNewMachine->m_pszAddress[pRegisterMasterMsg->dwAddressSize] = '\0'; // NULL termination

	if (pRegisterMasterMsg->dwSessionFilterSize > 0)
	{
		pNewMachine->m_pszSessionFilter = (char*) LocalAlloc(LPTR, (pRegisterMasterMsg->dwSessionFilterSize + 1));
		if (pNewMachine->m_pszSessionFilter == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
		CopyMemory(pNewMachine->m_pszSessionFilter,
				((LPBYTE) (pRegisterMasterMsg + 1)) + pRegisterMasterMsg->dwAddressSize,
				pRegisterMasterMsg->dwSessionFilterSize);
	} // end if (there's a session string)

	// Assign it an ID
	pNewMachine->m_id.dwTime = GetTickCount();

	//pNewMachine->commdata.hStatusEvent = this->m_hAllSlavesCommStatusEvent;
	pNewMachine->m_commdata.fDropped = FALSE;
	pNewMachine->m_commdata.pvAddress = (*ppvFromAddress);
	pNewMachine->m_commdata.dwAddressSize = dwFromAddressSize;

	hr = this->m_pCtrlComm->BindDataToAddress(&(pNewMachine->m_commdata));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't bind new machine's control comm data!", 0);
		goto DONE;
	} // end if (couldn't bind ctrl comm address)

	DPL(0, "Adding master at address \"%s\", session ID = %u.",
		2, pNewMachine->m_pszAddress, pNewMachine->m_dwSessionID);

	this->Log(TNLST_CONTROLLAYER_INFO,
			"Adding master at address \"%s\", session ID = %u.",
			2, pNewMachine->m_pszAddress, pNewMachine->m_dwSessionID);

	// Add it to the list
	hr = this->m_masters.Add(pNewMachine);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add new machine to our list!", 0);
		goto DONE;
	} // end if (couldn't add machine to list)

	// Send a reply
	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		pNewMachine = NULL; // forget about it, the list owns it now
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, dwFromAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		pNewMachine = NULL; // forget about it, the list owns it now
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	CopyMemory(pSendData->m_pvAddress, (*ppvFromAddress), dwFromAddressSize);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_REGISTERMASTERREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		pNewMachine = NULL; // forget about it, the list owns it now
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_REGISTERMASTERREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_REGISTERMASTERREPLY;

	CopyMemory(&(pReplyMsg->id), &(pNewMachine->m_id), sizeof (TNCTRLMACHINEID));

	pNewMachine = NULL; // forget about it so we don't free it below
	
	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pNewMachine != NULL)
		delete (pNewMachine);

	if (pSendData != NULL)
		delete (pSendData);

	return (hr);
} // CTNMetaMaster::HandleRegisterMasterMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::HandleMasterUpdateMsg()"
//==================================================================================
// CTNMetaMaster::HandleMasterUpdateMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session master update reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_MASTERUPDATEREPLY pMasterUpdateMsg		The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMetaMaster::HandleMasterUpdateMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_MASTERUPDATE pMasterUpdateMsg)
{
	PTNMASTERINFO	pMaster = NULL;


	DPL(0, "Got MasterUpdate message.", 0);

	pMaster = this->m_masters.GetMasterByID(&(pMasterUpdateMsg->id));
	if (pMaster == NULL)
	{
		DPL(0, "Couldn't find updating master (%i) in list!  Ignoring.",
			1, pMasterUpdateMsg->id.dwTime);

		// BUGBUG Fail?
		return (S_OK);
	} // end if (couldn't get slaveinfo object)

	pMaster->m_iNumSlaves = pMasterUpdateMsg->iNumSlaves;
	pMaster->m_fJoinersAllowed = pMasterUpdateMsg->fJoinersAllowed;

	DPL(0, "Master \"%s\" now has %i slaves, and is%saccepting joiners.",
		3, pMaster->m_pszAddress, pMaster->m_iNumSlaves,
		(pMasterUpdateMsg->fJoinersAllowed ? " " : " not "));

	return (S_OK);
} // CTNMetaMaster::HandleMasterUpdateMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNMetaMaster::HandleUnregisterMasterMsg()"
//==================================================================================
// CTNMetaMaster::HandleUnregisterMasterMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session unregister master message.
//
// Arguments:
//	PVOID* ppvFromAddress								Pointer to pointer to data
//														describing ctrl comm from
//														address.
//	DWORD dwFromAddressSize								Size of from address data.
//	LPCTRLMSG_UNREGISTERMASTER lpUnregisterMasterMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNMetaMaster::HandleUnregisterMasterMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
												PCTRLMSG_UNREGISTERMASTER pUnregisterMasterMsg)
{
	HRESULT			hr;
	PTNMASTERINFO	pMaster = NULL;


	DPL(0, "Got UnregisterMaster message.", 0);

	pMaster = this->m_masters.GetMasterByID(&(pUnregisterMasterMsg->id));
	if (pMaster == NULL)
	{
		DPL(0, "Couldn't find unregistering master (%i) in list!  Ignoring.",
			1, pUnregisterMasterMsg->id.dwTime);

		// BUGBUG Fail?
		return (S_OK);
	} // end if (couldn't get slaveinfo object)

	hr = this->m_masters.RemoveFirstReference(pMaster);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove just found master %x!", 1, pMaster);
		return (hr);
	} // end if (couldn't remove master)


	DPL(0, "Removing master at address \"%s\".", 1, pMaster->m_pszAddress);

	this->Log(TNLST_CONTROLLAYER_INFO, "Removing master at address \"%s\".",
			1, pMaster->m_pszAddress);

	if (pMaster->m_dwRefCount != 0)
	{
		DPL(0, "WARNING: Master %x still has %i references!",
			2, pMaster, pMaster->m_dwRefCount);
	} // end if (that wasn't the last use of the object)
	else
	{
		hr = this->m_pCtrlComm->UnbindDataFromAddress(&(pMaster->m_commdata));
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unbind machine's control comm data!", 0);
			return (hr);
		} // end if (couldn't unbind ctrl comm address)

		delete (pMaster);
		pMaster = NULL;
	} // end else (that was the last use of the object)

	return (S_OK);
} // CTNMetaMaster::HandleUnregisterMasterMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\periodicq.h ===
#ifndef __TNCONTROL_PERIODICQUEUE__
#define __TNCONTROL_PERIODICQUEUE__
//#pragma message("Defining __TNCONTROL_PERIODICQUEUE__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNPeriodicSend:public CTNSendData
{
	// These are friends so they can access the protected members.
	friend CTNSlave;
	friend CTNReachCheck;
	friend DWORD WINAPI SlavePeriodicSendThreadProc(LPVOID lpvParameter);


	protected:
		PTNCTRLCOMM						m_pCtrlComm; // control comm object to use when sending
		DWORD							m_dwInterval; // how often to resend
		DWORD							m_dwFirstSent; // when this item was first sent
		DWORD							m_dwLastSent; // when this item was last sent
		DWORD							m_dwTimeout; // when this item should stop being sent
		PVOID							m_pvUserContext; // context to use for callback if/when this send times out


		CTNPeriodicSend(void);
		virtual ~CTNPeriodicSend(void);
};

class DLLEXPORT CTNPeriodicSendQueue:public CTNSendDataQueue
{
};






#else //__TNCONTROL_PERIODICQUEUE__
//#pragma message("__TNCONTROL_PERIODICQUEUE__ already included!")
#endif //__TNCONTROL_PERIODICQUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\procs.h ===
#ifndef __TNCONTROL_PROCS__
#define __TNCONTROL_PROCS__
//#pragma message("Defining __TNCONTROL_PROCS__")




//==================================================================================
// External Callback Definitions
//==================================================================================
typedef HRESULT	(__stdcall *PTNLOADTESTTABLEPROC)			(PTNTESTTABLEGROUP);

typedef HRESULT	(__stdcall *PTNLOGSTRINGPROC)				(DWORD, char*);

typedef HRESULT	(__stdcall *PTNGETSTARTUPDATAPROC)			(PVOID, DWORD*);

typedef HRESULT	(__stdcall *PTNLOADSTARTUPDATAPROC)			(PLSTRINGLIST);

typedef HRESULT	(__stdcall *PTNWRITESTARTUPDATAPROC)		(PLSTRINGLIST);

typedef HRESULT	(__stdcall *PTNDOSTARTUPPROC)				(PTNMACHINEINFO, PVOID,
															DWORD, BOOL*);

typedef HRESULT	(__stdcall *PTNINITIALIZETESTINGPROC)		(PTNMACHINEINFO);

typedef HRESULT	(__stdcall *PTNCLEANUPTESTINGPROC)			(PTNMACHINEINFO);

typedef HRESULT (__stdcall *PTNGETTESTINGWINDOWPROC)		(HWND*);

typedef HRESULT	(__stdcall *PTNADDIMPORTANTBINARIESPROC)	(PTNTRACKEDBINARIES);

typedef HRESULT	(__stdcall *PTNHANDLEUSERQUERYPROC)			(DWORD, PVOID, DWORD,
															DWORD*, PVOID, DWORD*);

typedef HRESULT	(__stdcall *PTNCANRUNPROC)					(PTNCANRUNDATA);

typedef HRESULT	(__stdcall *PTNGETINPUTDATAPROC)			(PTNGETINPUTDATA);

typedef HRESULT	(__stdcall *PTNEXECCASEPROC)				(PTNEXECCASEDATA);

typedef HRESULT	(__stdcall *PTNCHANGEBINARYSETPROC)			(DWORD, PTNBINARYMANAGER);

typedef HRESULT	(__stdcall *PTNWRITEDATAPROC)				(PTNWRITEDATA);

typedef HRESULT	(__stdcall *PTNFILTERSUCCESSPROC)			(PTNFILTERSUCCESSDATA);

typedef HRESULT	(__stdcall *PTNPOKETESTCOMPLETEDPROC)		(PTNPOKETESTCOMPLETEDDATA);







#else //__TNCONTROL_PROCS__
//#pragma message("__TNCONTROL_PROCS__ already included!")
#endif //__TNCONTROL_PROCS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tncontrl.rc
//

#define IDD_WAITFORUSEROK               1000
#define IDS_DESCRIPTION                 1001
#define IDS_TONLY_TIMERDESC             1002
#define IDT_TONLY_TIMER                 1003
#define IDD_DBUNAVAILABLE               2000
#define IDS_TIMERDESC					2001
#define IDT_TIMER						2002


#define IDD_PROMPT_OK					101
#define IDD_PROMPT_YESNO				102
#define IDD_PROMPT_SELECTCOMBO			103

#define IDT_MESSAGE						3001
#define IDCB_PROMPT						3002


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\reportlist.h ===
#ifndef _XBOX // reports not supported
#ifndef __TNCONTROL_REPORTLIST__
#define __TNCONTROL_REPORTLIST__
//#pragma message("Defining __TNCONTROL_REPORTLIST__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG







//==================================================================================
// Classes
//==================================================================================
class DLLEXPORT CTNReportsList:public LLIST
{
	// This is a friends so it can use the object.
#ifndef _XBOX // ! no master supported
	friend class CTNMaster;
#endif // ! XBOX


	protected:
		int		m_iMaxNumEntries; // maximum number of entries to allow to accumulate in the list



		CTNReportsList(void);
		virtual ~CTNReportsList(void);



		HRESULT AddReport(DWORD dwType, int iNumMachines, PTNSLAVEINFO* aMachines,
						PTNTESTINSTANCEM pTest, HRESULT hresult,
						PVOID pvData, DWORD dwDataSize);

		PTNREPORT GetNextMatchingReport(PTNREPORT pStartFromItem,
										DWORD dwMatchFlags,
										PTNSLAVESLIST pMachineList,
										PTNTESTMSLIST pTestList,
										BOOL fRemoveStartFromItem);

		void SetMaxNumberReports(int iNumReports);
};






#else //__TNCONTROL_REPORTLIST__
//#pragma message("__TNCONTROL_REPORTLIST__ already included!")
#endif //__TNCONTROL_REPORTLIST__
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\reachcheck.h ===
#ifndef __TNCONTROL_REACHCHECK__
#define __TNCONTROL_REACHCHECK__
//#pragma message("Defining __TNCONTROL_REACHCHECK__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNReachCheck:public LLITEM
{
	// These are friends so they can access the protected members
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNSlave;
	friend CTNReachChecksList;
	friend CTNCtrlCommTCP;


	protected:
		DWORD				m_dwID; // ID of this check instance
		DWORD				m_dwMethod; // method of communication for this check
		PVOID				m_pvMethodData; // pointer to method data
		DWORD				m_dwMethodDataSize; // size of method data
		HANDLE				m_hEvent; // event to signal when operation is done
		BOOL				m_fResult; // is the result a success?
		HRESULT				m_hresult; // error code, if failed
		PTNPERIODICSEND		m_pPeriodicSend; // slave only; periodic send associated with check
		PVOID				m_pvAddress; // slave only; address retrieved
		DWORD				m_dwAddressSize; // slave only; size of address retrieved
		PTNCTRLCOMM			m_pCtrlComm; // slave only; control comm object being used to perform reach check
		PVOID				m_pvCommData; // slave only; data used by the control comm object


		CTNReachCheck(DWORD dwID, DWORD dwMethod, PVOID pvMethodData,
					DWORD dwMethodDataSize);
		virtual ~CTNReachCheck(void);
};

class DLLEXPORT CTNReachChecksList:public LLIST
{
	// These are friends so they can access the protected members.
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNSlave;


	protected:
		PTNREACHCHECK GetCheck(DWORD dwID);
};

class DLLEXPORT CTNReachCheckTarget:public LLITEM
{
	// These are friends so they can access the protected members
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNSlave;
	friend CTNReachCheckTargetsList;


	protected:
		TNCTRLMACHINEID		m_id; // id of other machine the list of checks pertains to
		CTNReachChecksList	m_checks; // list of checks for this machine


		CTNReachCheckTarget(PTNCTRLMACHINEID pSlaveID);
		virtual ~CTNReachCheckTarget(void);
};

class DLLEXPORT CTNReachCheckTargetsList:public LLIST
{
	// These are friends so they can access the protected members.
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNSlave;


	protected:
		PTNREACHCHECKTARGET GetTarget(PTNCTRLMACHINEID pSlaveID);
};





#else //__TNCONTROL_REACHCHECK__
//#pragma message("__TNCONTROL_REACHCHECK__ already included!")
#endif //__TNCONTROL_REACHCHECK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\reportlist.cpp ===
#ifndef _XBOX // reports not supported
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <time.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"
#include "reportitem.h"
#include "slaveinfo.h"

#include "reportlist.h"








#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReportsList::CTNReportsList()"
//==================================================================================
// CTNReportsList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNReportsList object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNReportsList::CTNReportsList(void):
	m_iMaxNumEntries(DEFAULT_MAX_NUM_REPORTS)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNReportsList));
} // CTNReportsList::CTNReportsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReportsList::~CTNReportsList()"
//==================================================================================
// CTNReportsList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNReportsList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNReportsList::~CTNReportsList(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNReportsList::~CTNReportsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReportsList::AddReport()"
//==================================================================================
// CTNReportsList::AddReport
//----------------------------------------------------------------------------------
//
// Description: Adds a new ReportItem object with the given values to this list.
//				The array/lists or the single items can be NULL to not use the
//				parameter.
//				If both the testlist and single test are specified, then the single
//				test is added at the end of the list.
//
// Arguments:
//	DWORD dwType				What kind of report this is.
//	int iNumMachines			The number of machines this report pertains to
//								(number of entries in the following array).
//	PTNSLAVEINFO* apMachines	Array of pointers to machines that this report
//								pertains to (or NULL for none).
//	PTNTESTINSTANCEM pTest		Pointer to the test that this report pertains to (or
//								NULL for none).
//	HRESULT hresult				Result code for report.
//	PVOID pvData				User specific data.
//	DWORD dwDataSize			Size of user data.
//
// Returns: S_OK if succesful, error code otherwise.
//==================================================================================
HRESULT CTNReportsList::AddReport(DWORD dwType, int iNumMachines, PTNSLAVEINFO* apMachines,
							PTNTESTINSTANCEM pTest, HRESULT hresult,
							PVOID pvData, DWORD dwDataSize)
{
	HRESULT				hr;
	PTNREPORT			pReport = NULL;
	int					i;
	PTNSLAVEINFO		pSlave = NULL;
	time_t 				ctimet;
	tm*					pCurrentTime;


	DPL(6, "Adding report type %u, count will probably be %i.", 2, dwType, (this->Count() + 1));

	pReport = new (CTNReport);
	if (pReport == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	if (apMachines != NULL)
	{
		// Loop through and copy all of the machines in the list passed in
		// to the report's internal list.
		for(i = 0; i < iNumMachines; i++)
		{
			pSlave = apMachines[i];

			if (pSlave != NULL)
			{
				hr = pReport->m_machines.Add(pSlave);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add machine %i (%s) to list!",
						2, i, pSlave->m_szComputerName);
					goto DONE;
				} // end if (couldn't add that item)

			} // end if (it's a valid slave)
			else
			{
				DPL(0, "WARNING: Ignoring NULL slave in machine list.", 0);
			} // end else (it's not a valid slave)

		} // end for (each machine to add)

	} // end if (we were given a list of machines)

	if (pTest != NULL)
	{
		pTest->m_dwRefCount++;
		pReport->m_pTest = pTest;
	} // end if (we were given a single test)

	time(&ctimet);
	pCurrentTime = localtime(&ctimet);
	CopyMemory(&(pReport->m_time), pCurrentTime, sizeof (tm));

	pReport->m_dwType = dwType;
	pReport->m_hresult = hresult;
	pReport->m_dwDataSize = 0;
	if ((pvData != NULL) && (dwDataSize > 0))
	{
		pReport->m_dwDataSize = dwDataSize;
		pReport->m_pvData = LocalAlloc(LPTR, dwDataSize);
		if (pReport->m_pvData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
		
		CopyMemory(pReport->m_pvData, pvData, dwDataSize);
	} // end if (there's actually data to add)


	this->EnterCritSection();

	// Make sure we don't go over our limit for number of entries.
	if (this->Count() >= this->m_iMaxNumEntries)
	{
		// Remove the last report in the list.
		hr = this->Remove(this->Count() - 1);
		if (hr != S_OK)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't remove last report in list!", 0);
			goto DONE;
		} // end if (couldn't 
	} // end if (already at limit of entries)

	hr = this->Add(pReport);
	if (hr != S_OK)
	{
		DPL(0, "Adding report item to list failed!", 0);

		// note continuing because that gets us to DONE anyway
	} // end if (add failed)

	this->LeaveCritSection();

	pReport = NULL; // forget about it so we don't free it below


DONE:

	if (pReport != NULL)
	{
		delete (pReport);
		pReport = NULL;
	} // end if (still have report)

	return (hr);
} // CTNReportsList::AddReport
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReportsList::GetNextMatchingReport()"
//==================================================================================
// CTNReportsList::GetNextMatchingReport
//----------------------------------------------------------------------------------
//
// Description: Searches from a given item in the list for the next item that
//				matches the criteria passed in.  If pStartFromItem is NULL, the
//				searching will start at the beginning of the list.  If the lists
//				are not NULL and contains items, then only reports pertaining
//				to those items will be returned.
//
// Arguments:
//	PTNREPORT pStartFromItem		Pointer to object to start looking from.
//	DWORD dwMatchFlags				Criteria to compare an item against.
//	PTNSLAVESLIST pMachineList		Machines to report on.
//	PTNTESTMSLIST pTestList			Tests to report on.
//	BOOL fRemoveStartFromItem		Whether to pull pStartFromItem from the list and
//									delete it.  Ignored if pStartFromItem is NULL.
//
// Returns: Pointer to object or NULL if none found.
//==================================================================================
PTNREPORT CTNReportsList::GetNextMatchingReport(PTNREPORT pStartFromItem,
												DWORD dwMatchFlags,
												PTNSLAVESLIST pMachineList,
												PTNTESTMSLIST pTestList,
												BOOL fRemoveStartFromItem)
{
	HRESULT				hr;
	PTNREPORT			pReport = NULL;
	BOOL				fMatchedType;
	BOOL				fMatchedMachine;
	BOOL				fMatchedTest;
	int					i;
	PTNSLAVEINFO		pSlave = NULL;
	BOOL				fComplete;
	BOOL				fSuccess;
	int					iNumWarnings;


	if ((dwMatchFlags == 0) || (dwMatchFlags == TNREPORT_SUBTESTS))
	{
		DPL(0, "Given invalid match flags (i.e. none or only TNREPORT_SUBTESTS)!", 0);
		return (NULL);
	} // end if (no flags specified)

	this->EnterCritSection();

	if (pStartFromItem == NULL)
		pReport = (PTNREPORT) this->GetItem(0);
	else
	{
		pReport = (PTNREPORT) this->GetNextItem(pStartFromItem);

		if (fRemoveStartFromItem)
		{
			hr = this->RemoveFirstReference(pStartFromItem);
			if (hr != S_OK)
			{
				this->LeaveCritSection();
				DPL(0, "Couldn't remove first reference to starting item %x!  %e",
					2, pStartFromItem, hr);
				return (NULL);
			} // end if (couldn't get next item)

			if (pStartFromItem->m_dwRefCount == 0)
			{
				delete (pStartFromItem);
				pStartFromItem = NULL;
			} // end if (can delete item)
			else
			{
				DPL(0, "Can't delete report item %x because it's refcount is %u!?",
					2, pStartFromItem, pStartFromItem->m_dwRefCount);
			} // end else (can't delete item)
		} // end if (should remove starting point item)
	} // end else (there's a starting item)

	while (pReport != NULL)
	{
		fMatchedType = FALSE;
		fMatchedMachine = FALSE;
		fMatchedTest = FALSE;
		fComplete = FALSE;
		fSuccess = FALSE;
		iNumWarnings = 0;


#pragma BUGBUG(vanceo, "FilterSuccess may override this")
		if ((pReport->m_pTest != NULL) &&
			(pReport->m_pTest->m_fStarted))
		{
			fComplete = TRUE;
			fSuccess = TRUE;

			for(i = 0; i < pReport->m_pTest->m_iNumMachines; i++)
			{
				if (pReport->m_pTest->m_paTesterSlots[i].fComplete)
				{
					if (! pReport->m_pTest->m_paTesterSlots[i].fSuccess)
						fSuccess = FALSE;
				} // end if (this tester completed)
				else
				{
					fComplete = FALSE;
				} // end else (this tester has not completed)

				iNumWarnings += pReport->m_pTest->m_paTesterSlots[i].iNumWarnings;
			} // end for (each tester slot)
		} // end if (there's a test and it has started)


		if ((dwMatchFlags & TNREPORT_NONTESTREPORTS) &&
			((pReport->m_dwType == RT_ADDMACHINE) ||
			(pReport->m_dwType == RT_REMOVEMACHINE) ||
			(pReport->m_dwType == RT_CLOSEDSESSION) ||
			(pReport->m_dwType == RT_ALLTESTINGCOMPLETE)))
		{
			fMatchedType = TRUE;
		} // end if (we're checking for non test reports)
		

		if ((dwMatchFlags & (TNREPORT_TESTASSIGNMENTSTESTNOTCOMPLETE |
							TNREPORT_TESTASSIGNMENTSTESTSUCCEEDED |
							TNREPORT_TESTASSIGNMENTSTESTFAILED |
							TNREPORT_TESTASSIGNMENTSTESTWARNED)) &&
			((pReport->m_dwType == RT_TESTASSIGNED) ||
			((pReport->m_dwType == RT_TESTASSIGNED_SUBTEST) &&
				(dwMatchFlags & TNREPORT_SUBTESTS))))
		{
			// They want to see some kind of test assignment, and this is one.  We
			// need to make sure it fits the specific kind they want.

			if ((dwMatchFlags & TNREPORT_TESTASSIGNMENTSTESTNOTCOMPLETE) &&
				(! fComplete))
			{
				fMatchedType = TRUE;
			} // end if (match not completed)

			if ((dwMatchFlags & TNREPORT_TESTASSIGNMENTSTESTSUCCEEDED) &&
				(fComplete) && (fSuccess))
			{
				fMatchedType = TRUE;
			} // end if (match succeeded)

			if ((dwMatchFlags & TNREPORT_TESTASSIGNMENTSTESTFAILED) &&
				(fComplete) && (! fSuccess))
			{
				fMatchedType = TRUE;
			} // end if (match failed)

			if ((dwMatchFlags & TNREPORT_TESTASSIGNMENTSTESTWARNED) &&
				(iNumWarnings > 0))
			{
				fMatchedType = TRUE;
			} // end if (match warned)
		} // end if (we're checking for test assignments)


		// This is not an else-if because it's possible to be in the above block but
		// not set fMatchedType to TRUE.
		if ((dwMatchFlags & (TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTNOTCOMPLETE |
							TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTSUCCEEDED |
							TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTFAILED |
							TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTWARNED)) &&
			((pReport->m_dwType == RT_TESTCOMPLETELYASSIGNED) ||
			((pReport->m_dwType == RT_TESTCOMPLETELYASSIGNED_SUBTEST) &&
				(dwMatchFlags & TNREPORT_SUBTESTS))))
		{
			// They want to see some kind of test assignment, and this is one.  We
			// need to make sure it fits the specific kind they want.

			if ((dwMatchFlags & TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTNOTCOMPLETE) &&
				(! fComplete))
			{
				fMatchedType = TRUE;
			} // end if (match not completed)

			if ((dwMatchFlags & TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTSUCCEEDED) &&
				(fComplete) && (fSuccess))
			{
				fMatchedType = TRUE;
			} // end if (match succeeded)

			if ((dwMatchFlags & TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTFAILED) &&
				(fComplete) && (! fSuccess))
			{
				fMatchedType = TRUE;
			} // end if (match failed)

			if ((dwMatchFlags & TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTWARNED) &&
				(iNumWarnings > 0))
			{
				fMatchedType = TRUE;
			} // end if (match warned)
		} // end if (we're checking for test assignment completions)

		
		// This is not an else-if because it's possible to be in the above block but
		// not set fMatchedType to TRUE.
		if ((dwMatchFlags & TNREPORT_TESTSUCCESSES) &&
			((pReport->m_dwType == RT_SUCCESSCOMPLETE) ||
			((pReport->m_dwType == RT_SUCCESSCOMPLETE_SUBTEST) &&
				(dwMatchFlags & TNREPORT_SUBTESTS))))
		{
			fMatchedType = TRUE;
		} // end if (we're checking for test successes)
		
		if ((dwMatchFlags & TNREPORT_TESTFAILURES) &&
			((pReport->m_dwType == RT_FAILURECOMPLETE) ||
			((pReport->m_dwType == RT_FAILURECOMPLETE_SUBTEST) &&
				(dwMatchFlags & TNREPORT_SUBTESTS))))
		{
			fMatchedType = TRUE;
		} // end if (we're checking for test successes)
		
		if ((dwMatchFlags & TNREPORT_DURINGTESTSUCCESSES) &&
			((pReport->m_dwType == RT_SUCCESS) ||
			((pReport->m_dwType == RT_SUCCESS_SUBTEST) &&
				(dwMatchFlags & TNREPORT_SUBTESTS))))
		{
			fMatchedType = TRUE;
		} // end if (we're checking for test successes)
		
		if ((dwMatchFlags & TNREPORT_DURINGTESTFAILURES) &&
			((pReport->m_dwType == RT_FAILURE) ||
			((pReport->m_dwType == RT_FAILURE_SUBTEST) &&
				(dwMatchFlags & TNREPORT_SUBTESTS))))
		{
			fMatchedType = TRUE;
		} // end if (we're checking for test successes)
		
		if ((dwMatchFlags & TNREPORT_DURINGTESTWARNINGS) &&
			((pReport->m_dwType == RT_WARNING) ||
			((pReport->m_dwType == RT_WARNING_SUBTEST) &&
				(dwMatchFlags & TNREPORT_SUBTESTS))))
		{
			fMatchedType = TRUE;
		} // end if (we're checking for test successes)

		if (fMatchedType) // don't bother checking if it's not the right type
		{
			// If we don't have to match any machines, then we're done.  Otherwise,
			// we have to check to see if any of the machines we need to match
			// appear in the list of machines this report pertains to.
			if ((pMachineList == NULL) || (pMachineList->Count() <= 0))
			{
				fMatchedMachine = TRUE;
			} // end if (we don't have to match machines)
			else
			{
				pMachineList->EnterCritSection();
				for(i = 0; i < pMachineList->Count(); i++)
				{
					pSlave = (PTNSLAVEINFO) pMachineList->GetItem(i);
					if (pReport->m_machines.GetFirstIndex(pSlave) >= 0)
					{
						fMatchedMachine = TRUE;
						break; // get out of the for loop
					} // end if (we found this machine in the list)
				} // end for (each machine to compare)
				pMachineList->LeaveCritSection();
			} // end if (we're matching a list of machines)

			// If we don't have to match any tests, then we're done.  Otherwise,
			// we have to check to see if any of the tests we need to match
			// appear in the list of test this report pertains to.
			if ((pTestList == NULL) || (pTestList->Count() <= 0))
			{
				fMatchedTest = TRUE;
			} // end if (we don't have to match machines)
			else
			{
				if ((pReport->m_pTest != NULL) &&
					(pTestList->GetFirstIndex(pReport->m_pTest) >= 0))
				{
					fMatchedTest = TRUE;
				} // end if (report uses test from list)
			} // end if (we're matching a list of machines)
		} // end if (we matched the right report type)

		if ((fMatchedType) && (fMatchedMachine) && (fMatchedTest))
			break; // found a match, get out of the while loop

		pReport = (PTNREPORT) this->GetNextItem(pReport);
	} // end while (we have a valid report to check)

	this->LeaveCritSection();

	return (pReport);
} // CTNReportsList::GetNextMatchingReport
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReportsList::SetMaxNumberReports()"
//==================================================================================
// CTNReportsList::SetMaxNumberReports
//----------------------------------------------------------------------------------
//
// Description: Sets the maximum number of reports this list will store before
//				throwing out old reports to make room for new ones.
//
// Arguments:
//	int iNumReports		How many reports to keep.
//
// Returns: None.
//==================================================================================
void CTNReportsList::SetMaxNumberReports(int iNumReports)
{
	this->EnterCritSection();
	this->m_iMaxNumEntries = iNumReports;
	this->LeaveCritSection();
} // CTNReportsList::SetMaxNumberReports
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\reportitem.cpp ===
#ifndef _XBOX // reports not supported
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <time.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\errors.h"
#include "..\tncommon\sprintf.h"

#include "tncontrl.h"
#include "main.h"
#include "slaveinfo.h"

#include "reportitem.h"







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReport::CTNReport()"
//==================================================================================
// CTNReport constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNReport object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNReport::CTNReport(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNReport));

	this->m_dwType = 0;
	ZeroMemory(&(this->m_time), sizeof (tm));
	this->m_pTest = NULL;
	this->m_hresult = S_OK;
	this->m_dwDataSize = 0;
	this->m_pvData = NULL;
} // CTNReport::CTNReport
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReport::~CTNReport()"
//==================================================================================
// CTNReport destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNReport object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNReport::~CTNReport(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pTest != NULL)
	{
		this->m_pTest->m_dwRefCount--;
		if (this->m_pTest->m_dwRefCount == 0)
		{
			//DPL(7, "Deleting test %x.", 1, this->m_pTest);
			delete (this->m_pTest);
		} // end if (last reference)

		this->m_pTest = NULL;
	} // end if (have test)

	if (this->m_pvData != NULL)
	{
		LocalFree(this->m_pvData);
		this->m_pvData = NULL;
	} // end if (allocated data)
} // CTNReport::~CTNReport
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReport::PrintToFile()"
//==================================================================================
// CTNReport::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the CTNReport object to the file specified.
//
// Arguments:
//	HANDLE hFile		File to print to.
//	BOOL fVerbose		Should we print extra information?
//	BOOL fBVTFormat		Should we print in BVT standard format?
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNReport::PrintToFile(HANDLE hFile, BOOL fVerbose, BOOL fBVTFormat)
{
	HRESULT				hr = S_OK;
	int					i;
	PTNSLAVEINFO		pSlave = NULL;
	char				szBuffer[1024];
	int					iTesterNum = -1;
	CTNStoredData		writedata;
	TNWRITEDATA			tnwd;
	BOOL				fComplete = TRUE;
	BOOL				fSuccess = TRUE;
	int					iNumWarnings = 0;



	switch (this->m_dwType)
	{
		case RT_ADDMACHINE:
			FileWriteLine(hFile, "[Report: AddMachine]");
			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			pSlave = (PTNSLAVEINFO) this->m_machines.GetItem(0);
			FileSprintfWriteLine(hFile, "Name= %s",
								1, pSlave->m_szComputerName);

			// BVT format needs a closing section
			if (fBVTFormat)
			{
				FileWriteLine(hFile, "[/Report: AddMachine]");
			} // end if (BVT format)
		  break;
		  
		case RT_REMOVEMACHINE:
			FileWriteLine(hFile, "[Report: RemoveMachine]");
			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			pSlave = (PTNSLAVEINFO) this->m_machines.GetItem(0);
			FileSprintfWriteLine(hFile, "Name= %s",
								1, pSlave->m_szComputerName);

			switch (this->m_hresult)
			{
				case RRM_DROPPED:
					FileWriteLine(hFile, "Reason= dropped");
				  break;

				case RRM_LEFT:
					FileWriteLine(hFile, "Reason= left");
				  break;

				case RRM_DONETESTING:
					FileWriteLine(hFile, "Reason= done testing");
				  break;

				case RRM_TIMEREXPIRED:
					FileWriteLine(hFile, "Reason= timer expired");
				  break;

				default:
					FileWriteLine(hFile, "Reason= unknown");
				  break;
			} // end switch (on reason for removal)

			// BVT format needs a closing section
			if (fBVTFormat)
			{
				FileWriteLine(hFile, "[/Report: RemoveMachine]");
			} // end if (BVT format)
		  break;
		
		case RT_CLOSEDSESSION:
			FileWriteLine(hFile, "[Report: ClosedSession]");
			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			// BVT format needs a closing section
			if (fBVTFormat)
			{
				FileWriteLine(hFile, "[/Report: ClosedSession]");
			} // end if (BVT format)
		  break;
		
		case RT_ALLTESTINGCOMPLETE:
			FileWriteLine(hFile, "[Report: AllTestingComplete]");
			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			// BVT format needs a closing section
			if (fBVTFormat)
			{
				FileWriteLine(hFile, "[/Report: AllTestingComplete]");
			} // end if (BVT format)
		  break;

		case RT_TESTSKIPPED:
			FileWriteLine(hFile, "[Report: TestSkipped]");

			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			//Ignore error
			this->m_pTest->PrintToFile(hFile, FALSE, FALSE);

			// BVT format needs a closing section
			if (fBVTFormat)
			{
				FileWriteLine(hFile, "[/Report: TestSkipped]");
			} // end if (BVT format)
		  break;

		case RT_TESTASSIGNED:
		case RT_TESTASSIGNED_SUBTEST:
			for(i = 0; i < this->m_pTest->m_iNumMachines; i++)
			{
				if (this->m_pTest->m_fStarted)
				{
					if (this->m_pTest->m_paTesterSlots[i].fComplete)
					{
						if (! this->m_pTest->m_paTesterSlots[i].fSuccess)
							fSuccess = FALSE;
					} // end if (this tester completed)
					else
					{
						fComplete = FALSE;
					} // end else (this tester has not completed)

					iNumWarnings += this->m_pTest->m_paTesterSlots[i].iNumWarnings;
				} // end if (test has started)
				else
				{
					// BVT format doesn't have comments.
					if ((this->m_pTest->m_paTesterSlots[i].dwAssignTime == 0) &&
						(this->m_pTest->m_paTesterSlots[i].pSlave != NULL) &&
						(! fBVTFormat))
					{
						FileSprintfWriteLine(hFile, "// %sest waiting for %s",
											2, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"),
											this->m_pTest->m_paTesterSlots[i].pSlave->m_szComputerName);
					} // end if (placeholder for a slave and not in BVT format)
				} // end else (test has not started)
			} // end for (each tester slot)

			// BVT format doesn't have comments.
			if ((this->m_pTest->m_fStarted) && (! fBVTFormat))
			{
				if (fComplete)
				{
#pragma BUGBUG(vanceo, "FilterSuccess may override this")
					if (fSuccess)
					{
						FileSprintfWriteLine(hFile, "// %sest completed successfully",
											1, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"));
					} // end if (test was successful)
					else
					{
						FileSprintfWriteLine(hFile, "// %sest completed with failures",
											1, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"));
					} // end else (test had failures)
				} // end if (test has completed)
				else
				{
					FileSprintfWriteLine(hFile, "// %sest not completed",
										1, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"));
				} // end else (test has not completed)

				if (iNumWarnings > 0)
				{
					FileSprintfWriteLine(hFile, "// %sest has %i warnings",
										2, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"),
										iNumWarnings);
				} // end if (the test had warnings)
			} // end if (test has started and not in BVT format)
	
			FileWriteLine(hFile, "[Report: TestAssigned]");
			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			//Ignore error
			this->m_pTest->PrintToFile(hFile, FALSE,
									((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? TRUE : FALSE));

			writedata.m_dwLocation = TNTSDL_REPORTASSIGN;

			goto ALL_SINGLETESTER_REPORTS;
		  break;


		case RT_TESTCOMPLETELYASSIGNED:
		case RT_TESTCOMPLETELYASSIGNED_SUBTEST:
			if (! this->m_pTest->m_fStarted)
			{
				DPL(0, "Test %u has been completely assigned but it's not started!?",
					1, this->m_pTest->m_dwUniqueID);

				DEBUGBREAK();
			} // end if (placeholder for a slave)

			for(i = 0; i < this->m_pTest->m_iNumMachines; i++)
			{
				if (this->m_pTest->m_paTesterSlots[i].fComplete)
				{
					if (! this->m_pTest->m_paTesterSlots[i].fSuccess)
						fSuccess = FALSE;
				} // end if (this tester completed)
				else
				{
					fComplete = FALSE;
				} // end else (this tester has not completed)

				iNumWarnings += this->m_pTest->m_paTesterSlots[i].iNumWarnings;
			} // end for (each tester slot)


			// BVT format doesn't have comments.
			if (! fBVTFormat)
			{
				if (fComplete)
				{
#pragma BUGBUG(vanceo, "FilterSuccess may override this")
					if (fSuccess)
					{
						FileSprintfWriteLine(hFile, "// %sest completed successfully",
											1, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"));
					} // end if (test was successful)
					else
					{
						FileSprintfWriteLine(hFile, "// %sest completed with failures",
											1, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"));
					} // end else (test had failures)
				} // end if (test has completed)
				else
				{
					FileSprintfWriteLine(hFile, "// %sest not completed",
										1, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"));
				} // end else (test has not completed)

				if (iNumWarnings > 0)
				{
					FileSprintfWriteLine(hFile, "// %sest has %i warnings",
										2, ((this->m_dwType == RT_TESTASSIGNED_SUBTEST) ? "Subt" : "T"),
										iNumWarnings);
				} // end if (the test had warnings)
			} // end if (not in BVT format)

			
			FileWriteLine(hFile, "[Report: TestCompletelyAssigned]");
			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			//Ignore error
			this->m_pTest->PrintToFile(hFile, FALSE,
									((this->m_dwType == RT_TESTCOMPLETELYASSIGNED_SUBTEST) ? TRUE : FALSE));


			this->m_machines.EnterCritSection();
			for(i = 0; i < this->m_machines.Count(); i++)
			{
				pSlave = (PTNSLAVEINFO) this->m_machines.GetItem(i);

				FileSprintfWriteLine(hFile, "{Tester: %i}", 1, i);

				if (fVerbose)
				{
					pSlave->PrintToFile(hFile);
				} // end if (we're printing verbosely)
				else
				{
					FileSprintfWriteLine(hFile, "\tComputerName= %s",
										1, pSlave->m_szComputerName);
				} // end else (we're not printing verbosely)

				// Single space
				FileWriteLine(hFile, "");
			} // end for (each slave)
			this->m_machines.LeaveCritSection();


			// BVT format needs a closing section
			if (fBVTFormat)
			{
				FileWriteLine(hFile, "[/Report: TestCompletelyAssigned]");
			} // end if (BVT format)
		  break;

		case RT_SUCCESS:
		case RT_SUCCESS_SUBTEST:
			FileWriteLine(hFile, "[Report: Success]");
			writedata.m_dwLocation = TNTSDL_REPORTSUCCESS;
			goto ALL_DURINGTEST_REPORTS;
		  break;

		case RT_FAILURE:
		case RT_FAILURE_SUBTEST:
			FileWriteLine(hFile, "[Report: Failure]");
			writedata.m_dwLocation = TNTSDL_REPORTFAILURE;
			goto ALL_DURINGTEST_REPORTS;
		  break;

		case RT_WARNING:
		case RT_WARNING_SUBTEST:
			FileWriteLine(hFile, "[Report: Warning]");
			writedata.m_dwLocation = TNTSDL_REPORTWARNING;

			// Note: continuing


ALL_DURINGTEST_REPORTS:

			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			//Ignore error
			this->m_pTest->PrintToFile(hFile, FALSE,
									(((this->m_dwType == RT_SUCCESS_SUBTEST) || (this->m_dwType == RT_FAILURE_SUBTEST) || (this->m_dwType == RT_WARNING_SUBTEST)) ? TRUE : FALSE));

			pSlave = (PTNSLAVEINFO) this->m_machines.GetItem(0);
			FileSprintfWriteLine(hFile, "ReporterName= %s",
								1, pSlave->m_szComputerName);

			FileSprintfWriteLine(hFile, "hresult= %x", 1, this->m_hresult);
			FileSprintfWriteLine(hFile, "ResultDescription= %e", 1, this->m_hresult);

			// Note: continuing


ALL_SINGLETESTER_REPORTS:

			pSlave = (PTNSLAVEINFO) this->m_machines.GetItem(0);

			iTesterNum = this->m_pTest->GetSlavesTesterNum(pSlave);

			// If we didn't find it, then bail.
			if (iTesterNum < 0)
			{
				DPL(0, "Couldn't locate slave (%s) in the tester list!",
					1, pSlave->m_szComputerName);

				// BVT format doesn't have comments.
				if (! fBVTFormat)
				{
					FileSprintfWriteLine(hFile, "// Couldn't locate slave (%s) in the tester list!",
										1, pSlave->m_szComputerName);
				} // end if (not in BVT format)

				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get the tester's index)


			FileSprintfWriteLine(hFile, "{Tester: %i}", 1, iTesterNum);

			if (fVerbose)
			{
				pSlave->PrintToFile(hFile);
			} // end if (we're printing verbosely)
			else
			{
				FileSprintfWriteLine(hFile, "\tComputerName= %s",
									1, pSlave->m_szComputerName);
			} // end else (we're not printing verbosely)

			if ((this->m_pvData != NULL) &&
				(this->m_pTest->m_pCase->m_pfnWriteData != NULL))
			{
				// Allow the module to write strings that can either help it
				// determine the reason for the report or be used as a means
				// of reproducing the test settings, if it chooses.

				ZeroMemory(&tnwd, sizeof (TNWRITEDATA));
				tnwd.dwSize = sizeof (TNWRITEDATA);
				tnwd.dwLocation = writedata.m_dwLocation;
				tnwd.pvData = this->m_pvData;
				tnwd.dwDataSize = this->m_dwDataSize;
				tnwd.pMachine = pSlave;
				tnwd.iTesterNum= iTesterNum;
				tnwd.pTest = this->m_pTest->m_pCase;
				tnwd.pWriteStoredData = &writedata;

				hr = this->m_pTest->m_pCase->m_pfnWriteData(&tnwd);

				if (hr != S_OK)
				{
					DPL(0, "Module's WriteData callback failed!", 0);

					// BVT format doesn't have comments.
					if (! fBVTFormat)
					{
						FileWriteLine(hFile, "// Module's WriteData callback failed!");
					} // end if (not in BVT format)

					goto DONE;
				} // end if (couldn't allocate memory)

				if (writedata.m_strings.Count() > 0)
					FileWriteLine(hFile, "{ModuleData}");

				for(i = 0; i < writedata.m_strings.Count(); i++)
				{
					FileSprintfWriteLine(hFile, "\t%s",
										1, writedata.m_strings.GetIndexedString(i));
				} // end for (each string)
			} // end if (the test has a write data function)

			// BVT format needs a closing section
			if (fBVTFormat)
			{
				switch (this->m_dwType)
				{
					case RT_TESTASSIGNED:
					case RT_TESTASSIGNED_SUBTEST:
						FileWriteLine(hFile, "[/Report: TestAssigned]");
					  break;

					case RT_SUCCESS:
					case RT_SUCCESS_SUBTEST:
						FileWriteLine(hFile, "[/Report: Success]");
					  break;

					case RT_FAILURE:
					case RT_FAILURE_SUBTEST:
						FileWriteLine(hFile, "[/Report: Failure]");
					  break;

					case RT_WARNING:
					case RT_WARNING_SUBTEST:
						FileWriteLine(hFile, "[/Report: Warning]");
					  break;

#ifdef DEBUG
					default:
						DPL(0, "In ALL_SINGLETESTER_REPORTS for unexpected report type %u!  DEBUGBREAK()-ing",
							1, this->m_dwType);
						DEBUGBREAK();
					  break;
				} // end switch (on report type)
#endif // DEBUG
			} // end if (BVT format)
		  break;



		case RT_SUCCESSCOMPLETE:
		case RT_SUCCESSCOMPLETE_SUBTEST:
			FileWriteLine(hFile, "[Report: CompleteSuccessfully]");
			writedata.m_dwLocation = TNTSDL_REPORTFINALSUCCESS;
			goto ALL_COMPLETETEST_REPORTS;
		  break;

		case RT_FAILURECOMPLETE:
		case RT_FAILURECOMPLETE_SUBTEST:
			FileWriteLine(hFile, "[Report: CompleteWithFailure]");
			writedata.m_dwLocation = TNTSDL_REPORTFINALFAILURE;

			// Note: continuing


ALL_COMPLETETEST_REPORTS:

			strftime(szBuffer, 1024, "Time= %I:%M:%S%p  %m/%d/%y", &(this->m_time));
			FileWriteLine(hFile, szBuffer);

			//Ignore error
			this->m_pTest->PrintToFile(hFile, FALSE,
									(((this->m_dwType == RT_SUCCESSCOMPLETE_SUBTEST) || (this->m_dwType == RT_FAILURECOMPLETE_SUBTEST)) ? TRUE : FALSE));

			if ((this->m_pvData != NULL) &&
				(this->m_pTest->m_pCase->m_pfnWriteData != NULL))
			{
				// Allow the module to write strings that can either help it
				// determine the reason for the report or be used as a means
				// of reproducing the test settings, if it chooses.

				ZeroMemory(&tnwd, sizeof (TNWRITEDATA));
				tnwd.dwSize = sizeof (TNWRITEDATA);
				tnwd.dwLocation = writedata.m_dwLocation;
				tnwd.pvData = this->m_pvData;
				tnwd.dwDataSize = this->m_dwDataSize;
				tnwd.pMachine = pSlave;
				tnwd.iTesterNum= iTesterNum;
				tnwd.pTest = this->m_pTest->m_pCase;
				tnwd.pWriteStoredData = &writedata;

				hr = this->m_pTest->m_pCase->m_pfnWriteData(&tnwd);

				if (hr != S_OK)
				{
					DPL(0, "Module's WriteData callback failed!", 0);
					
					// BVT format doesn't have comments.
					if (! fBVTFormat)
					{
						FileWriteLine(hFile, "// Module's WriteData callback failed!");
					} // end if (not in BVT format)

					goto DONE;
				} // end if (couldn't allocate memory)

				if (writedata.m_strings.Count() > 0)
					FileWriteLine(hFile, "{ModuleData}");

				for(i = 0; i < writedata.m_strings.Count(); i++)
				{
					FileSprintfWriteLine(hFile, "\t%s",
										1, writedata.m_strings.GetIndexedString(i));
				} // end for (each string)
			} // end if (the test has a write data function)

			if (fVerbose)
			{
				this->m_machines.EnterCritSection();
				for(i = 0; i < this->m_machines.Count(); i++)
				{
					pSlave = (PTNSLAVEINFO) this->m_machines.GetItem(i);

					FileSprintfWriteLine(hFile, "{Tester: %i}", 1, i);

					pSlave->PrintToFile(hFile);

					// Single space
					FileWriteLine(hFile, "");
				} // end for (each slave)
				this->m_machines.LeaveCritSection();
			} // end if (we're printing verbosely)


			// BVT format needs a closing section
			if (fBVTFormat)
			{
				switch (this->m_dwType)
				{
					case RT_SUCCESSCOMPLETE:
					case RT_SUCCESSCOMPLETE_SUBTEST:
						FileWriteLine(hFile, "[/Report: CompleteSuccessfully]");
					  break;

					case RT_FAILURECOMPLETE:
					case RT_FAILURECOMPLETE_SUBTEST:
						FileWriteLine(hFile, "[/Report: CompleteWithFailure]");
					  break;

#ifdef DEBUG
					default:
						DPL(0, "In ALL_COMPLETETEST_REPORTS for unexpected report type %u!  DEBUGBREAK()-ing",
							1, this->m_dwType);
						DEBUGBREAK();
					  break;
				} // end switch (on report type)
#endif // DEBUG
			} // end if (BVT format)
		  break;

		default:
			DPL(0, "Unknown kind of report type (%u)!", 1, this->m_dwType);

			// BVT format doesn't have comments.
			if (! fBVTFormat)
			{
				FileSprintfWriteLine(hFile, "// Unknown kind of report type (%u)!",
									1, this->m_dwType);
			} // end if (not in BVT format)

			hr = E_FAIL;
		  break;
	} // end switch (on kind of report)


DONE:

	if (hr != S_OK)
	{
		FileSprintfWriteLine(hFile, "// %E", 1, hr);
	} // end if (exiting with error)

	return (hr);
} // CTNReport::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\reachcheck.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"

#include "tncontrl.h"
#include "main.h"

#include "comm.h"
#include "reachcheck.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReachCheck::CTNReachCheck()"
//==================================================================================
// CTNReachCheck constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNReachCheck object.  Initializes the data structures.
//
// Arguments:
//	DWORD dwID				ID of reach check.
//	DWORD dwMethod			Method of communication being checked.
//	PVOID pvMethodData		Pointer to method data being used, if any.
//	DWORD dwMethodDataSize	Size of method data, if any.
//
// Returns: None (just the object).
//==================================================================================
CTNReachCheck::CTNReachCheck(DWORD dwID, DWORD dwMethod, PVOID pvMethodData,
							DWORD dwMethodDataSize)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNReachCheck));


	this->m_dwID = dwID;

	this->m_dwMethod = dwMethod;

	this->m_pvMethodData = NULL;
	this->m_dwMethodDataSize = dwMethodDataSize;

	if (pvMethodData != NULL)
	{
		this->m_pvMethodData = LocalAlloc(LPTR, dwMethodDataSize);
		if (this->m_pvMethodData != NULL)
		{
			CopyMemory(this->m_pvMethodData, pvMethodData, dwMethodDataSize);
			this->m_dwMethodDataSize = dwMethodDataSize;
		} // end if (method data)
	} // end if (method data)

	this->m_hEvent = NULL;

	this->m_fResult = FALSE;
	this->m_hresult = E_FAIL;

	this->m_pPeriodicSend = NULL;

	this->m_pvAddress = NULL;
	this->m_dwAddressSize = 0;

	this->m_pCtrlComm = NULL;
	this->m_pvCommData = NULL;
} // CTNReachCheck::CTNReachCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReachCheck::~CTNReachCheck()"
//==================================================================================
// CTNReachCheck destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNReachCheck object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNReachCheck::~CTNReachCheck(void)
{
	//DPL(0, "this = %x", 1, this);


	if (this->m_pvMethodData != NULL)
	{
		LocalFree(this->m_pvMethodData);
		this->m_pvMethodData = NULL;
	} // end if (allocated output data)

	if (this->m_hEvent != NULL)
	{
		CloseHandle(this->m_hEvent);
		this->m_hEvent = NULL;
	} // end if (have event)

	if (this->m_pPeriodicSend != NULL)
	{
		this->m_pPeriodicSend->m_dwRefCount--;
		if (this->m_pPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting periodic send object %x.", 1, this->m_pPeriodicSend);

			// If there's a context, we know it's allocated memory.  Free it.
			if (this->m_pPeriodicSend->m_pvUserContext != NULL)
			{
				LocalFree(this->m_pPeriodicSend->m_pvUserContext);
				this->m_pPeriodicSend->m_pvUserContext = NULL;
			} // end if (there's a user context)

			delete (this->m_pPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting periodic send object %x, its refcount is %u.",
				2, this->m_pPeriodicSend, this->m_pPeriodicSend->m_dwRefCount);
		} // end if (shouldn't delete object)
		this->m_pPeriodicSend = NULL;
	} // end if (there's a slave object)

	if (this->m_pvAddress != NULL)
	{
		LocalFree(this->m_pvAddress);
		this->m_pvAddress = NULL;
	} // end if (allocated output data)

	if (this->m_pCtrlComm != NULL)
	{
		this->m_pCtrlComm->m_dwRefCount--;
		if (this->m_pCtrlComm->m_dwRefCount == 0)
		{
			DPL(7, "Deleting control comm object %x.", 1, this->m_pCtrlComm);
			delete (this->m_pCtrlComm);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting control comm object %x, its refcount is %u.",
				2, this->m_pCtrlComm, this->m_pCtrlComm->m_dwRefCount);
		} // end if (shouldn't delete object)
		this->m_pCtrlComm = NULL;
	} // end if (there's a slave object)
} // CTNReachCheck::~CTNReachCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReachChecksList::GetCheck()"
//==================================================================================
// CTNReachChecksList::GetCheck
//----------------------------------------------------------------------------------
//
// Description: Returns the CTNReachCheck item with the specified ID, or NULL if not
//				found.
//
// Arguments:
//	DWORD dwID	ID of check to search for.
//
// Returns: Pointer to CTNReachCheck or NULL if not found.
//==================================================================================
PTNREACHCHECK CTNReachChecksList::GetCheck(DWORD dwID)
{
	int				i;
	PTNREACHCHECK	pItem = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		DPL(0, "CTNReachChecksList pointer is NULL!", 0);

		DEBUGBREAK();

		return (NULL);
	} // end if (got passed invalid object)
#endif // DEBUG

	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNREACHCHECK) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (NULL);
		} // end if (couldn't get that item)

		if (pItem->m_dwID == dwID)
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (found the ID the caller was looking for)
	} // end for (each item in the list)
	this->LeaveCritSection();

	return (NULL);
} // CTNReachChecksList::GetCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReachCheckTarget::CTNReachCheckTarget()"
//==================================================================================
// CTNReachCheckTarget constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNReachCheckTarget object.  Initializes the data
//				structures.
//
// Arguments:
//	PTNCTRLMACHINEID pSlaveID	Pointer to ID of slave this pertains to.
//
// Returns: None (just the object).
//==================================================================================
CTNReachCheckTarget::CTNReachCheckTarget(PTNCTRLMACHINEID pSlaveID)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNReachCheckTarget));

	CopyMemory(&(this->m_id), pSlaveID, sizeof (TNCTRLMACHINEID));
} // CTNReachCheckTarget::CTNReachCheckTarget
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReachCheckTarget::~CTNReachCheckTarget()"
//==================================================================================
// CTNReachCheckTarget destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNReachCheckTarget object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNReachCheckTarget::~CTNReachCheckTarget(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNReachCheckTarget::~CTNReachCheckTarget
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNReachCheckTargetsList::GetTarget()"
//==================================================================================
// CTNReachCheckTargetsList::GetTarget
//----------------------------------------------------------------------------------
//
// Description: Returns the CTNReachCheckTarget item for the specified slave, or
//				NULL if not found.
//
// Arguments:
//	PTNCTRLMACHINEID pSlaveID	ID of slave to search for.
//
// Returns: Pointer to CTNReachCheckTarget or NULL if not found.
//==================================================================================
PTNREACHCHECKTARGET CTNReachCheckTargetsList::GetTarget(PTNCTRLMACHINEID pSlaveID)
{
	int						i;
	PTNREACHCHECKTARGET		pItem = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		DPL(0, "CTNReachCheckTargetsList pointer is NULL!", 0);

		DEBUGBREAK();

		return (NULL);
	} // end if (got passed invalid object)
#endif // DEBUG

	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNREACHCHECKTARGET) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (NULL);
		} // end if (couldn't get that item)

		if (memcmp(&(pItem->m_id), pSlaveID, sizeof (TNCTRLMACHINEID)) == 0)
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (found the slave the caller was looking for)
	} // end for (each item in the list)
	this->LeaveCritSection();

	return (NULL);
} // CTNReachCheckTargetsList::GetTarget
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\reportitem.h ===
#ifndef _XBOX // reports not supported
#ifndef __DNTESTTOOLS_REPORTITEM__
#define __DNTESTTOOLS_REPORTITEM__
//#pragma message("Defining __DNTESTTOOLS_REPORTITEM__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG








//==================================================================================
// Defines
//==================================================================================
#define RT_ADDMACHINE						1
#define RT_REMOVEMACHINE					2
#define RT_CLOSEDSESSION					3
#define RT_ALLTESTINGCOMPLETE				4

#define RT_TESTSKIPPED						5

#define RT_TESTASSIGNED						101
#define RT_TESTASSIGNED_SUBTEST				102
#define RT_TESTCOMPLETELYASSIGNED			103
#define RT_TESTCOMPLETELYASSIGNED_SUBTEST	104
#define RT_SUCCESS							105
#define RT_SUCCESS_SUBTEST					106
#define RT_FAILURE							107
#define RT_FAILURE_SUBTEST					108
#define RT_WARNING							109
#define RT_WARNING_SUBTEST					110
#define RT_SUCCESSCOMPLETE					111
#define RT_SUCCESSCOMPLETE_SUBTEST			112
#define RT_FAILURECOMPLETE					113
#define RT_FAILURECOMPLETE_SUBTEST			114


#define RRM_DROPPED						0x00000001
#define RRM_LEFT						0x00000002
#define RRM_DONETESTING					0x00000003
#define RRM_TIMEREXPIRED				0x00000004



//==================================================================================
// Classes
//==================================================================================
class DLLEXPORT CTNReport:public LLITEM
{
	// Declare ReportList and master objects as friends so they can access
	// everything.
	friend class CTNReportsList;
#ifndef _XBOX // ! no master supported
	friend class CTNMaster;
#endif // ! XBOX


	protected:
		DWORD				m_dwType; // type of report, see RT_xxx above for possible values
		tm					m_time; // time the report was logged
		CTNSlavesList		m_machines; // list of machines this report pertains to
		PTNTESTINSTANCEM	m_pTest; // tests this report pertains to, if any
		HRESULT				m_hresult; // result code for this report
		DWORD				m_dwDataSize; // size of user data
		PVOID				m_pvData; // user specific data


	public:
		CTNReport(void);
		virtual ~CTNReport(void);


		HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose, BOOL fBVTFormat);
};







#else //__DNTESTTOOLS_REPORTITEM__
//#pragma message("__DNTESTTOOLS_REPORTITEM__ already included!")
#endif //__DNTESTTOOLS_REPORTITEM__
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\script.h ===
#ifndef __TNCONTROL_SCRIPT__
#define __TNCONTROL_SCRIPT__
//#pragma message("Defining __TNCONTROL_SCRIPT__")




//==================================================================================
// External Structures
//==================================================================================

//- - - - - - - - - - - - - - - -
// Test input data structures
//- - - - - - - - - - - - - - - -

// Script:FreeOutputVars
typedef struct tagTID_SCRIPT_FREEOUTPUTVARS
{
	DWORD	dwCaseIDSize; // size of the case ID string to match, if any
	DWORD	dwInstanceIDSize; // size of the instance ID string to match, if any
	DWORD	dwNameSize; // size of the output variable name string to match, if any
	DWORD	dwTypeSize; // size of the output variable type string to match, if any
	BOOL	fFreeData; // whether the output data can be freed as well, if no variables are left

	// Anything after this is part of the case ID, instance ID, name and type
	// strings.
} TID_SCRIPT_FREEOUTPUTVARS, * PTID_SCRIPT_FREEOUTPUTVARS;

// Script:FreeResults
typedef struct tagTID_SCRIPT_FREERESULTS
{
	DWORD	dwCaseIDSize; // size of the case ID string to match, if any
	DWORD	dwInstanceIDSize; // size of the instance ID string to match, if any

	// Anything after this is part of the case and instance ID strings.
} TID_SCRIPT_FREERESULTS, * PTID_SCRIPT_FREERESULTS;

// Script:Sleep
typedef struct tagTID_SCRIPT_SLEEP
{
	DWORD	dwMS; // milliseconds to sleep
} TID_SCRIPT_SLEEP, * PTID_SCRIPT_SLEEP;

// Script:Wait
typedef struct tagTID_SCRIPT_WAIT
{
	DWORD	dwSecs; // seconds to wait until timeout, or INFINITE
	DWORD	dwStringSize; // how big the following string is, including NULL termination.

	// Anything after this is part of the dialog box string.
} TID_SCRIPT_WAIT, * PTID_SCRIPT_WAIT;





//==================================================================================
// External Prototypes
//==================================================================================
HRESULT ScriptLoadTestTable(PTNTESTTABLEGROUP pTable);






#else //__TNCONTROL_SCRIPT__
//#pragma message("__TNCONTROL_SCRIPT__ already included!")
#endif //__TNCONTROL_SCRIPT__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\rsltchain.h ===
#ifndef __TNCONTROL_RESULTCHAIN__
#define __TNCONTROL_RESULTCHAIN__
//#pragma message("Defining __TNCONTROL_RESULTCHAIN__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNResult:public LLITEM
{
	// These are friends so they can access the protected members
	friend CTNResultsChain;
	friend CTNExecutorPriv;
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
#ifndef _XBOX // no IPC supported
	friend CTNLeech;
#endif // ! XBOX


	private:
		PTNTESTINSTANCES	m_pTest; // test that generated this result



	protected:
		HRESULT				m_hresult; // success or error code
		BOOL				m_fComplete; // is this the last result for the test?
		BOOL				m_fSuccess; // is the result a success?
		PVOID				m_pvOutputData; // pointer to output data
		DWORD				m_dwOutputDataSize; // size of output data
		BOOL				m_fUnderDontSaveTest; // is this result for a subtest under a DONTSAVERESULTS test?
		CTNOutputVarsList	m_vars; // list of variables set inside output data


		CTNResult(PTNTESTINSTANCES pTest);
		virtual ~CTNResult(void);


	public:
		// These are public because we want the module's ExecCase functions to be
		// be able to retrieve them.

		HRESULT SetResultCodeAndBools(HRESULT hresult, BOOL fTestComplete, BOOL fSuccess);
		PVOID CreateOutputDataBuffer(DWORD dwBufferSize);
		void DestroyOutputDataBufferAndVars(void);
		HRESULT GetOutputData(PVOID* ppvData, DWORD* pdwDataSize);
		HRESULT SetOutputVariable(char* szName, char* szType, PVOID pvValueLocation,
								DWORD dwValueSize);
		HRESULT GetOutputVariable(char* szName, char* szType, PVOID* ppvValueLocation,
								DWORD* pdwValueSize);
		HRESULT GetOutputVariableOfType(char* szType, char** ppszName,
										PVOID* ppvValueLocation, DWORD* pdwValueSize);
		BOOL IsCase(char* szID);
		BOOL IsSuccess(void);
		HRESULT GetResultCode(void);
};

class DLLEXPORT CTNResultsChain:public LLIST
{
	// These are friends so they can access the protected members.

#ifndef _XBOX // no IPC supported
	friend CTNLeech;
#endif // ! XBOX

	//friend CTNSlave;
	friend CTNExecutorPriv;
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX


	protected:
		PTNRESULT NewResult(PTNTESTINSTANCES pTest);
		PTNRESULT GetResultForTest(PTNTESTINSTANCES pTest);


	public:
		/*
		CTNResultsChain(void);
		virtual ~CTNResultsChain(void);
		*/

		PTNRESULT GetMostRecentResult(char* szTestCaseID);
		HRESULT GetMostRecentOutputVar(char* szName, char* szType,
										PVOID* ppvValueLocation,
										DWORD* pdwValueSize);
		HRESULT GetMostRecentOutputVarOfType(char* szType, char** ppszName,
											PVOID* ppvValueLocation,
											DWORD* pdwValueSize);
};






#else //__TNCONTROL_RESULTCHAIN__
//#pragma message("__TNCONTROL_RESULTCHAIN__ already included!")
#endif //__TNCONTROL_RESULTCHAIN__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\rsltchain.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"

#include "tncontrl.h"
#include "main.h"

#include "rsltchain.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::CTNResult()"
//==================================================================================
// CTNResult constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNResult object.  Initializes the data structures.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test this is a result for.
//
// Returns: None (just the object).
//==================================================================================
CTNResult::CTNResult(PTNTESTINSTANCES pTest)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNResult));

	pTest->m_dwRefCount++;
	this->m_pTest = pTest;

	this->m_hresult = S_OK;
	this->m_fComplete = FALSE;
	this->m_fSuccess = FALSE;
	this->m_pvOutputData = NULL;
	this->m_dwOutputDataSize = 0;
	this->m_fUnderDontSaveTest = FALSE;
} // CTNResult::CTNResult
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::~CTNResult()"
//==================================================================================
// CTNResult destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNResult object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNResult::~CTNResult(void)
{
	//DPL(0, "this = %x", 1, this);


	this->m_pTest->m_dwRefCount--;
	if (this->m_pTest->m_dwRefCount == 0)
	{
		DPL(7, "Deleting test %x.", 1, this->m_pTest);
		delete (this->m_pTest);
	} // end if (last reference)
	else
	{
		DPL(7, "Not deleting test %x, its refcount is %u.",
			2, this->m_pTest, this->m_pTest->m_dwRefCount);
	} // end else (not last reference)
	this->m_pTest = NULL;

	if (this->m_pvOutputData != NULL)
	{
		LocalFree(this->m_pvOutputData);
		this->m_pvOutputData = NULL;
	} // end if (allocated output data)
} // CTNResult::~CTNResult
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::SetResultCodeAndBools()"
//==================================================================================
// CTNResult::SetResultCodeAndBools
//----------------------------------------------------------------------------------
//
// Description: Sets this object's values.
//
// Arguments:
//	HRESULT hresult			Success or error code.
//	BOOL fTestComplete		Does this result mean that no more execution will be
//							performed on the test (either because it completed or it
//							encountered a fatal error)?
//	BOOL fSuccess			Is this result a success (note this does not
//							necessarily mean hresult is 0)?
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNResult::SetResultCodeAndBools(HRESULT hresult, BOOL fTestComplete,
										BOOL fSuccess)
{
	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)

	this->m_hresult = hresult;
	this->m_fComplete = fTestComplete;
	this->m_fSuccess = fSuccess;

	return (S_OK);
} // CTNResult::SetResultCodeAndBools
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::CreateOutputDataBuffer()"
//==================================================================================
// CTNResult::CreateOutputDataBuffer
//----------------------------------------------------------------------------------
//
// Description: Creates an output buffer of the specified size.  If data already
//				existed, it is freed to make room, and all output variables are
//				destroyed.  If 0 is passed in, no buffer is allocated.
//
// Arguments:
//	DWORD dwBufferSize	Size of buffer to create.
//
// Returns: Pointer to buffer, or NULL if an error occurred.
//==================================================================================
PVOID CTNResult::CreateOutputDataBuffer(DWORD dwBufferSize)
{
	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (NULL);
	} // end if (got passed invalid object)


	// Free anything that existed before.
	this->DestroyOutputDataBufferAndVars();


	if (dwBufferSize > 0)
	{
		this->m_pvOutputData = LocalAlloc(LPTR, dwBufferSize);
		if (this->m_pvOutputData != NULL)
		{
			this->m_dwOutputDataSize = dwBufferSize;
			this->m_vars.m_pvOutputDataStart = this->m_pvOutputData;
		} // end if (allocated memory)
	} // end if (there's a new buffer to create)

	return (this->m_pvOutputData);
} // CTNResult::CreateOutputDataBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::DestroyOutputDataBufferAndVars()"
//==================================================================================
// CTNResult::DestroyOutputDataBufferAndVars
//----------------------------------------------------------------------------------
//
// Description: Frees the output buffer if it existed, and all output variables are
//				destroyed.
//
// Arguments:  None.
//
// Returns: None.
//==================================================================================
void CTNResult::DestroyOutputDataBufferAndVars(void)
{
#ifdef DEBUG
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!  DEBUGBREAK()-ing.", 0);
		DEBUGBREAK();
	} // end if (got passed invalid object)

	DPL(9, "(%x)==>", 1, this);
#endif // DEBUG

	if (this->m_pvOutputData != NULL)
	{
#ifdef DEBUG
		DPL(9, "Destroying output data %x in result object %x.",
			2, this->m_pvOutputData, this);

		hr = this->m_vars.RemoveAll();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove all variables!  %e  DEBUGBREAK()-ing.",
				1, hr);
			DEBUGBREAK();
		} // end if (couldn't remove all variables)
#else // ! DEBUG
		this->m_vars.RemoveAll();
#endif // ! DEBUG

		this->m_vars.m_pvOutputDataStart = NULL;

		this->m_dwOutputDataSize = 0;
		LocalFree(this->m_pvOutputData);
		this->m_pvOutputData = NULL;
	} // end if (the output data buffer already existed)


	DPL(9, "(%x)<==", 1, this);
} // CTNResult::DestroyOutputDataBufferAndVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::GetOutputData()"
//==================================================================================
// CTNResult::GetOutputData
//----------------------------------------------------------------------------------
//
// Description: Retrieves pointers to the output data this object holds.  Note: this
//				is not a copy of the data.
//
// Arguments:
//	PVOID* ppvData			Pointer to set to point at data.
//	DWORD* pdwDataSize		Pointer to fill in with size of data.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNResult::GetOutputData(PVOID* ppvData, DWORD* pdwDataSize)
{
	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)

	(*ppvData) = this->m_pvOutputData;
	(*pdwDataSize) = this->m_dwOutputDataSize;

	return (S_OK);
} // CTNResult::GetOutputData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::SetOutputVariable()"
//==================================================================================
// CTNResult::SetOutputVariable
//----------------------------------------------------------------------------------
//
// Description: Creates a new variable with the given name and type (or overwrites
//				the old one if one existed for this result).  Its value is set to
//				the pointer passed in, which must point to some data within the
//				output data buffer.
//
// Arguments:
//	char* szName			Name of variable to create and set.
//	char* szType			Type of variable to create.
//	PVOID pvValueLocation	Pointer to variable's value.  This must be inside the
//							output data buffer.
//	DWORD dwValueSize		Size of variable's value.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNResult::SetOutputVariable(char* szName, char* szType,
									PVOID pvValueLocation,
									DWORD dwValueSize)
{
	HRESULT		hr;


	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)

	if (this->m_pvOutputData == NULL)
	{
		DPL(0, "Output data buffer doesn't exist yet!", 0);
		return (ERROR_NOT_READY);
	} // end if (got passed invalid object)

	if (((LPBYTE) pvValueLocation < (LPBYTE) this->m_pvOutputData) ||
		((LPBYTE) pvValueLocation >= (((LPBYTE) this->m_pvOutputData) + this->m_dwOutputDataSize)))
	{
		DPL(0, "Value pointer is out of range/not point somewhere in output data buffer (%x is not between %x and %x)!",
			3, pvValueLocation, this->m_pvOutputData,
			(((LPBYTE) this->m_pvOutputData) + this->m_dwOutputDataSize));
		return (ERROR_INVALID_PARAMETER);
	} // end if (got passed invalid object)

	hr = this->m_vars.AddVariable(szName, szType, pvValueLocation, dwValueSize);
	if (hr != S_OK)
	{
		DPL(0, "Adding variable failed!", 0);
	} // end if (adding variable failed)

	return (hr);
} // CTNResult::SetOutputVariable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::GetOutputVariable()"
//==================================================================================
// CTNResult::GetOutputVariable
//----------------------------------------------------------------------------------
//
// Description: Searches for a variable with the given name and type, and sets the
//				pointer and size to the variables value pointer and size.
//				Note: this is not a copy of the data.
//				If a variable with that name and type is not found, ERROR_NOT_FOUND
//				is returned.
//
// Arguments:
//	char* szName				Name of variable to retrieve.
//	char* szType				Type of variable to retrieve.
//	PVOID* ppvValueLocation		Pointer to set to point to variable's value.
//	DWORD* pdwValueSize			Pointer to set to size of variable's value.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNResult::GetOutputVariable(char* szName, char* szType,
									PVOID* ppvValueLocation,
									DWORD* pdwValueSize)
{
	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)

	return (this->m_vars.GetVariable(szName, szType, ppvValueLocation, pdwValueSize));
} // CTNResult::GetOutputVariable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::GetOutputVariableOfType()"
//==================================================================================
// CTNResult::GetOutputVariableOfType
//----------------------------------------------------------------------------------
//
// Description: Searches for the first variable of the given type, and sets the
//				pointer and size to the variables value pointer and size.  If
//				lplpszName is not NULL, then it is set to point to the name of the
//				variable found.
//				Note: this is not a copy of the data.
//				If a variable of that type is not found, ERROR_NOT_FOUND is
//				returned.
//
// Arguments:
//	char* szType				Type of variable to retrieve.
//	char** ppszName				Optional pointer to hold name of variable found.
//	PVOID* ppvValueLocation		Pointer to set to point to variable's value.
//	DWORD* pdwValueSize			Pointer to set to size of variable's value.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNResult::GetOutputVariableOfType(char* szType, char** ppszName,
											PVOID* ppvValueLocation,
											DWORD* pdwValueSize)
{
	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)

	return (this->m_vars.GetFirstVariableOfType(szType, ppszName,
												ppvValueLocation, pdwValueSize));
} // CTNResult::GetOutputVariableOfType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::IsCase()"
//==================================================================================
// CTNResult::IsCase
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the test case associated with this result is the
//				one specified, FALSE otherwise.
//
// Arguments:
//	char* szID		Test case ID to check.
//
// Returns: TRUE if we're that case, FALSE otherwise.
//==================================================================================
BOOL CTNResult::IsCase(char* szID)
{
	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (FALSE);
	} // end if (got passed invalid object)

	if (strcmp(this->m_pTest->m_pCase->m_pszID, szID) == 0)
		return (TRUE);

	return (FALSE);
} // CTNResult::IsCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::IsSuccess()"
//==================================================================================
// CTNResult::IsSuccess
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the test case associated with this result was a
//				success, FALSE otherwise.
//
// Arguments: None.
//
// Returns: TRUE if we're a success result, FALSE otherwise.
//==================================================================================
BOOL CTNResult::IsSuccess(void)
{
	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (FALSE);
	} // end if (got passed invalid object)

	return (this->m_fSuccess);
} // CTNResult::IsSuccess
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResult::GetResultCode()"
//==================================================================================
// CTNResult::GetResultCode
//----------------------------------------------------------------------------------
//
// Description: Returns the result code of the test case associated with this.
//
// Arguments: None.
//
// Returns: Result code for this object.
//==================================================================================
HRESULT CTNResult::GetResultCode(void)
{
	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)

	return (this->m_hresult);
} // CTNResult::GetResultCode
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResultsChain::NewResult()"
//==================================================================================
// CTNResultsChain::NewResult
//----------------------------------------------------------------------------------
//
// Description: Creates a new result associated with the given test and adds it to
//				the front of the list.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test to create result for.
//
// Returns: Pointer to test result or NULL if an error occurred.
//==================================================================================
PTNRESULT CTNResultsChain::NewResult(PTNTESTINSTANCES pTest)
{
	HRESULT		hr;
	PTNRESULT	pItem = NULL;


	if (this == NULL)
	{
		DPL(0, "ResultChain pointer is NULL!", 0);
		return (NULL);
	} // end if (got passed invalid object)

	pItem = new (CTNResult)(pTest);
	if (pItem == NULL)
	{
		return (NULL);
	} // end if (couldn't allocated object)

	hr = this->AddAfter(pItem, NULL);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add the item to the front of the list!  %e", 1, hr);
		delete (pItem);
		return (NULL);
	} // end if (adding the item failed)

	return (pItem);
} // CTNResultsChain::NewResult
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResultsChain::GetResultForTest()"
//==================================================================================
// CTNResultsChain::GetResultForTest
//----------------------------------------------------------------------------------
//
// Description: Returns the result associated with the given test.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test to look for matching result.
//
// Returns: Pointer to test result or NULL if an error occurred.
//==================================================================================
PTNRESULT CTNResultsChain::GetResultForTest(PTNTESTINSTANCES pTest)
{
	int			i;
	PTNRESULT	pItem = NULL;


	if (this == NULL)
	{
		DPL(0, "ResultChain pointer is NULL!", 0);
		return (NULL);
	} // end if (got passed invalid object)

	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNRESULT) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (NULL);
		} // end if (couldn't get item)

		if (pItem->m_pTest == pTest)
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (found item)
	} // end for (each item)
	this->LeaveCritSection();

	// Didn't find it, so return NULL.
	return (NULL);
} // CTNResultsChain::GetResultForTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResultsChain::GetMostRecentResult()"
//==================================================================================
// CTNResultsChain::GetMostRecentResult
//----------------------------------------------------------------------------------
//
// Description: Returns the most recently added result object in this list that
//				is associated with the specified ID.
//
// Arguments:
//	char* szID		ID to search for.
//
// Returns: Pointer to test result or NULL if an error occurred.
//==================================================================================
PTNRESULT CTNResultsChain::GetMostRecentResult(char* szID)
{
	int			i;
	PTNRESULT	pItem = NULL;


	if (this == NULL)
	{
		DPL(0, "ResultChain pointer is NULL!", 0);
		return (NULL);
	} // end if (got passed invalid object)

	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNRESULT) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (NULL);
		} // end if (couldn't get that item)

		if (pItem->IsCase(szID))
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (found an ID the caller was looking for)
	} // end for (each data item in the list)
	this->LeaveCritSection();

	//DPL(0, "Couldn't find an instance of ID %s!", 1, szID);

	return (NULL);
} // CTNResultsChain::GetMostRecentResult
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResultsChain::GetMostRecentOutputVar()"
//==================================================================================
// CTNResultsChain::GetMostRecentOutputVar
//----------------------------------------------------------------------------------
//
// Description: Searches for a variable with the given name and type, and sets the
//				pointer and size to the variables value pointer and size.
//				Note: this is not a copy of the data.
//				If a variable with that name is not found, ERROR_NOT_FOUND is
//				returned.
//
// Arguments:
//	char* szName				Name of variable to retrieve.
//	char* szType				Type of variable to retrieve.
//	PVOID* ppvValueLocation		Pointer to set to point to variable's value.
//	DWORD* pdwValueSize			Pointer to set to size of variable's value.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNResultsChain::GetMostRecentOutputVar(char* szName, char* szType,
												PVOID* ppvValueLocation,
												DWORD* pdwValueSize)
{
	HRESULT		hr;
	int			i;
	PTNRESULT	pResult;


	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)


	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pResult = (PTNRESULT) this->GetItem(i);
		if (pResult == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get result %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get item)

		hr = pResult->GetOutputVariable(szName, szType, ppvValueLocation,
										pdwValueSize);
		if (hr == S_OK)
		{
			// We found it, so we're done.
			this->LeaveCritSection();
			return (S_OK);
		} // end if (couldn't get item)

		if (hr != ERROR_NOT_FOUND)
		{
			// Got some wierd error
			this->LeaveCritSection();
			DPL(0, "Failed searching for output variable under result %i!", 1, i);
			return (hr);
		} // end if (couldn't get item)

		// Well it wasn't found yet, so keep looking
	} // end for (each result)

	this->LeaveCritSection();

	return (ERROR_NOT_FOUND);
} // CTNResultsChain::GetMostRecentOutputVar
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNResultsChain::GetMostRecentOutputVarOfType()"
//==================================================================================
// CTNResultsChain::GetMostRecentOutputVarOfType
//----------------------------------------------------------------------------------
//
// Description: Searches for the first variable of the given type, and sets the
//				pointer and size to the variables value pointer and size.  If
//				lplpszName is not NULL, then it is set to point to the name of the
//				variable found.
//				Note: this is not a copy of the data.
//				If a variable of that type is not found, ERROR_NOT_FOUND is
//				returned.
//
// Arguments:
//	char* szType				Type of variable to retrieve.
//	char** ppszName				Optional pointer to hold name of variable found.
//	PVOID* ppvValueLocation		Pointer to set to point to variable's value.
//	DWORD* pdwValueSize			Pointer to set to size of variable's value.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNResultsChain::GetMostRecentOutputVarOfType(char* szType, char** ppszName,
													PVOID* ppvValueLocation,
													DWORD* pdwValueSize)
{
	HRESULT		hr;
	int			i;
	PTNRESULT	pResult;


	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)


	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pResult = (PTNRESULT) this->GetItem(i);
		if (pResult == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get result %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get item)

		hr = pResult->GetOutputVariableOfType(szType, ppszName,
											ppvValueLocation,
											pdwValueSize);
		if (hr == S_OK)
		{
			// We found it, so we're done.
			this->LeaveCritSection();
			return (S_OK);
		} // end if (couldn't get item)

		if (hr != ERROR_NOT_FOUND)
		{
			// Got some wierd error
			this->LeaveCritSection();
			DPL(0, "Failed searching for output variable of type %s under result %i!",
				2, i, szType);
			return (hr);
		} // end if (couldn't get item)

		// Well it wasn't found yet, so keep looking
	} // end for (each result)

	this->LeaveCritSection();

	return (ERROR_NOT_FOUND);
} // CTNResultsChain::GetMostRecentOutputVarOfType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\script.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\debugprint.h"
#include "..\tncommon\strutils.h"


#include "tncontrl.h"
#include "main.h"

#include "resource.h"

#include "script.h"








//==================================================================================
// Prototypes
//==================================================================================
HRESULT ScriptGet_FreeOutputVars(PTNGETINPUTDATA pTNgid);

HRESULT ScriptExec_FreeOutputVars(PTNEXECCASEDATA pTNecd);


HRESULT ScriptGet_FreeResults(PTNGETINPUTDATA pTNgid);

HRESULT ScriptExec_FreeResults(PTNEXECCASEDATA pTNecd);


HRESULT ScriptGet_Sleep(PTNGETINPUTDATA pTNgid);

HRESULT ScriptExec_Sleep(PTNEXECCASEDATA pTNecd);


HRESULT ScriptGet_Wait(PTNGETINPUTDATA pTNgid);

HRESULT ScriptExec_Wait(PTNEXECCASEDATA pTNecd);


INT_PTR CALLBACK WaitForUserOKDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptLoadTestTable()"
//==================================================================================
// ScriptLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				FreeOutputVars	Built-in script: FreeOutputVars
//				FreeResults		Built-in script: FreeResults
//				Sleep			Built-in script: Sleep
//				WaitForUserOK	Built-in script: WaitForUserOK
//
// Arguments:
//	PTNTESTTABLEGROUP pTable	Group/table to fill with tests in this file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ScriptLoadTestTable(PTNTESTTABLEGROUP pTable)
{
	PTNTESTTABLEGROUP	pSubGroup;
	TNADDTESTDATA		tnatd;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// BuiltIn			Built-in script functions
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pTable, "BuiltIn", "Built-in script functions", &pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// FreeOutputVars	Built-in script: FreeOutputVars
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "FreeOutputVars";
	tnatd.pszName			= "Built-in script: FreeOutputVars";

	tnatd.pszDescription	= "Frees all output variables (matching the optional input data) that have accumulated.";

	tnatd.pszInputDataHelp	= "CaseID = frees only output variables generated from the matching case ID\n"
								"InstanceID = frees only output variables generated from that matching instance ID\n"
								"Name = frees only output variables with this name\n"
								"Type = frees only output variables with this type\n"
								"FreeData = TRUE to free the output data if all variables are gone, FALSE if not";

	tnatd.iNumMachines		= -1;
	tnatd.dwOptionFlags		= TNTCO_BUILTIN
								| TNTCO_API | TNTCO_STRESS | TNTCO_POKE | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= ScriptGet_FreeOutputVars;
	tnatd.pfnExecCase		= ScriptExec_FreeOutputVars;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// FreeResults		Built-in script: FreeResults
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "FreeResults";
	tnatd.pszName			= "Built-in script: FreeResults";

	tnatd.pszDescription	= "Frees all results (matching the optional input data) that have accumulated.";

	tnatd.pszInputDataHelp	= "CaseID = frees only results that match this case ID\n"
								"InstanceID = frees only results that match this instance ID";

	tnatd.iNumMachines		= -1;
	tnatd.dwOptionFlags		= TNTCO_BUILTIN
								| TNTCO_API | TNTCO_STRESS | TNTCO_POKE | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= ScriptGet_FreeResults;
	tnatd.pfnExecCase		= ScriptExec_FreeResults;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Sleep		Built-in script: Sleep
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "Sleep";
	tnatd.pszName			= "Built-in script: Sleep";

	tnatd.pszDescription	= "Causes the machine to do nothing for the given amount of time (see WaitForEventOrCancel).";

	tnatd.pszInputDataHelp	= "MS = Number of milliseconds to sleep";

	tnatd.iNumMachines		= -1;
	tnatd.dwOptionFlags		= TNTCO_BUILTIN
								| TNTCO_API | TNTCO_STRESS | TNTCO_POKE | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= ScriptGet_Sleep;
	tnatd.pfnExecCase		= ScriptExec_Sleep;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);


	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// WaitForUserOK		Built-in script: WaitForUserOK
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "WaitForUserOK";
	tnatd.pszName			= "Built-in script: WaitForUserOK";

	tnatd.pszDescription	= "Prompts the user to acknowledge a dialog box before continuing.";

	tnatd.pszInputDataHelp	= "Timeout = Number of seconds to wait before automatically closing dialog\n"
								"Message = Message string to display in dialog";

	tnatd.iNumMachines		= -1;
	tnatd.dwOptionFlags		= TNTCO_BUILTIN
								| TNTCO_API | TNTCO_STRESS | TNTCO_POKE | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= ScriptGet_Wait;
	tnatd.pfnExecCase		= ScriptExec_Wait;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);
#ifdef _XBOX // We don't support these, but we'll add them just so checksums match
#pragma TODO(tristanj, "We don't support WaitForUserOK, but we need to make the checksums match")
#endif // XBOX


	return (S_OK);
} // ScriptLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptGet_FreeOutputVars()"
//==================================================================================
// ScriptGet_FreeOutputVars
//----------------------------------------------------------------------------------
//
// Description: Callback that retrieves the initial data for the test case(s):
//				FreeOutputVars - Built-in script: FreeOutputVars
//
// Arguments:
//	PTNGETINPUTDATA pTNgid		Pointer to parameter block with information on how
//								and where to place the input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ScriptGet_FreeOutputVars(PTNGETINPUTDATA pTNgid)
{
	PTID_SCRIPT_FREEOUTPUTVARS	pParams = (PTID_SCRIPT_FREEOUTPUTVARS) pTNgid->pvData;
	PLSTRINGLIST				pStrings = NULL;
	char*						pszTemp;
	LPBYTE						lpCurrent;


	// Start off with base size.
	pTNgid->dwDataSize = sizeof (TID_SCRIPT_FREEOUTPUTVARS);


	if (pParams != NULL)
	{
		// Initialize to defaults.
		pParams->dwCaseIDSize = 0;
		pParams->dwInstanceIDSize = 0;
		pParams->dwNameSize = 0;
		pParams->dwTypeSize = 0;
		pParams->fFreeData = FALSE;

		lpCurrent = (LPBYTE) (pParams + 1);
	} // end if (there's a buffer)

	pStrings = pTNgid->pStringData->GetScriptInputDataStrings();

#pragma TODO(vanceo, "Check assignment reports")

	// Check for a message string
	if (pStrings != NULL)
	{
		// Find the CaseID key, case insensitive.
		pszTemp = pStrings->GetValueOfKey("CaseID");
		if (pszTemp != NULL)
		{
			if (pParams == NULL)
			{
				pTNgid->dwDataSize += strlen(pszTemp) + 1;
			} // end if (getting size)
			else
			{
				pParams->dwCaseIDSize = strlen(pszTemp) + 1;
				CopyAndMoveDestPointer(lpCurrent, pszTemp, pParams->dwCaseIDSize);
			} // end else (actually getting data)
		} // end if (got key value)


		// Find the InstanceID key, case insensitive.
		pszTemp = pStrings->GetValueOfKey("InstanceID");
		if (pszTemp != NULL)
		{
			if (pParams == NULL)
			{
				pTNgid->dwDataSize += strlen(pszTemp) + 1;
			} // end if (getting size)
			else
			{
				pParams->dwInstanceIDSize = strlen(pszTemp) + 1;
				CopyAndMoveDestPointer(lpCurrent, pszTemp, pParams->dwInstanceIDSize);
			} // end else (actually getting data)
		} // end if (got key value)


		// Find the name key, case insensitive.
		pszTemp = pStrings->GetValueOfKey("Name");
		if (pszTemp != NULL)
		{
			if (pParams == NULL)
			{
				pTNgid->dwDataSize += strlen(pszTemp) + 1;
			} // end if (getting size)
			else
			{
				pParams->dwNameSize = strlen(pszTemp) + 1;
				CopyAndMoveDestPointer(lpCurrent, pszTemp, pParams->dwInstanceIDSize);
			} // end else (actually getting data)
		} // end if (got key value)


		// Find the type key, case insensitive.
		pszTemp = pStrings->GetValueOfKey("Type");
		if (pszTemp != NULL)
		{
			if (pParams == NULL)
			{
				pTNgid->dwDataSize += strlen(pszTemp) + 1;
			} // end if (getting size)
			else
			{
				pParams->dwTypeSize = strlen(pszTemp) + 1;
				CopyAndMoveDestPointer(lpCurrent, pszTemp, pParams->dwInstanceIDSize);
			} // end else (actually getting data)
		} // end if (got key value)


		// If there's a buffer to copy too
		if (pParams != NULL)
		{
			// Find the name key, case insensitive.
			pParams->fFreeData = pStrings->IsKeyTrue("FreeData");
		} // end if (there's a buffer)
	} // end if (there was script data)


	if (pParams == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
} // ScriptGet_FreeOutputVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptExec_FreeOutputVars()"
//==================================================================================
// ScriptExec_FreeOutputVars
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				FreeOutputVars - Built-in script: FreeOutputVars
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data:
//	Optional case and instance IDs to filter.
//	Optional variable name and type to filter.
//	Whether to free the output data if all the variables are removed, too.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ScriptExec_FreeOutputVars(PTNEXECCASEDATA pTNecd)
{
	HRESULT						hr;
	PTID_SCRIPT_FREEOUTPUTVARS	pInput = (PTID_SCRIPT_FREEOUTPUTVARS) pTNecd->pvInputData;
	BOOL						fSuccess = TRUE;
	LPBYTE						lpCurrent;
	char*						pszCaseID = NULL;
	char*						pszInstanceID = NULL;
	char*						pszName = NULL;
	char*						pszType = NULL;


	if (pTNecd->dwInputDataSize != sizeof (TID_SCRIPT_FREEOUTPUTVARS))
	{
		DPL(0, "Didn't get expected input data (size %u != %u)!",
			2, pTNecd->dwInputDataSize, sizeof (TID_SCRIPT_FREEOUTPUTVARS));
		return (E_FAIL);
	} // end if (didn't get expected input data)


	lpCurrent = (LPBYTE) (pInput + 1);

	if (pInput->dwCaseIDSize > 0)
	{
		pszCaseID = (char*) lpCurrent;
		lpCurrent += pInput->dwCaseIDSize;
	} // end if (there's a case ID string)

	if (pInput->dwInstanceIDSize > 0)
	{
		pszInstanceID = (char*) lpCurrent;
		lpCurrent += pInput->dwInstanceIDSize;
	} // end if (there's an instance ID string)

	if (pInput->dwNameSize > 0)
	{
		pszName = (char*) lpCurrent;
		lpCurrent += pInput->dwNameSize;
	} // end if (there's a name string)

	if (pInput->dwTypeSize > 0)
	{
		pszType = (char*) lpCurrent;
		lpCurrent += pInput->dwTypeSize;
	} // end if (there's a type string)


	hr = pTNecd->pExecutor->FreeOutputVars(pszCaseID, pszInstanceID, pszName, pszType,
											pInput->fFreeData);
	if (hr != S_OK)
		fSuccess = FALSE;

	hr = pTNecd->pFinalResult->SetResultCodeAndBools(hr, TRUE, fSuccess);
	if (hr != S_OK)
	{
		DPL(0, "Setting test results failed!", 0);
	} // end if (setting results failed)

	return (hr);
} // ScriptExec_FreeOutputVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptGet_FreeResults()"
//==================================================================================
// ScriptGet_FreeResults
//----------------------------------------------------------------------------------
//
// Description: Callback that retrieves the initial data for the test case(s):
//				FreeResults - Built-in script: FreeResults
//
// Arguments:
//	PTNGETINPUTDATA pTNgid		Pointer to parameter block with information on how
//								and where to place the input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ScriptGet_FreeResults(PTNGETINPUTDATA pTNgid)
{
	PTID_SCRIPT_FREERESULTS		pParams = (PTID_SCRIPT_FREERESULTS) pTNgid->pvData;
	PLSTRINGLIST				pStrings = NULL;
	char*						pszTemp;
	LPBYTE						lpCurrent;


	// Start off with base size.
	pTNgid->dwDataSize = sizeof (TID_SCRIPT_FREERESULTS);


	if (pParams != NULL)
	{
		// Initialize to defaults.
		pParams->dwCaseIDSize = 0;
		pParams->dwInstanceIDSize = 0;

		lpCurrent = (LPBYTE) (pParams + 1);
	} // end if (there's a buffer)

	pStrings = pTNgid->pStringData->GetScriptInputDataStrings();

#pragma TODO(vanceo, "Check assignment reports")

	// Check for a message string
	if (pStrings != NULL)
	{
		// Find the CaseID key, case insensitive.
		pszTemp = pStrings->GetValueOfKey("CaseID");
		if (pszTemp != NULL)
		{
			if (pParams == NULL)
			{
				pTNgid->dwDataSize += strlen(pszTemp) + 1;
			} // end if (getting size)
			else
			{
				pParams->dwCaseIDSize = strlen(pszTemp) + 1;
				CopyAndMoveDestPointer(lpCurrent, pszTemp, pParams->dwCaseIDSize);
			} // end else (actually getting data)
		} // end if (got key value)


		// Find the InstanceID key, case insensitive.
		pszTemp = pStrings->GetValueOfKey("InstanceID");
		if (pszTemp != NULL)
		{
			if (pParams == NULL)
			{
				pTNgid->dwDataSize += strlen(pszTemp) + 1;
			} // end if (getting size)
			else
			{
				pParams->dwInstanceIDSize = strlen(pszTemp) + 1;
				CopyAndMoveDestPointer(lpCurrent, pszTemp, pParams->dwInstanceIDSize);
			} // end else (actually getting data)
		} // end if (got key value)
	} // end if (there was script data)


	if (pParams == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
} // ScriptGet_FreeResults
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptExec_FreeResults()"
//==================================================================================
// ScriptExec_FreeResults
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				FreeResults - Built-in script: FreeResults
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data:
//	Optional case and instance IDs to filter.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ScriptExec_FreeResults(PTNEXECCASEDATA pTNecd)
{
	HRESULT						hr;
	PTID_SCRIPT_FREERESULTS		pInput = (PTID_SCRIPT_FREERESULTS) pTNecd->pvInputData;
	BOOL						fSuccess = TRUE;
	LPBYTE						lpCurrent;
	char*						pszCaseID = NULL;
	char*						pszInstanceID = NULL;


	if (pTNecd->dwInputDataSize != sizeof (TID_SCRIPT_FREERESULTS))
	{
		DPL(0, "Didn't get expected input data (size %u != %u)!",
			2, pTNecd->dwInputDataSize, sizeof (TID_SCRIPT_FREERESULTS));
		return (E_FAIL);
	} // end if (didn't get expected input data)


	lpCurrent = (LPBYTE) (pInput + 1);

	if (pInput->dwCaseIDSize > 0)
	{
		pszCaseID = (char*) lpCurrent;
		lpCurrent += pInput->dwCaseIDSize;
	} // end if (there's a case ID string)

	if (pInput->dwInstanceIDSize > 0)
	{
		pszInstanceID = (char*) lpCurrent;
		lpCurrent += pInput->dwInstanceIDSize;
	} // end if (there's an instance ID string)


	hr = pTNecd->pExecutor->FreeResults(pszCaseID, pszInstanceID);
	if (hr != S_OK)
		fSuccess = FALSE;

	hr = pTNecd->pFinalResult->SetResultCodeAndBools(hr, TRUE, fSuccess);
	if (hr != S_OK)
	{
		DPL(0, "Setting test results failed!", 0);
	} // end if (setting results failed)

	return (hr);
} // ScriptExec_FreeResults
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptGet_Sleep()"
//==================================================================================
// ScriptGet_Sleep
//----------------------------------------------------------------------------------
//
// Description: Callback that retrieves the initial data for the test case(s):
//				Sleep - Built-in script: Sleep
//
// Arguments:
//	PTNGETINPUTDATA pTNgid		Pointer to parameter block with information on how
//								and where to place the input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ScriptGet_Sleep(PTNGETINPUTDATA pTNgid)
{
	PTID_SCRIPT_SLEEP	pParams = (PTID_SCRIPT_SLEEP) pTNgid->pvData;
	PLSTRINGLIST		pStrings = NULL;
	char*				pszTemp;


	pTNgid->dwDataSize = sizeof (TID_SCRIPT_SLEEP);

	if (pParams == NULL)
		return (ERROR_BUFFER_TOO_SMALL);


	pStrings = pTNgid->pStringData->GetScriptInputDataStrings();

#pragma TODO(vanceo, "Check assignment reports, improve")

	
	if ((pStrings == NULL) || (pStrings->Count() != 1))
	{
		DPL(0, "Didn't get expected script initial data (requires \"MS=\")", 0);
		return (S_OK);
	} // end if (didn't get expected parameters)


	// Find the key MS, case insensitive.
	pszTemp = pStrings->GetValueOfKey("MS");
	if (pszTemp == NULL)
	{
		DPL(0, "Couldn't get value of key \"MS\"!", 0);
		return (S_OK);
	} // end if (couldn't get key value)

	pParams->dwMS = StringToDWord(pszTemp);

	return (S_OK);
} // ScriptGet_Sleep
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptExec_Sleep()"
//==================================================================================
// ScriptExec_Sleep
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				Sleep - Built-in script: Sleep
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data:
//	Number of millisconds to sleep.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ScriptExec_Sleep(PTNEXECCASEDATA pTNecd)
{
	HRESULT				hr;
	PTID_SCRIPT_SLEEP	pInput = (PTID_SCRIPT_SLEEP) pTNecd->pvInputData;


	if (pTNecd->dwInputDataSize != sizeof (TID_SCRIPT_SLEEP))
	{
		DPL(0, "Didn't get expected input data (size %u != %u)!",
			2, pTNecd->dwInputDataSize, sizeof (TID_SCRIPT_SLEEP));
		return (E_FAIL);
	} // end if (didn't get expected input data)


	DPL(0, "Built-in script: Sleep;  Sleeping for %u milliseconds",
		1, pInput->dwMS);


	hr = pTNecd->pExecutor->WaitForEventOrCancel(NULL, 0, NULL, 0, pInput->dwMS, NULL);
	if (hr != TNWR_TIMEOUT)
	{
		DPL(0, "Had problem waiting for event or cancel!  %e", 1, hr);
		pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
							"Had problem waiting for event or cancel!  %e", 1, hr);
		return (hr);
	} // end if (waiting failed)


	// Of course this function always is successful.

	hr = pTNecd->pFinalResult->SetResultCodeAndBools(S_OK, TRUE, TRUE);
	if (hr != S_OK)
	{
		DPL(0, "Setting test results failed!", 0);
	} // end if (setting results failed)

	return (hr);
} // ScriptExec_Sleep
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptGet_Wait()"
//==================================================================================
// ScriptGet_Wait
//----------------------------------------------------------------------------------
//
// Description: Callback that retrieves the initial data for the test case(s):
//				WaitForUserOK	Built-in script: WaitForUserOK
//
// Arguments:
//	PTNGETINPUTDATA pTNgid	Pointer to parameter block with information on how and
//							where to place the input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ScriptGet_Wait(PTNGETINPUTDATA pTNgid)
{
#ifndef _XBOX
	PTID_SCRIPT_WAIT	pParams = (PTID_SCRIPT_WAIT) pTNgid->pvData;
	PLSTRINGLIST		pStrings = NULL;
	char*				pszTemp;


	pTNgid->dwDataSize = sizeof (TID_SCRIPT_WAIT);

	pStrings = pTNgid->pStringData->GetScriptInputDataStrings();

#pragma TODO(vanceo, "Check assignment reports")

	// Check for a message string
	if (pStrings != NULL)
	{
		// Find the key Timeout, case insensitive.
		pszTemp = pStrings->GetValueOfKey("Timeout");
		if (pszTemp == NULL)
		{
			if (pParams != NULL)
			{
				DPL(0, "There are strings, but couldn't get value of key \"Timeout\"!  Using default.", 0);
				pParams->dwSecs = 0;
			} // end if (not just retrieving size)

		} // end if (couldn't get key value)
		else if (pParams != NULL)
			pParams->dwSecs = StringToDWord(pszTemp);

		
		// Find the key Message, case insensitive.
		pszTemp = pStrings->GetValueOfKey("Message");
		if (pszTemp == NULL)
		{
			if (pParams != NULL)
			{
				DPL(0, "There are strings, but couldn't get value of key \"Message\"!  Using default.", 0);
				pParams->dwStringSize = 0;
			} // end if (not just retrieving size)

		} // end if (couldn't get key value)
		else
		{
			if (pParams == NULL)
			{
				pTNgid->dwDataSize += strlen(pszTemp) + 1;
			} // end if (just retrieve size)
			else
			{
				pParams->dwStringSize = strlen(pszTemp) + 1;
				strcpy((char*) (pParams + 1), pszTemp);
			} // end else (not just retrieving size)
		} // end else (successfully found message)

	} // end if (there was script data)
	else if (pParams != NULL)
	{
		pParams->dwSecs = 0;
		pParams->dwStringSize = 0;
	} // end else if (not just retrieving size)


	if (pParams == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
#else // ! XBOX
#pragma BUGBUG(tristanj, "Adding Wait case back so that the checksums match, but we don't support it")
	return E_FAIL;
#endif // XBOX
} // ScriptGet_Wait
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"ScriptExec_Wait()"
//==================================================================================
// ScriptExec_Wait
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				WaitForUserOK	Built-in script: WaitForUserOK
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data:
//	Number of seconds to timeout (optional).
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ScriptExec_Wait(PTNEXECCASEDATA pTNecd)
{
#ifndef _XBOX
	HRESULT				hr;
	PTID_SCRIPT_WAIT	pInput = (PTID_SCRIPT_WAIT) pTNecd->pvInputData;
	INT_PTR				iMsgBoxResult;


	if ((pInput == NULL) || (pInput->dwSecs == 0) || (pInput->dwSecs == INFINITE))
	{
		//DPL(0, "Built-in script: WaitForUserOK;  WARNING: Displaying dialog box without timeout.", 0);
		pTNecd->pExecutor->Log(TNLF_IMPORTANT | TNLF_PREFIX_TESTUNIQUEID,
								"NOTE: Displaying dialog box without timeout.",
								0);
	} // end if (we're not being timed)
	else
	{
		/*
		DPL(0, "Built-in script: WaitForUserOK;  Displaying dialog box with timeout of %u seconds.",
			1, pData->dwSecs);
		*/
		pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
								"Displaying dialog box with timeout of %u seconds.",
								1, pInput->dwSecs);
	} // end else (we're being timed)


	iMsgBoxResult = DialogBoxParam(s_hInstance, MAKEINTRESOURCE(IDD_WAITFORUSEROK), NULL,
				                   WaitForUserOKDlgProc, (LPARAM) pInput);


	// Of course this function always is successful.

	hr = pTNecd->pFinalResult->SetResultCodeAndBools(S_OK, TRUE, TRUE);
	if (hr != S_OK)
	{
		DPL(0, "Setting test results failed!", 0);
	} // end if (setting results failed)

	return (hr);
#else // ! XBOX
#pragma BUGBUG(tristanj, "Adding Wait case back so that the checksums match, but we don't support it")
	return E_FAIL;
#endif // XBOX
} // ScriptExec_Wait
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no window logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"WaitForUserOKDlgProc()"
//==================================================================================
// WaitForUserOKDlgProc
//----------------------------------------------------------------------------------
//
// Description: WaitForUserOK dialog window procedure.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK WaitForUserOKDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static DWORD	dwSecs = 0;

	char			szTemp[32];


	switch (uMsg)
	{
		case WM_INITDIALOG:
			PTID_SCRIPT_WAIT	pData;
			
			
			pData = (PTID_SCRIPT_WAIT) lParam;


			if ((pData != NULL) && (pData->dwStringSize > 0))
			{
				SetWindowText(GetDlgItem(hWnd, IDS_DESCRIPTION), (char*) (pData + 1));
			} // end if (there's a custom string)


			if ((pData == NULL) || (pData->dwSecs == 0) || (pData->dwSecs == INFINITE))
			{
				DestroyWindow(GetDlgItem(hWnd, IDS_TONLY_TIMERDESC));
				DestroyWindow(GetDlgItem(hWnd, IDT_TONLY_TIMER));
			} // end if (we're not being timed)
			else
			{
				dwSecs = pData->dwSecs;

				if (dwSecs != 1)
					wsprintf(szTemp, "%i seconds.", dwSecs);
				else
					strcpy(szTemp, "1 second.");


				SetWindowText(GetDlgItem(hWnd, IDT_TONLY_TIMER), szTemp);

				SetTimer(hWnd, 1, 1000, NULL);
			} // end else (we're being timed)
		  break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDOK:
					DPL(0, "User pressed 'OK'.", 0);

					KillTimer(hWnd, 1);
					EndDialog(hWnd, IDOK);
				  break;
			} // end switch (on the button pressed/control changed)
		  break;

		case WM_TIMER:
			dwSecs--;

			if (dwSecs > 0)
			{
				if (dwSecs != 1)
					wsprintf(szTemp, "%i seconds.", dwSecs);
				else
					strcpy(szTemp, "1 second.");

				SetWindowText(GetDlgItem(hWnd, IDT_TONLY_TIMER), szTemp);

				SetTimer(hWnd, 1, 1000, NULL);
			} // end if (time limit has not been reached)
			else
			{
				KillTimer(hWnd, 1);
				EndDialog(hWnd, IDOK);
			} // end else  (time limit has been reached)

			return (TRUE);
		  break;
	} // end switch (on the type of window message)

	return (DefWindowProc(hWnd, uMsg, wParam, lParam));
} // WaitForUserOKDlgProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\sendq.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\stack.h"

#include "tncontrl.h"
#include "main.h"

#include "sendq.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSendData::CTNSendData()"
//==================================================================================
// CTNSendData constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNSendData object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNSendData::CTNSendData(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNSendData));

	this->m_fGuaranteed = FALSE;
	this->m_pvAddress = NULL;
	this->m_dwAddressSize = 0;
	this->m_pvData = NULL;
	this->m_dwDataSize = 0;
	this->m_pvSubmittersAddress = NULL;
} // CTNSendData::CTNSendData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSendData::~CTNSendData()"
//==================================================================================
// CTNSendData destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNSendData object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNSendData::~CTNSendData(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pvAddress != NULL)
	{
		LocalFree(this->m_pvAddress);
		this->m_pvAddress = NULL;
	} // end if (an address was allocated)

	if (this->m_pvData != NULL)
	{
		LocalFree(this->m_pvData);
		this->m_pvData = NULL;
	} // end if (data was allocated)
} // CTNSendData::~CTNSendData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSendDataQueue::CTNSendDataQueue()"
//==================================================================================
// CTNSendDataQueue constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNSendDataQueue object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNSendDataQueue::CTNSendDataQueue(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNSendDataQueue));

	// Auto reset event
	this->m_hSendDataEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (this->m_hSendDataEvent == NULL)
	{
		HRESULT		hr;


		hr = GetLastError();
		DPL(0, "Failed to create send data event!  %e", 1, hr);
	} // end if (failed to create event)
} // CTNSendDataQueue::CTNSendDataQueue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSendDataQueue::~CTNSendDataQueue()"
//==================================================================================
// CTNSendDataQueue destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNSendDataQueue object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNSendDataQueue::~CTNSendDataQueue(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_hSendDataEvent != NULL)
	{
		CloseHandle(this->m_hSendDataEvent);
		this->m_hSendDataEvent = NULL;
	} // end if (have event)
} // CTNSendDataQueue::~CTNSendDataQueue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSendDataQueue::AddSendData()"
//==================================================================================
// CTNSendDataQueue::AddSendData
//----------------------------------------------------------------------------------
//
// Description: Adds the passed item onto the queue and sets the event.
//
// Arguments:
//	PTNSENDDATA pNewSendData	Item to add.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSendDataQueue::AddSendData(PTNSENDDATA pNewSendData)
{
	HRESULT		hr;
	PVOID		pvCallersCaller;


	// Save the address of the function calling us for debugging purposes.
	TNStackGetCallersAddress(&(pNewSendData->m_pvSubmittersAddress),
							&pvCallersCaller);

	/*
	DPL(9, "Data %x submitted by %X, %X",
		3, pNewSendData->m_pvData, pNewSendData->m_pvSubmittersAddress, pvCallersCaller);
	*/

	hr = this->Add(pNewSendData);
	if (hr != S_OK)
	{
		DPL(0, "Failed to add send data item!", 0);
		return (hr);
	} // end if (failed to add item)

	if (! SetEvent(this->m_hSendDataEvent))
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't set send data event %x!", 1, this->m_hSendDataEvent);

		return (hr);
	} // end if (couldn't set event)

	return (S_OK);
} // CTNSendDataQueue::AddSendData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSendDataQueue::RemoveAllItemsTo()"
//==================================================================================
// CTNSendDataQueue::RemoveAllItemsTo
//----------------------------------------------------------------------------------
//
// Description: Removes all items still in the queue that are to be sent to the
//				given address.
//
// Arguments:
//	PVOID pvAddress			Pointer to address memory to compare.
//	DWORD dwAddressSize		Size of address memory to compare.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSendDataQueue::RemoveAllItemsTo(PVOID pvAddress, DWORD dwAddressSize)
{
	HRESULT			hr = S_OK;
	int				i;
	PTNSENDDATA		pSendData;


	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pSendData = (PTNSENDDATA) this->GetItem(i);
		if (pSendData == NULL)
		{
			DPL(0, "Failed to get send item %i!", 1, i);
			return (E_FAIL);
		} // end if (failed to get first item)		
		
		if ((pSendData->m_dwAddressSize == dwAddressSize) &&
			(memcmp(pSendData->m_pvAddress, pvAddress, dwAddressSize) == 0))
		{
			DPL(0, "WARNING: Removing item %i (%x, size %u) from send queue!",
				3, i, pvAddress, dwAddressSize);

			// Ignore error
			hr = this->Remove(i);
			if (hr != S_OK)
			{
				DPL(0, "Failed removing item %i!", 1, i);
				goto DONE;
			} // end if (failed removing item)

			// Move our index back, so we don't get out of sync with the list.
			i--;
		} // end if (they're going to the same place)
	} // end for (each item)


DONE:

	this->LeaveCritSection();

	return (hr);
} // CTNSendDataQueue::RemoveAllItemsTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\sendq.h ===
#ifndef __TNCONTROL_SENDQUEUE__
#define __TNCONTROL_SENDQUEUE__
//#pragma message("Defining __TNCONTROL_SENDQUEUE__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNSendData:public LLITEM
{
	public:
		BOOL		m_fGuaranteed; // do we care if this actually gets there?
		PVOID		m_pvAddress; // pointer to address data
		DWORD		m_dwAddressSize; // size of address data
		PVOID		m_pvData; // pointer to message data
		DWORD		m_dwDataSize; // size of message data
		PVOID		m_pvSubmittersAddress; // pointer to function which place this item on the queue


		CTNSendData(void);
		virtual ~CTNSendData(void);
};

class DLLEXPORT CTNSendDataQueue:public LLIST
{
	public:
		// This is only public so that the threads can access it
		HANDLE		m_hSendDataEvent; // there is new data to send


		CTNSendDataQueue(void);
		virtual ~CTNSendDataQueue(void);

		HRESULT AddSendData(PTNSENDDATA pNewSendData);
		HRESULT RemoveAllItemsTo(PVOID pvAddress, DWORD dwAddressSize);
};






#else //__TNCONTROL_SENDQUEUE__
//#pragma message("__TNCONTROL_SENDQUEUE__ already included!")
#endif //__TNCONTROL_SENDQUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\slave.h ===
#ifndef __TNCONTRL_SLAVE__
#define __TNCONTRL_SLAVE__
//#pragma message("Defining __TNCONTRL_SLAVE__")






//==================================================================================
// Common Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG



//==================================================================================
// Defines
//==================================================================================
#define IDLE_INTERVAL		10000 // in milliseconds




//==================================================================================
// Prototypes
//==================================================================================
DWORD WINAPI SlavePeriodicSendThreadProc(LPVOID lpvParameter);





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNSlave:public CTNControlLayer
{
	// These are friends so they can access the protected members
	friend DWORD WINAPI SlavePeriodicSendThreadProc(LPVOID lpvParameter);
	friend CTNExecutor;
	friend CTNExecutorPriv;


	private:
		CTNExecutorPriv				m_executor; // executor object we use
		DWORD						m_dwCurrentUniqueID; // uniqueness counter for various operations
		CTNTestStats				m_totalstats; // statistics maintained on all tests

		DWORD						m_dwTimelimit; // time limit for testing
		char*						m_pszSessionFilter; // user specified session filter string
		PTNDOSTARTUPPROC			m_pfnDoStartup; // callback to use to run startup data
		PTNCHANGEBINARYSETPROC		m_pfnChangeBinarySet; // callback to use when swapping binary sets
		char*						m_pszSavedBinsDirPath; // directory to use when saving and restoring binary sets
		PLSTRINGLIST				m_pFailureBreakRules; // pointer to list of cases to DebugBreak() on
		char*						m_pszFailureMemDumpDirPath; // path to directory to dump logs to on failures
		BOOL						m_fGetNetStatInfoOnFailure; // whether to dump net stat info on failure or not

		DWORD						m_dwSessionID; // ID of current session
		HANDLE						m_hPeriodicSendThread; // the enumeration/joining etc. thread
		BOOL						m_fReadyToConnect; // should we respond to EnumReplies?
		BOOL						m_fInSession; // are we currently in a session?
		BOOL						m_fTestingComplete; // is all testing finished?
		PVOID						m_pvMetaMasterAddress; // pointer to buffer with meta-master's address
		DWORD						m_dwMetaMasterAddressSize; // size of meta-master's address
		PVOID						m_pvTestmasterCommData; // actually a PCOMMDATA pointer; testmaster's address data
		DWORD						m_dwLastMasterReceive; // tick count of when we last received data from the master
		PTNBINARYMANAGER			m_pBinMgr; // object to use for snapshot
		CTNReachCheckTargetsList	m_reachchecktargets; // list of targets of reach checks that have been performed
		PTNPERIODICSEND				m_pSessionPeriodicSend; // currently outstanding periodic send we're using to join a session
		HANDLE						m_hMultiInstanceMutex; // mutex used to synchronize access to the shared instance list
		HANDLE						m_hMultiInstanceMMFile; // handle to shared instance list
		int							m_iInstanceIndex; // index of our slot in the shared instance list
		CTNOtherMachineInfosList	m_otherinfos; // info objects for other machines in session

#ifdef _XBOX // We don't support filemapping, so we just store the key that the master wants
		DWORD						m_dwMultiInstanceKey;
#endif

		HRESULT HandleEnumReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_ENUMREPLY pEnumReplyMsg);
		HRESULT HandleHandshakeReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_HANDSHAKEREPLY pHandshakeReplyMsg);
		HRESULT HandleJoinReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_JOINREPLY pJoinReplyMsg);
		HRESULT HandleTestingStatusMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_TESTINGSTATUS pTestingStatusMsg);
		HRESULT HandleNewTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_NEWTEST pNewTestMsg);
		HRESULT HandleAnnounceTestReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_ANNOUNCETESTREPLY pAnnounceTestReplyMsg);
		HRESULT HandleSyncReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_SYNCREPLY pSyncReplyMsg);
		HRESULT HandleUserResponseMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_USERRESPONSE pUserResponseMsg);
		HRESULT HandleIdleReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_IDLEREPLY pIdleReplyMsg);
		HRESULT HandleDumpLogMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_DUMPLOG pDumpLogMsg);
		HRESULT HandleBreakMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_BREAK pBreakMsg);
		HRESULT HandleMetaMasterReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_METAMASTERREPLY pMetaMasterReplyMsg);
		HRESULT HandleMasterPingSlaveMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_MASTERPINGSLAVE pMasterPingMsg);
		HRESULT HandleLostTesterMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_LOSTTESTER pLostTesterMsg);
		HRESULT HandleAcceptReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_ACCEPTREACHCHECK pAcceptReachCheckMsg);
		HRESULT HandleConnectReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_CONNECTREACHCHECK pConnectReachCheckMsg);
		HRESULT HandleInterSlaveReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_INTERSLAVEREACHCHECK pInterSlaveReachCheckMsg);
		HRESULT HandleInterSlaveReachCheckReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
													PCTRLMSG_INTERSLAVEREACHCHECKREPLY pReplyMsg);
		HRESULT HandleGetMachineInfoReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_GETMACHINEINFOREPLY pReplyMsg);


		HRESULT RegisterWithOtherLocalSlaves(void);

		HRESULT GetMultiInstanceKey(DWORD* pdwKey);

		HRESULT UnregisterWithOtherLocalSlaves(void);

		HRESULT InitializeDBLogging(void);

		HRESULT SendReadyForFirstTest(void);

		HRESULT DoIdle(DWORD dwCurrentOp);

		HRESULT StartPeriodicSend(PTNCTRLCOMM pCtrlComm, BOOL fGuaranteed,
									PVOID pvAddress, DWORD dwAddressSize,
									PVOID pvData, DWORD dwDataSize,
									DWORD dwInterval, DWORD dwTimeout,
									PVOID pvUserContext,
									PTNPERIODICSEND* ppPeriodicSend);

		HRESULT StopPeriodicSend(PTNPERIODICSEND pPeriodicSend);

		HRESULT KillPeriodicSendThread(BOOL fKillingSelf);

		HRESULT StartDBCase(PTNTESTINSTANCES pTest);

		HRESULT EndDBCase(PTNTESTINSTANCES pTest, BOOL fSuccess);

		HRESULT DoConnectReachCheckResult(PTNREACHCHECK pReachCheck, BOOL fSuccess,
										HRESULT hresult, PVOID pvAddress,
										DWORD dwAddressSize);

		void GetNetStatInfo(void);



	protected:
		HANDLE						m_hKillPeriodicSendThreadEvent; // when to kill the enumeration/joining etc thread
		CTNPeriodicSendQueue		m_periodicsends; // periodic sends that are going on
		BOOL						m_fQueryingMetaMaster; // should we respond to MetaMasterReplies?
		BOOL						m_fShakingHands; // should we respond to Handshake/JoinReplies?

#ifndef _XBOX
		LPTMAGENT					m_lpTMAgent; // pointer to object to use when/if logging to database
#endif // ! XBOX


		HRESULT TakeSnapshot(void);
		HRESULT RestoreSnapshot(void);

		HRESULT FreeOutputVars(char* pszCaseID, char* pszInstanceID,
							PTNSLAVEINFO pSlave, char* pszName, char* pszType);

		HRESULT ReportInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
								BOOL fTestComplete, BOOL fSuccess,
								PVOID pvOutputData, DWORD dwOutputDataSize,
								PTNOUTPUTVARSLIST pOutputVars);

		HRESULT WarnInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
							PVOID pvUserData, DWORD dwUserDataSize);

		HRESULT AnnounceSubTest(PTNTESTINSTANCES pTest, int iNumMachines,
								PTNCTRLMACHINEID aTesters);

		HRESULT SyncInternal(PTNTESTINSTANCES pTest,
							char* szSyncName,
							PVOID pvSendData,
							DWORD dwSendDataSize,
							PTNSYNCDATALIST pReceiveData,
							int iNumMachines,
							int* aiTesters);

		BOOL IsTesterOnSameMachineInternal(PTNTESTINSTANCES pTest,
											int iTesterNum);

		HRESULT GetTestersIPForPortInternal(PTNTESTINSTANCES pTest,
											int iTesterNum, WORD wPort,
											char* szIPString);

		HRESULT GetTestersPhoneNumInternal(PTNTESTINSTANCES pTest,
											int iTesterNum,
											char* szPhoneNumber);

		HRESULT GetTestersCOMPortInternal(PTNTESTINSTANCES pTest,
										int iTesterNum, DWORD* pdwCOMPort);

		HRESULT SendFreeOutputVars(char* pszCaseID, char* pszInstanceID,
									char* pszName, char* pszType);

		HRESULT GetTestersMachineInfoInternal(PTNTESTINSTANCES pTest,
											int iTesterNum,
											PTNMACHINEINFO* ppInfo);

		HRESULT PeriodicSendExpired(PTNPERIODICSEND pPeriodicSend);

		// Virtual implementations
		HRESULT HandleMessage(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
							  PVOID pvData, DWORD dwDataSize);


	public:
		CTNSlave(void);
		virtual ~CTNSlave(void);


		HRESULT StartJoiningControlSession(PTNJOINCONTROLSESSIONDATA pTNjcsd);

		HRESULT LeaveControlSession(void);

		BOOL IsInSession(void);

		DWORD GetSessionID(void);

		BOOL IsTestingComplete(void);

		HRESULT GetModuleString(char* szString);

		PTNTESTSTATS GetTotalStats(void);

		int GetNumberOfCases(void);

		HRESULT GetCaseIndex(int iIndex, char** ppszID, char** ppszName,
							PTNTESTSTATS* ppStats);

		PTNMACHINEINFO GetMachineInfo(void);

		HRESULT PrintTestTableToFile(char* szFilepath);

		HRESULT PrintResultsToFile(char* szFilepath);

		HRESULT UserQuery(DWORD dwQuery, PVOID pvQueryData, DWORD dwQueryDataSize);

		HRESULT ExecPokeTest(char* szCaseID,
							PVOID pvInputData,
							DWORD dwInputDataSize,
							PTNPOKETESTCOMPLETEDPROC pfnPokeTestCompleted,
							PVOID pvUserContext);
};






#else //__TNCONTRL_SLAVE__
//#pragma message("__TNCONTRL_SLAVE__ already included!")
#endif //__TNCONTRL_SLAVE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\slavelist.h ===
#ifndef __TNCONTRL_SLAVELIST__
#define __TNCONTRL_SLAVELIST__
//#pragma message("Defining __TNCONTRL_SLAVELIST__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// Classes
//==================================================================================
class DLLEXPORT CTNSlavesList:public LLIST
{
	public:
		/*
		CTNSlavesList(void);
		virtual ~CTNSlavesList(void);
		*/

		PTNSLAVEINFO GetSlaveByID(PTNCTRLMACHINEID pID);
};






#else //__TNCONTRL_SLAVELIST__
//#pragma message("__TNCONTRL_SLAVELIST__ already included!")
#endif //__TNCONTRL_SLAVELIST__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\slavelist.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"

#include "slaveinfo.h"
#include "slavelist.h"







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlavesList::GetSlaveByID()"
//==================================================================================
// CTNSlavesList::GetSlaveByID
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the CTNSlaveInfo object identified by the
//				passed in ID.
//
// Arguments:
//	PTNCTRLMACHINEID pID	Pointer to machine to look up.
//
// Returns: Pointer to object or NULL if couldn't find it.
//==================================================================================
PTNSLAVEINFO CTNSlavesList::GetSlaveByID(PTNCTRLMACHINEID pID)
{
	int				i;
	PTNSLAVEINFO	pItem = NULL;


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNSLAVEINFO) this->GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve tester %i!", 1, i);
			this->LeaveCritSection();
			return (NULL);
		} // end if (couldn't get that item)

		if (pItem->m_id.dwTime == pID->dwTime)
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (we found the tester)
	} // end for (each tester)

	this->LeaveCritSection();

	return (NULL);
} // CTNSlavesList::GetSlaveByID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\slaveinfo.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"

#include "slaveinfo.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlaveInfo::CTNSlaveInfo()"
//==================================================================================
// CTNSlaveInfo constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNSlaveInfo object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNSlaveInfo::CTNSlaveInfo(void)
{
	DPL(9, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNSlaveInfo));

	ZeroMemory(&(this->m_id), sizeof (TNCTRLMACHINEID));
	ZeroMemory(&(this->m_commdata), sizeof (COMMDATA));
	this->m_fReadyToTest = FALSE;
	this->m_dwEndtime = 0;
	this->m_pCurrentTest = NULL;
	this->m_dwLastReceiveTime = 0;
	this->m_dwNumPingsSinceReceive = 0;
	this->m_dwMultiInstanceKey = 0;
	this->m_iNumOtherInstancesInSession = 0;
} // CTNSlaveInfo::CTNSlaveInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlaveInfo::~CTNSlaveInfo()"
//==================================================================================
// CTNSlaveInfo destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNSlaveInfo object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNSlaveInfo::~CTNSlaveInfo(void)
{
	DPL(9, "this = %x", 1, this);

	if (this->m_commdata.pvAddress != NULL)
	{
		LocalFree(this->m_commdata.pvAddress);
		this->m_commdata.pvAddress = NULL;
	} // end if (we have a control comm address structure)

	if (this->m_pCurrentTest != NULL)
	{
		this->m_pCurrentTest->m_dwRefCount--;
		if (this->m_pCurrentTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting current test %x.", 1, this->m_pCurrentTest);
			delete (this->m_pCurrentTest);
		} // end if (refcount hit 0)
		else
		{
			DPL(7, "Not deleting current test %x, it's refcount is %u.",
				2, this->m_pCurrentTest, this->m_pCurrentTest->m_dwRefCount);
		} // end else (refcount didn't hit 0)
		this->m_pCurrentTest = NULL;
	} // end if (there's a current test)
} // CTNSlaveInfo::~CTNSlaveInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlaveInfo::GetTest()"
//==================================================================================
// CTNSlaveInfo::GetTest
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the test with the given top level and personal
//				unique IDs.
//
// Arguments:
//	DWORD dwTopLevelUniqueID	ID of top level test the specified test is under
//								(may be same as the actual ID).
//	DWORD dwTestUniqueID		ID of actual test to retrieve.
//
// Returns: Pointer to the given test if found, NULL otherwise.
//==================================================================================
PTNTESTINSTANCEM CTNSlaveInfo::GetTest(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID)
{
	PTNTESTINSTANCEM	pTopLevelTest = NULL;


	// If we have a current test, see if the top level specified is that.
	if (this->m_pCurrentTest != NULL)
	{
		if (this->m_pCurrentTest->m_dwUniqueID == dwTopLevelUniqueID)
			pTopLevelTest = this->m_pCurrentTest;
	} // end if (there's a current test)

	// If we didn't get a top level test above, check all the ongoing tests to see
	// if they're the specified top level test.
	if (pTopLevelTest == NULL)
	{
		pTopLevelTest = (PTNTESTINSTANCEM) this->m_ongoingtestslist.GetTopLevelTest(dwTopLevelUniqueID);
	} // end if (haven't found top level test yet)


	// If we still don't have a top level test, we're screwed.
	if (pTopLevelTest == NULL)
		return (NULL);

	// Try to get the specified (sub)test.
	return (pTopLevelTest->GetTest(dwTestUniqueID));
} // CTNSlaveInfo::GetTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no file printing
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlaveInfo::PrintToFile()"
//==================================================================================
// CTNSlaveInfo::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the info associated with this object to the file specified.
//
// Arguments:
//	HANDLE hFile	Open file to print to.
//
// Returns: None.
//==================================================================================
void CTNSlaveInfo::PrintToFile(HANDLE hFile)
{
	char	szBuffer[1024];


	FileSprintfWriteLine(hFile, "\tID= %u", 1, this->m_id.dwTime);

	FileSprintfWriteLine(hFile, "\tComputerName= %s", 1, this->m_szComputerName);
	FileSprintfWriteLine(hFile, "\tUserName= %s", 1, this->m_szUserName);


	//BUGBUG do we want a string?
	this->GetOSString(szBuffer); //ignoring errors
	FileSprintfWriteLine(hFile, "\tOS= %s", 1, szBuffer);

	switch (this->m_wProcessorArchitecture)
	{
		case PROCESSOR_ARCHITECTURE_INTEL:
			strcpy(szBuffer, "Intel");
		  break;

		case PROCESSOR_ARCHITECTURE_MIPS:
			strcpy(szBuffer, "MIPS");
		  break;

		case PROCESSOR_ARCHITECTURE_ALPHA:
			strcpy(szBuffer, "ALPHA");
		  break;

		case PROCESSOR_ARCHITECTURE_PPC:
			strcpy(szBuffer, "PPC");
		  break;

		default:
			strcpy(szBuffer, "Unknown");
		  break;
	} // end switch (on architecture)
	FileSprintfWriteLine(hFile, "\tProcessorArchitecture= %s", 1, szBuffer);

	FileSprintfWriteLine(hFile, "\tNumProcessors= %u", 1, this->m_dwNumberOfProcessors);


	FileSprintfWriteLine(hFile, "\tWinSock= v%u.%u", 2, LOBYTE(this->m_wWinSock),
						HIBYTE(this->m_wWinSock));

	FileSprintfWriteLine(hFile, "\tIPX= %s",
						1, ((this->m_fIPXInstalled) ? "yes" : "no"));

	FileSprintfWriteLine(hFile, "\tIMTest= %s",
						1, ((this->m_fFaultSimIMTestAvailable) ? "yes" : "no"));

	this->m_TAPIdevices.PrintToFile(hFile);

	this->m_COMports.PrintToFile(hFile);

	this->m_soundcards.PrintToFile(hFile);

	this->m_binaries.PrintToFile(hFile);
} // CTNSlaveInfo::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlaveInfo::UpdateLastReceiveTime()"
//==================================================================================
// CTNSlaveInfo::UpdateLastReceiveTime
//----------------------------------------------------------------------------------
//
// Description: Sets the last time that the slave sent a message to the current time
//				and resets the ping count.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlaveInfo::UpdateLastReceiveTime(void)
{
	this->m_dwLastReceiveTime = GetTickCount();
	this->m_dwNumPingsSinceReceive = 0;

	return (S_OK);
} // CTNSlaveInfo::UpdateLastReceiveTime
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlaveInfo::TimeSinceLastReceive()"
//==================================================================================
// CTNSlaveInfo::TimeSinceLastReceive
//----------------------------------------------------------------------------------
//
// Description: Returns the number of ticks elapsed since the last
//				UpdateLastReceiveTime call for this slave.
//
// Arguments: None.
//
// Returns: Time since last receive.
//==================================================================================
DWORD CTNSlaveInfo::TimeSinceLastReceive(void)
{
	return (GetTickCount() - this->m_dwLastReceiveTime);
} // CTNSlaveInfo::TimeSinceLastReceive
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlaveInfo::PingsSinceLastReceive()"
//==================================================================================
// CTNSlaveInfo::PingsSinceLastReceive
//----------------------------------------------------------------------------------
//
// Description: Returns the number of pings sent elapsed since the last
//				UpdateLastReceiveTime call for this slave.
//
// Arguments: None.
//
// Returns: Number of pings since last receive.
//==================================================================================
DWORD CTNSlaveInfo::PingsSinceLastReceive(void)
{
	return (this->m_dwNumPingsSinceReceive);
} // CTNSlaveInfo::PingsSinceLastReceive
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\sndcards.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <mmreg.h> // NT BUILD requires this before dsound.h
#include <dsound.h>


#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
//#include "..\tncommon\strutils.h"

#include "tncontrl.h"
#include "main.h"

#include "sndcards.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSoundCard::CTNSoundCard()"
//==================================================================================
// CTNSoundCard constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNSoundCard object.  Initializes the data structures.
//
// Arguments:
//	char* szName			Name of this sound card.
//	GUID* pguidDSoundID		GUID DSound uses to identify this sound card.
//	BOOL fHalfDuplex		Whether this device is known to be half-duplex or not.
//
// Returns: None (just the object).
//==================================================================================
CTNSoundCard::CTNSoundCard(char* szName, GUID* pguidDSoundID, BOOL fHalfDuplex):
	CLString(szName),
	m_fHalfDuplex(fHalfDuplex)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNSoundCard));

	CopyMemory(&(this->m_guidDSoundID), pguidDSoundID, sizeof (GUID));
} // CTNSoundCard::CTNSoundCard
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSoundCard::~CTNSoundCard()"
//==================================================================================
// CTNSoundCard destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNSoundCard object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNSoundCard::~CTNSoundCard(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNSoundCard::~CTNSoundCard
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSoundCard::GetDSoundGUID()"
//==================================================================================
// CTNSoundCard::GetDSoundGUID
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the GUID DSound used to identify this device.
//				Note this is not a copy of the data.
//
// Arguments: None.
//
// Returns: Pointer to DSound's GUID for device.
//==================================================================================
GUID* CTNSoundCard::GetDSoundGUID(void)
{
	return (&this->m_guidDSoundID);
} // CTNSoundCard::GetDSoundGUID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSoundCard::IsKnownHalfDuplex()"
//==================================================================================
// CTNSoundCard::IsKnownHalfDuplex
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this device is known to be half-duplex, FALSE if
//				not.
//
// Arguments: None.
//
// Returns: Whether the device is known to be half-duplex or not.
//==================================================================================
BOOL CTNSoundCard::IsKnownHalfDuplex(void)
{
	return (this->m_fHalfDuplex);
} // CTNSoundCard::IsKnownHalfDuplex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSoundCardsList::PackIntoBuffer()"
//==================================================================================
// CTNSoundCardsList::PackIntoBuffer
//----------------------------------------------------------------------------------
//
// Description: Flattens this list into a contiguous buffer for easy transmission.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required, and ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to fill in with
//							buffer size required.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSoundCardsList::PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize)
{
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				i;
	PTNSOUNDCARD	pSoundCard = NULL;



	if (pvBuffer == NULL)
	{
		(*pdwBufferSize) = 0;
	} // end if (just retrieving size)

	this->EnterCritSection();

	i = this->Count();

	if (i <= 0)
	{
		this->LeaveCritSection();
		return (S_OK);
	} // end if (there aren't any items in this list)


	// If we have the buffer already, start copying.
	if (pvBuffer == NULL)
	{
		(*pdwBufferSize) = sizeof (int);
	} // end if (just retrieving size)
	else
	{
		// Copy the number of items in.
		CopyAndMoveDestPointer(lpCurrent, &i, sizeof (int))
	} // end else (have buffer)


	for(i = 0; i < this->Count(); i++)
	{
		pSoundCard = (PTNSOUNDCARD) this->GetItem(i);
		if (pSoundCard == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get sound card %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)


		if (pvBuffer == NULL)
		{
			(*pdwBufferSize) += (strlen(pSoundCard->GetString()) + 1)
							+ sizeof (GUID)
							+ sizeof (BOOL);
		} // end if (just retrieving size)
		else
		{
			CopyAndMoveDestPointer(lpCurrent, pSoundCard->GetString(),
									(strlen(pSoundCard->GetString()) + 1));
			CopyAndMoveDestPointer(lpCurrent, pSoundCard->GetDSoundGUID(), sizeof (GUID));
			CopyAndMoveDestPointer(lpCurrent, &(pSoundCard->m_fHalfDuplex), sizeof (BOOL));
		} // end else (have buffer)

	} // end for (each device)
	this->LeaveCritSection();

	if (pvBuffer == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
} // CTNSoundCardsList::PackIntoBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSoundCardsList::UnpackFromBuffer()"
//==================================================================================
// CTNSoundCardsList::UnpackFromBuffer
//----------------------------------------------------------------------------------
//
// Description: Populates this list with the contents previously stored in a
//				contiguous buffer.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD dwBufferSize		Size of buffer.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSoundCardsList::UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize)
{
	HRESULT			hr;
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				iNumItems = 0;
	int				i;
	PTNSOUNDCARD	pSoundCard = NULL;
	char*			pszName;
	GUID*			pguidDSoundID;
	BOOL			fHalfDuplex;



	this->EnterCritSection();

	CopyAndMoveSrcPointer(&iNumItems, lpCurrent, sizeof (int));

	for(i = 0; i < iNumItems; i++)
	{
		pszName = (char*) lpCurrent;
		lpCurrent += strlen(pszName) + 1;

		pguidDSoundID = (GUID*) lpCurrent;
		lpCurrent += sizeof (GUID);

		CopyAndMoveSrcPointer(&fHalfDuplex, lpCurrent, sizeof (BOOL));
		
		pSoundCard = new (CTNSoundCard)(pszName, pguidDSoundID, fHalfDuplex);
		if (pSoundCard == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		hr = this->Add(pSoundCard);
		if (hr != S_OK)
		{
			DPL(0, "Adding sound card %i failed!", 1, i);
			goto DONE;
		} // end if (couldn't add item)

		pSoundCard = NULL; // forget about it so we don't free it below
	} // end for (each binary location list)


DONE:

	this->LeaveCritSection();

	if (pSoundCard != NULL)
	{
		delete (pSoundCard);
		pSoundCard = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSoundCardsList::UnpackFromBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // no file printing supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSoundCardsList::PrintToFile()"
//==================================================================================
// CTNSoundCardsList::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints all the objects in this list to the file specified.
//
// Arguments:
//	HANDLE hFile	File to print to.
//
// Returns: None.
//==================================================================================
void CTNSoundCardsList::PrintToFile(HANDLE hFile)
{
	int				i;
	PTNSOUNDCARD	pSoundCard = NULL;


	FileWriteLine(hFile, "\t(SoundCards)"); //ignoring errors

	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pSoundCard = (PTNSOUNDCARD) this->GetItem(i);
		if (pSoundCard == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get sound card %i!", 1, i);
			return;
		} // end if (couldn't get that item)

		// ignoring errors
		FileSprintfWriteLine(hFile, "\t\t<%s>",
							1, pSoundCard->GetString());

		FileSprintfWriteLine(hFile, "\t\t\tDSoundGUID= %g",
							1, pSoundCard->GetDSoundGUID());

		FileSprintfWriteLine(hFile, "\t\t\tKnownHalfDuplex= %B",
							1, pSoundCard->IsKnownHalfDuplex());
	} // end for (each item in the list)

	this->LeaveCritSection();

	return;
} // CTNSoundCardsList::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\slaveinfo.h ===
#ifndef __TNCONTROL_SLAVEINFO__
#define __TNCONTROL_SLAVEINFO__
//#pragma message("Defining __TNCONTROL_SLAVEINFO__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG







//==================================================================================
// Classes
//==================================================================================
class DLLEXPORT CTNSlaveInfo:public CTNMachineInfo
{
	// Declare these as friends so they can access the protected members.
	friend class CTNSlavesList;
	friend class CTNTestInstanceM;
#ifndef _XBOX 
	friend class CTNReport;					// Reports not supported
	friend class CTNMaster;					// Masters not supported
#endif // ! XBOX
	friend class CTNJob;


	protected:
		TNCTRLMACHINEID				m_id; // ID of this slave
		COMMDATA					m_commdata; // structure with ctrl comm related data in it
		DWORD						m_fReadyToTest; // has the slave completely joined the session yet
		DWORD						m_dwEndtime; // time when the slave should stop getting additional tests
		PTNTESTINSTANCEM			m_pCurrentTest; // test this machine is currently working on
		CTNTestMsList				m_ongoingtestslist; // list of all tests this slave has outstanding
		//CTNTestMsList				m_completedtestslist; // list of all tests this slave has finished
		CTNReachCheckTargetsList	m_reachchecktargets; // list of targets of reach checks that have been performed
		DWORD						m_dwLastReceiveTime; // last time we received something from the slave
		DWORD						m_dwNumPingsSinceReceive; // how many pings we've sent since we last received from this slave
		DWORD						m_dwMultiInstanceKey; // key generated to help detect multiple slave instances on the same machine
		int							m_iNumOtherInstancesInSession; // how many other slaves on same machine are in the current session


		CTNSlaveInfo(void);
		virtual ~CTNSlaveInfo(void);

		PTNTESTINSTANCEM GetTest(DWORD dwTopLevelUniqueID, DWORD dwTestUniqueID);
		void PrintToFile(HANDLE hFile);
		HRESULT	UpdateLastReceiveTime(void);
		DWORD TimeSinceLastReceive(void);
		DWORD PingsSinceLastReceive(void);
};






#else //__TNCONTROL_SLAVEINFO__
//#pragma message("__TNCONTROL_SLAVEINFO__ already included!")
#endif //__TNCONTROL_SLAVEINFO__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\slave.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define _WIN32_DCOM // so we can use CoInitializeEx.  requires DCOM95 on Win95
#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock2 fn proto's, for getprocaddress
#ifndef _XBOX
#include <winsock2.h>
#else // ! XBOX
#include <winsockx.h>		// Needed for XnetInitialize
#endif // XBOX
#include <windows.h>

#ifdef _XBOX // Damn ANSI conversion
#include <stdio.h>
#include <stdlib.h>
#endif

#include <mmsystem.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\sprintf.h"
#include "..\tncommon\stack.h"

#include "tncontrl.h"
#include "main.h"
#include "resource.h"

#include "sendq.h"
#include "comm.h"
#include "commtcp.h"

#include "slave.h"





//==================================================================================
// Defines
//==================================================================================
#define DBUNVAILABLE_DIALOG_TIMEOUT				15 // in seconds

#define PERIODICSENDTHREAD_STARTUP_TIMEOUT		10000 // in milliseconds
#define TIMEOUT_DIE_PERIODICSENDTHREAD			10000 // in milliseconds

#define CONTROL_ENUM_INTERVAL					3000 // in milliseconds
#define CONTROL_ENUM_TIMEOUT					60000 // in milliseconds
#define CONTROL_DIRECTJOIN_TIMEOUT				20000 // in milliseconds
#define CONTROL_QUERYMETAMASTER_TIMEOUT			20000 // in milliseconds

#define NO_MASTER_TRAFFIC_TIME_WARNING			(IDLE_INTERVAL * 3)

#define DEADLOCK_WARNING_TIME					60000 // in ticks
#define DEADLOCK_BREAK_TIME						30000 // after WARNING time, in ticks

#define TAKINGTOOLONG_NUMINTERVALS_PRINT		3 // after 3 intervals, start noting the problem in the log
#define TAKINGTOOLONG_NUMINTERVALS_TIMEOUT		7 // after 7 intervals, stop waiting and fail


#define TN_DATABASE_APPID						1 // ID to use when logging to the database

#define TNSLAVE_MULTIINSTANCEDETECT_MUTEX		"TestNet Slave multi-instance detection mutex"
#define TNSLAVE_MULTIINSTANCEDETECT_MMFILE		"TestNet Slave multi-instance detection memory mapped file"
#define MAX_NUM_LOCAL_INSTANCES					16





//==================================================================================
// DCOM function type definitions
//==================================================================================
typedef HRESULT	(WINAPI *LPCOINITIALIZEEXPROC)	(LPVOID, DWORD);





//==================================================================================
// Periodic send context structures
//==================================================================================
#define PSCT_QUERYMETAMASTER	1
#define PSCT_JOINDIRECT			2
#define PSCT_ENUM				3
#define PSCT_REACHCHECK			4


typedef struct tagPERIODICSENDCONTEXT
{
	// This must be in every structure.
	DWORD				dwType; // type of context this actually is
} PERIODICSENDCONTEXT, * PPERIODICSENDCONTEXT;

typedef struct tagQUERYMETAMASTERCONTEXT
{
	// This must be in every structure
	DWORD				dwType; // type of context this actually is

	// This is unique to this structure.
} QUERYMETAMASTERCONTEXT, * PQUERYMETAMASTERCONTEXT;

typedef struct tagJOINDIRECTCONTEXT
{
	// This must be in every structure
	DWORD				dwType; // type of context this actually is

	// This is unique to this structure.
} JOINDIRECTCONTEXT, * PJOINDIRECTCONTEXT;

typedef struct tagENUMCONTEXT
{
	// This must be in every structure
	DWORD				dwType; // type of context this actually is

	// This is unique to this structure.
} ENUMCONTEXT, * PENUMCONTEXT;

typedef struct tagREACHCHECKCONTEXT
{
	// This must be in every structure
	DWORD				dwType; // type of context this actually is

	// This is unique to this structure.
	PTNREACHCHECK		pReachCheck; // reach check object this send was for
	char*				pszAddressStrings; // pointer to buffer with multiple address strings to use.
	DWORD				dwTotalAddressStrings; // how many strings in previous buffer
	DWORD				dwCurrentAddressString; // which string is the next one to use
} REACHCHECKCONTEXT, * PREACHCHECKCONTEXT;



//==================================================================================
// Other structures
//==================================================================================
typedef struct tagMULTIINSTANCEITEM
{
	BOOL					fInUse; // is this slot in use yet?
	DWORD					dwSessionID; // session this instance is in, or 0 if this slot is open
	TNCTRLMACHINEID			id; // ID of this instance
} MULTIINSTANCEITEM, * PMULTIINSTANCEITEM;

typedef struct tagMULTIINSTANCEMMFILE
{
	DWORD					dwKey; // special key generated by first instance that helps identify multiple instances
	int						iNumInstances; // how many instances there are currently
	MULTIINSTANCEITEM		aInstances[MAX_NUM_LOCAL_INSTANCES]; // array of instances
} MULTIINSTANCEMMFILE, * PMULTIINSTANCEMMFILE;





//==================================================================================
// Local Prototypes
//==================================================================================
INT_PTR CALLBACK DBUnavailableDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT SlaveReadNetStatTempFileCB(char* szLine, PFILELINEINFO pInfo, PVOID pvContext,
								BOOL* pfStopReading);





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::CTNSlave()"
//==================================================================================
// CTNSlave constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNSlave object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNSlave::CTNSlave(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNSlave));


	// Any changes here should go in LeaveControlSession as well.

	this->m_dwCurrentUniqueID = 1;

	this->m_dwTimelimit = 0;
	this->m_pszSessionFilter = NULL;
	this->m_pfnDoStartup = NULL;
	this->m_pfnChangeBinarySet = NULL;
	this->m_pszSavedBinsDirPath = NULL;
	this->m_pFailureBreakRules = NULL;
	this->m_pszFailureMemDumpDirPath = NULL;
	this->m_fGetNetStatInfoOnFailure = FALSE;

	this->m_dwSessionID = 0;
	this->m_hPeriodicSendThread = NULL;
	this->m_fReadyToConnect = FALSE;
	this->m_fInSession = FALSE;
	this->m_fTestingComplete = FALSE;
	this->m_pvMetaMasterAddress = NULL;
	this->m_dwMetaMasterAddressSize = 0;
	this->m_pvTestmasterCommData = LocalAlloc(LPTR, sizeof (COMMDATA));
	this->m_dwLastMasterReceive = 0;
	this->m_pBinMgr = NULL;
	this->m_pSessionPeriodicSend = NULL;
	this->m_hMultiInstanceMutex = NULL;
	this->m_hMultiInstanceMMFile = NULL;
	this->m_iInstanceIndex = -1;

	this->m_hKillPeriodicSendThreadEvent = NULL;
	this->m_fQueryingMetaMaster = FALSE;
	this->m_fShakingHands = FALSE;

#ifndef _XBOX // no DB logging supported
	this->m_lpTMAgent = NULL;
#endif // ! XBOX

} // CTNSlave::CTNSlave
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::~CTNSlave()"
//==================================================================================
// CTNSlave destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNSlave object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNSlave::~CTNSlave(void)
{
	HRESULT		hr;


	//DPL(0, "this = %x", 1, this);

	hr = this->LeaveControlSession();
	if (hr != S_OK)
	{
		DPL(0, "Closing control layer session failed!  %e", 1, hr);
	} // end if (closing control layer failed)

	if (this->m_pvTestmasterCommData != NULL)
	{
		LocalFree(this->m_pvTestmasterCommData);
		this->m_pvTestmasterCommData = NULL;
	} // end if (allocated memory)
} // CTNSlave::~CTNSlave
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::StartJoiningControlSession()"
//==================================================================================
// CTNSlave::StartJoiningControlSession
//----------------------------------------------------------------------------------
//
// Description: Starts looking for a control session to join.  This is an
//				asynchronous call, so this function returns E_PENDING if successful,
//				and the caller should wait until the hCompletionOrUpdateEvent
//				(if specified) is set, then call IsInSession() to check whether this
//				succeeded or not.
//
// Arguments:
//	PTNJOINCONTROLSESSIONDATA pTNjcsd	Parameter block.  See header file for
//										information.
//
// Returns: E_PENDING if search successfully started, or error code otherwise.
//==================================================================================
HRESULT CTNSlave::StartJoiningControlSession(PTNJOINCONTROLSESSIONDATA pTNjcsd)
{
	HRESULT						hr;
	CONTROLCOMMINITPBLOCK		ctrlcomminitparams;
	TNEXECUTORINITBYSLAVEDATA	tneibsd;
	PVOID						pvBroadcastAddress = NULL;
	DWORD						dwBroadcastAddressSize = 0;
	PVOID						pvMsg = NULL;
	DWORD						dwMsgSize = 0;
	PPERIODICSENDCONTEXT		pContext = NULL;



	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (we got passed a bad pointer)

	if (pTNjcsd == NULL)
	{
		DPL(0, "Must pass a valid structure pointer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNjcsd->dwSize != sizeof (TNJOINCONTROLSESSIONDATA))
	{
		DPL(0, "Must pass a structure of correct size (%u != %u)!",
			2, pTNjcsd->dwSize, sizeof (TNJOINCONTROLSESSIONDATA));
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNjcsd->dwAPIVersion != CURRENT_TNCONTROL_API_VERSION)
	{
		DPL(0, "WARNING: Caller requesting different API version (%u != %u), problems may occur.",
			2, pTNjcsd->dwAPIVersion, CURRENT_TNCONTROL_API_VERSION);
	} // end if (got passed an invalid parameter)

	if ((pTNjcsd->dwMode != TNMODE_API) &&
		(pTNjcsd->dwMode != TNMODE_STRESS) &&
		(pTNjcsd->dwMode != TNMODE_POKE) &&
		(pTNjcsd->dwMode != TNMODE_PICKY) &&
		(pTNjcsd->dwMode != TNMODE_DOCUMENTATION))
	{
		DPL(0, "Must pass a valid mode (%u is invalid)!", 1, pTNjcsd->dwMode);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNjcsd->hUserCancelEvent == NULL)
	{
		DPL(0, "Must pass a valid user cancel event!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNjcsd->dwControlMethodID != TN_CTRLMETHOD_TCPIP_OPTIMAL) &&
		(pTNjcsd->dwControlMethodID != TN_CTRLMETHOD_TCPIP_WINSOCK1))
	{
		DPL(0, "Must pass a control method ID (%u is invalid)!",
			1, pTNjcsd->dwControlMethodID);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNjcsd->pModuleID == NULL) ||
		(pTNjcsd->apfnLoadTestTable == NULL) ||
			(pTNjcsd->dwNumLoadTestTables < 1) ||
			(pTNjcsd->apfnLoadTestTable[0] == NULL))
	{
		DPL(0, "Must pass a valid module ID and LoadTestTable callbacks array!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNjcsd->pszMetaMasterAddress != NULL) &&
		(pTNjcsd->pszMasterAddress != NULL))
	{
		DPL(0, "Either the meta-master address or the master address can be specified, but not both!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNjcsd->pszErrToSrcFilepath != NULL)
	{
		if (((pTNjcsd->pszErrToSrcPathSearch != NULL) &&
			(pTNjcsd->pszErrToSrcPathReplace == NULL)) ||
			((pTNjcsd->pszErrToSrcPathSearch == NULL) &&
			(pTNjcsd->pszErrToSrcPathReplace != NULL)))
		{
			DPL(0, "Must specify both ErrToSrc search and replace path or neither!", 0);
			hr = ERROR_INVALID_PARAMETER;
			goto ERROR_EXIT;
		} // end if (got passed an invalid parameter)
	} // end if (errtosrc path specified)
	else
	{
		if ((pTNjcsd->pszErrToSrcPathSearch != NULL) ||
			(pTNjcsd->pszErrToSrcPathReplace != NULL))
		{
			DPL(0, "Can't specify ErrToSrc search or replace path without specifying an errtosrc filepath!", 0);
			hr = ERROR_INVALID_PARAMETER;
			goto ERROR_EXIT;
		} // end if (got passed an invalid parameter)
	} // end else (errtosrc path not specified)

	this->m_pfnLogString = pTNjcsd->pfnLogString;



	// Check to see how many other slaves are running on this machine.
	hr = this->RegisterWithOtherLocalSlaves();
	if (hr != S_OK)
	{
		DPL(0, "Failed while registering other slaves running on this machine!", 0);
		this->Log(TNLST_CRITICAL, "Failed while registering other slaves running on this machine!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't detect multiple instances)


	ZeroMemory(&tneibsd, sizeof (TNEXECUTORINITBYSLAVEDATA));
	tneibsd.pOwningSlave = this;
	tneibsd.dwMode = pTNjcsd->dwMode;
	tneibsd.pModuleID = pTNjcsd->pModuleID;
	tneibsd.pszTestNetRootPath = pTNjcsd->pszTestNetRootPath;
	tneibsd.apfnLoadTestTable = pTNjcsd->apfnLoadTestTable;
	tneibsd.dwNumLoadTestTables = pTNjcsd->dwNumLoadTestTables;
	tneibsd.pfnInitializeTesting = pTNjcsd->pfnInitializeTesting;
	tneibsd.pfnCleanupTesting = pTNjcsd->pfnCleanupTesting;
	tneibsd.pfnAddImportantBinaries = pTNjcsd->pfnAddImportantBinaries;
	tneibsd.pfnGetTestingWindow = pTNjcsd->pfnGetTestingWindow;
	tneibsd.fInitializeCOMInTestThread = pTNjcsd->fInitializeCOMInTestThread;
	tneibsd.fPromptTestThreadDieTimeout = pTNjcsd->fPromptTestThreadDieTimeout;
	tneibsd.hUserCancelEvent = pTNjcsd->hUserCancelEvent;
	tneibsd.pszErrToSrcFilepath = pTNjcsd->pszErrToSrcFilepath;
	tneibsd.pszErrToSrcPathSearch = pTNjcsd->pszErrToSrcPathSearch;
	tneibsd.pszErrToSrcPathReplace = pTNjcsd->pszErrToSrcPathReplace;
	tneibsd.pszDocFilepath = pTNjcsd->pszDocFilepath;
	tneibsd.iMultiInstanceNum = this->m_iInstanceIndex;

	hr = this->m_executor.InitializeBySlave(&tneibsd);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't initialize executor!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't initialize executor)


	if (pTNjcsd->hCompletionOrUpdateEvent != NULL)
	{
		if (! DuplicateHandle(GetCurrentProcess(), pTNjcsd->hCompletionOrUpdateEvent,
								GetCurrentProcess(), &(this->m_hCompletionOrUpdateEvent),
								0, FALSE, DUPLICATE_SAME_ACCESS))
		{
			hr = GetLastError();
			DPL(0, "Couldn't duplicate user's completion or update event handle (%x)!",
				2, pTNjcsd->hCompletionOrUpdateEvent);
			goto ERROR_EXIT;
		} // end if (couldn't duplicate handle)
	} // end if (there's an event)

	this->m_pfnDoStartup = pTNjcsd->pfnDoStartup;
	this->m_pfnChangeBinarySet = pTNjcsd->pfnChangeBinarySet;


	// If we're in documentation mode, we can skip the rest of this startup code.
	if (pTNjcsd->dwMode == TNMODE_DOCUMENTATION)
		return (E_PENDING);


	// Create the event to artificially kill the send thread.
	this->m_hKillPeriodicSendThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (this->m_hKillPeriodicSendThreadEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create kill thread event!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't create event)


	if (pTNjcsd->pszSessionFilter != NULL)
	{
		this->m_pszSessionFilter = (char*) LocalAlloc(LPTR, (strlen(pTNjcsd->pszSessionFilter) + 1));
		if (this->m_pszSessionFilter == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszSessionFilter, pTNjcsd->pszSessionFilter);
	} // end if (theres a user session ID)

	this->m_dwTimelimit = pTNjcsd->dwTimelimit;
	if (pTNjcsd->pszSavedBinsDirPath != NULL)
	{
		this->m_pszSavedBinsDirPath = (char*) LocalAlloc(LPTR, (strlen(pTNjcsd->pszSavedBinsDirPath) + 1));
		if (this->m_pszSavedBinsDirPath == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszSavedBinsDirPath, pTNjcsd->pszSavedBinsDirPath);
	} // end if (there's a saved bins path)

	this->m_pFailureBreakRules = pTNjcsd->pFailureBreakRules;

	if (pTNjcsd->pszFailureMemDumpDirPath != NULL)
	{
		this->m_pszFailureMemDumpDirPath = (char*) LocalAlloc(LPTR, (strlen(pTNjcsd->pszFailureMemDumpDirPath) + 1));
		if (this->m_pszFailureMemDumpDirPath == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszFailureMemDumpDirPath, pTNjcsd->pszFailureMemDumpDirPath);
	} // end if (there's a saved bins path)

	this->m_fGetNetStatInfoOnFailure = pTNjcsd->fGetNetStatInfoOnFailure;


#ifndef _XBOX // no DB logging supported

	// Setup TMAgent for database logging, if we're doing that.
	if (pTNjcsd->fLogToDB)
	{
		hr = this->InitializeDBLogging();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't initialize database logging!", 0);
			this->Log(TNLST_CRITICAL, "Couldn't initialize database logging!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't initialize DB logging)
	} // end if (logging to database)

#endif // ! XBOX

	ZeroMemory(&ctrlcomminitparams, sizeof (CONTROLCOMMINITPBLOCK));
	ctrlcomminitparams.dwSize = sizeof (CONTROLCOMMINITPBLOCK);
	ctrlcomminitparams.dwControlMethodID = pTNjcsd->dwControlMethodID;
	ctrlcomminitparams.pControlLayerObj = this;
	ctrlcomminitparams.fMaster = FALSE;
	ctrlcomminitparams.dwFlags = pTNjcsd->dwMethodFlags;
	ctrlcomminitparams.pvData = pTNjcsd->pvMethodData;
	ctrlcomminitparams.dwDataSize = pTNjcsd->dwMethodDataSize;

	// Initialize desired control method
	switch (pTNjcsd->dwControlMethodID)
	{
		case TN_CTRLMETHOD_TCPIP_OPTIMAL:
			hr = CtrlCommTCPLoadOptimal(&ctrlcomminitparams, &(this->m_pCtrlComm));
			if (hr != S_OK)
			{
				DPL(0, "Initializing TCP/IP optimal control method failed!", 0);
				goto ERROR_EXIT;
			} // end if (initting TCP/IP optimal control method failed)
		  break;
		case TN_CTRLMETHOD_TCPIP_WINSOCK1:
			hr = CtrlCommTCPLoadWinSock1(&ctrlcomminitparams, &(this->m_pCtrlComm));
			if (hr != S_OK)
			{
				DPL(0, "Initializing TCP/IP WinSock1 control method failed!", 0);
				goto ERROR_EXIT;
			} // end if (initting TCP/IP WinSock1 control method failed)
		  break;
	} // end switch (on control method ID)



	// Initialize control communication method
	hr = this->m_pCtrlComm->Initialize();
	if (hr != S_OK)
	{
		DPL(0, "Initializing control communications method failed!", 0);
		goto ERROR_EXIT;
	} // end if (initting ctrl comm failed)


	if (pTNjcsd->pszMetaMasterAddress != NULL)
	{
		PCTRLMSG_QUERYMETAMASTER	pQueryMetaMasterMsg;


		// Ignore error, assume BUFFER_TOO_SMALL
		this->m_pCtrlComm->ConvertStringToAddress(pTNjcsd->pszMetaMasterAddress,
													NULL,
													0,
													NULL,
													&(this->m_dwMetaMasterAddressSize));
		this->m_pvMetaMasterAddress = LocalAlloc(LPTR, this->m_dwMetaMasterAddressSize);
		if (this->m_pvMetaMasterAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		hr = this->m_pCtrlComm->ConvertStringToAddress(pTNjcsd->pszMetaMasterAddress,
														NULL,
														0,
														this->m_pvMetaMasterAddress,
														&(this->m_dwMetaMasterAddressSize));
		if (hr != S_OK)
		{
			DPL(0, "Converting \"%s\" into meta-master address failed!",
				1, pTNjcsd->pszMetaMasterAddress);
			goto ERROR_EXIT;
		} // end if (initting ctrl comm failed)


		dwMsgSize = sizeof (CTRLMSG_QUERYMETAMASTER);
		if (this->m_pszSessionFilter != NULL)
			dwMsgSize += strlen(this->m_pszSessionFilter) + 1;
		else
			dwMsgSize++; // just NULL terminator (for empty string)

		pvMsg = LocalAlloc(LPTR, dwMsgSize);
		if (pvMsg == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		pQueryMetaMasterMsg = (PCTRLMSG_QUERYMETAMASTER) pvMsg;

		pQueryMetaMasterMsg->dwSize = dwMsgSize;
		pQueryMetaMasterMsg->dwType = CTRLMSGID_QUERYMETAMASTER;
		pQueryMetaMasterMsg->dwMetaVersion = CURRENT_METAMASTER_API_VERSION;
		pQueryMetaMasterMsg->dwControlVersion = CURRENT_TNCONTROL_API_VERSION;
		CopyMemory(&(pQueryMetaMasterMsg->moduleID), &(this->m_executor.m_moduleID),
					sizeof (TNMODULEID));
		pQueryMetaMasterMsg->dwMode = this->m_executor.m_dwMode;

		if (this->m_pszSessionFilter != NULL)
			strcpy((char*) (pQueryMetaMasterMsg + 1), this->m_pszSessionFilter);
		else
			(*((char*) (pQueryMetaMasterMsg + 1))) = '\0'; // empty string


		pContext = (PPERIODICSENDCONTEXT) LocalAlloc(LPTR, sizeof (QUERYMETAMASTERCONTEXT));
		if (pContext == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		((PQUERYMETAMASTERCONTEXT) pContext)->dwType = PSCT_QUERYMETAMASTER;


		// Note that we're querying the meta-master right now.
		this->m_fQueryingMetaMaster = TRUE;


		// Start trying to connect to the meta-master.
		hr = this->StartPeriodicSend(this->m_pCtrlComm,
									TRUE,
									this->m_pvMetaMasterAddress,
									this->m_dwMetaMasterAddressSize,
									pvMsg,
									dwMsgSize,
									0,
									CONTROL_QUERYMETAMASTER_TIMEOUT,
									pContext,
									&(this->m_pSessionPeriodicSend));

		LocalFree(pvMsg);
		pvMsg = NULL;
	} // end if (a meta master was specified)
	else if (pTNjcsd->pszMasterAddress != NULL)
	{
		PCTRLMSG_HANDSHAKE	pHandshakeMsg;


		// Ignore error, assume BUFFER_TOO_SMALL
		this->m_pCtrlComm->ConvertStringToAddress(pTNjcsd->pszMasterAddress,
													NULL,
													0,
													NULL,
													&(((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize));
		((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress = LocalAlloc(LPTR, ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize);
		if (((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		hr = this->m_pCtrlComm->ConvertStringToAddress(pTNjcsd->pszMasterAddress,
														NULL,
														0,
														((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
														&(((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize));
		if (hr != S_OK)
		{
			DPL(0, "Converting \"%s\" into master address failed!",
				1, pTNjcsd->pszMasterAddress);
			goto ERROR_EXIT;
		} // end if (initting ctrl comm failed)


		dwMsgSize = sizeof (CTRLMSG_HANDSHAKE);
		if (this->m_pszSessionFilter != NULL)
			dwMsgSize += strlen(this->m_pszSessionFilter) + 1;
		else
			dwMsgSize++; // just NULL terminator (for empty string)

		pvMsg = LocalAlloc(LPTR, dwMsgSize);
		if (pvMsg == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		pHandshakeMsg = (PCTRLMSG_HANDSHAKE) pvMsg;

		pHandshakeMsg->dwSize = dwMsgSize;
		pHandshakeMsg->dwType = CTRLMSGID_HANDSHAKE;
		pHandshakeMsg->dwVersion = CURRENT_TNCONTROL_API_VERSION;
		CopyMemory(&(pHandshakeMsg->moduleID), &(this->m_executor.m_moduleID),
					sizeof (TNMODULEID));
		pHandshakeMsg->dwMode = this->m_executor.m_dwMode;

		if (this->m_pszSessionFilter != NULL)
			strcpy((char*) (pHandshakeMsg + 1), this->m_pszSessionFilter);
		else
			(*((char*) (pHandshakeMsg + 1))) = '\0'; // empty string


		pContext = (PPERIODICSENDCONTEXT) LocalAlloc(LPTR, sizeof (JOINDIRECTCONTEXT));
		if (pContext == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		((PJOINDIRECTCONTEXT) pContext)->dwType = PSCT_JOINDIRECT;


		// Note that we're trying to connect.
		this->m_fShakingHands = TRUE;
			

		// Start trying to directly connect to the session.
		hr = this->StartPeriodicSend(this->m_pCtrlComm,
									TRUE,
									((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
									((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize,
									pvMsg,
									dwMsgSize,
									0,
									CONTROL_DIRECTJOIN_TIMEOUT,
									pContext,
									&(this->m_pSessionPeriodicSend));

		LocalFree(pvMsg);
		pvMsg = NULL;
	} // end else if (a specific master was specified)
	else
	{
		PCTRLMSG_ENUM	pEnumMsg;


		// Ignore error, assume BUFFER_TOO_SMALL
		this->m_pCtrlComm->GetBroadcastAddress(NULL,
												0, 
												NULL,
												&dwBroadcastAddressSize);

		pvBroadcastAddress = LocalAlloc(LPTR, dwBroadcastAddressSize);
		if (pvBroadcastAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		hr = this->m_pCtrlComm->GetBroadcastAddress(NULL,
													0,
													pvBroadcastAddress,
													&dwBroadcastAddressSize);
		if (hr != S_OK)
		{
			DPL(0, "Getting broadcast address failed!", 0);
			goto ERROR_EXIT;
		} // end if (initting ctrl comm failed)

		dwMsgSize = sizeof (CTRLMSG_ENUM);
		if (this->m_pszSessionFilter != NULL)
			dwMsgSize += strlen(this->m_pszSessionFilter) + 1;
		else
			dwMsgSize++; // just NULL terminator (for empty string)

		pvMsg = LocalAlloc(LPTR, dwMsgSize);
		if (pvMsg == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		pEnumMsg = (PCTRLMSG_ENUM) pvMsg;

		pEnumMsg->dwSize = dwMsgSize;
		pEnumMsg->dwType = CTRLMSGID_ENUM;
		pEnumMsg->dwVersion = CURRENT_TNCONTROL_API_VERSION;
		CopyMemory(&(pEnumMsg->moduleID), &(this->m_executor.m_moduleID),
					sizeof (TNMODULEID));
		pEnumMsg->dwMode = this->m_executor.m_dwMode;

		if (this->m_pszSessionFilter != NULL)
			strcpy((char*) (pEnumMsg + 1), this->m_pszSessionFilter);
		else
			(*((char*) (pEnumMsg + 1))) = '\0'; // empty string
		

		pContext = (PPERIODICSENDCONTEXT) LocalAlloc(LPTR, sizeof (ENUMCONTEXT));
		if (pContext == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		((PENUMCONTEXT) pContext)->dwType = PSCT_ENUM;


		// Note that we should handle EnumReplies now.
		this->m_fReadyToConnect = TRUE;


		// Start enuming sessions via broadcast.
		hr = this->StartPeriodicSend(this->m_pCtrlComm,
									FALSE,
									pvBroadcastAddress,
									dwBroadcastAddressSize,
									pvMsg,
									dwMsgSize,
									CONTROL_ENUM_INTERVAL,
									CONTROL_ENUM_TIMEOUT,
									pContext,
									&(this->m_pSessionPeriodicSend));

		LocalFree(pvMsg);
		pvMsg = NULL;

		LocalFree(pvBroadcastAddress);
		pvBroadcastAddress = NULL;
	} // end if (there isn't any special join data)

	if (hr != S_OK)
	{
		DPL(0, "Starting to enum sessions/join failed!", 0);
		goto ERROR_EXIT;
	} // end if (starting to enum sessions/join failed)

	
	return (E_PENDING);


ERROR_EXIT:

#pragma BUGBUG(vanceo, "Cleanup, return to original state")

	if (this->m_pSessionPeriodicSend != NULL)
	{
		hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
		if (hr != S_OK)
		{
			DPL(0, "Stopping periodic send %x failed!  %e",
				2, this->m_pSessionPeriodicSend, hr);
		} // end if (there's an active send)

		this->m_pSessionPeriodicSend->m_dwRefCount--;
		if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting session periodic send %x.",
				1, this->m_pSessionPeriodicSend);
			delete (this->m_pSessionPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
				2, this->m_pSessionPeriodicSend,
				this->m_pSessionPeriodicSend->m_dwRefCount);
		} // end else (not last reference)
		this->m_pSessionPeriodicSend = NULL;
	} // end if (have active send)

	if (pContext != NULL)
	{
		LocalFree(pContext);
		pContext = NULL;
	} // end if (have context)

	if (pvMsg != NULL)
	{
		LocalFree(pvMsg);
		pvMsg = NULL;
	} // end if (allocated memory)

	if (pvBroadcastAddress != NULL)
	{
		LocalFree(pvBroadcastAddress);
		pvBroadcastAddress = NULL;
	} // end if (allocated memory)

	return (hr);
} // CTNSlave::StartJoiningControlSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::LeaveControlSession()"
//==================================================================================
// CTNSlave::LeaveControlSession
//----------------------------------------------------------------------------------
//
// Description: Leaves the control session if in one, stops the enumeration and
//				test threads if running, and releases the ctrl comm object if it
//				existed.
//				Note that errors will probably be masked.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::LeaveControlSession(void)
{
	HRESULT		hr = S_OK;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we got passed a bad pointer)


	DPL(9, "==>", 0);


	if (this->m_pSessionPeriodicSend != NULL)
	{
		hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
		if (hr != S_OK)
		{
			DPL(0, "Stopping periodic send %x failed!  %e",
				2, this->m_pSessionPeriodicSend, hr);
		} // end if (there's an active send)

		this->m_pSessionPeriodicSend->m_dwRefCount--;
		if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting session periodic send %x.",
				1, this->m_pSessionPeriodicSend);
			delete (this->m_pSessionPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
				2, this->m_pSessionPeriodicSend,
				this->m_pSessionPeriodicSend->m_dwRefCount);
		} // end else (not last reference)
		this->m_pSessionPeriodicSend = NULL;
	} // end if (have active send)


	this->m_fInSession = FALSE;
	this->m_fTestingComplete = FALSE;

	hr = this->KillPeriodicSendThread(FALSE);
	if (hr != S_OK)
	{
		DPL(0, "Stopping periodic send thread failed!  %e", 1, hr);
	} // end if (stopping thread failed)

	hr = this->m_executor.Cleanup();
	if (hr != S_OK)
	{
		DPL(0, "Cleaning up executor failed!  %e", 1, hr);
	} // end if (killing test thread failed)

	if (this->m_pCtrlComm != NULL)
	{
		this->m_pCtrlComm->m_dwRefCount--;
		if (this->m_pCtrlComm->m_dwRefCount == 0)
		{
			DPL(7, "Releasing and deleting control comm object %x.",
				1, this->m_pCtrlComm);

			hr = this->m_pCtrlComm->Release();
			if (hr != S_OK)
			{
				DPL(0, "Releasing control communication method failed!  %e", 1, hr);
			} // end if (releasing control method failed)

			delete (this->m_pCtrlComm);
		} // end if (last reference)
		else
		{
			DPL(0, "WARNING: Not releasing and deleting control comm object %x, its refcount is %u!",
				2, this->m_pCtrlComm, this->m_pCtrlComm->m_dwRefCount);
		} // end else (not last reference)

		this->m_pCtrlComm = NULL;
	} // end if (we're still validly connected to the control method)


	// Reset the members, just like in the constructor

	if (this->m_pszSessionFilter != NULL)
	{
		LocalFree(this->m_pszSessionFilter);
		this->m_pszSessionFilter = NULL;
	} // end if (session ID exists)

	this->m_pszSessionFilter = NULL;
	this->m_pFailureBreakRules = NULL;

	if (this->m_pszFailureMemDumpDirPath != NULL)
	{
		LocalFree(this->m_pszFailureMemDumpDirPath);
		this->m_pszFailureMemDumpDirPath = NULL;
	} // end if (dump dir path exists)

	this->m_fReadyToConnect = FALSE;
	this->m_fQueryingMetaMaster = FALSE;
	this->m_fShakingHands = FALSE;
	this->m_fInSession = FALSE;
	this->m_dwLastMasterReceive = 0;
	this->m_pfnDoStartup = NULL;
	this->m_pfnChangeBinarySet = NULL;

	if (this->m_pvMetaMasterAddress != NULL)
	{
		LocalFree(this->m_pvMetaMasterAddress);
		this->m_pvMetaMasterAddress = NULL;
	} // end if (meta master address exists)

	// BUGBUG The control object technically owns this item
	if (((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress != NULL)
	{
		LocalFree(((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress);
		((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress = NULL;
	} // end if (we have a control comm address)

	if (this->m_pszSavedBinsDirPath != NULL)
	{
		LocalFree(this->m_pszSavedBinsDirPath);
		this->m_pszSavedBinsDirPath = NULL;
	} // end if (saved bins dir exists)

	if (this->m_pBinMgr != NULL)
	{
		delete (this->m_pBinMgr);
		this->m_pBinMgr = NULL;
	} // end if (bin manager exists)

	if (this->m_hCompletionOrUpdateEvent != NULL)
	{
		CloseHandle(this->m_hCompletionOrUpdateEvent);
		this->m_hCompletionOrUpdateEvent = NULL;
	} // end if (have event)


	// Remove all info objects for other machines.
	hr = this->m_otherinfos.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove all info objects for other machines!  %e",
			1, hr);
	} // end if (couldn't remove all info objects)


	// Clean up info shared with other slaves that are running on this machine.
	hr = this->UnregisterWithOtherLocalSlaves();
	if (hr != S_OK)
	{
		DPL(0, "Failed while unregistering other slaves running on this machine!  %e",
			1, hr);
	} // end if (couldn't unregister multi-instance detection)

#ifndef _XBOX // no database logging supported

	// Shutdown database logging.
	if (this->m_lpTMAgent != NULL)
	{
		// Ignoring error
		this->m_lpTMAgent->EndTest();
		this->m_lpTMAgent->Uninitialize();
		this->m_lpTMAgent->Release();
		this->m_lpTMAgent = NULL;

		DPL(8, "Uninitializing COM.", 0);
		CoUninitialize();
	} // end if (we were logging to a database)

#endif // ! XBOX

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNSlave::LeaveControlSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::IsInSession()"
//==================================================================================
// CTNSlave::IsInSession
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this object is in a control session, FALSE if not.
//
// Arguments: None.
//
// Returns: TRUE if in session, FALSE otherwise.
//==================================================================================
BOOL CTNSlave::IsInSession(void)
{
	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (FALSE);
	} // end if (slave object is invalid)

	return (this->m_fInSession);
} // CTNSlave::IsInSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetSessionID()"
//==================================================================================
// CTNSlave::GetSessionID
//----------------------------------------------------------------------------------
//
// Description: Returns the identifier of the current session.
//
// Arguments: None.
//
// Returns: ID of current session.
//==================================================================================
DWORD CTNSlave::GetSessionID(void)
{
	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (0);
	} // end if (slave object is invalid)

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session yet, can't determine session ID!", 0);
		return (0);
	} // end if (not in a session)
	
	return (this->m_dwSessionID);
} // CTNSlave::GetSessionID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::IsTestingComplete()"
//==================================================================================
// CTNSlave::IsTestingComplete
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if all tests intended to be run have actually been.
//
// Arguments: None.
//
// Returns: TRUE if all tests are run, FALSE otherwise.
//==================================================================================
BOOL CTNSlave::IsTestingComplete(void)
{
	return (this->m_fTestingComplete);
} // CTNSlave::IsTestingComplete
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetModuleString()"
//==================================================================================
// CTNSlave::GetModuleString
//----------------------------------------------------------------------------------
//
// Description: Returns a string describing the currently loaded module.
//
// Arguments:
//	char* szString	String buffer to copy results in.  Should be able to hold 64
//					characters.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetModuleString(char* szString)
{
#ifdef _XBOX // Damn ANSI conversion
	WCHAR	szWideString[256];
#endif // ! XBOX

	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)

	// Prevent the user from retrieving the module string before we're fully in the
	// session, unless we're in documentation mode.
	if ((! this->m_fInSession) && (this->m_executor.m_dwMode != TNMODE_DOCUMENTATION))
	{
		DPL(0, "Not in session yet, can't determine module ID!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (not in a session)
	
#ifndef _XBOX // Damn ANSI conversion
	wsprintf(szString, "%s v%02u.%02u.%02u.%04u", this->m_executor.m_moduleID.szBriefName,
			this->m_executor.m_moduleID.dwMajorVersion,
			this->m_executor.m_moduleID.dwMinorVersion1,
			this->m_executor.m_moduleID.dwMinorVersion2,
			this->m_executor.m_moduleID.dwBuildVersion);
#else // ! XBOX
	ZeroMemory(szWideString, sizeof(WCHAR) * 256);
	swprintf(szWideString, L"%hs v%02u.%02u.%02u.%04u", this->m_executor.m_moduleID.szBriefName,
			this->m_executor.m_moduleID.dwMajorVersion,
			this->m_executor.m_moduleID.dwMinorVersion1,
			this->m_executor.m_moduleID.dwMinorVersion2,
			this->m_executor.m_moduleID.dwBuildVersion);
	wcstombs(szString, szWideString, wcslen(szWideString));
	szString[wcslen(szWideString)] = 0;
#endif // XBOX
	
	return (S_OK);
} // CTNSlave::GetModuleString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTotalStats()"
//==================================================================================
// CTNSlave::GetTotalStats
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the total test table stats object.
//
// Arguments: None.
//
// Returns: Pointer to stats object, or NULL if an error occurred.
//==================================================================================
PTNTESTSTATS CTNSlave::GetTotalStats(void)
{
	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (NULL);
	} // end if (slave object is invalid)

	return (&(this->m_totalstats));
} // CTNSlave::GetTotalStats
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetNumberOfCases()"
//==================================================================================
// CTNSlave::GetNumberOfCases
//----------------------------------------------------------------------------------
//
// Description: Returns the number of test cases loaded.
//
// Arguments: None.
//
// Returns: The number of test cases loaded, or -1 if an error occurred.
//==================================================================================
int CTNSlave::GetNumberOfCases(void)
{
	HRESULT		hr;
	int			iNumCases = 0;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (-1);
	} // end if (slave object is invalid)

	hr = this->m_executor.m_testtable.GetNumberOfCases(&iNumCases);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get number of cases!  %e", 1, hr);
		return (-1);
	} // end if (couldn't get number of cases in the testtable)

	return (iNumCases);
} // CTNSlave::GetNumberOfCases
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetCaseIndex()"
//==================================================================================
// CTNSlave::GetCaseIndex
//----------------------------------------------------------------------------------
//
// Description: Returns pointers to the ID, name, and stats for the case at the
//				given index.  If NULL is passed in for an argument, then that
//				item is not returned.
//
// Arguments:
//	int iIndex				Zero based index of case to retrieve.
//	char** ppszID,			Pointer to place to store pointer to the case ID string,
//							or NULL if not wanted.
//	char** ppszName			Pointer to place to store pointer to the case name
//							string, or NULL if not wanted.
//	PTNTESTSTATS* ppStats	Pointer to place to store pointer to the case stats, or
//							NULL if not wanted.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetCaseIndex(int iIndex, char** ppszID, char** ppszName,
								PTNTESTSTATS* ppStats)
{
	HRESULT				hr;
	int					iNumItemsLeft = iIndex;
	PTNTESTTABLECASE	pItem = NULL;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)

	hr = this->m_executor.m_testtable.GetCaseIndex(&iNumItemsLeft, &pItem);
	if (hr != S_OK)
	{
		DPL(0, "Failed getting case index %i!", 1, iIndex);
		return (hr);
	} // end if (couldn't get that item)

	if (pItem == NULL)
	{
		DPL(0, "Couldn't find case index %i!", 1, iIndex);
		return (ERROR_INVALID_PARAMETER);
	} // end if (couldn't get that item)


	// Otherwise, we found it so return what we need to.

	if (ppszID != NULL)
		(*ppszID) = pItem->m_pszID;

	if (ppszName != NULL)
		(*ppszName) = pItem->m_pszName;

	if (ppStats != NULL)
		(*ppStats) = &(pItem->m_stats);

	return (S_OK);
} // CTNSlave::GetCaseIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetMachineInfo()"
//==================================================================================
// CTNSlave::GetMachineInfo
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the local machine information, or NULL if an
//				error occurred.
//
// Arguments: None.
//
// Returns: Pointer to info.
//==================================================================================
PTNMACHINEINFO CTNSlave::GetMachineInfo(void)
{
	if (this == NULL)
	{
		DPL(0, "Pointer to object is NULL!", 0);
		return (NULL);
	} // end if (invalid slave object)

	// Prevent the user from retrieving machine information before we're fully in
	// the session, unless we're in documentation mode.
	if ((! this->m_fInSession) && (this->m_executor.m_dwMode != TNMODE_DOCUMENTATION))
	{
		DPL(0, "Not in session yet, can't retrieve accurate machine information!", 0);
		return (NULL);
	} // end if (not in session yet)

	return (&(this->m_executor.m_info));
} // CTNSlave::GetMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::PrintTestTableToFile()"
//==================================================================================
// CTNSlave::PrintTestTableToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the table of all tests loaded to the specified file path.
//
// Arguments:
//	char* szFilepath	Filepath to print to.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::PrintTestTableToFile(char* szFilepath)
{
#ifndef _XBOX // no files
	HRESULT		hr;
	HANDLE		hFile = INVALID_HANDLE_VALUE;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)

	hr = FileCreateAndOpenFile(szFilepath, FALSE, FALSE, FALSE, &hFile);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't open file \"%s\"!", 1, szFilepath);
		goto DONE;
	} // end if (couldn't open file)

	this->Log(TNLST_CONTROLLAYER_INFO, "Printing test table to file %s",
			1, szFilepath);

	// Ignoring error
	FileWriteLine(hFile, "ID\tName");
	FileWriteLine(hFile, "--\t----");

	hr = this->m_executor.m_testtable.PrintToFile(hFile, TNTTPO_BUILTIN | TNTTPO_GROUPS);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't print test table to file \"%s\"!", 1, szFilepath);
	} // end if (couldn't open file)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opened file)

	return (hr);
#else // ! XBOX
	return S_OK;
#endif // XBOX

} // CTNSlave::PrintTestTableToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::PrintResultsToFile()"
//==================================================================================
// CTNSlave::PrintResultsToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the current success/failure results for all tests loaded to
//				the specified file.
//
// Arguments:
//	char* szFilepath	Filepath to print to.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::PrintResultsToFile(char* szFilepath)
{
#ifndef _XBOX // no files
	HRESULT		hr;
	HANDLE		hFile = INVALID_HANDLE_VALUE;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)


	hr = FileCreateAndOpenFile(szFilepath, FALSE, FALSE, FALSE, &hFile);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't open file \"%s\"!", 1, szFilepath);
		goto DONE;
	} // end if (couldn't open file)

	this->Log(TNLST_CONTROLLAYER_INFO, "Printing test results to file %s",
			1, szFilepath);

	// Ignoring error
	FileWriteLine(hFile, " ID \t Name \t Successes \t Failures \t Total Run \t Warnings ");
	FileWriteLine(hFile, "----\t------\t-----------\t----------\t-----------\t----------");

	hr = this->m_executor.m_testtable.PrintToFile(hFile, TNTTPO_SUCCESSES | TNTTPO_FAILURES | TNTTPO_TOTAL | TNTTPO_WARNINGS);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't print test results to file \"%s\"!", 1, szFilepath);
	} // end if (couldn't open file)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opened file)

	return (hr);
#else // ! XBOX
	return S_OK;
#endif // XBOX
} // CTNSlave::PrintResultsToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::UserQuery()"
//==================================================================================
// CTNSlave::UserQuery
//----------------------------------------------------------------------------------
//
//BUGBUG sync or async?
// Description: Issues a query to the testmaster with the given query ID and
//				data passed in.  The pointers to values will be set to the master's
//				response.
//				The extra response data buffer is allocated here, so it is up to
//				the caller to free it when done.
//
// Arguments:
//	DWORD dwQuery			User defined ID of the query command or type.
//	PVOID pvQueryData		Pointer to data to send with the query.
//	DWORD dwQueryDataSize	Size of the data buffer to send with the query command.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::UserQuery(DWORD dwQuery, PVOID pvQueryData, DWORD dwQueryDataSize)
{
	HRESULT					hr = S_OK;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_USERQUERY		pUserQueryMsg = NULL;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (slave object is invalid)

	if (! this->m_fInSession)
	{
		DPL(0, "Not sending a user request because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_USERQUERY)
							+ dwQueryDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pUserQueryMsg = (PCTRLMSG_USERQUERY) pSendData->m_pvData;
	pUserQueryMsg->dwSize = pSendData->m_dwDataSize;
	pUserQueryMsg->dwType = CTRLMSGID_USERQUERY;

	pUserQueryMsg->dwQuery = dwQuery;
	pUserQueryMsg->dwDataSize = dwQueryDataSize;
	if (pvQueryData != NULL)
		CopyMemory((pUserQueryMsg + 1), pvQueryData, dwQueryDataSize);

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNSlave::UserQuery
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::ExecPokeTest()"
//==================================================================================
// CTNSlave::ExecPokeTest
//----------------------------------------------------------------------------------
//
// Description: Initiates asynchronous execution of the specified test case with the
//				given input data.
//
// Arguments:
//	char* szCaseID									Case to execute.
//	PVOID pvInputData								Pointer to input data for case.
//	DWORD dwInputDataSize							Size of input data buffer for case.
//	PTNPOKETESTCOMPLETEDPROC pfnPokeTestCompleted	Optional function to call when
//													test completes.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::ExecPokeTest(char* szCaseID, PVOID pvInputData, DWORD dwInputDataSize,
								PTNPOKETESTCOMPLETEDPROC pfnPokeTestCompleted,
								PVOID pvUserContext)
{
	HRESULT						hr;
	PTNTESTTABLECASE			pCase = NULL;
	PTNTESTINSTANCES			pTest = NULL;
	int							iNumMachines = 1;
	TNCTRLMACHINEID				aTesterArray[1];
	PTNSENDDATA					pSendData = NULL;
	DWORD						dwModuleIDSize;
	PCTRLMSG_REQUESTPOKETEST	pRequestPokeTestMsg = NULL;
	LPBYTE						lpCurrent = NULL;


	if (! this->m_fInSession)
	{
		DPL(0, "Can't execute poke test (case ID \"%s\") because not in a session!",
			1, szCaseID);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not in a session)

	if (this->m_executor.m_dwMode != TNMODE_POKE)
	{
		DPL(0, "Can't execute poke test (case ID \"%s\") because not in a poke mode session (it's type %u)!",
			2, szCaseID, this->m_executor.m_dwMode);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not in a session)

	pCase = this->m_executor.m_testtable.GetTest(szCaseID);
	if (pCase == NULL)
	{
		DPL(0, "Can't find test with case ID \"%s\"!", 1, szCaseID);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (couldn't find case ID)

	if (! (pCase->m_dwOptionFlags & TNTCO_POKE))
	{
		DPL(0, "Test case \"%s\" didn't specify it could be run in poke mode!",
			1, szCaseID);
		hr = E_FAIL;
		goto DONE;
	} // end if (not a poke mode capable test)


#pragma BUGBUG(vanceo, "Implement something for multiple testers")
	CopyMemory(&(aTesterArray[0]), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));


	pTest = new (CTNTestInstanceS)(0xFFFFFFFF,
								pCase,
								NULL,
								iNumMachines,
								aTesterArray,
								//0,
								NULL);
	if (pTest == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pTest->m_dwRefCount++; // we're using it

	pTest->m_iNumMachines = iNumMachines;

	pTest->SetInputData(pvInputData, dwInputDataSize);
	pTest->m_dwRequestID = this->m_dwCurrentUniqueID++;
	pTest->m_pfnPokeTestCompleted = pfnPokeTestCompleted;
	pTest->m_pvUserContext = pvUserContext;


	// Add it to the queue so when we get an ID for it, it can be run.
	hr = this->m_executor.m_queuedtests.Add(pTest);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add new test %x to list!", 1, pTest);
		goto DONE;
	} // end if (couldn't add test to list)




	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	dwModuleIDSize = strlen(szCaseID) + 1;

	pSendData->m_dwDataSize = sizeof (CTRLMSG_REQUESTPOKETEST)
							+ dwModuleIDSize
							+ (iNumMachines * sizeof (TNCTRLMACHINEID))
							+ dwInputDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pRequestPokeTestMsg = (PCTRLMSG_REQUESTPOKETEST) pSendData->m_pvData;
	pRequestPokeTestMsg->dwSize = pSendData->m_dwDataSize;
	pRequestPokeTestMsg->dwType = CTRLMSGID_REQUESTPOKETEST;

	CopyMemory(&(pRequestPokeTestMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pRequestPokeTestMsg->dwRequestID = pTest->m_dwRequestID;
	pRequestPokeTestMsg->iNumMachines = iNumMachines;
	pRequestPokeTestMsg->dwInputDataSize = dwInputDataSize;

	lpCurrent = (LPBYTE) (pRequestPokeTestMsg + 1);
	CopyAndMoveDestPointer(lpCurrent, szCaseID, dwModuleIDSize);
	CopyAndMoveDestPointer(lpCurrent, aTesterArray, (iNumMachines * (sizeof (TNCTRLMACHINEID))));

	if (dwInputDataSize > 0)
	{
		//CopyAndMoveDestPointer(lpCurrent, pvInputData, dwInputDataSize);
		CopyMemory(lpCurrent, pvInputData, dwInputDataSize);
	} // end if (there's input data)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below



DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have send object)

	if (pTest != NULL)
	{
		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting test %x.", 1, pTest);
			delete (pTest);
		} // end if (we were the last ones to use the test)
		else
		{
			DPL(7, "Not deleting test %x.", 1, pTest);
		} // end else (we weren't the last ones to use the test)
		pTest = NULL;
	} // end if (have test)

	return (hr);
} // CTNSlave::ExecPokeTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // no swapping supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::TakeSnapshot()"
//==================================================================================
// CTNSlave::TakeSnapshot
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::TakeSnapshot(void)
{
	HRESULT		hr;


	if (this->m_pBinMgr != NULL)
	{
		DPL(0, "Binary manager already in use!  Can't use again until previous test is complete!", 0);
		return (E_FAIL);
	} // end if (binary manager already in use)

	this->m_pBinMgr = new (CTNBinaryManager);
	if (this->m_pBinMgr == NULL)
	{
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate object)

	hr = this->m_pBinMgr->SaveSnapshot(&(this->m_executor.m_info.m_binaries),
										this->m_pszSavedBinsDirPath);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't save snapshot of binaries!", 0);
		return (hr);
	} // end if (couldn't allocate object)

	return (S_OK);
} // CTNSlave::TakeSnapshot
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // no swapping supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::RestoreSnapshot()"
//==================================================================================
// CTNSlave::RestoreSnapshot
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::RestoreSnapshot(void)
{
	HRESULT		hr;


	if (this->m_pBinMgr == NULL)
	{
		DPL(0, "Binary manager not in use!  Can't restore snapshot!", 0);
		return (E_FAIL);
	} // end if (binary manager already in use)

	hr = this->m_pBinMgr->RestoreSnapshot();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't restore snapshot of binaries!", 0);
		return (hr);
	} // end if (couldn't allocate object)

	delete (this->m_pBinMgr);
	this->m_pBinMgr = NULL;

	return (S_OK);
} // CTNSlave::RestoreSnapshot
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleEnumReplyMsg()"
//==================================================================================
// CTNSlave::HandleEnumReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session enum reply message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_ENUMREPLY pEnumReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleEnumReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_ENUMREPLY pEnumReplyMsg)
{
	HRESULT					hr = S_OK;
	PTNSENDDATA				pSendData = NULL;
	DWORD					dwSessionUserIDSize = 0;
	PCTRLMSG_HANDSHAKE		pHandshakeMsg = NULL;


	//DPL(1, "Got EnumReply message.", 0);

	if (! this->m_fReadyToConnect)
	{
		DPL(0, "Not listening for EnumReplies, ignoring.", 0);
		goto DONE;
	} // end if (we're not listening for these messages)

	if (this->m_fShakingHands)
	{
		DPL(0, "Got EnumReply even though we're in the process of handshaking.  Ignoring.", 0);
		goto DONE;
	} // end if (we're handshaking already)

	if (this->m_fInSession)
	{
		DPL(0, "Got EnumReply even though already in session.  Ignoring.", 0);
		goto DONE;
	} // end if (we're in a session already)

	// BUGBUG compare lpEnumReplyMsg->moduleID or something similar


	if (this->m_pSessionPeriodicSend == NULL)
	{
		DPL(0, "WARNING: Already stopped periodic send, assuming already trying to join but ran into non-thread-safe issue with boolean checks above.  Ignoring.", 0);
		goto DONE;
	} // end if (stopped session already)

	// Since this appears to be a valid enum reply message, we're going
	// to stop enumerating sessions and assume we'll connect.
	hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
	if (hr != S_OK)
	{
		DPL(0, "Stopping periodic send %x failed!  %e",
			2, this->m_pSessionPeriodicSend, hr);
	} // end if (there's an active send)

	this->m_pSessionPeriodicSend->m_dwRefCount--;
	if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
	{
		DPL(7, "Deleting session periodic send %x.",
			1, this->m_pSessionPeriodicSend);
		delete (this->m_pSessionPeriodicSend);
	} // end if (last reference)
	else
	{
		DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
			2, this->m_pSessionPeriodicSend,
			this->m_pSessionPeriodicSend->m_dwRefCount);
	} // end else (not last reference)
	this->m_pSessionPeriodicSend = NULL;

	this->m_fShakingHands = TRUE;


	dwSessionUserIDSize = 1; // empty string
	if (this->m_pszSessionFilter != NULL)
		dwSessionUserIDSize += strlen(this->m_pszSessionFilter);


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_HANDSHAKE)
							+ dwSessionUserIDSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pHandshakeMsg = (PCTRLMSG_HANDSHAKE) pSendData->m_pvData;
	pHandshakeMsg->dwSize = pSendData->m_dwDataSize;
	pHandshakeMsg->dwType = CTRLMSGID_HANDSHAKE;
	pHandshakeMsg->dwVersion = CURRENT_TNCONTROL_API_VERSION;
	CopyMemory(&(pHandshakeMsg->moduleID), &(this->m_executor.m_moduleID),
				sizeof (TNMODULEID));
	pHandshakeMsg->dwMode = this->m_executor.m_dwMode;


	if (this->m_pszSessionFilter != NULL)
		strcpy((char*) (pHandshakeMsg + 1), this->m_pszSessionFilter);
	else
		(*((char*) (pHandshakeMsg + 1))) = '\0'; // empty string


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSlave::HandleEnumReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleHandshakeReplyMsg()"
//==================================================================================
// CTNSlave::HandleHandshakeReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session handshake reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_HANDSHAKEREPLY pHandshakeReplyMsg		The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleHandshakeReplyMsg(PVOID* ppvFromAddress,
											DWORD dwFromAddressSize,
											PCTRLMSG_HANDSHAKEREPLY pHandshakeReplyMsg)
{
	HRESULT				hr = S_OK;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_JOIN		pJoinMsg = NULL;
	DWORD				dwInfoBufferSize = 0;
	PVOID				pvMasterIPAddr = NULL;
	DWORD				dwMasterIPAddrSize = 0;
	BOOL				fStopJoining = FALSE;


	//DPL(1, "Got HandshakeReply message.", 0);

	if (! this->m_fShakingHands)
	{
		DPL(0, "Not listening for HandshakeReplies, ignoring.", 0);
		goto DONE;
	} // end if (we're not listening for these messages)

	if (this->m_fInSession)
	{
		DPL(0, "Got HandshakeReply even though already in session.  Ignoring.", 0);
		goto DONE;
	} // end if (we're in a session already)

	// BUGBUG compare lpHandshakeReplyMsg->moduleID or something similar

	this->m_fShakingHands = FALSE;


	// If this is the result of a direct join attempt, we should cancel the
	// timer for it.
	if (this->m_pSessionPeriodicSend != NULL)
	{
		hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
		if (hr != S_OK)
		{
			DPL(0, "Stopping periodic send %x failed!  %e",
				2, this->m_pSessionPeriodicSend, hr);
		} // end if (there's an active send)

		this->m_pSessionPeriodicSend->m_dwRefCount--;
		if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting session periodic send %x.",
				1, this->m_pSessionPeriodicSend);
			delete (this->m_pSessionPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
				2, this->m_pSessionPeriodicSend,
				this->m_pSessionPeriodicSend->m_dwRefCount);
		} // end else (not last reference)
		this->m_pSessionPeriodicSend = NULL;
	} // end if (this is a direct join)


	if (pHandshakeReplyMsg->dwStartupDataSize > 0)
	{
		hr = this->m_pfnDoStartup(&(this->m_executor.m_info),
								(pHandshakeReplyMsg + 1),
								pHandshakeReplyMsg->dwStartupDataSize,
								&fStopJoining);
		if (hr != S_OK)
		{
			DPL(0, "Module's DoStartup proc failed!", 0);
			goto DONE;
		} // end if (failed module's proc)

		if (fStopJoining)
		{
			DPL(0, "App specified that we should not join this session.", 0);

			///BUGBUG are we sure we want to reset this?
			this->m_fShakingHands = TRUE;

			// Stop trying to join.  hr == S_OK at this point, so skip to DONE

			goto DONE;
		} // end if (app wants us to stop joining)
	} // end if (there's startup data to perform)


	// Store the session ID
	this->m_dwSessionID = pHandshakeReplyMsg->dwSessionID;

	// Ignore error, assume BUFFER_TOO_SMALL
	this->m_executor.m_info.PackIntoBuffer(NULL, &dwInfoBufferSize);

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	// We can't forget the address just yet because we need it again below
	//(*ppvFromAddress) = NULL;

	pSendData->m_dwDataSize = sizeof (CTRLMSG_JOIN)
							+ dwInfoBufferSize
							+ dwFromAddressSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pJoinMsg = (PCTRLMSG_JOIN) pSendData->m_pvData;
	pJoinMsg->dwSize = pSendData->m_dwDataSize;
	pJoinMsg->dwType = CTRLMSGID_JOIN;

	hr = this->m_executor.m_testtable.CalculateChecksum(&(pJoinMsg->testChecksum));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't calculate test table checksum!", 0);
		goto DONE;
	} // end if (couldn't calculate checksum)

	hr = this->GetMultiInstanceKey(&(pJoinMsg->dwMultiInstanceKey));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get multi-instance key!", 0);
		goto DONE;
	} // end if (couldn't get key)

	pJoinMsg->dwTimelimit = this->m_dwTimelimit;
	pJoinMsg->dwInfoSize = dwInfoBufferSize;
	pJoinMsg->dwMasterAddrSize = dwFromAddressSize;

	hr = this->m_executor.m_info.PackIntoBuffer((pJoinMsg + 1), &dwInfoBufferSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack machine info into buffer!", 0);
		goto DONE;
	} // end if (failed PackIntoBuffer)

	// Spit the master's address right back to him.  It may be used for some
	// NAT stuff on TCP/IP, see the master object for details.
	CopyMemory((((LPBYTE) (pJoinMsg + 1)) + dwInfoBufferSize), (*ppvFromAddress),
			dwFromAddressSize);

	// Forget about return address so it doesn't get freed (we used it for the send
	// data object above)
	(*ppvFromAddress) = NULL;

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSlave::HandleHandshakeReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleJoinReplyMsg()"
//==================================================================================
// CTNSlave::HandleJoinReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session join reply message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_JOINREPLY pJoinReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleJoinReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_JOINREPLY pJoinReplyMsg)
{
	HRESULT					hr;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;
#ifndef _XBOX // multiple local slaves not supported
	int						i;
#endif // ! XBOX

	//DPL(1, "Got JoinReply message.", 0);

	if (this->m_fInSession)
	{
		DPL(0, "Already in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar

	CopyMemory(&(this->m_executor.m_id), &(pJoinReplyMsg->id),
				sizeof (TNCTRLMACHINEID));

	((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress = (*ppvFromAddress);
	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize = dwFromAddressSize;

	hr = this->m_pCtrlComm->BindDataToAddress((PCOMMDATA) this->m_pvTestmasterCommData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't bind new machine's control comm data!", 0);
		return (hr);
	} // end if (couldn't bind ctrl comm address)

	// We've got our first real, in-session message from the master, update the time
	this->m_dwLastMasterReceive = GetTickCount();


#ifndef _XBOX // multiple local slaves not supported

	// Save the session and slave IDs into the instance info area, too.  Print a note
	// if we notice there is another instance already in the same session.

	// Grab the lock
	WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);

	// Map the file
	pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pMultiInstanceInfo == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't map view of file!", 0);
		ReleaseMutex(this->m_hMultiInstanceMutex);
		return (hr);
	} // end if (couldn't map view of file)

	pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].dwSessionID = this->m_dwSessionID;
	CopyMemory(&(pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].id),
				&(pJoinReplyMsg->id), sizeof (TNCTRLMACHINEID));

	// Loop through all the slots to determine if there's another instance already
	// running on this machine that's in the session we just joined.
	for(i = 0; i < MAX_NUM_LOCAL_INSTANCES; i++)
	{
		// Skip our slot.
		if (i == this->m_iInstanceIndex)
			continue;

		if ((pMultiInstanceInfo->aInstances[i].fInUse) &&
			(pMultiInstanceInfo->aInstances[i].dwSessionID == this->m_dwSessionID))
		{
			DPL(0, "WARNING: Another TestNet slave instance on this machine is already in the same session we're joining!", 0);
			this->Log(TNLST_CRITICAL,
					"WARNING: Another TestNet slave instance on this machine is already in the same session we're joining!",
					0);
			break; // don't bother looking for more
		} // end if (slot is in use and in same session)
	} // end for (each existing slot)

	ReleaseMutex(this->m_hMultiInstanceMutex);

#endif // ! XBOX

	// Start up testing thread
	hr = this->m_executor.StartTestThread();
	if (hr != S_OK)
	{
		DPL(0, "Starting test thread failed!", 0);
		return (hr);
	} // end if (starting test thread failed)


	// Okeydokey
	this->m_fInSession = TRUE;

	DPL(1, "Joined session ID %u.", 1, this->m_dwSessionID);


	// Ping the event to let the app know we're in a session and the control
	// layer is ready.
	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		return (hr);
	} // end if (couldn't set the user's update event)


#pragma TODO(vanceo, "Start timer if user wants us to close session after x amount of time")


	hr = this->SendReadyForFirstTest();
	if (hr != S_OK)
	{
		DPL(0, "Notify master of readiness failed!", 0);
	} // end if (sending ready failed)

	return (hr);
} // CTNSlave::HandleJoinReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleTestingStatusMsg()"
//==================================================================================
// CTNSlave::HandleTestingStatusMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session testing status message.
//
// Arguments:
//	PVOID* ppvFromAddress						Pointer to pointer to data
//												describing ctrl comm from address.
//	DWORD dwFromAddressSize						Size of from address data.
//	PCTRLMSG_TESTINGSTATUS pTestingStatusMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleTestingStatusMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_TESTINGSTATUS pTestingStatusMsg)
{
	HRESULT		hr;


	//DPL(1, "Got TestStatus message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();

	switch (pTestingStatusMsg->dwStatus)
	{
		case CTRLTS_ALLCOMPLETE:
			// All testing is completely finished, you are all done.

			// BUGBUG toss out if we are currently running a test

			this->m_fTestingComplete = TRUE;


			hr = this->m_executor.KillTestThread(FALSE);
			if (hr != S_OK)
			{
				DPL(0, "Failed killing test thread because of testing completion!  %e", 1, hr);
			} // end if (couldn't kill test thread)
			else
			{
				DPL(1, "Disconnecting from master.", 0);

				hr = this->m_pCtrlComm->UnbindDataFromAddress((PCOMMDATA) this->m_pvTestmasterCommData);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't disconnect from master!  %e", 1, hr);
				} // end if (couldn't disconnect from master)
				else
				{
					LocalFree(((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress);
					((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress = NULL;
					((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize = 0;


					// Empty out the results list.
					hr = this->m_executor.FreeResultsInternal(NULL, NULL, FALSE);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't free all results!", 0);
					} // end if (couldn't free all results)
					else
					{
						DPL(0, "All testing complete.", 0);
						// Ignore error
						this->Log(TNLST_CONTROLLAYER_INFO, "All testing complete!", 0);

						if (this->m_totalstats.GetFailures() > 0)
						{
							DPL(0, "NOTE: %u failure%soccurred (not including subtests).",
								2, this->m_totalstats.GetFailures(),
								((this->m_totalstats.GetFailures() == 1) ? " " : "s "));
							// Ignore error
							this->Log(TNLST_CONTROLLAYER_TESTFAILURE, "NOTE: %u failure%soccurred (not including subtests).",
									2, this->m_totalstats.GetFailures(),
									((this->m_totalstats.GetFailures() == 1) ? " " : "s "));
						} // end if (there were failures)

						if (this->m_totalstats.GetWarnings() > 0)
						{
							DPL(0, "NOTE: %u warning%soccurred.",
								2, this->m_totalstats.GetWarnings(),
								((this->m_totalstats.GetWarnings() == 1) ? " " : "s "));
							// Ignore error
							this->Log(TNLST_CONTROLLAYER_TESTWARNING, "NOTE: %u warning%soccurred.",
									2, this->m_totalstats.GetWarnings(),
									((this->m_totalstats.GetWarnings() == 1) ? " " : "s "));
						} // end if (there were warnings)

						// Fire the event to let the app know we're done.
						if ((this->m_hCompletionOrUpdateEvent != NULL) &&
							(! SetEvent(this->m_hCompletionOrUpdateEvent)))
						{
							hr = GetLastError();
								
							DPL(0, "Couldn't set the user's update event (%x)!",
								1, this->m_hCompletionOrUpdateEvent);
						} // end if (couldn't set the user's update event)
					} // end else (successfully freed all results)
				} // end else (didn't fail to disconnect)
			} // end else (didn't fail to kill the test thread)
		  break;

		case CTRLTS_REPETITIONCOMPLETE:
			// The current pass is finished, reset yourself for the next pass.


			DPL(0, "Repetition has completed.", 0);
			// Ignore error
			this->Log(TNLST_CONTROLLAYER_INFO, "Repetition has completed.", 0);
			
#pragma TODO(vanceo, "Make sure no leeches exist, here and in CTRLTS_ALLCOMPLETE")

#pragma BUGBUG(vanceo, "Make it an option to free all results?")
			hr = this->m_executor.FreeResultsInternal(NULL, NULL, FALSE);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't free all results!", 0);
				//goto DONE;
			} // end if (couldn't free all results)
		  break;

		default:
			DPL(0, "Received unknown testing status (%u)!",
				1, pTestingStatusMsg->dwStatus);

			hr = E_NOTIMPL;
		  break;
	} // end switch (on the type of status)

	return (hr);
} // CTNSlave::HandleTestingStatusMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleNewTestMsg()"
//==================================================================================
// CTNSlave::HandleNewTestMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session new test message.
//
// Arguments:
//	PVOID* ppvFromAddress			Pointer to pointer to data describing ctrl comm
//									from address.
//	DWORD dwFromAddressSize			Size of from address data.
//	PCTRLMSG_NEWTEST pNewTestMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleNewTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_NEWTEST pNewTestMsg)
{
	HRESULT				hr;
	char*				pszCaseString;
	char*				pszInstanceString;
	PTNCTRLMACHINEID	paTesters;
	PVOID				pvInputData;


	DPL(6, "Got NewTest message (ID %u).",
		1, pNewTestMsg->dwUniqueTestID);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


	pszCaseString = (char*) (pNewTestMsg + 1);

	pszInstanceString = pszCaseString + strlen(pszCaseString) + 1;

	paTesters = (PTNCTRLMACHINEID) (pszInstanceString + strlen(pszInstanceString) + 1);

	if (pNewTestMsg->dwInputDataSize == 0)
		pvInputData = NULL;
	else
		pvInputData = paTesters + pNewTestMsg->iNumMachines;


	hr = this->m_executor.HandleNewTest(pNewTestMsg->dwUniqueTestID,
										pszCaseString,
										pszInstanceString,
										pNewTestMsg->iNumMachines,
										paTesters,
										pvInputData,
										pNewTestMsg->dwInputDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle new test!", 0);
		// return (hr);
	} // end if (couldn't have executor handle new test)

	return (hr);
} // CTNSlave::HandleNewTestMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleAnnounceTestReplyMsg()"
//==================================================================================
// CTNSlave::HandleAnnounceTestReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session announce test reply message.
//
// Arguments:
//	PVOID* ppvFromAddress								Pointer to pointer to data
//														describing ctrl comm from
//														address.
//	DWORD dwFromAddressSize								Size of from address data.
//	PCTRLMSG_ANNOUNCETESTREPLY pAnnounceTestReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleAnnounceTestReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_ANNOUNCETESTREPLY pAnnounceTestReplyMsg)
{
	HRESULT		hr;


	//DPL(1, "Got AnnounceTestReply message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


	hr = this->m_executor.HandleAnnounceResponse(pAnnounceTestReplyMsg->dwResponseID,
												pAnnounceTestReplyMsg->dwUniqueTestID);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle announce test response!", 0);
		// return (hr);
	} // end if (couldn't have executor handle response)

	return (hr);
} // CTNSlave::HandleAnnounceTestReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleSyncReplyMsg()"
//==================================================================================
// CTNSlave::HandleSyncReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session sync reply message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_SYNCREPLY pSyncReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleSyncReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_SYNCREPLY pSyncReplyMsg)
{
	HRESULT		hr;


	//DPL(1, "Got SyncReply message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


	hr = this->m_executor.HandleSyncResponse(pSyncReplyMsg->dwResponseID,
											((pSyncReplyMsg->dwDataSize > 0) ? (pSyncReplyMsg + 1) : NULL),
											pSyncReplyMsg->dwDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle sync response!", 0);
		// return (hr);
	} // end if (couldn't have executor handle response)

	return (hr);
} // CTNSlave::HandleSyncReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleUserResponseMsg()"
//==================================================================================
// CTNSlave::HandleUserResponseMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session user response message.
//
// Arguments:
//	PVOID* ppvFromAddress					Pointer to pointer to data describing
//											ctrl comm from address.
//	DWORD dwFromAddressSize					Size of from address data.
//	PCTRLMSG_USERRESPONSE pUserResponseMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleUserResponseMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_USERRESPONSE pUserResponseMsg)
{
	PUSERRESPONSEDATA	purData = NULL;
	DWORD				dwURDataSize = 0;


	//DPL(1, "Got UserResponse message.", 0);

	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();

	dwURDataSize = sizeof (DWORD) * 3 // dwSize, dwResponse & dwResponseDataSize
					+ pUserResponseMsg->dwDataSize;

	purData = (PUSERRESPONSEDATA) LocalAlloc(LPTR, dwURDataSize);
	if (purData == NULL)
		return (E_OUTOFMEMORY);

	purData->dwSize = dwURDataSize;
	purData->dwResponse = pUserResponseMsg->dwResponse;
	purData->dwResponseDataSize = pUserResponseMsg->dwDataSize;
	CopyMemory((purData + 1), (pUserResponseMsg + 1),
			pUserResponseMsg->dwDataSize);

	//BUGBUG this is leaking right now, either do async or sync
	//PostMessage(this->m_hWnd, WM_TN_USERRESPONSE, (WPARAM) purData, 0);

	return (S_OK);
} // CTNSlave::HandleUserResponseMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleIdleReplyMsg()"
//==================================================================================
// CTNSlave::HandleIdleReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session idle reply message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_IDLEREPLY pIdleReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleIdleReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_IDLEREPLY pIdleReplyMsg)
{
	DPL(1, "Got IdleReply message.", 0);


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();

	switch (pIdleReplyMsg->dwStatus)
	{
		case CTRLIDLEREPLY_WAITINGFOROTHERTESTERS:
			// The master knows we're waiting, he's just not letting us go yet
			// because of someone else.
#pragma BUGBUG(vanceo, "Implement!")
			//this->m_dwAnnounceTimeouts = 0;
		  break;

		default:
			DPL(0, "Unknown IdleReply status %u!  Ignoring.", 1, pIdleReplyMsg->dwStatus);
		  break;
	} // end switch (on master's status)

	return (S_OK);
} // CTNSlave::HandleIdleReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleDumpLogMsg()"
//==================================================================================
// CTNSlave::HandleDumpLogMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session break message.
//
// Arguments:
//	PVOID* ppvFromAddress			Pointer to pointer to data describing ctrl comm
//									from address.
//	DWORD dwFromAddressSize			Size of from address data.
//	PCTRLMSG_DUMPLOG pDumpLogMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleDumpLogMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_DUMPLOG pDumpLogMsg)
{
	HRESULT		hr = S_OK;
	char*		pszFile = NULL;
	DWORD		dwSize;
	char		szNumber[32];
	char		szTemp[1024];
#ifdef _XBOX // Damn ANSI conversion
	WCHAR		szWideNumber[32];
#endif

	//DPL(1, "Got DumpLog message.", 0);


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


#ifndef _XBOX // no other processes supported, so can't call netstat
	// If we should grab the net stat info, do so.
	if (this->m_fGetNetStatInfoOnFailure)
	{
		this->GetNetStatInfo();
	} // end if (failed and should grab net stat info)
#else // ! XBOX
#pragma TODO(tristanj, "No longer able to call netstat on a failure")
#endif // XBOX


#ifndef _XBOX // Damn ANSI conversion
	wsprintf(szNumber, "%u", pDumpLogMsg->dwUniqueTestID);
#else // ! XBOX
	wsprintf(szWideNumber, L"%u", pDumpLogMsg->dwUniqueTestID);
	wcstombs(szNumber, szWideNumber, wcslen(szWideNumber));
	szNumber[wcslen(szWideNumber)] = 0;
#endif // XBOX

	// If the master specified a location use it.  Otherwise, use our default
	// location.  If we don't have that either, than just ignore the message
	if (pDumpLogMsg->dwPathSize > 0)
	{
		pszFile = (char*) LocalAlloc(LPTR, (pDumpLogMsg->dwPathSize + 1));
		if (pszFile == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		CopyMemory(pszFile, (pDumpLogMsg + 1), pDumpLogMsg->dwPathSize);
	} // end if (the master is specifying a path to dump)
	else if (this->m_pszFailureMemDumpDirPath != NULL)
	{
		dwSize = strlen(this->m_pszFailureMemDumpDirPath)
				+ strlen(szNumber)
				+ 16; // "req_memlog_" + ".txt" + NULL termination

		if (! StringEndsWith(this->m_pszFailureMemDumpDirPath, "\\", TRUE))
			dwSize++; // add backslash
		
		pszFile = (char*) LocalAlloc(LPTR, dwSize);
		if (pszFile == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		strcpy(pszFile, this->m_pszFailureMemDumpDirPath);
		if (! StringEndsWith(this->m_pszFailureMemDumpDirPath, "\\", TRUE))
			strcat(pszFile, "\\"); // add backslash
		strcat(pszFile, "req_memlog_");
		strcat(pszFile, szNumber);
		strcat(pszFile, ".txt");
	} // end else if (we have a local path)
	else
	{
		DPL(0, "Master told us to dump the memory log, but didn't specify where and we don't have a default location!  Ignoring.", 0);
		goto DONE;
	} // end else (we don't have any idea where to put it)


	// If we got here, we have location to use from somewhere.

#ifndef _XBOX // No dumping files supported
	//Ignoring error
	this->Log(TNLST_CONTROLLAYER_INFO,
				"Master requested memory log dump to file \"%s\" because of test ID %u.",
				2, pszFile, pDumpLogMsg->dwUniqueTestID);
	DPL(0, "Master requested memory log dump to file \"%s\" because of test ID %u.",
		2, pszFile, pDumpLogMsg->dwUniqueTestID);

	StringGetCurrentDateStr(szTemp);
	StringPrepend(szTemp, ")");
	StringPrepend(szTemp, szNumber);
	StringPrepend(szTemp, "Master requested mem log dump (for test ID ");

	TNDebugDumpMemoryLogToFile(pszFile, szTemp, TRUE);
#endif // ! XBOX
	


DONE:

	if (pszFile != NULL)
	{
		LocalFree(pszFile);
		pszFile = NULL;
	} // end if (allocated string)

	return (hr);
} // CTNSlave::HandleDumpLogMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleBreakMsg()"
//==================================================================================
// CTNSlave::HandleBreakMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session break message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm from
//								address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PCTRLMSG_BREAK pBreakMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleBreakMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_BREAK pBreakMsg)
{
	HRESULT		hr;


	//DPL(1, "Got Break message.", 0);


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();
	

	// Make sure all outgoing messages are actually on their way.
	hr = this->m_pCtrlComm->FlushSendQueue();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't flush send queue!", 0);
		goto DONE;
	} // end if (couldn't flush queue)


	//Ignoring error
	this->Log(TNLST_CRITICAL,
			"Master requested we DebugBreak because of test unique ID %u!",
			1, pBreakMsg->dwUniqueTestID);

	DPL(0, "Master requested we DebugBreak because of test unique ID %u!",
		1, pBreakMsg->dwUniqueTestID);

	DEBUGBREAK();


DONE:

	return (hr);
} // CTNSlave::HandleBreakMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleMetaMasterReplyMsg()"
//==================================================================================
// CTNSlave::HandleMetaMasterReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session meta-master reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_METAMASTERREPLY pMetaMasterReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleMetaMasterReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_METAMASTERREPLY pMetaMasterReplyMsg)
{
	HRESULT					hr = S_OK;
	COMMDATA				cd;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_HANDSHAKE		pHandshakeMsg = NULL;


	//DPL(1, "Got MetaMasterReply message.", 0);

	if (! this->m_fQueryingMetaMaster)
	{
		DPL(0, "Not listening for MetaMasterReplies, ignoring.", 0);
		goto DONE;
	} // end if (we're not listening for these messages)

	if (this->m_fShakingHands)
	{
		DPL(0, "Got MetaMasterReply even though we're in the process of handshaking.  Ignoring.", 0);
		goto DONE;
	} // end if (we're handshaking already)

	if (this->m_fInSession)
	{
		DPL(0, "Got MetaMasterReply even though we're already in session.  Ignoring.", 0);
		goto DONE;
	} // end if (we're in a session already)

	// BUGBUG compare lpMetaMasterReplyMsg->moduleID or something similar

	// Since this appears to be a valid meta-master reply message, we're going to
	// try to join the specified master.  Stop trying to talk to the meta-master
	hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
	if (hr != S_OK)
	{
		DPL(0, "Stopping periodic send %x failed!  %e",
			2, this->m_pSessionPeriodicSend, hr);
	} // end if (there's an active send)

	this->m_pSessionPeriodicSend->m_dwRefCount--;
	if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
	{
		DPL(7, "Deleting session periodic send %x.",
			1, this->m_pSessionPeriodicSend);
		delete (this->m_pSessionPeriodicSend);
	} // end if (last reference)
	else
	{
		DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
			2, this->m_pSessionPeriodicSend,
			this->m_pSessionPeriodicSend->m_dwRefCount);
	} // end else (not last reference)
	this->m_pSessionPeriodicSend = NULL;


	// Disconnect from the meta master.  Control comm objects are spec'ed to treat
	// an Unbind call on an address that isn't bound yet as a disconnect.
	ZeroMemory(&cd, sizeof (COMMDATA));
	cd.pvAddress = (*ppvFromAddress);
	cd.dwAddressSize = dwFromAddressSize;
	hr = this->m_pCtrlComm->UnbindDataFromAddress(&cd);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't disconnect from meta-master!", 0);
		goto DONE;
	} // end if (couldn't disconnect meta-master)


	if (pMetaMasterReplyMsg->dwStatus == CTRLMETAMASTERREPLY_FOUNDMASTER)
	{
		DPL(0, "Meta-master found a suitable master, attempting to connect to \"%s\".",
			1, (pMetaMasterReplyMsg + 1));
		this->Log(TNLST_CONTROLLAYER_INFO,
					"Meta-master found a suitable master, attempting to connect to \"%s\".",
					1, (pMetaMasterReplyMsg + 1));


		this->m_fShakingHands = TRUE;

		pSendData = new (CTNSendData);
		if (pSendData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (out of memory)

		pSendData->m_fGuaranteed = TRUE;

		// Ignore error, assume ERROR_BUFFER_TOO_SMALL
		this->m_pCtrlComm->ConvertStringToAddress((char*) (pMetaMasterReplyMsg + 1),
													NULL,
													0,
													NULL,
													&(pSendData->m_dwAddressSize));
		pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
		if (pSendData->m_pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
		hr = this->m_pCtrlComm->ConvertStringToAddress((char*) (pMetaMasterReplyMsg + 1),
														NULL,
														0,
														pSendData->m_pvAddress,
														&(pSendData->m_dwAddressSize));
		if (hr != S_OK)
		{
			DPL(0, "Control method couldn't convert \"%s\" to address!",
				1, (char*) (pMetaMasterReplyMsg + 1));
			goto DONE;
		} // end if (failed converting string to address)

		pSendData->m_dwDataSize = sizeof (CTRLMSG_HANDSHAKE);
		if (this->m_pszSessionFilter != NULL)
			pSendData->m_dwDataSize += strlen(this->m_pszSessionFilter) + 1;
		else
			pSendData->m_dwDataSize++; // empty string


		pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
		if (pSendData->m_pvData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		pHandshakeMsg = (PCTRLMSG_HANDSHAKE) pSendData->m_pvData;
		pHandshakeMsg->dwSize = pSendData->m_dwDataSize;
		pHandshakeMsg->dwType = CTRLMSGID_HANDSHAKE;
		pHandshakeMsg->dwVersion = CURRENT_TNCONTROL_API_VERSION;
		CopyMemory(&(pHandshakeMsg->moduleID), &(this->m_executor.m_moduleID),
					sizeof (TNMODULEID));
		pHandshakeMsg->dwMode = this->m_executor.m_dwMode;


		if (this->m_pszSessionFilter != NULL)
			strcpy((char*) (pHandshakeMsg + 1), this->m_pszSessionFilter);
		else
			(*((char*) (pHandshakeMsg + 1))) = '\0'; // empty string


		hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add send item to queue!", 0);
			goto DONE;
		} // end if (failed to add item to queue)

		pSendData = NULL; // forget about it so it doesn't get freed below
	} // end if (found a master to try to join)
	else
	{
		DPL(0, "Meta-master did not successfully find a master for us!", 0);
		this->Log(TNLST_CRITICAL,
				"Meta-master did not successfully find a master for us!", 0);

		// Ping the event to let the app know we failed to get a session.
		if ((this->m_hCompletionOrUpdateEvent != NULL) &&
			(! SetEvent(this->m_hCompletionOrUpdateEvent)))
		{
			if (hr == S_OK)
				hr = GetLastError();
				
			DPL(0, "Couldn't set the user's update event (%x)!",
				1, this->m_hCompletionOrUpdateEvent);
		} // end if (couldn't set the user's update event)
	} // end else (not okay to join)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSlave::HandleMetaMasterReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleMasterPingSlaveMsg()"
//==================================================================================
// CTNSlave::HandleMasterPingSlaveMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a master ping slave reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	LPCTRLMSG_MASTERPINGSLAVE lpMasterPingMsg		Master ping message.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleMasterPingSlaveMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_MASTERPINGSLAVE pMasterPingMsg)
{
	HRESULT							hr = S_OK;
	DWORD							dwTickCount;
	PTNSENDDATA						pSendData = NULL;
	PCTRLMSG_MASTERPINGSLAVEREPLY	pMasterPingReply = NULL;
	

	DPL(8, "Got MasterPingSlave message.", 0);

	// If our test thread isn't cooking, ignore the message
	if (this->m_executor.m_hTestThread == NULL)
	{
		//BUGBUG disconnect from session gracefully
		DPL(0, "Ignoring ping message because test thread is gone.", 0);
		return (S_OK);
	} // end if (we don't have a test thread)


	// Only run the deadlock check if the module hasn't disabled it.
	if (this->m_executor.m_fDeadlockCheck)
	{
#pragma BUGBUG(vanceo, "This won't detect deadlocks in leeches.")
		dwTickCount = GetTickCount();
		if (this->m_executor.m_dwLastTestthreadPing + DEADLOCK_WARNING_TIME < dwTickCount)
		{
			if (this->m_executor.m_dwLastTestthreadPing + DEADLOCK_WARNING_TIME + DEADLOCK_BREAK_TIME < dwTickCount)
			{
				BOOL	fGotThreadBlockNote;
				char	szModule[256];
				char	szSection[256];
				char	szFile[256];
				int		iLineNum = 0;
				char	szInfoString[256];
				DWORD	dwNoteAge = 0;


				DPL(0, "Test thread appears to be deadlocked, haven't heard from it in %u ticks!",
					1, dwTickCount - this->m_executor.m_dwLastTestthreadPing);
#ifndef _XBOX // no GetCurrentProcessId
				DPL(0, "Current process ID = %x/%u, test thread ID = %x/%u, DEBUGBREAK()ing",
					4, GetCurrentProcessId(), GetCurrentProcessId(),
					this->m_executor.m_dwTestThreadID, this->m_executor.m_dwTestThreadID);
#endif // ! XBOX

				fGotThreadBlockNote = TNDebugGetThreadBlockNote(this->m_executor.m_dwTestThreadID,
																szModule, szSection,
																szFile, &iLineNum,
																szInfoString, &dwNoteAge);
				if (fGotThreadBlockNote)
				{
					DPL(0, "Last known position (%u ms ago) = %s:%s (%s line %i) \"%s\".",
						6, dwNoteAge, szModule, szSection, szFile, iLineNum, szInfoString);
				} // end if (failed getting last known thread position)

				this->Log(TNLST_CRITICAL,
						"Test thread appears to be deadlocked, haven't heard from it in %u ticks!",
						1, dwTickCount - this->m_executor.m_dwLastTestthreadPing);
#ifndef _XBOX // No GetCurrentProcessId
				this->Log(TNLST_CRITICAL,
						"Current process ID = %x/%u, test thread ID = %x/%u, DEBUGBREAK()ing",
						4, GetCurrentProcessId(), GetCurrentProcessId(),
						this->m_executor.m_dwTestThreadID, this->m_executor.m_dwTestThreadID);
#endif // ! XBOX

				if (fGotThreadBlockNote)
				{
					this->Log(TNLST_CRITICAL,
							"Last known position (%u ms ago) = %s:%s (%s line %i) \"%s\".",
							6, dwNoteAge, szModule, szSection, szFile, iLineNum, szInfoString);
				} // end if (failed getting last known thread position)

				// Make sure all the messages are out of the queue.
				this->m_pCtrlComm->FlushSendQueue();

				DEBUGBREAK();

				return (E_FAIL);
			} // end if (should break)
			else
			{
				DPL(0, "WARNING: Deadlock/hang may be occurring, haven't heard from test thread in %u ticks.",
					1, dwTickCount - this->m_executor.m_dwLastTestthreadPing);

				this->Log(TNLST_CRITICAL,
						"Deadlock/hang may be occurring, haven't heard from test thread in %u ticks.",
						1, dwTickCount - this->m_executor.m_dwLastTestthreadPing);
			} // end else (should just be a deadlock warning)
		} // end if (deadlock may be occurring)
	} // end if (should check for deadlocks)


	// Send a reply back to the master

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;

	// Use the address supplied
	pSendData->m_pvAddress = *ppvFromAddress;

	*ppvFromAddress = NULL;

	pSendData->m_dwDataSize = sizeof(CTRLMSG_MASTERPINGSLAVEREPLY);
	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	
	if (!pSendData->m_pvData)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Copy the master ping slave data back
	// This consists mainly of the slave ID so that the master can use
	// it for reference
	
	ZeroMemory(pSendData->m_pvData, pSendData->m_dwDataSize);

	pMasterPingReply = (PCTRLMSG_MASTERPINGSLAVEREPLY)pSendData->m_pvData;
	pMasterPingReply->dwSize = pSendData->m_dwDataSize;
	pMasterPingReply->dwType = CTRLMSGID_MASTERPINGSLAVEREPLY;

	CopyMemory(&pMasterPingReply->id, &this->m_executor.m_id, 
				sizeof (TNCTRLMACHINEID));

	// Queue the send
	
	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed sending data)

	pSendData = NULL; // forget about it so we don't free it below
	


DONE:

	// Delete any allocated memory
	
	if (pSendData != NULL)
	{
		delete pSendData;
		pSendData = NULL;
	} // end if (have object)

	return (hr);
} // CTNSlave::HandleMasterPingSlaveMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleLostTesterMsg()"
//==================================================================================
// CTNSlave::HandleLostTesterMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session get LostTester message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_LOSTTESTER pLostTesterMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleLostTesterMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_LOSTTESTER pLostTesterMsg)
{
	HRESULT			hr = S_OK;


	//DPL(1, "Got LostTester message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		goto DONE;
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();



	hr = this->m_executor.HandleLostTester(pLostTesterMsg->dwTopLevelUniqueID,
											pLostTesterMsg->dwTestUniqueID,
											pLostTesterMsg->iTesterNum);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle LostTester message!", 0);
		//goto DONE;
	} // end if (couldn't have executor handle message)

DONE:

	return (hr);
} // CTNSlave::HandleLostTesterMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleAcceptReachCheckMsg()"
//==================================================================================
// CTNSlave::HandleAcceptReachCheckMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session accept reach check message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_ACCEPTREACHCHECK pAcceptReachCheckMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleAcceptReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_ACCEPTREACHCHECK pAcceptReachCheckMsg)
{
	HRESULT								hr = S_OK;
	PTNREACHCHECK						pReachCheck = NULL;
	PTNREACHCHECKTARGET					pReachCheckTarget = NULL;
	BOOL								fReplySuccess = FALSE;
	HRESULT								hrReplyResult = E_FAIL;
	PTNSENDDATA							pSendData = NULL;
	PCTRLMSG_ACCEPTREACHCHECKREPLY		pReplyMsg;



	DPL(1, "Got AcceptReachCheck message (method %u, ID %u).",
		2, pAcceptReachCheckMsg->dwMethod,
		pAcceptReachCheckMsg->dwID);


	// Get our self-target list if it exists, or create one otherwise.
	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(this->m_executor.m_id));
	if (pReachCheckTarget == NULL)
	{
		pReachCheckTarget = new (CTNReachCheckTarget)(&(this->m_executor.m_id));
		if (pReachCheckTarget == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		hr = this->m_reachchecktargets.Add(pReachCheckTarget);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add reach check target %x to list!",
				1, pReachCheckTarget);

			delete (pReachCheckTarget);
			pReachCheckTarget = NULL;

			goto DONE;
		} // end if (couldn't add target)
	} // end if (couldn't find target)


	// If it's actually a cancel for a previous accept, look for the ID and stop
	// accepting with that ID.
	if (pAcceptReachCheckMsg->dwMethod == TNRCM_CANCEL)
	{
		pReachCheck = pReachCheckTarget->m_checks.GetCheck(pAcceptReachCheckMsg->dwID);
		if (pReachCheck == NULL)
		{
			DPL(0, "Couldn't find reach check with ID %u!",
				1, pAcceptReachCheckMsg->dwID);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't find reach check)

		pReachCheck->m_dwRefCount++; // we've got it

		hr = pReachCheckTarget->m_checks.RemoveFirstReference(pReachCheck);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove check %x from list!", 1, pReachCheck);
			goto DONE;
		} // end if (couldn't remove check from list)

		switch (pReachCheck->m_dwMethod)
		{
			case TNRCM_UDPBROADCAST:
			case TNRCM_UDP:
			case TNRCM_TCP:
				hr = pReachCheck->m_pCtrlComm->StopAcceptingReachCheck(pReachCheck);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't stop accepting TCP/IP reach check %u!",
						1, pReachCheck->m_dwID);
					goto DONE;
				} // end if (couldn't start accepting reach check)
			  break;

			case TNRCM_IPX:
			case TNRCM_MODEM:
			case TNRCM_SERIAL:
#pragma TODO(vanceo, "Implement checking for these 3 SPs")
			  break;

			default:
				DPL(0, "Unrecognized reach check method %u!",
					1, pReachCheck->m_dwMethod);
				hr = E_FAIL;
				goto DONE;
			  break;
		} // end switch (on the type of method)

		goto DONE;
	} // end if (cancelling an accept)


	// Otherwise, it's a new accept.  Create a corresponding reach check
	// object.

	pReachCheck = new (CTNReachCheck)(pAcceptReachCheckMsg->dwID,
									pAcceptReachCheckMsg->dwMethod,
									((pAcceptReachCheckMsg->dwMethodDataSize > 0) ? (pAcceptReachCheckMsg + 1) : NULL),
									pAcceptReachCheckMsg->dwMethodDataSize);
	if (pReachCheck == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pReachCheck->m_dwRefCount++; // we've got it


	switch (pAcceptReachCheckMsg->dwMethod)
	{
		case TNRCM_UDPBROADCAST:
		case TNRCM_UDP:
		case TNRCM_TCP:
			if ((this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_OPTIMAL) ||
				(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK1) ||
				(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK2_ONETOONE))
			{
				this->m_pCtrlComm->m_dwRefCount++;
				pReachCheck->m_pCtrlComm = this->m_pCtrlComm;
			} // end if (using TCP/IP control comm method)
			else
			{
				DPL(0, "Using control comm methods other than TCP/IP is not implemented!  DEBUGBREAK()-ing.", 0);

				DEBUGBREAK();

				hr = E_NOTIMPL;
			} // end else (not using TCP/IP control comm method)

			hr = pReachCheck->m_pCtrlComm->StartAcceptingReachCheck(pReachCheck);
			if (hr != S_OK)
			{
				DPL(0, "WARNING: Couldn't start accepting TCP/IP reach check ID %u!",
					1, pReachCheck->m_dwID);

				this->Log(TNLST_CRITICAL,
						"WARNING: Couldn't start accepting TCP/IP reach check!", 0);

				hrReplyResult = hr;
				hr = S_OK;
			} // end if (couldn't start accepting reach check)
			else
			{
				fReplySuccess = TRUE;
				hrReplyResult = S_OK;

				// Add the check to our self-target list.
				hr = pReachCheckTarget->m_checks.Add(pReachCheck);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add reach check %x to self-target list (%x)!",
						2, pReachCheck, pReachCheckTarget);
					goto DONE;
				} // end if (couldn't add check to list)
			} // end else (did start accepting reach check)
		  break;

		case TNRCM_IPX:
		case TNRCM_MODEM:
		case TNRCM_SERIAL:
#pragma TODO(vanceo, "Implement checking for these 3 SPs")

			fReplySuccess = TRUE;
			hrReplyResult = S_OK;

			// Add the check to our self-target list.
			hr = pReachCheckTarget->m_checks.Add(pReachCheck);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add reach check %x to self-target list (%x)!",
					2, pReachCheck, pReachCheckTarget);
				goto DONE;
			} // end if (couldn't add check to list)
		  break;

		default:
			DPL(0, "Unrecognized reach check method %u!",
				1, pAcceptReachCheckMsg->dwMethod);
			hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on the type of method)



	// Send the ready response.

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_ACCEPTREACHCHECKREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_ACCEPTREACHCHECKREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_ACCEPTREACHCHECKREPLY;

	CopyMemory(&(pReplyMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pReplyMsg->dwID = pReachCheck->m_dwID;
	pReplyMsg->fReady = fReplySuccess;
	pReplyMsg->hresult = hrReplyResult;


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	if (pReachCheck != NULL)
	{
		pReachCheck->m_dwRefCount--;
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(7, "Deleting reach check %x.", 1, pReachCheck);
			delete (pReachCheck);
		} // end if (can delete item)
		else
		{
			DPL(7, "Not deleting reach check %x, it's refcount is %u.",
				2, pReachCheck, pReachCheck->m_dwRefCount);
		} // end else (can't delete item)
		pReachCheck = NULL;
	} // end if (have object)

	return (hr);
} // CTNSlave::HandleAcceptReachCheckMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleConnectReachCheckMsg()"
//==================================================================================
// CTNSlave::HandleConnectReachCheckMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session accept reach check message.
//
// Arguments:
//	PVOID* ppvFromAddress								Pointer to pointer to data
//														describing ctrl comm from
//														address.
//	DWORD dwFromAddressSize								Size of from address data.
//	PCTRLMSG_CONNECTREACHCHECK pConnectReachCheckMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleConnectReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_CONNECTREACHCHECK pConnectReachCheckMsg)
{
	HRESULT					hr = S_OK;
	PREACHCHECKCONTEXT		pRCContext = NULL;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	PTNREACHCHECK			pPreviousReachCheck = NULL;
	BOOL					fStartSending = FALSE;
	LPBYTE					lpCurrent;
	PVOID					pvMethodData = NULL;
	PVOID					pvAddresses = NULL;
	BOOL					fGuaranteed = FALSE;
	PVOID					pvFirstAddressToUse = NULL;
	DWORD					dwFirstAddressToUseSize = 0;
	DWORD					dwTimeout = 0;
	DWORD					dwInterval = 0;
	BOOL					fReplySuccess = FALSE;
	HRESULT					hrReplyResult = E_FAIL;
	DWORD					dwTemp;
	int						i;

	

	DPL(1, "Got ConnectReachCheck message (method %u, ID %u).",
		2, pConnectReachCheckMsg->dwMethod, pConnectReachCheckMsg->dwID);

	pRCContext = (PREACHCHECKCONTEXT) LocalAlloc(LPTR, sizeof (REACHCHECKCONTEXT));
	if (pRCContext == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pRCContext->dwType = PSCT_REACHCHECK;



	lpCurrent = (LPBYTE) (pConnectReachCheckMsg + 1);

	if (pConnectReachCheckMsg->dwMethodDataSize != 0)
	{
		pvMethodData = lpCurrent;
		lpCurrent += pConnectReachCheckMsg->dwMethodDataSize;
	} // end if (there's method data)

	if (pConnectReachCheckMsg->dwAddressesSize != 0)
	{
		pvAddresses = lpCurrent;
		//lpCurrent += pConnectReachCheckMsg->dwAddressesSize;
	} // end if (there's method data)


	// Create a new corresponding reach check object.

	pRCContext->pReachCheck = new (CTNReachCheck)(pConnectReachCheckMsg->dwID,
												pConnectReachCheckMsg->dwMethod,
												pvMethodData,
												pConnectReachCheckMsg->dwMethodDataSize);
	if (pRCContext->pReachCheck == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	// We're using it (may become the context's reference)
	pRCContext->pReachCheck->m_dwRefCount++;


	// Get the target for that slave if it exists, or create one otherwise.
	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pConnectReachCheckMsg->idTarget));
	if (pReachCheckTarget == NULL)
	{
		pReachCheckTarget = new (CTNReachCheckTarget)(&(pConnectReachCheckMsg->idTarget));
		if (pReachCheckTarget == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		hr = this->m_reachchecktargets.Add(pReachCheckTarget);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add reach check target %x to list!",
				1, pReachCheckTarget);

			delete (pReachCheckTarget);
			pReachCheckTarget = NULL;

			goto DONE;
		} // end if (couldn't add target)
	} // end if (couldn't find target)


	// Add the check to the target's list.
	hr = pReachCheckTarget->m_checks.Add(pRCContext->pReachCheck);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add reach check %x to target %x's list!",
			2, pRCContext->pReachCheck, pReachCheckTarget);
		goto DONE;
	} // end if (couldn't add check to list)


	// If the target is actually on a machine which has multiple slave instances in
	// the same session, and we've already tried this reach check on another
	// instance, the master will send the ID of the machine so we can just copy the
	// result from the earlier attempt.
	// Otherwise, prepare to connect.
	if (IsZero(&(pConnectReachCheckMsg->idPreviousTarget), sizeof (TNCTRLMACHINEID)))
	{
		switch (pConnectReachCheckMsg->dwMethod)
		{
			case TNRCM_UDPBROADCAST:
			case TNRCM_UDP:
			case TNRCM_TCP:
				if ((this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_OPTIMAL) ||
					(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK1) ||
					(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK2_ONETOONE))
				{
					this->m_pCtrlComm->m_dwRefCount++;
					pRCContext->pReachCheck->m_pCtrlComm = this->m_pCtrlComm;
				} // end if (using TCP/IP control comm method)
				else
				{
					DPL(0, "Using control comm methods other than TCP/IP is not implemented!  DEBUGBREAK()-ing.", 0);

					DEBUGBREAK();

					hr = E_NOTIMPL;
				} // end else (not using TCP/IP control comm method)


				if (pConnectReachCheckMsg->dwMethod == TNRCM_TCP)
				{
					fGuaranteed = TRUE;
					dwInterval = 0; // don't retry
					dwTimeout = 45000; // 45 second timeout
				} // end if (TCP)
				else
				{
					dwInterval = 4000; // send every 4 seconds
					dwTimeout = 24000; // 24 second timeout total (~ 6 attempts)
				} // end else (not TCP)

				if (pConnectReachCheckMsg->dwMethod == TNRCM_UDPBROADCAST)
				{
#ifdef DEBUG
				if (pvAddresses != NULL)
				{
					DPL(0, "Address exist for UDP broadcast?!?  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
				} // end if (there are addresses)
#endif // DEBUG


					// Ignore error, assume BUFFER_TOO_SMALL
					pRCContext->pReachCheck->m_pCtrlComm->GetBroadcastAddress(pvMethodData,
																			pConnectReachCheckMsg->dwMethodDataSize,
																			NULL,
																			&dwFirstAddressToUseSize);

					pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
					if (pvFirstAddressToUse == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)

					hr = pRCContext->pReachCheck->m_pCtrlComm->GetBroadcastAddress(pvMethodData,
																					pConnectReachCheckMsg->dwMethodDataSize,
																					pvFirstAddressToUse,
																					&dwFirstAddressToUseSize);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't get broadcast address!", 0);
						goto DONE;
					} // end if (couldn't add check to list)
				} // end if (UDP broadcast)
				else
				{
					CTNIPAddressesList		ipaddrs;



					// Convert the list of IP addresses the master gave us into
					// IP strings.

					hr = ipaddrs.UnpackFromBuffer(pvAddresses,
												pConnectReachCheckMsg->dwAddressesSize);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't unpack IP addresses list from buffer!", 0);
						goto DONE;
					} // end if (couldn't unpack list)


					pRCContext->dwTotalAddressStrings = ipaddrs.Count();

					// Allocate a buffer large enough to hold that many 15 character
					// (+ NULL termination) IP strings.
					pRCContext->pszAddressStrings = (char*) LocalAlloc(LPTR, (pRCContext->dwTotalAddressStrings * 16));
					if (pRCContext->pszAddressStrings == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)


					for(dwTemp = 0; dwTemp < pRCContext->dwTotalAddressStrings; dwTemp++)
					{
						// Convert the first remaining IP address into a string in
						// that buffer.
						hr = ipaddrs.GetIPString(0, pRCContext->pszAddressStrings + (dwTemp * 16));
						if (hr != S_OK)
						{
							DPL(0, "Couldn't get string for first remaining IP address from list!", 0);
							goto DONE;
						} // end if (couldn't get IP string)

						// Remove the IP address object
						hr = ipaddrs.Remove(0);
						if (hr != S_OK)
						{
							DPL(0, "Couldn't remove first remaining IP address from list!", 0);
							goto DONE;
						} // end if (couldn't remove item)
					} // end for (each IP address)


					// Now convert the first address in the buffer for use in
					// kicking off the periodic sends.
					
					// Ignore error, assume BUFFER_TOO_SMALL
					pRCContext->pReachCheck->m_pCtrlComm->ConvertStringToAddress(pRCContext->pszAddressStrings,
																				pvMethodData,
																				pConnectReachCheckMsg->dwMethodDataSize,
																				NULL,
																				&dwFirstAddressToUseSize);

					pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
					if (pvFirstAddressToUse == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)

					hr = pRCContext->pReachCheck->m_pCtrlComm->ConvertStringToAddress(pRCContext->pszAddressStrings,
																					pvMethodData,
																					pConnectReachCheckMsg->dwMethodDataSize,
																					pvFirstAddressToUse,
																					&dwFirstAddressToUseSize);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't convert IP string \"%s\" to address!",
							1, pRCContext->pszAddressStrings);
						goto DONE;
					} // end if (couldn't add check to list)

					// We've used one address, so note that.
					pRCContext->dwCurrentAddressString++;


					DPL(1, "Trying address string 1 of %u (\"%s\").",
						2, pRCContext->dwTotalAddressStrings,
						pRCContext->pszAddressStrings);
				} // end else (not UDP broadcast)


				// Let the control comm object prepare.
				hr = pRCContext->pReachCheck->m_pCtrlComm->PrepareToReachCheck(pRCContext->pReachCheck);
				if (hr != S_OK)
				{
					DPL(0, "WARNING: Couldn't have control comm object prepare to reach check (ID %u)!",
						1, pRCContext->pReachCheck->m_dwID);

					this->Log(TNLST_CRITICAL,
							"WARNING: Couldn't have control comm object prepare to reach check!", 0);

					fReplySuccess = FALSE;
					hrReplyResult = hr;
					hr = S_OK;


					// Since we couldn't have the control comm object start the reach
					// check, no point in keeping the object around.  Plus, if it still
					// exists when we go to complete this reach check below, the code
					// assumes that if it exists it was started up successfully.
					pRCContext->pReachCheck->m_pCtrlComm->m_dwRefCount--;
					if (pRCContext->pReachCheck->m_pCtrlComm->m_dwRefCount == 0)
					{
						DPL(7, "Deleting control comm object %x.",
							1, pRCContext->pReachCheck->m_pCtrlComm);
						delete (pRCContext->pReachCheck->m_pCtrlComm);
					} // end if (last reference)
					else
					{
						DPL(7, "Not deleting control comm object %x, its refcount is %u.",
							2, pRCContext->pReachCheck->m_pCtrlComm,
							pRCContext->pReachCheck->m_pCtrlComm->m_dwRefCount);
					} // end else (not last reference)

					pRCContext->pReachCheck->m_pCtrlComm = NULL;
				} // end if (couldn't prepare)
				else
				{
					fStartSending = TRUE;
				} // end else (could prepare)
			  break;

			case TNRCM_IPX:
#pragma TODO(vanceo, "Implement checking for these 3 SPs")

				// IPX doesn't need an address. We're good.

				fReplySuccess = TRUE;
				hrReplyResult = E_NOTIMPL;

				// pvFirstAddressToUse == NULL
			  break;

			case TNRCM_MODEM:
				// There should be a phone number as the only address.  Copy it and
				// use it without question.

				fReplySuccess = TRUE;
				hrReplyResult = E_NOTIMPL;


				dwFirstAddressToUseSize = pConnectReachCheckMsg->dwAddressesSize;

				pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
				if (pvFirstAddressToUse == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				CopyMemory(pvFirstAddressToUse, pvAddresses, dwFirstAddressToUseSize);
			  break;

			case TNRCM_SERIAL:
				// There should be a COM port as the only address.  Copy it and
				// use it without question.

				fReplySuccess = TRUE;
				hrReplyResult = E_NOTIMPL;


				dwFirstAddressToUseSize = pConnectReachCheckMsg->dwAddressesSize;

				pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
				if (pvFirstAddressToUse == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				CopyMemory(pvFirstAddressToUse, pvAddresses, dwFirstAddressToUseSize);
			  break;

			default:
				DPL(0, "Unrecognized reach check method %u!",
					1, pConnectReachCheckMsg->dwMethod);
				hr = E_FAIL;
				goto DONE;
			  break;
		} // end switch (on the type of method)
	} // end if (didn't already check machine)
	else
	{
		// Find the result the master referred to.
		pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pConnectReachCheckMsg->idPreviousTarget));
		if (pReachCheckTarget == NULL)
		{
			DPL(0, "Couldn't find reach check target master said we previously contacted (%u)!",
				1, pConnectReachCheckMsg->idPreviousTarget.dwTime);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't find target)


		// Set these in case we don't find the right info.  They'll get overwritten
		// if we get what we need.
		fReplySuccess = FALSE;
		hrReplyResult = E_FAIL;


		for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
		{
			pPreviousReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
			if (pPreviousReachCheck == NULL)
			{
				DPL(0, "Couldn't get reach check %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)


			if ((pPreviousReachCheck->m_dwMethod == pConnectReachCheckMsg->dwMethod) &&
				(pPreviousReachCheck->m_dwMethodDataSize == pConnectReachCheckMsg->dwMethodDataSize) &&
				((pPreviousReachCheck->m_dwMethodDataSize == 0) || (memcmp(pPreviousReachCheck->m_pvMethodData, pvMethodData, pConnectReachCheckMsg->dwMethodDataSize) == 0)))
			{
				if (pPreviousReachCheck->m_fResult)
				{
					DPL(3, "Found a successful reach check to another slave instance (target ID = %u, previous target ID = %u).",
						2, pConnectReachCheckMsg->idTarget.dwTime,
						pConnectReachCheckMsg->idPreviousTarget.dwTime);
				} // end if (check succeeded)
				else
				{
					DPL(3, "Found an unsuccessful reach check to another slave instance (target ID = %u, previous target ID = %u).",
						2, pConnectReachCheckMsg->idTarget.dwTime,
						pConnectReachCheckMsg->idPreviousTarget.dwTime);
				} // end else (check failed)


				// Alright, we're good to go.
				fReplySuccess = pPreviousReachCheck->m_fResult;
				hrReplyResult = ERROR_ALREADY_EXISTS;


				// Copy the info.
				dwFirstAddressToUseSize = pPreviousReachCheck->m_dwAddressSize;

				pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
				if (pvFirstAddressToUse == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				CopyMemory(pvFirstAddressToUse, pPreviousReachCheck->m_pvAddress,
							dwFirstAddressToUseSize);

				// Stop searching.
				break;
			} // end if (found reach check)
		} // end for (each reach check)
	} // end else (already checked another instance)


	// If we should kick off the reach checking, do it, otherwise send the
	// reply.
	if (fStartSending)
	{
		PCTRLMSG_INTERSLAVEREACHCHECK	pInterSlaveReachCheckMsg;
		DWORD							dwMsgSize;



		dwMsgSize = sizeof (CTRLMSG_INTERSLAVEREACHCHECK)
					+ dwFirstAddressToUseSize;

		pInterSlaveReachCheckMsg = (PCTRLMSG_INTERSLAVEREACHCHECK) LocalAlloc(LPTR, dwMsgSize);
		if (pInterSlaveReachCheckMsg == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		pInterSlaveReachCheckMsg->dwSize = dwMsgSize;
		pInterSlaveReachCheckMsg->dwType = CTRLMSGID_INTERSLAVEREACHCHECK;
		CopyMemory(&(pInterSlaveReachCheckMsg->id),
					&(this->m_executor.m_id),
					sizeof (TNCTRLMACHINEID));
		pInterSlaveReachCheckMsg->dwID = pConnectReachCheckMsg->dwID;
		pInterSlaveReachCheckMsg->fGuaranteed = fGuaranteed;
		pInterSlaveReachCheckMsg->dwUsedAddressSize = dwFirstAddressToUseSize;

		CopyMemory((pInterSlaveReachCheckMsg + 1), pvFirstAddressToUse,
					dwFirstAddressToUseSize);


		hr = this->StartPeriodicSend(pRCContext->pReachCheck->m_pCtrlComm,
									fGuaranteed,
									pvFirstAddressToUse,
									dwFirstAddressToUseSize,
									pInterSlaveReachCheckMsg,
									dwMsgSize,
									dwInterval,
									dwTimeout,
									pRCContext,
									&(pRCContext->pReachCheck->m_pPeriodicSend));

		LocalFree(pInterSlaveReachCheckMsg);
		pInterSlaveReachCheckMsg = NULL;

		if (hr != S_OK)
		{
			DPL(0, "Couldn't start periodic send!", 0);
			goto DONE;
		} // end if (couldn't start send)

		pRCContext = NULL; // forget about it so we don't free it below
	} // end if (ctrl comm object to use)
	else
	{
		hr = this->DoConnectReachCheckResult(pRCContext->pReachCheck,
											fReplySuccess,
											hrReplyResult,
											pvFirstAddressToUse,
											dwFirstAddressToUseSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't do connect reach check result!", 0);
			goto DONE;
		} // end if (couldn't handle result)
	} // end else (no ctrl comm object to use)
	

DONE:

	if (pvFirstAddressToUse != NULL)
	{
		LocalFree(pvFirstAddressToUse);
		pvFirstAddressToUse = NULL;
	} // end if (have address)

	if (pRCContext != NULL)
	{
		if (pRCContext->pszAddressStrings != NULL)
		{
			LocalFree(pRCContext->pszAddressStrings);
			pRCContext->pszAddressStrings = NULL;
		} // end if (have string)

		if (pRCContext->pReachCheck != NULL)
		{
			pRCContext->pReachCheck->m_dwRefCount--;
			if (pRCContext->pReachCheck->m_dwRefCount == 0)
			{
				DPL(7, "Deleting reach check %x.", 1, pRCContext->pReachCheck);
				delete (pRCContext->pReachCheck);
			} // end if (can delete item)
			else
			{
				DPL(7, "Not deleting reach check %x, it's refcount is %u.",
					2, pRCContext->pReachCheck,
					pRCContext->pReachCheck->m_dwRefCount);
			} // end else (can't delete item)
			pRCContext->pReachCheck = NULL;
		} // end if (have object)

		LocalFree(pRCContext);
		pRCContext = NULL;
	} // end if (still have context)

	return (hr);
} // CTNSlave::HandleConnectReachCheckMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleInterSlaveReachCheckMsg()"
//==================================================================================
// CTNSlave::HandleInterSlaveReachCheckMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session inter-slave reach check message.
//
// Arguments:
//	PVOID* ppvFromAddress									Pointer to pointer to
//															data describing ctrl
//															comm from address.
//	DWORD dwFromAddressSize									Size of from address
//															data.
//	PCTRLMSG_INTERSLAVEREACHCHECK pInterSlaveReachCheckMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleInterSlaveReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
												PCTRLMSG_INTERSLAVEREACHCHECK pInterSlaveReachCheckMsg)
{
	HRESULT								hr;
	PTNREACHCHECKTARGET					pReachCheckTarget;
	PTNREACHCHECK						pReachCheck = NULL;
	PTNSENDDATA							pSendData = NULL;
	PCTRLMSG_INTERSLAVEREACHCHECKREPLY	pReplyMsg;


	if (memcmp(&(pInterSlaveReachCheckMsg->id), &(this->m_executor.m_id), sizeof (TNCTRLMACHINEID)) == 0)
	{
		DPL(1, "Ignoring InterSlaveReachCheck message from ourselves (must be a broadcast).", 0);
		hr = S_OK;
		goto DONE;
	} // end if (it's our own ID)


	DPL(1, "Got InterSlaveReachCheck message from slave ID %u, reach check %u.",
		2, pInterSlaveReachCheckMsg->id.dwTime, pInterSlaveReachCheckMsg->dwID);


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(this->m_executor.m_id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find self target reach checks list!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find reach check)

	pReachCheck = pReachCheckTarget->m_checks.GetCheck(pInterSlaveReachCheckMsg->dwID);
	if (pReachCheck == NULL)
	{
		DPL(0, "Couldn't find self target reach check with ID %u!  Ignoring.",
			1, pInterSlaveReachCheckMsg->dwID);
		hr = S_OK;
		goto DONE;
	} // end if (couldn't find reach check)

	pReachCheck->m_dwRefCount++; // we've got it




	// Send the response.

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	// Send it back the way it came in.
	pSendData->m_fGuaranteed = pInterSlaveReachCheckMsg->fGuaranteed;
	pSendData->m_dwAddressSize = dwFromAddressSize;

	// We can't just use it directly because we use the pointer later.  We have
	// to make a copy.
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	CopyMemory(pSendData->m_pvAddress, (*ppvFromAddress), pSendData->m_dwAddressSize);


	pSendData->m_dwDataSize = sizeof (CTRLMSG_INTERSLAVEREACHCHECKREPLY)
							+ pInterSlaveReachCheckMsg->dwUsedAddressSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_INTERSLAVEREACHCHECKREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_INTERSLAVEREACHCHECKREPLY;

	CopyMemory(&(pReplyMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pReplyMsg->dwID = pReachCheck->m_dwID;
	pReplyMsg->dwUsedAddressSize = pInterSlaveReachCheckMsg->dwUsedAddressSize;

	if (pInterSlaveReachCheckMsg->dwUsedAddressSize > 0)
	{
		CopyMemory((pReplyMsg + 1), (pInterSlaveReachCheckMsg + 1),
					pInterSlaveReachCheckMsg->dwUsedAddressSize);
	} // end if (there's a used address)


	hr = pReachCheck->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to reach check's send queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below



	// Make sure that message has gotten out.
	hr = pReachCheck->m_pCtrlComm->FlushSendQueue();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't flush the reach check's control comm object's send queue!", 0);
		goto DONE;
	} // end if (failed to flush send queue)


	// If it's a guaranteed message, disconnect from the sender, because we don't
	// need this connection anymore.  Control comm objects are spec'ed to treat an
	// Unbind call on an address that isn't bound yet as a disconnect.
	if (pInterSlaveReachCheckMsg->fGuaranteed)
	{
		COMMDATA	cd;


		ZeroMemory(&cd, sizeof (COMMDATA));
		// We don't NULL it out, because it's not saved anywhere by this function
		// or UnbindDataFromAddress.  We'll let our caller free it.
		cd.pvAddress = (*ppvFromAddress);
		cd.dwAddressSize = dwFromAddressSize;


		hr = pReachCheck->m_pCtrlComm->UnbindDataFromAddress(&cd);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't disconnect from slave!", 0);
			goto DONE;
		} // end if (couldn't disconnect slave)
	} // end if (it's a guaranteed message)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	if (pReachCheck != NULL)
	{
		pReachCheck->m_dwRefCount--;
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(7, "Deleting reach check %x.", 1, pReachCheck);
			delete (pReachCheck);
		} // end if (can delete item)
		else
		{
			DPL(7, "Not deleting reach check %x, it's refcount is %u.",
				2, pReachCheck, pReachCheck->m_dwRefCount);
		} // end else (can't delete item)
		pReachCheck = NULL;
	} // end if (have object)

	return (hr);
} // CTNSlave::HandleInterSlaveReachCheckMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleInterSlaveReachCheckReplyMsg()"
//==================================================================================
// CTNSlave::HandleInterSlaveReachCheckReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session inter-slave reach check reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_INTERSLAVEREACHCHECKREPLY pReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleInterSlaveReachCheckReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
													PCTRLMSG_INTERSLAVEREACHCHECKREPLY pReplyMsg)
{
	HRESULT					hr;
	PTNREACHCHECKTARGET		pReachCheckTarget;
	PTNREACHCHECK			pReachCheck = NULL;
	PREACHCHECKCONTEXT		pRCContext;



	DPL(1, "Got InterSlaveReachCheckReply message from slave ID %u, reach check %u.",
		2, pReplyMsg->id.dwTime, pReplyMsg->dwID);


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pReplyMsg->id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find target's reach checks list!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find reach check)

	pReachCheck = pReachCheckTarget->m_checks.GetCheck(pReplyMsg->dwID);
	if (pReachCheck == NULL)
	{
		DPL(0, "Couldn't find target's reach check with ID %u!",
			1, pReplyMsg->dwID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find reach check)

	pReachCheck->m_dwRefCount++; // we've got it
	

	// If we've already received a reply (or timed out), who cares.
	if (pReachCheck->m_pPeriodicSend == NULL)
	{
		DPL(1, "Already completed reach check %u, ignoring response.",
			1, pReplyMsg->dwID);
		hr = S_OK;
		goto DONE;
	} // end if (already stopped send)


	switch (pReachCheck->m_dwMethod)
	{
		case TNRCM_UDPBROADCAST:
		case TNRCM_UDP:
		case TNRCM_TCP:
			// The address we sent to should have been of type SOCKADDR_IN.

#ifdef DEBUG
			if (pReplyMsg->dwUsedAddressSize != sizeof (SOCKADDR_IN))
			{
				DPL(0, "Reply message used address is not expected size (%u != %u)!",
					2, pReplyMsg->dwUsedAddressSize, sizeof (SOCKADDR_IN));
				hr = E_FAIL;
				goto DONE;
			} // end if (invalid reply)
#endif // DEBUG


			DPL(1, "Got a response for reach check %u after sending to %o.",
				2, pReachCheck->m_dwID, (SOCKADDR_IN*) (pReplyMsg + 1));
			

#pragma BUGBUG(vanceo, "Need locking mechanism, not thread safe")

			// Stop the periodic send that was going.
			hr = this->StopPeriodicSend(pReachCheck->m_pPeriodicSend);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't stop periodic send %x!",
					1, pReachCheck->m_pPeriodicSend);
				goto DONE;
			} // end if (couldn't stop periodic send)


			// Clean up the periodic send context.

			pRCContext = (PREACHCHECKCONTEXT) pReachCheck->m_pPeriodicSend->m_pvUserContext;
			pReachCheck->m_pPeriodicSend->m_pvUserContext = NULL;


			pRCContext->pReachCheck->m_dwRefCount--;
			if (pRCContext->pReachCheck->m_dwRefCount == 0)
			{
				DPL(0, "Deleting reach check %x!?  DEBUGBREAK()-ing.",
					1, pRCContext->pReachCheck);

				DEBUGBREAK();

				delete (pRCContext->pReachCheck);
			} // end if (can delete item)
			pRCContext->pReachCheck = NULL;

			LocalFree(pRCContext->pszAddressStrings);
			pRCContext->pszAddressStrings = NULL;

			LocalFree(pRCContext);
			pRCContext = NULL;


			// Complete the result.
			hr = this->DoConnectReachCheckResult(pReachCheck,
												TRUE,
												S_OK,
												&(((SOCKADDR_IN*) (pReplyMsg + 1))->sin_addr),
												sizeof (IN_ADDR));
			if (hr != S_OK)
			{
				DPL(0, "Couldn't send ConnectReachCheckReply message!", 0);
				//goto DONE;
			} // end if (couldn't send message)
		  break;

		case TNRCM_IPX:
		case TNRCM_MODEM:
		case TNRCM_SERIAL:
		default:
			DPL(0, "Unhandled reach check mode (%u)!  DEBUGBREAK()-ing.",
				1, pReachCheck->m_dwMethod);

			DEBUGBREAK();

			hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on method)


DONE:

	if (pReachCheck != NULL)
	{
		pReachCheck->m_dwRefCount--;
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(7, "Deleting reach check %x.", 1, pReachCheck);
			delete (pReachCheck);
		} // end if (can delete item)
		else
		{
			DPL(7, "Not deleting reach check %x, it's refcount is %u.",
				2, pReachCheck, pReachCheck->m_dwRefCount);
		} // end else (can't delete item)
		pReachCheck = NULL;
	} // end if (have object)

	
	
	return (hr);
} // CTNSlave::HandleInterSlaveReachCheckReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleGetMachineInfoReplyMsg()"
//==================================================================================
// CTNSlave::HandleGetMachineInfoReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session GetMachineInfo reply message.
//
// Arguments:
//	PVOID* ppvFromAddress					Pointer to pointer to data describing
//											ctrl comm from address.
//	DWORD dwFromAddressSize					Size of from address data.
//	PCTRLMSG_GETMACHINEINFOREPLY pReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleGetMachineInfoReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_GETMACHINEINFOREPLY pReplyMsg)
{
	HRESULT		hr;


	//DPL(1, "Got GetMachineInfo message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


	hr = this->m_executor.HandleGetMachineInfoResponse(pReplyMsg->dwResponseID,
													((pReplyMsg->dwMachineInfoSize > 0) ? (pReplyMsg + 1) : NULL),
													pReplyMsg->dwMachineInfoSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle GetMachineInfo response!", 0);
		// return (hr);
	} // end if (couldn't have executor handle response)

	return (hr);
} // CTNSlave::HandleGetMachineInfoReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::RegisterWithOtherLocalSlaves()"
//==================================================================================
// CTNSlave::RegisterWithOtherLocalSlaves
//----------------------------------------------------------------------------------
//
// Description: Uses a shared memory space to notify any other slaves already
//				running on this machine.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::RegisterWithOtherLocalSlaves(void)
{
#ifndef _XBOX // only one local slave allowed

	HRESULT					hr;
	int						i;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;


	// Create the mutex, or open it if it already exists.
	this->m_hMultiInstanceMutex = CreateMutex(NULL, FALSE, TNSLAVE_MULTIINSTANCEDETECT_MUTEX);
	if (this->m_hMultiInstanceMutex == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create mutex \"%s\"!", 1, TNSLAVE_MULTIINSTANCEDETECT_MUTEX);
		goto ERROR_EXIT;
	} // end if (couldn't create mutex)

	// Grab the lock
	WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);


	// Grab and map the actual file.

	this->m_hMultiInstanceMMFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
													PAGE_READWRITE, 0,
													sizeof (MULTIINSTANCEMMFILE),
													TNSLAVE_MULTIINSTANCEDETECT_MMFILE);
	if (this->m_hMultiInstanceMMFile == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create file mapping \"%s\"!",
			1, TNSLAVE_MULTIINSTANCEDETECT_MMFILE);
		goto ERROR_EXIT;
	} // end if (couldn't create file mapping)


	pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pMultiInstanceInfo == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't map view of file)


	if (pMultiInstanceInfo->iNumInstances >= MAX_NUM_LOCAL_INSTANCES)
	{
		DPL(0, "Can't start another TestNet slave on this machine, there are already %i existing instances!",
			1, pMultiInstanceInfo->iNumInstances);

		hr = ERROR_TOO_MANY_OPEN_FILES;

		goto ERROR_EXIT;
	} // end if (too many instances)


	pMultiInstanceInfo->iNumInstances++;

	// Search through all the available slots to find the first one open.
	for(i = 0; i < MAX_NUM_LOCAL_INSTANCES; i++)
	{
		if (! pMultiInstanceInfo->aInstances[i].fInUse)
		{
			pMultiInstanceInfo->aInstances[i].fInUse = TRUE; // it's in use now
			this->m_iInstanceIndex = i;
			break;
		} // end if (this slot is open)
	} // end for (each instance slot)

#ifdef DEBUG
	if (this->m_iInstanceIndex < 0)
	{
		DPL(0, "No slot found in multiinstanceinfo (%x), but there are now %i instances!?  DEBUGBREAK()-ing.",
			2, pMultiInstanceInfo, pMultiInstanceInfo->iNumInstances);

		DEBUGBREAK();
	} // end if (no slot found)
#endif // DEBUG


	// If we're the first instance, we get to decide the special uniqueness key for
	// this file.  It will be used by the master to help correlate which slaves are
	// on the same machine.

	if (pMultiInstanceInfo->iNumInstances == 1)
	{
#ifdef DEBUG
		if (this->m_iInstanceIndex != 0)
		{
			DPL(0, "Only current instance, but slot found for multiinstanceinfo (%x) is not the first one!?  DEBUGBREAK()-ing.",
				1, pMultiInstanceInfo);

			DEBUGBREAK();
		} // end if (no slot found)

		if (pMultiInstanceInfo->dwKey != 0)
		{
			DPL(0, "Only current instance, but key is already defined as %u (info = %x)!?  DEBUGBREAK()-ing.",
				2, pMultiInstanceInfo->dwKey, pMultiInstanceInfo);

			DEBUGBREAK();
		} // end if (key already used)
#endif // DEBUG

#ifndef _XBOX // timeGetTime not supported
		pMultiInstanceInfo->dwKey = timeGetTime();
#else // ! XBOX
		pMultiInstanceInfo->dwKey = GetTickCount();
#endif // XBOX

		//HACKHACK Make sure no 2 tries can get the same key (by sleeping for well over
		//		   the timeGetTime resolution).  We need a real uniqueness ID though.
		Sleep(100);
	} // end if (first instance)



	// Unmap our view.
	UnmapViewOfFile(pMultiInstanceInfo);
	pMultiInstanceInfo = NULL;

	// Drop the lock we took.
	ReleaseMutex(this->m_hMultiInstanceMutex);

	return (S_OK);


ERROR_EXIT:

	if (pMultiInstanceInfo != NULL)
	{
		UnmapViewOfFile(pMultiInstanceInfo);
		pMultiInstanceInfo = NULL;
	} // end if (mapped a view)

	if (this->m_hMultiInstanceMMFile != NULL)
	{
		CloseHandle(this->m_hMultiInstanceMMFile);
		this->m_hMultiInstanceMMFile = NULL;
	} // end if (have the file)

	if (this->m_hMultiInstanceMutex != NULL)
	{
		ReleaseMutex(this->m_hMultiInstanceMutex);
		this->m_hMultiInstanceMutex = NULL;
	} // end if (have the mutex)

	return (hr);

#else // ! XBOX
#pragma TODO(tristanj, "Only one local slave allowed, fake the multi-instance key")
	m_dwMultiInstanceKey = GetTickCount();
	return (S_OK);
#endif // XBOX

} // CTNSlave::RegisterWithOtherLocalSlaves
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetMultiInstanceKey()"
//==================================================================================
// CTNSlave::GetMultiInstanceKey
//----------------------------------------------------------------------------------
//
// Description: Retrieves the uniqueness key used for detecting multiple instances
//				of slaves on a single machine.
//
// Arguments:
//	DWORD* pdwKey	Pointer to place to store key being used.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetMultiInstanceKey(DWORD* pdwKey)
{
#ifndef _XBOX // only one local slave allowed
	HRESULT					hr = S_OK;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;


	if (this->m_hMultiInstanceMutex == NULL)
	{
		DPL(0, "No mutex!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (no mutex)

	if (this->m_hMultiInstanceMMFile == NULL)
	{
		DPL(0, "No memory mapped file!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (no mm file)


	// Grab the lock
	WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);

	// Map the file
	pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pMultiInstanceInfo == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto DONE;
	} // end if (couldn't map view of file)

	// Grab the value we want.
	(*pdwKey) = pMultiInstanceInfo->dwKey;


	// Unmap our view.
	UnmapViewOfFile(pMultiInstanceInfo);
	pMultiInstanceInfo = NULL;

	// Drop the lock we took.
	ReleaseMutex(this->m_hMultiInstanceMutex);


DONE:

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "Only one local slave allowed, fake the multi-instance key")
	(*pdwKey) = m_dwMultiInstanceKey;
	return (S_OK);
#endif // XBOX
} // CTNSlave::GetMultiInstanceKey
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::UnregisterWithOtherLocalSlaves()"
//==================================================================================
// CTNSlave::UnregisterWithOtherLocalSlaves
//----------------------------------------------------------------------------------
//
// Description: Cleans up the shared memory space used for detecting multiple
//				instances of slaves on a single machine.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::UnregisterWithOtherLocalSlaves(void)
{
#ifndef _XBOX // only one local slave allowed
	HRESULT					hr = S_OK;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;


	if (this->m_hMultiInstanceMutex != NULL)
	{
		if (this->m_hMultiInstanceMMFile != NULL)
		{
			// Grab the lock
			WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);


			if (this->m_iInstanceIndex > 0)
			{
				pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
																		FILE_MAP_ALL_ACCESS,
																		0, 0, 0);
				if (pMultiInstanceInfo == NULL)
				{
					hr = GetLastError();
					DPL(0, "Couldn't map view of file!", 0);
				} // end if (couldn't map view of file)
				else
				{
#ifdef DEBUG
					if (! pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].fInUse)
					{
						DPL(0, "Our multiinstanceinfo slot (%i, info = %x) isn't in use!?  DEBUGBREAK()-ing.",
							2, this->m_iInstanceIndex, pMultiInstanceInfo);

						DEBUGBREAK();
					} // end if (no slot found)
#endif // DEBUG

					ZeroMemory(&(pMultiInstanceInfo->aInstances[this->m_iInstanceIndex]),
								sizeof (MULTIINSTANCEITEM));
					/*
					pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].fInUse = FALSE;
					pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].dwSessionID = 0;
					ZeroMemory(&(pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].id),
								sizeof (TNCTRLMACHINEID));
					*/

					this->m_iInstanceIndex = -1;

					pMultiInstanceInfo->iNumInstances--;

					UnmapViewOfFile(pMultiInstanceInfo);
					pMultiInstanceInfo = NULL;
				} // end else (mapped view of file)
			} // end if (we actually registered already)


			CloseHandle(this->m_hMultiInstanceMMFile);
			this->m_hMultiInstanceMMFile = NULL;


			ReleaseMutex(this->m_hMultiInstanceMutex);
		} // end if (have file)

		CloseHandle(this->m_hMultiInstanceMMFile);
		this->m_hMultiInstanceMMFile = NULL;
	} // end if (have mutex)

	return (hr);

#else // ! XBOX
#pragma TODO(tristanj, "Only one local slave allowed")
	return (S_OK);
#endif // XBOX

} // CTNSlave::UnregisterWithOtherLocalSlaves
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no DB logging supported

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::InitializeDBLogging()"
//==================================================================================
// CTNSlave::InitializeDBLogging
//----------------------------------------------------------------------------------
//
// Description: Starts looking for a control session to join.  This is an
//				asynchronous call, so this function returns E_PENDING if successful,
//				and the caller should wait until the hCompletionOrUpdateEvent
//				(if specified) is set, then call IsInSession() to check whether this
//				succeeded or not.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::InitializeDBLogging(void)
{
	HRESULT					hr;
	HMODULE					hOle32 = NULL;
	LPCOINITIALIZEEXPROC	pfnCoInitializeEx = NULL;
	BOOL					fCOMInitialized = FALSE;
	LPTMSETUP				lpTMSetup = NULL;
	INT_PTR					iMsgBoxResult;


	DPL(0, "Attempting to initialize database logging.", 0);


	// Use CoInitializeEx if available, otherwise CoInitialize.

#pragma BUGBUG(vanceo, "CoInitializeEx is crashing my Win9x machines when CoCreating DNWSOCK")
	//hOle32 = LoadLibrary("ole32.dll");
	if (hOle32 != NULL)
		pfnCoInitializeEx = (LPCOINITIALIZEEXPROC) GetProcAddress(hOle32, "CoInitializeEx");

	// If we couldn't get it, assume it's because we're on a Win95 Gold machine
	if (pfnCoInitializeEx == NULL)
	{
		DPL(8, "Initializing COM with single thread apartment concurrency model.", 0);

		// Just use the regular CoInitialize.  S_FALSE is okay, it just means it was
		// already called.
		hr = CoInitialize(NULL);
		if ((hr != S_OK) && (hr != S_FALSE))
		{
			DPL(0, "Couldn't initialize COM!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't initialize COM)
	}
	else
	{
		DPL(8, "Initializing COM with multithread apartment concurrency model.", 0);

		// Note: this function call requires DCOM95 to be installed on Win95 machines and
		// it returns S_FALSE if it was already called (which is documented as being okay,
		// as long as we balance the calls).
		hr = pfnCoInitializeEx(NULL, COINIT_MULTITHREADED);
		if ((hr != S_OK) && (hr != S_FALSE))
		{
			DPL(0, "Couldn't initialize COM using Ex interface!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't initialize COM ex)
	} // end if (got CoInitializeEx)

	fCOMInitialized = TRUE;

	if (hOle32 != NULL)
	{
		FreeLibrary(hOle32); // ignore error
		hOle32 = NULL;
	} // end if (have OLE library)


	hr = CoCreateInstance(CLSID_tmAgent, NULL, CLSCTX_ALL, IID_ItmAgent,
						(void**) &(this->m_lpTMAgent));
	if (hr != S_OK)
	{
		DPL(0, "Creating TMAgent object failed!  Check that TMAgent.dll is registered.", 0);
		goto ERROR_EXIT;
	} // end if (creating TMAgent object failed)

	hr = this->m_lpTMAgent->QueryInterface(IID_ItmSetup, (void**) &lpTMSetup);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get TMSetup interface from TMAgent object!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't get a setup interface)


	// Since the database logging is wierd like that, we need to generate a new
	// system ID every time we want to run the same test, which for us is essentially
	// every time.  So get a TMSetup interface, and generate an ID.
	hr = lpTMSetup->NewSysID();
	if (hr != S_OK)
	{
		/*
		DPL(0, "Creating a new system ID failed!  Ignoring.  %e", 1, hr);
		hr = S_OK;
		*/
		DPL(0, "Creating a new system ID failed!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't create new system ID)

	lpTMSetup->Release();
	lpTMSetup = NULL;


	hr = this->m_lpTMAgent->Initialize();
	if (hr != S_OK)
	{
		DPL(0, "Initializing TMAgent object failed!", 0);
		goto ERROR_EXIT;
	} // end if (initting TMAgent object failed)
	
	hr = this->m_lpTMAgent->StartTest(TN_DATABASE_APPID);
	if (hr != S_OK)
	{
		DPL(0, "Notifying database of test pass start failed!", 0);
		goto ERROR_EXIT;
	} // end if (starting test pass failed)

	// Hey, everything's cool, so we're done

	return (S_OK);


ERROR_EXIT:

	if (lpTMSetup != NULL)
	{
		lpTMSetup->Release();
		lpTMSetup = NULL;
	} // end if (we have a TMSetup interface)

	if (this->m_lpTMAgent != NULL)
	{
		this->m_lpTMAgent->Release();
		this->m_lpTMAgent = NULL;
	} // end if (we have a TMAgent interface)

	if (hOle32 != NULL)
	{
		FreeLibrary(hOle32); // ignore error
		hOle32 = NULL;
	} // end if (have OLE library)

	if (fCOMInitialized)
	{
		CoUninitialize();
		fCOMInitialized = FALSE;
	} // end if (we initialized COM)

	iMsgBoxResult = IDYES;
	//if (! this->m_fQuiet) // BUGBUG implement something like this
	{
		iMsgBoxResult = DialogBoxParam(s_hInstance, MAKEINTRESOURCE(IDD_DBUNAVAILABLE), NULL,
										DBUnavailableDlgProc, 0);
	} // end if (can display dialog box)

	if (iMsgBoxResult == IDYES)
	{
		DPL(0, "WARNING: Couldn't initialize database logging, but user chose to continue testing!", 0);
		this->Log(TNLST_CRITICAL,
				"WARNING: Couldn't initialize database logging, but user chose to continue testing!", 0);
		hr = S_OK;
	} // end if (continue)

	return (hr);
} // CTNSlave::InitializeDBLogging
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::ReportInternal()"
//==================================================================================
// CTNSlave::ReportInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of test result reporting.
//
// Arguments:
//	PTNTESTINSTANCES pTest			Pointer to test instance this report pertains
//									to.
//	HRESULT hresult					Success or error code.
//	BOOL fTestComplete				Does this report mean that no more execution
//									will be performed on the test (either because it
//									completed or it encountered a fatal error)?
//	BOOL fSuccess					Is this report a success (note this does not
//									necessarily mean hresult is 0)?
//	PVOID pvOutputData				Optional pointer to output data to send with
//									report.
//	DWORD dwOutputDataSize			Size of output data to send with report.
//	PTNOUTPUTVARSLIST pOutputVars	Optional pointer to list of output variables
//									associated with result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::ReportInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
								BOOL fTestComplete, BOOL fSuccess,
								PVOID pvOutputData, DWORD dwOutputDataSize,
								PTNOUTPUTVARSLIST pOutputVars)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTopLevelTest = NULL;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_REPORT		pReportMsg = NULL;
	DWORD				dwVarsSize = 0;
	BOOL				fDebugBreak = FALSE;


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test %u!", 1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)

	DPL(1, "Sending %s %s report for test ID %u:%u, hresult = %x",
		5, ((fTestComplete) ? "complete" : "during-test"),
		((fSuccess) ? "success" : "failure"),
		pTopLevelTest->m_dwUniqueID, pTest->m_dwUniqueID, hresult);

	if (fTestComplete)
	{
		this->Log(((fSuccess) ? TNLST_CONTROLLAYER_TESTSUCCESS : TNLST_CONTROLLAYER_TESTFAILURE),
				"Test %u was %s, %e",
				3, pTest->m_dwUniqueID,
				((fSuccess) ? "successful" : "a failure"),
				hresult);
	} // end if (test is complete)
	else
	{
		this->Log(((fSuccess) ? TNLST_CONTROLLAYER_TESTSUCCESS : TNLST_CONTROLLAYER_TESTFAILURE),
				"Test %u is continuing %s, %e",
				3, pTest->m_dwUniqueID,
				((fSuccess) ? "successfully" : "despite a failure"),
				hresult);
	} // end if (test is complete)


	// Ignore error, assume BUFFER_TOO_SMALL
	if (pOutputVars != NULL)
		pOutputVars->PackIntoBuffer(NULL, &dwVarsSize);


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_REPORT)
								+ dwOutputDataSize
								+ dwVarsSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReportMsg = (PCTRLMSG_REPORT) pSendData->m_pvData;
	pReportMsg->dwSize = pSendData->m_dwDataSize;
	pReportMsg->dwType = CTRLMSGID_REPORT;

	CopyMemory(&(pReportMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pReportMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pReportMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pReportMsg->hresult = hresult;
	pReportMsg->fTestComplete = fTestComplete;
	pReportMsg->fSuccess = fSuccess;
	//pReportMsg->dwOutputDataSize = 0;
	//pReportMsg->dwVarsSize = 0;
	if ((pvOutputData != NULL) && (dwOutputDataSize > 0))
	{
		pReportMsg->dwOutputDataSize = dwOutputDataSize;
		CopyMemory((pReportMsg + 1), pvOutputData, dwOutputDataSize);
	} // end if (there's actually output data)
	if (pOutputVars != NULL)
	{
		pReportMsg->dwVarsSize = dwVarsSize;
		hr = pOutputVars->PackIntoBuffer(((LPBYTE) (pReportMsg + 1)) + dwOutputDataSize,
										&dwVarsSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't pack output variables into buffer!", 0);
			goto DONE;
		} // end if (failed to add item to queue)
	} // end if (there are output variables)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


	if ((! fSuccess) && (this->m_pFailureBreakRules != NULL))
	{
		char		szNumber[32];
		int			i;
		PLSTRING	pBreakRule;
		char*		pszTemp;
		DWORD		dwNumFields;
#ifdef _XBOX // Damn ANSI conversion
	WCHAR				szWideNumber[32];
#endif // XBOX
		

#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szNumber, "0x%08x", hresult);
#else // ! XBOX
		swprintf(szWideNumber, L"0x%08x", hresult);
		wcstombs(szNumber, szWideNumber, wcslen(szWideNumber));
		szNumber[wcslen(szWideNumber)] = 0;
#endif // XBOX

		this->m_pFailureBreakRules->EnterCritSection();
		for(i = 0; i < this->m_pFailureBreakRules->Count(); i++)
		{
			pBreakRule = (PLSTRING) this->m_pFailureBreakRules->GetItem(i);
			if (pBreakRule == NULL)
			{
				DPL(0, "Couldn't get failure break rule %i!", 1, i);
				this->m_pFailureBreakRules->LeaveCritSection();
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get break rule)

			pszTemp = (char*) LocalAlloc(LPTR, strlen(pBreakRule->GetString()) + 1);
			if (pszTemp == NULL)
			{
				this->m_pFailureBreakRules->LeaveCritSection();
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't get break rule)

			// Ignoring possible return of 0.
			dwNumFields = StringSplitIntoFields(pBreakRule->GetString(), " ",
												pszTemp, NULL);

			fDebugBreak = StringMatchesWithWildcard(StringGetFieldPtr(pszTemp, 0),
													pTest->m_pCase->m_pszID,
													TRUE);
			if ((fDebugBreak) && (dwNumFields >= 2))
			{
				fDebugBreak = StringMatchesWithWildcard(StringGetFieldPtr(pszTemp, 1),
														szNumber,
														TRUE);
			} // end if (only one field)

			LocalFree(pszTemp);
			pszTemp = NULL;

			// If we matched, stop searching.
			if (fDebugBreak)
			{
				DPL(5, "\"%s %x\" matched \"%s\"", 3, pTest->m_pCase->m_pszID, hresult,
					pBreakRule->GetString());
				break;
			} // end if (matched)
		} // end for (each failure break rule)
		this->m_pFailureBreakRules->LeaveCritSection();
	} // end if (we may want to break on this failure)


	// If this doesn't complete the test, then we're done.
	if (! fTestComplete)
		goto SKIP;


	// If we should grab the net stat info, do so.
	if ((! fSuccess) && (this->m_fGetNetStatInfoOnFailure))
	{
		this->GetNetStatInfo();
	} // end if (failed and should grab net stat info)


#ifndef _XBOX // no dumping files supported
	if ((! fSuccess) && (this->m_pszFailureMemDumpDirPath != NULL))
	{
		char*	pszFile;
		DWORD	dwSize;
		char	szNumber[32];
		char	szDate[256];
		char	szTemp[1024];
#ifdef _XBOX // Damn ANSI conversion
		WCHAR	szWideNumber[32];
		WCHAR	szWideTemp[1024];
#endif // XBOX
		

		dwSize = strlen(this->m_pszFailureMemDumpDirPath) + 1; // + NULL termination

		if (! StringEndsWith(this->m_pszFailureMemDumpDirPath, "\\", TRUE))
			dwSize++; // add backslash
		
		dwSize += 16; // "memlog_test_" + ".txt"
		if (pTest->m_pParentTest != NULL) // if a subtest
			dwSize += 3; // "sub"

#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szNumber, "%u", pTest->m_dwUniqueID);
#else // ! XBOX
		swprintf(szWideNumber, L"%u", pTest->m_dwUniqueID);
		wcstombs(szNumber, szWideNumber, wcslen(szWideNumber));
		szNumber[wcslen(szWideNumber)] = 0;
#endif // XBOX

		dwSize += strlen(szNumber);

		pszFile = (char*) LocalAlloc(LPTR, dwSize);
		if (pszFile == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		strcpy(pszFile, this->m_pszFailureMemDumpDirPath);
		if (! StringEndsWith(this->m_pszFailureMemDumpDirPath, "\\", TRUE))
			strcat(pszFile, "\\"); // add backslash

		if (pTest->m_pParentTest == NULL)
			strcat(pszFile, "memlog_test_");
		else
			strcat(pszFile, "memlog_subtest_");

		strcat(pszFile, szNumber);
		strcat(pszFile, ".txt");

		StringGetCurrentDateStr(szDate);
		
		if (pTest->m_pParentTest == NULL)
		{
#ifndef _XBOX // Damn ANSI conversion
			wsprintf(szTemp, "Test %u (case \"%s-%s\", \"%s\") failure mem log dump %s",
				pTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID,
				pTest->m_pszInstanceID,
				pTest->m_pCase->m_pszName,
				szDate);
#else // ! XBOX
			swprintf(szWideTemp, L"Test %u (case \"%s-%s\", \"%s\") failure mem log dump %s",
				pTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID,
				pTest->m_pszInstanceID,
				pTest->m_pCase->m_pszName,
				szDate);
			wcstombs(szTemp, szWideTemp, wcslen(szWideTemp));
			szTemp[wcslen(szWideTemp)] = 0;
#endif // XBOX
		} // end if (there's no test instance ID)
		else
		{
#ifndef _XBOX // Damn ANSI conversion
			wsprintf(szTemp, "Subtest %u (case \"%s\", \"%s\", parent ID is %u) failure mem log dump %s",
					pTest->m_dwUniqueID,
					pTest->m_pCase->m_pszID,
					pTest->m_pCase->m_pszName,
					pTest->m_pParentTest->m_dwUniqueID,
					szDate);
#else // ! XBOX
			swprintf(szWideTemp, L"Subtest %u (case \"%s\", \"%s\", parent ID is %u) failure mem log dump %s",
					pTest->m_dwUniqueID,
					pTest->m_pCase->m_pszID,
					pTest->m_pCase->m_pszName,
					pTest->m_pParentTest->m_dwUniqueID,
					szDate);
			wcstombs(szTemp, szWideTemp, wcslen(szWideTemp));
			szTemp[wcslen(szWideTemp)] = 0;
#endif // XBOX
		} // end if (there is a test instance ID)

		TNDebugDumpMemoryLogToFile(pszFile, szTemp, TRUE);

		LocalFree(pszFile);
		pszFile = NULL;
	} // end if (we should dump the log on failures)
#endif // !	XBOX

	// Update statistics for the test, and the global statistics if it's
	// not a subtest.
	if (fSuccess)
	{
		if (pTest->m_pParentTest == NULL)
			this->m_totalstats.IncrementSuccesses();

		pTest->m_pCase->m_stats.IncrementSuccesses();
	} // end if (its a success report)
	else
	{
		if (pTest->m_pParentTest == NULL)
			this->m_totalstats.IncrementFailures();

		pTest->m_pCase->m_stats.IncrementFailures();
	} // end else (its a failure report)


	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update stats event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update stats event)

#ifndef _XBOX

#pragma BUGBUG(vanceo, "What about ongoing tests?  They'll be top level")
	// Only logged if it was a top level test.
	if (pTest->m_pParentTest == NULL)
	{
		hr = this->EndDBCase(pTest, fSuccess);
		if (hr != S_OK)
		{
			DPL(0, "Failed notify database of test case end!", 0);
			goto DONE;
		} // end if (couldn't end case in DB)
	} // end if (it's a top level slave test)

#endif // ! XBOX

SKIP:

	if (fDebugBreak)
	{
		// Flush the queue, to make sure all outgoing messages are sent before we die.
		hr = this->m_pCtrlComm->FlushSendQueue();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't flush send queue!", 0);
			goto DONE;
		} // end if (failed to flush queue)

		//Ignoring error
		this->Log(TNLST_CRITICAL,
				"Failure for test %u (case %s, \"%s\", result = %x) fits break rules, DEBUGBREAK()-ing.",
				4, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
				pTest->m_pCase->m_pszName, hresult);

		DPL(0, "Failure for test %u (case %s: \"%s\", result = %x) fits break rules, DEBUGBREAK()-ing.",
			4, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
			pTest->m_pCase->m_pszName, hresult);

		DEBUGBREAK();
	} // end if (we should break on this failure)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	return (hr);
} // CTNSlave::ReportInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::WarnInternal()"
//==================================================================================
// CTNSlave::WarnInternal
//----------------------------------------------------------------------------------
//
// Description: Reports a non-fatal warning for a test.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test warning is for.
//	HRESULT hresult				Warning hresult code.
//	PVOID pvUserData			Pointer to optional user data to associate with
//								warning.
//	DWORD dwUserDataSize		Size of user data for warning.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::WarnInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
						PVOID pvUserData, DWORD dwUserDataSize)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTopLevelTest = NULL;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_WARNING	pWarningMsg = NULL;


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test %u!", 1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	DPL(0, "Sending warning for test ID %u:%u, hr = %x",
		3, pTopLevelTest->m_dwUniqueID, pTest->m_dwUniqueID, hresult);

	this->Log(TNLST_CONTROLLAYER_TESTWARNING,
			"Sending warning, %e",
			1, hresult);


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_WARNING)
								+ dwUserDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pWarningMsg = (PCTRLMSG_WARNING) pSendData->m_pvData;
	pWarningMsg->dwSize = pSendData->m_dwDataSize;
	pWarningMsg->dwType = CTRLMSGID_WARNING;

	CopyMemory(&(pWarningMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pWarningMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pWarningMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pWarningMsg->hresult = hresult;
	//pWarningMsg->dwUserDataSize = 0;

	if ((pvUserData != NULL) && (dwUserDataSize > 0))
	{
		pWarningMsg->dwUserDataSize = dwUserDataSize;
		CopyMemory((pWarningMsg + 1), pvUserData, dwUserDataSize);
	} // end if (there's user data)


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below





	this->m_totalstats.IncrementWarnings();
	if (pTest != NULL)
		pTest->m_pCase->m_stats.IncrementWarnings();


	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update stats event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update stats event)



DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSlave::WarnInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::AnnounceSubTest()"
//==================================================================================
// CTNSlave::AnnounceSubTest
//----------------------------------------------------------------------------------
//
// Description: Notifies the master that testing is about to begin on the indicated
//				test (subtest if dwTopLevelUniqueID and dwParentUniqueID are not 0).
//				The master will then reply with a unique ID to assign to the test.
//				This function will block until the response comes in.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test to announce.
//	int iNumMachines			Number of testers in the following array.
//	PTNCTRLMACHINEID aTesters	Array of IDs indicating the testers in their
//								respective testing positions for the new test.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::AnnounceSubTest(PTNTESTINSTANCES pTest, int iNumMachines,
								PTNCTRLMACHINEID aTesters)
{
#pragma BUGBUG(vanceo, "All of this functionality is duplicated in request poke test now")
	HRESULT						hr = S_OK;
	PTNTESTINSTANCES			pTopLevelTest = NULL;
	PTNTESTINSTANCES			pParentTest = NULL;
	DWORD						dwModuleIDSize = 0;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_ANNOUNCESUBTEST	pAnnounceSubTestMsg = NULL;
	LPBYTE						lpCurrent = NULL;
	HANDLE						ahWaitObjects[3];
	DWORD						dwNumWaitObjects = 0;
	DWORD						dwTimeouts = 0;
	int							i;
	int							j;


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!", 1, pTest->m_dwUniqueID);
		return (E_FAIL);
	} // end if (couldn't get top level test)

	//BUGBUG what about poke mode?  will they have parent tests?
	pParentTest = (PTNTESTINSTANCES) pTest->m_pParentTest;
	if (pParentTest == NULL)
	{
		DPL(0, "No parent test for test ID %u!", 1, pTest->m_dwUniqueID);
		return (E_FAIL);
	} // end if (no parent test)


	// We're using them
	pParentTest->m_dwRefCount++;
	pTest->m_dwRefCount++;

	EnterCriticalSection(&(pParentTest->m_csMasterOp));

	pParentTest->m_dwRequestID = this->m_dwCurrentUniqueID++;

	if (pParentTest->m_hResponseEvent != NULL)
	{
		DPL(0, "Get response event already in use!?", 0);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (response event already exists)

	pParentTest->m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pParentTest->m_hResponseEvent == NULL)
	{
		hr = GetLastError();
		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't create get response event!", 0);
		goto DONE;
	} // end if (couldn't create event)


	// Make sure all the specified testers are still alive.
	for(i = 0; i < iNumMachines; i++)
	{
		for(j = 0; j < pParentTest->m_iNumMachines; j++)
		{
			if ((memcmp(&(aTesters[i]), &(pParentTest->m_paTesterSlots[j].id), sizeof (TNCTRLMACHINEID)) == 0) &&
				(pParentTest->m_paTesterSlots[j].fGone))
			{
				DPL(0, "Tester %i of parent test %u has already gone, can't announce sub test!",
					2, j, pParentTest->m_dwUniqueID);
				hr = TNERR_LOSTTESTER;
				goto DONE;
			} // end if (syncing with dead guy)
		} // end for (each parent tester)
	} // end for (each tester)


	DPL(6, "Announcing subtest %u:%u:%s with request ID %u.",
		4, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
		pTest->m_pCase->m_pszID, pParentTest->m_dwRequestID);


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	dwModuleIDSize = strlen(pTest->m_pCase->m_pszID) + 1;

	pSendData->m_dwDataSize = sizeof (CTRLMSG_ANNOUNCESUBTEST)
							+ dwModuleIDSize
							+ (iNumMachines * sizeof (TNCTRLMACHINEID));

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pAnnounceSubTestMsg = (PCTRLMSG_ANNOUNCESUBTEST) pSendData->m_pvData;
	pAnnounceSubTestMsg->dwSize = pSendData->m_dwDataSize;
	pAnnounceSubTestMsg->dwType = CTRLMSGID_ANNOUNCESUBTEST;

	CopyMemory(&(pAnnounceSubTestMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pAnnounceSubTestMsg->dwRequestID = pParentTest->m_dwRequestID;
	pAnnounceSubTestMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pAnnounceSubTestMsg->dwParentUniqueID = pParentTest->m_dwUniqueID;
	pAnnounceSubTestMsg->iNumMachines = iNumMachines;

	lpCurrent = (LPBYTE) (pAnnounceSubTestMsg + 1);
	CopyAndMoveDestPointer(lpCurrent, pTest->m_pCase->m_pszID, dwModuleIDSize);
	CopyAndMoveDestPointer(lpCurrent, aTesters, (iNumMachines * (sizeof (TNCTRLMACHINEID))));

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below

	ahWaitObjects[dwNumWaitObjects++] = pParentTest->m_hResponseEvent;

	if (this->m_executor.m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_executor.m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	dwTimeouts = 0;


REWAIT:

	//BUGBUG need a real timeout?
	hr = WaitForMultipleObjects(dwNumWaitObjects, ahWaitObjects, FALSE,
								IDLE_INTERVAL);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			DPL(7, "Received announcement response event (for %u:%u:%s, it's %u).",
				4, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID, pTest->m_dwUniqueID);

			if (pParentTest->m_hrResponseResult == TNERR_LOSTTESTER)
			{
				// See if any of the testers we're trying to work with died.
				for(i = 0; i < iNumMachines; i++)
				{
					for(j = 0; j < pParentTest->m_iNumMachines; j++)
					{
						if ((memcmp(&(aTesters[i]), &(pParentTest->m_paTesterSlots[j].id), sizeof (TNCTRLMACHINEID)) == 0) &&
							(pParentTest->m_paTesterSlots[j].fGone))
						{
							DPL(0, "Tester %i of parent test %u left, can't announce sub test!",
								2, j, pParentTest->m_dwUniqueID);
							hr = TNERR_LOSTTESTER;
							goto DONE;
						} // end if (syncing with dead guy)
					} // end for (each parent tester)
				} // end for (each tester)

				// If we're here, none of the testers we care about
				// died, so just go back to waiting.

#pragma BUGBUG(vanceo, "Timer sort of reset")
				goto REWAIT;
			} // end if (lost a tester)

			hr = pParentTest->m_hrResponseResult;
		  break;

		case WAIT_OBJECT_0 + 1:
			DPL(0, "Announce wait (for %u:%u:%s) aborted!",
				3, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID);

			hr = TNWR_USERCANCEL;
		  break;

		case WAIT_TIMEOUT:
			dwTimeouts++;


			// Twiddle our thumbs while we're waiting.
			hr = this->DoIdle(CTRLIDLE_ANNOUNCESUBTEST);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't perform the idle activities!", 0);
				goto DONE;
			} // end if (failed idling)


			if (dwTimeouts < TAKINGTOOLONG_NUMINTERVALS_TIMEOUT)
			{
				// If we've been sitting here for a while, print a warning
				if (dwTimeouts > TAKINGTOOLONG_NUMINTERVALS_PRINT)
				{
					DPL(0, "Boy, announce test (for %u:%u:%s) sure is taking an awfully long time...",
						3, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
						pTest->m_pCase->m_pszID);

					this->Log(TNLST_CONTROLLAYER_INFO,
							"Boy, announcing the subtest sure is taking an awfully long time...", 0);
				} // end if (time to print)
				else
				{
					DPL(0, "Still waiting for announce test (for %u:%u:%s) response.",
						3, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
						pTest->m_pCase->m_pszID);
				} // end else (shouldn't print yet)

				goto REWAIT; // go back to waiting
			} // end if (not time to fail yet)

			DPL(0, "Waiting for announcement response (for %u:%u:%s) timed out!",
				3, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID);

			hr = TNWR_TIMEOUT;
		  break;

		default:
			DPL(0, "Received unexpected return from WaitForMultipleObjects!", 0);

			if (hr == S_OK)
				hr = E_FAIL;
		  break;
	} // end switch (on wait result)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have send object)

	if (pParentTest->m_hResponseEvent)
	{
		CloseHandle(pParentTest->m_hResponseEvent);
		pParentTest->m_hResponseEvent = NULL;
	} // end if (have response event)

	pParentTest->m_dwRequestID = 0;
	pParentTest->m_hrResponseResult = E_FAIL;


	LeaveCriticalSection(&(pParentTest->m_csMasterOp));


	pTest->m_dwRefCount--;
	if (pTest->m_dwRefCount == 0)
	{
		DPL(0, "Deleting new sub test %x!?  DEBUGBREAK()-ing.", 1, pTest);
		DEBUGBREAK();
	} // end if (we were the last ones to use the test)
	else
	{
		DPL(7, "Not deleting new sub test %x, refcount is %u.",
			2, pTest, pTest->m_dwRefCount);
	} // end else (not last ones to use test)
	pTest = NULL;


	pParentTest->m_dwRefCount--;
	if (pParentTest->m_dwRefCount == 0)
	{
		DPL(0, "Deleting parent test %x!?", 1, pParentTest);
		DEBUGBREAK();
	} // end if (we were the last ones to use the test)
	else
	{
		DPL(7, "Not deleting parent test %x, refcount is %u.",
			2, pParentTest, pParentTest->m_dwRefCount);
	} // end else (not last ones to use test)
	pParentTest = NULL;

	return (hr);
} // CTNSlave::AnnounceSubTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::SyncInternal()"
//==================================================================================
// CTNSlave::SyncInternal
//----------------------------------------------------------------------------------
//
// Description:    Issues a request to the testmaster to synchronize with specific
//				other machines working on the test (designated in the passed in
//				array).  Data can also be sent to these machines at this time.
//				   A slave is determined to be in-sync when the master has also
//				received sync requests from each of the other testers in the array
//				with the slave specified as a tester to sync with.
//				   This has a domino effect, so that each tester in a slave's sync
//				list must also have heard from all the tester's in its own sync
//				list before marking the first slave as ready.  At that point, the
//				master will fill the return data buffer with the data given by all
//				parties and return with TNSR_INSYNC.
//				   Only one sync attempt is allowed to be outstanding at a time, per
//				unique test ID.  Syncing with your own tester number has no effect.
//				   If this function doesn't return TNSR_INSYNC, it is expected that
//				the test case will end as soon as possible.  Specifically, if
//				TNSR_LOSTTESTER is returned, the test case must not call any Sync
//				or Exec function that requires multiple machines.
//
// Arguments:
//	PTNTESTINSTANCES pTest			Pointer to test to sync under.
//	char* szSyncName				User defined unique name for this sync
//									operation.  Must match on all machines involved.
//	PVOID pvSendData				Pointer to data to send to people to sync with.
//	DWORD dwSendDataSize			Size of data to send to people to sync with.
//	PTNSYNCDATALIST pReceiveData	Pointer to list that will hold the data received
//									from the other synchronizing testers.
//	int iNumMachines				How many testers we're syncing with (i.e. how
//									many integers there are in following array).
//	int* aiTesters					Array of integers indicating the testers to sync
//									with.
//
// Returns: TNSR_INSYNC if successful, or TNSR_xxx error code otherwise.
//==================================================================================
HRESULT CTNSlave::SyncInternal(PTNTESTINSTANCES pTest,
								char* szSyncName,
								PVOID pvSendData,
								DWORD dwSendDataSize,
								PTNSYNCDATALIST pReceiveData,
								int iNumMachines,
								int* aiTesters)
{
	HRESULT					hr = S_OK;
	PTNTESTINSTANCES		pTopLevelTest = NULL;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_REQUESTSYNC	pRequestSyncMsg = NULL;
	LPBYTE					lpCurrent;
#ifndef _XBOX // no messaging supported
	MSG						msg;
#endif // ! XBOX
	HANDLE					ahWaitObjects[3];
	DWORD					dwNumWaitObjects = 0;
	int						i;
	DWORD					dwLastIdleTime = 0;



	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test %u!", 1, pTest->m_dwUniqueID);
		return (E_FAIL);
	} // end if (couldn't get top level test)


	pTest->m_dwRefCount++; // we're using it

	EnterCriticalSection(&(pTest->m_csMasterOp));

	pTest->m_dwRequestID = this->m_dwCurrentUniqueID++;

	if (pTest->m_hResponseEvent != NULL)
	{
		DPL(0, "Test ID %u's response event already in use?!",
			1, pTest->m_dwUniqueID);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (we're already syncing)

	pTest->m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pTest->m_hResponseEvent == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't create sync event for test ID %u!",
			1, pTest->m_dwUniqueID);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't create event)

	// Assume that this will not exist if the event didn't already exist either.
	pTest->m_pSyncDataList = pReceiveData;


	// Make sure all the specified testers are still alive.
	for(i = 0; i < iNumMachines; i++)
	{
		if (pTest->m_paTesterSlots[aiTesters[i]].fGone)
		{
			DPL(0, "Tester %i has already gone, can't sync!",
				1, aiTesters[i]);
			hr = TNSR_LOSTTESTER;
			goto DONE;
		} // end if (syncing with dead guy)
	} // end for (each tester)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_REQUESTSYNC)
							+ strlen(szSyncName) + 1
							+ (iNumMachines * sizeof (int))
							+ dwSendDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pRequestSyncMsg = (PCTRLMSG_REQUESTSYNC) pSendData->m_pvData;
	pRequestSyncMsg->dwSize = pSendData->m_dwDataSize;
	pRequestSyncMsg->dwType = CTRLMSGID_REQUESTSYNC;

	CopyMemory(&(pRequestSyncMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pRequestSyncMsg->dwRequestID = pTest->m_dwRequestID;
	pRequestSyncMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pRequestSyncMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pRequestSyncMsg->dwNameSize = strlen(szSyncName) + 1;
	pRequestSyncMsg->iNumMachines = iNumMachines;
	pRequestSyncMsg->dwDataSize = dwSendDataSize;

	lpCurrent = (LPBYTE) (pRequestSyncMsg + 1);

	CopyAndMoveDestPointer(lpCurrent, szSyncName, strlen(szSyncName) + 1);
	CopyAndMoveDestPointer(lpCurrent, aiTesters, iNumMachines * (sizeof (int)));


	if (pvSendData != NULL)
	{
		CopyAndMoveDestPointer(lpCurrent, pvSendData, dwSendDataSize);
	} // end if (there's data to send)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below

	ahWaitObjects[dwNumWaitObjects++] = pTest->m_hResponseEvent;

	if (this->m_executor.m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_executor.m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


	dwLastIdleTime = GetTickCount();


REWAIT:
	// Make sure the test thread still looks alive
	this->m_executor.m_dwLastTestthreadPing = GetTickCount();


#ifndef _XBOX // no message functions supported
	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)
#else // !XBOX
#pragma TODO(tristanj, "Removing message pump may affect things if TAPI isn't removed")
#endif // XBOX



	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								MESSAGE_PUMP_CHECK_INTERVAL, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			DPL(2, "Test ID %u:%u \"%s\" received sync response (result = %x).",
				4, pTopLevelTest->m_dwUniqueID, pTest->m_dwUniqueID,
				szSyncName, pTest->m_hrResponseResult);

			if (pTest->m_hrResponseResult == S_OK)
			{
				hr = TNSR_INSYNC;
				goto DONE;
			} // end if (successful)

			if (pTest->m_hrResponseResult == TNERR_LOSTTESTER)
			{
				for(i = 0; i < iNumMachines; i++)
				{
					if (pTest->m_paTesterSlots[aiTesters[i]].fGone)
					{
						DPL(0, "Lost a tester we're syncing with (%i)!",
							1, aiTesters[i]);
						hr = TNSR_LOSTTESTER;
						goto DONE;
					} // end if (syncing with dead guy)
				} // end for (each tester)

				// If we got here, it means we aren't doing anything with
				// that guy, so who cares?
				goto REWAIT;
			} // end if (lost a tester)
			

			// Some generic failure
			hr = pTest->m_hrResponseResult;
			DPL(0, "Failed synchronizing \"%s\" under test ID %u!  %E",
				3, szSyncName, pTest->m_dwUniqueID, hr);
		  break;

		case WAIT_OBJECT_0 + 1:
			DPL(0, "Test ID %u \"%s\" sync wait aborted.", 2, pTest->m_dwUniqueID,
				szSyncName);

			hr = TNSR_USERCANCEL;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			if (GetTickCount() > (dwLastIdleTime + IDLE_INTERVAL))
			{
				// Twiddle our thumbs while we're waiting.
				hr = this->DoIdle(CTRLIDLE_SYNC);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't perform the idle activities!", 0);
					goto DONE;
				} // end if (failed idling)

				dwLastIdleTime = GetTickCount();
			} // end if (time to idle again)

			goto REWAIT;
		  break;

		default:
			DPL(0, "Sync wait for test ID %u \"%s\" received unexpected return from WaitForMultipleObjects!",
				2, pTest->m_dwUniqueID, szSyncName);
		  break;
	} // end switch (on wait result)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	if (pTest->m_hResponseEvent != NULL)
	{
		CloseHandle(pTest->m_hResponseEvent);
		pTest->m_hResponseEvent = NULL;
	} // end if (we have response event)

	pTest->m_dwRequestID = 0;
	pTest->m_hrResponseResult = E_FAIL;

	pTest->m_pSyncDataList = NULL; // forget about the list

	LeaveCriticalSection(&pTest->m_csMasterOp);

		
	pTest->m_dwRefCount--;
	if (pTest->m_dwRefCount == 0)
	{
		DPL(0, "Deleting test %x!?", 1, pTest);
		delete (pTest);
	} // end if (we were the last ones to use the test)
	pTest = NULL;

	return (hr);
} // CTNSlave::SyncInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::IsTesterOnSameMachineInternal()"
//==================================================================================
// CTNSlave::IsTesterOnSameMachineInternal
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the given tester is located on this same machine,
//				FALSE if not.
//
// Arguments:
//	int iTesterNum		Tester number to check.
//
// Returns: TRUE if tester is on same machine, FALSE otherwise.
//==================================================================================
BOOL CTNSlave::IsTesterOnSameMachineInternal(PTNTESTINSTANCES pTest,
											int iTesterNum)
{
#ifndef _XBOX // no multiple local slaves, so no tester can be on the same machine...
	BOOL					fResult = FALSE;
	HRESULT					hr;
	int						i;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;


	if (this->m_hMultiInstanceMutex == NULL)
	{
		DPL(0, "No mutex!", 0);
		goto DONE;
	} // end if (no mutex)

	if (this->m_hMultiInstanceMMFile == NULL)
	{
		DPL(0, "No memory mapped file!", 0);
		goto DONE;
	} // end if (no mm file)

	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not checking if tester %i of test %u is on same machine because he has already left the test!",
			3, iTesterNum, pTest->m_dwUniqueID);
		goto DONE;
	} // end if (the tester is already gone)


	// Grab the lock
	WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);

	// Map the file
	pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pMultiInstanceInfo == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto DONE;
	} // end if (couldn't map view of file)


	// Loop through each instance slot looking for one with the right IDs.
	for(i = 0; i < MAX_NUM_LOCAL_INSTANCES; i++)
	{
		// Skip our index.
		if (i == this->m_iInstanceIndex)
			continue;

		// Skip empty indices.
		if (! pMultiInstanceInfo->aInstances[i].fInUse)
			continue;

		// If the session and slave IDs match, we found the guy.
		if ((pMultiInstanceInfo->aInstances[i].dwSessionID == this->m_dwSessionID) &&
			(memcmp(&(pMultiInstanceInfo->aInstances[i].id), &(pTest->m_paTesterSlots[iTesterNum].id), sizeof (TNCTRLMACHINEID)) == 0))
		{
			fResult = TRUE;
			break;
		} // end if (found the ID)
	} // end for (each instance slot)


	// Unmap our view.
	UnmapViewOfFile(pMultiInstanceInfo);
	pMultiInstanceInfo = NULL;

	// Drop the lock we took.
	ReleaseMutex(this->m_hMultiInstanceMutex);


DONE:

	return (fResult);
#else // ! XBOX
	return FALSE;
#endif // XBOX
} // CTNSlave::IsTesterOnSameMachineInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTestersIPForPortInternal()"
//==================================================================================
// CTNSlave::GetTestersIPForPortInternal
//----------------------------------------------------------------------------------
//
// Description: Retrieves the IP address of the specified tester and places it in
//				the passed in string buffer.  The buffer must be at least 15
//				characters + NULL termination long.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve IP address.
//	WORD wPort				IP port used to verify reachability.
//	char* szIPString		String to store results in (must be 16 chars).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetTestersIPForPortInternal(PTNTESTINSTANCES pTest,
											int iTesterNum, WORD wPort,
											char* szIPString)
{
	HRESULT					hr = S_OK;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;


#pragma BUGBUG(vanceo, "Do we want this here or at every level maybe?")
	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not getting IP for tester %i of test %u on port %u because he has already left the test!",
			3, iTesterNum, pTest->m_dwUniqueID, wPort);
		hr = TNERR_LOSTTESTER;
		goto DONE;
	} // end if (the tester is already gone)


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pTest->m_paTesterSlots[iTesterNum].id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
			2, iTesterNum, pTest->m_dwUniqueID);
		this->Log(TNLST_CRITICAL,
					"Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
					2, iTesterNum, pTest->m_dwUniqueID);
		hr = ERROR_NOT_FOUND;
		goto DONE;
	} // end if (couldn't get reach check target)


	// Loop through all the reach checks performed on the tester til we find the
	// right kind.
	for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
	{
		pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
		if (pReachCheck == NULL)
		{
			DPL(0, "Couldn't get reach check %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get reach check target)

#pragma BUGBUG(vanceo, "Check for specific IP method?")
		if ((pReachCheck->m_dwMethod == TNRCM_UDPBROADCAST) ||
			(pReachCheck->m_dwMethod == TNRCM_UDP) ||
			(pReachCheck->m_dwMethod == TNRCM_UDP))
		{
#ifdef DEBUG
			if (pReachCheck->m_dwMethodDataSize != sizeof (WORD))
			{
				DPL(0, "IP reach check method data size is not correct (%u != %u)!  DEBUGBREAK()-ing.",
					2, pReachCheck->m_dwMethodDataSize, sizeof (WORD));

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (not a valid item)

			// If this is triggered, it's almost certainly because the user's CanRun
			// function is not correctly rejecting permutations which failed the IP
			// reach check.
			if (pReachCheck->m_dwAddressSize != sizeof (IN_ADDR))
			{
				DPL(0, "IP reach check address size is not correct (%u != %u)!  Are you sure the CanRun function is correctly rejecting invalid permutations?  DEBUGBREAK()-ing.",
					2, pReachCheck->m_dwAddressSize, sizeof (IN_ADDR));

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (not a valid item)
#endif // DEBUG

			// If it's on the same port and it's successful, we got the result
			// we want.
			if (*((WORD*) pReachCheck->m_pvMethodData) == wPort)
			{
				if (pReachCheck->m_fResult)
				{
					strcpy(szIPString,
							inet_ntoa(*((IN_ADDR*) pReachCheck->m_pvAddress)));

					DPL(2, "Tester %i (test %u)'s IP address (reachable on port %u) is \"%s\".",
						4, iTesterNum, pTest->m_dwUniqueID, wPort, szIPString);
				} // end if (succeeded)
				else
				{
					DPL(0, "Tester %i (test %u) was found to be unreachable on port %u!",
						3, iTesterNum, pTest->m_dwUniqueID, wPort);
				} // end else (failed)

				// We found the item we want, we're done.
				goto DONE;
			} // end if (matched port)
			else
			{
				DPL(7, "Tester %i (test %u) was %seachable on port %u, but we're looking for port %u.",
					5, iTesterNum,
					pTest->m_dwUniqueID,
					((pReachCheck->m_fResult) ? "r" : "unr"),
					*((WORD*) pReachCheck->m_pvMethodData),
					wPort);
			} // end else (didn't match port)
		} // end if (found IP method)
	} // end for (each reach check)


	// If we got here, it means we couldn't find any pertinent reach checks.

	DPL(0, "Couldn't find any IP reach checks for tester %i of test %u on port %u!  Are you sure the master verified reachability?",
		3, iTesterNum, pTest->m_dwUniqueID, wPort);
	this->Log(TNLST_CRITICAL,
				"Couldn't find any IP reach checks for tester %i of test %u on port %u!  Are you sure the master verified reachability?",
				3, iTesterNum, pTest->m_dwUniqueID, wPort);
	hr = ERROR_NOT_FOUND;

DONE:

	return (hr);
} // CTNSlave::GetTestersIPForPortInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTestersPhoneNumInternal()"
//==================================================================================
// CTNSlave::GetTestersPhoneNumInternal
//----------------------------------------------------------------------------------
//
// Description: Returns the phone number of the specified tester number in the given
//				string buffer.  It is assumed to be large enough.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve phone number.
//	char* szPhoneNumber		String to store result in.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetTestersPhoneNumInternal(PTNTESTINSTANCES pTest,
											int iTesterNum, char* szPhoneNumber)
{
	HRESULT					hr = S_OK;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;


#pragma BUGBUG(vanceo, "Do we want this here or at every level maybe?")
	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not getting phone number for tester %i of test %u because he has already left the test!",
			2, iTesterNum, pTest->m_dwUniqueID);
		hr = TNERR_LOSTTESTER;
		goto DONE;
	} // end if (the tester is already gone)


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pTest->m_paTesterSlots[iTesterNum].id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
			2, iTesterNum, pTest->m_dwUniqueID);
		this->Log(TNLST_CRITICAL,
					"Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
					2, iTesterNum, pTest->m_dwUniqueID);
		hr = ERROR_NOT_FOUND;
		goto DONE;
	} // end if (couldn't get reach check target)


	// Loop through all the reach checks performed on the tester til we find
	// the right kind.
	for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
	{
		pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
		if (pReachCheck == NULL)
		{
			DPL(0, "Couldn't get reach check %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get reach check target)

		if (pReachCheck->m_dwMethod == TNRCM_MODEM)
		{
			// This is the result we want, success or failure.
			if (pReachCheck->m_fResult)
			{
#pragma BUGBUG(vanceo, "Don't assume buffer is large enough, improve behavior")
				strcpy(szPhoneNumber, (char*) pReachCheck->m_pvAddress);

				DPL(2, "Tester %i (test %u)'s reachable phone number is \"%s\".",
					3, iTesterNum, pTest->m_dwUniqueID, szPhoneNumber);
			} // end if (succeeded)
			else
			{
				DPL(0, "Tester %i (test %u) was found to be unreachable via modem!",
					2, iTesterNum, pTest->m_dwUniqueID);
			} // end else (failed)

			// We found the item we want, we're done.
			goto DONE;
		} // end if (found modem method)
	} // end for (each reach check)


	// If we got here, it means we couldn't find any pertinent reach checks.

	DPL(0, "Couldn't find any modem reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
		2, iTesterNum, pTest->m_dwUniqueID);
	this->Log(TNLST_CRITICAL,
				"Couldn't find any modem reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
				2, iTesterNum, pTest->m_dwUniqueID);
	hr = ERROR_NOT_FOUND;


DONE:

	return (hr);
} // CTNSlave::GetTestersPhoneNumInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTestersCOMPortInternal()"
//==================================================================================
// CTNSlave::GetTestersCOMPortInternal
//----------------------------------------------------------------------------------
//
// Description: Returns the COM port connected to the specified tester in the DWORD
//				pointer given.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve COM port.
//	DWORD* pdwCOMPort		Place to store result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetTestersCOMPortInternal(PTNTESTINSTANCES pTest,
											int iTesterNum, DWORD* pdwCOMPort)
{
	HRESULT					hr = S_OK;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;


#pragma BUGBUG(vanceo, "Do we want this here or at every level maybe?")
	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not getting COM port for tester %i of test %u because he has already left the test!",
			2, iTesterNum, pTest->m_dwUniqueID);
		hr = TNERR_LOSTTESTER;
		goto DONE;
	} // end if (the tester is already gone)


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pTest->m_paTesterSlots[iTesterNum].id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
			2, iTesterNum, pTest->m_dwUniqueID);
		this->Log(TNLST_CRITICAL,
					"Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
					2, iTesterNum, pTest->m_dwUniqueID);
		hr = ERROR_NOT_FOUND;
		goto DONE;
	} // end if (couldn't get reach check target)


	// Loop through all the reach checks performed on the tester til we find
	// the right kind.
	for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
	{
		pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
		if (pReachCheck == NULL)
		{
			DPL(0, "Couldn't get reach check %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get reach check target)

		if (pReachCheck->m_dwMethod == TNRCM_SERIAL)
		{
			// This is the result we want, success or failure.
			if (pReachCheck->m_fResult)
			{
				(*pdwCOMPort) = *((DWORD*) pReachCheck->m_pvAddress);

				DPL(2, "Tester %i (test %u)'s is reachable via COM port %u.",
					3, iTesterNum, pTest->m_dwUniqueID, (*pdwCOMPort));
			} // end if (succeeded)
			else
			{
				DPL(0, "Tester %i (test %u) was found to be unreachable via serial!",
					2, iTesterNum, pTest->m_dwUniqueID);
			} // end else (failed)

			// We found the item we want, we're done.
			goto DONE;
		} // end if (found serial method)
	} // end for (each reach check)


	// If we got here, it means we couldn't find any pertinent reach checks.

	DPL(0, "Couldn't find any serial reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
		2, iTesterNum, pTest->m_dwUniqueID);
	this->Log(TNLST_CRITICAL,
				"Couldn't find any serial reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
				2, iTesterNum, pTest->m_dwUniqueID);
	hr = ERROR_NOT_FOUND;


DONE:

	return (hr);
} // CTNSlave::GetTestersCOMPortInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::SendFreeOutputVars()"
//==================================================================================
// CTNSlave::SendFreeOutputVars
//----------------------------------------------------------------------------------
//
// Description: Tells the master to free the output variables identified so it will
//				have the same list as the slave.
//
// Arguments:
//	char* pszCaseID			Case ID to match, if any.
//	char* pszInstanceID		Instance ID to match, if any.
//	char* pszName			Variable name to match, if any.
//	char* pszType			Variable type to match, if any.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::SendFreeOutputVars(char* pszCaseID, char* pszInstanceID,
									char* pszName, char* pszType)
{
	HRESULT						hr;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_FREEOUTPUTVARS		pFreeOutputVarsMsg = NULL;
	LPBYTE						lpCurrent;



	if (((PCOMMDATA) this->m_pvTestmasterCommData)->fDropped)
	{
		DPL(0, "Can't send ready of first test message to master because the connection went down!", 0);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to master went down)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_FREEOUTPUTVARS);
	if (pszCaseID != NULL)
		pSendData->m_dwDataSize += strlen(pszCaseID) + 1;
	if (pszInstanceID != NULL)
		pSendData->m_dwDataSize += strlen(pszInstanceID) + 1;
	if (pszName != NULL)
		pSendData->m_dwDataSize += strlen(pszName) + 1;
	if (pszType != NULL)
		pSendData->m_dwDataSize += strlen(pszType) + 1;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pFreeOutputVarsMsg = (PCTRLMSG_FREEOUTPUTVARS) pSendData->m_pvData;
	pFreeOutputVarsMsg->dwSize = pSendData->m_dwDataSize;
	pFreeOutputVarsMsg->dwType = CTRLMSGID_FREEOUTPUTVARS;

	CopyMemory(&(pFreeOutputVarsMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));

	lpCurrent = (LPBYTE) (pFreeOutputVarsMsg + 1);

	if (pszCaseID != NULL)
	{
		pFreeOutputVarsMsg->dwCaseIDSize = strlen(pszCaseID) + 1;

		CopyAndMoveDestPointer(lpCurrent, pszCaseID,
								pFreeOutputVarsMsg->dwCaseIDSize);
	} // end if (there's a case ID)

	if (pszInstanceID != NULL)
	{
		pFreeOutputVarsMsg->dwInstanceIDSize = strlen(pszInstanceID) + 1;

		CopyAndMoveDestPointer(lpCurrent, pszInstanceID,
								pFreeOutputVarsMsg->dwInstanceIDSize);
	} // end if (there's an instance ID)

	if (pszName != NULL)
	{
		pFreeOutputVarsMsg->dwNameSize = strlen(pszName) + 1;

		CopyAndMoveDestPointer(lpCurrent, pszName,
								pFreeOutputVarsMsg->dwNameSize);
	} // end if (there's a name)

	if (pszType != NULL)
	{
		pFreeOutputVarsMsg->dwTypeSize = strlen(pszType) + 1;

		CopyAndMoveDestPointer(lpCurrent, pszType,
								pFreeOutputVarsMsg->dwTypeSize);
	} // end if (there's a type)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNSlave::SendFreeOutputVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTestersMachineInfoInternal()"
//==================================================================================
// CTNSlave::GetTestersMachineInfoInternal
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the machine info for the specified tester.
//				NOTE: The caller must release a reference to the object when done
//				with it.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve COM port.
//	PTNMACHINEINFO* ppInfo	Place to store result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetTestersMachineInfoInternal(PTNTESTINSTANCES pTest,
												int iTesterNum,
												PTNMACHINEINFO* ppInfo)
{
	HRESULT						hr = S_OK;
	PTNOTHERMACHINEINFO			pOtherInfo = NULL;
	BOOL						fTookMasterOpLock = FALSE;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_GETMACHINEINFO		pGetMachineInfoMsg = NULL;
	HANDLE						ahWaitObjects[3];
	DWORD						dwNumWaitObjects = 0;
#ifndef _XBOX // no messaging supported
	MSG							msg;
#endif // ! XBOX

#pragma BUGBUG(vanceo, "Do we want this here or at every level maybe?")
	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not getting machine info for tester %i of test %u because he has already left the test!",
			2, iTesterNum, pTest->m_dwUniqueID);
		hr = TNERR_LOSTTESTER;
		goto DONE;
	} // end if (the tester is already gone)


	pOtherInfo = this->m_otherinfos.GetInfoForMachine(&(pTest->m_paTesterSlots[iTesterNum].id));
	if (pOtherInfo != NULL)
	{
		DPL(9, "Already retrieved tester %i's info, returning object %x.",
			2, iTesterNum, pOtherInfo);

		// Increment a ref for the user.
		pOtherInfo->m_dwRefCount++;

		(*ppInfo) = pOtherInfo;
		pOtherInfo = NULL;

		goto DONE;
	} // end if (found info)


	// If we got here, it means we couldn't find the machine info in our
	// previously retrieved list.  We have to ask the master for it now.

	DPL(0, "Couldn't find machine info for tester %i of test %u, requesting from master.",
		2, iTesterNum, pTest->m_dwUniqueID);

	EnterCriticalSection(&(pTest->m_csMasterOp));
	fTookMasterOpLock = TRUE;

	pTest->m_dwRequestID = this->m_dwCurrentUniqueID++;

	if (pTest->m_hResponseEvent != NULL)
	{
		DPL(0, "Test ID %u's response event already in use?!",
			1, pTest->m_dwUniqueID);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (we're already syncing)

	pTest->m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pTest->m_hResponseEvent == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't create response event for test ID %u!",
			1, pTest->m_dwUniqueID);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't create event)

	pOtherInfo = new (CTNOtherMachineInfo)(&(pTest->m_paTesterSlots[iTesterNum].id));

	pOtherInfo->m_dwRefCount += 2; // 1 for pOtherInfo, 1 for pTest->m_pReturnedInfo
	pTest->m_pReturnedInfo = pOtherInfo;



	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_GETMACHINEINFO);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pGetMachineInfoMsg = (PCTRLMSG_GETMACHINEINFO) pSendData->m_pvData;
	pGetMachineInfoMsg->dwSize = pSendData->m_dwDataSize;
	pGetMachineInfoMsg->dwType = CTRLMSGID_GETMACHINEINFO;

	CopyMemory(&(pGetMachineInfoMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pGetMachineInfoMsg->dwRequestID = pTest->m_dwRequestID;
	CopyMemory(&(pGetMachineInfoMsg->idMachineForInfo),
				&(pTest->m_paTesterSlots[iTesterNum].id),
				sizeof (TNCTRLMACHINEID));

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below

	ahWaitObjects[dwNumWaitObjects++] = pTest->m_hResponseEvent;

	if (this->m_executor.m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_executor.m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


REWAIT:
	// Make sure the test thread still looks alive
	this->m_executor.m_dwLastTestthreadPing = GetTickCount();


#ifndef _XBOX // no message functions supported
	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)
#else // !XBOX
#pragma TODO(tristanj, "Removing message pump may affect things if TAPI isn't removed")
#endif // XBOX


	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								MESSAGE_PUMP_CHECK_INTERVAL, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			DPL(2, "Test ID %u received GetMachineInfo response (%x).",
				2, pTest->m_dwUniqueID, pTest->m_hrResponseResult);

			hr = pTest->m_hrResponseResult;
			if (hr == S_OK)
			{
				// Add it to the cache, and return.
				hr = this->m_otherinfos.Add(pOtherInfo);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add other info %x to list!", 1, pOtherInfo);
					goto DONE;
				} // end if (failed adding item to list)

				(*ppInfo) = pOtherInfo;
				pOtherInfo = NULL;

				goto DONE;
			} // end if (successful)

			if (hr != TNERR_LOSTTESTER)
			{
				// Some generic failure
				DPL(0, "Got unexpected error while retrieving machine info for %i under test ID %u!  %E",
					3, iTesterNum, pTest->m_dwUniqueID, hr);
				goto DONE;
			} // end if (not lost a tester error)

			if (pTest->m_paTesterSlots[iTesterNum].fGone)
			{
				DPL(0, "Lost the tester we're retrieving info for (%i)!",
					1, iTesterNum);
				hr = TNWR_LOSTTESTER;
				goto DONE;
			} // end if (syncing with dead guy)

			// If we got here, it means we aren't doing anything with
			// that guy, so who cares?
			goto REWAIT;
		  break;

		case WAIT_OBJECT_0 + 1:
			DPL(0, "Test ID %u GetMachineInfo wait aborted.", 1, pTest->m_dwUniqueID);

			hr = TNWR_USERCANCEL;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			goto REWAIT;
		  break;

		default:
			DPL(0, "Machine info (tester %i) wait for test ID %u received unexpected return from WaitForMultipleObjects!",
				2, iTesterNum, pTest->m_dwUniqueID);
		  break;
	} // end switch (on wait result)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	if (pTest->m_hResponseEvent != NULL)
	{
		CloseHandle(pTest->m_hResponseEvent);
		pTest->m_hResponseEvent = NULL;
	} // end if (we have response event)

	pTest->m_dwRequestID = 0;
	pTest->m_hrResponseResult = E_FAIL;

	if (pTest->m_pReturnedInfo != NULL)
	{
		pTest->m_pReturnedInfo->m_dwRefCount--;
		if (pTest->m_pReturnedInfo->m_dwRefCount == 0)
		{
			DPL(7, "Deleting other machine info %x (test's returned info).", 1, pTest->m_pReturnedInfo);
			delete (pTest->m_pReturnedInfo);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting other machine info %x (test's returned info), its refcount is %u.",
				2, pTest->m_pReturnedInfo, pTest->m_pReturnedInfo->m_dwRefCount);
		} // end else (not last reference)
		pTest->m_pReturnedInfo = NULL;
	} // end if (still have info object)

	if (pOtherInfo != NULL)
	{
		pOtherInfo->m_dwRefCount--;
		if (pOtherInfo->m_dwRefCount == 0)
		{
			DPL(7, "Deleting other machine info %x (pOtherInfo).", 1, pOtherInfo);
			delete (pOtherInfo);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting other machine info %x (pOtherInfo), its refcount is %u.",
				2, pOtherInfo, pOtherInfo->m_dwRefCount);
		} // end else (not last reference)
		pOtherInfo = NULL;
	} // end if (still have info object)

	if (fTookMasterOpLock)
	{
		fTookMasterOpLock = FALSE;
		LeaveCriticalSection(&pTest->m_csMasterOp);
	} // end if (took lock)

	return (hr);
} // CTNSlave::GetTestersMachineInfoInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::PeriodicSendExpired()"
//==================================================================================
// CTNSlave::PeriodicSendExpired
//----------------------------------------------------------------------------------
//
// Description: Function that gets called whenever a periodic send expires.  It
//				does whatever processing is appropriate and removes the send from
//				the list.
//
// Arguments:
//	PTNPERIODICSEND pPeriodicSend	Pointer to send that expired.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::PeriodicSendExpired(PTNPERIODICSEND pPeriodicSend)
{
	HRESULT					hr;
	PVOID					pvAddress = NULL;
	DWORD					dwAddressSize = 0;
	BOOL					fFreeContext = TRUE;
	PREACHCHECKCONTEXT		pRCContext = NULL;


	switch (((PPERIODICSENDCONTEXT) pPeriodicSend->m_pvUserContext)->dwType)
	{
		case PSCT_QUERYMETAMASTER:
			DPL(0, "Failed to query meta-master for sessions!", 0);
			this->Log(TNLST_CRITICAL, "Failed to query meta-master for sessions!", 0);

			this->m_fQueryingMetaMaster = FALSE;

			// Ping the UI to let it know
			if (! SetEvent(this->m_hCompletionOrUpdateEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set event %x!", 1, this->m_hCompletionOrUpdateEvent);
				goto DONE;
			} // end if (couldn't set event)

			this->m_pSessionPeriodicSend->m_dwRefCount--;
			// This should never hit 0, because it should be the same as the passed
			// in pPeriodicSend, and our caller has a reference to that.
			if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
			{
				DPL(0, "Deleting session periodic send (%x)!?  DEBUGBREAK()-ing.",
					1, this->m_pSessionPeriodicSend->m_dwRefCount);

				DEBUGBREAK();

				delete (this->m_pSessionPeriodicSend);
			} // end if (last reference)

			this->m_pSessionPeriodicSend = NULL;
		  break;

		case PSCT_JOINDIRECT:
			DPL(0, "Failed to join the specified master!", 0);
			this->Log(TNLST_CRITICAL, "Failed to join the specified master!", 0);

			this->m_fShakingHands = FALSE;

			// Ping the UI to let it know
			if (! SetEvent(this->m_hCompletionOrUpdateEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set event %x!", 1, this->m_hCompletionOrUpdateEvent);
				goto DONE;
			} // end if (couldn't set event)

			this->m_pSessionPeriodicSend->m_dwRefCount--;
			// This should never hit 0, because it should be the same as the passed
			// in pPeriodicSend, and our caller has a reference to that.
			if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
			{
				DPL(0, "Deleting session periodic send (%x)!?  DEBUGBREAK()-ing.",
					1, this->m_pSessionPeriodicSend->m_dwRefCount);

				DEBUGBREAK();

				delete (this->m_pSessionPeriodicSend);
			} // end if (last reference)

			this->m_pSessionPeriodicSend = NULL;
		  break;

		case PSCT_ENUM:
			DPL(0, "Failed to find any sessions by broadcasting!", 0);
			this->Log(TNLST_CRITICAL, "Failed to find any sessions by broadcasting!", 0);

			this->m_fReadyToConnect = FALSE;

			// Ping the UI to let it know
			if (! SetEvent(this->m_hCompletionOrUpdateEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set event %x!", 1, this->m_hCompletionOrUpdateEvent);
				goto DONE;
			} // end if (couldn't set event)


			this->m_pSessionPeriodicSend->m_dwRefCount--;
			// This should never hit 0, because it should be the same as the passed
			// in pPeriodicSend, and our caller has a reference to that.
			if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
			{
				DPL(0, "Deleting session periodic send (%x)!?  DEBUGBREAK()-ing.",
					1, this->m_pSessionPeriodicSend->m_dwRefCount);

				DEBUGBREAK();

				delete (this->m_pSessionPeriodicSend);
			} // end if (last reference)

			this->m_pSessionPeriodicSend = NULL;
		  break;

		case PSCT_REACHCHECK:
			pRCContext = (PREACHCHECKCONTEXT) pPeriodicSend->m_pvUserContext;

			if (pRCContext->dwCurrentAddressString == pRCContext->dwTotalAddressStrings)
			{
				DPL(0, "WARNING: All %u reach check address strings have been tried with no response!",
					1, pRCContext->dwTotalAddressStrings);

				this->Log(TNLST_CRITICAL,
						"WARNING: All reach check address strings have been tried with no response!", 0);


				// Complete the result.
				hr = this->DoConnectReachCheckResult(pRCContext->pReachCheck,
													FALSE,
													WAIT_TIMEOUT,
													NULL, 0);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't send ConnectReachCheckReply message!", 0);
					//goto DONE;
				} // end if (couldn't send message)

				// Context will get cleaned up below.

			} // end if (no more address strings)
			else
			{
				char*							pszTemp;
				PCTRLMSG_INTERSLAVEREACHCHECK	pInterSlaveReachCheckMsg;
				DWORD							dwMsgSize;



				// Remove the reach check's reference to the periodic send.  It
				// should not be being deleted right now (because it's also
				// being passed in, so our caller must have a ref).
#ifdef DEBUG
				// Make sure it's the expected periodic send.
				if (pRCContext->pReachCheck->m_pPeriodicSend != pPeriodicSend)
				{
					DPL(0, "Reach check's periodic send (%x) is not the same as one passed in (%x)!  DEBUGBREAK()-ing.",
						2, pRCContext->pReachCheck->m_pPeriodicSend,
						pPeriodicSend);
					DEBUGBREAK();
				} // end if (reach checks differ)
#endif // DEBUG

				pRCContext->pReachCheck->m_pPeriodicSend->m_dwRefCount--;
				if (pRCContext->pReachCheck->m_pPeriodicSend->m_dwRefCount == 0)
				{
					DPL(0, "Deleting periodic send %x!?  DEBUGBREAK()-ing",
						1, pRCContext->pReachCheck->m_pPeriodicSend);
					DEBUGBREAK();
					//delete (pReachCheck->m_pPeriodicSend);
				} // end if (can delete item)
				else
				{
					DPL(7, "Not deleting periodic send %x, it's refcount is %u.",
						2, pRCContext->pReachCheck->m_pPeriodicSend,
						pRCContext->pReachCheck->m_pPeriodicSend->m_dwRefCount);
				} // end else (can't delete item)
				pRCContext->pReachCheck->m_pPeriodicSend = NULL;



				// Increment counter after get field pointer cause offset is
				// zero-based.  16 is the size of each entry.
				pszTemp = pRCContext->pszAddressStrings
						+ (pRCContext->dwCurrentAddressString * 16);

				pRCContext->dwCurrentAddressString++;

				DPL(1, "Trying address string %u of %u (\"%s\").",
					3, pRCContext->dwCurrentAddressString,
					pRCContext->dwTotalAddressStrings,
					pszTemp);


				// Ignore error, assume BUFFER_TOO_SMALL
				pPeriodicSend->m_pCtrlComm->ConvertStringToAddress(pszTemp,
																	pRCContext->pReachCheck->m_pvMethodData,
																	pRCContext->pReachCheck->m_dwMethodDataSize,
																	pvAddress,
																	&dwAddressSize);

				pvAddress = LocalAlloc(LPTR, dwAddressSize);
				if (pvAddress == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				hr = pPeriodicSend->m_pCtrlComm->ConvertStringToAddress(pszTemp,
																		pRCContext->pReachCheck->m_pvMethodData,
																		pRCContext->pReachCheck->m_dwMethodDataSize,
																		pvAddress,
																		&dwAddressSize);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't convert IP string \"%s\" to address!",
						1, pszTemp);
					goto DONE;
				} // end if (couldn't add check to list)


				dwMsgSize = sizeof (CTRLMSG_INTERSLAVEREACHCHECK)
							+ dwAddressSize;

				pInterSlaveReachCheckMsg = (PCTRLMSG_INTERSLAVEREACHCHECK) LocalAlloc(LPTR, dwMsgSize);
				if (pInterSlaveReachCheckMsg == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				pInterSlaveReachCheckMsg->dwSize = dwMsgSize;
				pInterSlaveReachCheckMsg->dwType = CTRLMSGID_INTERSLAVEREACHCHECK;
				CopyMemory(&(pInterSlaveReachCheckMsg->id),
							&(this->m_executor.m_id),
							sizeof (TNCTRLMACHINEID));
				pInterSlaveReachCheckMsg->dwID = pRCContext->pReachCheck->m_dwID;
				pInterSlaveReachCheckMsg->fGuaranteed = pPeriodicSend->m_fGuaranteed;
				pInterSlaveReachCheckMsg->dwUsedAddressSize = dwAddressSize;

				CopyMemory((pInterSlaveReachCheckMsg + 1), pvAddress,
							dwAddressSize);


				// Start a new send, using the new address and message,
				// but same of everything else.
				hr = this->StartPeriodicSend(pPeriodicSend->m_pCtrlComm,
											pPeriodicSend->m_fGuaranteed,
											pvAddress,
											dwAddressSize,
											pInterSlaveReachCheckMsg,
											dwMsgSize,
											pPeriodicSend->m_dwInterval,
											pPeriodicSend->m_dwTimeout,
											pRCContext,
											&(pRCContext->pReachCheck->m_pPeriodicSend));

				LocalFree(pInterSlaveReachCheckMsg);
				pInterSlaveReachCheckMsg = NULL;

				if (hr != S_OK)
				{
					DPL(0, "Couldn't start periodic send!", 0);
					goto DONE;
				} // end if (couldn't start send)


				// We reused the context in the next periodic send, so don't
				// free it.
				fFreeContext = FALSE;
				pPeriodicSend->m_pvUserContext = NULL;
			} // end if (more address strings to try)
		  break;

		default:
			DPL(0, "What kind of periodic send context is type %u!?",
				1, ((PPERIODICSENDCONTEXT) pPeriodicSend->m_pvUserContext)->dwType);

			// It probably means the memory is deallocated, so don't bother freeing
			// it (it'll crash).
			fFreeContext = FALSE;

			hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on send type)


DONE:

	// In almost all cases, we're done with the context, so free it.
	if (fFreeContext)
	{
		DPL(5, "Freeing context %x, reachcheck = %s.",
			2, pPeriodicSend->m_pvUserContext,
			((pRCContext != NULL) ? "TRUE" : "FALSE"));

		// ReachCheck contexts have other items in them that need to be freed.
		if (pRCContext != NULL)
		{
			if (pRCContext->pReachCheck != NULL)
			{
				pRCContext->pReachCheck->m_dwRefCount--;
				if (pRCContext->pReachCheck->m_dwRefCount == 0)
				{
					DPL(7, "Deleting reach check %x.",
						1, pRCContext->pReachCheck);
					delete (pRCContext->pReachCheck);
				} // end if (last reference)
				else
				{
					DPL(7, "Not deleting reach check %x, its refcount is %u.",
						2, pRCContext->pReachCheck,
						pRCContext->pReachCheck->m_dwRefCount);
				} // end else (not last reference)
				pRCContext->pReachCheck = NULL;
			} // end if (still have reach check)

			LocalFree(pRCContext->pszAddressStrings);
			pRCContext->pszAddressStrings = NULL;
		} // end if (still have reach check context)

		LocalFree(pPeriodicSend->m_pvUserContext);
		pPeriodicSend->m_pvUserContext = NULL;
	} // end if (should free context)

	if (pvAddress != NULL)
	{
		LocalFree(pvAddress);
		pvAddress = NULL;
	} // end if (allocated memory)

	return (hr);
} // CTNSlave::PeriodicSendExpired
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleMessage()"
//==================================================================================
// CTNSlave::HandleMessage
//----------------------------------------------------------------------------------
//
// Description: Handles an incoming control session message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm
//								from address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PVOID pvData				Pointer to data received by ctrl comm.
//	DWORD dwDataSize			Size of data.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleMessage(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								  PVOID pvData, DWORD dwDataSize)
{
	PCTRLMSG_GENERIC	pGenericMsg = NULL;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)

	if ((*ppvFromAddress) == NULL)
	{
		DPL(0, "WARNING!  No from address!", 0);
	} // end if (no from address info)

	if (dwDataSize < sizeof (CTRLMSG_GENERIC))
	{
		DPL(0, "Data too small to be valid message!  Ignoring.", 0);
		return (S_OK);
	} // end if (smaller than the smallest valid message)

	pGenericMsg = (PCTRLMSG_GENERIC) pvData;
	
	if (pGenericMsg->dwSize != dwDataSize)
	{
		DPL(0, "Incomplete or invalid message (expected size %i bytes differs from actual size %i bytes)!  Ignoring.",
			2, pGenericMsg->dwSize, dwDataSize);
		return (S_OK);
	} // end if (didn't get complete/valid message)
	
	switch(pGenericMsg->dwType)
	{
		case CTRLMSGID_ENUM:
			// Ignore these broadcasts.
		  break;

		case CTRLMSGID_ENUMREPLY:
			if (dwDataSize < sizeof (CTRLMSG_ENUMREPLY))
			{
				DPL(0, "Data too small to be valid EnumReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid enumreply message)

			return (this->HandleEnumReplyMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_ENUMREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_HANDSHAKEREPLY:
			if (dwDataSize < sizeof (CTRLMSG_HANDSHAKEREPLY))
			{
				DPL(0, "Data too small to be valid HandshakeReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid handshakereply message)

			return (this->HandleHandshakeReplyMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_HANDSHAKEREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_JOINREPLY:
			if (dwDataSize < sizeof (CTRLMSG_JOINREPLY))
			{
				DPL(0, "Data too small to be valid JoinReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid joinreply message)

			return (this->HandleJoinReplyMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_JOINREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_TESTINGSTATUS:
			if (dwDataSize < sizeof (CTRLMSG_TESTINGSTATUS))
			{
				DPL(0, "Data too small to be valid TestingStatus message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid testingstatus message)

			return (this->HandleTestingStatusMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_TESTINGSTATUS) pGenericMsg));
		  break;

		case CTRLMSGID_NEWTEST:
			if (dwDataSize < sizeof (CTRLMSG_NEWTEST))
			{
				DPL(0, "Data too small to be valid NewTest message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid newtest message)

			return (this->HandleNewTestMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_NEWTEST) pGenericMsg));
		  break;

		case CTRLMSGID_ANNOUNCETESTREPLY:
			if (dwDataSize < sizeof (CTRLMSG_ANNOUNCETESTREPLY))
			{
				DPL(0, "Data too small to be valid AnnounceTestReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid announcetestreply message)

			return (this->HandleAnnounceTestReplyMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_ANNOUNCETESTREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_SYNCREPLY:
			if (dwDataSize < sizeof (CTRLMSG_SYNCREPLY))
			{
				DPL(0, "Data too small to be valid SyncReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid syncreply message)

			return (this->HandleSyncReplyMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_SYNCREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_USERRESPONSE:
			if (dwDataSize < sizeof (CTRLMSG_USERRESPONSE))
			{
				DPL(0, "Data too small to be valid UserResponse message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid syncreply message)

			return (this->HandleUserResponseMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_USERRESPONSE) pGenericMsg));
		  break;

		case CTRLMSGID_IDLEREPLY:
			if (dwDataSize < sizeof (CTRLMSG_IDLEREPLY))
			{
				DPL(0, "Data too small to be valid IdleReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid idlereply message)

			return (this->HandleIdleReplyMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_IDLEREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_DUMPLOG:
			if (dwDataSize < sizeof (CTRLMSG_DUMPLOG))
			{
				DPL(0, "Data too small to be valid DumpLog message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid dumplog message)

			return (this->HandleDumpLogMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_DUMPLOG) pGenericMsg));
		  break;

		case CTRLMSGID_BREAK:
			if (dwDataSize < sizeof (CTRLMSG_BREAK))
			{
				DPL(0, "Data too small to be valid Break message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid break message)

			return (this->HandleBreakMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_BREAK) pGenericMsg));
		  break;

		case CTRLMSGID_METAMASTERREPLY:
			if (dwDataSize < sizeof (CTRLMSG_METAMASTERREPLY))
			{
				DPL(0, "Data too small to be valid MetaMasterReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid metamasterreply message)

			return (this->HandleMetaMasterReplyMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_METAMASTERREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_MASTERPINGSLAVE:
			if (dwDataSize < sizeof (CTRLMSG_MASTERPINGSLAVE))
			{
				DPL(0, "Data too small to be valid MasterPingSlave message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid metamasterreply message)

			return (this->HandleMasterPingSlaveMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_MASTERPINGSLAVE) pGenericMsg));
		  break;

		case CTRLMSGID_LOSTTESTER:
			if (dwDataSize < sizeof (CTRLMSG_LOSTTESTER))
			{
				DPL(0, "Data too small to be valid LostTester message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid losttester message)

			return (this->HandleLostTesterMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_LOSTTESTER) pGenericMsg));
		  break;

		case CTRLMSGID_ACCEPTREACHCHECK:
			if (dwDataSize < (sizeof (CTRLMSG_ACCEPTREACHCHECK)))
			{
				DPL(0, "Data too small to be valid AcceptReachCheck message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid acceptreachcheck message)

			return (this->HandleAcceptReachCheckMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_ACCEPTREACHCHECK) pGenericMsg));
		  break;

		case CTRLMSGID_CONNECTREACHCHECK:
			if (dwDataSize < (sizeof (CTRLMSG_CONNECTREACHCHECK)))
			{
				DPL(0, "Data too small to be valid ConnectReachCheck message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid connectreachcheck message)

			return (this->HandleConnectReachCheckMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_CONNECTREACHCHECK) pGenericMsg));
		  break;

		case CTRLMSGID_INTERSLAVEREACHCHECK:
			if (dwDataSize < sizeof (CTRLMSG_INTERSLAVEREACHCHECK))
			{
				DPL(0, "Data too small to be valid InterSlaveReachCheck message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid interslavereachcheck message)

			return (this->HandleInterSlaveReachCheckMsg(ppvFromAddress, dwFromAddressSize,
														(PCTRLMSG_INTERSLAVEREACHCHECK) pGenericMsg));
		  break;

		case CTRLMSGID_INTERSLAVEREACHCHECKREPLY:
			if (dwDataSize < sizeof (CTRLMSG_INTERSLAVEREACHCHECKREPLY))
			{
				DPL(0, "Data too small to be valid InterSlaveReachCheckReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid interslavereachcheckreply message)

			return (this->HandleInterSlaveReachCheckReplyMsg(ppvFromAddress, dwFromAddressSize,
															(PCTRLMSG_INTERSLAVEREACHCHECKREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_GETMACHINEINFOREPLY:
			if (dwDataSize < sizeof (CTRLMSG_GETMACHINEINFOREPLY))
			{
				DPL(0, "Data too small to be valid GetMachineInfoReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid getmachineinforeply message)

			return (this->HandleGetMachineInfoReplyMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_GETMACHINEINFOREPLY) pGenericMsg));
		  break;

		default:
			DPL(0, "Message of invalid/unknown type (%i)!  Ignoring.", 1, pGenericMsg->dwType);
		  break;
	} // end switch (on message type)

	return (S_OK);
} // CTNSlave::HandleMessage
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::SendReadyForFirstTest()"
//==================================================================================
// CTNSlave::SendReadyForFirstTest
//----------------------------------------------------------------------------------
//
// Description: Lets the testmaster know we're ready to test, and gets the first
//				test to run.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::SendReadyForFirstTest(void)
{
	HRESULT					hr;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_READYTOTEST	pReadyToTestMsg = NULL;



	if (((PCOMMDATA) this->m_pvTestmasterCommData)->fDropped)
	{
#pragma BUGBUG(vanceo, "Add TNERR_CONNECTIONDROPPED check to all sendings")
		DPL(0, "Can't send ready of first test message to master because the connection went down!", 0);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to master went down)



	// If we're not in poke mode, request our first test.
	if (this->m_executor.m_dwMode == TNMODE_POKE)
	{
		DPL(3, "Notifying master that we're ready to test.", 0);
	} // end if (we're in poke mode)
	else
	{
		DPL(3, "Notifying master of readiness and requesting first test.", 0);
	} // end else (we're not in poke mode)

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_READYTOTEST);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReadyToTestMsg = (PCTRLMSG_READYTOTEST) pSendData->m_pvData;
	pReadyToTestMsg->dwSize = pSendData->m_dwDataSize;
	pReadyToTestMsg->dwType = CTRLMSGID_READYTOTEST;

	CopyMemory(&(pReadyToTestMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNSlave::SendReadyForFirstTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::DoIdle()"
//==================================================================================
// CTNSlave::DoIdle
//----------------------------------------------------------------------------------
//
// Description: Does some housekeeping since we've got nothing to do.  Pings the
//				master to make sure he still knows we're waiting on him, if that's
//				the case.
//
// Arguments:
//	DWORD dwCurrentOp	Current operation (see CTRLIDLE_xxx) for values.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::DoIdle(DWORD dwCurrentOp)
{
	HRESULT				hr = S_OK;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_IDLE		pIdleMsg = NULL;


	/*
	if (! this->m_bInSession)
	{
		DPL(0, "Not sending message because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)
	*/

	if (((PCOMMDATA) this->m_pvTestmasterCommData)->fDropped)
	{
#pragma BUGBUG(vanceo, "Add this everywhere (and have better logic?)")
		DPL(0, "Can't idle (op %u) because connection to master dropped!",
			1, dwCurrentOp);


		// Disconnect from the master so the receive thread doesn't go nuts.
		hr = this->m_pCtrlComm->UnbindDataFromAddress((PCOMMDATA) this->m_pvTestmasterCommData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unbind master connection!  %e", 1, hr);
		} // end if (couldn't unbind data)


		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (the connection to the master dropped)


	DPL(1, "Idling (current op = %u).", 1, dwCurrentOp);



	// If we've been sitting here without any data from the master for a while,
	// something's up.
	if (GetTickCount() > this->m_dwLastMasterReceive + NO_MASTER_TRAFFIC_TIME_WARNING)
	{
#pragma TODO(vanceo, "Improve")
		DPL(0, "WARNING: Haven't heard from master in a while!", 0);
		this->Log(TNLST_CONTROLLAYER_INFO, "WARNING: haven't heard from master in a while!", 0);
	} // end if (haven't heard from master in a while)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_IDLE);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pIdleMsg = (PCTRLMSG_IDLE) pSendData->m_pvData;
	pIdleMsg->dwSize = pSendData->m_dwDataSize;
	pIdleMsg->dwType = CTRLMSGID_IDLE;

	CopyMemory(&(pIdleMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pIdleMsg->dwWaitingOp = dwCurrentOp;

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	return (hr);
} // CTNSlave::DoIdle
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::StartPeriodicSend()"
//==================================================================================
// CTNSlave::StartPeriodicSend
//----------------------------------------------------------------------------------
//
// Description: Keeps trying to send a piece of data until the timeout expires or
//				it is stopped using the returned object.
//
// Arguments:
//	PTNCTRLCOMM pCtrlComm				Pointer to control comm object to use when
//										sending.
//	BOOL fGuaranteed					Whether to send guaranteed or not.
//	PVOID pvAddress						Pointer to address to send to.
//	DWORD dwAddressSize					Size of address to send to.
//	PVOID pvData						Pointer to data to send.
//	DWORD dwDataSize					Size of data to send.
//	DWORD dwInterval					How often to retry sending in ticks, or 0
//										to send only once.
//	DWORD dwTimeout						How long to keep retrying in ticks (or wait,
//										if dwInterval is 0) before stopping.
//	PVOID pvUserContext					Context to use in the callback if the send
//										times out.
//	PTNPERIODICSEND* ppPeriodicSend		Place to store pointer to resulting
//										CTNPeriodicSend object (used for cancelling
//										the send).  This object will have a refcount
//										for the caller already upon return.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::StartPeriodicSend(PTNCTRLCOMM pCtrlComm, BOOL fGuaranteed,
									PVOID pvAddress, DWORD dwAddressSize,
									PVOID pvData, DWORD dwDataSize,
									DWORD dwInterval, DWORD dwTimeout,
									PVOID pvUserContext,
									PTNPERIODICSEND* ppPeriodicSend)
{
	HRESULT					hr;
	PVOID					pvCallersCaller = NULL;
	DWORD					dwThreadID;


	DPL(9, "==> (%x, %B, %x, %u, %x, %u, %u, %u, %x, %x)",
		10, pCtrlComm,
		fGuaranteed,
		pvAddress, dwAddressSize,
		pvData, dwDataSize,
		dwInterval, dwTimeout,
		pvUserContext,
		ppPeriodicSend);


#ifdef DEBUG
	if ((*ppPeriodicSend) != NULL)
	{
		DPL(0, "About to overwrite periodic send %x!  DEBUGBREAK()-ing.", 1, (*ppPeriodicSend));
		DEBUGBREAK();
	} // end if (may be overwriting periodic send)
#endif // DEBUG

	(*ppPeriodicSend) = new (CTNPeriodicSend);
	if ((*ppPeriodicSend) == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate object)

	(*ppPeriodicSend)->m_dwRefCount++; // its in use

	(*ppPeriodicSend)->m_fGuaranteed = fGuaranteed;

	(*ppPeriodicSend)->m_dwAddressSize = dwAddressSize;
	(*ppPeriodicSend)->m_pvAddress = LocalAlloc(LPTR, (*ppPeriodicSend)->m_dwAddressSize);
	if ((*ppPeriodicSend)->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	CopyMemory((*ppPeriodicSend)->m_pvAddress, pvAddress,
				(*ppPeriodicSend)->m_dwAddressSize);


	(*ppPeriodicSend)->m_dwDataSize = dwDataSize;
	(*ppPeriodicSend)->m_pvData = LocalAlloc(LPTR, (*ppPeriodicSend)->m_dwDataSize);
	if ((*ppPeriodicSend)->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	CopyMemory((*ppPeriodicSend)->m_pvData, pvData,
				(*ppPeriodicSend)->m_dwDataSize);


	TNStackGetCallersAddress(&((*ppPeriodicSend)->m_pvSubmittersAddress),
							&pvCallersCaller);

	pCtrlComm->m_dwRefCount++; // send is using it
	(*ppPeriodicSend)->m_pCtrlComm = pCtrlComm;
	(*ppPeriodicSend)->m_dwInterval = dwInterval;
	(*ppPeriodicSend)->m_dwLastSent = 0;
	(*ppPeriodicSend)->m_dwTimeout = dwTimeout;
	(*ppPeriodicSend)->m_pvUserContext = pvUserContext;


	hr = this->m_periodicsends.Add((*ppPeriodicSend));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add periodic send %x to queue!", 1, (*ppPeriodicSend));
		goto ERROR_EXIT;
	} // end if (couldn't add periodic send)


	// If the thread isn't running, start it.
	if (this->m_hPeriodicSendThread == NULL)
	{
		this->m_hPeriodicSendThread = CreateThread(NULL, 0, SlavePeriodicSendThreadProc,
													this, 0, &dwThreadID);
		if (this->m_hPeriodicSendThread == NULL)
		{
			hr = GetLastError();

			if (hr == S_OK)
				hr = E_FAIL;

			DPL(0, "Couldn't create thread!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't create thread)
	} // end if (thread isn't running)


	// Kick it to let it know it has something to check right away.
	if (! SetEvent(this->m_periodicsends.m_hSendDataEvent))
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't set periodic send event %x!",
			1, this->m_periodicsends.m_hSendDataEvent);

		goto ERROR_EXIT;
	} // end if (couldn't set event)


	DPL(9, "<== S_OK", 0);

	return (S_OK);
	

ERROR_EXIT:

	DPL(9, "<== %e", 1, hr);

	if ((*ppPeriodicSend) != NULL)
	{
		(*ppPeriodicSend)->m_dwRefCount--;
		if ((*ppPeriodicSend)->m_dwRefCount == 0)
		{
			DPL(7, "Deleting periodic send %x.", 1, (*ppPeriodicSend));
			delete ((*ppPeriodicSend));
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting periodic send %x, its refcount is %u.",
				2, (*ppPeriodicSend), (*ppPeriodicSend)->m_dwRefCount);
		} // end else (not last reference)
		(*ppPeriodicSend) = NULL;
	} // end if (have object)

	return (hr);
} // CTNSlave::StartPeriodicSend
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::StopPeriodicSend()"
//==================================================================================
// CTNSlave::StopPeriodicSend
//----------------------------------------------------------------------------------
//
// Description: Stops the passed in periodic send, if it exists.
//
// Arguments:
//	PTNPERIODICSEND pPeriodicSend	Send to cancel.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::StopPeriodicSend(PTNPERIODICSEND pPeriodicSend)
{
	HRESULT		hr;


	DPL(9, "==>(%x)", 1, pPeriodicSend);

	this->m_periodicsends.EnterCritSection();

	hr = this->m_periodicsends.RemoveFirstReference(pPeriodicSend);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove periodic send %x from list!", 1, pPeriodicSend);
		//goto DONE;
	} // end if (couldn't remove item)


	/*
	// Notify the thread that the list changed.
	if(! SetEvent(this->m_periodicsends.m_hSendDataEvent))
	{
		hr = GetLastError();

		DPL(0, "Couldn't set periodic send list event %x!",
			1, this->m_periodicsends.m_hSendDataEvent);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't set event)
	*/

	this->m_periodicsends.LeaveCritSection();

	// Not checking refcount because it is assumed the caller will have one
	DPL(9, "<== (%x refcount %u) %e",
		3, pPeriodicSend, pPeriodicSend->m_dwRefCount, hr);

	return (hr);
} // CTNSlave::StopPeriodicSend
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::KillPeriodicSendThread()"
//==================================================================================
// CTNSlave::KillPeriodicSendThread
//----------------------------------------------------------------------------------
//
// Description: Shuts down the thread that enumerates/joins/etc. and releases the
//				events used.
//				The boolean passed in should only be set to TRUE if the caller is
//				the PeriodicSendThread, FALSE in all other cases.
//
// Arguments:
//	BOOL fKillingSelf	TRUE if being called from within the PeriodicSendThread
//						itself, FALSE otherwise.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::KillPeriodicSendThread(BOOL fKillingSelf)
{
	DPL(9, "==> (%B)", 1, fKillingSelf);

	if (this->m_hPeriodicSendThread != NULL)
	{
		if (! fKillingSelf)
		{
			if (this->m_hKillPeriodicSendThreadEvent == NULL) // ack, we won't be able to tell it to die
				return (E_FAIL);

			if (! SetEvent(this->m_hKillPeriodicSendThreadEvent))
				return (E_FAIL);

			switch (WaitForSingleObject(this->m_hPeriodicSendThread, TIMEOUT_DIE_PERIODICSENDTHREAD))
			{
				case WAIT_OBJECT_0:
					// what we want
				  break;

				case WAIT_TIMEOUT:
					DPL(0, "Waited %i ms for periodic send thread to die but it didn't!",
						1, TIMEOUT_DIE_PERIODICSENDTHREAD);


#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
					DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT

				  break;

				default:
					DPL(0, "Got unexpected return code from WaitForSingleObject on the periodic send thread!", 0);
				  break;
			} // end switch (on result of waiting for thread to die)
		} // end if (the thread isn't calling us)

		CloseHandle(this->m_hPeriodicSendThread);
		this->m_hPeriodicSendThread = NULL;
	} // end if (the send thread exists)

	if (this->m_hKillPeriodicSendThreadEvent != NULL)
	{
		CloseHandle(this->m_hKillPeriodicSendThreadEvent);
		this->m_hKillPeriodicSendThreadEvent = NULL;
	} // end if (have event)

	DPL(9, "<== S_OK", 0);

	return (S_OK);
} // CTNSlave::KillPeriodicSendThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#ifndef _XBOX // no DB logging supported

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::StartDBCase()"
//==================================================================================
// CTNSlave::StartDBCase
//----------------------------------------------------------------------------------
//
// Description: If this object is logging to the database, it is notified of the
//				start of the test case.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to notify database of.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::StartDBCase(PTNTESTINSTANCES pTest)
{
	HRESULT		hr = S_OK;
	char*		pszTemp = NULL;

	// If we're not connected to the database, we're done.
	if (this->m_lpTMAgent == NULL)
		goto DONE;


	TNsprintf(&pszTemp, "%s-%s#%i", 3, pTest->m_pCase->m_pszID,
				pTest->m_pszInstanceID, pTest->GetSlavesTesterNum(&(this->m_executor.m_id)));

	// Ignore the error because AddNewCase fails if the case already exists.
	hr = this->m_lpTMAgent->AddNewCase(TN_DATABASE_APPID,
										pszTemp, pTest->m_pCase->m_pszName);
	/*
	if (hr != S_OK)
	{
		DPL(0, "Failed to add test case \"%s\" to database!", 1, pszTemp);
		TNsprintf_free(&pszTemp);
		goto DONE;
	} // end if (failed adding test case)
	*/


	hr = this->m_lpTMAgent->StartTestCase(pszTemp, pTest->m_pCase->m_pszName);
	if (hr != S_OK)
	{
		DPL(0, "Failed to notify database of test case \"%s\" start!", 1, pszTemp);
		TNsprintf_free(&pszTemp);
		goto DONE;
	} // end if (failed starting test case)

	TNsprintf_free(&pszTemp);


DONE:

	if (pszTemp != NULL)
		TNsprintf_free(&pszTemp);

	return (hr);
} // CTNSlave::StartDBCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX


#ifndef _XBOX // no DB logging supported

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::EndDBCase()"
//==================================================================================
// CTNSlave::EndDBCase
//----------------------------------------------------------------------------------
//
// Description: If this object is logging to the database, it is notified of the
//				end of the test case.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to notify database of.
//	BOOL fSuccess			Whether the test was a success or not.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::EndDBCase(PTNTESTINSTANCES pTest, BOOL fSuccess)
{
	HRESULT		hr = S_OK;
	char*		pszTemp = NULL;
	char*		pszMemLog = NULL;



	// If we're not connected to the database, we're done.
	if (this->m_lpTMAgent == NULL)
		goto DONE;


	TNsprintf(&pszTemp, "UniqueID=%i\n", 1, pTest->m_dwUniqueID);
	hr = this->m_lpTMAgent->CaseLog(pszTemp);
	TNsprintf_free(&pszTemp);
	if (hr != S_OK)
	{
		DPL(0, "Failed logging unique ID to database!", 0);
		goto DONE;
	} // end if (failed logging to database)
	
	/*
	if (pTest->m_pszFriendlyName != NULL)
	{
		TNsprintf(&pszTemp, "FriendlyName=%s\n", 1, pTest->m_pszFriendlyName);
		hr = this->m_lpTMAgent->CaseLog(pszTemp);
		TNsprintf_free(&pszTemp);
		if (hr != S_OK)
		{
			DPL(0, "Failed logging test friendly name to database!", 0);
			goto DONE;
		} // end if (failed logging to database)
	} // end if (there's a friendly name)
	*/


	// If this wasn't a success, dump the last 5K of memory log to the
	// database.
	if (! fSuccess)
	{
		this->m_lpTMAgent->CaseLog("\n//------------------------------\n\n"); // ignore error

		pszMemLog = (char*) LocalAlloc(LPTR, 5120);
		if (pszMemLog == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		TNDebugDumpMemoryLogToString(pszMemLog, 5120);

		hr = this->m_lpTMAgent->CaseLog(pszMemLog);

		LocalFree(pszMemLog);
		pszMemLog = NULL;

		if (hr != S_OK)
		{
			DPL(0, "Failed dumping memory log to database!", 0);
			goto DONE;
		} // end if (failed logging to database)

		this->m_lpTMAgent->CaseLog("\n"); // ignore error
	} // end if (test failed)


	//BUGBUG using "PASS_SAVELOG" because using "PASS" causes it to erase the
	//		 CaseLog stuff
	hr = this->m_lpTMAgent->EndTestCase((fSuccess) ? "PASS_SAVELOG" : "FAIL");
	if (hr != S_OK)
	{
		DPL(0, "Failed notifying database of test case end!", 0);
		goto DONE;
	} // end if (failed ending test case)


DONE:

	if (pszMemLog != NULL)
	{
		LocalFree(pszMemLog);
		pszMemLog = NULL;
	} // end if (allocated string)

	if (pszTemp != NULL)
		TNsprintf_free(&pszTemp);

	return (hr);
} // CTNSlave::EndDBCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::DoConnectReachCheckResult()"
//==================================================================================
// CTNSlave::DoConnectReachCheckResult
//----------------------------------------------------------------------------------
//
// Description: Records the results of the reach check, and sends a reply to the
//				master.
//
// Arguments:
//	PTNREACHCHECK pReachCheck	Reach check which has a result.
//	BOOL fSuccess				Whether the connect was a success or not.
//	HRESULT hresult				Error code for connect, if any.
//	PVOID pvAddress				Pointer to address buffer that worked, if any.
//	DWORD dwAddressSize			Size of address buffer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::DoConnectReachCheckResult(PTNREACHCHECK pReachCheck, BOOL fSuccess,
											HRESULT hresult, PVOID pvAddress,
											DWORD dwAddressSize)
{
	HRESULT								hr = S_OK;
	PTNSENDDATA							pSendData = NULL;
	PCTRLMSG_CONNECTREACHCHECKREPLY		pReplyMsg = NULL;


	/*
	if (! this->m_bInSession)
	{
		DPL(0, "Not sending message because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)
	*/


	// Let the control comm object clean up, if it exists.
	if (pReachCheck->m_pCtrlComm != NULL)
	{
		// Stop the control layer.
		hr = pReachCheck->m_pCtrlComm->CleanupReachCheck(pReachCheck);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't cleanup TCP/IP reach check %u!",
				1, pReachCheck->m_dwID);
			goto DONE;
		} // end if (couldn't cleanup reach check)


		// Free up the control comm reference.

		pReachCheck->m_pCtrlComm->m_dwRefCount--;
		if (pReachCheck->m_pCtrlComm->m_dwRefCount == 0)
		{
			DPL(7, "Releasing and deleting control comm object %x.",
				1, pReachCheck->m_pCtrlComm);

			hr = pReachCheck->m_pCtrlComm->Release();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't release control comm object %x!",
					1, pReachCheck->m_pCtrlComm);
				goto DONE;
			} // end if (couldn't release control comm)

			delete (pReachCheck->m_pCtrlComm);
		} // end if (last use of control comm)
		else
		{
			DPL(7, "Not releasing and deleting control comm object %x, its refcount is %u.",
				2, pReachCheck->m_pCtrlComm, pReachCheck->m_pCtrlComm->m_dwRefCount);
		} // end else (not last use of control comm)

		pReachCheck->m_pCtrlComm = NULL;
	} // end if (there's a control comm reference)


	// If there's a periodic send object still, clean it up.
	if (pReachCheck->m_pPeriodicSend != NULL)
	{
		pReachCheck->m_pPeriodicSend->m_dwRefCount--;
		if (pReachCheck->m_pPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting periodic send %x.", 1, pReachCheck->m_pPeriodicSend);

			// If there's a context, we know it's allocated memory.  Free it.
			if (pReachCheck->m_pPeriodicSend->m_pvUserContext != NULL)
			{
				LocalFree(pReachCheck->m_pPeriodicSend->m_pvUserContext);
				pReachCheck->m_pPeriodicSend->m_pvUserContext = NULL;
			} // end if (there's a user context)

			delete (pReachCheck->m_pPeriodicSend);
		} // end if (can delete item)
		else
		{
			DPL(7, "Not deleting periodic send %x, it's refcount is %u.",
				2, pReachCheck->m_pPeriodicSend,
				pReachCheck->m_pPeriodicSend->m_dwRefCount);
		} // end else (can't delete item)
		pReachCheck->m_pPeriodicSend = NULL;
	} // end if (there's a control comm reference)



	pReachCheck->m_fResult = fSuccess;
	pReachCheck->m_hresult = hresult;
	if (pvAddress != NULL)
	{
		pReachCheck->m_pvAddress = LocalAlloc(LPTR, dwAddressSize);
		if (pReachCheck->m_pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (out of memory)

		pReachCheck->m_dwAddressSize = dwAddressSize;

		CopyMemory(pReachCheck->m_pvAddress, pvAddress, dwAddressSize);
	} // end if (there's an address)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_CONNECTREACHCHECKREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_CONNECTREACHCHECKREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_CONNECTREACHCHECKREPLY;

	CopyMemory(&(pReplyMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pReplyMsg->dwID = pReachCheck->m_dwID;
	pReplyMsg->fReachable = fSuccess;
	pReplyMsg->hresult = hresult;


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	return (hr);
} // CTNSlave::DoConnectReachCheckResult
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetNetStatInfo()"
//==================================================================================
// CTNSlave::GetNetStatInfo
//----------------------------------------------------------------------------------
//
// Description: Retrieves the current net stat info to the memory log.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNSlave::GetNetStatInfo(void)
{
#ifndef _XBOX // no other processes supported, so can't call netstat
	HRESULT					hr;
	STARTUPINFO				si;
	PROCESS_INFORMATION		pi;
	char					szOutputFile[256];



	ZeroMemory(&si, sizeof (STARTUPINFO));
	si.cb = sizeof (STARTUPINFO);
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	si.hStdOutput = INVALID_HANDLE_VALUE;
	si.hStdError = GetStdHandle(STD_ERROR_HANDLE);

	ZeroMemory(&pi, sizeof (PROCESS_INFORMATION));



	wsprintf(szOutputFile, "netstatinfo_%u.txt", GetTickCount());

	DPL(1, "Retrieving net stat info to \"%s\".", 1, szOutputFile);


	// Create the batch file used to redirect netstat output.
	hr = FileCreateAndOpenFile(szOutputFile, FALSE, FALSE, TRUE, &(si.hStdOutput));
	if (hr != S_OK)
	{
		DPL(0, "Creating batch file \"%s\" failed!  Ignoring.  %e", 2, szOutputFile, hr);
		goto DONE;
	} // end if (failed creating file)


	// Launch the redirector batch file.
	if (! CreateProcess(NULL, "netstat -na", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
	{
		hr = GetLastError();
		DPL(0, "Failed dumping net stat to \"%s\"!  Ignoring.  %e",
			2, szOutputFile, hr);
		goto DONE;
	} // end if (failed creating process)



	// Wait for netstat to finish.
	WaitForSingleObject(pi.hProcess, INFINITE);


	// Close the file before trying to read from it.
	CloseHandle(si.hStdOutput);
	si.hStdOutput = INVALID_HANDLE_VALUE;


	// Read the file generated
	hr = FileReadTextFile(szOutputFile, FILERTFO_SKIP_EMPTY_LINES,
						SlaveReadNetStatTempFileCB, NULL);
	if (hr != S_OK)
	{
		DPL(0, "Reading text file \"%s\" failed!  Ignoring.  %e",
			2, szOutputFile, hr);

		// Continue...
	} // end if (failed reading file)


	// There's an output file, so try to delete it.
	if (! DeleteFile(szOutputFile))
	{
		hr = GetLastError();
		DPL(0, "Couldn't delete temp net stat file \"%s\"!  Ignoring.  %e",
			2, szOutputFile, hr);
		// Continue...
	} // end if (couldn't delete file)


DONE:

	if (pi.hThread != NULL)
	{
		CloseHandle(pi.hThread);
		pi.hThread = NULL;
	} // end if (have thread handle)

	if (pi.hProcess != NULL)
	{
		CloseHandle(pi.hProcess);
		pi.hProcess = NULL;
	} // end if (have process handle)

	if (si.hStdOutput != INVALID_HANDLE_VALUE)
	{
		CloseHandle(si.hStdOutput);
		si.hStdOutput = NULL;
	} // end if (have output file handle)

#else // ! XBOX
#pragma TODO(tristanj, "No longer able to call netstat on a failure")
#endif // XBOX

} // CTNSlave::GetNetStatInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no DB logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"DBUnavailableDlgProc()"
//==================================================================================
// DBUnavailableDlgProc
//----------------------------------------------------------------------------------
//
// Description: DB logging unavailable choice dialog window procedure.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK DBUnavailableDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static DWORD	dwSecs = 0;

	char			szTemp[64];


	switch (uMsg)
	{
		case WM_INITDIALOG:
			dwSecs = DBUNVAILABLE_DIALOG_TIMEOUT;

			if (dwSecs != 1)
				wsprintf(szTemp, "%i seconds.", dwSecs);
			else
				strcpy(szTemp, "1 second.");


			SetWindowText(GetDlgItem(hWnd, IDT_TIMER), szTemp);

			SetTimer(hWnd, 1, 1000, NULL);
		  break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDYES:
					DPL(0, "User pressed 'Yes'.", 0);

					KillTimer(hWnd, 1);
					EndDialog(hWnd, IDYES);
				  break;

				case IDNO:
					DPL(0, "User pressed 'No'.", 0);

					KillTimer(hWnd, 1);
					EndDialog(hWnd, IDNO);
				  break;
			} // end switch (on the button pressed/control changed)
		  break;

		case WM_TIMER:
			dwSecs--;

			if (dwSecs > 0)
			{
				if (dwSecs != 1)
					wsprintf(szTemp, "%i seconds.", dwSecs);
				else
					strcpy(szTemp, "1 second.");

				SetWindowText(GetDlgItem(hWnd, IDT_TIMER), szTemp);

				SetTimer(hWnd, 1, 1000, NULL);
			} // end if (time limit has not been reached)
			else
			{
				KillTimer(hWnd, 1);
				EndDialog(hWnd, IDNO); // hit the NO button
			} // end else  (time limit has been reached)

			return (TRUE);
		  break;
	} // end switch (on the type of window message)

	return (DefWindowProc(hWnd, uMsg, wParam, lParam));
} // DBUnavailableDlgProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#undef DEBUG_SECTION
#define DEBUG_SECTION	"SlaveReadNetStatTempFileCB()"
//==================================================================================
// SlaveReadNetStatTempFileCB
//----------------------------------------------------------------------------------
//
// Description: Callback that handles a line read from a text file.
//
// Arguments:
//	char* szLine			Line that was read.
//	PFILELINEINFO pInfo		Line that was read.
//	PVOID pvContext			Pointer to context.  Cast as a READSCRIPTFILECONTEXT
//							pointer.
//	BOOL* pfStopReading		Pointer to boolean to set to TRUE to discontinue reading
//							from the file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT SlaveReadNetStatTempFileCB(char* szLine, PFILELINEINFO pInfo, PVOID pvContext,
								BOOL* pfStopReading)
{
	DPL(1, "NETSTAT: %u: %s", 2, pInfo->dwLineNumber, szLine);

	return (S_OK);
} // SlaveReadNetStatTempFileCB
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"SlavePeriodicSendThreadProc()"
//==================================================================================
// SlavePeriodicSendThreadProc
//----------------------------------------------------------------------------------
//
// Description: This thread periodically wakes up and performs periodic sends.
//
// Arguments:
//	LPVOID lpvParameter		Thread startup parameter.  Cast to a pointer to a slave
//							object.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI SlavePeriodicSendThreadProc(LPVOID lpvParameter)
{
	HRESULT				hr = S_OK;
	PTNSLAVE			pSlave = (PTNSLAVE) lpvParameter;
	HANDLE				ahWaitArray[3];
	DWORD				dwInterval;
	BOOL				fHaveSendLock = FALSE;
	int					i;
	PTNPERIODICSEND		pPeriodicSend = NULL;
	BOOL				fSend;
	PTNSENDDATA			pSendData = NULL;
	DWORD				dwCurrentTime;



	DPL(8, "Starting up.", 0);


	ahWaitArray[0] = pSlave->m_hKillPeriodicSendThreadEvent;
	ahWaitArray[1] = pSlave->m_periodicsends.m_hSendDataEvent;
	ahWaitArray[2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	dwInterval = INFINITE; // wait for an item to kick us

	while (TRUE)
	{
		hr = WaitForMultipleObjects(2, ahWaitArray, FALSE, dwInterval);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// Time for the thread to die.
				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// There's a new item in the list, we'll just drop through...

			case WAIT_TIMEOUT:
				dwInterval = INFINITE; // items will override

				pSlave->m_periodicsends.EnterCritSection();
				fHaveSendLock = TRUE;

				// Loop through all the slaves in the list
				for(i = 0; i < pSlave->m_periodicsends.Count(); i++)
				{
					pPeriodicSend = (PTNPERIODICSEND) pSlave->m_periodicsends.GetItem(i);
					if (pPeriodicSend == NULL)
					{
						DPL(0, "Couldn't get periodic send %i!", 1, i);
						hr = E_FAIL;
						goto DONE;
					} // end if (couldn't get item)

					pPeriodicSend->m_dwRefCount++; // we're using it

					fSend = FALSE;
					dwCurrentTime = GetTickCount();


					// Check if it's the first time its being sent
					if (pPeriodicSend->m_dwFirstSent == 0)
					{
						pPeriodicSend->m_dwFirstSent = dwCurrentTime;
						fSend = TRUE;
					} // end if (this is the first time the item has been sent)
					else
					{
						// Only resend things that should be sent more than once.
						if (pPeriodicSend->m_dwInterval != 0)
						{
							// If it's past time to resend the item, do it.
							if ((GetTickCount() - pPeriodicSend->m_dwLastSent) >= pPeriodicSend->m_dwInterval)
								fSend = TRUE;
						} // end if (should resend)
					} // end else (not first time being sent)

					if (fSend)
					{
						// Copy the item and put it on the send queue.

						pSendData = new (CTNSendData);
						if (pSendData == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (out of memory)

						pSendData->m_fGuaranteed = pPeriodicSend->m_fGuaranteed;
						pSendData->m_dwAddressSize = pPeriodicSend->m_dwAddressSize;
						pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
						if (pSendData->m_pvAddress == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (out of memory)

						CopyMemory(pSendData->m_pvAddress, pPeriodicSend->m_pvAddress,
								pSendData->m_dwAddressSize);

						pSendData->m_dwDataSize = pPeriodicSend->m_dwDataSize;

						pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
						if (pSendData->m_pvData == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (couldn't allocate memory)

						CopyMemory(pSendData->m_pvData, pPeriodicSend->m_pvData,
									pSendData->m_dwDataSize);


						hr = pPeriodicSend->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
						if (hr != S_OK)
						{
							DPL(0, "Couldn't add send item to queue!", 0);
							goto DONE;
						} // end if (failed to add item to queue)

						pSendData = NULL; // forget about it so it doesn't get freed below


						pPeriodicSend->m_dwLastSent = dwCurrentTime;
					} // end else if (should be sent)


					// If it's past the expire time, do it.
					if ((dwCurrentTime - pPeriodicSend->m_dwFirstSent) >= pPeriodicSend->m_dwTimeout)
					{
						// Pull the item from the list
						hr = pSlave->m_periodicsends.Remove(i);
						if (hr != S_OK)
						{
							DPL(0, "Couldn't remove periodic send %i from list!",
								1, i);
							goto DONE;
						} // end if (couldn't remove item)

						// We pulled it off the list, so don't screw up our index.
						i--;


						// Call the slave's callback.  It may add the send back to
						// the list.  That's cool, cause it will be added to the
						// end and the 'for' statement at the top will note that
						// the list grew again.
						hr = pSlave->PeriodicSendExpired(pPeriodicSend);
						if (hr != S_OK)
						{
							DPL(0, "Slave's periodic send expiration callback failed!", 0);
							goto DONE;
						} // end if (couldn't use slave callback)
					} // end if (the item expired)
					else
					{
						// It's not expired, so when should it be looked at again?

						// If there's an interval, calculate if it's going to be
						// the next thing to fire.
						if (pPeriodicSend->m_dwInterval != 0)
						{
							// If this needs to be sent before the currently
							// calculated interval, shorten it to fire in time for
							// this one.
							if ((pPeriodicSend->m_dwInterval - (dwCurrentTime - pPeriodicSend->m_dwLastSent)) < dwInterval)
								dwInterval = pPeriodicSend->m_dwInterval - (dwCurrentTime - pPeriodicSend->m_dwLastSent);
						} // end if (there's an interval)

						// If this needs to expire before the currently
						// calculated interval, shorten it to fire in time for
						// that.
						if ((pPeriodicSend->m_dwTimeout - (dwCurrentTime - pPeriodicSend->m_dwFirstSent)) < dwInterval)
							dwInterval = pPeriodicSend->m_dwTimeout - (dwCurrentTime - pPeriodicSend->m_dwFirstSent);
					} // end else (didn't expire)
					

					pPeriodicSend->m_dwRefCount--;
					if (pPeriodicSend->m_dwRefCount == 0)
					{
						DPL(7, "Deleting periodic send %x.", 1, pPeriodicSend);

						// If there's a context, we know it's allocated memory.  Free it.
						if (pPeriodicSend->m_pvUserContext != NULL)
						{
							LocalFree(pPeriodicSend->m_pvUserContext);
							pPeriodicSend->m_pvUserContext = NULL;
						} // end if (there's a user context)

						delete (pPeriodicSend);
					} // end if (last reference)
					else
					{
						DPL(7, "Not deleting periodic send %x, its refcount is %u.",
							2, pPeriodicSend, pPeriodicSend->m_dwRefCount);
					} // end else (not last reference)
					pPeriodicSend = NULL;
				} // end for (each send)

				fHaveSendLock = FALSE;
				pSlave->m_periodicsends.LeaveCritSection();
			  break;

			default:
				DPL(0, "Got unexpected result from WaitForMultipleObjects!", 0);
				goto DONE;
			  break;
		} // end switch (on wait result)
	} // end while (not done)


DONE:

	if (fHaveSendLock)
	{
		pSlave->m_periodicsends.LeaveCritSection();
		fHaveSendLock = FALSE;
	} // end if (have lock)

	if (pPeriodicSend != NULL)
	{
		pPeriodicSend->m_dwRefCount--;
		if (pPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting periodic send %x.", 1, pPeriodicSend);

			// If there's a context, we know it's allocated memory.  Free it.
			if (pPeriodicSend->m_pvUserContext != NULL)
			{
				LocalFree(pPeriodicSend->m_pvUserContext);
				pPeriodicSend->m_pvUserContext = NULL;
			} // end if (there's a user context)

			delete (pPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting periodic send %x, its refcount is %u.",
				2, pPeriodicSend, pPeriodicSend->m_dwRefCount);
		} // end else (not last reference)
		pPeriodicSend = NULL;
	} // end if (have object)

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have object)

	if (hr != S_OK)
	{
		DPL(0, "%e", 1, hr);

		// Ignoring error
		pSlave->Log(TNLST_CRITICAL,
					"PeriodicSend thread exiting with failure!  %e",
					1, hr);
	} // end if (quitting with a failure)

	DPL(8, "Exiting.", 0);

	return (hr);
} // SlavePeriodicSendThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\sndcards.h ===
#ifndef __TNCONTROL_SNDCARDS__
#define __TNCONTROL_SNDCARDS__
//#pragma message("Defining __TNCONTROL_SNDCARDS__")





//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNSoundCard:public CLString
{
	// These are friends so they can access the protected members.
	friend CTNMachineInfo;
	friend CTNSoundCardsList;


	protected:
		GUID	m_guidDSoundID; // GUID DSound uses to identify this device
		BOOL	m_fHalfDuplex; // whether this device is known to be half-duplex


	public:
		CTNSoundCard(char* szName, GUID* pguidDSoundID, BOOL fHalfDuplex);
		virtual ~CTNSoundCard(void);

		GUID* GetDSoundGUID(void);
		BOOL IsKnownHalfDuplex(void);
};

class DLLEXPORT CTNSoundCardsList:public CLStringList
{
	// These are friends so they can access the protected members.
	friend CTNMachineInfo;
	friend CTNSlaveInfo;


	protected:
		//CTNSoundCardsList(void);
		//virtual ~CTNSoundCardsList(void);

		HRESULT PackIntoBuffer(PVOID pvBuffer, DWORD* pdwSize);
		HRESULT UnpackFromBuffer(PVOID pvBuffer, DWORD dwSize);
#ifndef _XBOX // no file printing supported
		void PrintToFile(HANDLE hFile);
#endif // ! XBOX
};





#else //__TNCONTROL_SNDCARDS__
//#pragma message("__TNCONTROL_SNDCARDS__ already included!")
#endif //__TNCONTROL_SNDCARDS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\storedata.h ===
#ifndef __TNCONTROL_STOREDATA__
#define __TNCONTROL_STOREDATA__
//#pragma message("Defining __TNCONTROL_STOREDATA__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG




// These are the possible data locations for a stored data item

#define TNTSDL_REPORTASSIGN			1 // The strings came from/are initial data (from an tester assignment report)
#define TNTSDL_REPORTSUCCESS		2 // The strings came from/are going to a tester's success report
#define TNTSDL_REPORTFAILURE		3 // The strings came from/are going to a tester's failure report
#define TNTSDL_REPORTWARNING		4 // The strings came from/are going to a tester's warning
#define TNTSDL_REPORTFINALSUCCESS	5 // The strings came from/are going to a final success report
#define TNTSDL_REPORTFINALFAILURE	6 // The strings came from/are going to a final failure report

#define TNTSDL_SCRIPTSECTION		100 // The strings came from the script section




//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNStoredData:public LLITEM
{
	// These are friends so they can access the protected data
	friend CTNStoredDataList;
#ifndef _XBOX // Reports not supported
	friend CTNReport;
#endif
	friend CTNTestInstanceM;
	friend HRESULT MasterReadFileCB(char* szLine, PFILELINEINFO pInfo,
									PVOID pvContext, BOOL* pfStopReading);


	protected:
		DWORD			m_dwLocation; // location where this item was stored (a script, a report, etc.)
		int				m_iTesterNum; // tester number this item is associated with
		CLStringList	m_strings; // the stored data strings


	public:
		CTNStoredData(void);
		virtual ~CTNStoredData(void);

		HRESULT AddString(char* szString);
};

class DLLEXPORT CTNStoredDataList:public LLIST
{
	public:
		CTNStoredDataList(void);
		virtual ~CTNStoredDataList(void);


		PLSTRINGLIST GetScriptInputDataStrings(void);

		PLSTRINGLIST GetReportStringsForTester(DWORD dwReportType, int iTesterNum,
												int iIndex);
};






#else //__TNCONTROL_STOREDATA__
//#pragma message("__TNCONTROL_STOREDATA__ already included!")
#endif //__TNCONTROL_STOREDATA__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\sources.inc ===
!IF 0

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tncontrl.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Tristan Jackson (tristanj)

!ENDIF

TARGETTYPE=DYNLINK
TARGETPATH=$(BASEDIR)\private\test\directx\dplay\testnet\bins

DLLENTRY=_DllMainCRTStartup

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DTNCONTRL_EXPORTS -DDONT_CATCH_DOC_EXCEPTIONS -DXBOX

INCLUDES= \
        $(INCLUDES); \
        $(BASEDIR)\private\test\directx\dplay\testnet\tncontrl; \
        $(BASEDIR)\private\test\directx\dplay\testnet\tncommon; \
        $(BASEDIR)\private\windows\directx\dplay\inc; \
        $(BASEDIR)\private\test\inc; \

SOURCES=\
        ..\tncontrl.rc        \
        ..\binmgmt.cpp        \
        ..\comm.cpp           \
        ..\commtcp.cpp        \
        ..\comports.cpp       \
        ..\control.cpp        \
        ..\excptns.cpp        \
        ..\executor.cpp       \
        ..\faultsim.cpp       \
        ..\faultsimimtest.cpp \
        ..\info.cpp           \
        ..\ipaddrs.cpp        \
        ..\ipcobj.cpp         \
        ..\jobq.cpp           \
        ..\leech.cpp          \
        ..\main.cpp           \
        ..\master.cpp         \
        ..\masterinfo.cpp     \
        ..\masterlist.cpp     \
        ..\meta.cpp           \
        ..\periodicq.cpp      \
        ..\reachcheck.cpp     \
        ..\reportitem.cpp     \
        ..\reportlist.cpp     \
        ..\rsltchain.cpp      \
        ..\script.cpp         \
        ..\sendq.cpp          \
        ..\slave.cpp          \
        ..\slaveinfo.cpp      \
        ..\slavelist.cpp      \
        ..\sndcards.cpp       \
        ..\storedata.cpp      \
        ..\syncdata.cpp       \
        ..\tablecase.cpp      \
        ..\tablegroup.cpp     \
        ..\tableitem.cpp      \
        ..\tapidevs.cpp       \
        ..\testfromfiles.cpp  \
        ..\testinst.cpp       \
        ..\testlist.cpp       \
        ..\teststats.cpp      \
        ..\vars.cpp           \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\storedata.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"

#include "storedata.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNStoredData::CTNStoredData()"
//==================================================================================
// CTNStoredData constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNStoredData object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNStoredData::CTNStoredData(void):
	m_dwLocation(0),
	m_iTesterNum(-1)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNStoredData));
	} // CTNStoredData::CTNStoredData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNStoredData::~CTNStoredData()"
//==================================================================================
// CTNStoredData destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNStoredData object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNStoredData::~CTNStoredData(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNStoredData::~CTNStoredData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNStoredData::AddString()"
//==================================================================================
// CTNStoredData::AddString
//----------------------------------------------------------------------------------
//
// Description: Adds the given string to this stored data.
//
// Arguments:
//	char* szString	String to add.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNStoredData::AddString(char* szString)
{
	return (this->m_strings.AddString(szString));
} // CTNStoredData::AddString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNStoredDataList::CTNStoredDataList()"
//==================================================================================
// CTNStoredDataList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNStoredDataList object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNStoredDataList::CTNStoredDataList(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNStoredDataList));
} // CTNStoredDataList::CTNStoredDataList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNStoredDataList::~CTNStoredDataList()"
//==================================================================================
// CTNStoredDataList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNStoredDataList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNStoredDataList::~CTNStoredDataList(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNStoredDataList::~CTNStoredDataList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNStoredDataList::GetScriptInputDataStrings()"
//==================================================================================
// CTNStoredDataList::GetScriptInputDataStrings
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the list of strings the user added under the
//				InputData section in the script that loaded this test, or NULL if
//				this test was not instantiated by a script.
//
// Arguments: None.
//
// Returns: Pointer to script string list, or NULL if doesn't exist.
//==================================================================================
PLSTRINGLIST CTNStoredDataList::GetScriptInputDataStrings(void)
{
	PTNSTOREDDATA	pStoredData = NULL;


	// Get the first stored data item
	pStoredData = (PTNSTOREDDATA) this->GetItem(0);

	// If it doesn't exist, this wasn't instantiated by a file
	if (pStoredData == NULL)
		return (NULL);

	// If the data is from a script section, then this is what we want.  Note that
	// we only look at the first item because only one script section can be
	// associated with a test (if you tried to put another section with the same
	// case ID, it would create another instance of the test).
	if (pStoredData->m_dwLocation == TNTSDL_SCRIPTSECTION)
		return (&(pStoredData->m_strings));

	return (NULL);
} // CTNStoredDataList::GetScriptInputDataStrings
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNStoredDataList::GetReportStringsForTester()"
//==================================================================================
// CTNStoredDataList::GetReportStringsForTester
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the list of strings that were written out
//				(using the module's WriteData function) for the iIndex-th report
//				that matches the report type and tester number.
//				For example, passing (TNTSDL_REPORTASSIGN, 0, 0) will return the
//				first tester 0 assignment report (if it exists).  Passing
//				(TNTSDL_REPORTFAILURE, 0, 2) will skip the first 2 tester 0
//				failure reports and return the third (if it exists).
//
// Arguments:
//	DWORD dwReportType		ID of the report type to search for (TNTSDL_REPORTxxx).
//	int iTesterNum			Tester number that generated the report.
//	int iIndex				How many matching reports to skip.
//
// Returns: Pointer to script string list, or NULL if doesn't exist.
//==================================================================================
PLSTRINGLIST CTNStoredDataList::GetReportStringsForTester(DWORD dwReportType,
														int iTesterNum,
														int iIndex)
{
	int				i;
	PTNSTOREDDATA	pStoredData = NULL;
	int				iSkipped = 0;


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		// Get the stored data item
		pStoredData = (PTNSTOREDDATA) this->GetItem(i);
		if (pStoredData == NULL)
		{
			DPL(0, "Couldn't get item %i!", 1, i);
			this->LeaveCritSection();
			return (NULL);
		} // end if (couldn't get that item)

		// Check to see if the report type and tester number match.
		if ((pStoredData->m_dwLocation == dwReportType) &&
			(pStoredData->m_iTesterNum == iTesterNum))
		{
			// Okay, we found a matching item, but does the user actually want
			// this one?
			if (iSkipped >= iIndex)
			{
				this->LeaveCritSection();
				return (&(pStoredData->m_strings));
			} // end if (shouldn't skip this one)

			// User doesn't, so skip it and look for the next match
			iSkipped++;
		} // end if (the report type and tester number match)
	} // end for (each item associated with this test)
	this->LeaveCritSection();

	return (NULL);
} // CTNStoredDataList::GetReportStringsForTester
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\syncdata.h ===
#ifndef __TNCONTROL_SYNCDATA__
#define __TNCONTROL_SYNCDATA__
//#pragma message("Defining __TNCONTROL_SYNCDATA__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNSyncData:public LLITEM
{
	// These are friends so they can access the protected members
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNSyncDataList;


	private:
		PVOID				m_pvData; // pointer to sync data, use functions to access
		DWORD				m_dwDataSize; // size of sync data, use functions to access


	protected:
		DWORD				m_dwRequestID; // request ID that generated this sync item
		char*				m_pszSyncName; // pointer to name of sync operation this falls under
		int					m_iTesterNum; // tester this item represents
		PTNSYNCDATALIST		m_pSyncList; // pointer to list of testers this guy is trying to sync with


		HRESULT SetData(PVOID pvNewData, DWORD dwNewDataSize);
		HRESULT GetData(PVOID* ppvData, DWORD* pdwDataSize);
		HRESULT DoSyncCheck(PTNSYNCDATALIST pCheckedList, BOOL* pfInSync);


	public:
		CTNSyncData(DWORD dwRequestID, char* pszSyncName, int iTesterNum);
		virtual ~CTNSyncData(void);
};

class DLLEXPORT CTNSyncDataList:public LLIST
{
	// These are friends so they can access the protected members
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNExecutorPriv;

#ifndef _XBOX // no IPC supported
	friend CTNLeech;
#endif // ! XBOX


	protected:
		PTNSYNCDATA GetItemForTester(int iTesterNum);
		PTNSYNCDATA GetItemForTester(char* szSyncName, int iTesterNum);

		HRESULT AddAndDoSyncCheck(DWORD dwRequestID, char* szSyncName,
								int iTesterNum, int iNumTargets, int* aiTargetList,
								PVOID pvData, DWORD dwDataSize,
								PTNSYNCDATALIST pAffectedList, BOOL* pfInSync);

		HRESULT AddDataFromTester(int iTesterNum, PVOID pvNewData,
									DWORD dwNewDataSize);

		HRESULT PackDataForTesterIntoBuffer(int iTesterNum,
											PVOID pvBuffer,
											DWORD* pdwBufferSize);

		HRESULT UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize);



	public:
		CTNSyncDataList(void);
		virtual ~CTNSyncDataList(void);


		HRESULT GetDataFromTester(int iTesterNum, PVOID* ppvData,
								DWORD* pdwDataSize);
};






#else //__TNCONTROL_SYNCDATA__
//#pragma message("__TNCONTROL_SYNCDATA__ already included!")
#endif //__TNCONTROL_SYNCDATA__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\syncdata.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"

#include "tncontrl.h"
#include "main.h"

#include "syncdata.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncData::CTNSyncData()"
//==================================================================================
// CTNSyncData constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNSyncData object.  Initializes the data
//				structures.
//
// Arguments:
//	DWORD dwRequestID	Request ID that created this item.
//	char* pszSyncName	Name of sync operation this object belongs to, or NULL if
//						not important.
//	int iTesterNum		Tester number this sync represents.
//
// Returns: None (just the object).
//==================================================================================
CTNSyncData::CTNSyncData(DWORD dwRequestID, char* pszSyncName, int iTesterNum):
	m_dwRequestID(dwRequestID),
	m_pszSyncName(NULL),
	m_iTesterNum(iTesterNum),
	m_pSyncList(NULL),

	m_pvData(NULL),
	m_dwDataSize(0)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNSyncData));


	if (pszSyncName != NULL)
	{
		this->m_pszSyncName = (char*) LocalAlloc(LPTR, (strlen(pszSyncName) + 1));
		if (this->m_pszSyncName != NULL)
		{
			strcpy(this->m_pszSyncName, pszSyncName);
		} // end if (allocated memory)
	} // end if (there's a sync name to use)
} // CTNSyncData::CTNSyncData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncData::~CTNSyncData()"
//==================================================================================
// CTNSyncData destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNSyncData object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNSyncData::~CTNSyncData(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pszSyncName != NULL)
	{
		LocalFree(this->m_pszSyncName);
		this->m_pszSyncName = NULL;
	} // end if (there's a sync name)

	if (this->m_pvData != NULL)
	{
		LocalFree(this->m_pvData);
		this->m_pvData = NULL;
	} // end if (there's sync data)

	if (this->m_pSyncList != NULL)
	{
		delete (this->m_pSyncList);
		this->m_pSyncList = NULL;
	} // end if (there's a sync list)
} // CTNSyncData::~CTNSyncData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncData::SetData()"
//==================================================================================
// CTNSyncData::SetData
//----------------------------------------------------------------------------------
//
// Description: Sets this object's data to a copy based on the pointers passed in.
//				If data already existed, it is freed to make room.  If NULL is
//				passed, no data is copied in its place.
//
// Arguments:
//	PVOID pvNewData			Pointer to data to set.
//	DWORD dwNewDataSize		Size of data to set.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSyncData::SetData(PVOID pvNewData, DWORD dwNewDataSize)
{
	if (this->m_pvData != NULL)
		LocalFree(this->m_pvData);

	this->m_dwDataSize = 0;

	if (pvNewData != NULL)
	{
		this->m_pvData = LocalAlloc(LPTR, dwNewDataSize);
		if (this->m_pvData == NULL)
			return (E_OUTOFMEMORY);
	} // end if (there's actually data)

	this->m_dwDataSize = dwNewDataSize;

	if (pvNewData != NULL)
		CopyMemory(this->m_pvData, pvNewData, dwNewDataSize);

	return (S_OK);
} // CTNSyncData::SetData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncData::GetData()"
//==================================================================================
// CTNSyncData::GetData
//----------------------------------------------------------------------------------
//
// Description: Retrieves pointers to the data this object holds.  Note: this is
//				not a copy of the data.
//
// Arguments:
//	PVOID* ppvData			Pointer to set to point at data.
//	DWORD* pdwDataSize		Pointer to fill in with size of data.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSyncData::GetData(PVOID* ppvData, DWORD* pdwDataSize)
{
	(*ppvData) = this->m_pvData;
	(*pdwDataSize) = this->m_dwDataSize;

	return (S_OK);
} // CTNSyncData::GetData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncData::DoSyncCheck()"
//==================================================================================
// CTNSyncData::DoSyncCheck
//----------------------------------------------------------------------------------
//
// Description: Checks if all of this item's targets are recursively in sync.
//				The passed in list gets added to each time an item has been checked,
//				so after the top-most check has completed, if the pfInSync is TRUE,
//				then the list holds all the items that are now in sync.
//
// Arguments:
//	PTNSYNCDATALIST pCheckedList	Pointer to list that will be filled with items
//									that have been checked.
//	BOOL* pfInSync					Pointer to boolean to set to TRUE if all targets
//									are in sync.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSyncData::DoSyncCheck(PTNSYNCDATALIST pCheckedList, BOOL* pfInSync)
{
	HRESULT			hr;
	int				i;
	PTNSYNCDATA		pTarget = NULL;



	(*pfInSync) = FALSE;


	// We're checking ourselves, so add us to the list.
	hr = pCheckedList->Add(this);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add tester %i to our temporary checked list!",
			1, this->m_iTesterNum);
		return (hr);
	} // end if (couldn't add this item to our temp list)


	// Loop through each target.  If it's a placeholder, then we're not in sync so
	// stop and percolate that back through the call stack.  Otherwise, recursively
	// check if the target is in sync, unless it's been checked already.

	for(i = 0; i < this->m_pSyncList->Count(); i++)
	{
		pTarget = (PTNSYNCDATA) this->m_pSyncList->GetItem(i);
		if (pTarget == NULL)
		{
			DPL(0, "Couldn't get target at index %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)


		// If the target is a placeholder, we're done.
		if (pTarget->m_pSyncList == NULL)
			return (S_OK);


		// If the target has not been checked already, check it
		if (pCheckedList->GetFirstIndex(pTarget) < 0)
		{
			hr = pTarget->DoSyncCheck(pCheckedList, pfInSync);
			if (hr != S_OK)
			{
				DPL(0, "Checking target tester index %i failed!", 1, i);
				return (hr);
			} // end if (couldn't add this item to our temp list)

			if (! (*pfInSync))
				return (S_OK);
		} // end if (the item has not been checked)

	} // end for (each target)

	// If we got here, then all of the items are in sync.
	(*pfInSync) = TRUE;

	return (S_OK);
} // CTNSyncData::DoSyncCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::CTNSyncDataList()"
//==================================================================================
// CTNSyncDataList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNSyncDataList object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNSyncDataList::CTNSyncDataList(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNSyncDataList));
} // CTNSyncDataList::CTNSyncDataList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::~CTNSyncDataList()"
//==================================================================================
// CTNSyncDataList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNSyncDataList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNSyncDataList::~CTNSyncDataList(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNSyncDataList::~CTNSyncDataList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::GetDataFromTester()"
//==================================================================================
// CTNSyncDataList::GetDataFromTester
//----------------------------------------------------------------------------------
//
// Description: Retrieves pointers to the data sent by the specified tester.  Note:
//				this is not a copy of the data.
//				If either of the pointers passed in are NULL, then this function
//				returns S_OK if the tester has data in the list, or E_FAIL if not.
//
// Arguments:
//	int iTesterNum			Tester from which to retrieve data.
//	PVOID* ppvData			Pointer to set to point at data.
//	DWORD* pdwDataSize		Pointer to fill in with size of data.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSyncDataList::GetDataFromTester(int iTesterNum, PVOID* ppvData,
											DWORD* pdwDataSize)
{
	HRESULT			hr;
	int				i;
	PTNSYNCDATA		pItem = NULL;


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNSYNCDATA) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)

		if (pItem->m_iTesterNum == iTesterNum)
		{
			// If the pointers passed in are NULL, the caller just wants to know
			// if the tester already has data in the list.
			if ((ppvData == NULL) || (pdwDataSize == NULL))
			{
				this->LeaveCritSection();
				return (S_OK);
			} // end if (just trying to find out if the tester exists)

			hr = pItem->GetData(ppvData, pdwDataSize);
			this->LeaveCritSection();
			return (hr);
		} // end if (found the tester caller is looking for)
	} // end for (each data item in the list)
	this->LeaveCritSection();


	DPL(0, "Couldn't find data from tester %i!", 1, iTesterNum);

	return (E_FAIL);
} // CTNSyncDataList::GetDataFromTester
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::GetItemForTester(int)"
//==================================================================================
// Overloaded function
// CTNSyncDataList::GetItemForTester
// Integer version
//----------------------------------------------------------------------------------
//
// Description: Searches the list, and returns a pointer to the first data for the
//				specified tester for any sync operation, NULL if no more exist.
//
// Arguments:
//	int iTesterNum		Tester to search for.
//
// Returns: Pointer to data for tester if in the list, NULL otherwise.
//==================================================================================
PTNSYNCDATA CTNSyncDataList::GetItemForTester(int iTesterNum)
{
	int				i;
	PTNSYNCDATA		pItem = NULL;


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNSYNCDATA) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (NULL);
		} // end if (couldn't get that item)

		if (pItem->m_iTesterNum == iTesterNum)
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (found the tester caller is looking for)
	} // end for (each data item in the list)
	this->LeaveCritSection();


	// This is commented out because sometimes we get called just to find out
	// if the item exists or not.
	//DPL(0, "Couldn't find first item for tester %i!", 1, iTesterNum);

	return (NULL);
} //CTNSyncDataList::GetItemForTester(int)
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::GetItemForTester(char*, int)"
//==================================================================================
// Overloaded function
// CTNSyncDataList::GetItemForTester
// Name and integer version
//----------------------------------------------------------------------------------
//
// Description: Searches the list, and returns a pointer to the data for the passed
//				tester in the given sync operation if one was found, NULL otherwise.
//
// Arguments:
//	char* szSyncName	Name of sync operation.
//	int iTesterNum		Tester to search for.
//
// Returns: Pointer to data for tester if in the list, NULL otherwise.
//==================================================================================
PTNSYNCDATA CTNSyncDataList::GetItemForTester(char* szSyncName, int iTesterNum)
{
	int				i;
	PTNSYNCDATA		pItem = NULL;


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNSYNCDATA) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (NULL);
		} // end if (couldn't get that item)

		if (pItem->m_pszSyncName == NULL)
		{
			DPL(0, "Sync object %i name wasn't set up!?", 1, i);
			DEBUGBREAK();
			return (NULL);
		} // end if (the name wasn't set up)

		if ((pItem->m_iTesterNum == iTesterNum) &&
			(strcmp(pItem->m_pszSyncName, szSyncName) == 0))
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (found the tester caller is looking for)
	} // end for (each data item in the list)
	this->LeaveCritSection();


	// This is commented out because sometimes we get called just to find out
	// if the item exists or not.
	//DPL(0, "Couldn't find \"%s\" item for tester %i!", 2, szSyncName, iTesterNum);

	return (NULL);
} // CTNSyncDataList::GetItemForTester(char*, int)
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::AddAndDoSyncCheck()"
//==================================================================================
// CTNSyncDataList::AddAndDoSyncCheck
//----------------------------------------------------------------------------------
//
// Description: Adds the given tester and the specified targets to this list of
//				people trying to sync.
//				This also updates the relationships among the syncers, so that any
//				testers that become in sync as a result of this addition will be
//				accumulated in the passed in list (which should start as empty).
//				The boolean at pfInSync will be set to TRUE on function exit if
//				everyone in the affected list is in sync and should be notified.
//
// Arguments:
//	DWORD dwRequestID					ID used to identify the request generating
//										this object.
//	char* szSyncName					Unique string name of sync operation.
//	int iTesterNum						Tester who is now trying to sync.
//	int iNumTargets						Number of targets in the following array.
//	int* aiTargetList					Array of targets that the tester is trying to
//										sync with.
//	PVOID pvData						Optional pointer to data to send to targets.
//	DWORD dwDataSize					Size of data to send to targets.
//	PTNSYNCDATALIST pAffectedList		Pointer to list that accumulates all the
//										related testers.
//	BOOL* pfInSync						Pointer to boolean that will be set to TRUE
//										if all items in the affected list are in
//										sync, FALSE otherwise.
//	
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSyncDataList::AddAndDoSyncCheck(DWORD dwRequestID, char* szSyncName,
											int iTesterNum, int iNumTargets,
											int* aiTargetList, PVOID pvData,
											DWORD dwDataSize,
											PTNSYNCDATALIST pAffectedList,
											BOOL* pfInSync)
{
	HRESULT			hr = S_OK;
	PTNSYNCDATA		pNewItem = NULL;
	int				i;
	PTNSYNCDATA		pTarget = NULL;



	this->EnterCritSection();


	(*pfInSync) = FALSE;

	if (iTesterNum < 0)
	{
		DPL(0, "Tester %i is not valid!", 1, iTesterNum);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (the previous tester wasn't a place holder)

	
	pNewItem = this->GetItemForTester(szSyncName, iTesterNum);
	if (pNewItem != NULL)
	{
		// If there's no sync list for this existing object, then it's just a
		// placeholder and it's okay.  But if it does exist, then something's wacky.

		if (pNewItem->m_pSyncList != NULL)
		{
			DPL(0, "Tester %i already exists in the \"%s\" list and it's not a placeholder!",
				2, iTesterNum, szSyncName);
			hr = ERROR_ALREADY_EXISTS;
			goto DONE;
		} // end if (the previous tester wasn't a place holder)

		DPL(0, "Converting sync \"%s\" placeholder for tester %i into real object.",
			2, szSyncName, iTesterNum);

		pNewItem->m_dwRequestID = dwRequestID;
	} // end if (the tester already was in the list)
	else
	{
		// It didn't already exist, so we can make a new one.

		pNewItem = new (CTNSyncData)(dwRequestID, szSyncName, iTesterNum);
		if (pNewItem == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		hr = this->Add(pNewItem);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add the item to the list!", 0);
			delete (pNewItem);
			pNewItem = NULL;
			goto DONE;
		} // end if (adding data item failed)
	} // end else (it didn't already exist)


	// Start our sync list
	pNewItem->m_pSyncList = new (CTNSyncDataList);
	if (pNewItem->m_pSyncList == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)


	// Well of course the item we're adding is affected...
	hr = pAffectedList->Add(pNewItem);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add the item to the affected list!", 0);
		goto DONE;
	} // end if (adding item failed)


	// Assume we're in sync for starters
	(*pfInSync) = TRUE;

	// Loop through each target, and add a pointer to it (or at least a pointer to a
	// placeholder for it) to our target list.

	for(i = 0; i < iNumTargets; i++)
	{
        //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		if (((UNALIGNED int*)aiTargetList)[i] == iTesterNum)
		{
			DPL(0, "\"%s\" tester %i is trying to sync with himself!",
				2, szSyncName, iTesterNum);
			hr = ERROR_INVALID_DATA;
			goto DONE;
		} // end if (the guy is trying to sync with himself)

		pTarget = this->GetItemForTester(szSyncName, ((UNALIGNED int*)aiTargetList)[i]);
		if (pTarget == NULL)
		{
			// We'll have to create a placeholder.  This means we're not in sync.
			(*pfInSync) = FALSE;

			DPL(0, "\"%s\" target tester number %i doesn't exist.  Adding placeholder.",
				2, szSyncName, ((UNALIGNED int*)aiTargetList)[i]);
			

			// Note we create a place holder in this main list here and put a
			// reference to it in the syncer's target list below.
			
			pTarget = new (CTNSyncData)(0, szSyncName, ((UNALIGNED int*)aiTargetList)[i]);
			if (pTarget == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)

			hr = this->Add(pTarget);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add the target item to the list!", 0);
				delete (pTarget);
				pTarget = NULL;
				goto DONE;
			} // end if (adding data item failed)

		} // end if (the tester wasn't in the list)
		else
		{
			// The target already existed, check to see if it's a placeholder.
			// If it is a placeholder, we're not in sync.  If it's not, and we're
			// in sync so far, and we haven't checked it yet, then do the
			// recursive sync check.

			if (pTarget->m_pSyncList == NULL)
				(*pfInSync) = FALSE;
			else if ((*pfInSync))
			{
				if (pAffectedList->GetFirstIndex(pTarget) < 0)
				{
					hr = pTarget->DoSyncCheck(pAffectedList, pfInSync);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't perform sync check for target tester %i!",
							1, ((UNALIGNED int*)aiTargetList)[i]);
						goto DONE;
					} // end if (couldn't add placeholder)
				} // end if (we haven't checked this target yet)

			} // end else if (not a placeholder and still in sync so far)
		} // end else (the tester already existed)


		// Now that we have a pointer to the target, or at the very least a pointer
		// to his placeholder, we can add it to this syncer's list of targets.  See
		// the above notes.
		
		hr = pNewItem->m_pSyncList->Add(pTarget);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add target tester %i to \"%s\" list!", 2, ((UNALIGNED int*)aiTargetList)[i],
				szSyncName);
			goto DONE;
		} // end if (adding target failed)

	} // end for (each target)


	hr = pNewItem->SetData(pvData, dwDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't set tester %i's data!", 1, iTesterNum);
		goto DONE;
	} // end if (setting item's data failed)



DONE:

	this->LeaveCritSection();

	return (hr);
} // CTNSyncDataList::AddAndDoSyncCheck
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::AddDataFromTester()"
//==================================================================================
// CTNSyncDataList::AddDataFromTester
//----------------------------------------------------------------------------------
//
// Description: Sets this object's data to a copy based on the pointers passed in.
//				If data already existed, it is freed to make room.
//
// Arguments:
//	int iTesterNum			Tester whose data we're adding.
//	PVOID pvNewData			Pointer to data to set.
//	DWORD dwNewDataSize		Size of data to set.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSyncDataList::AddDataFromTester(int iTesterNum, 	PVOID pvNewData,
											DWORD dwNewDataSize)
{
	HRESULT			hr = S_OK;
	PTNSYNCDATA		pItem = NULL;


	if ((pvNewData == NULL) || (dwNewDataSize == 0))
	{
		DPL(0, "Attempting to add NULL data!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (the tester already has data in the list)

	this->EnterCritSection();

	// I removed this check because we now put things on the front of the list
	// (like a stack), so a pointer to the old data will still be valid, but any
	// time you try to request data from this tester you'll get the most recent
	// one.
#if 0
	if (this->GetDataFromTester(iTesterNum, NULL, NULL) == S_OK)
	{
		DPL(0, "Tester %i already has data in the list!",
			1, iTesterNum);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (the tester already has data in the list)
#endif


	pItem = new (CTNSyncData)(0, NULL, iTesterNum);
	if (pItem == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	hr = pItem->SetData(pvNewData, dwNewDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't set the item's data!", 0);
		goto DONE;
	} // end if (setting data failed)


	// See above note
#if 0
	hr = this->Add(pItem);
#else
	hr = this->AddAfter(pItem, NULL); // put it at the front of the list
#endif

	if (hr != S_OK)
	{
		DPL(0, "Couldn't add the item to the list!", 0);
		goto DONE;
	} // end if (adding data item failed)

	pItem = NULL; // forget about it so we don't free it below


DONE:

	this->LeaveCritSection();

	if (pItem != NULL)
		delete (pItem);

	return (hr);
} // CTNSyncDataList::AddDataFromTester
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::PackDataForTesterIntoBuffer()"
//==================================================================================
// CTNSyncDataList::PackDataForTesterIntoBuffer
//----------------------------------------------------------------------------------
//
// Description: Flattens all the data in this list for the specified tester into a
//				contiguous buffer for easy transmission.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required.
//				If the tester number to retrieve is -1, all items are stuffed.
//
// Arguments:
//	int iTesterNum			Tester for which to retrieve data, or -1 for all.
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to fill in with
//							buffer size required.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSyncDataList::PackDataForTesterIntoBuffer(int iTesterNum,
													PVOID pvBuffer,
													DWORD* pdwBufferSize)
{
	HRESULT			hr;
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				i;
	PTNSYNCDATA		pItem = NULL;
	PVOID			pvItemData = NULL;
	DWORD			dwItemDataSize = 0;



	(*pdwBufferSize) = 0;

	if (this->Count() <= 0)
	{
		return (S_OK);
	} // end if (there aren't any items in this list)

	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNSYNCDATA) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)


		// If it's the specified tester, he's obviously not going to be sending
		// data to himself, so skip it.
		if (pItem->m_iTesterNum == iTesterNum)
		{
			continue;
		} // end if (tester number matters and this isn't it)

		hr = pItem->GetData(&pvItemData, &dwItemDataSize);
		if (hr != S_OK)
		{
			this->LeaveCritSection();
			DPL(0, "Get item %i's data failed!", 1, i);
			return (hr);
		} // end if (couldn't get that item)

		// If there is no data, then skip it.
		if ((pvItemData == NULL) || (dwItemDataSize <= 0))
			continue;

		// If we haven't added any items yet, we need to make room for the header
		// that says how many items we have.
		if ((*pdwBufferSize) == 0)
		{
			(*pdwBufferSize) = sizeof (int); // number of items in the list

			// If there's a buffer, intialize the header.
			if (pvBuffer != NULL)
			{
				*((int*) pvBuffer) = 0;
				lpCurrent += sizeof (int); // move the pointer
			} // end if (there's a buffer to copy to)
		} // end if (this is the first item)

		(*pdwBufferSize) += sizeof (int)		// tester number
							+ sizeof (DWORD)	// size of item data
							+ dwItemDataSize;	// item data

		if (pvBuffer != NULL)
		{
			// Adjust the header
			(*((int*) pvBuffer))++;

			// Copy the item to the current location
			CopyAndMoveDestPointer(lpCurrent, &(pItem->m_iTesterNum), sizeof (int))
			CopyAndMoveDestPointer(lpCurrent, &dwItemDataSize, sizeof (DWORD))
			CopyAndMoveDestPointer(lpCurrent, pvItemData, dwItemDataSize)
		} // end if (there's a buffer to copy to)
	} // end for (each data item in the list)
	this->LeaveCritSection();

	if (pvBuffer == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
} // CTNSyncDataList::PackDataForTesterIntoBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSyncDataList::UnpackFromBuffer()"
//==================================================================================
// CTNSyncDataList::UnpackFromBuffer
//----------------------------------------------------------------------------------
//
// Description: Populates this list with the contents previously stored in a
//				contiguous buffer.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD dwBufferSize		Size of buffer.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNSyncDataList::UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize)
{
	HRESULT				hr;
	LPBYTE				lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int					iNumItems = 0;
	int					i;
	int					iTesterNum = -1;
	DWORD				dwDataSize = 0;


	this->EnterCritSection();

	CopyAndMoveSrcPointer(&iNumItems, lpCurrent, sizeof (int));

	for(i = 0; i < iNumItems; i++)
	{
		CopyAndMoveSrcPointer(&iTesterNum, lpCurrent, sizeof (int));
		CopyAndMoveSrcPointer(&dwDataSize, lpCurrent, sizeof (DWORD));

		hr = this->AddDataFromTester(iTesterNum, lpCurrent, dwDataSize);
		if (hr != S_OK)
		{
			this->LeaveCritSection();
			DPL(0, "Adding data item %i (from tester %i) failed!",
				2, i, iTesterNum);
			return (hr);
		} // end if (couldn't get that item)

		lpCurrent += dwDataSize; // we have to manually move the pointer
	} // end for (each data item in the list)
	this->LeaveCritSection();

	return (S_OK);
} // CTNSyncDataList::UnpackFromBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tablecase.h ===
#ifndef __TNCONTROL_TESTTABLECASE__
#define __TNCONTROL_TESTTABLECASE__
//#pragma message("Defining __TNCONTROL_TESTTABLECASE__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNTestTableCase:public CTNTestTableItem
{
	public:
		char*					m_pszDescription; // pointer to this item's constant description string
		char*					m_pszInputDataHelp; // pointer to this item's constant input data help string

		int						m_iNumMachines; // the number of machines required to run this test
		DWORD					m_dwOptionFlags; // test options

		PTNCANRUNPROC			m_pfnCanRun; // callback for master to use to check if a given machine can run this
		PTNGETINPUTDATAPROC		m_pfnGetInputData; // callback for master to use to retrieve initial data
		PTNEXECCASEPROC			m_pfnExecCase; // callback for slave to use to execute the test case
		PTNWRITEDATAPROC		m_pfnWriteData; // callback for master to use when writing report or initial data to strings
		PTNFILTERSUCCESSPROC	m_pfnFilterSuccess; // callback for master to use when double checking that a success is really a success

		PTNGRAPHITEM			m_paGraphs; // array of graph items
		DWORD					m_dwNumGraphs; // number of graph items in the following array

		CTNTestStats			m_stats; // statistics for this case


		CTNTestTableCase(void);
		virtual ~CTNTestTableCase(void);


		// Virtual implementations
		HRESULT CalculateChecksum(LPCHECKSUM lpChecksum);
#ifndef _XBOX // no file printing
		HRESULT PrintToFile(HANDLE hFile, DWORD dwOptions);
#endif // ! XBOX
};






#else //__TNCONTROL_TESTTABLECASE__
//#pragma message("__TNCONTROL_TESTTABLECASE__ already included!")
#endif //__TNCONTROL_TESTTABLECASE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tablecase.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#ifdef _XBOX // Damn ANSI conversion
#include <stdio.h>
#include <stdlib.h>
#endif

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"

#include "tablecase.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableCase::CTNTestTableCase()"
//==================================================================================
// CTNTestTableCase constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestTableCase object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNTestTableCase::CTNTestTableCase(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTestTableCase));

	this->m_pszDescription = NULL;
	this->m_pszInputDataHelp = NULL;

	this->m_iNumMachines = -1;
	this->m_dwOptionFlags = 0;

	this->m_pfnCanRun = NULL;

	this->m_pfnGetInputData = NULL;
	this->m_pfnExecCase = NULL;
	this->m_pfnWriteData = NULL;
	this->m_pfnFilterSuccess = NULL;

	this->m_paGraphs = NULL;
	this->m_dwNumGraphs = 0;
} // CTNTestTableCase::CTNTestTableCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableCase::~CTNTestTableCase()"
//==================================================================================
// CTNTestTableCase destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestTableCase object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestTableCase::~CTNTestTableCase(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNTestTableCase::~CTNTestTableCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableCase::CalculateChecksum()"
//==================================================================================
// CTNTestTableCase::CalculateChecksum
//----------------------------------------------------------------------------------
//
// Description: Calculates the checksum for this test case.
//
// Arguments:
//	LPCHECKSUM lpChecksum	Place to store checksum generated.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableCase::CalculateChecksum(LPCHECKSUM lpChecksum)
{
	// Calculate checksum with our name, ID, num machines and options.
	(*lpChecksum) = GetChecksum(this->m_pszName, strlen(this->m_pszName))
					+ GetChecksum(this->m_pszID, strlen(this->m_pszID))
					+ this->m_iNumMachines
					+ this->m_dwOptionFlags;
	return (S_OK);
} // CTNTestTableCase::CalculateChecksum
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#ifndef _XBOX // ! XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableCase::PrintToFile()"
//==================================================================================
// CTNTestTableCase::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the name and ID of this test case to the passed in file.
//
// Arguments:
//	HANDLE hFile		File to print to.
//	DWORD dwOptions		Options on how to print.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableCase::PrintToFile(HANDLE hFile, DWORD dwOptions)
{
	char	szTemp[256];
#ifdef _XBOX // Damn ANSI conversion
	WCHAR	szWideTemp[256];
#endif

	// If this is a built-in script and we shouldn't print those, we're done.
	if ((this->m_dwOptionFlags & TNTCO_BUILTIN) && (! (dwOptions & TNTTPO_BUILTIN)))
		return (S_OK);


	if ((this->m_pszID == NULL) || (this->m_pszName == NULL))
	{
		DPL(0, "This test case (%x) is invalid!", 1, this);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (there's not a valid ID or name)


	//Ignoring errors for these
	FileWriteString(hFile, this->m_pszID);
	FileWriteString(hFile, "\t");
	FileWriteString(hFile, this->m_pszName);

	if (dwOptions & TNTTPO_CASEDESCRIPTIONS)
	{
#pragma BUGBUG(vanceo, "Remove check when all tests switched over to new ADDTESTDATA")
		if (this->m_pszDescription != NULL)
		{
			FileWriteString(hFile, "\t");
			FileWriteString(hFile, this->m_pszDescription);
		} // end if (there's a description)
	} // end if (we should print case descriptions)

	if (dwOptions & TNTTPO_SUCCESSES)
	{
#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szTemp, "\t%i", this->m_stats.GetSuccesses());
#else
		swprintf(szWideTemp, L"\t%i", this->m_stats.GetSuccesses());
		wcstombs(szTemp, szWideTemp, wcslen(szWideTemp));
		szTemp[wcslen(szWideTemp)] = 0;
#endif
		FileWriteString(hFile, szTemp);	
	} // end if (we should print the total)

	if (dwOptions & TNTTPO_FAILURES)
	{
#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szTemp, "\t%i", this->m_stats.GetFailures());
#else
		swprintf(szWideTemp, L"\t%i", this->m_stats.GetFailures());
		wcstombs(szTemp, szWideTemp, wcslen(szWideTemp));
		szTemp[wcslen(szWideTemp)] = 0;
#endif
		FileWriteString(hFile, szTemp);	
	} // end if (we should print the total)

	if (dwOptions & TNTTPO_TOTAL)
	{
#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szTemp, "\t%i", this->m_stats.GetTotalComplete());
#else
		swprintf(szWideTemp, L"\t%i", this->m_stats.GetTotalComplete());
		wcstombs(szTemp, szWideTemp, wcslen(szWideTemp));
		szTemp[wcslen(szWideTemp)] = 0;
#endif
		FileWriteString(hFile, szTemp);	
	} // end if (we should print the total)

	if (dwOptions & TNTTPO_WARNINGS)
	{
#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szTemp, "\t%i", this->m_stats.GetWarnings());
#else
		swprintf(szWideTemp, L"\t%i", this->m_stats.GetWarnings());
		wcstombs(szTemp, szWideTemp, wcslen(szWideTemp));
		szTemp[wcslen(szWideTemp)] = 0;
#endif
		FileWriteString(hFile, szTemp);	
	} // end if (we should print the total)

	// This will end the line
	FileWriteLine(hFile, "");


	return (S_OK);
} // CTNTestTableCase::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tablegroup.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\strutils.h"

#include "tncontrl.h"
#include "main.h"

#include "tablegroup.h"




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::CTNTestTableGroup()"
//==================================================================================
// CTNTestTableGroup constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestTableGroup object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNTestTableGroup::CTNTestTableGroup(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTestTableGroup));

	this->m_fGroup = TRUE;
} // CTNTestTableGroup::CTNTestTableGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::~CTNTestTableGroup()"
//==================================================================================
// CTNTestTableGroup destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestTableGroup object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestTableGroup::~CTNTestTableGroup(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNTestTableGroup::~CTNTestTableGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::CalculateChecksum()"
//==================================================================================
// CTNTestTableGroup::CalculateChecksum
//----------------------------------------------------------------------------------
//
// Description: Calculates the checksum for this group based on all the test cases
//				and sub groups it contains.
//
// Arguments:
//	LPCHECKSUM lpChecksum	Place to store checksum generated.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableGroup::CalculateChecksum(LPCHECKSUM lpChecksum)
{
	HRESULT				hr = S_OK;
	PTNTESTTABLEITEM	pItem = NULL;
	int					i;
	CHECKSUM			subChecksum;



	this->m_items.EnterCritSection();


	// Start checksum with the number of sub items, our name and ID.

	(*lpChecksum) = this->m_items.Count();

	if (this->m_pszName != NULL)
		(*lpChecksum) += GetChecksum(this->m_pszName, strlen(this->m_pszName));

	if (this->m_pszName != NULL)
		(*lpChecksum) += GetChecksum(this->m_pszID, strlen(this->m_pszID));


	// Loop through all the subitems and grab their checksum too.
	for(i = 0; i < this->m_items.Count(); i++)
	{
		pItem = (PTNTESTTABLEITEM) this->m_items.GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't get item %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get that item)

		hr = pItem->CalculateChecksum(&subChecksum);
		if (hr != S_OK)
		{
			DPL(0, "Calculating subitem %i (%x)'s checksum failed!",
				2, i, pItem);
			goto DONE;
		} // end if (calculating subgroup checksum failed)

		(*lpChecksum) += subChecksum;
	} // end for (each item in this group)


DONE:

	this->m_items.LeaveCritSection();

	return (hr);
} // CTNTestTableGroup::CalculateChecksum
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::GetNumberOfCases()"
//==================================================================================
// CTNTestTableGroup::GetNumberOfCases
//----------------------------------------------------------------------------------
//
// Description: Returns the number of test cases contained in this group.  The
//				hierarchy is treated as flat.
//
// Arguments:
//	int* piTotal	Pointer to place to store total.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableGroup::GetNumberOfCases(int* piTotal)
{
	HRESULT				hr;
	int					i;
	PTNTESTTABLEITEM	pItem = NULL;


	for(i = 0; i < this->m_items.Count(); i++)
	{
		pItem = (PTNTESTTABLEITEM) this->m_items.GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve item %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)

		if (pItem->m_fGroup)
		{
			hr = ((PTNTESTTABLEGROUP) pItem)->GetNumberOfCases(piTotal);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't get number of cases from group indexed %i!",
					1, i);
				return (hr);
			} // end if (an error occurred)
		} // end if (the item is a group)
		else
		{
			// Don't report the built-in test cases

			if (! (((PTNTESTTABLECASE) pItem)->m_dwOptionFlags & TNTCO_BUILTIN))
				(*piTotal)++;
		} // end else (the item is a case)
	} // end for (each item in the testtable)

	return (S_OK);
} // CTNTestTableGroup::GetNumberOfCases
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::GetCaseIndex()"
//==================================================================================
// CTNTestTableGroup::GetCaseIndex
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the case at the given index, searching all sub
//				groups, treating the hierarchy as flat.
//
// Arguments:
//	int* piNumItemsLeft			Pointer to item to use in determining when we've
//								reached the item.
//	PTNTESTTABLECASE* ppCase	Pointer to place to store result if found.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableGroup::GetCaseIndex(int* piNumItemsLeft, PTNTESTTABLECASE* ppCase)
{
	HRESULT				hr;
	int					i;
	PTNTESTTABLEITEM	pItem = NULL;


	for(i = 0; i < this->m_items.Count(); i++)
	{
		pItem = (PTNTESTTABLEITEM) this->m_items.GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve item %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)

		if (pItem->m_fGroup)
		{
			hr = ((PTNTESTTABLEGROUP) pItem)->GetCaseIndex(piNumItemsLeft,
															ppCase);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't get case from group indexed %i!", 1, i);
				return (hr);
			} // end if (an error occurred)

			// If the subgroup found it, then we're done too
			if ((*ppCase) != NULL)
				return (S_OK);
		} // end if (the item is a group)
		else
		{
			// Don't return built-in cases.
			if (! (((PTNTESTTABLECASE) pItem)->m_dwOptionFlags & TNTCO_BUILTIN))
			{
				if ((*piNumItemsLeft) == 0)
				{
					(*ppCase) = (PTNTESTTABLECASE) pItem;

					return (S_OK);
				} // end if (this is the item we want)

				// Otherwise, move on
				(*piNumItemsLeft)--;
			} // end if (it's not a built-in test case)
		} // end else (the item is a case)
	} // end for (each item in the testtable)


	// We didn't find it in this group, but that's not a fatal error.
	//(*ppCase) = NULL;

	return (S_OK);
} // CTNTestTableGroup::GetCaseIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::NewGroup()"
//==================================================================================
// CTNTestTableGroup::NewGroup
//----------------------------------------------------------------------------------
//
// Description: Creates a new grouping with the given ID & name, and adds it to the
//				end of the list.
//				The strings must be constant (must point to valid memory for life
//				of object).
//
// Arguments:
//	char* pszID		Pointer to constant string ID of the group.
//	char* pszName	Pointer to constant string name of the group.
//
// Returns: Pointer to the new group or NULL if an error occurred.
//==================================================================================
PTNTESTTABLEGROUP CTNTestTableGroup::NewGroup(char* pszID, char* pszName)
{
	HRESULT				hr;
	PTNTESTTABLEGROUP	pNewGroup = NULL;


	if ((pszID == NULL) || (strlen(pszID) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty ID string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (passed in invalid param)

	if ((pszName == NULL) || (strlen(pszName) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty name string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (passed in invalid param)

	pNewGroup = new (CTNTestTableGroup);
	if (pNewGroup == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	// Save the string pointers.
	pNewGroup->m_pszID = pszID;
	pNewGroup->m_pszName = pszName;
	
	hr = this->m_items.Add(pNewGroup);
	if (hr != S_OK)
	{
		DPL(0, "Adding group failed!", 0);
		goto ERROR_EXIT;
	} // end if (add failed)

	return (pNewGroup);


ERROR_EXIT:

	if (pNewGroup != NULL)
	{
		delete (pNewGroup);
		pNewGroup = NULL;
	} // end if (have object)

	return (NULL);
} // CTNTestTableGroup::NewGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::NewSubGroup()"
//==================================================================================
// CTNTestTableGroup::NewSubGroup
//----------------------------------------------------------------------------------
//
// Description: Creates a new subgrouping with the given ID & name, and adds it to
//				the end of the list.
//				The strings must be constant (must point to valid memory for life
//				of object).
//
// Arguments:
//	char* pszID							Pointer to constant string ID of the group.
//	char* pszName						Pointer to constant string name of the
//										group.
//	PTNTESTTABLEGROUP* ppNewSubGroup	Place to store group created.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableGroup::NewSubGroup(char* pszID, char* pszName,
									PTNTESTTABLEGROUP* ppNewSubGroup)
{
	HRESULT		hr;


	(*ppNewSubGroup) = NULL;

	if ((pszID == NULL) || (strlen(pszID) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty ID string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (passed in invalid param)

	if ((pszName == NULL) || (strlen(pszName) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty name string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (passed in invalid param)

	// Only the built-in group is allowed to pass some non-numeric characters.
	if (strcmp(pszID, "BuiltIn") != 0)
	{
		if (StringContainsNonChar(pszID, "0123456789.", TRUE, 0) >= 0)
		{
			// It's an invalid character)
			DPL(0, "Group ID cannot contain any characters other than numbers and periods (specified \"%s\")!",
				1, pszID);
			hr = ERROR_INVALID_PARAMETER;
			goto ERROR_EXIT;
		} // end if (non-numeric or period character)
	} // end if (not built-in group)

#pragma TODO(vanceo, "Validate uniqueness and location of ID")


	(*ppNewSubGroup) = new (CTNTestTableGroup);
	if ((*ppNewSubGroup) == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	// Save the string pointers.
	(*ppNewSubGroup)->m_pszID = pszID;
	(*ppNewSubGroup)->m_pszName = pszName;
	
	hr = this->m_items.Add(*ppNewSubGroup);
	if (hr != S_OK)
	{
		DPL(0, "Adding group failed!", 0);
		goto ERROR_EXIT;
	} // end if (add failed)

	return (S_OK);


ERROR_EXIT:

	if ((*ppNewSubGroup) != NULL)
	{
		delete (*ppNewSubGroup);
		(*ppNewSubGroup) = NULL;
	} // end if (have object)

	return (hr);
} // CTNTestTableGroup::NewSubGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // no master supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::AddTest()"
//==================================================================================
// CTNTestTableGroup::AddTest
//----------------------------------------------------------------------------------
//
// Description: Adds the passed in test ID to the end of the list.
//				The strings must be constant (must point to valid memory for life
//				of object).
//
// Arguments:
//	char* pszCaseID				Pointer to constant string ID of the test.
//	char* pszName				Pointer to constant string name of the test.
//	int iNumMachines			Number of machines required for this test.
//	DWORD dwOptionFlags			Options for this test (TNTCO_xxx).
//	PTNTESTCASEPROCS pProcs		Pointer to structure containing a list of callback
//								functions associated with the new case.
//	DWORD dwNumGraphs			Number of graph items in the following array.
//	PTNGRAPHITEM paGraphs		Array of TNGRAPHITEMs.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableGroup::AddTest(char* pszCaseID, char* pszName, int iNumMachines,
						DWORD dwOptionFlags, PTNTESTCASEPROCS pProcs,
						DWORD dwNumGraphs, PTNGRAPHITEM paGraphs)
{
	HRESULT				hr;
	PTNTESTTABLECASE	pNewTest = NULL;


	if (iNumMachines < 0)
	{
		DPL(0, "Can't pass a negative number for number of machines required!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (invalid number of machines)

	if ((pszCaseID == NULL) || (strlen(pszCaseID) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty case ID string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)

	if ((pszName == NULL) || (strlen(pszName) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty name string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)

	// Built-in test cases are allowed to pass some non-numeric characters.  We'll
	// assume the developer knows what he's doing, so we'll just skip the checking
	// completely.
	if (! (dwOptionFlags & TNTCO_BUILTIN))
	{
		if (StringContainsNonChar(pszCaseID, "0123456789.", TRUE, 0) >= 0)
		{
			// It's an invalid character)
			DPL(0, "Test ID cannot contain any characters other than numbers and periods (specified \"%s\")!",
				1, pszCaseID);
			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (non-numeric or period character)
	} // end if (not built-in test case)

	//BUGBUG these aren't checked later on yet
	if (! (dwOptionFlags & (TNTCO_API | TNTCO_STRESS | TNTCO_POKE)))
	{
		DPL(0, "Invalid test to add (\"%s\"), need to specify availability in API, stress, or poke mode!",
			1, pszCaseID);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (test passed in invalid)

	pNewTest = new (CTNTestTableCase);
	if (pNewTest == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Save the string pointers.
	pNewTest->m_pszID = pszCaseID;
	pNewTest->m_pszName = pszName;

	pNewTest->m_iNumMachines = iNumMachines;
	pNewTest->m_dwOptionFlags = dwOptionFlags;
	pNewTest->m_pfnCanRun = pProcs->pfnCanRun;
	pNewTest->m_pfnGetInputData = pProcs->pfnGetInputData;
	pNewTest->m_pfnExecCase = pProcs->pfnExecCase;
	pNewTest->m_pfnWriteData = pProcs->pfnWriteData;
	pNewTest->m_pfnFilterSuccess = pProcs->pfnFilterSuccess;
	pNewTest->m_dwNumGraphs = dwNumGraphs;
	pNewTest->m_paGraphs = paGraphs;

	//BUGBUG Generate a checksum for this item
	//pNewTest->m_dwChecksum = ?

	//DPL(0, "Adding test at %x to list at %x", 2, pNewTest, this);
	
	hr = this->m_items.Add(pNewTest);
	if (hr != S_OK)
	{
		DPL(0, "Adding test failed!", 0);
		goto DONE;
	} // end if (add failed)

	pNewTest = NULL; // forget about it so we don't free it below


DONE:

	if (pNewTest != NULL)
	{
		delete(pNewTest);
		pNewTest = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNTestTableGroup::AddTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::AddTest()"
//==================================================================================
// CTNTestTableGroup::AddTest
//----------------------------------------------------------------------------------
//
// Description: Adds the passed in test to the end of the list.
//
// Arguments:
//	PTNADDTESTDATA pAddTestData		Pointer to structure containing information on
//									test case to add.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableGroup::AddTest(PTNADDTESTDATA pAddTestData)
{
	HRESULT				hr;
	PTNTESTTABLECASE	pNewTest = NULL;


	if (pAddTestData->dwSize != sizeof (TNADDTESTDATA))
	{
		DPL(0, "AddTestData structure size is not correct (%u != %u)!",
			2, pAddTestData->dwSize, sizeof (TNADDTESTDATA));
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)

	if ((pAddTestData->pszCaseID == NULL) || (strlen(pAddTestData->pszCaseID) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty case ID string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)

	// Built-in test cases are allowed to pass some non-numeric characters.  We'll
	// assume the control layer developer knows what he's doing, so we'll just skip
	// the checking completely.
	if (! (pAddTestData->dwOptionFlags & TNTCO_BUILTIN))
	{
		if (StringContainsNonChar(pAddTestData->pszCaseID, "0123456789.", TRUE, 0) >= 0)
		{
			// It's an invalid character)
			DPL(0, "Test ID cannot contain any characters other than numbers and periods (specified \"%s\")!",
				1, pAddTestData->pszCaseID);
			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (non-numeric or period character)
	} // end if (not built-in test case)

#pragma TODO(vanceo, "Validate uniqueness and location of case ID")

	if ((pAddTestData->pszName == NULL) || (strlen(pAddTestData->pszName) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty name string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)

	if ((pAddTestData->pszDescription == NULL) || (strlen(pAddTestData->pszDescription) <= 0))
	{
		DPL(0, "Can't pass a NULL or empty description string!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)

	if (pAddTestData->pszInputDataHelp == NULL)
	{
		if (pAddTestData->pfnGetInputData != NULL)
		{
			DPL(0, "Must pass an input data help string when using a GetInputData callback!", 0);
			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (callback)
	} // end if (input data help string)
	else
	{
		if (pAddTestData->pfnGetInputData == NULL)
		{
			DPL(0, "Can't pass an input data help string when no GetInputData callback!", 0);
			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (no callback)

		if (strlen(pAddTestData->pszInputDataHelp) <= 0)
		{
			DPL(0, "Can't pass an empty input data help string!", 0);
			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (empty string)
	} // end else (no input data help string)


	if (pAddTestData->iNumMachines == 0)
	{
		DPL(0, "Can't pass 0 for number of machines required!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)

	if (! (pAddTestData->dwOptionFlags & (TNTCO_API | TNTCO_STRESS | TNTCO_POKE | TNTCO_PICKY)))
	{
		DPL(0, "Need to specify availability in API, stress, poke, or picky mode!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)

	if (! (pAddTestData->dwOptionFlags & (TNTCO_TOPLEVELTEST | TNTCO_SUBTEST)))
	{
		DPL(0, "Need to specify either TOPLEVELTEST, SUBTEST or both!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (passed in invalid param)


	if (pAddTestData->pfnExecCase == NULL)
	{
		DPL(0, "Test case must have at least an ExecCase function!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (doesn't have exec case)



	pNewTest = new (CTNTestTableCase);
	if (pNewTest == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Save the string pointers.
	pNewTest->m_pszID = pAddTestData->pszCaseID;
	pNewTest->m_pszName = pAddTestData->pszName;
	pNewTest->m_pszDescription = pAddTestData->pszDescription;
	pNewTest->m_pszInputDataHelp = pAddTestData->pszInputDataHelp;

	pNewTest->m_iNumMachines = pAddTestData->iNumMachines;
	pNewTest->m_dwOptionFlags = pAddTestData->dwOptionFlags;

	pNewTest->m_pfnCanRun = pAddTestData->pfnCanRun;
	pNewTest->m_pfnGetInputData = pAddTestData->pfnGetInputData;
	pNewTest->m_pfnExecCase = pAddTestData->pfnExecCase;
	pNewTest->m_pfnWriteData = pAddTestData->pfnWriteData;
	pNewTest->m_pfnFilterSuccess = pAddTestData->pfnFilterSuccess;

	pNewTest->m_paGraphs = pAddTestData->paGraphs;
	pNewTest->m_dwNumGraphs = pAddTestData->dwNumGraphs;


	//DPL(9, "Adding test at %x to list at %x", 2, pNewTest, this);
	
	hr = this->m_items.Add(pNewTest);
	if (hr != S_OK)
	{
		DPL(0, "Adding test failed!", 0);
		goto DONE;
	} // end if (add failed)

	pNewTest = NULL; // forget about it so we don't free it below


DONE:

	if (pNewTest != NULL)
	{
		delete(pNewTest);
		pNewTest = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNTestTableGroup::AddTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::GetTest()"
//==================================================================================
// CTNTestTableGroup::GetTest
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the CTNTestTableCase object identified by the
//				passed in module ID.
//
// Arguments:
//	char* szID		Module defined ID of test to retrieve.
//
// Returns: Pointer to object or NULL if couldn't find it.
//==================================================================================
PTNTESTTABLECASE CTNTestTableGroup::GetTest(char* szID)
{
	int					i;
	PTNTESTTABLEITEM	pItem = NULL;


	this->m_items.EnterCritSection();
	for(i = 0; i < this->m_items.Count(); i++)
	{
		pItem = (PTNTESTTABLEITEM) this->m_items.GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve table item %i!", 1, i);
			this->m_items.LeaveCritSection();
			return (NULL);
		} // end if (couldn't get that item)

		if (pItem->m_fGroup)
		{
			// Try having the group look through its members for the test
			pItem = ((PTNTESTTABLEGROUP) pItem)->GetTest(szID);
			if (pItem != NULL)
			{
				this->m_items.LeaveCritSection();
				return ((PTNTESTTABLECASE) pItem);
			} // end if (the group found the module ID)
		} // end if (this is a group)
		else
		{
			if (strcmp(pItem->m_pszID, szID) == 0)
			{
				this->m_items.LeaveCritSection();
				return ((PTNTESTTABLECASE) pItem);
			} // end if (we found the module ID)
		} // end else (this is a test case)
	} // end for (each test)

	this->m_items.LeaveCritSection();

	return (NULL);
} // CTNTestTableGroup::GetTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#ifndef _XBOX // no file printing supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableGroup::PrintToFile()"
//==================================================================================
// CTNTestTableGroup::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the contents of this group to the passed in file.
//
// Arguments:
//	HANDLE hFile		File to print to.
//	DWORD dwOptions		Options on how to print.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestTableGroup::PrintToFile(HANDLE hFile, DWORD dwOptions)
{
	HRESULT				hr;
	int					i;
	PTNTESTTABLEITEM	pItem = NULL;


	if (dwOptions & TNTTPO_GROUPS)
	{
		if ((this->m_pszID != NULL) && (this->m_pszName != NULL))
		{
			//Ignoring errors for these
			FileWriteString(hFile, this->m_pszID);
			FileWriteString(hFile, "\t");
			FileWriteLine(hFile, this->m_pszName);
		} // end if (there's a valid ID and name)
	} // end if (groups should be printed)

	this->m_items.EnterCritSection();
	for(i = 0; i < this->m_items.Count(); i++)
	{
		pItem = (PTNTESTTABLEITEM) this->m_items.GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve table item %i!", 1, i);
			this->m_items.LeaveCritSection();
			return (E_FAIL);
		} // end if (couldn't get that item)

		hr = pItem->PrintToFile(hFile, dwOptions);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't print table item %i to file!", 1, i);
			this->m_items.LeaveCritSection();
			return (hr);
		} // end if (couldn't get that item)
	} // end for (each test)

	this->m_items.LeaveCritSection();

	return (S_OK);
} // CTNTestTableGroup::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tableitem.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"

#include "tncontrl.h"
#include "main.h"

#include "tableitem.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableItem::CTNTestTableItem()"
//==================================================================================
// CTNTestTableItem constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestTableItem object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNTestTableItem::CTNTestTableItem(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTestTableItem));

	this->m_pszID = NULL;
	this->m_pszName = NULL;
	this->m_fGroup = FALSE;
} // CTNTestTableItem::CTNTestTableItem
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestTableItem::~CTNTestTableItem()"
//==================================================================================
// CTNTestTableItem destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestTableItem object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestTableItem::~CTNTestTableItem(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNTestTableItem::~CTNTestTableItem
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tablegroup.h ===
#ifndef __TNCONTROL_TESTTABLEGROUP__
#define __TNCONTROL_TESTTABLEGROUP__
//#pragma message("Defining __TNCONTROL_TESTTABLEGROUP__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNTestTableGroup:public CTNTestTableItem
{
	public:
		LLIST	m_items; // all table items contained in this group


		CTNTestTableGroup(void);
		//virtual ~CTNTestTableGroup(void);


		HRESULT CalculateChecksum(LPCHECKSUM lpChecksum);

		HRESULT GetNumberOfCases(int* piTotal);

		HRESULT GetCaseIndex(int* piNumItemsLeft, PTNTESTTABLECASE* ppCase);

		PTNTESTTABLEGROUP 