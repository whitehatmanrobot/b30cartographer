ack[nDlg], m_nCurrTrack);
	if (nHelpID == 0)
		nHelpID = pDlg->m_nTemplate;
	else
		nHelpID -= HID_BASE_RESOURCE;
	SetHelpID(nHelpID);
    m_nCurrIndex = nDlg;
    VERIFY(pDlg->Create(pDlg->m_nTemplate, this));
	int nLeft = m_nChildDlgLeft;
	if (!pDlg->ShouldShowPicture())
		nLeft = 0;
    pDlg->SetWindowPos(NULL, nLeft, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
    pDlg->ShowWindow(SW_SHOWNOACTIVATE);
    pDlg->EnableWindow(TRUE);
	EnableWindow(TRUE);
	SetFocusOnStep(pDlg);
#ifndef VS_PACKAGE
	imeEnableIME(0, TRUE);
#endif	// VS_PACKAGE

	UpdateStepDisplay();

	RedrawBitmap(BMPSIZE_SUM);
	RedrawBitmap(BMPSIZE_3D);
}

void CMainDlg::UpdateStepDisplay()
{
	// Determine current and maximum steps
	int nCurrentStep, nMaxStep;
	CString strWizardTitle;
	if (IsUserAWX())
	{
		// Currently an extension is in charge, so get the
		//  step numbers & title from it.
		nCurrentStep = m_nCurrUserStep;
		nMaxStep = m_nMaxUserSteps;
		strWizardTitle = projOptions.m_UserExtension.m_strExtensionTitle;
	}
	else
	{
		// Currently we're in charge, so we know the step numbers & title
		nCurrentStep = m_nCurrIndex;
		nMaxStep =
			(m_nCurrIndex <= 1 && projOptions.m_nProjType != PROJTYPE_DLL)
			? -1 : m_nCurrLastIndex-1;
		strWizardTitle.LoadString(IDS_APPWIZ_TITLE);
	}

	// Now construct the title message

	// Bail if we're not created yet (e.g., we just loaded a custom appwiz which
	//  set the number of steps, all before CMainDlg has been created).
	if (!GetSafeHwnd())
		return;

	CString strBuffer;
	LPTSTR szBuffer = strBuffer.GetBuffer(strWizardTitle.GetLength() + 32);
    if (nMaxStep == -1)
    {
        // We don't know the total number of steps
		CString strFullString;
		strFullString.LoadString(IDS_TITLE_NOMAXSTEP);
        sprintf(szBuffer, (LPCTSTR) strFullString, (LPCTSTR) strWizardTitle, nCurrentStep);
	    SetWindowText(szBuffer);
    }
    else if (nMaxStep > 0)
    {
        // We DO know the total number of steps
		CString strFullString;
		strFullString.LoadString(IDS_TITLE_MAXSTEP);
        sprintf(szBuffer, (LPCTSTR) strFullString, (LPCTSTR) strWizardTitle, nCurrentStep, nMaxStep);
	    SetWindowText(szBuffer);
    }
	strBuffer.ReleaseBuffer();

    // Make "Next" or "Finish" the default
	AdjustEndAndOK(nCurrentStep == nMaxStep && nMaxStep != -1);
}


// nAddHelpButton == 1 (add help button) or 0 (don't add help button)
void CMainDlg::ArrangeButtons(int nAddHelpButton)
{
	// We need to dynamically add/remove the help button, which means
	//  shifting all the other buttons to the left (or right) as
	//  appropriate, because the buttons must be right-aligned and
	//  the help button (when visible) must be on the right.
	// Thus, we store the dialog-unit coordinates here, and move the
	//  buttons to the appropriate coordinates, which we convert from
	//  dialog units to client coordinates.

	const int BACK[2]	= {  83,  23 };
	const int NEXT[2]   = { 133,  73 };
	const int FINISH[2] = { 193, 133 };
	const int CANCEL[2] = { 253, 193 };
	static int y = -1;

	ASSERT (nAddHelpButton == 1 || nAddHelpButton == 0);

	if (m_nHasHelpButton == nAddHelpButton)
		return;		// same state we were in when we came in here, so nothing to do...

	m_nHasHelpButton = nAddHelpButton;

	if (y == -1)
	{
		RECT rect;
		GetDlgItem(IDC_BACK)->GetWindowRect(&rect);
		ScreenToClient(&rect);
		y = rect.top;
	}

	RECT rect = {0,0,0,0};
	
	rect.left = BACK[nAddHelpButton];
	MapDialogRect(&rect);
	GetDlgItem(IDC_BACK)->SetWindowPos(NULL, rect.left, y, 0, 0, SWP_NOREDRAW | SWP_NOSIZE | SWP_NOZORDER);

	rect.left = NEXT[nAddHelpButton];
	MapDialogRect(&rect);
	GetDlgItem(IDOK)->SetWindowPos(NULL, rect.left, y, 0, 0, SWP_NOREDRAW | SWP_NOSIZE | SWP_NOZORDER);

	rect.left = FINISH[nAddHelpButton];
	MapDialogRect(&rect);
	GetDlgItem(IDC_END)->SetWindowPos(NULL, rect.left, y, 0, 0, SWP_NOREDRAW | SWP_NOSIZE | SWP_NOZORDER);

	rect.left = CANCEL[nAddHelpButton];
	MapDialogRect(&rect);
	GetDlgItem(IDCANCEL)->SetWindowPos(NULL, rect.left, y, 0, 0, SWP_NOREDRAW | SWP_NOSIZE | SWP_NOZORDER);

	GetDlgItem(ID_HELP)->ShowWindow(nAddHelpButton ? SW_SHOW : SW_HIDE);

	// Finally, add/remove the "?" button in the titlebar
	LONG nExStyle = GetWindowLong(m_hWnd, GWL_EXSTYLE);
	nExStyle = nAddHelpButton ?
		nExStyle & ~WS_EX_CONTEXTHELP :
		nExStyle | WS_EX_CONTEXTHELP;
	SetWindowLong(m_hWnd, GWL_EXSTYLE, nExStyle);

	Invalidate();
    DrawMenuBar();
}

// Returns TRUE if everything went according to plan and steps are being brought up
//  as normal (in which case appwiz will relinquish control when CTheDLL::m_bQuit
//  is set to TRUE).  Returns FALSE if we need to immediately bring back CPromptDlg.
//  See CTheDLL::RunAppWizSteps() to show how this is called.
BOOL CMainDlg::StartAppWizSteps()
{
    m_nCurrIndex = 0;

	// Bug 2032 in the DevStudio '96 database.  This symbol is left lingering around
	// if the previous appwizard had changed the view's type to CRichEditView.  I'm
	// really not confident that this is the right place to clear this, but it seems
	// as good as any I've found.  -mgrier 5/15/96
	RemoveSymbol("CRichEditView");

	// If this fires, be sure InitAppWiz() was called first!
	ASSERT(pLaunchParent != NULL);
	if (pLaunchParent)
		pLaunchParent->EnableWindow(FALSE);

	VERIFY(GetCurrentDirectory(_MAX_PATH, m_strCWDProjGen.GetBuffer(_MAX_PATH)) != 0);
	m_strCWDProjGen.ReleaseBuffer();

	InitializeUserVars();

	// A change in the CPromptDlg's project type may cause a track change.
	SetCurrentTrack();
	
	if (IsUserAWX())
	{
		// Launch the custom AppWizard steps
		GetAllSymbols();
		if (m_nMaxUserSteps == 0)
		{
			// We have a zero-step extension
			if (GetAWX()->Next(NULL) != NULL)	// Let 'em set symbols
			{
				// They didn't return NULL when they were supposed to!
				ReportErrorExt(IDP_BAD_0STEP_AWX);
				return FALSE;
			}

			if (ActivateConfirmDlg())
				return TRUE;	// If they created project, outta here.
			return FALSE;		// Otherwise they canceled CConfirmDlg; bring back promptdlg
		}
		CalculateDimensions();
		ArrangeButtons((IsDefinitelyKnownWizard() || m_pCurrUserSeqDlg != NULL) ? 0 : 1);
        ShowWindow(SW_SHOW);
		ActivateUserDlg(TRUE);
	}
	else
	{
		// Launch the standard AppWizard steps
		CalculateDimensions();
		ArrangeButtons(0);
        ShowWindow(SW_SHOW);
        ActivateDlg(1);
	}

    return TRUE;
}

BOOL CMainDlg::ActivateConfirmDlg()
{
    CConfirmDlg dlg(this, (!IsUserAWX() || m_nMaxUserSteps != 0));

	// VERIFY(SetCurrentDirectory(m_strCWDProjGen));
	m_pConfirmDlg = &dlg;
    int nRetValue = dlg.DoModal();
	m_pConfirmDlg = NULL;
    switch(nRetValue)
    {
    case IDOK:
        if (pLaunchParent != NULL)
        {
            pLaunchParent->EnableWindow(TRUE);
			ASSERT(pLaunchParent->IsWindowEnabled());
        }
        VERIFY(DestroyWindow());
		return TRUE;
    case IDCANCEL:
		return FALSE;
    }
	return TRUE;
}

void MyPostQuitMessage()
{
	::PostMessage(NULL, WM_MYQUIT, 0, 0);
}

void CMainDlg::OnDestroy()
{
	if (pLaunchParent)
		pLaunchParent->EnableWindow(TRUE);
    ::WinHelp(m_hWnd, NULL, HELP_QUIT, 0L);
    C3dDialog::OnDestroy();
}

void CMainDlg::PostNcDestroy()
{
	theDLL.m_bQuit = TRUE;
}

CMainDlg::~CMainDlg()
{
	DeleteDialogs();
}

void CMainDlg::UserDeletedStandardStep(CAppWizStepDlg* pDlg)
{
	for (int i=0; i < NUM_DLG_CLASSES; i++)
		if (m_pExtensionKeys[i] == pDlg)
			m_pExtensionKeys[i] = NULL;
}

// Delete dialogs from the heap
void CMainDlg::DeleteDialogs()
{
	// This is defined in pagedlg.cpp.  When we set this, we have
	//  permission to call CAppWizStepDlg's destructor
	void AppWizCallingStructor(BOOL bAppWizCallingStructor);
	AppWizCallingStructor(TRUE);

    for (int i=0; i < NUM_DLG_CLASSES; i++)
    {
        if (m_pDialogClasses[i] != NULL)
            delete m_pDialogClasses[i];
		if (m_pExtensionKeys[i] != NULL)
			delete m_pExtensionKeys[i];
    }
	
	AppWizCallingStructor(FALSE);
}

BOOL CMainDlg::FinalProcessing()
{
	// First, get rid of .pjx, .mdp & .opt files if they exist.
	CPath PjxFile, MdpFile, OptFile;
	PjxFile.CreateFromDirAndFilename(projOptions.m_ProjDir, projOptions.m_strProj + BUILDER_EXT);
	MdpFile.CreateFromDirAndFilename(projOptions.m_ProjDir, projOptions.m_strProj + ".mdp");
	OptFile.CreateFromDirAndFilename(projOptions.m_ProjDir, projOptions.m_strProj + ".opt");

	if (!DestroyFile(PjxFile.GetFullPath()))
		return FALSE;
	if (!DestroyFile(MdpFile.GetFullPath()))
		return FALSE;
	if (!DestroyFile(OptFile.GetFullPath()))
		return FALSE;
	
    // create a status dialog
	ASSERT(m_pConfirmDlg);
    CStatusDlg statDlg(m_pConfirmDlg);

    if (Generate(statDlg.GetDlgItem(IDC_OUTPROJ), statDlg.GetDlgItem(IDC_OUTFILE)))
    {
        statDlg.DestroyWindow();    // avoids uglyness on completion!
        return TRUE;
    }
    else
    {
        statDlg.DestroyWindow();    // avoids warning in destructor
        return FALSE;
    }

    // else don't cancel the dialog
}

// Return index into szPlatforms (MAC, POWERMAC, WIN) that the given long
//  platform name corresponds to.  If it's not in the array, return -1.
int PlatformLongToEnum(const CString& strPlatform)
{
	// Determine which platform this really is
	if (strPlatform == szPlatforms[MAC])
		return MAC;
	else if (strPlatform == szPlatforms[POWERMAC])
		return POWERMAC;
	else if (strPlatform == szPlatforms[WIN])
		return WIN;
	else if (strPlatform == szPlatforms[JAVA])
		return JAVA;
    else if (strPlatform == szPlatforms[XBOX])
        return XBOX;
	else
		return -1;
}

void AddDefaultTargetsWithPseudoDebug(const CString& strPlatform,
	const CString& strProjType, HBLDTARGET& hDebugTarg, HBLDTARGET& hReleaseTarg, HBUILDER hBld)
{
	TCHAR szFileName[_MAX_FNAME];	// our project name
	CString strTargName;			// our target name
	CString strCfgName;				// our config. name
	
	// First, get the project's name
	_tsplitpath(pTermStatus->szFullName, NULL, NULL, szFileName, NULL);
	
	// Add retail target first.

	strTargName = szFileName;
	VERIFY(strCfgName.LoadString(IDS_RELEASE));
	strTargName += strCfgName;

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif

	pBldWizIFace->AddTarget(
		&hReleaseTarg,
		strTargName,				// Default target name
		strPlatform,				// Platform name
		strProjType,				// Target type
		FALSE,						// Using non-UI ("official") names
		FALSE,						// Retail settings
		TrgDefault,					// don't clone or mirror
		NO_TARGET,					// don't clone or mirror
		SettingsDefault,			// default settings
		NO_TARGET,					// no target to copy settings from
		FALSE, TRUE, TRUE,			// other random stuff
		hBld);						// builder that contains target

	ASSERT (hReleaseTarg != NO_TARGET);

	// The targets have AWX as their extension.
	CString strAWX = "awx";
	//pBldWizIFace->SetTargetDefExt(hDebugTarg, strAWX, hBld);
	pBldWizIFace->SetTargetDefExt(hReleaseTarg, strAWX, hBld);

	// Add custom build step to copy .AWX & .PDB files to msvc30\Template
	CString strDescription;
	strDescription.LoadString(IDS_COPY_AWX);
	pBldWizIFace->AssignCustomBuildStep(
		"if not exist \"$(MSDEVDIR)\\Template\\nul\" md \"$(MSDEVDIR)\\Template\"\t\
copy \"$(TargetPath)\" \"$(MSDEVDIR)\\Template\"\t\
if exist \"$(OutDir)\\$(TargetName).pdb\" copy \"$(OutDir)\\$(TargetName).pdb\" \"$(MSDEVDIR)\\Template\"",
		"$(MSDEVDIR)\\Template\\$(TargetName).awx",
		strDescription,
		hReleaseTarg,
		NO_FILE,
		hBld);

	// Add the pseudo-debug target as mirroring & copying hReleaseTarget.
	
	strTargName = szFileName;
	VERIFY(strCfgName.LoadString(IDS_PSEUDO_DEBUG));
	strTargName += strCfgName;

	//  And create that target.  Start its options off as retail options.
	pBldWizIFace->AddTarget(
		&hDebugTarg,
		strTargName,
		strPlatform,				// Platform name
		strProjType,				// Target type
		FALSE,						// Using non-UI ("official") names
		FALSE,						// Retail settings
		TrgMirror,					// We're mirroring...
		hReleaseTarg,				// ...the retail target we just added
		SettingsClone,				// We want to copy settings from...
		hReleaseTarg,				// ...release target
		FALSE, TRUE, TRUE,			// other random stuff
		hBld);						// builder that contains target

	ASSERT (hDebugTarg != NO_TARGET);

	// Now the fun begins.  Let's play with the options of hDebugTarget, so that
	//  it makes a retail build w/ symbols & no optimization

	// First, the compiler.  Add /Od /Zi /D "_PSEUDO_DEBUG"
	pBldWizIFace->SetToolSettings(
		hDebugTarg,					// We're partying on the "debug" target
		"/Od /Zi /D ""_PSEUDO_DEBUG""",
		"cl.exe",					// Compiler options
		TRUE, FALSE, ACTIVE_BUILDER);

	// Next, the linker.  Add /debug & /incremental:yes
	pBldWizIFace->SetToolSettings(
		hDebugTarg,					// We're partying on the "debug" target
		"/debug /incremental:yes",					
		"link.exe",					// Linker options
		TRUE, FALSE, ACTIVE_BUILDER);

	// The resource compiler.  Add /D "_PSEUDO_DEBUG"
	pBldWizIFace->SetToolSettings(
		hDebugTarg,					// We're partying on the "debug" target
		"/D ""_PSEUDO_DEBUG""",
		"rc.exe",					// Resource compiler options
		TRUE, FALSE, ACTIVE_BUILDER);

	// Set the output & intermediate directories.
	CString strWinDebug = "Debug";
	pBldWizIFace->SetTargetOutDir(
		hDebugTarg,					// We're partying on the "debug" target
		strWinDebug,				// Set the output directory...to Debug
		ACTIVE_BUILDER);
	pBldWizIFace->SetTargetIntDir(
		hDebugTarg,					// We're partying on the "debug" target
		strWinDebug,				// Set the intermediate directory...to Debug
		ACTIVE_BUILDER);

/*	pBldWizIFace->SetActiveTarget(hDebugTarg, hBld);
	pBldWizIFace->SetDefaultTarget(hDebugTarg, hBld);*/
	pBldWizIFace->Release();

}

void AddUnicodeTargets(HBLDTARGET hDebug, HBLDTARGET hRelease, LPCTSTR szProjType, HBUILDER hBld)
{
	// The win32 ansi targets have already been created (they were passed here), so
	//  clone their settings and mirror their filesets with new UNICODE targets

	// First generate their names
	// Need the project name
	TCHAR szFileName[_MAX_FNAME];
	_tsplitpath(pTermStatus->szFullName, NULL, NULL, szFileName, NULL);
	CString strNameDebug, strNameRelease, strCfgName;
	strNameDebug = szFileName;
	VERIFY(strCfgName.LoadString(IDS_DEBUG_UNICODE));
	strNameDebug += strCfgName;
	strNameRelease = szFileName;
	VERIFY(strCfgName.LoadString(IDS_RELEASE_UNICODE));
	strNameRelease += strCfgName;

	// Second, clone the given targets

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif

	HBLDTARGET hDebugUnicode;
	pBldWizIFace->AddTarget(
		&hDebugUnicode,
		strNameDebug,		// name of this target
		szPlatforms[WIN],	// 'official' name of this target's platform
		szProjType,			// 'official' name of this target type
		FALSE,				// using 'official' names
		TRUE,				// debug settings?  Ignored
		TrgMirror,			// mirror ansi target
		hDebug,				// target to mirror
		SettingsClone,		// copy settings
		hDebug,				// target to copy settings from
		FALSE, TRUE, TRUE,	// Other random stuff
		hBld);				// The builder
	ASSERT (hDebugUnicode != NULL);
		
	HBLDTARGET hReleaseUnicode;
	pBldWizIFace->AddTarget(
		&hReleaseUnicode,
		strNameRelease,		// name of this target
		szPlatforms[WIN],	// 'official' name of this target's platform
		szProjType,			// 'official' name of this target type
		FALSE,				// using 'official' names
		TRUE,				// debug settings?  Ignored
		TrgMirror,			// mirror ansi target
		hRelease,			// target to mirror
		SettingsClone,		// copy settings
		hRelease,			// target to copy settings from
		FALSE, TRUE, TRUE,	// Other random stuff
		hBld);				// The builder
	ASSERT (hReleaseUnicode != NULL);

	// Third, change the output directories (append a "u")
	VERIFY(pBldWizIFace->GetTargetOutDir(hDebug, strNameDebug, hBld) == S_OK);
	VERIFY(pBldWizIFace->GetTargetOutDir(hRelease, strNameRelease, hBld) == S_OK);
	strNameDebug += 'U';
	strNameRelease += 'U';
	VERIFY(pBldWizIFace->SetTargetOutDir(hDebugUnicode, strNameDebug, hBld) == S_OK);
	VERIFY(pBldWizIFace->SetTargetOutDir(hReleaseUnicode, strNameRelease, hBld) == S_OK);
	VERIFY(pBldWizIFace->SetTargetIntDir(hDebugUnicode, strNameDebug, hBld) == S_OK);
	VERIFY(pBldWizIFace->SetTargetIntDir(hReleaseUnicode, strNameRelease, hBld) == S_OK);

	// Penultimately, have the unicode targets define UNICODE
	pBldWizIFace->SetToolSettings(hDebugUnicode, "/D \"_MBCS\"",
			"cl.exe", FALSE, FALSE, hBld);
	pBldWizIFace->SetToolSettings(hReleaseUnicode, "/D \"_MBCS\"",
			"cl.exe", FALSE, FALSE, hBld);
	pBldWizIFace->SetToolSettings(hDebugUnicode, "/D \"_UNICODE\"",
			"cl.exe", TRUE, FALSE, hBld);
	pBldWizIFace->SetToolSettings(hReleaseUnicode, "/D \"_UNICODE\"",
			"cl.exe", TRUE, FALSE, hBld);

/*	pBldWizIFace->SetActiveTarget(hDebug, hBld);
	pBldWizIFace->SetDefaultTarget(hDebug, hBld);*/
	
	// TODO: Verify we don't actually need to do this
	// Finally, add /entry:wWinMainCRTStartup
/*	pBldWizIFace->SetToolSettings(hDebugUnicode, "/entry:wWinMainCRTStartup",
			"link.exe", TRUE, FALSE, hBld);
	pBldWizIFace->SetToolSettings(hReleaseUnicode, "/entry:wWinMainCRTStartup",
			"link.exe", TRUE, FALSE, hBld);*/
	pBldWizIFace->Release();
}

void AddCopyLicenseStep(HBLDTARGET hTarg, HBLDFILE hLicense, HBUILDER hBld)
{
	// Adds a custom build step to copy the .lic file in a controlwiz project
	CString strDescription;
	strDescription.LoadString(IDS_COPY_LIC);

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif

	pBldWizIFace->AssignCustomBuildStep(
		"copy \"$(ProjDir)\\$(TargetName).lic\" \"$(OutDir)\"",
		"$(OutDir)\\$(TargetName).lic",
		strDescription,
		hTarg,
		hLicense,
		hBld);
	pBldWizIFace->Release();
}

void AddRegSvrStep(HBLDTARGET hTarg, HBUILDER hBld)
{
	// Adds a custom build step to register the control
	CString strDescription;
	strDescription.LoadString(IDS_REGISTER_CONTROL);

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif

	pBldWizIFace->AssignCustomBuildStep(
		"regsvr32 /s /c \"$(TargetPath)\"\t\
echo regsvr32 exec. time > \"$(OutDir)\\regsvr32.trg\"",
		"$(OutDir)\\regsvr32.trg",
		strDescription,
		hTarg,
		NO_FILE,
		hBld);
	pBldWizIFace->Release();
}

void AddMakehelpStep(HBLDTARGET hTarg, HBLDFILE hHpjFile, HBLDFILE hResource, HBLDFILE hCnt, HBUILDER hBld, BOOL bMac = FALSE)
{

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif


	CString strDescription;
	CString strOutput;
	CString strCommand;

	// put this step on the hpj
	strDescription.LoadString(IDS_MAKEHELP);

	strOutput = "\"$(OutDir)\\$(InputName).hlp\"";

	strCommand = "start /wait hcw /C /E /M \"hlp\\$(InputName).hpj\"\t" \
		"if errorlevel 1 goto :Error\t" \
		"if not exist \"hlp\\$(InputName).hlp\" goto :Error\t" \
		"copy \"hlp\\$(InputName).hlp\" $(OutDir)\t";

	if (DoesSymbolExist(_T("PROJTYPE_CUSTOMAW")))
	{
		strCommand += "copy \"$(OutDir)\\$(TargetName).hlp\" \"$(MSDEVDIR)\\Template\"\t";
		strOutput += "\t\"$(MSDEVDIR)\\Template\"";
	}

	CString strTmp, strTmp2;
	if (!strTmp2.LoadString(IDS_ERR_BLD_HELP))
		strTmp2 = _T("Problem encountered creating help file");
	strTmp.Format("goto :done\t"\
		":Error\t"\
		"echo hlp\\$(InputName).hpj(1) : error: %s\t"\
		"type \"hlp\\$(InputName).log\"\t"\
		":done", strTmp);
	strCommand += strTmp;

	if( hHpjFile != NO_FILE ){
		pBldWizIFace->AssignCustomBuildStep(
			strCommand,
			strOutput,
			strDescription,
			hTarg,
			hHpjFile,
			hBld);
	
		// Add dependencies (not needed for dialog-based apps or custom appwizards)
		if( !DoesSymbolExist( _T("PROJTYPE_DLG") ) )
		{
			CString strDep = "hlp\\AfxCore.rtf";
			if (DoesSymbolExist(_T("PRINT")))
				strDep += "\nhlp\\AfxPrint.rtf";
			if( hResource != NO_FILE )
				strDep += "\nhlp\\$(TargetName).hm";
	
			pBldWizIFace->SetUserDefinedDependencies(
				strDep,
				hTarg,
				hHpjFile,
				hBld);
		}
	}

	strDescription.LoadString(IDS_MAKEHM);

	strOutput = "hlp\\$(TargetName).hm";

	strCommand = "echo. >\"hlp\\$(TargetName).hm\"\t"\
		"echo // Commands (ID_* and IDM_*) >>\"hlp\\$(TargetName).hm\"\t"\
		"makehm ID_,HID_,0x10000 IDM_,HIDM_,0x10000 resource.h >>\"hlp\\$(TargetName).hm\"\t"\
		"echo. >>\"hlp\\$(TargetName).hm\"\t"\
		"echo // Prompts (IDP_*) >>\"hlp\\$(TargetName).hm\"\t"\
		"makehm IDP_,HIDP_,0x30000 resource.h >>\"hlp\\$(TargetName).hm\"\t"\
		"echo. >>\"hlp\\$(TargetName).hm\"\t"\
		"echo // Resources (IDR_*) >>\"hlp\\$(TargetName).hm\"\t"\
		"makehm IDR_,HIDR_,0x20000 resource.h >>\"hlp\\$(TargetName).hm\"\t"\
		"echo. >>\"hlp\\$(TargetName).hm\"\t"\
		"echo // Dialogs (IDD_*) >>\"hlp\\$(TargetName).hm\"\t"\
		"makehm IDD_,HIDD_,0x20000 resource.h >>\"hlp\\$(TargetName).hm\"\t"\
		"echo. >>\"hlp\\$(TargetName).hm\"\t"\
		"echo // Frame Controls (IDW_*) >>\"hlp\\$(TargetName).hm\"\t"\
		"makehm IDW_,HIDW_,0x50000 resource.h >>\"hlp\\$(TargetName).hm\"";

	if( hResource != NO_FILE ){
		pBldWizIFace->AssignCustomBuildStep(
			strCommand,
			strOutput,
			strDescription,
			hTarg,
			hResource,
			hBld);
	}
	
	strDescription.LoadString(IDS_MAKECNT);

	strOutput = "$(OutDir)\\$(InputName).cnt";

	strCommand = "copy \"hlp\\$(InputName).cnt\" $(OutDir)";


	if( hCnt != NO_FILE ){
		pBldWizIFace->AssignCustomBuildStep(
			strCommand,
			strOutput,
			strDescription,
			hTarg,
			hCnt,
			hBld);
	}

	pBldWizIFace->Release();
}

enum { AFXDLL, USRDLL, AFXEXT };

void AddDllOptions(HBLDTARGET hTarg, HBUILDER hBld, int nSymbol)
{
	ASSERT (0 <= nSymbol && nSymbol <= 2);
	static LPCTSTR szSymbols[3] =
	{
		"/D \"_USRDLL\" /D \"_AFXDLL\"",
		"/D \"_USRDLL\"",
		"/D \"_AFXEXT\"",
	};

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif

	// Reset...
	pBldWizIFace->SetToolSettings(hTarg, szSymbols[0], "cl.exe", FALSE, FALSE, hBld);
	pBldWizIFace->SetToolSettings(hTarg, szSymbols[2], "cl.exe", FALSE, FALSE, hBld);

	// Set the option corresponding to nSymbol
	pBldWizIFace->SetToolSettings(hTarg, szSymbols[nSymbol], "cl.exe", TRUE, FALSE, hBld);
	pBldWizIFace->Release();
}

int CalcDllSymbol()
{
	int nReturn = -1;
	if (DoesSymbolExist("MFCDLL"))
	{
		if (DoesSymbolExist("EXTDLL"))
			// MFC Extension DLL
			nReturn = AFXEXT;
		else
			// Regular DLL, dynamically linked
			nReturn = AFXDLL;
	}
	else
	{
		// Regular DLL, statically linked
		ASSERT (!DoesSymbolExist("EXTDLL"));
		nReturn = USRDLL;
	}
	ASSERT (nReturn != -1);
	return nReturn;
}

void AddFilesFromList(HFILESET hFileSet, CString & strProjDir, const CStringList * pstrlFiles, HBUILDER hBld, HFOLDER hFolder = NO_FOLDER, int fSettings = 0)
{
	if (pstrlFiles==NULL || pstrlFiles->IsEmpty())
		return;  // nothing to do

	HBLDFILE hFile;
	CString strFile;
	CPath path;

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif

	POSITION pos = pstrlFiles->GetHeadPosition();
	while (pos != NULL)
	{
		strFile = pstrlFiles->GetNext(pos);

		// Make full pathname of file
		strFile = strProjDir + strFile;

		// Make CPath from the full pathname of file
		VERIFY(path.Create(strFile));

		// Call add dep file API
		VERIFY(pBldWizIFace->AddFile(&hFile, hFileSet, &path, fSettings, hBld, hFolder) == S_OK);
	}
	pBldWizIFace->Release();
}

void CreateProject(HBUILDER hBld)
{
	// This should only be called if the project was created by AppWizard
	ASSERT(pTermStatus->nTermType == APPWIZTERMTYPE_APPWIZPROJ);

	// Determine the target-type
	
	int nTarget = 0;				// Default is .exe
	BOOL bUsePseudoDebug = FALSE;	// Default is make default targets
    BOOL fSkipIt = FALSE;
	CString strProjType;

	if (IsUserAWX())
	{
		// The project generated by an extension gets its target type
		//  from the appropriate symbol.
		if (DoesSymbolExist("PROJTYPE_DLL") || DoesSymbolExist("PROJTYPE_OCX"))
			nTarget = 1;			// DLL
#if 0
		else if (DoesSymbolExist("PROJTYPE_JAVA"))
        {
			// REVIEW UNDONE HACK ALERT...
			// jimsc 2/21/96
			// We know this is Java, just set the string.
			fSkipIt = TRUE;
            strProjType = "Java Project";
        }
#endif	// 0
		else if (DoesSymbolExist("PROJTYPE_LIB"))
        {
			fSkipIt = TRUE;
            strProjType = "Static Library";
        }
		else if (DoesSymbolExist("PROJTYPE_GEN"))
        {
			fSkipIt = TRUE;
            strProjType = "Generic Project";
        }
		else if (DoesSymbolExist("PROJTYPE_MAK"))
        {
			fSkipIt = TRUE;
            strProjType = "External Target";
        }
		else if (DoesSymbolExist("PROJTYPE_CON"))
        {
			fSkipIt = TRUE;
            strProjType = "Console Application";
        }
		else if (DoesSymbolExist("PROJTYPE_QWA"))
        {
			fSkipIt = TRUE;
            strProjType = "QuickWin Application";
        }
		else if (DoesSymbolExist("PROJTYPE_GRA"))
        {
			fSkipIt = TRUE;
            strProjType = "Standard Graphics Application";
        }
		else if (DoesSymbolExist("PROJTYPE_CUSTOMAW"))
		{
			// This option is generally used only by ExtensionWizard to create an extension project
			nTarget = 1;			// DLL
			bUsePseudoDebug = TRUE;	// Make Pseudo-debug target
			SetSymbol("EXTDLL", "1");
		}
		else
			nTarget = 0;			// EXE
	}
	else
	{
		// Here, AppWizard is creating the project, so our answer
		//  was recorded in pTermStatus
		nTarget = pTermStatus->nProjType;
	}

    if (!fSkipIt)
        strProjType = strlProjTypes.GetAt(strlProjTypes.FindIndex(nTarget));

	// Determine platforms

	// Add default targets based on target-type & platforms
	HBLDTARGET hDebugTarg = NO_TARGET, hReleaseTarg = NO_TARGET;
	HFILESET hFileSet;

	enum {DEBUG_TGT, RELEASE_TGT};
	HBLDTARGET htgts[PLATFORM_MAX][2];
	for (int i=0; i < PLATFORM_MAX; i++)
		for (int j=0; j < 2; j++)
			htgts[i][j] = NO_TARGET;


	// Determine project name and directory
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szDir[_MAX_DIR];
	TCHAR szProjName[_MAX_FNAME];
	TCHAR szExt[_MAX_FNAME];
	_tsplitpath(pTermStatus->szFullName, szDrive, szDir, szProjName, szExt );
	CString strProjName = szProjName;
	strProjName += szExt;
	CString strPath = szDrive;
	strPath += szDir;

    if (pTermStatus != &g_TermStatus)
    {
        // This is not the first project, but some additional
        // project being added because of $$NEWPROJ directive
        // So the path name should contain the subdirectory
        strPath += strProjName;
        strPath += "\\";
    }

	// Go through each of the installed platforms.  For each, check
	//  whether the user chose it; if so, add the appropriate targets

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif

	POSITION pos = g_PlatformsSelected.GetStartPosition();
	while (pos != NULL)
	{
		CString strPlatform, tmp;
		g_PlatformsSelected.GetNextAssoc(pos, strPlatform, tmp);
		if (!DoesSymbolExist(strPlatform))
			continue;

		int nPlatform;
		if ((nPlatform = PlatformLongToEnum(strPlatform)) != -1)
		{
			// If this platform is a known one (i.e., not contrived
			//  by an extension), then add the dbg & rel targets.  If
			//  previous ones were added have these targets mirror them.
			if (bUsePseudoDebug)
			{
				// Projects that build custom AppWizards use pseudo-debug
				//  rather than debug...
				AddDefaultTargetsWithPseudoDebug
					(strPlatform, strProjType, hDebugTarg, hReleaseTarg, hBld);
			}
			else
				pBldWizIFace->AddDefaultTargets
					(strPlatform, strProjType, hDebugTarg, hReleaseTarg,
					FALSE, TRUE, TRUE, hDebugTarg, hBld, strProjName);

			// did it work? (this only fails if platform or projtype is bad)
			if (hDebugTarg == NO_TARGET)
				break;

			if (DoesSymbolExist("PROJTYPE_OCX"))
			{
				// OLE Controls have OCX as their extension
				CString strOCX = "ocx";
				pBldWizIFace->SetTargetDefExt(hDebugTarg, strOCX, hBld);
				pBldWizIFace->SetTargetDefExt(hReleaseTarg, strOCX, hBld);
			}


			if (!IsUserAWX())
			{
				pBldWizIFace->SetTargetIsAppWiz(hDebugTarg, 1, hBld);
				pBldWizIFace->SetTargetIsAppWiz(hReleaseTarg, 1, hBld);
			}

			// Set the appropriate target handles
			htgts[nPlatform][DEBUG_TGT] = hDebugTarg;
			htgts[nPlatform][RELEASE_TGT] = hReleaseTarg;
		}
	}

	if (hDebugTarg == NO_TARGET)
	{
		// If no "real" targets were selected (possible with an extension), return.
		ASSERT(hReleaseTarg == NO_TARGET);
		pBldWizIFace->Release();
		return;
	}

	ASSERT(hDebugTarg != NO_TARGET);
	ASSERT(hReleaseTarg != NO_TARGET);

	// We now take the list of files and add them to the project: a three
	//  step process

	// STEP 1/3: Create CPtrList of CPath pointers from the filelist
	
	CStringList* pstrlFiles = &(pTermStatus->strlDepFiles); // For easy list reference
	int nNumFiles = pstrlFiles->GetCount();
	CPath* pPaths = NULL;
	if (nNumFiles > 0)
		pPaths = new CPath[nNumFiles];

	CPtrList ptrlPaths;
	pos = pstrlFiles->GetHeadPosition();
	for (i=0; pos != NULL; i++)
	{
		ASSERT(i < nNumFiles);

		CString strFile = pstrlFiles->GetNext(pos);

		// Make full pathname of file
		strFile = strPath + strFile;

		// Make CPath from the full pathname of file
		pPaths[i].Create(strFile);

		// Add entry in ptrlist for this path
		ptrlPaths.AddTail(&(pPaths[i]));
	}

	// STEP 2/3: Call the bldiface API with the new ptrlist

#ifndef VS_PACKAGE
	theApp.NotifyPackages(PN_BEGIN_MULTIOP);
#endif

	pBldWizIFace->GetFileSet(hBld, hDebugTarg, &hFileSet);	// use debug which a target of fileset

	// Add default groups
	HFOLDER hSources = NO_FOLDER;
	HFOLDER hHeaders = NO_FOLDER;
	HFOLDER hResources = NO_FOLDER;
	HFOLDER hHelpFiles = NO_FOLDER;
	HFOLDER hTemplates = NO_FOLDER;

	// if this is a java project, then we set file type correctly and don't create the "Header files" folder.
	CString strT;
#if 0
	if (DoesSymbolExist("PROJTYPE_JAVA"))
	{
		strT.LoadString(IDS_SOURCE_FILES);
		pBldWizIFace->AddFolder(&hSources, hFileSet, strT, hBld, NO_FOLDER, "java;html");
		ASSERT(hSources != NO_FOLDER);
	}
	else if (!DoesSymbolExist("PROJTYPE_GEN") )
#else
	if (!DoesSymbolExist("PROJTYPE_GEN") )
#endif
	{
		CString strFilter;
		if (DoesSymbolExist("SOURCE_FILTER"))
		{
			strT.LoadString(IDS_SOURCE_FILES);
			GetSymbol("SOURCE_FILTER", strFilter );
			pBldWizIFace->AddFolder(&hSources, hFileSet, strT, hBld, NO_FOLDER, strFilter);
		}
		if (DoesSymbolExist("INCLUDE_FILTER"))
		{
			strT.LoadString(IDS_HEADER_FILES);
			GetSymbol("INCLUDE_FILTER", strFilter );
			pBldWizIFace->AddFolder(&hHeaders, hFileSet, strT, hBld, NO_FOLDER, strFilter);
		}
		ASSERT(hSources != NO_FOLDER);
	}

//	if (!pTermStatus->strlResFiles.IsEmpty())
	if (!DoesSymbolExist("PROJTYPE_LIB") && !DoesSymbolExist("PROJTYPE_GEN") )
	{
		strT.LoadString(IDS_RESOURCE_FILES);
		pBldWizIFace->AddFolder(&hResources, hFileSet, strT, hBld, NO_FOLDER, "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"); // UNDONE: more files to filter
	}

	// Optionally add folder for Help files
	if (!pTermStatus->strlHelpFiles.IsEmpty())
	{
		strT.LoadString(IDS_HELP_FILES);
		pBldWizIFace->AddFolder(&hHelpFiles, hFileSet, strT, hBld, NO_FOLDER, "cnt;rtf");
	}

	// Optionally add folder for Template files
	if (!pTermStatus->strlTemplFiles.IsEmpty())
	{
		strT.LoadString(IDS_TEMPLATE_FILES);
		pBldWizIFace->AddFolder(&hTemplates, hFileSet, strT, hBld, NO_FOLDER, "<templates>");
	}

	CPtrList ptrlhFiles;
	pBldWizIFace->AddMultiFiles(hFileSet, &ptrlPaths, &ptrlhFiles, FALSE, hBld, NO_FOLDER);

	// Optionally add any other resource files as well
	if (!pTermStatus->strlResFiles.IsEmpty())
		AddFilesFromList(hFileSet, strPath, &(pTermStatus->strlResFiles), hBld, hResources);

	// Optionally add any help files as well
	if (!pTermStatus->strlHelpFiles.IsEmpty())
		AddFilesFromList(hFileSet, strPath, &(pTermStatus->strlHelpFiles), hBld, hHelpFiles);

	// Optionally add any exclude from build files
	if (!pTermStatus->strlNonBldFiles.IsEmpty())
		AddFilesFromList(hFileSet, strPath, &(pTermStatus->strlNonBldFiles), hBld, NO_FOLDER /* use defaults */, ADB_EXCLUDE_FROM_BUILD /* must exclude from build */);

	// Optionally add (and exclude) any template files as well
	if (!pTermStatus->strlTemplFiles.IsEmpty())
		AddFilesFromList(hFileSet, strPath, &(pTermStatus->strlTemplFiles), hBld, hTemplates, (ADB_EXCLUDE_FROM_BUILD | ADB_EXCLUDE_FROM_SCAN) /* must exclude from build & scan */);

#ifndef VS_PACKAGE
	theApp.NotifyPackages(PN_END_MULTIOP);
#endif

	// STEP 3/3: Iterate through fileset to find special files

	pos = ptrlPaths.GetHeadPosition();
	POSITION pos2 = ptrlhFiles.GetHeadPosition();
	HBLDFILE hStdafx = NO_FILE, hLicense = NO_FILE, hResource = NO_FILE,
		hHpjFile = NO_FILE, hCntFile = NO_FILE, hMacHpjFile = NO_FILE, hRFile = NO_FILE, hOdl = NO_FILE;
	CString strOdlFname;

	while (pos != NULL)
	{
		ASSERT(pos2 != NULL);

		// Get HBLDFILE corresponding to this file that was given to us by AddMultiFiles
		HBLDFILE hFile = (HBLDFILE) ptrlhFiles.GetNext(pos2);

		// Determine what type of file this is and set the appropriate HBLDFILE
		CString strFile = ((CPath*)ptrlPaths.GetNext(pos))->GetFileName();
		if (!strFile.CompareNoCase("stdafx.cpp"))
			hStdafx = hFile;	// Remember whether to use precompiled headers for later...
		else if (!strFile.CompareNoCase("resource.h"))
			hResource = hFile;	// Remember whether to use precompiled headers for later...
		else
		{
			LPCTSTR szExt = _tcschr(strFile, '.');
			if (szExt == NULL)
			{}		// no extension?  doesn't belong in any of the buckets below...
			else if (!_tcsicmp(szExt, ".r") && DoesSymbolExist("TARGET_MAC"))
				hRFile = hFile;
			else if (!_tcsicmp(szExt, ".lic")
				&& DoesSymbolExist("PROJTYPE_OCX") && DoesSymbolExist("LICENSED"))
			{
				hLicense = hFile;
			}
			else if( !_tcsicmp(szExt, ".hpj") )
			{
				// LATER: With multiple languages, we'll need to distinguish
				//  between all the languages' .hpj files.
				// Is this the mac or the win32 .hpj file?
				CString strMacHpjFilename;
				GetSymbol("mac_hpj", strMacHpjFilename);
				if (!strFile.CompareNoCase(strMacHpjFilename + ".hpj"))
				{
					hMacHpjFile = hFile;
				}
				else
					hHpjFile = hFile;
			}
			else if( !_tcsicmp(szExt, ".cnt") )
			{
				hCntFile = hFile;
			}
			else if (!_tcsicmp(szExt, ".odl"))
			{
				ASSERT(hOdl == NO_FILE);	// don't expect more than one .odl
				hOdl = hFile;

				_TCHAR szFname[_MAX_FNAME];
				_splitpath(LPCTSTR(strFile), NULL, NULL, szFname, NULL);
				strOdlFname = szFname;
			}
		}
	}

	// We're done with adding the files to the project.  Let's clean up our mess.
	if (nNumFiles > 0)
		delete [nNumFiles] pPaths;

	// Exclude .r file and mac .hpj file from Win32 builds
	if (hRFile != NO_FILE && htgts[WIN][DEBUG_TGT] != NO_TARGET)
	{
		ASSERT(htgts[WIN][RELEASE_TGT] != NO_TARGET);
		for (int j=0; j < 2; j++)
		{
			pBldWizIFace->SetBuildExclude(htgts[WIN][j], hRFile, TRUE);
			if (hMacHpjFile != NO_FILE)
				pBldWizIFace->SetBuildExclude(htgts[WIN][j], hMacHpjFile, TRUE);
		}
	}

	// Exclude win32 .hpj file from Mac builds
	if (hHpjFile != NO_FILE)
	{
		for (int i=0; i < PLATFORM_MAX; i++)
		{
			if (i != MAC && i != POWERMAC)
				continue;

			if (htgts[i][DEBUG_TGT] != NO_TARGET)
			{
				ASSERT (htgts[i][RELEASE_TGT] != NO_TARGET);
				for (int j=0; j < 2; j++)
					pBldWizIFace->SetBuildExclude(htgts[i][j], hHpjFile, TRUE);
			}
		}
	}

	// Ok, all the targets have been added, and the files have been added
	//  too, so nothing left to do, right?  Wrong.  Now let's set the
	//  target & file options to use precompiled headers if there's a stdafx.cpp
	if (hStdafx != NO_FILE)
	{
		// For each target, replace /YX with /Yu"stdafx.h", and
		//  add /Yc"stdafx.h" for stdafx.cpp.
		for (i=0; i < PLATFORM_MAX; i++)
		{
			if (htgts[i][DEBUG_TGT] == NO_TARGET)
				continue;
			ASSERT(htgts[i][RELEASE_TGT] != NO_TARGET);

			for (int j=0; j < 2; j++)
			{
				pBldWizIFace->SetToolSettings(htgts[i][j], "/YX",
					"cl.exe", FALSE, FALSE, hBld);
				pBldWizIFace->SetToolSettings(htgts[i][j], "/Yu\"stdafx.h\"",
					"cl.exe", TRUE, FALSE, hBld);
				pBldWizIFace->SetToolSettings(htgts[i][j], hStdafx, "/Yc\"stdafx.h\"",
					"cl.exe", TRUE, FALSE);
			}
		}
	}

	// Other options changes: change options to link MFC statically,
	//  use .def file, mac creator, invoke makehelp.bat.
	const int MFC_STATIC = 1;
	const int MFC_DYNAMIC = 2;
	int nMFCProp = DoesSymbolExist("MFCDLL") ? MFC_DYNAMIC : MFC_STATIC;
	int nDllSymbol = (DoesSymbolExist("PROJTYPE_DLL") || DoesSymbolExist("PROJTYPE_CUSTOMAW"))
		? CalcDllSymbol() : -1;
 	CString strCreator;
	GetSymbol("CREATOR", strCreator);
	for (i=0; i < PLATFORM_MAX; i++)
	{
		if (htgts[i][DEBUG_TGT] == NO_TARGET)
			continue;
		ASSERT(htgts[i][RELEASE_TGT] != NO_TARGET);

		for (int j=0; j < 2; j++)
		{
			// Link MFC
			if (i == MAC)	// Special case:  68K mac must link statically
				pBldWizIFace->SetTargetUseOfMFC(htgts[i][j], MFC_STATIC, hBld);
			else if (i == JAVA)
				pBldWizIFace->SetTargetUseOfMFC(htgts[i][j], 0, hBld);
			else
				pBldWizIFace->SetTargetUseOfMFC(htgts[i][j], nMFCProp, hBld);

			// Everybody should be _MBCS
			pBldWizIFace->SetToolSettings(htgts[i][j], "/D _MBCS",
					"cl.exe", TRUE, FALSE, hBld);

			// Special symbols for DLLs
			if (nDllSymbol != -1)
				AddDllOptions(htgts[i][j], hBld, nDllSymbol);

			/*if (!pTermStatus->strClwFile.IsEmpty())
			{
				// Set the name of the clw file if we have one

				// Make full pathname of file
				CString strClwFile = strPath + pTermStatus->strClwFile;
				pBldWizIFace->SetTargetProp(htgts[i][j], Prop_ClsWzdName, strClwFile, hBld);
			}*/

			// Mac creator
			if (i == MAC || i == POWERMAC)
			{
				pBldWizIFace->SetToolSettings(htgts[i][j], "/MAC:creator=\"" +  strCreator + "\"",
					"link.exe", TRUE, FALSE, hBld);
			}

			// Help support
			if (hHpjFile != NO_FILE && i == WIN)		// For win32
				AddMakehelpStep(htgts[i][j], hHpjFile,hResource,hCntFile, hBld);
			else if (hMacHpjFile != NO_FILE && (i == MAC || i == POWERMAC))
				AddMakehelpStep(htgts[i][j], hMacHpjFile, hResource, hCntFile, hBld, TRUE);

		}
	}

	if (hOdl != NO_FILE && DoesSymbolExist("HAS_ODL_HEADER"))
	{
		for (i=0; i < PLATFORM_MAX; i++)
		{
			if (htgts[i][DEBUG_TGT] == NO_TARGET)
				continue;
			ASSERT(htgts[i][RELEASE_TGT] != NO_TARGET);

			for (int j=0; j < 2; j++)
			{
				_TCHAR szSettings[_MAX_FNAME + 10];
				_stprintf(szSettings, "/h \"I%s.h\"", LPCTSTR(strOdlFname));

				pBldWizIFace->SetToolSettings(htgts[i][j], hOdl, szSettings,
					"mktyplib.exe", TRUE, FALSE);
			}
		}
	}

	if (DoesSymbolExist("PROJTYPE_OCX"))
	{
		ASSERT(htgts[WIN][DEBUG_TGT] != NULL);
		ASSERT(htgts[WIN][RELEASE_TGT] != NULL);
		if (hLicense != NO_FILE)
		{
			ASSERT(DoesSymbolExist("LICENSED"));
	
			// If the control is licensed, the project makefile must know
			//  to copy the license to the output dirs via a custom build tool
			AddCopyLicenseStep(htgts[WIN][DEBUG_TGT], hLicense, hBld);
			AddCopyLicenseStep(htgts[WIN][RELEASE_TGT], hLicense, hBld);

		}
		AddRegSvrStep(htgts[WIN][DEBUG_TGT], hBld);
		AddRegSvrStep(htgts[WIN][RELEASE_TGT], hBld);
		AddUnicodeTargets(htgts[WIN][DEBUG_TGT], htgts[WIN][RELEASE_TGT], strProjType, hBld);
	}
	else if (DoesSymbolExist("HAS_REGISTRATION"))
	{
		AddRegSvrStep(htgts[WIN][DEBUG_TGT], hBld);
		AddRegSvrStep(htgts[WIN][RELEASE_TGT], hBld);
	}

	if (DoesSymbolExist("_ATL_WIZ_UNICODE_") && !DoesSymbolExist("PROJTYPE_OCX"))
	{
		ASSERT(htgts[WIN][DEBUG_TGT] != NULL);
		ASSERT(htgts[WIN][RELEASE_TGT] != NULL);
		AddUnicodeTargets(htgts[WIN][DEBUG_TGT], htgts[WIN][RELEASE_TGT], strProjType, hBld);
	}

	if (htgts[WIN][DEBUG_TGT] != NO_TARGET)
	{
		// This will make the win32 ansi debug (for ctlwiz projects) or
		//  the pseudo debug (for customwz projects) or
		//  the Win32, non-mac, debug (for appwiz projects)
		//  target the active (currently selected in UI) & default (when
		//  you nmake the .mak file from command-line) target.
		pBldWizIFace->SetActiveTarget(htgts[WIN][DEBUG_TGT], hBld);
		pBldWizIFace->SetDefaultTarget(htgts[WIN][DEBUG_TGT], hBld);
	}

	{
		// These lines should always be at the BOTTOM of CreateProject.  This
		//  calls into the custom AppWizard and gives it the opportunity
		//  to customize the project.  This happens AFTER all of the default
		//  aspects of the project have been set up.

		IBuildProject* pProject = NULL;
		pBldWizIFace->GetAutoProject(hBld, &pProject);
		if (pProject != NULL)
		{
			// Second parameter is documented as reserved.  Internal consumers
			//  may use it as IBuildWizard or QI for IBuildSystem.  They
			//  must AddRef it if they want it to hang around.
			GetAWX()->CustomizeProject(pProject);
			pProject->Release();
		}
#ifndef VS_PACKAGE
		else
			ASSERT (FALSE);		// GetAutoProject failed?!
#endif
	}

	pBldWizIFace->Release();
	pTermStatus->strlDepFiles.RemoveAll();
	pTermStatus->strlResFiles.RemoveAll();
	pTermStatus->strlNonPrjFiles.RemoveAll();
	pTermStatus->strlNonBldFiles.RemoveAll();
	pTermStatus->strlHelpFiles.RemoveAll();
	pTermStatus->strlTemplFiles.RemoveAll();
}

// Performs cleanup done after EACH TIME appwiz is exited.  NOT when
//  the IDE unloads it (as it was before).
int CTheDLL::ExitInstance()
{
//	UnloadOleEntryPoints();
	langDlls.FreeLibs();

	return 0;
}

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// Routine that glues it all together

void MakeProjectDirectory(const char* szSubDir)
{
    // first make sure '.' is a valid directory
    if (_chdir(".") != 0)
    {
        AfxMessageBox(IDP_CURDIR_GONE, MB_OK, 0);
        AfxThrowUserException();
    }

    if (szSubDir[0] != '\0')
        CreateDirectory(szSubDir, TRUE);    // relative path
}

CMainDlg::Generate(CWnd* pProjStatus, CWnd* pFileStatus)
{
    // save original directory
    char szOrigDir[_MAX_DIR];
    if (_getcwd(szOrigDir, _MAX_DIR) == NULL)
        szOrigDir[0] = '\0';

    BOOL bOK = TRUE;
    BeginWaitCursor();
    TRY
    {
        MakeProjectDirectory((LPCTSTR) projOptions.m_ProjDir);

		// Initialize file list
		pTermStatus->strlDepFiles.RemoveAll();
		pTermStatus->strlResFiles.RemoveAll();
		pTermStatus->strlHelpFiles.RemoveAll();
		pTermStatus->strlNonPrjFiles.RemoveAll();
		pTermStatus->strlNonBldFiles.RemoveAll();
		pTermStatus->strlTemplFiles.RemoveAll();

		// Generate project
		CProjGen projGen;
		projGen.Go(pProjStatus, pFileStatus);

		CString strFileToOpen = projOptions.m_strProj;
        if (pLaunchParent != NULL && !strFileToOpen.IsEmpty())
        {
            // ugly if we are visible while IDE is scanning dependencies!
            ASSERT(pProjStatus->GetParent() != NULL);
            pProjStatus->GetParent()->SetWindowPos(NULL, 0, 0, 0, 0,
                SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_HIDEWINDOW);
            SetWindowPos(NULL, 0, 0, 0, 0,
                SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_HIDEWINDOW);
			// Commented these out when made appwz a DLL
            pLaunchParent->EnableWindow(TRUE);
            ASSERT(pLaunchParent->IsWindowEnabled());
			
			pLaunchParent->SetActiveWindow();
//          pLaunchParent->UpdateWindow();

            // inherits the current directory from where we are now !
            FakeShellExecute(pLaunchParent->m_hWnd, "open", strFileToOpen);
        }
    }
    CATCH (CUserException, e)
    {
        bOK = FALSE;
    }
    AND_CATCH (CException, e)
    {
		TCHAR szError[1024];
		e->GetErrorMessage(szError, sizeof(szError) / sizeof(szError[0]));

		CString strBaseMessage;
		strBaseMessage.LoadString(IDS_GENERATE_FAILURE);
		CString strFormattedMessage;
		strFormattedMessage.Format(strBaseMessage, szError);

        AfxMessageBox(strFormattedMessage, MB_OK, 0);
        bOK = FALSE;
    }
    END_CATCH

/*    // Free handle to DLL.
	if (projOptions.m_hLocalizedRsc != NULL)
	{
   		FreeLibrary(projOptions.m_hLocalizedRsc);
		projOptions.m_hLocalizedRsc = NULL;
	}*/

	if (bOK)
		langDlls.FreeLibs();

    EndWaitCursor();
    // restore to original directory
    if (szOrigDir[0] != '\0')
        _chdir(szOrigDir);

    return bOK;
}

/////////////////////////////////////////////////////////////////////////////
// CConfirmDlg dialog


CConfirmDlg::CConfirmDlg(CWnd* pParent /*=NULL*/, BOOL bHasCancel /*=TRUE*/)
    : C3dDialog(CConfirmDlg::IDD, pParent)
{
	m_bHasCancel = bHasCancel;
	SetHelpID(CConfirmDlg::IDD);
}

void CConfirmDlg::OnHelp()
{
	SendMessage(WM_COMMANDHELP, 0, 0);
}

void CConfirmDlg::DoDataExchange(CDataExchange* pDX)
{
    C3dDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmDlg)
    DDX_Control(pDX, IDC_OUTPUT, m_stcOutput);
    DDX_Control(pDX, IDC_CONFIRM_DIR, m_stcDir);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CConfirmDlg, C3dDialog)
    //{{AFX_MSG_MAP(CConfirmDlg)
    ON_BN_CLICKED(ID_HELP, OnHelp)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
    //ON_BN_CLICKED(IDC_BACK, OnClickedBack)
END_MESSAGE_MAP()

void SpaceToUnderscore(CString& str)
{
	const TCHAR* pch = str;
	for (int i=0; *pch != '\0'; i += _tclen(pch), pch = _tcsinc(pch))
	{
		if (str[i] == _T(' '))
			str.SetAt(i, _T('_'));
	}
}

void CConfirmDlg::SetSymbols()
{
    SetMFCPathSymbol();
	SetYearSymbol();

	CString strInsertionComment;
	strInsertionComment.LoadString(IDS_INSERT_LOCATION_COMMENT);
	SetSymbol(_T("INSERT_LOCATION_COMMENT"), strInsertionComment);

    // set the current directory and to be generated directory
	m_strDir = (LPCTSTR) projOptions.m_ProjDir;
	SetSymbol("FullProjDir", m_strDir);

	if (IsUserAWX() && !langDlls.IsAnythingLoaded())
	{
		// If we're an extension, the extension may want to have the localized
		//  DLLs loaded.  Thus, we may want to load them all now.
		CString strUseDefault;
		GetSymbol(_T("USE_DEFAULT_LANGUAGE"), strUseDefault);

		if (strUseDefault.IsEmpty())
			langDlls.LoadLibsByName();
	}

	if (!langDlls.IsAnythingLoaded())
	{
		// We haven't had the occasion to load any langdlls yet
		//  (this can occur if we're generating a DLL), so look for the right
		//  language to use. [speed:4169]

		langDlls.m_AvailableLangDlls.ScanForAvailableLanguagesIfNecessary();

		CString strLibs;
		LPCTSTR szLibs = "appwzenu.dll\n0x040904E4";	// default guess
		if (!langDlls.m_AvailableLangDlls.m_strDefaultDllName.IsEmpty())
		{
			strLibs.Format("%s\n0x%x", (LPCTSTR)langDlls.m_AvailableLangDlls.m_strDefaultDllName, 
				langDlls.m_AvailableLangDlls.m_dwDefaultTranslation);
			szLibs = strLibs;
		}
		VERIFY(langDlls.LoadLibsByName(szLibs));
	}

	// TODO: This doesn't work: 0-step zapped extensions get no symbols set.
	/*if (IsUserAWX() && !projOptions.m_bMayBeAppWizTrack)
		// Don't set these symbols if we're a non-appwiz-track extension
		return;*/

	SetMenuSymbols();
	SetFrameSymbols();
	SetChildFrameSymbols();
	SetSizeMRUSymbols(projOptions.m_nSizeMRU);

	SetSplitterSymbols();
	SetLanguageSymbols();

    // get the strings for the two main edit items
	// TODO: DELETE!!! We don't need these cuz of MFC #pragmas, right?
//    SetSymbol("EXTRA_DEBUG_LIBRARIES", "");
 //   SetSymbol("EXTRA_RELEASE_LIBRARIES", "");

    // Project type
	// We shouldn't need this set here, since it's set after first dialog.
	//SetProjectTypeSymbol();

    // app options
	SetAppOptionsSymbols();

	// project options (common to both doc & dlg app)
	// For custom wizards we do not update symbols here since that would write over
	// any change that the custom wizard made.
	// For v5 we should *never* do this here (the custom test is just to make the
	// minimal change in v4.1 which is post-beta).
	if (!IsUserAWX())
	{
		SetProjOptionsSymbols();
	}

	SetOleSymbols();

    // fill in the symbols for classes
    CString tmp;
    if (projOptions.m_names.strClass[0].IsEmpty())
        FillDefaultNames(projOptions.m_names, projOptions.m_strProj);   // just use defaults
    UpdateTrackingNames(projOptions.m_names, projOptions.m_strProj);
	tmp = projOptions.m_strProjTag;   // non-DBCS root string
	SetSymbol("Safe_root", tmp);
	SetSymbol("safe_root", tmp);
	tmp.MakeUpper();
	SetSymbol("SAFE_ROOT", tmp);
	SetClassesSymbols();
	SetDBSymbols();

    // Set DLG-related symbols
    if (projOptions.m_nProjType == PROJTYPE_DLG)
    {
		// KEEP!!! the NOT used for classes dialog
        SetSymbol("PROJTYPE_DLG", "1");
        RemoveSymbol("PROJTYPE_NOT_DLG");
		CString strDialog;
		strDialog.Format("IDD_%s_DIALOG",tmp); // name of dialog resource to open
		SetSymbol( _T("APPWIZ_INITIAL_DIALOG"), strDialog );
    }
    else
    {
        RemoveSymbol("PROJTYPE_DLG");
		if( !projOptions.m_bNoDocView ) {
			SetSymbol("PROJTYPE_NOT_DLG", "1");
		}
    }
    if (projOptions.m_nProjType != PROJTYPE_DLG && !projOptions.m_bDBSimple)
    {
        SetSymbol("NOT_DLG_OR_SIMPLE", "1");
    }
    else
    {
        RemoveSymbol("NOT_DLG_OR_SIMPLE");
    }

	SetDocumentSymbols();
	
	// MAC-specific
	if (DoesSymbolExist("TARGET_MAC"))
	{
		SetSymbol("FILE_TYPE", projOptions.m_names.strDocFileType);
		SetSymbol("CREATOR", projOptions.m_names.strDocFileCreator);
		SetSymbol("MAC_FILTER", projOptions.m_names.strMacFilter);
		
		CString strRfile = projOptions.m_strProj + "Mac";
		SetSymbol("R_FILE", strRfile);
		SetSymbol("r_file", strRfile);
	}

	SetBaseViewSymbols();
	
	RemoveInapplicableSymbols();
}

void CConfirmDlg::OnOK()
{
    TRY
    {
		if(projOptions.m_nProjType == 3)
		{
			projOptions.m_nStartRes = GetRegInt("AppWizard","StartRes",0);
			projOptions.m_nStartRes = projOptions.m_nStartRes%30000;
			projOptions.m_nStartRes+=1000;
			WriteRegInt("AppWizard","StartRes",projOptions.m_nStartRes );
		}
        if (!((CMainDlg*) m_pParentWnd)->FinalProcessing())
            return;
    }
    CATCH (CException, e)
    {
        return;
    }
    END_CATCH
    C3dDialog::OnOK();
}

BOOL CConfirmDlg::OnInitDialog()
{
    C3dDialog::OnInitDialog();
    CenterWindow();

	// Should Cancel button say "< Back"?
	if (!m_bHasCancel)
	{
		CString strBack;
		strBack.LoadString(IDS_BACK);
		GetDlgItem(IDCANCEL)->SetWindowText(strBack);
	}

	// Print static creation message ("AppWizard will create...") at top
	CString strCreation, strWizardName;
	if (!IsUserAWX() || DoesSymbolExist("PROJTYPE_CUSTOMAW"))
		strWizardName.LoadString(IDS_APPWIZ_TITLE_CREATION);
	else
		strWizardName = projOptions.m_UserExtension.m_strExtensionTitle;
	strCreation.Format(IDS_CREATION, (LPCTSTR) strWizardName);
	SetDlgItemText(IDC_STATIC_CREATION, strCreation);

	// Fill edit ctrl with parsed contents of confirm.inf
	ListStream descriptionList;
    TRY
    {
        SetSymbols();          // Set options into symbol table
	    ASSERT(m_stcOutput.m_hWnd != NULL);
	    ASSERT(m_stcDir.m_hWnd != NULL);

	    // set directory name
	    //m_stcDir.SetWindowText(FixPath(m_strDir));
		// With FixPath moved to bld system, I wonder... why was I using
		//  it here in the first place?!
		m_stcDir.SetWindowText(m_strDir);

	    // fill with canned message
		CProjGen projGen;		// For storage in case confirm.inf loops & includes
		g_IncludeStack.Clear();
		LoadAndProcessTemplate("confirm.inf", &descriptionList);
		g_IncludeStack.Clear();

    }
    CATCH(CException, e)
    {
		OnCancel();
        return TRUE;
    }
    END_CATCH


    // turn into a long string
    CString strOut;
    POSITION pos = descriptionList.list.GetHeadPosition();
    while (pos)
    {
        const CString& s = descriptionList.list.GetNext(pos);
        if (!strOut.IsEmpty())
        {
            strOut += '\r';
            strOut += '\n';
        }
        strOut += s;
    }
	
	// Figure out whether we need a scrollbar.
	
	// Count # lines in output text
	const TCHAR* pch = (const TCHAR*) strOut;
	int nTextLines = 1;
	while (pch != NULL)
	{
		pch = _tcschr(pch, _T('\n'));
		if (pch == NULL)
			break;
		pch = _tcsinc(pch);
		nTextLines++;
	}

	CWindowDC dc(&m_stcOutput);
	CFont* pFont = m_stcOutput.GetFont();
	CFont *pOldFont = dc.SelectObject(pFont);
	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);
	dc.SelectObject(pOldFont);

	LONG fHeight = tm.tmHeight * nTextLines;
	RECT rect;
	m_stcOutput.GetClientRect(&rect);
	m_stcOutput.SetWindowText(strOut);
	if (fHeight > rect.bottom)
		m_stcOutput.ShowScrollBar(SB_VERT, TRUE);
	else
		m_stcOutput.ShowScrollBar(SB_VERT, FALSE);

	// If a modal dialog is brought up before OnInitDialog is finished (e.g.,
	//  if a server's guid is already registered, and appwiz asks the user
	//  whether to use the old guid), somehow, for some reason pLaunchParent
	//  seems to become enabled, and just disabling pLaunchParent makes
	//  CConfirmDlg disabled (though its titlebar appears active).  Enabling
	//  CConfirmDlg here seems to fix all the trouble.
	EnableWindow(TRUE);

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Little helper which will clear a radio button (i.e., set the other in its pair)
//  or clear a checkbox.
void MyResetCheck(CButton* pBtn)
{
    if (pBtn->GetButtonStyle() == BS_AUTORADIOBUTTON)
    {
        ((CButton*) pBtn->GetParent()->GetNextDlgGroupItem(pBtn))->SetCheck(1);
    }
    pBtn->SetCheck(0);
}

// Miscellaneous...

BOOL IsMDI()
{
	return projOptions.m_nProjType == PROJTYPE_MDI;
}

void SetMDI(BOOL bMDI)
{
	projOptions.m_nProjType = (bMDI ? PROJTYPE_MDI : PROJTYPE_SDI);
	SetProjectTypeSymbol();
}

BOOL CConfirmDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
	//OnHelp();
	return TRUE;
}

BOOL CMainDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
	if (GetDlgItem(ID_HELP)->IsWindowVisible())
	{
		// Do regular winhelp stuff if a help button is around
		OnHelp();
		return TRUE;
	}

	return DoHelpInfo(pHelpInfo);
}

BOOL CMainDlg::DoHelpInfo(HELPINFO* pInfo)
{
	if (pInfo->iContextType == HELPINFO_WINDOW)
	{
		HWND hwndCtrl = (HWND)pInfo->hItemHandle;
		DWORD hid;
		HWND hwndHelp;
#ifdef VS_PACKAGE
		return TRUE;
#else
		if (!GetHID(m_hWnd, hwndCtrl, &hwndHelp, &hid))
		{
			// default F1 to dialog help in main help window
//			CWnd::OnHelp();
			return TRUE;
		}
#endif	// VS_PACKAGE

        CString strHelp;
        GetHelpFile(strHelp);
        if(strHelp.IsEmpty())
			return TRUE;
   		::WinHelp(hwndHelp, strHelp, HELP_WM_HELP, hid);
	}
	return TRUE;
}

BOOL CanViewClassBeUsedWithSplitter(const CString &rstrViewClassName)
{
	BOOL fResult = TRUE;
	ULONG i;

	static LPCTSTR rgszClassesThatCantUseSplitters[] =
	{
		_T("CListView"),
		_T("CTreeView"),
		_T("CEditView"),
		_T("CRichEditView"),
		_T("CFormView"),
	};

	for (i=0; i<(sizeof(rgszClassesThatCantUseSplitters) / sizeof(rgszClassesThatCantUseSplitters[0])); i++)
	{
		if (rstrViewClassName == rgszClassesThatCantUseSplitters[i])
		{
			fResult = FALSE;
			break;
		}
	}

	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\mfcclass.h ===
// This file generated from the IDE FindInFiles.  Grepped through MFC headers for
//  occurrences of "class BLAH :".  Then used the IDE's Replace w/ regular expressions
//  to add the tabs, quotes, and commas, and erase unused junk.  Non CObject-derived
//  classes were added manually by eyeballing the MFC hierarchy charts.  Afterward, a
//  windiff -l, looking for lines in red with black text show classes that were omitted.

	"CObject",
	"CException",
	"CSimpleException",
	"CMemoryException",
	"CNotSupportedException",
	"CArchiveException",
	"CFileException",
	"CFile",
	"CStdioFile",
	"CMemFile",
	"CToolInfo",
	"CToolInfo",
	"CDragListBox",
	"CStatusBarCtrl",
	"CListCtrl",
	"CTreeCtrl",
	"CSpinButtonCtrl",
	"CSliderCtrl",
	"CProgressCtrl",
	"CHeaderCtrl",
	"CHotKeyCtrl",
	"CToolTipCtrl",
	"CTabCtrl",
	"CAnimateCtrl",
	"CImageList",
	"CToolBarCtrl",
	"CRichEditCtrl",
	"CByteArray",
	"CWordArray",
	"CDWordArray",
	"CUIntArray",
	"CPtrArray",
	"CObArray",
	"CStringArray",
	"CPtrList",
	"CObList",
	"CStringList",
	"CMapWordToPtr",
	"CMapPtrToWord",
	"CMapPtrToPtr",
	"CMapWordToOb",
	"CMapStringToPtr",
	"CMapStringToOb",
	"CMapStringToString",
	"COleControlModule",
	"COleControl",
	"COlePropertyPage",
	"CListView",
	"CTreeView",
	"CDaoWorkspace",
	"CDaoException",
	"CDaoDatabase",
	"CDaoTableDef",
	"CDaoQueryDef",
	"CDaoRecordset",
	"CDaoRecordView",
	"CDBException",
	"CDatabase",
	"CRecordset",
	"CRecordView",
	"CLongBinary",
	"COleException",
	"COleDispatchException",
	"COleObjectFactory",
	"COleTemplateServer",
	"CConnectionPoint",
	"COleVariant",
	"CCommonDialog",
	"CFileDialog",
	"CFontDialog",
	"CColorDialog",
	"CPageSetupDialog",
	"CPrintDialog",
	"CFindReplaceDialog",
	"CPropertyPage",
	"CPropertySheet",
	"CDynLinkLibrary",
	"CBitmapButton",
	"CControlBar",
	"CStatusBar",
	"CToolBar",
	"CDialogBar",
	"CSplitterWnd",
	"CFormView",
	"CHtmlView",
	"CEditView",
	"CMetaFileDC",
	"CSyncObject",
	"CSemaphore",
	"CMutex",
	"CEvent",
	"CCriticalSection",
	"COleUILinkInfo",
	"COleDialog",
	"COleInsertDialog",
	"COleConvertDialog",
	"COleChangeIconDialog",
	"COlePasteSpecialDialog",
	"COleLinksDialog",
	"COleUpdateDialog",
	"COleBusyDialog",
	"COlePropertiesDialog",
	"COleChangeSourceDialog",
	"COleDataSource",
	"CDocItem",
	"COleDocument",
	"COleClientItem",
	"COleServerItem",
	"COleLinkingDoc",
	"COleServerDoc",
	"COleIPFrameWnd",
	"COleResizeBar",
	"COleStreamFile",
	"COleDropSource",
	"COleDropTarget",
	"COleMessageFilter",
	"CSharedFile",
	"CMirrorFile",
	"CPreviewDC",
	"CPreviewView",
	"CDockState",
	"CDockBar",
	"CMiniDockFrameWnd",
	"COleCntrFrameWnd",
	"CArchiveStream",
	"CRichEditView",
	"CRichEditDoc",
	"CRichEditCntrItem",
	"CSocketWnd",
	"CAsyncSocket",
	"CSocket",
	"CSocketFile",
	"CArray",
	"CList",
	"CMap",
	"CTypedPtrArray",
	"CTypedPtrList",
	"CTypedPtrMap",
	"CTypedSimpleList",
	"CThreadLocal",
	"CProcessLocal",
	"CSize",
	"CPoint",
	"CRect",
	"CResourceException",
	"CUserException",
	"CGdiObject",
	"CPen",
	"CBrush",
	"CFont",
	"CBitmap",
	"CPalette",
	"CRgn",
	"CDC",
	"CPaintDC",
	"CClientDC",
	"CWindowDC",
	"CMenu",
	"CCmdTarget",
	"CWnd",
	"CDialog",
	"CStatic",
	"CButton",
	"CListBox",
	"CCheckListBox",
	"CComboBox",
	"CEdit",
	"CScrollBar",
	"CFrameWnd",
	"CMDIFrameWnd",
	"CMDIChildWnd",
	"CMiniFrameWnd",
	"CView",
	"CCtrlView",
	"CScrollView",
	"CWinThread",
	"CCommandLineInfo",
	"CDocManager",
	"CWinApp",
	"CDocTemplate",
	"CSingleDocTemplate",
	"CMultiDocTemplate",
	"CDocument",

// Not derived from CObject
	"CArchive",
	"CDumpContext",
	"CRuntimeClass",
	"CString",
	"CTime",
	"CTimeSpan",
	"CCreateContext",
	"CFileStatus",
	"CMemoryState",
	"CPrintInfo",
	"CCmdUI",
	"CDaoFieldExchange",
	"CDataExchange",
	"CFieldExchange",
	"COleDataObject",
	"COleDispatchDriver",
	"CPropExchange",
	"CRectTracker",
	"CWaitCursor",
	"CFontHolder",
	"CPictureHolder",
	"COleCurrency",
	"COleDateTime",
	"COleDateTimeSpan",
	"CMultiLock",
	"CSingleLock",
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\makefile.inc ===
!include $(IDE_ROOT)\makefile.inc

# ---------------------------------------------------------------------------
# Set up dependance on package versioning file
# ---------------------------------------------------------------------------
..\mfcappwz.cpp: $(PACKVERCHECK)

# ---------------------------------------------------------------------------
# General macros
# ---------------------------------------------------------------------------

APPWIZ_OBJDIR=$(APPWIZ_ROOT)\\$(O)


# ---------------------------------------------------------------------------
# Rules for building $(NEW_RC_FILE) "mfcappwz.rc_"
# ---------------------------------------------------------------------------

TPL_NOLOC_FILES=*.*
NEW_RC_FILE=$(APPWIZ_OBJDIR)\\mfcappwz.rc_

mfcappwz.rc : $(NEW_RC_FILE)
$(NEW_RC_FILE) : $(TPL_NOLOC_DIR)\$(TPL_NOLOC_FILES)
    cd $(TPL_NOLOC_DIR)
    echo // Code templates                                                       > $*.tm2
    @for %%f in ($(TPL_NOLOC_FILES)) do echo %%f TEMPLATE "$(TPL_NOLOC_DIR)\\%%f" >> $*.tm2
    fixwhack < $*.tm2 > $@
    cd $(APPWIZ_ROOT)


# ---------------------------------------------------------------------------
# Build the resource DLL
# ---------------------------------------------------------------------------

LINKFLAGS_RES = -dll -noentry -machine:$(TARGET_DIRECTORY) -debug:none -release
NEW_LANG_FILE=$(APPWIZ_OBJDIR)\\$(APPWIZ_LANG).rc_
LANG_RC_FILE=$(APPWIZ_ROOT)\\$(APPWIZ_LANG).rc
TPL_LOC_FILES= *.*

$(LANG_RC_FILE): $(NEW_LANG_FILE)

$(NEW_LANG_FILE): $(TPL_LOC_DIR)\$(TPL_LOC_FILES) $(TPL_TAG_DIR)\$(TPL_LOC_FILES)
    cd $(TPL_LOC_DIR)
    echo // Resource templates                                                >  $*.tm2
    @for %%f in ($(TPL_LOC_FILES)) do echo %%f TEMPLATE "$(TPL_LOC_DIR)\\%%f" >> $*.tm2
    cd $(APPWIZ_ROOT)
    cd $(TPL_TAG_DIR)
    echo // Tagged resource templates                                         >>  $*.tm2
    @for %%f in ($(TPL_LOC_FILES)) do echo %%f TEMPLATE_TAG "$(TPL_TAG_DIR)\\%%f" >> $*.tm2
    fixwhack < $*.tm2 > $@
    cd $(APPWIZ_ROOT)


$O\$(APPWIZ_LANG).res: $(LANG_RC_FILE)

$(RESDLL_NAME): $O\$(APPWIZ_LANG).res
    $(LINKER) $(LINKFLAGS_RES) $O\$(APPWIZ_LANG).res


# ---------------------------------------------------------------------------
# rules for generating a .def file from hell
# ---------------------------------------------------------------------------

!if "$(DEBUG)"=="0"
DESCRIPTION="APPWIZ_DLL"
DLL=dllretail
!else
DESCRIPTION="APPWIZD_DLL"
DLL=dlldebug
!endif

SHARE=shared

!ifdef REDEFPASS

$O\$(TARGETNAME).def:
    -del /f/q $O\$(TARGETNAME).def
    echo LIBRARY $(TARGETNAME) > $@

!else

$(DLLDEF): $O\$(TARGETNAME).map
#   strip the map file to symbols leave 1 space at the beginning of line
    maptweak $** $O\tmp.1
#   filter out what we don't want to export (blank at start of each line)
    qgrep -v -f $(APPWIZ_ROOT)\filter.no $O\tmp.1 > $O\tmp.3
    qgrep < $O\tmp.3 -f $(APPWIZ_ROOT)\filter.yes > $O\tmp.4
    sort < $O\tmp.4 > $O\tmp.2
    type $O\tmp.2 > $O\$(TARGETNAME).tmp
    #-del $O\tmp.1 $O\tmp.2 $O\tmp.3 $O\tmp.4
#   build the real .DEF file
    echo LIBRARY $(TARGETNAME)           > $@
    echo DESCRIPTION $(DESCRIPTION)     >> $@
    echo EXPORTS                        >> $@
    type canned.exp     >> $@
!if "$(DEBUG)"=="0"
    genord 2 < $O\$(TARGETNAME).tmp >> $@
!else
    type $O\$(TARGETNAME).tmp >> $@
!endif
    #-del $O\$(TARGETNAME).tmp

$O\$(TARGETNAME).map: $(LIBRARY_OBJS)
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp
    -del $(DLLDEF)
    set LINKER_FLAGS=-map:$@
    set NOLINK=
    $(MAKE) MAKEDLL=1 REDEFPASS=1 LINKER_NOREF=1
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\myaw.h ===
#ifndef __MYAW_H__
#define __MYAW_H__

#include "customaw.h"

LPCTSTR LoadTemplateWrapper(LPCTSTR lpszResource, DWORD& dwSize, HINSTANCE hInstance = NULL);

class CMyCustomAppWiz : public CCustomAppWiz
{
public:
	virtual LPCTSTR LoadTemplate(LPCTSTR lpszResource,
		DWORD& dwSize, HINSTANCE hInstance = NULL);
};

CCustomAppWiz* GetAWX();

#endif //__MYAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\miscdlgs.cpp ===
// miscdlgs.cpp : implementation file
//

#include "stdafx.h"
#include "mfcappwz.h"
#include "miscdlgs.h"
#include "ddxddv.h"
#include "advanced.h"
#include "symbols.h"
#include "lang.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


// This is used by the DocAppOptionsDlg & DlgAppOptionsDlg to verify
//  the string entered as the app's title.

#define MAX_MAC_TITLE 27   // Max no. chars. in Mac titlebar.

BOOL IsValidTitle(const char* szTitle)
{
	int nLen = strlen(szTitle);
	if (nLen > MAX_MAC_TITLE)
		return FALSE;
	while (*szTitle)
	{
		//this won't go off the end of the string because even if you see a '\' as
		//the last char, checking the \0 against 'n' won't hurt anything
		if (*szTitle == _T('\"') || (*szTitle == _T('\\') && *(szTitle + 1) == _T('n')))
		{
			return FALSE;
		}
		szTitle = _tcsinc(szTitle);
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDocAppOptionsDlg dialog

CDocAppOptionsDlg::CDocAppOptionsDlg(CWnd* pParent /*=NULL*/)
	: CSeqDlg(CDocAppOptionsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDocAppOptionsDlg)
	m_nSizeMRU = 0;
	m_nMenus = 0;
	//}}AFX_DATA_INIT
}

void CDocAppOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CSeqDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDocAppOptionsDlg)
	DDX_Text(pDX, IDC_MRU, m_nSizeMRU);
	DDV_MinMaxUInt(pDX, m_nSizeMRU, 0, 16);
	DDX_Radio(pDX, IDC_NORMALMENU, m_nMenus);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDocAppOptionsDlg, CSeqDlg)
	//{{AFX_MSG_MAP(CDocAppOptionsDlg)
	ON_BN_CLICKED(IDC_ADVANCED, OnAdvanced)
	ON_COMMAND_EX(IDCD_POTOOLBAR, OnClickedCheckbox)
	ON_COMMAND_EX(IDCD_POSTATUSBAR, OnClickedCheckbox)
	ON_COMMAND_EX(IDCD_POPRINT, OnClickedCheckbox)
	ON_COMMAND_EX(IDCD_POHELP, OnClickedCheckbox)
	ON_COMMAND_EX(IDCD_PO3D, OnClickedCheckbox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CDocAppOptionsDlg::CanDestroy()
{
	if (!UpdateData(TRUE))
		return FALSE;

	if (projOptions.m_bActiveDocServer && projOptions.m_names.strDocFileExt.IsEmpty())
	{
		AfxMessageBox(IDP_NOEXT_DOCSVR);
		return FALSE;
	}

	WriteValues();		
	return TRUE;
}

void CDocAppOptionsDlg::WriteValues()
{
	UpdateData(TRUE);
	projOptions.m_nSizeMRU = m_nSizeMRU;
    for (int i=0; i < PO_OPTION_COUNT; i++)
    {
        CButton* pCheck = (CButton*)GetDlgItem(IDCD_POBASE + i);
        ASSERT(pCheck != NULL);
        if (pCheck->GetCheck())
            projOptions.m_options |= (1 << i);
        else
            projOptions.m_options &= ~(1 << i);
    }
	projOptions.m_nMenuStyle = m_nMenus;
	SetAppOptionsSymbols();
	SetSizeMRUSymbols(m_nSizeMRU);
	SetDocumentSymbols();
	SetFrameSymbols();
	SetMenuSymbols();
	SetSplitterSymbols();
	SetChildFrameSymbols();
}

void CDocAppOptionsDlg::ReadValues()
{
	GetAppOptionsSymbols();
	GetSizeMRUSymbols();
	GetDocumentSymbols();
	GetFrameSymbols();
	GetMenuSymbols();
	GetSplitterSymbols();
	GetChildFrameSymbols();
	m_nSizeMRU = projOptions.m_nSizeMRU;
	m_nMenus = projOptions.m_nMenuStyle;
	UpdateData(FALSE);
    for (int i=0; i < PO_OPTION_COUNT; i++)
    {
        CButton* pCheck = (CButton*)GetDlgItem(IDCD_POBASE + i);
        ASSERT(pCheck != NULL);
        if (projOptions.m_options & (1 << i))
            pCheck->SetCheck(1);
        else
            MyResetCheck(pCheck);
    }
	CButton* pCheck = (CButton*)GetDlgItem(IDCD_POTOOLBAR);
	ASSERT(pCheck != NULL);
	GetDlgItem(IDC_REBARMENU)->EnableWindow(pCheck->GetCheck());
	GetDlgItem(IDC_NORMALMENU)->EnableWindow(pCheck->GetCheck());
}

BOOL CDocAppOptionsDlg::OnClickedCheckbox(UINT nID)
{
	CMainDlg* pMainDlg = (CMainDlg*) GetParent();
	pMainDlg->RedrawBitmap(BMPSIZE_SUM);
	pMainDlg->RedrawBitmap(BMPSIZE_3D);

	if(nID == IDCD_POTOOLBAR)
	{
		CButton* pCheck = (CButton*)GetDlgItem(IDCD_POTOOLBAR);
		ASSERT(pCheck != NULL);
		GetDlgItem(IDC_REBARMENU)->EnableWindow(pCheck->GetCheck());
		GetDlgItem(IDC_NORMALMENU)->EnableWindow(pCheck->GetCheck());
	}

	return TRUE;
}

static UINT DAObmp[] =
{
	IDB_B140000, IDB_B140001, IDB_B140010, IDB_B140011,
	IDB_B140100, IDB_B140101, IDB_B140110, IDB_B140111,
	IDB_B141000, IDB_B141001, IDB_B141010, IDB_B141011,
	IDB_B141100, IDB_B141101, IDB_B141110, IDB_B141111,
};

#define NUM_PICTURED_OPTIONS 4
UINT CDocAppOptionsDlg::ChooseBitmap()
{
	int nIndex = 0;
	for (int i=0; i < NUM_PICTURED_OPTIONS; i++)
	{
		CButton* pCheck = (CButton*)GetDlgItem(IDCD_PICBASE + ((NUM_PICTURED_OPTIONS-1) - i));
        ASSERT(pCheck != NULL);
		if (pCheck->GetCheck())
			nIndex += (1 << i);
	}
	return DAObmp[nIndex];
}

static UINT DAO3Dbmp[] =
{
	IDB_B143DNO, IDB_B143DON,
};

UINT CDocAppOptionsDlg::ChooseBitmap2()
{
	CButton* pCheck = (CButton*) GetDlgItem(IDCD_PO3D);
	ASSERT(pCheck != NULL);
	if (pCheck->GetCheck())
		return DAO3Dbmp[1];
	else
		return DAO3Dbmp[0];
}

BOOL IsMacWOSA();		// defined in mfcappwz.cpp

void CDocAppOptionsDlg::EnablePrint(BOOL bEnable)
{
	GetDlgItem(IDCD_POPRINT)->EnableWindow(bEnable);
}

BOOL CDocAppOptionsDlg::OnInitDialog()
{
    CSeqDlg::OnInitDialog();
	VERIFY(m_btnAdvanced.SubclassDlgItem(IDC_ADVANCED, this));

	// Init MRU Spin control
	CSpinButtonCtrl* pSpin = (CSpinButtonCtrl*) GetDlgItem(IDC_SPINMRU);
	pSpin->SetRange(0, 16);


    CenterWindow();

	if (projOptions.m_bNoDocView)
	{
		// No Doc View architecture support means no printing
		projOptions.m_options &= ~(1 << (IDCD_POPRINT-IDCD_POBASE) );
		SetAppOptionsSymbols();
		EnablePrint(FALSE);
		GetDlgItem(IDCD_POMAPI)->EnableWindow(FALSE);
	}
	else
	{
		EnablePrint(TRUE);
		GetDlgItem(IDCD_POMAPI)->EnableWindow(TRUE);
	}

    ReadValues();
    return TRUE;
}

// We override PreTranslate to make sure that if a button is default,
//  <return> causes it to be activated.
BOOL CDocAppOptionsDlg::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN
		&& ::GetFocus() == GetDlgItem(IDC_ADVANCED)->GetSafeHwnd())
	{
		SendMessage(WM_COMMAND,
			MAKEWPARAM(IDC_ADVANCED, BN_CLICKED),
			(LPARAM) (GetDlgItem(IDC_ADVANCED)->GetSafeHwnd()));
		return TRUE;
	}

	return CSeqDlg::PreTranslateMessage(pMsg);
}

/////////////////////////////////////////////////////////////////////////////
// CDlgAppOptionsDlg dialog


CDlgAppOptionsDlg::CDlgAppOptionsDlg(CWnd* pParent /*=NULL*/)
	: CSeqDlg(CDlgAppOptionsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgAppOptionsDlg)
	m_bOleAutomation = FALSE;
	m_bOcx = TRUE;
	//}}AFX_DATA_INIT
}

void CDlgAppOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CSeqDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgAppOptionsDlg)
	DDX_Check(pDX, IDCD_AUTOMATION, m_bOleAutomation);
	DDX_Check(pDX, IDCD_OCX, m_bOcx);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDlgAppOptionsDlg, CSeqDlg)
	//{{AFX_MSG_MAP(CDlgAppOptionsDlg)
    ON_WM_DESTROY()
	ON_COMMAND_EX(IDCD_POABOUT, OnClickedCheckbox)
	ON_COMMAND_EX(IDCD_POHELP, OnClickedCheckbox)
	ON_COMMAND_EX(IDCD_PO3D, OnClickedCheckbox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CDlgAppOptionsDlg::GetTitle(CString& strTitle)
{
	CWnd* pEdit = GetDlgItem(IDC_APP_TITLE);
	ASSERT_VALID(pEdit);
	pEdit->GetWindowText(strTitle);
	strTitle.ReleaseBuffer();
}

BOOL CDlgAppOptionsDlg::CanDestroy()
{
	CString strTitle;
	GetTitle(strTitle);
	if (!(strTitle))
	{
		AfxMessageBox(IDP_BAD_TITLE);
		CEdit* pEdit = (CEdit*) GetDlgItem(IDC_APP_TITLE);
		pEdit->SetSel(0, -1);
		pEdit->SetFocus();
		return FALSE;
	}
	projOptions.m_names.strTitle = strTitle;
	return TRUE;
}
		
void CDlgAppOptionsDlg::WriteValues()
{
	VERIFY(UpdateData());
	projOptions.m_bOleAutomation = m_bOleAutomation;
	projOptions.m_bOcx = m_bOcx;
	GetTitle(langDlls.m_astrTitle[0]);
    for (int i=0; i < PODLG_OPTION_COUNT; i++)
    {
        CButton* pCheck = (CButton*)GetDlgItem(IDCD_PODLGBASE + i);
        ASSERT(pCheck != NULL);
        if (pCheck->GetCheck())
            projOptions.m_options |= (1 << (i + IDCD_PODLGBASE-IDCD_POBASE));
        else
            projOptions.m_options &= ~(1 << (i + IDCD_PODLGBASE-IDCD_POBASE));
    }
	SetAppOptionsSymbols();
	SetOleSymbols();
}

void CDlgAppOptionsDlg::ReadValues()
{
	GetAppOptionsSymbols();
	GetOleSymbols();
    for (int i=0; i < PODLG_OPTION_COUNT; i++)
    {
        CButton* pCheck = (CButton*)GetDlgItem(IDCD_PODLGBASE + i);
        ASSERT(pCheck != NULL);
        if (projOptions.m_options & (1 << (i + IDCD_PODLGBASE-IDCD_POBASE)))
            pCheck->SetCheck(1);
        else
            MyResetCheck(pCheck);
    }

	CWnd* pEdit = GetDlgItem(IDC_APP_TITLE);
	ASSERT_VALID(pEdit);
	pEdit->SetWindowText(projOptions.m_names.strTitle);	
	m_bOleAutomation = projOptions.m_bOleAutomation;
	m_bOcx = projOptions.m_bOcx;
	UpdateData(FALSE);
}

// Enable/disable WOSA & OCX options
void CDlgAppOptionsDlg::EnableVarious(BOOL bEnableWOSA, BOOL bEnableOCX)
{
	// WOSA
	GetDlgItem(IDCD_POSOCKETS)->EnableWindow(bEnableWOSA);
	GetDlgItem(IDC_WOSA_QUESTION)->EnableWindow(bEnableWOSA);
	GetDlgItem(IDC_WOSA_STATIC)->ShowWindow(bEnableWOSA ? SW_HIDE : SW_SHOW);

	// OCX
	GetDlgItem(IDCD_OCX)->EnableWindow(bEnableOCX);
	GetDlgItem(IDC_OCX_STATIC)->ShowWindow(bEnableOCX ? SW_HIDE : SW_SHOW);
}

BOOL CDlgAppOptionsDlg::OnInitDialog()
{
    CSeqDlg::OnInitDialog();
    CenterWindow();
    
	CString tmp;
	if (DoesSymbolExist("TARGET_MAC") && !IsMacWOSA())
	{
		// MacWOSA is not around, so select no WOSA support & disable the controls
		projOptions.m_options &= ~(1 << IDCD_POMAPI-IDCD_POBASE);
		projOptions.m_options &= ~(1 << IDCD_POSOCKETS-IDCD_POBASE);
		projOptions.m_bOcx = IsMacOcx();
		EnableVarious(FALSE, IsMacOcx());
	}
	else
	{
		// WOSA is a-ok to be enabled.
		EnableVarious(TRUE, TRUE);
	}

    ReadValues();
    return TRUE;
}

BOOL CDlgAppOptionsDlg::OnClickedCheckbox(UINT nID)
{
	CMainDlg* pMainDlg = (CMainDlg*) GetParent();
	pMainDlg->RedrawBitmap(BMPSIZE_SUM);
	pMainDlg->RedrawBitmap(BMPSIZE_3D);
	return TRUE;
}

static UINT DgAObmp[] =
{
	IDB_B2200, IDB_B2201, IDB_B2210, IDB_B2211,
};

UINT CDlgAppOptionsDlg::ChooseBitmap()
{
	int nIndex = 0;
	CButton* pCheck = (CButton*)GetDlgItem(IDCD_POABOUT);
	ASSERT(pCheck != NULL);
	if (pCheck->GetCheck())
		nIndex += (1 << 1);
	pCheck = (CButton*)GetDlgItem(IDCD_POHELP);
	ASSERT(pCheck != NULL);
	if (pCheck->GetCheck())
		nIndex += (1 << 0);

	return DgAObmp[nIndex];
}

UINT CDlgAppOptionsDlg::ChooseBitmap2()
{
	CButton* pCheck = (CButton*) GetDlgItem(IDCD_PO3D);
	ASSERT(pCheck != NULL);
	if (pCheck->GetCheck())
		return DAO3Dbmp[1];
	else
		return DAO3Dbmp[0];
}

void CDlgAppOptionsDlg::OnDestroy()
{
    WriteValues();
    CSeqDlg::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////
// CProjOptionsDlg dialog

CProjOptionsDlg::CProjOptionsDlg(UINT nID, CWnd* pParent)
	: CSeqDlg(nID, pParent)
{
}

CProjOptionsDlg::CProjOptionsDlg(CWnd* pParent /*=NULL*/)
	: CSeqDlg(CProjOptionsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CProjOptionsDlg)
	m_nAtlSupport = 1;
	m_nProjStyle = PS_MFCNORMAL;
	//}}AFX_DATA_INIT
}

void CProjOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CSeqDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProjOptionsDlg)
	DDX_Radio(pDX, IDC_MFCSTANDARD, m_nProjStyle);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CProjOptionsDlg, CSeqDlg)
	//{{AFX_MSG_MAP(CProjOptionsDlg)
	ON_COMMAND_EX(IDCD_POVERBOSE, OnClickedRadio)
    ON_WM_DESTROY()
	ON_COMMAND_EX(IDC_RADIO2, OnClickedRadio)
	ON_COMMAND_EX(IDC_RADIO3, OnClickedRadio)
	ON_COMMAND_EX(IDC_RADIO5, OnClickedRadio)
	ON_COMMAND_EX(IDC_MFCSTANDARD, OnClickedRadio)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CProjOptionsDlg::OnClickedRadio(UINT nID)
{
	UpdateData(TRUE);	// Force a DDX to Get values
	CMainDlg* pMainDlg = (CMainDlg*) GetParent();
	pMainDlg->RedrawBitmap(BMPSIZE_SUM);
	return TRUE;
}

static UINT PObmp[] =
{
	IDB_B150110, IDB_B150101, IDB_B151010, IDB_B151001,
};

UINT CProjOptionsDlg::ChooseBitmap()
{
	int nIndex = 0;
	//for (int i=0; i < PO_PROJ_COUNT-1; i++)
	const int i = 0;
	{
        CButton* pCheck = (CButton*)GetDlgItem(IDCD_POPROJBASE + i);
        ASSERT(pCheck != NULL);
        if (pCheck->GetCheck())
			nIndex = 2;
		else
			nIndex = 0;
	}
	return PObmp[nIndex];
	// TODO: Fix me

}

void CProjOptionsDlg::WriteValues()
{
    for (int i=0; i < PO_PROJ_COUNT; i++)
    {
        CButton* pCheck = (CButton*)GetDlgItem(IDCD_POPROJBASE + i);
        ASSERT(pCheck != NULL);
        if (pCheck->GetCheck())
            projOptions.m_projOptions |= (1 << i);
        else
            projOptions.m_projOptions &= ~(1 << i);
    }
    projOptions.m_bATLSupport= !m_nAtlSupport;
    projOptions.m_nProjStyle = m_nProjStyle;
	SetProjOptionsSymbols();
}

BOOL CProjOptionsDlg::CanDestroy()
{
    WriteValues();
	return TRUE;
}

void CProjOptionsDlg::ReadValues()
{
	GetProjOptionsSymbols();
    for (int i=0; i < PO_PROJ_COUNT; i++)
    {
        CButton* pCheck = (CButton*)GetDlgItem(IDCD_POPROJBASE + i);
        ASSERT(pCheck != NULL);
        if (projOptions.m_projOptions & (1 << i))
            pCheck->SetCheck(1);
        else
            MyResetCheck(pCheck);
    }
    if( projOptions.m_bATLSupport ) 
		m_nAtlSupport = 0;
	else 
		m_nAtlSupport = 1;

    m_nProjStyle = projOptions.m_nProjStyle;
}

BOOL CProjOptionsDlg::OnInitDialog()
{
	// we don't give the user an option to change how we link to MFC
	// for the learning edition.  The GetDlgItem(IDC_MFC_LIB) call
	// in the if is to make sure we're working with the dialog resource
	// that belongs to CProjOptionsDlg.  CDllProjOptionsDlg is derived
	// from this class and handles the MFC linkage a bit differently.
	if (IsLearningBox() && GetDlgItem(IDC_MFC_LIB))
	{
		GetDlgItem(IDC_MFC_LIB)->ShowWindow(SW_HIDE);
		GetDlgItem(IDCD_PODLL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDCD_PONOTDLL)->ShowWindow(SW_HIDE);
	}
	if( GetDlgItem(IDC_RADIO5) )
	{
		if( projOptions.m_bNoDocView || (projOptions.m_nProjType == PROJTYPE_DLG) )
			GetDlgItem(IDC_RADIO5)->EnableWindow(FALSE);
		else
			GetDlgItem(IDC_RADIO5)->EnableWindow(TRUE);
	}

    CSeqDlg::OnInitDialog();
    CenterWindow();

	// If we're not targeting something that can use MFC in a DLL,
	//  force user to use static MFC
	CString tmp;
	if (!DoesSymbolExist("TARGET_MIPS")
		&& !DoesSymbolExist("TARGET_ALPHA")
		&& !DoesSymbolExist("TARGET_INTEL")
		&& !DoesSymbolExist("TARGET_POWERMAC"))

	{
		projOptions.m_projOptions &= ~(1 << (IDCD_PODLL-IDCD_POPROJBASE));
		SetProjOptionsSymbols();
		ReadValues();
		GetDlgItem(IDCD_PODLL)->EnableWindow(FALSE);
		GetDlgItem(IDCD_PONOTDLL)->EnableWindow(FALSE);
	}
	else
		ReadValues();

	UpdateData(FALSE);
    return TRUE;
}

void CProjOptionsDlg::OnDestroy()
{
    WriteValues();
    CSeqDlg::OnDestroy();
}

void CDocAppOptionsDlg::OnAdvanced()
{
	CAdvancedDlg dlg(GetParent());
	dlg.DoModal();

	// don't allow user to 'finish' from here if ActiveX doc server AND no file extension
	GetParent()->GetDlgItem(IDC_END)->EnableWindow(!(projOptions.m_bActiveDocServer && projOptions.m_names.strDocFileExt.IsEmpty()));
}

/////////////////////////////////////////////////////////////////////////////
// CDllProjOptionsDlg dialog


CDllProjOptionsDlg::CDllProjOptionsDlg(CWnd* pParent /*=NULL*/)
	: CProjOptionsDlg(CDllProjOptionsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDllProjOptionsDlg)
	m_nDllType = -1;
	m_nVerbose = -1;
	//}}AFX_DATA_INIT
}


void CDllProjOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CProjOptionsDlg::DoDataExchange(pDX);
	if (IsLearningBox())
	{
		// m_nDllType is based on IDC_DLLTYPE as position 0
		// since we're getting rid of it for the learning box,
		// we need to adjust accordingly
		if (m_nDllType > 0)
			m_nDllType--;
		DDX_Radio(pDX, IDCD_PODLL, m_nDllType);
		m_nDllType++;
	}
	else
		DDX_Radio(pDX, IDC_DLLTYPE, m_nDllType);
	//{{AFX_DATA_MAP(CDllProjOptionsDlg)
		DDX_Radio(pDX, IDCD_POVERBOSE, m_nVerbose);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDllProjOptionsDlg, CProjOptionsDlg)
	//{{AFX_MSG_MAP(CDllProjOptionsDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CDllProjOptionsDlg::OnInitDialog() 
{
	if (IsLearningBox())
	{
		// this little exercise gets rid of the static linkage option and moves 
		// the other two options up on the screen
		CWnd* wnd = GetDlgItem(IDC_DLLTYPE);
		RECT rect1, rect2;
		if (wnd)
		{
			wnd->GetWindowRect(&rect1);
			ScreenToClient(&rect1);
			wnd->ShowWindow(SW_HIDE);
		}
		wnd = GetDlgItem(IDCD_PODLL);
		if (wnd)
		{
			wnd->GetWindowRect(&rect2);
			ScreenToClient(&rect2);
			wnd->ModifyStyle(0L, WS_GROUP);
			wnd->MoveWindow(&rect1);
			if (GetDlgItem(IDC_RADIO1))
				GetDlgItem(IDC_RADIO1)->MoveWindow(&rect2);
		}
	}

	CProjOptionsDlg::OnInitDialog();

	if (DoesSymbolExist("TARGET_MAC") && !IsMacWOSA())
	{
		// MacWOSA is not around, so select no WOSA support & disable the controls
		projOptions.m_options &= ~(1 << IDCD_POSOCKETS-IDCD_POBASE);
		RemoveSymbol("SOCKETS");
		EnableSockets(FALSE);
	}
	else
	{
		// WOSA is a-ok to be enabled.
		EnableSockets(TRUE);
	}

	ReadValues();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDllProjOptionsDlg::EnableSockets(BOOL bEnable)
{
	GetDlgItem(IDCD_SOCKETS)->EnableWindow(bEnable);
	GetDlgItem(IDC_SOCKETS_STATIC)->ShowWindow(bEnable ? SW_HIDE : SW_SHOW);
}

void CDllProjOptionsDlg::ReadValues()
{
	// DLL Type
	GetProjOptionsSymbols();
	GetDllSymbol();
	if (projOptions.m_bExtdll)
	{
		if (!(projOptions.m_projOptions & (1 << (IDCD_PODLL-IDCD_POPROJBASE))))
		{
			ASSERT(FALSE);
			projOptions.m_projOptions |= (1 << IDCD_PODLL-IDCD_POPROJBASE);
		}
		m_nDllType = DT_EXT;
	}
	else
	{
		if (projOptions.m_projOptions & (1 << IDCD_PODLL-IDCD_POPROJBASE))
			m_nDllType = DT_REGSHARED;
		else
			m_nDllType = DT_REGSTATIC;
	}
 
	// automation
	GetOleSymbols();
	((CButton*) GetDlgItem(IDCD_AUTOMATION))->SetCheck(projOptions.m_bOleAutomation);
	
	// sockets
	GetAppOptionsSymbols();
	if (projOptions.m_options & (1 << (IDCD_POSOCKETS-IDCD_POBASE)))
		((CButton*) GetDlgItem(IDCD_SOCKETS))->SetCheck(1);
	else
		((CButton*) GetDlgItem(IDCD_SOCKETS))->SetCheck(0);

	// verbose
	if (projOptions.m_projOptions & (1 << (IDCD_POVERBOSE-IDCD_POPROJBASE)))
		m_nVerbose = 0;
	else
		m_nVerbose = 1;

	UpdateData(FALSE);
}

void CDllProjOptionsDlg::WriteValues()
{
	VERIFY(UpdateData(TRUE));

	// DLL Type
	switch(m_nDllType)
	{
	case DT_REGSTATIC:
		projOptions.m_bExtdll = FALSE;
		projOptions.m_projOptions &= ~(1 << (IDCD_PODLL-IDCD_POPROJBASE));
		break;
	case DT_REGSHARED:
		projOptions.m_bExtdll = FALSE;
		projOptions.m_projOptions |= (1 << (IDCD_PODLL-IDCD_POPROJBASE));
		break;
	case DT_EXT:
		projOptions.m_bExtdll = TRUE;
		projOptions.m_projOptions |= (1 << (IDCD_PODLL-IDCD_POPROJBASE));
		break;
	}
	SetDllSymbol();

	// automation
	projOptions.m_nOleType = OLE_NO;	
	projOptions.m_bOleAutomation = ((CButton*) GetDlgItem(IDCD_AUTOMATION))->GetCheck();
	SetOleSymbols();
	
	// sockets
	if (((CButton*) GetDlgItem(IDCD_SOCKETS))->GetCheck())
		projOptions.m_options |= (1 << (IDCD_POSOCKETS-IDCD_POBASE));
	else
		projOptions.m_options &= ~(1 << (IDCD_POSOCKETS-IDCD_POBASE));
	SetAppOptionsSymbols();

	// verbose
	if (m_nVerbose == 0)
		projOptions.m_projOptions |= (1 << (IDCD_POVERBOSE-IDCD_POPROJBASE));
	else
		projOptions.m_projOptions &= ~(1 << (IDCD_POVERBOSE-IDCD_POPROJBASE));
	SetProjOptionsSymbols();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\miscdlgs.h ===
// miscdlgs.h : header file
//
#include "datbdlg.h"  // <-- declaration of CMyButton
#include "seqdlg.h"

/////////////////////////////////////////////////////////////////////////////
// CDocAppOptionsDlg dialog

class CDocAppOptionsDlg : public CSeqDlg
{
// Construction
public:
	CDocAppOptionsDlg(CWnd* pParent = NULL);	// standard constructor
	virtual void WriteValues();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual UINT ChooseBitmap();
	virtual UINT ChooseBitmap2();
	virtual BOOL ShowTwoBitmaps() { return TRUE; }
	virtual BOOL CanDestroy();
	
// Dialog Data
	//{{AFX_DATA(CDocAppOptionsDlg)
	enum { IDD = IDD_DOCAPP_OPTIONS };
	UINT	m_nSizeMRU;
	int		m_nMenus;
	//}}AFX_DATA

// Implementation
protected:
	CMyButton m_btnAdvanced;
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	void ReadValues();         // Reads from projectOptions
	void EnablePrint(BOOL bEnable);
	
	// Generated message map functions
	//{{AFX_MSG(CDocAppOptionsDlg)
	virtual BOOL OnInitDialog();
//	afx_msg void OnDocStrings();
//	afx_msg void OnFrameStyles();
	afx_msg void OnAdvanced();
	afx_msg BOOL OnClickedCheckbox(UINT nID);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CDlgAppOptionsDlg dialog

class CDlgAppOptionsDlg : public CSeqDlg
{
// Construction
public:
	CDlgAppOptionsDlg(CWnd* pParent = NULL);	// standard constructor
	virtual void WriteValues();
    virtual BOOL CanDestroy();
	virtual UINT ChooseBitmap();
	virtual UINT ChooseBitmap2();
	virtual BOOL ShowTwoBitmaps() { return TRUE; }

// Dialog Data
	//{{AFX_DATA(CDlgAppOptionsDlg)
	enum { IDD = IDD_DLGAPP_OPTIONS };
	BOOL	m_bOleAutomation;
	BOOL	m_bOcx;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	void ReadValues();         // Reads from projectOptions
	void GetTitle(CString& strTitle);
	afx_msg BOOL OnClickedCheckbox(UINT nID);
	void EnableVarious(BOOL bEnableWOSA, BOOL bEnableOCX);
	
	// Generated message map functions
	//{{AFX_MSG(CDlgAppOptionsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CProjOptionsDlg dialog

class CProjOptionsDlg : public CSeqDlg
{
// Construction
public:
	CProjOptionsDlg(UINT nID, CWnd* pParent);
	CProjOptionsDlg(CWnd* pParent = NULL);	// standard constructor
	virtual void WriteValues();
	virtual UINT ChooseBitmap();
	virtual BOOL CanDestroy();
	
// Dialog Data
	//{{AFX_DATA(CProjOptionsDlg)
	enum { IDD = IDD_PROJ_OPTIONS };
	int		m_nAtlSupport;
	int		m_nProjStyle;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual void ReadValues();         // Reads from projectOptions

	// Generated message map functions
	//{{AFX_MSG(CProjOptionsDlg)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnClickedRadio(UINT nID);		
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CDllProjOptionsDlg dialog

// This enum order must match tab order of DLL Type buttons
enum {DT_REGSTATIC, DT_REGSHARED, DT_EXT};

class CDllProjOptionsDlg : public CProjOptionsDlg
{
// Construction
public:
	CDllProjOptionsDlg(CWnd* pParent = NULL);   // standard constructor
	virtual void WriteValues();

// Dialog Data
	//{{AFX_DATA(CDllProjOptionsDlg)
	enum { IDD = IDD_DLLPROJ_OPTIONS };
	int		m_nDllType;
	int		m_nVerbose;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDllProjOptionsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//void EnableUsrdllOptions(BOOL bEnable);
	virtual void ReadValues();         // Reads from projectOptions
	void EnableSockets(BOOL bEnable);
	
	// Generated message map functions
	//{{AFX_MSG(CDllProjOptionsDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\oledlg.cpp ===
// oledlg.cpp : implementation file
//

#include "stdafx.h"
#include "mfcappwz.h"
#include "symbols.h"
#include "oleutil.h"
#include "oledlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COleDlg dialog

COleDlg::COleDlg(CWnd* pParent /*=NULL*/)
	: CSeqDlg(COleDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(COleDlg)
	m_bActiveDocServer = FALSE;
	m_nOleType = -1;
	m_nCompFile = -1;
	m_bAutomation = FALSE;
	m_bOcx = TRUE;
	m_bActiveDocContainer = FALSE;
	//}}AFX_DATA_INIT
	m_nLastCompFile = 1;

	// If the ActiveX doc checkbox is disabled and becomes enabled
	// later, its default is TRUE.
	//--------------REVIEW!!!
	// Changed to FALSE in order to not break the sniffs until the MFC docobj
	// support is actually in a drop.
	// Once MFC supports docobjs in 4.2, change back to TRUE and delete this comment.
	m_bActiveDocServerSave = FALSE;
	m_bActiveDocContainerSave = FALSE;
}

void COleDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COleDlg)
	DDX_Control(pDX, IDC_XDOCCONTAINER, m_btnActiveDocContainer);
	DDX_Control(pDX, IDCD_DOCOBJ, m_btnActiveDocServer);
	DDX_Check(pDX, IDCD_DOCOBJ, m_bActiveDocServer);
	DDX_Radio(pDX, IDC_NO_INPLACE, m_nOleType);
	DDX_Radio(pDX, IDC_COMPFILE_RADIO, m_nCompFile);
	DDX_Check(pDX, IDCD_AUTOMATION, m_bAutomation);
	DDX_Check(pDX, IDCD_OCX, m_bOcx);
	DDX_Check(pDX, IDC_XDOCCONTAINER, m_bActiveDocContainer);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(COleDlg, CSeqDlg)
	//{{AFX_MSG_MAP(COleDlg)
	ON_COMMAND_EX(IDC_NO_INPLACE, OnClickedRadio)
	ON_COMMAND_EX(IDC_CONTAINER, OnClickedRadio)
	ON_COMMAND_EX(IDC_MSERVER, OnClickedRadio)
	ON_COMMAND_EX(IDC_FSERVER, OnClickedRadio)
	ON_COMMAND_EX(IDC_CSERVER, OnClickedRadio)
	ON_BN_CLICKED(IDCD_DOCOBJ, OnClickedDocServer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleDlg message handlers

BOOL COleDlg::OnClickedRadio(UINT nID)
{
	CMainDlg* pMainDlg = (CMainDlg*) GetParent();
	pMainDlg->RedrawBitmap(BMPSIZE_SUM);
	UpdateCompFile();
	UpdateActiveDocServer(FALSE);
	return TRUE;
}

void COleDlg::OnClickedDocServer() 
{
	// don't allow user to 'finish' from here if ActiveX doc server AND no file extension
	GetParent()->GetDlgItem(IDC_END)->EnableWindow(!(m_btnActiveDocServer.GetCheck() && projOptions.m_names.strDocFileExt.IsEmpty()));
}

void COleDlg::UpdateActiveDocServer(BOOL fInitDialog)
{
	BOOL bOleServer = (m_nOleType != OLE_NO && m_nOleType != OLE_CONTAINER);
	BOOL bOleContainer =  (m_nOleType == OLE_CONTAINER || m_nOleType == OLE_CSERVER );
	if (bOleServer && DoesSymbolExist("TARGET_MAC"))
	{
		bOleServer = FALSE;	// with Mac targets, force it to be turned off
		m_bActiveDocServer = FALSE;
	}
	BOOL bActiveDocCEnabled;
	BOOL bActiveDocSEnabled;
	if (fInitDialog)
	{
		// get in a consistent state to begin with
		ASSERT(bOleServer || !m_bActiveDocServer);	// inconsistent initial state
		m_btnActiveDocServer.EnableWindow(bActiveDocSEnabled = bOleServer);
		m_btnActiveDocContainer.EnableWindow(bActiveDocCEnabled = bOleContainer);
		m_btnActiveDocServer.SetCheck(m_bActiveDocServer);
		m_btnActiveDocContainer.SetCheck(m_bActiveDocContainer);
	}
	else
	{
		bActiveDocSEnabled = m_btnActiveDocServer.IsWindowEnabled();
		bActiveDocCEnabled = m_btnActiveDocContainer.IsWindowEnabled();
	}

	if (bOleServer != bActiveDocSEnabled)
	{
		// must change enabledness of "activex doc server" button.
		if (bOleServer)
		{
			m_bActiveDocServer = m_bActiveDocServerSave;
		}
		else
		{
			m_bActiveDocServerSave = m_bActiveDocServer;
			m_bActiveDocServer = FALSE;
		}
		m_btnActiveDocServer.SetCheck(m_bActiveDocServer);
		m_btnActiveDocServer.EnableWindow(bOleServer);
		OnClickedDocServer();	// may need to reset 'Finish' button
	}
	if (bOleContainer != bActiveDocCEnabled)
	{
		// must change enabledness of "activex doc server" button.
		if (bOleContainer)
		{
			m_bActiveDocContainer = m_bActiveDocContainerSave;
		}
		else
		{
			m_bActiveDocContainerSave = m_bActiveDocContainer;
			m_bActiveDocContainer = FALSE;
		}
		m_btnActiveDocContainer.SetCheck(m_bActiveDocContainer);
		m_btnActiveDocContainer.EnableWindow(bOleContainer);
		// OnClickedDocServer();	// may need to reset 'Finish' button
	}
}

static UINT Obmp[] =
{
	IDB_B13NONE, IDB_B131000, IDB_B130100, IDB_B130010, IDB_B130001,
};

UINT COleDlg::ChooseBitmap()
{
	if (((CButton*) GetDlgItem(IDC_NO_INPLACE))->GetCheck())
		return Obmp[0];
	for (int i=0; i <= OLELAST-OLEBASE; i++)
	{
		if (((CButton*) GetDlgItem(OLEBASE+i))->GetCheck())
			break;
	}
	ASSERT (((CButton*) GetDlgItem(OLEBASE+i))->GetCheck());
	return Obmp[i+1];
}

void COleDlg::ReadValues()
{
	GetOleSymbols();
	m_nOleType = projOptions.m_nOleType;
	m_nCompFile = projOptions.m_bOleCompFile ? 1 : 0;
	m_bAutomation = projOptions.m_bOleAutomation;
	m_bOcx = projOptions.m_bOcx;
	m_bActiveDocServer = projOptions.m_bActiveDocServer;
	m_bActiveDocContainer = projOptions.m_bActiveDocContainer;
	UpdateData(FALSE);
}

void COleDlg::WriteValues()
{
	UpdateData(TRUE);
	projOptions.m_nOleType = m_nOleType;
	projOptions.m_bOleCompFile = (m_nCompFile == 1 ? TRUE : FALSE);
	projOptions.m_bOleAutomation = m_bAutomation;
	projOptions.m_bOcx = m_bOcx;
	projOptions.m_bActiveDocServer = m_bActiveDocServer;
	projOptions.m_bActiveDocContainer = m_bActiveDocContainer;
	
	// Record settings in symbol table
	SetOleSymbols();

	if (m_nOleType == OLE_MSERVER)
	{
		// If user selected mini-server, we must become SDI
		SetMDI(FALSE);
	}

}

BOOL COleDlg::CanDestroy()
{
	WriteValues();
	// If user selected a container or container-server, make sure
	//  CEditView isn't selected.
	if ((m_nOleType == OLE_CONTAINER || m_nOleType == OLE_CSERVER)
		&& projOptions.m_names.strBaseClass[classView] == "CEditView")
	{
		int nResult = AfxMessageBox(IDP_EDITVIEW_THEN_OLE, MB_OKCANCEL);
		if (nResult == IDCANCEL)
			return FALSE;
		projOptions.m_names.strBaseClass[classView] = "CView";
		SetBaseViewSymbols();
	}

	// If container/server support enabled, make sure m_bDBSimple is unset
	if (m_nOleType != OLE_NO && projOptions.m_bDBSimple)
	{
		int nResult = AfxMessageBox(IDP_SIMPLE_THEN_OLE, MB_OKCANCEL);
		if (nResult == IDCANCEL)
			return FALSE;
		projOptions.m_bDBSimple = FALSE;
		SetDBSymbols();
	}

	// If container unset, make sure "CRichEditView" is unset
	if (projOptions.m_names.strBaseClass[classView] == "CRichEditView"
		&& m_nOleType != OLE_CONTAINER && m_nOleType != OLE_CSERVER)
	{
		if (AfxMessageBox(IDP_RICHEDIT_THEN_NOOLE, MB_OKCANCEL) == IDCANCEL)
			return FALSE;
		projOptions.m_names.strBaseClass[classView] = "CView";
		SetBaseViewSymbols();
	}
	return TRUE;
}	

BOOL COleDlg::OnInitDialog()
{
	CSeqDlg::OnInitDialog();
	CenterWindow();
	CString tmp;
	if (projOptions.m_bNoDocView == TRUE)
	{
		// Turn off everything for no doc view
		ReadValues();
		//EnableOcx(FALSE);
		UpdateCompFile(FALSE);
		UpdateActiveDocServer(FALSE);
		GetDlgItem(IDC_NO_INPLACE)->EnableWindow(FALSE);
		GetDlgItem(IDC_CONTAINER)->EnableWindow(FALSE);
		GetDlgItem(IDC_MSERVER)->EnableWindow(FALSE);
		GetDlgItem(IDC_FSERVER)->EnableWindow(FALSE);
		GetDlgItem(IDC_CSERVER)->EnableWindow(FALSE);
		GetDlgItem(IDCD_AUTOMATION)->EnableWindow(FALSE);
	}
	else
	{
		GetDlgItem(IDC_NO_INPLACE)->EnableWindow(TRUE);
		GetDlgItem(IDC_CONTAINER)->EnableWindow(TRUE);
		GetDlgItem(IDC_MSERVER)->EnableWindow(TRUE);
		GetDlgItem(IDC_FSERVER)->EnableWindow(TRUE);
		GetDlgItem(IDC_CSERVER)->EnableWindow(TRUE);
		GetDlgItem(IDCD_AUTOMATION)->EnableWindow(TRUE);
		projOptions.m_bOcx = TRUE;
		EnableOcx(TRUE);
		ReadValues();
		UpdateCompFile(TRUE);
		UpdateActiveDocServer(TRUE);
	}

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void COleDlg::UpdateCompFile(BOOL bCalledFromInit /* = FALSE */)
{
	UpdateData(TRUE);	// Get values
	CWnd* pCompFileRadio = GetDlgItem(IDC_COMPFILE_RADIO);
	CWnd* pCompFileRadio2 = GetDlgItem(IDC_COMPFILE_RADIO2);
	if (m_nOleType == OLE_NO && pCompFileRadio->IsWindowEnabled())
	{
		ASSERT (pCompFileRadio2->IsWindowEnabled());

		// No OLE selected.  Disable compound files, but remember its
		//  last setting
		if (!bCalledFromInit)
		{
			m_nLastCompFile = m_nCompFile;
			m_nCompFile = 0;
			UpdateData(FALSE);		// Set compfile to no
		}
		pCompFileRadio->EnableWindow(FALSE);
		pCompFileRadio2->EnableWindow(FALSE);
		GetDlgItem(IDC_STATIC3)->EnableWindow(FALSE);
	}
	else if (m_nOleType != OLE_NO && !pCompFileRadio->IsWindowEnabled())
	{
		ASSERT (!pCompFileRadio2->IsWindowEnabled());

		// OLE is selected, and compfile is currently disabled.  Thus,
		//  re-enable it with the previous setting.
		pCompFileRadio->EnableWindow(TRUE);
		pCompFileRadio2->EnableWindow(TRUE);
		GetDlgItem(IDC_STATIC3)->EnableWindow(TRUE);
		m_nCompFile = m_nLastCompFile;
		UpdateData(FALSE);		// Set compfile to prev. setting
	}
}


void COleDlg::EnableOcx(BOOL bEnable)
{
	GetDlgItem(IDCD_OCX)->EnableWindow(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\oledlg.h ===
// oledlg.h : header file
//

#include "seqdlg.h"

/////////////////////////////////////////////////////////////////////////////
// COleDlg dialog

class COleDlg : public CSeqDlg
{
// Construction
public:
	COleDlg(CWnd* pParent = NULL);	// standard constructor
	virtual void WriteValues();
	virtual UINT ChooseBitmap();

// Dialog Data
	//{{AFX_DATA(COleDlg)
	enum { IDD = IDD_OLE_OPTIONS };
	CButton	m_btnActiveDocContainer;
	CButton	m_btnActiveDocServer;
	BOOL	m_bActiveDocServer;
	int		m_nOleType;
	int		m_nCompFile;
	BOOL	m_bAutomation;
	BOOL	m_bOcx;
	BOOL	m_bActiveDocContainer;
	//}}AFX_DATA

	virtual BOOL CanDestroy();

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	void EnableOcx(BOOL bEnable);
	void ReadValues();

	int m_nLastCompFile;
	BOOL	m_bActiveDocServerSave;	// valid when the btn is disabled
	BOOL	m_bActiveDocContainerSave;	// valid when the btn is disabled
	void UpdateActiveDocServer(BOOL fInitDialog);
	void UpdateCompFile(BOOL bCalledFromInit = FALSE);

	// Generated message map functions
	//{{AFX_MSG(COleDlg)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnClickedRadio(UINT nID);	
	afx_msg void OnClickedDocServer();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\oleutil.h ===
// oledlgs.h : header file
//

#ifndef _OLEUTIL_H
#define _OLEUTIL_H

#include <objbase.h>
#include <scode.h>


/////////////////////////////////////////////////////////////////////////////
// Helpers for OLE dynamic load

// This struct contains the OLE entry points that we use in ClassWizard
// These are filled in dynamically at runtime if the DLLs happen to exist
//	on the system.
/* struct OleEntryPoints
{
	// from OLE2.DLL
	HRESULT (FAR STDAPICALLTYPE EXPORT* lpOleInitialize)(IMalloc FAR*);
	void (FAR STDAPICALLTYPE EXPORT* lpOleUninitialize)();
	HRESULT (FAR STDAPICALLTYPE EXPORT* lpCoCreateGuid)(GUID FAR*);
	HRESULT (FAR STDAPICALLTYPE EXPORT* lpCLSIDFromString)(LPSTR lpsz, LPCLSID pclsid);	
};

extern OleEntryPoints NEAR oleEntryPoints;
void PASCAL LoadOleEntryPoints(BOOL bNeedTypeLib);	
	// loads above global (call at init time)
	
void PASCAL UnloadOleEntryPoints();	// unloads above global (call at term time)

BOOL PASCAL IsOleLoaded();	// checks for non-typelib entry points
BOOL PASCAL CheckOleVersion();

BOOL PASCAL IsOleInstalled();
*/
BOOL PASCAL GetValidGuid(GUID FAR& guid);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\oleutil.cpp ===
// oleutil.cpp : implementation file
//

#include "stdafx.h"
#include "oleutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define MAX_LINE 1024      			// Never used; came from class wizard

/* OleEntryPoints NEAR oleEntryPoints;	// will be initialized to NULL

HINSTANCE hOle2, hMFCAnsi;

BOOL bOleInitWorked = FALSE;
BOOL bOleVersionOK = FALSE;

static char BASED_CODE szOle2[] = "OLE32.DLL";
static char BASED_CODE szMFCAnsi[] = "MFCANS32.DLL";

BOOL PASCAL IsOleInstalled()
{
	OFSTRUCT ofs;
	return OpenFile(szOle2, &ofs, OF_EXIST) != HFILE_ERROR
		&& OpenFile(szMFCAnsi, &ofs, OF_EXIST) != HFILE_ERROR;
}

BOOL PASCAL CheckOleVersion()
{
#ifndef BOGUSGUID
	ASSERT(IsOleInstalled());
#endif //BOGUSGUID
	
	// if we haven't tried initialize OLE then do it here	
	if (IsOleInstalled())
		LoadOleEntryPoints(FALSE);
		
	return bOleVersionOK;
}

void PASCAL LoadOleEntryPoints(BOOL bNeedTypeInfo)
{
	// attempt to load all the OLE entry points
	//	(note: load by name, since the ordinals aren't guaranteed to stay fixed)
	UINT uErrorMode = ::SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);
	if (hOle2 == NULL)
	{	
		hOle2 = LoadLibrary(szOle2);
		if (hOle2 != NULL)
		{
			(FARPROC&)oleEntryPoints.lpCoCreateGuid = 
				GetProcAddress(hOle2, "CoCreateGuid");
			(FARPROC&)oleEntryPoints.lpOleInitialize = 
				GetProcAddress(hOle2, "OleInitialize");
			(FARPROC&)oleEntryPoints.lpOleUninitialize = 
				GetProcAddress(hOle2, "OleUninitialize");
		}
	}
	if (hMFCAnsi == NULL)
	{
		hMFCAnsi = LoadLibrary(szMFCAnsi);
		if (hMFCAnsi != NULL)
		{
			(FARPROC&)oleEntryPoints.lpCLSIDFromString =
				GetProcAddress(hMFCAnsi, "CLSIDFromString");			
		}

	}	
	::SetErrorMode(uErrorMode);

	if (oleEntryPoints.lpCoCreateGuid 		!= NULL
		&& oleEntryPoints.lpCLSIDFromString != NULL
		&& oleEntryPoints.lpOleInitialize 	!= NULL
		&& oleEntryPoints.lpOleUninitialize != NULL)
	{
		bOleVersionOK = TRUE;
	}
	else
		bOleVersionOK = FALSE;

	if (!IsOleLoaded())
	{
		// otherwise don't need them if don't have all of them
		UnloadOleEntryPoints();
		return;
	}	
		
	// initialize OLE since it was successfully loaded
	if (!bOleInitWorked)
	{
		ASSERT(oleEntryPoints.lpOleInitialize != NULL);
		if (!FAILED(GetScode(oleEntryPoints.lpOleInitialize(NULL))))
			bOleInitWorked = TRUE;
	}		
}

void PASCAL UnloadOleEntryPoints()
{
	// uninitialize OLE
	if (bOleInitWorked)
	{
		ASSERT(oleEntryPoints.lpOleUninitialize != NULL);
		oleEntryPoints.lpOleUninitialize();
		bOleInitWorked = FALSE;
	}

	if (hOle2 != NULL)
	{
		FreeLibrary(hOle2);
		hOle2 = NULL;
	}
	if (hMFCAnsi != NULL)
	{
		FreeLibrary(hMFCAnsi);
		hMFCAnsi = NULL;
	}

	// entry points are now invalid -- so NULL them out
	memset(&oleEntryPoints, 0, sizeof oleEntryPoints);
}

BOOL PASCAL IsOleLoaded()
{
	// return TRUE if non-typelib entry points available
	return oleEntryPoints.lpCoCreateGuid 	!= NULL
		&& oleEntryPoints.lpCLSIDFromString != NULL
		&& oleEntryPoints.lpOleInitialize 	!= NULL
		&& oleEntryPoints.lpOleUninitialize != NULL;
}

*/

#ifdef BOGUSGUID
void GetGuidFromList(GUID FAR& guid, UINT nGuid)
{
	// Create guid from range given to us.

	// nGuid ranges from 1 to 0x100, to reserve 0 for when .ini entry
	//  for next guid isn't an int.  Thus, we subtract 1 fron nGuid
	
	guid.Data1=0x00027800 + (nGuid-1);
	guid.Data2=0;
	guid.Data3=0;
	guid.Data4[0]=0xC0;
	guid.Data4[1]=0;
	guid.Data4[2]=0;
	guid.Data4[3]=0;
	guid.Data4[4]=0;
	guid.Data4[5]=0;
	guid.Data4[6]=0;
	guid.Data4[7]=0x46;
}
#endif //BOGUSGUID

BOOL PASCAL GetValidGuid(GUID FAR& guid)
{
	//LoadOleEntryPoints(FALSE);

	// start by filling the GUID with 0
	memset((void*) &guid, 0, sizeof(GUID));
	
	// Retain a zeroed guid to compare to later
	GUID zero;
	memset((void*) &zero, 0, sizeof(GUID));

/*	if (IsOleLoaded())
	{
	*/
		// then call OLE api to get a random GUID
		// Deliberately ignore CoCreateGuid's return value.  It calls UuidCreate
		//  which can sometimes succeed but return a success-value unrecognized
		//  by CoCreateGuid-- in this case CoCreateGuid will fail, even
		//  though we've just gotten a perfectly valid guid.
		// Instead, we'll just see if guid is still zeroed out-- THAT will
		//  indicate whether we should fail.
		CoCreateGuid(&guid);
		if (!memcmp((void*) &guid, (void*) &zero, sizeof(GUID)))
			return FALSE;		// The new guid is still zeroed-- no guid created
		else
			return TRUE;		// The guid has changed-- we're ok
/*	}
	else
#ifndef BOGUSGUID	
		return FALSE;
#else
	{
		// The code below generated guids from a range of 256, w/out using OLE
		#define GUID_MAX 0x100
		CWinApp* pApp = AfxGetApp();
		UINT nGuid = pApp->GetProfileInt("guid generation", "next guid", GUID_MAX + 1);
		if (nGuid == GUID_MAX + 1 || nGuid == 0)
		{
			// If entry not found or cycled past end...
			pApp->WriteProfileInt("guid generation", "next guid", 2);
			nGuid = 1;
		}
		else
			pApp->WriteProfileInt("guid generation", "next guid", nGuid+1);
		GetGuidFromList(guid, nGuid);
		return TRUE;
	}
#endif //BOGUSGUID*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\platname.h ===
class CPlatNameConvert
{
public:
	void Init();
	void UItoLong(const CString& strUI, CString& strLong);
	void LongToUI(const CString& strLong, CString& strUI);

protected:
	CMapStringToString m_NameMap;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\platname.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "platname.h"

#ifndef VS_PACKAGE
#include <bldapi.h>
#include <bldguid.h>
#endif	// VS_PACKAGE

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void CPlatNameConvert::Init()
{
#ifndef VS_PACKAGE
	m_NameMap.RemoveAll();
	LPBUILDPLATFORMS pPlatforms;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildPlatforms, (LPVOID FAR *)&pPlatforms)));
	const CStringList* pPlatformsUI;
	pPlatforms->GetAvailablePlatforms(&pPlatformsUI, NULL, TRUE);
	const CStringList* pPlatformsLong;
	pPlatforms->GetAvailablePlatforms(&pPlatformsLong, NULL, FALSE);

	POSITION posUI = pPlatformsUI->GetHeadPosition();
	POSITION posLong = pPlatformsLong->GetHeadPosition();
	while (posUI != NULL && posLong != NULL)
	{
		m_NameMap[pPlatformsUI->GetNext(posUI)]
			= pPlatformsLong->GetNext(posLong);
	}
	pPlatforms->Release();
#endif	// VS_PACKAGE
}

// Looks the UI name up in the map.  If a long name is assigned to  it, it's
//  returned in strLong; otherwise, strUI is returned in strLong.
void CPlatNameConvert::UItoLong(const CString& strUI, CString& strLong)
{
	if (!m_NameMap.Lookup(strUI, strLong))
		strLong = strUI;
}
	
// Here, we do a linear search for values that match Long, and return the
//  corresponding key in strUI; if not there, just return strLong in strUI.
//  We choose a linear search rather than keeping two maps simply because
//  this map is typically only going to have 2 or 3 elements in it.  In most
//  cases, just 1 (if the user doesn't have an add-on).
void CPlatNameConvert::LongToUI(const CString& strLong, CString& strUI)
{
	POSITION pos = m_NameMap.GetStartPosition();
	while (pos != NULL)
	{
		CString strValue;
		m_NameMap.GetNextAssoc(pos, strUI, strValue);
		if (strValue == strLong)
		{
			// We've found a match, and the value is already in strUI
			return;
		}
	}

	// If we got to this point, there is no match, so just set strUI to strLong.
	strUI = strLong;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\pagedlg.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "customaw.h"		// Has declaration of CAppWizStepDlg
#include "codegen.h"		// For ReportErrorExt
#ifndef VS_PACKAGE
#include <dlgbase.h>
#endif	// VS_PACKAGE

// This flag is used to sense whether AppWizard-proper or an extension is
//  calling the CAppWizStepDlg constructor or destructor.  The extension
//  may not call the constructor with 0, and may NEVER call the destructor.
static BOOL s_bAppWizCallingStructor;
void AppWizCallingStructor(BOOL bAppWizCallingStructor)
{
	s_bAppWizCallingStructor = bAppWizCallingStructor;
}

/////////////////////////////////////////////////////////////////////////////
// pagedlg.cpp -- Implementation of CAppWizStepDlg

BOOL IsaMainBtn(char c);		// Defined in mfcappwz.cpp

//////////////////////////////////////////////////////////////////////////////
// CAppWizStepDlg dialog class

CAppWizStepDlg::CAppWizStepDlg(UINT nIDTemplate)
	: CDialog()
{
	// Before constructing, make sure extension isn't calling us with 0
	if (nIDTemplate == 0				// We're being called with 0
		&& !s_bAppWizCallingStructor)		// And AppWizard isn't doing it
	{
		ReportErrorExt(IDP_AWX_CALLED_BAD_CONSTRUCTOR);
	}
	m_pParentWnd = (CWnd*) theDLL.m_pMainDlg;
	m_lpszTemplateName = MAKEINTRESOURCE(nIDTemplate);
	m_nIDTemplate = nIDTemplate;
	m_nIDHelp = nIDTemplate;
}

CAppWizStepDlg::~CAppWizStepDlg()
{
	// Before destructing, make sure extension isn't trying to delete
	//  a seqdlg key
	if (m_nIDTemplate == 0				// It's a seqdlg key
		&& !s_bAppWizCallingStructor)	// And AppWizard isn't doing it
	{
		ReportErrorExt(IDP_AWX_CALLED_BAD_DESCRUCTOR);
		theDLL.m_pMainDlg->UserDeletedStandardStep(this);
	}
}

BOOL CAppWizStepDlg::Create(UINT nIDTemplate, CWnd* pParentWnd /* = NULL */)
{
	LPCTSTR lpszTemplateName = MAKEINTRESOURCE(nIDTemplate);
	C3dDialogTemplate dt;

	if (dt.Load(lpszTemplateName))
	{
		SetStdFont(dt);
	}
	
	return CDialog::CreateIndirect(dt.GetTemplate(), pParentWnd);
}

BOOL CAppWizStepDlg::OnDismiss()
{
	return TRUE;
}

BOOL CAppWizStepDlg::PreTranslateMessage(MSG* pMsg)
{
    // CSeqDlg shouldn't be sent a close command.
/*    if (pMsg->message == WM_SYSCOMMAND && pMsg->wParam == SC_CLOSE)
        return TRUE;

	// Escape should close the main dialog.
	else if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE)
    {
		// Explicitly set focus to button to avoid IME problem.
		((CDialog*) m_pParentWnd)->GetDlgItem(IDCANCEL)->SetFocus();
		m_pParentWnd->SendMessage(WM_COMMAND,
			MAKEWPARAM(IDCANCEL, BN_CLICKED),
            (LPARAM) (m_pParentWnd->GetDlgItem(IDCANCEL)->m_hWnd));
        return TRUE;
	}

	// Return should go to next dialog, since focus is in CSeqDlg, and thus
	//  IDOK is the default button.
	else if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN)
    {
		// First, make sure that the control active doesn't want the return
		CWnd* pWnd = CWnd::GetFocus();
		if (pWnd != NULL)
		{
			// Someone has focus.  Is it an edit control?
			HWND hwnd = pWnd->GetSafeHwnd();
			ASSERT (hwnd != NULL);
			char szClassName[256];
			::GetClassName(hwnd, szClassName, 256);
			if (_tcscmp(szClassName, "EDIT"))
			{
				// It's an edit control-- does it want return?
				if (pWnd->GetStyle() & 0x1000L)
					// Yes, it does, so give it the return.
					return CDialog::PreTranslateMessage(pMsg);
			}
		}

		// Don't have to worry about giving the return to a control, so
		//  advance as if Next were hit.
        DWORD nID = ((CDialog*) m_pParentWnd)->GetDefID();
        if (nID == 0) nID = IDOK;
        nID &= 0x0000FFFF;
		// Explicitly set focus to button to avoid IME problem.
		((CDialog*) m_pParentWnd)->GetDlgItem(nID)->SetFocus();
        m_pParentWnd->SendMessage(WM_COMMAND,
            MAKEWPARAM(nID, BN_CLICKED),
            (LPARAM) (m_pParentWnd->GetDlgItem(nID)->m_hWnd));
        return TRUE;
    }
	
	// Handle tabbing back into the tab area when tabbing away from
    // either end of the subject's tab order
	else if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB &&
        (SendMessage(WM_GETDLGCODE) & (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
    {
        CWnd* pCtl = GetFocus();
        if (IsChild(pCtl))
        {
            do
            {
                int nKeyState = GetKeyState(VK_SHIFT);
                pCtl = pCtl->GetWindow(nKeyState < 0 ? GW_HWNDPREV : GW_HWNDNEXT);

                if (pCtl == NULL)
                {
                    if (nKeyState < 0)
                    {
                        // Shift-tabbing, so highlight last button
                        if (((CMainDlg*) m_pParentWnd)->m_nCurrIndex
                            == ((CMainDlg*) m_pParentWnd)->m_nCurrLastIndex)
                        {
                            // On last dialog, so highlight Create button
                            m_pParentWnd->GetDlgItem(IDOK)->SetFocus();
                        }
                        else
                        {
                            // On non-last dialog, so highlight rightmost button
							int nRightmostBtn = ((CMainDlg*) m_pParentWnd)->m_nRightmostBtn;
                            m_pParentWnd->GetDlgItem(nRightmostBtn)->SetFocus();
							((CDialog*) m_pParentWnd)->SetDefID(nRightmostBtn);
							if (nRightmostBtn != IDOK)
								((CButton*) (m_pParentWnd->GetDlgItem(IDOK)))
									->SetButtonStyle(BS_PUSHBUTTON);
                        }
                    }
                    else
                    {
                        // Regular-tabbing, so highlight HELP
                        m_pParentWnd->GetDlgItem(ID_HELP)->SetFocus();
						((CDialog*) m_pParentWnd)->SetDefID(ID_HELP);
						((CButton*) (m_pParentWnd->GetDlgItem(IDOK)))
							->SetButtonStyle(BS_PUSHBUTTON);
                    }
                    return TRUE;
                }
            }
            while ((pCtl->GetStyle() & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
        }
	}

	else if (pMsg->message == WM_SYSCHAR || pMsg->message == WM_CHAR)
	{
		// If user tried kbd equivalent for CMainDlg's buttons, pass the
		//  the message to CMainDlg.
		if (IsaMainBtn((char) pMsg->wParam))
		{
			CDialog* dlg = (CDialog*) m_pParentWnd;
			if (pMsg->message == WM_CHAR)
			{
				// We only pass the message to CMainDlg if a button
				//  currently has the focus.
				HWND hwnd = ::GetFocus();
				char szClassName[256];
				::GetClassName(hwnd, szClassName, 256);
				if (strcmp(szClassName, "Button"))
				{
					// Not a button, so do the default.
					return CDialog::PreTranslateMessage(pMsg);
				}
			}
			pMsg->hwnd = dlg->GetDlgItem(IDOK)->GetSafeHwnd();
			// ::SetFocus(pMsg->hwnd);
			dlg->GetDlgItem(IDC_BOGUS_DEFBTN)->SetFocus();
			return dlg->IsDialogMessage(pMsg);
		}	
				

		else
			return CDialog::PreTranslateMessage(pMsg);
	}*/


	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN)
    {
		// First, make sure that the control active doesn't want the return
		CWnd* pWnd = CWnd::GetFocus();
		if (pWnd != NULL)
		{
			// Someone has focus.  Is it an edit control?
			HWND hwnd = pWnd->GetSafeHwnd();
			ASSERT (hwnd != NULL);
			char szClassName[256];
			::GetClassName(hwnd, szClassName, 256);
			if (!_tcsicmp(szClassName, "EDIT"))
			{
				// It's an edit control-- does it want return?
				if (pWnd->GetStyle() & 0x1000L)
					// Yes, it does, so give it the return.
					return CDialog::PreTranslateMessage(pMsg);
			}
			else if (!_tcsicmp(szClassName, "BUTTON"))
			{
				DWORD dwBtnStyles = pWnd->GetStyle() & 0x0000000F;
				if ((dwBtnStyles == BS_PUSHBUTTON) || (dwBtnStyles == BS_DEFPUSHBUTTON))
				{
					int nID = pWnd->GetDlgCtrlID();
					SendMessage(WM_COMMAND,
						MAKEWPARAM(nID, BN_CLICKED),
						(LPARAM) (hwnd));
						return TRUE;
				}
			}
		}
    }
	// Escape should close the main dialog.
	else if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE)
    {
		// Explicitly set focus to button to avoid IME problem.
		((CDialog*) m_pParentWnd)->GetDlgItem(IDCANCEL)->SetFocus();
		m_pParentWnd->SendMessage(WM_COMMAND,
			MAKEWPARAM(IDCANCEL, BN_CLICKED),
            (LPARAM) (m_pParentWnd->GetDlgItem(IDCANCEL)->m_hWnd));
        return TRUE;
	}


	CDialog* dlg = (CDialog*) m_pParentWnd;
	if (dlg->IsDialogMessage(pMsg))
		return TRUE;

    return CDialog::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\projtype.cpp ===
// projtype.cpp : implementation file
//

#include "stdafx.h"
#include <ver.h>
#include "mfcappwz.h"
#include "projtype.h"
#include "lang.h"
#include "symbols.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CProjDlg dialog

CProjDlg::CProjDlg(CWnd* pParent /*=NULL*/)
    : CSeqDlg(CProjDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CProjDlg)
    m_nPTRadio = -1;
	m_bDocView = TRUE;
	//}}AFX_DATA_INIT
}

void CProjDlg::DoDataExchange(CDataExchange* pDX)
{
    CSeqDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProjDlg)
    DDX_Radio(pDX, IDC_PTRADIO, m_nPTRadio);
	DDX_Check(pDX, IDC_DOCVIEW, m_bDocView);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CProjDlg, CSeqDlg)
    //{{AFX_MSG_MAP(CProjDlg)
	ON_COMMAND_EX(IDC_PTRADIO, OnClickedRadio)
    ON_WM_DESTROY()
	ON_COMMAND_EX(IDC_PTMDI, OnClickedRadio)
	ON_COMMAND_EX(IDC_PTDLG, OnClickedRadio)
	ON_COMMAND_EX(IDC_DOCVIEW, OnClickedRadio)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProjDlg message handlers



BOOL CProjDlg::OnInitDialog()
{
    CSeqDlg::OnInitDialog();
    CenterWindow();
	// LATER: when multiple langs are allowed, uncomment
	//VERIFY(m_chklstLang.SubclassDlgItem(IDC_RSC_LANG, this));

    ReadValues();
	
	/*if (m_chklstLang.GetCount() == 1)
	{
		// If there's only one item, check it & disable the listbox
		m_chklstLang.SetItemData(0, 1);
		m_chklstLang.EnableWindow(FALSE);
	}*/

	if( projOptions.m_nProjType !=  PROJTYPE_DLG )
		GetDlgItem(IDC_DOCVIEW)->EnableWindow(TRUE);
	else
		GetDlgItem(IDC_DOCVIEW)->EnableWindow(FALSE);
    
	// this is for the Forms AppWizard. A lot simpler to do if we put the code here. bobz 6/6/97
	CString strExplanation;
	GetSymbol("EXPLAIN_PROJTYPE", strExplanation);

	if (!strExplanation.IsEmpty())
	{
		// move controls to make room for explanation
		CRect crect;
		CSize csize;
		CWnd *pwnd1;
		CWnd *pwnd2;

		pwnd1 = GetDlgItem(IDC_LBL_LANG);
		ASSERT(pwnd1);
		pwnd1->GetWindowRect(&crect);
		csize = crect.Size();
		pwnd2 = GetDlgItem(IDC_MOVE_LBL_LANG);
		ASSERT(pwnd2);
		pwnd2->GetWindowRect(&crect);
		ScreenToClient(&crect); //top and left ok, reset size
		crect.SetRect(crect.left, crect.top, 
			crect.left + csize.cx, crect.top + csize.cy);
		pwnd1->MoveWindow(&crect);

		pwnd1 = GetDlgItem(IDC_RSC_LANG);
		ASSERT(pwnd1);
		pwnd1->GetWindowRect(&crect);
		csize = crect.Size();
		pwnd2 = GetDlgItem(IDC_MOVE_RSC_LANG);
		ASSERT(pwnd2);
		pwnd2->GetWindowRect(&crect);
		ScreenToClient(&crect); //top and left ok, reset size
		crect.SetRect(crect.left, crect.top, 
			crect.left + csize.cx, crect.top + csize.cy);
		pwnd1->MoveWindow(&crect);

		// now fill explain window text
		pwnd1 = GetDlgItem(IDC_EXPLAIN);
		ASSERT(pwnd1);
		pwnd1->SetWindowText(strExplanation);
		pwnd1->ShowWindow(SW_SHOWNOACTIVATE);	
	}


    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CProjDlg::WriteProjType()
{
	projOptions.m_nProjType = m_nPTRadio;
	projOptions.m_bNoDocView = !m_bDocView;
	if(!m_bDocView)
	{
		// No Doc View architecture support means no printing
		projOptions.m_options &= ~(1 << (IDCD_POPRINT-IDCD_POBASE) );
		projOptions.m_nOleType = OLE_NO;
		projOptions.m_bOleAutomation = FALSE;
		projOptions.m_bSplitter = FALSE;
    	projOptions.m_nProjStyle = PS_MFCNORMAL;       // Explorer or Normal.
		projOptions.m_bDBSimple = FALSE;
		projOptions.m_bDBHeader = FALSE;
		projOptions.m_options &= ~(1 << IDCD_POMAPI-IDCD_POBASE);
		projOptions.m_options &= ~(1 << IDCD_POSOCKETS-IDCD_POBASE);

		RemoveSymbol("MAPI");
		RemoveSymbol("SOCKETS");

		RemoveSymbol("DB_COLSINFO");
		RemoveSymbol("DB_VARSINFO");
		RemoveSymbol("DB_SOURCE");
		RemoveSymbol("DB_DSN");

		SetProjOptionsSymbols();
		SetSplitterSymbols();
		SetDBSymbols();
		SetOleSymbols();
	}
}

BOOL CProjDlg::OnClickedRadio(UINT nID)
{
    UpdateData(TRUE);
	WriteProjType();

	if( projOptions.m_nProjType !=  PROJTYPE_DLG )
		GetDlgItem(IDC_DOCVIEW)->EnableWindow(TRUE);
	else
		GetDlgItem(IDC_DOCVIEW)->EnableWindow(FALSE);

	CMainDlg* pMainDlg = (CMainDlg*) GetParent();
	pMainDlg->RedrawBitmap(BMPSIZE_SUM);
	return TRUE;
}

static UINT Pbmp[] =
{
	IDB_B11100, IDB_B11010, IDB_B11001, IDB_B110001,
};

UINT CProjDlg::ChooseBitmap()
{
	for (int i=0; i < 4; i++)
	{
		if (((CButton*) GetDlgItem(IDC_PTRADIO+i))->GetCheck())
			break;
	}
	ASSERT (((CButton*) GetDlgItem(IDC_PTRADIO+i))->GetCheck());
	return Pbmp[i];
}

void CProjDlg::OnDestroy()
{
    WriteValues();
    CSeqDlg::OnDestroy();
}

BOOL CProjDlg::CanDestroy()
{
    WriteValues();

	if (!langDlls.LoadLibs())
		return FALSE;

	if (!langDlls.LoadLangSpecificDefaults())
		return FALSE;

    // If MDI selected, make sure m_bDBSimple is unset & we're not a mini-server.
    if (projOptions.m_nProjType == PROJTYPE_MDI)
    {
        if (projOptions.m_bDBSimple)
        {
            int nResult = AfxMessageBox(IDP_SIMPLE_THEN_MDI, MB_OKCANCEL);
            if (nResult == IDCANCEL)
                return FALSE;
            
            projOptions.m_bDBSimple = FALSE;
			SetDBSymbols();
        }

        // If we were a mini-server, must now become a full-server
        if (projOptions.m_nOleType == OLE_MSERVER)
        {
            int nResult = AfxMessageBox(IDP_MSERVER_THEN_MDI, MB_OKCANCEL);
            if (nResult == IDCANCEL)
                return FALSE;
            
            projOptions.m_nOleType = OLE_FSERVER;
			SetOleSymbols();
        }
    }

	return TRUE;
}

    

void CProjDlg::WriteValues()
{
    UpdateData(TRUE);
	projOptions.m_nProjType = m_nPTRadio;
	projOptions.m_bNoDocView = !m_bDocView;
	WriteProjType();
	SetProjectTypeSymbol();

    // If we're now dlg-based, unset some symbols
    if (projOptions.m_nProjType == PROJTYPE_DLG)
    {
        ResetOleSymbols();
        RemoveSymbol("CRecordView");
		RemoveSymbol("DB");

		// Set the default to OLE control hosting ... the user gets to change
		// it in later dialogs, if desired.
		projOptions.m_bOcx = TRUE;
		SetSymbol("OLECTL", "1");
    }
    else
    {
        // Otherwise, set the ole symbols again.
        SetOleSymbols();
        if (projOptions.m_names.strBaseClass[classView] == "CRecordView")
            SetSymbol("CRecordView", "1");
    }
	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_RSC_LANG);
	langDlls.WriteLangDlls(pCombo);
	SetLanguageSymbols();
}

void CProjDlg::ReadValues()
{
	GetProjectTypeSymbol();
	GetLanguageSymbols();
    m_nPTRadio = projOptions.m_nProjType;
    m_bDocView = !projOptions.m_bNoDocView;
    UpdateData(FALSE);

	// Initialize language dll check list
	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_RSC_LANG);
	if (!langDlls.m_AvailableLangDlls.InitLangDllList(pCombo))
	{
		PostMessage(WM_GOTO_BEGINNING, 0, 0);
		return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\symbols.h ===
/////////////////////////////////////////////////////////////////////////////
// Project Type / Language options

void SetProjectTypeSymbol();
void GetProjectTypeSymbol();
void SetLanguageSymbols();
void GetLanguageSymbols();

/////////////////////////////////////////////////////////////////////////////
// Database options

void SetDBSymbols();
void GetDBSymbols();

/////////////////////////////////////////////////////////////////////////////
// OLE options

void ResetOleSymbols();
void SetOleSymbols();
void GetOleSymbols();

/////////////////////////////////////////////////////////////////////////////
// Application options

void SetAppOptionsSymbols();
void GetAppOptionsSymbols();
void SetSizeMRUSymbols(UINT nSizeMRU);
void GetSizeMRUSymbols();
void SetDocumentSymbols();
void GetDocumentSymbols();
void SetFrameSymbols();
void GetFrameSymbols();
void SetSplitterSymbols();
void GetSplitterSymbols();
void SetChildFrameSymbols();
void GetChildFrameSymbols();
void GetMenuSymbols();
void SetMenuSymbols();

/////////////////////////////////////////////////////////////////////////////
// Project options

void SetProjOptionsSymbols();
void GetProjOptionsSymbols();
void SetDllSymbol();
void GetDllSymbol();

/////////////////////////////////////////////////////////////////////////////
// Classes dialog names

void SetClassesSymbols();
void GetClassesSymbols();
void SetBaseViewSymbols();

/////////////////////////////////////////////////////////////////////////////
// Set miscellaneous symbols

void SetMFCPathSymbol();
void SetYearSymbol();
void RemoveInapplicableSymbols();


/////////////////////////////////////////////////////////////////////////////
// Dictionary lookup functions

void GetSymbol(const TCHAR* tszKey, CString& rStrValue);
void SetSymbol(const TCHAR* tszKey, const TCHAR* tszValue);
CString& CreateSymbol(const TCHAR* tszKey);
BOOL DoesSymbolExist(const TCHAR* tszKey);
void RemoveSymbol(const TCHAR* tszKey);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\stdafx.h ===
#include <afxwin.h>
#ifdef VS_PACKAGE
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#pragma warning(disable:4100) // 'unreferenced formal parameter'

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#endif	// VS_PACKAGE

#if !defined(_AFX_NO_OLE_SUPPORT)
#include <afxole.h>
#endif
#include <afxdlgs.h>
#include <afxext.h>
//#include <ctype.h>
#include <stdlib.h>
#include <afxtempl.h>
#include <afxpriv.h>   // To get main.h to compile

#if !defined(_AFX_NO_DB_SUPPORT)
#include <afxdb.h>
#endif

#include <afxcmn.h>		// Spin control
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\seqdlg.h ===
// seqdlg.h - header for inner sequential dialogs of AppWizard
//

#ifndef SEQDLG_H
#define SEQDLG_H

class CSeqDlg : public C3dDialog
{
// Construction
public:
    CSeqDlg (UINT IDD, CWnd* pParent = NULL);
    virtual BOOL Create(UINT nIDTemplate, CWnd* pParentWnd);
    virtual BOOL CanDestroy() { return TRUE; }
	virtual BOOL ShouldShowPicture() { return TRUE; }
	virtual BOOL ShowTwoBitmaps() { return FALSE; }
	virtual void WriteValues() = 0;
	virtual int GetBitmapSizeIndex() { return BMPSIZE_STANDARD; }
	virtual UINT ChooseBitmap() { return 0; }
	virtual UINT ChooseBitmap2() { return 0; }
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	UINT m_nTemplate;
    
protected:
    //{{AFX_MSG(CSeqDlg)
    //}}AFX_MSG(CSeqDlg)
    afx_msg LRESULT OnGotoBeginning(WPARAM wparam, LPARAM lparam);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt);
	afx_msg BOOL OnHelpInfo(HELPINFO *pHelpInfo);
    virtual BOOL OnCommand( WPARAM wParam, LPARAM lParam );
    DECLARE_MESSAGE_MAP()
};


#endif //SEQDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\seqdlg.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "seqdlg.h"

#ifndef VS_PACKAGE
#include <dlgbase.h>
#endif	// VS_PACKAGE

void MakeOKDefault(CMainDlg* pMainDlg);
BOOL IsaMainBtn(char c);		// Defined in mfcappwz.cpp

//////////////////////////////////////////////////////////////////////////////
// CSeqDlg dialog class

CSeqDlg::CSeqDlg(UINT IDD, CWnd *pParent)
    : C3dDialog(IDD, pParent)
{
    m_pParentWnd = pParent;
    m_nTemplate = IDD;
}

BOOL CSeqDlg::Create(UINT nIDTemplate, CWnd* pParentWnd)
{
    return C3dDialog::Create(MAKEINTRESOURCE(nIDTemplate), pParentWnd);
}

LRESULT CSeqDlg::OnGotoBeginning(WPARAM wparam, LPARAM lparam)
{
	((CMainDlg*) GetParent())->ActivateDlg(0);
    return 0;
}

BOOL CSeqDlg::OnCommand( WPARAM wParam, LPARAM lParam )
{
    // Make sure the proper button is default
    MakeOKDefault((CMainDlg*) m_pParentWnd);
    return C3dDialog::OnCommand(wParam, lParam );
}

BOOL CSeqDlg::PreTranslateMessage(MSG* pMsg)
{
    // CSeqDlg shouldn't be sent a close command.
/*    if (pMsg->message == WM_SYSCOMMAND && pMsg->wParam == SC_CLOSE)
        return TRUE;

	// Escape should close the main dialog.
	else if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE)
    {
		// Explicitly set focus to button to avoid IME problem.
		((CDialog*) m_pParentWnd)->GetDlgItem(IDCANCEL)->SetFocus();
		m_pParentWnd->SendMessage(WM_COMMAND,
			MAKEWPARAM(IDCANCEL, BN_CLICKED),
            (LPARAM) (m_pParentWnd->GetDlgItem(IDCANCEL)->m_hWnd));
        return TRUE;
	}

	// Return should go to next dialog, since focus is in CSeqDlg, and thus
	//  IDOK is the default button.
	else if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN)
    {
        DWORD nID = ((CDialog*) m_pParentWnd)->GetDefID();
        if (nID == 0) nID = IDOK;
        nID &= 0x0000FFFF;
		// Explicitly set focus to button to avoid IME problem.
		((CDialog*) m_pParentWnd)->GetDlgItem(nID)->SetFocus();
        m_pParentWnd->SendMessage(WM_COMMAND,
            MAKEWPARAM(nID, BN_CLICKED),
            (LPARAM) (m_pParentWnd->GetDlgItem(nID)->m_hWnd));
        return TRUE;
    }

 #ifndef PRIVATE	
	// Handle tabbing back into the tab area when tabbing away from
    // either end of the subject's tab order
	else if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB &&
        (SendMessage(WM_GETDLGCODE) & (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
    {
        CWnd* pCtl = GetFocus();
        if (IsChild(pCtl))
        {
            do
            {
                int nKeyState = GetKeyState(VK_SHIFT);
                pCtl = pCtl->GetWindow(nKeyState < 0 ? GW_HWNDPREV : GW_HWNDNEXT);

                if (pCtl == NULL)
                {
                    if (nKeyState < 0)
                    {
                        // Shift-tabbing, so highlight last button
                        if (((CMainDlg*) m_pParentWnd)->m_nCurrIndex
                            == ((CMainDlg*) m_pParentWnd)->m_nCurrLastIndex)
                        {
                            // On last dialog, so highlight Create button
                            m_pParentWnd->GetDlgItem(IDOK)->SetFocus();
                        }
                        else
                        {
                            // On non-last dialog, so highlight rightmost button
							int nRightmostBtn = ((CMainDlg*) m_pParentWnd)->m_nRightmostBtn;
                            m_pParentWnd->GetDlgItem(nRightmostBtn)->SetFocus();
							((CDialog*) m_pParentWnd)->SetDefID(nRightmostBtn);
							if (nRightmostBtn != IDOK)
								((CButton*) (m_pParentWnd->GetDlgItem(IDOK)))
									->SetButtonStyle(BS_PUSHBUTTON);
                        }
                    }
                    else
                    {
                        // Regular-tabbing, so highlight HELP
                        m_pParentWnd->GetDlgItem(ID_HELP)->SetFocus();
						((CDialog*) m_pParentWnd)->SetDefID(ID_HELP);
						((CButton*) (m_pParentWnd->GetDlgItem(IDOK)))
							->SetButtonStyle(BS_PUSHBUTTON);
                    }
                    return TRUE;
                }
            }
            while ((pCtl->GetStyle() & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
        }
	}

	else if (pMsg->message == WM_SYSCHAR || pMsg->message == WM_CHAR)
	{
		// If user tried kbd equivalent for CMainDlg's buttons, pass the
		//  the message to CMainDlg.
		if (IsaMainBtn((char) pMsg->wParam))
		{
			CDialog* dlg = (CDialog*) m_pParentWnd;
			if (pMsg->message == WM_CHAR)
			{
				// We only pass the message to CMainDlg if a button
				//  currently has the focus.
				HWND hwnd = ::GetFocus();
				char szClassName[256];
				::GetClassName(hwnd, szClassName, 256);
				if (strcmp(szClassName, "Button"))
				{
					// Not a button, so do the default.
					return C3dDialog::PreTranslateMessage(pMsg);
				}
			}
			pMsg->hwnd = dlg->GetDlgItem(IDOK)->GetSafeHwnd();
			// ::SetFocus(pMsg->hwnd);
			dlg->GetDlgItem(IDC_BOGUS_DEFBTN)->SetFocus();
			return dlg->IsDialogMessage(pMsg);
		}	
				

		else
			return C3dDialog::PreTranslateMessage(pMsg);
	}
#else //PRIVATE */

	CDialog* dlg = (CDialog*) m_pParentWnd;
	if (dlg->IsDialogMessage(pMsg))
		return TRUE;
// #endif //PRIVATE

    return C3dDialog::PreTranslateMessage(pMsg);
}

BEGIN_MESSAGE_MAP(CSeqDlg, C3dDialog)
    //{{AFX_MSG_MAP(CSeqDlg)
	ON_MESSAGE(WM_GOTO_BEGINNING, OnGotoBeginning)
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
    //}}AFX_MSG_MAP(CSeqDlg)
END_MESSAGE_MAP()


void CSeqDlg::OnContextMenu(CWnd* pWnd, CPoint pt)
{
#ifndef VS_PACKAGE
	// call helper in shell
	::DoHelpContextMenu(this, m_nIDHelp, pt);
#endif	// VS_PACKAGE
}

BOOL CSeqDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
#ifdef VS_PACKAGE
	return FALSE;
#else
	// call helper in shell
	return ::DoHelpInfo(this, m_nIDHelp, pHelpInfo);
#endif	// VS_PACKAGE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcappwz.rc
//
#define PO_PROJ_COUNT                   2
#define IDC_DONE                        3
#define IDCANCEL2                       3
#define PODLG_OPTION_COUNT              4
#define OTHER_VIEWS_COUNT               5
#define DEFAULT_VIEWS_COUNT             6
#define PO_OPTION_COUNT                 7
#define PO_TOTAL_COUNT                  8
#define OPTION_COUNT                    8
#define IDCD_BASE                       64
#define IDCD_MDI                        64
#define IDCD_TOOLBAR                    65
#define IDCD_PRINT                      66
#define IDCD_HELP                       67
#define IDCD_DB                         68
#define IDCD_EXTMAK                     69
#define IDCD_VERBOSE                    70
#define IDCD_VBX                        80
#define IDC_CLASS_LIST                  100
#define IDR_VSAPPWIZARDPKG              100
#define IDC_CLASS_NAME                  101
#define IDS_PROJNAME                    101
#define IDC_BASE_CLASS                  102
#define IDS_VSAPPWIZARD_DESC            102
#define IDC_HFILE                       103
#define IDC_IFILE                       104
#define IDC_BUILD_INFO                  105
#define IDC_MFCICON                     106
#define IDC_REG_ID                      106
#define IDC_REG_NAME                    107
#define IDC_FILE_NEW                    108
#define IDC_FILTER                      109
#define IDR_CUSTOMAPPWIZARD             112
#define IDC_DOCFIELD_FIRST              200
#define IDC_DOC_EXT                     200
#define IDC_DOC_TYPE                    201
#define IDC_DOC_LABEL1                  202
#define IDC_DOC_LABEL2                  203
#define IDC_DOCFIELD_LAST               203
#define IDC_DOC_LABEL3                  204
#define IDC_DOC_LABEL4                  205
#define IDC_DOC_LABEL6                  207
#define IDC_DOC_LABEL7                  208
#define IDC_OUTPUT                      300
#define IDC_CONFIRM_DIR                 301
#define IDC_OUTFILE                     301
#define IDC_OUTPROJ                     302
#define IDC_BASE_CLASS_COMBO            402
#define OLEBASE                         414
#define IDC_CONTAINER                   414
#define IDC_MSERVER                     415
#define IDC_FSERVER                     416
#define IDC_CSERVER                     417
#define OLELAST                         417
#define IDC_USE_DLL                     418
#define IDC_LARGE                       420
#define IDC_NO_INPLACE                  422
#define IDC_DATA_SOURCE                 424
#define IDC_OLEBOX                      425
#define IDC_DB_RADIO                    430
#define IDC_DB_HEADER                   431
#define IDC_DB_SIMPLE                   432
#define IDC_PROJTYPE                    433
#define IDC_DB_DOCVIEW                  433
#define IDC_RADIO2                      434
#define IDC_RADIO3                      435
#define IDC_ATLSUPPORT                  435
#define IDC_DOCSTREECTL                 436
#define IDC_NEWDOC                      437
#define IDC_NEWVIEW                     438
#define IDC_BEGINNING                   439
#define IDC_END                         440
#define IDC_BACK                        441
#define IDC_NEXT                        442
#define IDC_PONOTDLL                    443
#define IDCD_PONOTDLL                   443
#define IDCD_POBASE                     444
#define IDCD_POMAPI                     444
#define IDCD_PICBASE                    445
#define IDCD_POTOOLBAR                  445
#define IDCD_POSTATUSBAR                446
#define IDCD_POPRINT                    447
#define IDCD_PODLGBASE                  448
#define IDCD_POHELP                     448
#define IDCD_POPROJBASE                 449
#define IDCD_POSOCKETS                  449
#define IDCD_POVERBOSE                  449
#define IDCD_PO3D                       450
#define IDCD_PODLL                      450
#define IDCD_POABOUT                    451
#define IDC_PTSTATIC                    465
#define IDC_RADIO1                      469
#define IDC_PTRADIO                     469
#define IDC_AUTOMATION_RADIO2           469
#define IDC_PTMDI                       470
#define IDC_STATIC_HEADER               470
#define IDC_COMPFILE_RADIO2             470
#define IDC_PTDLG                       471
#define IDC_STATIC_IMP                  471
#define IDC_PTMODULES                   472
#define IDC_AUTOMATION_RADIO            474
#define IDCD_AUTOMATION                 474
#define IDC_DATASOURCE_TEXT             475
#define IDC_COMPFILE_RADIO              475
#define IDC_BOGUS_DEFBTN                476
#define IDC_BASE_STATIC                 477
#define IDC_APP_TITLE                   478
#define IDC_RSC_LANG                    479
#define IDC_FRAME_STYLES                481
#define IDC_DOC_STRINGS                 482
#define FRAME_STYLES_START              484
#define IDC_THICKFRAME                  484
#define IDC_SYSMENU                     485
#define IDC_MINIMIZEBOX                 486
#define IDC_MINIMIZE                    487
#define IDC_MAXIMIZEBOX                 488
#define IDC_MAXIMIZE                    489
#define FRAME_STYLES_END                489
#define CHILD_FRAME_STYLES_START        490
#define IDC_CHILD_THICKFRAME            490
#define IDC_CHILD_MINIMIZEBOX           491
#define IDC_CHILD_MINIMIZE              492
#define IDC_CHILD_MAXIMIZEBOX           493
#define IDC_CHILD_MAXIMIZE              494
#define CHILD_FRAME_STYLES_END          494
#define IDC_CHILD_SPLITTER              496
#define IDC_EDIT2                       497
#define IDC_EDIT3                       498
#define IDC_EDIT4                       499
#define IDC_ADVANCED                    501
#define IDC_DOC_CREATOR                 502
#define IDC_MAIN_SPLITTER               508
#define IDC_BUTTON1                     510
#define IDC_BROWSE                      510
#define IDC_PROJ_NAME2                  511
#define IDC_PROJ_DIR                    512
#define IDC_DIRECTORY_LABEL             513
#define IDC_SUBIDR_STATIC               514
#define IDC_FILE_TYPE                   515
#define IDC_STATIC1                     516
#define IDC_STATIC2                     517
#define IDC_MESSAGE_TEXT                518
#define IDC_MODULES_COMBO               519
#define IDC_MODULES_STATIC              520
#define IDC_WOSA_BOX                    521
#define IDC_LANG_COMBO                  522
#define IDC_WOSA_STATIC                 522
#define IDC_CHILD_STATIC                524
#define IDCD_SOCKETS                    524
#define IDC_WOSA_QUESTION               525
#define IDC_STATIC3                     525
#define IDC_STATIC_CREATION             526
#define IDC_SPIN1                       528
#define IDC_SPINMRU                     528
#define IDC_CHECK1                      529
#define IDCD_DOCOBJ                     529
#define IDC_DOCVIEW                     529
#define IDCD_OCX                        530
#define IDC_OCX_STATIC                  531
#define IDC_NOMACDAO                    532
#define IDC_DLLTYPE                     533
#define IDC_SOCKETS_STATIC              534
#define IDC_NOTE                        536
#define IDC_NOTE_NOMINMAX               537
#define IDC_MFC_LIB                     538
#define IDC_EXPLAIN                     539
#define IDC_LBL_LANG                    540
#define IDC_MOVE_LBL_LANG               541
#define IDC_MOVE_RSC_LANG               542
#define IDC_MFCSTANDARD                 543
#define IDC_RADIO5                      544
#define IDC_RADIO6                      545
#define IDC_XDOCCONTAINER               546
#define IDC_NORMALMENU                  548
#define IDC_REBARMENU                   549
#define IDC_ATLSTATIC                   551
#define IDC_NOATLSUPPORT                552
#define IDC_SUBDIR_STATIC               1000
#define IDC_POSTATUSBAR                 1000
#define IDC_EDIT1                       1001
#define IDC_MRU                         1001
#define IDC_SOURCES                     1008
#define IDC_SOURCE                      1017
#define IDC_BIGICON                     2030
#define IDC_LICENSEE_NAME               2031
#define IDC_LICENSEE_COMPANY            2032
#define IDC_AVAIL_MEM                   2034
#define IDC_MATH_COPR                   2037
#define IDC_DISK_SPACE                  2040
#define IDR_AFXLOGO                     17000
#define IDB_FOLDERS                     17001
#define IDB_EXPANDNODES                 17002
#define IDB_YELLOW_PATTERN              17003
#define IDB_B2200                       17004
#define IDB_B11001                      17004
#define IDB_B11010                      17005
#define IDB_B11100                      17006
#define IDB_B120001                     17007
#define IDB_B120010                     17008
#define IDB_B120100                     17009
#define IDB_B121000                     17010
#define IDB_B130001                     17011
#define IDB_B130010                     17012
#define IDB_B130100                     17013
#define IDB_B131000                     17014
#define IDB_B13NONE                     17015
#define IDB_B140000                     17016
#define IDB_B140001                     17017
#define IDB_B140010                     17018
#define IDB_B140011                     17019
#define IDB_B140100                     17020
#define IDB_B141101                     17021
#define IDB_B141110                     17022
#define IDB_B141111                     17023
#define IDB_B2201                       17024
#define IDB_B2210                       17025
#define IDB_B2211                       17026
#define IDB_B140101                     17027
#define IDB_B140110                     17028
#define IDB_B140111                     17029
#define IDB_B141000                     17030
#define IDB_B141001                     17031
#define IDB_B141010                     17032
#define IDB_B141011                     17033
#define IDB_B141100                     17034
#define IDB_B150101                     17035
#define IDB_B150110                     17036
#define IDB_B151001                     17037
#define IDB_B151010                     17038
#define IDB_B143DNO                     17039
#define IDB_B143DON                     17040
#define IDB_FLAG                        17041
#define IDB_B110001                     17042
#define IDB_SCROLL                      17043
#define IDB_SCROLL_L                    17044
#define IDB_SCROLL_R                    17045
#define IDB_SCROLL_RD                   17046
#define IDB_SCROLL_LD                   17047
#define IDD_PROGRESS                    17050
#define IDD_DB_OPTIONS                  17051
#define IDD_PROJTYPE                    17052
#define IDD_MAINDLG                     17053
#define IDD_OLE_OPTIONS                 17054
#define IDD_DOCSTRINGS                  17055
#define IDD_FRAME_STYLES                17056
#define IDD_CHILD_FRAME_STYLES          17057
#define IDD_MAC                         17058
#define IDD_NAMES                       17061
#define IDD_CONFIRM                     17062
#define IDD_NOHELPFILE                  17064
#define IDD_DLGAPP_OPTIONS              17065
#define IDD_DOCAPP_OPTIONS              17066
#define IDD_PROJ_OPTIONS                17067
#define IDD_PROJOPTIONS_ALT             17068
#define IDD_NAMES_ALT                   17078
#define IDD_NEWAPP2                     17081
#define IDD_DLLPROJ_OPTIONS             17081
#define IDS_LNCOLPRMPT                  17082
#define IDS_GETTING_SOURCES             17083
#define IDS_GETTING_COLS                17084
#define IDS_GETTING_SOURCES2            17085
#define IDS_ERR_COCREATEGUID_FAILED     17086
#define IDS_ERR_NOTABLES                17087
#define IDS_ERR_DBOPEN_FAILED           17088
#define IDS_SELECT_TABLE                17089
#define IDS_NEED_OLE_201                17090
#define IDS_AVAIL_MEM                   17091
#define IDS_MATH_COPR_PRESENT           17092
#define IDS_MATH_COPR_NOTPRESENT        17093
#define IDS_DISK_SPACE                  17094
#define IDP_GENERAL_BAGOUT              17095
#define IDP_FILE_EXISTS                 17095
#define IDP_FILE_IS_DIRECT              17095
#define IDP_GENERAL_ERROR               17096
#define IDP_DIRECT_CHANGE               17097
#define IDP_DIRECT_CREATE               17098
#define IDP_FILE_CREATE                 17099
#define IDP_FILE_WRITE                  17100
#define IDP_CURDIR_GONE                 17101
#define IDP_PROJFILE_EXISTS             17102
#define IDP_RESERVED_CLASS              17103
#define IDP_DUPLICATE_CLASS             17104
#define IDP_DUPLICATE_FILE              17105
#define IDP_INVALID_PROJ                17106
#define IDP_INVALID_SUBDIR              17107
#define IDP_INVALID_SYMBOL              17108
#define IDP_INVALID_FILENAME            17109
#define IDP_INVALID_EXTENSION           17110
#define IDP_GUID_ERROR                  17111
#define IDP_GUID_REGISTERED             17112
#define IDP_GENERAL_BAGOUT2             17113
#define IDP_OVERWRITE_FILE              17114
#define IDP_FILE_IS_READONLY            17115
#define IDP_CANT_DELETE_FILE            17116
#define IDS_DATASOURCE_TEXT             17117
#define IDS_NODATASOURCE_TEXT           17118
#define IDP_DIRECT_IS_FILE              17119
#define IDP_FILE_INTERFERE_DEFAULTS     17120
#define IDP_NO_PERMISSION               17121
#define IDP_SUBDIR_ERROR                17122
#define IDP_BAD_TITLE                   17123
#define IDP_ERROR_LOAD_DLL              17124
#define IDP_INVALID_PROGID              17125
#define IDS_ADVANCED                    17126
#define IDS_FRAME_STYLES                17127
#define IDS_DOC_STRINGS                 17128
#define IDS_CHILD_FRAME_STYLES          17129
#define IDS_MAC                         17130
#define IDP_EXACT_CHARS                 17131
#define IDP_BAD_LANG_DLL                17132
#define IDP_RESCAN_LANGDLL              17133
#define IDP_OLE_THEN_SIMPLE             17134
#define IDP_SIMPLE_THEN_OLE             17135
#define IDP_EDITVIEW_THEN_OLE           17136
#define IDP_DB_NO_DATA_SOURCE           17137
#define IDP_SIMPLE_THEN_MDI             17138
#define IDP_MSERVER_THEN_MDI            17139
#define IDS_HELP_DEFAULTDIR             17140
#define IDS_ERROR_HELP_NOFILE           17141
#define IDS_DISK_SPACE_UNAVAIL          17142
#define IDS_SELECT_PLATFORM             17143
#define IDS_APPWIZ_EXE                  17144
#define IDS_APPWIZ_DLL                  17145
#define IDS_CREATE_DOTS                 17146
#define IDS_CREATE_NODOTS               17147
#define IDS_HEADERF_ACC                 17148
#define IDS_HEADERF_NOACC               17149
#define IDS_IMPLF_ACC                   17150
#define IDS_IMPLF_NOACC                 17151
#define IDS_BASEC_ACC                   17152
#define IDS_BASEC_NOACC                 17153
#define IDS_ENGLISH                     17154
#define IDS_UNKNOWN                     17155
#define IDS_TITLE_MAXSTEP               17156
#define IDS_TITLE_NOMAXSTEP             17157
#define IDP_EDITVIEW_THEN_SPLITTER      17158
#define IDS_FILE_IS_DIRECT              17159
#define IDP_NO_MAC_MFCDLL               17160
#define IDP_DB_GENERAL_ERROR            17161
#define IDS_FILES                       17162
#define IDP_SPACE_IN_PATH               17163
#define IDS_NO_ODBC                     17164
#define IDP_PATH_TOO_LONG               17165
#define IDS_NO_MACODBC                  17166
#define IDS_NO_MACOLE                   17167
#define IDS_NO_OLE                      17168
#define IDS_CG_IF_TOO_DEEP              17169
#define IDS_CG_BAD_IF                   17170
#define IDS_CG_BAD_ELIF                 17171
#define IDS_CG_BAD_ELSE                 17172
#define IDS_CG_BAD_ENDIF                17173
#define IDS_CG_MISSING_DLR              17174
#define IDS_CG_UNDEFINED_SYMBOL         17175
#define IDS_CG_MISSING_DATA_RSC         17176
#define IDS_CG_ERROR_LOADING            17177
#define IDS_CG_MISSING_EOL              17178
#define IDS_CG_BAD_ITEM                 17179
#define IDP_CANT_LOAD_MODULE            17179
#define IDS_CG_STRAY_NULL               17180
#define IDP_EXTENSION_NO_EXPORT         17181
#define IDP_FILE_INTERFERE_DEFAULTS_OCX 17181
#define IDP_GETEXTCLS_RETURNS_NULL      17182
#define IDP_SETAWX_WITH_NULL            17182
#define IDP_CANT_LOAD_EXTENSION         17183
#define IDP_CANT_LOAD_LOC_TPL           17184
#define IDS_CG_CANT_LOAD_TPL            17184
#define IDP_NULL_TEMPLATE               17185
#define IDS_CG_LOOP_IN_LOOP             17186
#define IDS_CG_BAD_BEGINLOOP            17187
#define IDS_CG_UNDEF_IN_BEGINLOOP       17188
#define IDS_CG_BAD_ITERATIONS           17189
#define IDS_CG_EOF_IN_LOOP              17190
#define IDS_CG_NO_ENDIF                 17191
#define IDS_CG_EL_NO_BL                 17192
#define IDS_CG_BAD_WL_ITEM              17193
#define IDP_BAD_0STEP_AWX               17194
#define IDP_EXTENSION_ERROR             17195
#define IDS_CG_0SIZE_RSC                17196
#define IDS_CG_CANT_FIND_TPL            17197
#define IDS_CG_BAD_RSC                  17198
#define IDS_GETDLG_BAD_RANGE            17199
#define IDS_CG_BAD_INCLUDE              17200
#define IDS_CG_UNDEF_IN_INCLUDE         17201
#define IDP_SIMPLE_THEN_MAPI            17202
#define IDP_MAPI_THEN_SIMPLE            17203
#define IDS_APPWIZ_TITLE                17204
#define IDS_CG_NO_NEWPROJ_INF           17205
#define IDS_CG_BAD_SETDEFLANG           17206
#define IDS_CG_UNDEF_IN_SETDEFLANG      17207
#define IDS_CG_BADLANG_IN_SETDEFLANG    17208
#define IDP_AWX_CALLED_BAD_CONSTRUCTOR  17209
#define IDP_AWX_CALLED_BAD_DESCRUCTOR   17210
#define IDS_BACK                        17211
#define IDP_EXT_NOT_CALL_SETAWX         17212
#define IDP_FILE_WILL_EXIST             17213
#define IDS_CG_RECURSIVE_INCLUDE        17214
#define IDS_APPWIZ_OCX                  17215
#define IDS_CTLWIZ_TITLE                17215
#define IDR_MFCAPPWIZARD                17215
#define IDP_DUPLICATE_FILEGEN           17216
#define IDR_MFCAPPWIZARDDLL             17216
#define IDS_CREATION                    17217
#define IDR_OLECONTROL                  17217
#define IDS_APPWIZ_TITLE_CREATION       17218
#define IDS_PSEUDO_DEBUG                17219
#define IDS_UNICODE                     17220
#define IDS_DEBUG_UNICODE               17220
#define IDS_COPY_LIC                    17221
#define IDS_COPY_AWX                    17222
#define IDS_MAKEHELP                    17223
#define IDS_NO_MACOCX                   17224
#define IDS_REGISTER_CONTROL            17225
#define IDP_NOOLE_THEN_RICHEDIT         17226
#define IDP_RICHEDIT_THEN_NOOLE         17227
#define IDS_RELEASE                     17228
#define IDS_RELEASE_UNICODE             17229
#define IDS_CG_BAD_NEWPROJ              17230
#define IDS_CG_UNDEF_IN_NEWPROJ         17231
#define IDS_CG_LOOP_IN_NEWPROJ          17232
#define IDP_MDI_THEN_SIMPLE             17233
#define IDP_CANT_USE_SPLITTER           17234
#define IDS_GENERATE_FAILURE            17235
#define IDS_INSERT_LOCATION_COMMENT     17236
#define IDP_NOEXT_DOCSVR                17237
#define IDS_SOURCE_FILES                17238
#define IDS_HEADER_FILES                17239
#define IDS_RESOURCE_FILES              17240
#define IDS_HELP_FILES                  17241
#define IDS_TEMPLATE_FILES              17242
#define IDS_MAKEHM                      17243
#define IDS_MAKECNT                     17244
#define IDS_OLEDATASOURCE_TEXT          17245
#define IDS_ERR_BLD_HELP                17246
#define IDC_HELPPATH1                   20647
#define IDC_HELPPATH2                   20648
#define IDC_ERRORTEXT                   20649
#define IDC_INFO_ICON                   20656
#define IDC_OPTIONS                     0x8001
#define IDC_NAMES                       0x8002
#define ID_INIT_SOURCES                 0x8009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        17244
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         553
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\projtype.h ===
// projtype.h : header file
//

#include "seqdlg.h"
#ifndef VS_PACKAGE
#include <slob.h>
#include <utilctrl.h>
#endif	// VS_PACKAGE

/////////////////////////////////////////////////////////////////////////////
// CProjDlg dialog

class CProjDlg : public CSeqDlg
{
// Construction
public:
	CProjDlg(CWnd* pParent = NULL);	// standard constructor
	virtual void WriteValues();         // Writes to projectOptions
	virtual UINT ChooseBitmap();

// Dialog Data
	//{{AFX_DATA(CProjDlg)
	enum { IDD = IDD_PROJTYPE };
	int		m_nPTRadio;
	BOOL	m_bDocView;
	//}}AFX_DATA

	virtual BOOL CanDestroy();

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	void ReadValues();          // Reads from projectOptions
	void WriteProjType();
	// LATER: Uncomment when we allow multiple langauges
	//CCheckList m_chklstLang;
	
	// Generated message map functions
	//{{AFX_MSG(CProjDlg)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnClickedRadio(UINT nID);	
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\symbols.cpp ===
// projtype.cpp : implementation file
//

#include "stdafx.h"
#include "mfcappwz.h"
#include "symbols.h"
#include "oleutil.h"
#include "ddxddv.h"
#include "lang.h"
#include "util.h"

#include <malloc.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWnd* pLaunchParent;
static char BASED_CODE szMFCPathKey[] = "MFCPath32Bit";


/////////////////////////////////////////////////////////////////////////////
// Private helper functions

static void SetUpperAndLowerFile(CString strKey, CString strValue)
{
    // strip any suffix
    int iDot = strValue.ReverseFind('.');
	if (iDot != -1)
		strValue = strValue.Left(iDot);

    ASSERT(!strKey.IsEmpty());
    ASSERT(!strValue.IsEmpty());

    strKey.MakeUpper();
    SetSymbol(strKey, strValue);

    strKey.MakeLower();
    SetSymbol(strKey, strValue);
}

/////////////////////////////////////////////////////////////////////////////
// Project Type / Language options

static const char* szProjTypeString[] =
{
    "PROJTYPE_SDI",
	"PROJTYPE_MDI",
    "PROJTYPE_DLG",
    "PROJTYPE_DLL",
};

void SetProjectTypeSymbol()
{
	for (int i = 0; i < PROJTYPE_COUNT; i++)
	{
		RemoveSymbol(szProjTypeString[i]);
	}
	SetSymbol(szProjTypeString[projOptions.m_nProjType], "1");

	if( projOptions.m_bNoDocView )
		SetSymbol("NODOCVIEW", "1");
	else
		RemoveSymbol("NODOCVIEW");

	
	if(projOptions.m_nProjType == 3)
	{
		int i = GetRegInt( "AppWizard","StartRes", 1000 );
		CString strStart;
		strStart.Format("%d",i);
		SetSymbol( "START_RES", strStart );
	}
	
}

void GetProjectTypeSymbol()
{
	projOptions.m_nProjType = -1;
    for (int i = 0; i < PROJTYPE_COUNT; i++)
	{
        if (DoesSymbolExist(szProjTypeString[i]))
			projOptions.m_nProjType = i;
	}
	projOptions.m_bNoDocView = FALSE;
	if (DoesSymbolExist("NODOCVIEW")){
		projOptions.m_bNoDocView = TRUE;
	}

	ASSERT(projOptions.m_nProjType != -1);
}

static LPCTSTR szPreambleLines[] =
{
	"#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_%s)",
	"#ifdef _WIN32",
	"LANGUAGE %d, %d",
	"#pragma code_page(%d)",
	"#endif //_WIN32",
	NULL
};

// Defined in lang.cpp
WORD CodepageFromTranslation(DWORD dwTranslation);

void MakePreamble(CString& strPreamble, CString& strPreambleInQuotes,
					LPCTSTR szLangSuffix, DWORD dwTranslation)
{
	// Make format strings
	
	CString strFormat, strFormatInQuotes;
	LPCTSTR szLine;
	for (int i=0; ((szLine = szPreambleLines[i]) != NULL); i++)
	{
		strFormat = (strFormat + szLine) + '\n';
		strFormatInQuotes = (((strFormatInQuotes + "\t\"") + szLine) + "\\r\\n\"\n");
	}
	// Chop off ending \n
	strFormat = strFormat.Left(strFormat.GetLength() - 1);
	strFormatInQuotes = strFormatInQuotes.Left(strFormatInQuotes.GetLength() - 1);

	// Make arguments

	// Suffix
	CString strSuffix = szLangSuffix;
	strSuffix.MakeUpper();

	// Langid...
	LANGID langid = (WORD) (dwTranslation >> 16);
	//		primary...
	WORD nPrimaryLang = (USHORT)PRIMARYLANGID(langid);
	//		sub...
	WORD nSubLang = (USHORT)SUBLANGID(langid);

	// Code page
	WORD nCodePage = CodepageFromTranslation(dwTranslation);

	// Do it!!
	strPreamble.Format
		(strFormat, (LPCTSTR) strSuffix, nPrimaryLang, nSubLang, nCodePage);
	strPreambleInQuotes.Format
		(strFormatInQuotes, (LPCTSTR) strSuffix, nPrimaryLang, nSubLang, nCodePage);
}


void SetLanguageSymbols()
{
	CString strLangListSuffixes;
	RemoveSymbol(_T("DO_KANA"));		// only want this if we've got Japanese in our language set
	int nSize = langDlls.GetSize();
	for (int nDll = 0; nDll < nSize && langDlls.IsValidEntry(nDll); nDll++)
	{
		CString strKey;
		strKey.Format("LANGUAGE_%d", nDll);
		if (!langDlls.m_astrNameLang[nDll].IsEmpty())
			SetSymbol(strKey, langDlls.m_astrNameLang[nDll]);
		else
			SetSymbol(strKey, " ");

		// Set loop symbols for languages

		// Let's get the suffix for the languages
		CString strLangSuffix = langDlls.m_astrNameDll[nDll];
		strLangSuffix.MakeLower();
		ASSERT(strLangSuffix.Left(5) == "appwz");
		int nPeriod = strLangSuffix.Find('.');
		ASSERT(nPeriod-5 <= 3);	// i.e., suffix <= 3 characters
		strLangSuffix = strLangSuffix.Mid(5, nPeriod-5);
		strKey.Format("LANG_SUFFIX_%d", nDll);
		SetSymbol(strKey, strLangSuffix);
		
		// Japanese specific symbol needed
		strLangSuffix.MakeLower();
		if (!strLangSuffix.Compare(_T("jpn")))
			SetSymbol(_T("DO_KANA"), _T("1"));

		// HLP directory name
		CString strHlpDir;
		strLangSuffix.MakeLower();
		strKey.Format("HLP_DIR_LOC_%d", nDll);
		strHlpDir.Format("hlp\\%s", (LPCTSTR) strLangSuffix);
		SetSymbol(strKey, strHlpDir);

		// RES directory name
		CString strResDir;
		strKey.Format("RES_DIR_LOC_DBLSLASH_%d", nDll);
		strResDir.Format("res\\\\%s\\\\", (LPCTSTR) strLangSuffix);
		SetSymbol(strKey, strResDir);
		strKey.Format("RES_DIR_LOC_%d", nDll);
		strResDir.Format("res\\%s", (LPCTSTR) strLangSuffix);
		SetSymbol(strKey, strResDir);

		// MFC resource include directory name
		CString strMFCDir;
		strKey.Format("MFC_DIR_LOC_%d", nDll);
		if (strLangSuffix == "enu")
			// Special case: MFC rsc inc for enu is top-level
			strMFCDir = "";
		else
			strMFCDir.Format("l.%s\\\\", (LPCTSTR) strLangSuffix);
		SetSymbol(strKey, strMFCDir);

		// Set preamble string
		CString strPreamble, strPreambleInQuotes;
		DWORD dwTranslation = langDlls.m_adwTranslation[nDll];
		MakePreamble(strPreamble, strPreambleInQuotes, strLangSuffix, dwTranslation);
		strKey.Format("LANG_PREAMBLE_%d", nDll);
		SetSymbol(strKey, strPreamble);
		strKey.Format("LANG_PREAMBLE_INQUOTES_%d", nDll);
		SetSymbol(strKey, strPreambleInQuotes);

		// Postamble string
		strKey.Format("LANG_POSTAMBLE_%d", nDll);
		SetSymbol(strKey, "#endif");
		strKey.Format("LANG_POSTAMBLE_INQUOTES_%d", nDll);
		SetSymbol(strKey, "\t\"#endif\\r\\n\"");

		// Tack suffix onto end of strLangListSuffixes
		strLangListSuffixes += ", " + strLangSuffix;
	}
	CString strNumLangs;
	strNumLangs.Format("%d", nDll);
	SetSymbol("NUM_LANGS", strNumLangs);

	
	if (nDll == 1)
	{
		// Special case: Only one language.

		SetSymbol("HLP_DIR_LOC_0", "hlp");
		SetSymbol("RES_DIR_LOC_DBLSLASH_0", "res\\\\");
		SetSymbol("RES_DIR_LOC_0", "res");
		
		/*SetSymbol("LANG_PREAMBLE_0", "");
		SetSymbol("LANG_PREAMBLE_INQUOTES_0", "");
		SetSymbol("LANG_POSTAMBLE_0", "");
		SetSymbol("LANG_POSTAMBLE_INQUOTES_0", "");*/

		RemoveSymbol("MULTIPLE_LANGS");

		SetSymbol("HLPARG_MAC", "1");
		SetSymbol("HLPARG_MACPATH", "2");
	}
	else if (nDll > 1)
	{
		SetSymbol("MULTIPLE_LANGS", "1");
		SetSymbol("HLPARG_MAC", "2");
		SetSymbol("HLPARG_MACPATH", "3");

		// Take out leading ", " in strLangSuffix
		ASSERT(strLangListSuffixes.GetLength() > 2);
		strLangListSuffixes = strLangListSuffixes.Mid(2);
		SetSymbol("LANG_LIST_SUFFIXES", strLangListSuffixes);
	}


	SetSymbol("LOC_RC", "loc.rc");
	SetSymbol("MACLOC_RC", "macloc.rc");
	SetSymbol("DLGLOC_RC", "dlgloc.rc");

	/* CString strLangid;
	sprintf(strLangid.GetBuffer(256), "%#x", projOptions.m_langid);
	strLangid.ReleaseBuffer();
	SetSymbol("LANGID", strLangid);*/
}

void GetLanguageSymbols()
{
	// TODO: Fix me
	GetSymbol("LANGUAGE", langDlls.m_astrNameLang[0]);
/*	CString strLangid;
	int langid;
	GetSymbol("LANGID", strLangid);
	sscanf(strLangid, "0x%x", &langid);
	projOptions.m_langid = (WORD) langid;*/
}

/////////////////////////////////////////////////////////////////////////////
// Database options

struct RFXData
{
	LPCTSTR m_lpszCType;	// C Type corresponding to ODBC type
	LPCTSTR m_lpszInit;		// Initial value for the recordset member variable
	LPCTSTR m_lpszRFX;		// The RFX_ function to use w/ this recordset mem var
};

// These arrays are indexed by ODBC data type.  Format:
//  { C type, initializer value, RFX_ (or DFX_) suffix }
#define RFX_TABLE_SIZE 20

// This is for ODBC recordsets
static RFXData rdRFX[] =
{
	{ "BOOL", "FALSE", "Bool" },
	{ "BYTE", "0", "Byte" },
	{ "CString", "_T(\"\")", "Text" },
	{ "CLongBinary", "", "LongBinary" },
	{ "CByteArray", "", "Binary" },
	{ "CByteArray", "", "Binary" },
	{ "CString", "_T(\"\")", "Text" },
	{ NULL, NULL, NULL },
	{ "CString", "_T(\"\")", "Text" },
	{ "CString", "_T(\"\")", "Text" },
	{ "CString", "_T(\"\")", "Text" },
	{ "long", "0", "Long" },
	{ "int", "0", "Int" },
	{ "double", "0.0", "Double" },
	{ "float", "0.0f", "Single" },
	{ "double", "0.0", "Double" },
	{ "CTime", "0", "Date" },
	{ "CTime", "0", "Date" },
	{ "CTime", "0", "Date" },
	{ "CString","_T(\"\")", "Text" },
};

// This is for DAO recordsets
static RFXData rdDFX[] =
{
	{ "BOOL", "FALSE", "Bool" },
	{ "BYTE", "0", "Byte" },
	{ "COleCurrency", "", "Currency" },
	{ "CLongBinary", "", "LongBinary" },
	{ "CByteArray", "", "Binary" },
	{ "CByteArray", "", "Binary" },
	{ "CString", "_T(\"\")", "Text" },
	{ NULL, NULL, NULL },
	{ "CString", "_T(\"\")", "Text" },
	{ "CString", "_T(\"\")", "Text" },
	{ "CString", "_T(\"\")", "Text" },
	{ "long", "0", "Long" },
	{ "short", "0", "Short" },
	{ "double", "0.0", "Double" },
	{ "float", "0.0f", "Single" },
	{ "double", "0.0", "Double" },
	{ "COleDateTime", "(DATE)0", "DateTime" },
	{ "COleDateTime", "(DATE)0", "DateTime" },
	{ "COleDateTime", "(DATE)0", "DateTime" },
	{ "CString","_T(\"\")", "Text" },
};

static BOOL ShouldDelimitName(LPCTSTR szName)
{
	return FALSE;
	/*// Name should be delmimited if there exist non-EnglishAlphanumerics
	while (*szName != '\0')
	{
		if (!('a' <= *szName && *szName <= 'z')
			&& !('A' <= *szName && *szName <= 'Z')
			&& !('0' <= *szName && *szName <= '9'))
		{
			return TRUE;
		}
		szName++;
	}
	return FALSE;*/
}

BOOL GenerateDBBindings(CString& strDecls, CString& strInits, CString& strRFXs)
{
    ASSERT(strDecls == "");
    ASSERT(strInits == "");
    ASSERT(strRFXs == "");

	// Initialize the strings to 100 characters each to avoid
	// at least some of the unnecessary growing of buffers
	strDecls.GetBuffer(100);
	strDecls.ReleaseBuffer();
	strInits.GetBuffer(100);
	strInits.ReleaseBuffer();
	strRFXs.GetBuffer(100);
	strRFXs.ReleaseBuffer();

    // Use the nameMap to guarantee uniqueness of member variable names
	CMapStringToPtr nameMap;

	CString strCols;
	GetSymbol("DB_COLSINFO", strCols);
	CString strVars;
	GetSymbol("DB_VARSINFO", strVars);

    LPCSTR lpszLine = _tcschr(strCols, '=');
	int nCannedNameIndex = 1;
    while(lpszLine != NULL)
    {
        lpszLine++;       // Move past the '='
        // Get the variable's name
        CString strName;
        CString strNumType;
        AfxExtractSubString(strName, lpszLine, 0, ',');
        AfxExtractSubString(strNumType, lpszLine, 1, ',');

        // Extract its type info from the appropriate array
		RFXData* rdFX = rdRFX;
		if( projOptions.m_nDataSource == dbDao )
			rdFX = rdDFX;
        int nType;
        sscanf(strNumType, "%d", &nType);
		nType += 7;							// Get it into table's range
		if (nType < 0 || nType >= RFX_TABLE_SIZE || nType == 7)
		{
			// Somehow we managed to get an invalid ODBC type
			ASSERT(FALSE);

			// But let's be gracious and go on to the next one anyway
	        lpszLine = _tcschr(lpszLine, '\n');
	        if (lpszLine == NULL) break;
			lpszLine++;
	        lpszLine = _tcschr(lpszLine, '=');
			continue;
		}
		
        CString strCType = rdFX[nType].m_lpszCType;
        CString strInit = rdFX[nType].m_lpszInit;
        CString strRFX = rdFX[nType].m_lpszRFX;

		int nPos = strVars.Find('\n');
		CString strCName = strVars.Left(nPos);
		strVars = strVars.Mid(nPos + 1);

        // Build the three output strings
		BOOL bDelim = ShouldDelimitName(strName);
        strDecls += '\t' + strCType + '\t' + strCName + ";\n";  // Declaration
        if (strInit != "")
            strInits += '\t' + strCName + " = " + strInit + ";\n";  // Initialization

		if( projOptions.m_nDataSource == dbDao )
			strRFXs += "\tDFX_";
		else 
			strRFXs += "\tRFX_";

		strRFXs += strRFX + "(pFX, _T(\"";

		if (bDelim)
			strRFXs += "[" + strName + "]\"), " + strCName + ");\n"; // RFX call
		else
			strRFXs += strName + "\"), " + strCName + ");\n";        // RFX call

        lpszLine = _tcschr(lpszLine, '\n');
        if (lpszLine == NULL) break;
		lpszLine++;
        lpszLine = _tcschr(lpszLine, '=');
    }

    // Get rid of final '\n's and add m_nFields initialization.
	if (strDecls.GetLength() != 0)
		strDecls = strDecls.Left(strDecls.GetLength() - 1);
	if (strRFXs.GetLength() != 0)
		strRFXs = strRFXs.Left(strRFXs.GetLength() - 1);

	CString strNumCols;
	GetSymbol("DB_NUMCOLS", strNumCols);
    strInits += "\tm_nFields = " + strNumCols + ';';
    return TRUE;
}

void SetDBSymbols()					// Can throw an exception!!
{
    // Any database support at all?
    if (projOptions.m_bDBHeader &&
    	(projOptions.m_nProjType == PROJTYPE_MDI
		|| projOptions.m_nProjType == PROJTYPE_SDI))
	{
        SetSymbol("DB", "1");
	}
    else
	{
        RemoveSymbol("DB");
		RemoveSymbol("DB_COLSINFO");
		RemoveSymbol("DB_VARSINFO");
		RemoveSymbol("DB_NUMCOLS");
		RemoveSymbol("DB_SOURCE");
		RemoveSymbol("DB_TABLE_TYPE");
		RemoveSymbol("DB_TABLECLASS");
		RemoveSymbol("DB_CONNECT");
		RemoveSymbol("DB_DSN");
		RemoveSymbol("PARAM_VARS");
		RemoveSymbol("PARAM_VAR_BINDINGS");
		RemoveSymbol("PARAM_RFX");
	}

	// File support?
    if (projOptions.m_bDBSimple)
		SetSymbol("DB_NO_FILE", "1");
    else
 		RemoveSymbol("DB_NO_FILE");

	RemoveSymbol("OLEDB");
	RemoveSymbol("DAO");
	if (projOptions.m_nDataSource == dbDao ) {
		RemoveSymbol("CRecordView");
		RemoveSymbol("COleDBRecordView");
		SetSymbol("DAO", "1");
	} else if (projOptions.m_nDataSource == dbOledb) {
		SetSymbol("OLEDB", "1");
		RemoveSymbol("CRecordView");
		RemoveSymbol("CDaoRecordView");
	} else {
		RemoveSymbol("OleDBRecordView");
		RemoveSymbol("CDaoRecordView");
	}
		

	if (projOptions.m_bAutoDetect)
		RemoveSymbol("DB_NO_DETECT");
	else
		SetSymbol("DB_NO_DETECT", "1");

	// Set connection & recset column symbols

	SetSymbol("RECSET_VARS", "");
    SetSymbol("RECSET_VAR_BINDINGS", "");
    SetSymbol("RECSET_RFX", "");

	if (!DoesSymbolExist("DB"))
		return;

	const TCHAR *pCompare = "";
	switch(projOptions.m_nDataSource)
	{
		case dbOdbc:
			pCompare = "CRecordView";
			break;
		case dbDao:	
			pCompare = "CDaoRecordView";
			break;
		case dbOledb:	
			pCompare = "COleDBRecordView";
			break;
		default:
			break;
	}

	
    if (projOptions.m_names.strBaseClass[classView] == pCompare)
    {
        if (!GenerateDBBindings(CreateSymbol("RECSET_VARS"),
            CreateSymbol("RECSET_VAR_BINDINGS"),
            CreateSymbol("RECSET_RFX")))
        {
            AfxThrowUserException();
        }

        // now synthesize the name for the embedded
        //  CRecordset class that is in the document
        CString strVarName = "m_";
        CString strTmp, strRecsetClass;
        GetSymbol("RECSET_CLASS", strTmp);
		strRecsetClass = strTmp;
		// FUTURE: We're copying this because we'll modify strRecsetClass
		//  but we don't want to modify the RECSET_CLASS symbol.  For next
		//  version, change GetSymbol to return a copy of the string


        LPCSTR szTemp = strRecsetClass;

        BOOL bStartsWithC = (*szTemp == 'C');
        while (*szTemp != '\0' && isupper(*szTemp++))
            ;

        BOOL bAllUpper = (*szTemp == '\0');

        szTemp = strRecsetClass.GetBuffer(strRecsetClass.GetLength());

        if (bStartsWithC)
        {
            if (isupper(*++szTemp))
            {
                if (bAllUpper)
                {
                    strRecsetClass.MakeLower();
                    szTemp = strRecsetClass;
                    strVarName += ++szTemp;
                }
                else
                {
                    // MFC style name
                    *(LPSTR) szTemp = (TCHAR)tolower(*szTemp);
                    strVarName += szTemp;
                }
            }
            else
            {
                // not MFC style name
                szTemp--;
                *(LPSTR) szTemp = (TCHAR)tolower(*szTemp);
                strVarName += szTemp;
            }
        }
        else
        {
            // can't be an MFC style name
            if (bAllUpper)
            {
                strRecsetClass.MakeLower();
                strVarName += strRecsetClass;
            }
            else
            {
                *(LPSTR)szTemp = (TCHAR)tolower(*szTemp);
                strVarName += szTemp;
            }
        }
        SetSymbol("RECSET_VARIABLE", strVarName);
        TRACE("Setting recordset variable = %s\n", (LPCSTR) strVarName);
    }
}

void GetDBSymbols()
{
	// No minimal support for any database?
	if (!DoesSymbolExist("DB"))
	{
		projOptions.m_bDBHeader = FALSE;
		if (projOptions.m_names.strBaseClass[classView] == "CRecordView")
			projOptions.m_names.strBaseClass[classView] = "CView";
		projOptions.m_bDBSimple = FALSE;
		return;
	}
	projOptions.m_bDBHeader = TRUE;

	// No record view?
	if (!DoesSymbolExist("CRecordView"))
	{
		if (projOptions.m_names.strBaseClass[classView] == "CRecordView")
			projOptions.m_names.strBaseClass[classView] = "CView";
		projOptions.m_bDBSimple = FALSE;
	}
	else
		projOptions.m_names.strBaseClass[classView] = "CRecordView";

	// Are we simple?
	if (DoesSymbolExist("DB_NO_FILE"))
		projOptions.m_bDBSimple = TRUE;
	else
		projOptions.m_bDBSimple = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// OLE options

// Function to generate GUIDs for OLE.  First string is entered into
//  the main .cpp file, second string in registration database.
void generateGUID(CString& str, CString& strReg, CString& strMacro)
{
/*    if (!CheckOleVersion())
    {
#ifndef BOGUSGUID
        AfxMessageBox(IDS_NEED_OLE_201);
		if (pLaunchParent)
			pLaunchParent->EnableWindow(FALSE);
        AfxThrowUserException();
#else
		static BOOL bFirstTime = TRUE;
		if (bFirstTime)
		{
			AfxMessageBox("OLE 2.0 does not yet support unique GUID creation.  Because of this,\
 AppWizard has not been able to provide your application with a\
 globally unique GUID which is necessary for complete OLE\
 interoperability.  Please read the comment in your project's main\
 source file for more information.");
 			if (pLaunchParent)
				pLaunchParent->EnableWindow(FALSE);
			bFirstTime = FALSE;
		}
#endif //BOGUSGUID
	}*/
	
    GUID guid;
    if(!GetValidGuid(guid))
    {
        AfxMessageBox(IDS_ERR_COCREATEGUID_FAILED);
		if (pLaunchParent)
			pLaunchParent->EnableWindow(FALSE);
        AfxThrowUserException();
    }

    str.Empty();
    wsprintf(str.GetBuffer(200),
        "{ %#lx, %#x, %#x, { %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x } }",
        guid.Data1, guid.Data2, guid.Data3, (int) guid.Data4[0],
        (int) guid.Data4[1], (int) guid.Data4[2], (int) guid.Data4[3],
        (int) guid.Data4[4], (int) guid.Data4[5], (int) guid.Data4[6], (int) guid.Data4[7]);
    str.ReleaseBuffer();
    strReg.Empty();
    wsprintf(strReg.GetBuffer(200),
        "%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
        guid.Data1, guid.Data2, guid.Data3, (int) guid.Data4[0],
        (int) guid.Data4[1], (int) guid.Data4[2], (int) guid.Data4[3],
        (int) guid.Data4[4], (int) guid.Data4[5], (int) guid.Data4[6], (int) guid.Data4[7]);
    strReg.ReleaseBuffer();
    strMacro.Empty();
    wsprintf(strMacro.GetBuffer(200),
        "%#lx, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        guid.Data1, guid.Data2, guid.Data3, (int) guid.Data4[0],
        (int) guid.Data4[1], (int) guid.Data4[2], (int) guid.Data4[3],
        (int) guid.Data4[4], (int) guid.Data4[5], (int) guid.Data4[6], (int) guid.Data4[7]);
    strMacro.ReleaseBuffer();
}


// Takes text of guid in registration db form, and converts it to a C++
//  text description of its struct
void regToStructGuid(const char* szRegGuid, CString& strStructGuid)
{
	USES_CONVERSION;
	CString strRegGuid = szRegGuid;
    GUID guid;
/*	if (!CheckOleVersion())
    {
#ifndef BOGUSGUID
        AfxMessageBox(IDS_NEED_OLE_201);
        AfxThrowUserException();
	}*/
    //LoadOleEntryPoints(FALSE);
	// CLSIDFromString expects braces around the guid string
	strRegGuid = "{" + strRegGuid + "}";
    HRESULT hres = CLSIDFromString(A2W(strRegGuid.GetBuffer(strRegGuid.GetLength())), &guid);
	strRegGuid.ReleaseBuffer();
/*#else
    	sscanf(strRegGuid,
	        "%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
	        &(guid.Data1), &(guid.Data2), &(guid.Data3), &(guid.Data4[0]),
	        &(guid.Data4[1]), &(guid.Data4[2]), &(guid.Data4[3]),
	        &(guid.Data4[4]), &(guid.Data4[5]), &(guid.Data4[6]), &(guid.Data4[7]));
	    strStructGuid.Empty();
	}
#endif //BOGUSGUID
*/
	wsprintf(strStructGuid.GetBuffer(200),
	    "{ %#lx, %#x, %#x, { %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x } }",
	    guid.Data1, guid.Data2, guid.Data3, guid.Data4[0],
	    guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4],
	    guid.Data4[5], guid.Data4[6], guid.Data4[7]);
	strStructGuid.ReleaseBuffer();
}

// Ties above functions together.
void recordGuid(const CString& strDocTag)
{
	// We only want to record the guids if we're being called by CConfirmDlg
	if (theDLL.m_pMainDlg->m_pConfirmDlg == NULL)
		return;

	// If we haven't yet chosen the doc GUID yet, do it now.
	LPCTSTR szProgIDSuffix = (projOptions.m_nProjType == PROJTYPE_DLG) ?
		".Application" : ".Document";
	HKEY hkDoc;
	if (RegOpenKey(HKEY_CLASSES_ROOT,
		strDocTag + szProgIDSuffix, &hkDoc) == ERROR_SUCCESS)
	{
		// Application is already in the registration database.
		// Give user a chance to use the old guid or generate a new one
		char szBuf[100];
		LONG lSize = sizeof(szBuf);
		if (RegQueryValue(hkDoc, "CLSID", (LPSTR) szBuf, &lSize) == ERROR_SUCCESS)
		{
			// Put up dialog so user can choose which guid to use
			int nResponse = AfxMessageBox(IDP_GUID_REGISTERED, MB_YESNOCANCEL, 0);
			if (pLaunchParent)
				pLaunchParent->EnableWindow(FALSE);
			switch(nResponse)
			{
			case IDYES:
			{
				// Enter registration db guid into our symbol table.
				CString strRegGuid = szBuf;
				if (strRegGuid.Left(1) == "{" && strRegGuid.Right(1) == "}")
				{
					// Chop off leading & trailing braces
					strRegGuid = strRegGuid.Mid(1, strRegGuid.GetLength()-2);
            		SetSymbol("APP_CLSID_REG", strRegGuid);
            		regToStructGuid(strRegGuid, CreateSymbol("APP_CLSID"));
				}
				else
					// The string in the registration DB is not of the assumed format
					//  so just make a new guid.
					generateGUID(CreateSymbol("APP_CLSID"), CreateSymbol("APP_CLSID_REG"), CreateSymbol("APP_CLSID_MACRO"));
				break;
			}
			case IDNO:
				// User wants to generate a new guid
				generateGUID(CreateSymbol("APP_CLSID"), CreateSymbol("APP_CLSID_REG"), CreateSymbol("APP_CLSID_MACRO"));
				break;
			case IDCANCEL:
				// Abort
				RegCloseKey(hkDoc);
				AfxThrowUserException();
				break;
			}
		}
		else
		{
			// The application is registered, but no guid there.  Create new one.
			generateGUID(CreateSymbol("APP_CLSID"), CreateSymbol("APP_CLSID_REG"), CreateSymbol("APP_CLSID_MACRO"));
		}
		RegCloseKey(hkDoc);
	}
	else
	{
		// The application is not registered, so make new guid
		generateGUID(CreateSymbol("APP_CLSID"), CreateSymbol("APP_CLSID_REG"), CreateSymbol("APP_CLSID_MACRO"));
	}


	CString tmp, tmp2;

	// For app with OLE Automation, the .odl file needs two more guids.
	if (DoesSymbolExist("AUTOMATION"))
	{
		generateGUID(tmp, CreateSymbol("LIB_CLSID_ODL"), tmp2);
		generateGUID(CreateSymbol("DISPIID_CLSID"), CreateSymbol("DISPIID_CLSID_ODL"), tmp2);
	}
}

char* oleOptions[5] =
{ NULL, "CONTAINER", "MINI_SERVER", "FULL_SERVER", "CONTAINER_SERVER" };

void ResetOleDocSymbols()
{
    for (int i = 1; i < OLE_MAX; i++)
    {
        if (oleOptions[i] != NULL)
            RemoveSymbol(oleOptions[i]);
    }
	RemoveSymbol("COMPFILE");
	RemoveSymbol("ACTIVE_DOC_SERVER");
	RemoveSymbol("ACTIVE_DOC_CONTAINER");
}

void ResetOleSymbols()
{
	ResetOleDocSymbols();
	RemoveSymbol("AUTOMATION");
}

void SetOleSymbols()
{
    // Set flag for OLE, erase other OLE flags
    ResetOleSymbols();
    ASSERT(projOptions.m_nOleType < sizeof(oleOptions)/sizeof(oleOptions[0]));
    if (oleOptions[projOptions.m_nOleType])
        SetSymbol(oleOptions[projOptions.m_nOleType], "1");
    if (projOptions.m_bOleAutomation)
        SetSymbol("AUTOMATION", "1");
    if (projOptions.m_bOleCompFile)
        SetSymbol("COMPFILE", "1");
	if (projOptions.m_bOcx)
		SetSymbol("OLECTL", "1");
	else
		RemoveSymbol("OLECTL");	// NOTE: This is not removed in resetOleSymbols, since
			// dlg-based apps and possibly DLLs need this set.

	if (projOptions.m_bActiveDocServer)
		SetSymbol("ACTIVE_DOC_SERVER", "1");
	if (projOptions.m_bActiveDocContainer)
		SetSymbol("ACTIVE_DOC_CONTAINER", "1");

	// Set GUID symbols
    if (DoesSymbolExist("FULL_SERVER")
        || DoesSymbolExist("MINI_SERVER")
        || DoesSymbolExist("CONTAINER_SERVER")
        || DoesSymbolExist("AUTOMATION"))
    {
        // Either creates a new guid or selects existing one from registry,
        //  then records it in symbol table
		// TODO: Change this to the nonlocalized safe doc tag
        recordGuid(projOptions.m_strProj);
    }
}

void GetOleSymbols()
{
	projOptions.m_nOleType = OLE_NO;
	for (int i=1; i < OLE_MAX; i++)
	{
		if (DoesSymbolExist(oleOptions[i]))
			projOptions.m_nOleType = i;
	}

	projOptions.m_bActiveDocServer = DoesSymbolExist("ACTIVE_DOC_SERVER");
	projOptions.m_bActiveDocContainer = DoesSymbolExist("ACTIVE_DOC_CONTAINER");

	if (DoesSymbolExist("AUTOMATION"))
		projOptions.m_bOleAutomation = TRUE;
	else
		projOptions.m_bOleAutomation = FALSE;

	if (DoesSymbolExist("OLECTL"))
		projOptions.m_bOcx = TRUE;
	else
		projOptions.m_bOcx = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Application options

// order must match IDCD_ values
char* rgszOptions[] =
{
	"MAPI",
    "TOOLBAR",
	"STATUSBAR",
    "PRINT",
    "HELP",
	"SOCKETS",
	"3D",
    "ABOUT",
};

void SetAppOptionsSymbols()
{
    for (int i = 0; i < PO_TOTAL_COUNT; i++)
    {
        char* szOption = rgszOptions[i];
        if (projOptions.m_options & (1<<i))
        {
            SetSymbol(szOption, "1");
        }
        else
        {
            // remove key just in case set from previous attempt
            RemoveSymbol(szOption);
        }
    }
}

void GetAppOptionsSymbols()
{
    for (int i = 0; i < PO_TOTAL_COUNT; i++)
    {
        char* szOption = rgszOptions[i];
		if (DoesSymbolExist(szOption))
			projOptions.m_options |= (1<<i);
		else
			projOptions.m_options &= ~(1<<i);
	}
}

// MRU

void SetSizeMRUSymbols(UINT nSizeMRU)
{
	if (nSizeMRU != 0)
		SetSymbol("HAS_MRU", "1");
	else
		RemoveSymbol("HAS_MRU");

	if (nSizeMRU == 4)
	{
		// This is the default
		SetSymbol("SIZE_MRU", "");
		return;
	}

	ASSERT(nSizeMRU <= 16);

	CString strMRU;
	sprintf(strMRU.GetBuffer(16), "%d", nSizeMRU);
	strMRU.ReleaseBuffer();
	SetSymbol("SIZE_MRU", strMRU);
}

void GetSizeMRUSymbols()
{
	if (!DoesSymbolExist("HAS_MRU"))
	{
		projOptions.m_nSizeMRU = 0;
		return;
	}

	CString strMRU;
	GetSymbol("SIZE_MRU", strMRU);
	sscanf(strMRU, "%ud", &projOptions.m_nSizeMRU);
}

// ADVANCED DIALOG TABS

// Document Symbols

void SetDocumentSymbols()
{
	// Set nonlocalizable strings
	if (!projOptions.m_names.strDocFileExt.IsEmpty())
	{
		SetSymbol("SUFFIX", '.' + projOptions.m_names.strDocFileExt);
		if (!projOptions.m_bDBSimple)
			SetSymbol("HAS_SUFFIX", "1");
		else
			RemoveSymbol("HAS_SUFFIX");
	}
	else
		RemoveSymbol("HAS_SUFFIX");
	SetSymbol("DOC_REGID", projOptions.m_names.strDocRegID);

	// document coclass name (probably 'Document')
	CString strCoClass;
	int idxPeriod = projOptions.m_names.strDocRegID.Find(_T('.'));
	if (idxPeriod < 0)
		strCoClass = projOptions.m_names.strDocRegID;
	else
		strCoClass = projOptions.m_names.strDocRegID.Mid(idxPeriod+1);
	idxPeriod = strCoClass.Find(_T('.'));
	if (idxPeriod >= 0)
		strCoClass = strCoClass.Left(idxPeriod);
	SetSymbol("DOC_COCLASS", strCoClass);

	// Set localizable strings
	int nSize = langDlls.GetSize();
	for (int i = 0; i < nSize && !langDlls.m_astrDocTag[i].IsEmpty(); i++)
	{
		CString strNum;
		strNum.Format("_%d", i);
	    SetSymbol("Doc" + strNum, langDlls.m_astrDocTag[i]);
	    SetSymbol("DOC" + strNum, Upper(langDlls.m_astrDocTag[i]));
		SetSymbol("DOC_FILENEW" + strNum, langDlls.m_astrDocFileNew[i]);
		SetSymbol("DOC_FILTER" + strNum, langDlls.m_astrDocFilter[i]);
		SetSymbol("DOC_REGNAME" + strNum, langDlls.m_astrDocRegName[i]);
		SetSymbol("TITLE" + strNum, langDlls.m_astrTitle[i]);
	}

	// FUTURE: When the templates are in order take out stuff below
	if (i > 0)
	{
		// FUTURE: With multiple langs, replace these lines w/ what's commented
		//  out below them.  We need to separate out uses of $$DOC$$ that should
		//  be localized (e.g., in the big doc string in the string table) from
		//  those uses that should NOT be localized (e.g., in the name of the
		//  resource ID of that string mentioned above, and in the .odl ID, etc.)
		SetSymbol("Doc", langDlls.m_astrDocTag[0]);
		SetSymbol("DOC", Upper(langDlls.m_astrDocTag[0]));
		//SetSymbol("Doc", projOptions.m_strProjTag.Left(6));
		//SetSymbol("DOC", Upper(projOptions.m_strProjTag.Left(6)));

		SetSymbol("DOC_FILENEW", langDlls.m_astrDocFileNew[0]);
		SetSymbol("DOC_FILTER", langDlls.m_astrDocFilter[0]);
		SetSymbol("DOC_REGNAME", langDlls.m_astrDocRegName[0]);
		SetSymbol("TITLE", langDlls.m_astrTitle[0]);
	}
	else if (nSize > 0)
		SetSymbol("TITLE", langDlls.m_astrTitle[0]);

}

void GetDocumentSymbols()
{
	if (DoesSymbolExist("HAS_SUFFIX"))
	{
		// There is a doc suffix, so get it from the symbols.
		GetSymbol("SUFFIX", projOptions.m_names.strDocFileExt);
		if (projOptions.m_names.strDocFileExt.Left(1) == ".")
		{
			// Take out period
			projOptions.m_names.strDocFileExt =
				projOptions.m_names.strDocFileExt.Right
					(projOptions.m_names.strDocFileExt.GetLength()-1);
		}
		projOptions.m_bDBSimple = FALSE;
	}
	else
	{
		// No doc suffix, so clear out corresponding option
		projOptions.m_names.strDocFileExt.Empty();
	}
	GetSymbol("DOC_REGID", projOptions.m_names.strDocRegID);

	// TODO: Fix this to work with langDlls.
/*
    GetSymbol("Doc", projOptions.m_names.strDocTag);
	GetSymbol("DOC_FILENEW", projOptions.m_names.strDocFileNew);
	GetSymbol("DOC_FILTER", projOptions.m_names.strDocFilter);
	GetSymbol("DOC_REGNAME", projOptions.m_names.strDocRegName);*/
}

// Main Frame symbols

char* rgszFrameStyles[] =
{
	" | WS_THICKFRAME",
	" | WS_SYSMENU",
	" | WS_MINIMIZEBOX",
	" | WS_MINIMIZE",
	" | WS_MAXIMIZEBOX",
	" | WS_MAXIMIZE",
};

void SetFrameSymbols()
{
	if ((projOptions.m_nProjType != PROJTYPE_MDI
		&& projOptions.m_nProjType != PROJTYPE_SDI)
		|| projOptions.m_nFrameStyles == GetDefaultFrameStyles())
	{
		RemoveSymbol("FRAME_STYLES");
		if (projOptions.m_nProjType == PROJTYPE_SDI)
			SetSymbol("SW_ARG", "SW_SHOW");
		else
			SetSymbol("SW_ARG", "m_nCmdShow");

		return;
	}

	SetSymbol("FRAME_STYLES", "1");
	CString strStyles = "";
	for (int i=0; i < FRAME_STYLES_END - FRAME_STYLES_START + 1; i++)
	{
		if (projOptions.m_nFrameStyles & (1 << i))
			strStyles += rgszFrameStyles[i];
	}

	// Minimized & Maximized are special cases, since we need to also alter
	//  the ShowWindow call.
	if (projOptions.m_nFrameStyles & (1 << (IDC_MINIMIZE-FRAME_STYLES_START)))
		SetSymbol("SW_ARG", "SW_SHOWMINIMIZED");
	else if (projOptions.m_nFrameStyles & (1 << (IDC_MAXIMIZE-FRAME_STYLES_START)))
		SetSymbol("SW_ARG", "SW_SHOWMAXIMIZED");
	else if (projOptions.m_nProjType == PROJTYPE_SDI)
		SetSymbol("SW_ARG", "SW_SHOW");
	else
		SetSymbol("SW_ARG", "m_nCmdShow");

	// Get rid of leading space.
	if (strStyles.Left(1) == " ")
		strStyles = strStyles.Mid(1);
	SetSymbol("FRAME_STYLE_FLAGS", strStyles);
}

void GetFrameSymbols()
{
	if (!DoesSymbolExist("FRAME_STYLES"))
	{
		projOptions.m_nFrameStyles = GetDefaultFrameStyles();
		return;
	}
	CString strStyles;
	GetSymbol("FRAME_STYLE_FLAGS", strStyles);
	for (int i=0; i < FRAME_STYLES_END - FRAME_STYLES_START + 1; i++)
	{
		// See if the flag (minus the leading space which is removed from
		//  the first flag) is a substring of strStyles
		CString strSearchString = ((LPCTSTR) rgszFrameStyles[i])+1;
		if (strStyles.Find(strSearchString + ' ') != -1
			|| strStyles.Right(strSearchString.GetLength()) == strSearchString)
		{
			projOptions.m_nFrameStyles |= (1<<i);
		}
		else
			projOptions.m_nFrameStyles &= ~(1<<i);
	}
}

void SetSplitterSymbols()
{
	BOOL fHandled = FALSE;

	if (projOptions.m_bSplitter)
	{
		SetSymbol("SPLITTER", "1");
		if (projOptions.m_nProjType == PROJTYPE_MDI)
		{
			SetSymbol("SPLITTER_MDI", "1");
			RemoveSymbol("SPLITTER_SDI");
			fHandled = TRUE;
		}
		else if (projOptions.m_nProjType == PROJTYPE_SDI)
		{
			SetSymbol("SPLITTER_SDI", "1");
			RemoveSymbol("SPLITTER_MDI");
			fHandled = TRUE;
		}
	}
	if (!fHandled) // other projects, such as dlg and dll.
	{
		RemoveSymbol("SPLITTER");
		RemoveSymbol("SPLITTER_MDI");
		RemoveSymbol("SPLITTER_SDI");
	}
}

void GetSplitterSymbols()
{
	if (DoesSymbolExist("SPLITTER"))
		projOptions.m_bSplitter = TRUE;
	else
		projOptions.m_bSplitter = FALSE;
}

void SetMenuSymbols()
{
	BOOL fHandled = TRUE;

	RemoveSymbol("REBAR");
	RemoveSymbol("NORMALMENU");
	switch (projOptions.m_nMenuStyle)
	{
		case NORMAL_MENUS:
			SetSymbol("NORMALMENU", "1");
			break;
		case REBAR_MENUS:
			SetSymbol("REBAR", "1");
			break;
		default:
			ASSERT(FALSE);
			break;
	}
}

void GetMenuSymbols()
{
	projOptions.m_nMenuStyle = NORMAL_MENUS;
	if (DoesSymbolExist("REBAR"))
		projOptions.m_nMenuStyle = REBAR_MENUS;
}

// Child Frame symbols	

char* rgszChildFrameStyles[] =
{
	" | WS_THICKFRAME",
	" | WS_MINIMIZEBOX",
	"",   //" | WS_MINIMIZE"
	" | WS_MAXIMIZEBOX",
	"", 	//" | WS_MAXIMIZE",
};

void SetChildFrameSymbols()
{
	// Set symbol for emitting childfrm files.  (We now *always* emit child frame for MD apps.)
	if (IsMDI())
		SetSymbol("MDICHILD", "1");
	else
		RemoveSymbol("MDICHILD");

	int nDefChildFrameStyles = GetDefaultChildFrameStyles();
	if (!IsMDI()
		|| (projOptions.m_nChildFrameStyles == nDefChildFrameStyles
			&& !projOptions.m_bSplitter))
	{
		// Reset child frame symbols
		RemoveSymbol("CHILD_FRAME_STYLE_FLAGS");
		RemoveSymbol("CHILD_FRAME_STYLES");
		RemoveSymbol("CHILD_FRAME_MAXIMIZED");
		RemoveSymbol("CHILD_FRAME_MINIMIZED");
		SetSplitterSymbols();
		return;
	}

	// Set symbol for emitting PreCreateWindow if necessary
	if (projOptions.m_nChildFrameStyles != nDefChildFrameStyles)
		SetSymbol("CHILD_FRAME_STYLES", "1");
	else
		RemoveSymbol("CHILD_FRAME_STYLES");

	// Set style flags symbol
	CString strStyles = "";
	for (int i=0; i < CHILD_FRAME_STYLES_END - CHILD_FRAME_STYLES_START + 1; i++)
	{
		if (projOptions.m_nChildFrameStyles & (1 << i))
			strStyles += rgszChildFrameStyles[i];
	}
	SetSymbol("CHILD_FRAME_STYLE_FLAGS", strStyles);
	if (projOptions.m_nChildFrameStyles & (1 << 4 ))
		SetSymbol("CHILD_FRAME_MAXIMIZED", "1");
	if (projOptions.m_nChildFrameStyles & (1 << 2 ))
		SetSymbol("CHILD_FRAME_MINIMIZED", "1");

	SetSplitterSymbols();
}

void GetChildFrameSymbols()
{
	int nDefChildFrameStyles = GetDefaultChildFrameStyles();
	if (!DoesSymbolExist("MDICHILD"))
	{
		projOptions.m_nChildFrameStyles = nDefChildFrameStyles;
		GetSplitterSymbols();
		return;
	}

	// Get child frame styles
	if (DoesSymbolExist("CHILD_FRAME_STYLES"))
	{
		CString strStyles;
		GetSymbol("CHILD_FRAME_STYLE_FLAGS", strStyles);
		for (int i=0; i < CHILD_FRAME_STYLES_END - CHILD_FRAME_STYLES_START + 1; i++)
		{
			// See if the flag is a substring of strStyles
			CString strSearchString = ((LPCTSTR) rgszChildFrameStyles[i])+1;
			if (strStyles.Find(strSearchString + ' ') != -1
				|| strStyles.Right(strSearchString.GetLength()) == strSearchString)
			{
				projOptions.m_nChildFrameStyles |= (1<<i);
			} else {
				projOptions.m_nChildFrameStyles &= ~(1<<i);
			}
		}
		if( DoesSymbolExist("CHILD_FRAME_MAXIMIZED") ) {
			projOptions.m_nChildFrameStyles &= (1<<4);
		} else {
			projOptions.m_nChildFrameStyles &= ~(1<<4);
		}
		if( DoesSymbolExist("CHILD_FRAME_MINIMIZED") ) {
			projOptions.m_nChildFrameStyles &= (1<<2);
		} else {
			projOptions.m_nChildFrameStyles &= ~(1<<2);
		}
	}
	else
		projOptions.m_nChildFrameStyles = nDefChildFrameStyles;
	GetSplitterSymbols();
}

/////////////////////////////////////////////////////////////////////////////
// Project options

char* rgszProjOptions[] =
{
	"VERBOSE",
	"MFCDLL",
};

void SetProjOptionsSymbols()
{
    for (int i = 0; i < PO_PROJ_COUNT; i++)
    {
        char* szOption = rgszProjOptions[i];
        if (projOptions.m_projOptions & (1<<i))
        {
            SetSymbol(szOption, "1");
        }
        else
        {
            // remove key just in case set from previous attempt
            RemoveSymbol(szOption);
        }
    }
    if (projOptions.m_bATLSupport)
    {
        SetSymbol("ATL_SUPPORT", "1");
    }
    else
    {
        // remove key just in case set from previous attempt
        RemoveSymbol("ATL_SUPPORT");
    }
    if (projOptions.m_nProjStyle == PS_EXPLORER  )
	{
        if (projOptions.m_names.strBaseClass[classView] == "CView" )
		{
            projOptions.m_names.strBaseClass[classView] = "CListView";
		}
        SetSymbol("PROJTYPE_EXPLORER", "1");
	}
	else
	{
		if( DoesSymbolExist("PROJTYPE_EXPLORER") )
		{
			if (projOptions.m_names.strBaseClass[classView] == "CListView" )
			{
				projOptions.m_names.strBaseClass[classView] = "CView";
			}
			RemoveSymbol("PROJTYPE_EXPLORER");
		}
	}
}

void GetProjOptionsSymbols()
{
    for (int i = 0; i < PO_PROJ_COUNT; i++)
    {
        char* szOption = rgszProjOptions[i];
		if (DoesSymbolExist(szOption))
			projOptions.m_projOptions |= (1<<i);
		else
			projOptions.m_projOptions &= ~(1<<i);
	}
	if (DoesSymbolExist("ATL_SUPPORT")) 
		projOptions.m_bATLSupport = TRUE;
	else
		projOptions.m_bATLSupport = FALSE;
    if (DoesSymbolExist("PROJTYPE_EXPLORER")  )
	{
		projOptions.m_nProjStyle = PS_EXPLORER;
	}
	else
	{
		projOptions.m_nProjStyle = PS_MFCNORMAL;
	}
}

LPCTSTR szExtdll = "EXTDLL";

void SetDllSymbol()
{
	if (projOptions.m_bExtdll)
		SetSymbol(szExtdll, "1");
	else
		RemoveSymbol(szExtdll);
}

void GetDllSymbol()
{
	projOptions.m_bExtdll = DoesSymbolExist(szExtdll);
}

/////////////////////////////////////////////////////////////////////////////
// Classes dialog names

static char* classPrefix[classMax] =
{ "VIEW", "APP", "FRAME", "CHILD_FRAME", "DOC", "DLG",
  "RECSET", "SRVRITEM", "CNTRITEM",	"IPFRAME",  "DLGAUTOPROXY", "TREEVIEW", "WNDVIEW" };

void SetClassesSymbols()
{
    for (int iClass = 0; iClass < classMax; iClass++)
    {
        CString prefix = classPrefix[iClass];
        SetSymbol(prefix + "_CLASS", projOptions.m_names.strClass[iClass]);
        SetSymbol(prefix + "_BASE_CLASS", projOptions.m_names.strBaseClass[iClass]);
        SetUpperAndLowerFile(prefix + "_IFILE", projOptions.m_names.strIFile[iClass]);
        SetUpperAndLowerFile(prefix + "_HFILE", projOptions.m_names.strHFile[iClass]);
    }

	SetBaseViewSymbols();
}

void GetClassesSymbols()
{
    for (int iClass = 0; iClass < classMax; iClass++)
    {
        CString prefix = classPrefix[iClass];
        GetSymbol(prefix + "_CLASS", projOptions.m_names.strClass[iClass]);
        GetSymbol(prefix + "_BASE_CLASS", projOptions.m_names.strBaseClass[iClass]);
        GetSymbol(prefix + "_IFILE", projOptions.m_names.strIFile[iClass]);
        GetSymbol(prefix + "_HFILE", projOptions.m_names.strHFile[iClass]);
    }
}

char* szDefaultViews[DEFAULT_VIEWS_COUNT] =
{
	"CView",
	"CScrollView",
	"CFormView",
	"CListView",
	"CTreeView",
	"CRichEditView",
};

static char* szOtherViews[OTHER_VIEWS_COUNT] =
{
	"CEditView",
	"CRecordView",
	"CDaoRecordView",
	"COleDBRecordView",
	"CHtmlView",
};

void SetBaseViewSymbols()
{
    // Set flag for type of view, erase other view-type flags
    for (int i=0; i < DEFAULT_VIEWS_COUNT; i++)
    	RemoveSymbol(szDefaultViews[i]);
	for (i=0; i < OTHER_VIEWS_COUNT; i++)
    	RemoveSymbol(szOtherViews[i]);
    SetSymbol(projOptions.m_names.strBaseClass[classView], "1");

	// Bring up the dialog if its a FormView Derived Class
	if(
		projOptions.m_names.strBaseClass[classView] == szDefaultViews[2] ||
		projOptions.m_names.strBaseClass[classView] == szOtherViews[1] ||
		projOptions.m_names.strBaseClass[classView] == szOtherViews[2] ||
		projOptions.m_names.strBaseClass[classView] == szOtherViews[3]
	  )
	{
		CString strDialog;
		CString strTemp;
		BOOL fDialog;
	
		GetSymbol(_T("SAFE_ROOT"), strTemp);
		strDialog.Format("IDD_%s_FORM", strTemp); // name of dialog resource to open
		SetSymbol( _T("APPWIZ_INITIAL_DIALOG"),strDialog);
	
	}
}

/////////////////////////////////////////////////////////////////////////////
// Set miscellaneous symbols

void SetMFCPathSymbol()
{
	// get MFC path from Registry
    CString strMFCPath;

#ifndef VS_PACKAGE
    HKEY hVCKey;
	CString strVCKey = GetRegistryKeyName();
	strVCKey += "\\General";
    if (RegOpenKeyEx(HKEY_CURRENT_USER, strVCKey, 0, KEY_QUERY_VALUE, &hVCKey) == ERROR_SUCCESS)
    {
        DWORD dwLength = _MAX_PATH;
        DWORD dwType;
        RegQueryValueEx(hVCKey, szMFCPathKey, NULL, &dwType,
            (LPBYTE) strMFCPath.GetBuffer(_MAX_PATH), &dwLength);
        strMFCPath.ReleaseBuffer();

        RegCloseKey(hVCKey);
    }
#endif	// VS_PACKAGE

    int nLen = strMFCPath.GetLength();
    if (nLen != 0)
	{
		TCHAR ch = *_tcsdec((const TCHAR*) strMFCPath, ((const TCHAR*) strMFCPath) + nLen);
		if (ch != '\\' && ch != '/')
			strMFCPath += "\\";
	}
    SetSymbol("MFCPath", strMFCPath);
}

// Set year for copyright
void SetYearSymbol()
{
	time_t osBinaryTime;  // C run-time time (defined in <time.h>)
	time( &osBinaryTime ) ;  // Get the current time from the
	CTime osTime( osBinaryTime );  // CTime from C run-time time
	
	int year = osTime.GetYear(); // extract the year and turn it into a string
	CString str;
	str.Format("%d",year);
						 
    SetSymbol("YEAR", str);  // at last check, this will last us until the year 2038
}

void RemoveInapplicableSymbols()
{
    // Those project options that don't jibe with current app-type
    //  must have their symbols un-set
    if (projOptions.m_nProjType == PROJTYPE_DLG)
    {
        // Dialog-based app doesn't use these symbols
        RemoveSymbol("TOOLBAR");
        RemoveSymbol("PRINT");
        RemoveSymbol("CRecordView");
		RemoveSymbol("SPLITTER_MDI");
		RemoveSymbol("SPLITTER_SDI");
		RemoveSymbol("SPLITTER");
		RemoveSymbol("MAPI");
		ResetOleDocSymbols();
    }
    else
    {
        // Doc/view app doesn't use this symbol
        RemoveSymbol("ABOUT");
    }
}



/////////////////////////////////////////////////////////////////////////////
// Dictionary lookup functions

void GetSymbol(const TCHAR* tszKey, CString& rStrValue)
{
	GetAWX()->m_Dictionary.Lookup(tszKey, rStrValue);
}

void SetSymbol(const TCHAR* tszKey, const TCHAR* tszValue)
{
	GetAWX()->m_Dictionary[tszKey] = tszValue;
}

CString& CreateSymbol(const TCHAR* tszKey)
{
	return GetAWX()->m_Dictionary[tszKey];
}
	
BOOL DoesSymbolExist(const TCHAR* tszKey)
{
	CString tmp;
	return (GetAWX()->m_Dictionary.Lookup(tszKey, tmp));
}

void RemoveSymbol(const TCHAR* tszKey)
{
	GetAWX()->m_Dictionary.RemoveKey(tszKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\cntritem.h ===
// $$cntritem_hfile$$.h : interface of the $$CNTRITEM_CLASS$$ class
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$DOC_CLASS$$;
class $$VIEW_CLASS$$;

class $$CNTRITEM_CLASS$$ : public $$CNTRITEM_BASE_CLASS$$
{
	DECLARE_SERIAL($$CNTRITEM_CLASS$$)

// Constructors
public:
$$IF(CRichEditView)
	$$CNTRITEM_CLASS$$(REOBJECT* preo = NULL, $$DOC_CLASS$$* pContainer = NULL);
$$ELSE
	$$CNTRITEM_CLASS$$($$DOC_CLASS$$* pContainer = NULL);
$$ENDIF //CRichEditView
$$IF(VERBOSE)
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.
$$ENDIF

// Attributes
public:
	$$DOC_CLASS$$* GetDocument()
		{ return ($$DOC_CLASS$$*)$$CNTRITEM_BASE_CLASS$$::GetDocument(); }
	$$VIEW_CLASS$$* GetActiveView()
		{ return ($$VIEW_CLASS$$*)$$CNTRITEM_BASE_CLASS$$::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$CNTRITEM_CLASS$$)
	public:
$$IF(!CRichEditView)
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
$$ENDIF //!CRichEditView
	protected:
$$IF(!CRichEditView)
$$IF(!ACTIVE_DOC_CONTAINER)
	virtual void OnGetItemPosition(CRect& rPosition);
$$ENDIF
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
$$IF(CONTAINER_SERVER)
	virtual BOOL CanActivate();
$$ENDIF
$$ENDIF //!CRichEditView
	//}}AFX_VIRTUAL

// Implementation
public:
	~$$CNTRITEM_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
$$IF(!CRichEditView)
	virtual void Serialize(CArchive& ar);
$$ENDIF //!CRichEditView
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dialog.h ===
// $$dlg_hfile$$.h : header file
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

$$IF(AUTOMATION)
class $$DLGAUTOPROXY_CLASS$$;

$$ENDIF //AUTOMATION
/////////////////////////////////////////////////////////////////////////////
// $$DLG_CLASS$$ dialog

class $$DLG_CLASS$$ : public $$DLG_BASE_CLASS$$
{
$$IF(AUTOMATION)
	DECLARE_DYNAMIC($$DLG_CLASS$$);
	friend class $$DLGAUTOPROXY_CLASS$$;

$$ENDIF
// Construction
public:
	$$DLG_CLASS$$(CWnd* pParent = NULL);	// standard constructor
$$IF(AUTOMATION)
	virtual ~$$DLG_CLASS$$();
$$ENDIF

// Dialog Data
	//{{AFX_DATA($$DLG_CLASS$$)
	enum { IDD = IDD_$$SAFE_ROOT$$_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$DLG_CLASS$$)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
$$IF(AUTOMATION)
	$$DLGAUTOPROXY_CLASS$$* m_pAutoProxy;
$$ENDIF
	HICON m_hIcon;
$$IF(AUTOMATION)

	BOOL CanExit();
$$ENDIF //AUTOMATION

	// Generated message map functions
	//{{AFX_MSG($$DLG_CLASS$$)
	virtual BOOL OnInitDialog();
$$IF(ABOUT)	
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
$$ENDIF
$$IF(HELP)
	afx_msg void OnDestroy();
$$ENDIF
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
$$IF(AUTOMATION)
	afx_msg void OnClose();
	virtual void OnOK();
	virtual void OnCancel();
$$ENDIF //AUTOMATION
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dlgproxy.cpp ===
// $$dlgautoproxy_ifile$$.cpp : implementation file
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$dlgautoproxy_hfile$$.h"
#include "$$dlg_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$DLGAUTOPROXY_CLASS$$

IMPLEMENT_DYNCREATE($$DLGAUTOPROXY_CLASS$$, $$DLGAUTOPROXY_BASE_CLASS$$)

$$DLGAUTOPROXY_CLASS$$::$$DLGAUTOPROXY_CLASS$$()
{
	EnableAutomation();
	
	// To keep the application running as long as an automation 
	//	object is active, the constructor calls AfxOleLockApp.
	AfxOleLockApp();

$$IF(VERBOSE)
	// Get access to the dialog through the application's
	//  main window pointer.  Set the proxy's internal pointer
	//  to point to the dialog, and set the dialog's back pointer to
	//  this proxy.
$$ENDIF //VERBOSE
	ASSERT (AfxGetApp()->m_pMainWnd != NULL);
	ASSERT_VALID (AfxGetApp()->m_pMainWnd);
	ASSERT_KINDOF($$DLG_CLASS$$, AfxGetApp()->m_pMainWnd);
	m_pDialog = ($$DLG_CLASS$$*) AfxGetApp()->m_pMainWnd;
	m_pDialog->m_pAutoProxy = this;
}

$$DLGAUTOPROXY_CLASS$$::~$$DLGAUTOPROXY_CLASS$$()
{
$$IF(VERBOSE)
	// To terminate the application when all objects created with
	// 	with automation, the destructor calls AfxOleUnlockApp.
	//  Among other things, this will destroy the main dialog
$$ENDIF //VERBOSE
	if (m_pDialog != NULL)
		m_pDialog->m_pAutoProxy = NULL;
	AfxOleUnlockApp();
}

void $$DLGAUTOPROXY_CLASS$$::OnFinalRelease()
{
$$IF(VERBOSE)
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

$$ENDIF //VERBOSE
	$$DLGAUTOPROXY_BASE_CLASS$$::OnFinalRelease();
}

BEGIN_MESSAGE_MAP($$DLGAUTOPROXY_CLASS$$, $$DLGAUTOPROXY_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$DLGAUTOPROXY_CLASS$$)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP($$DLGAUTOPROXY_CLASS$$, $$DLGAUTOPROXY_BASE_CLASS$$)
	//{{AFX_DISPATCH_MAP($$DLGAUTOPROXY_CLASS$$)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_I$$Safe_root$$ to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {$$DISPIID_CLSID_ODL$$}
static const IID IID_I$$Safe_root$$ =
$$DISPIID_CLSID$$;

BEGIN_INTERFACE_MAP($$DLGAUTOPROXY_CLASS$$, $$DLGAUTOPROXY_BASE_CLASS$$)
	INTERFACE_PART($$DLGAUTOPROXY_CLASS$$, IID_I$$Safe_root$$, Dispatch)
END_INTERFACE_MAP()

$$IF(VERBOSE)
// The IMPLEMENT_OLECREATE2 macro is defined in StdAfx.h of this project
$$ENDIF //VERBOSE
// {$$APP_CLSID_REG$$}
IMPLEMENT_OLECREATE2($$DLGAUTOPROXY_CLASS$$, "$$Safe_root$$.Application", $$APP_CLSID_MACRO$$)

/////////////////////////////////////////////////////////////////////////////
// $$DLGAUTOPROXY_CLASS$$ message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\childfrm.cpp ===
// $$child_frame_ifile$$.cpp : implementation of the $$CHILD_FRAME_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$child_frame_hfile$$.h"
$$IF(PROJTYPE_EXPLORER)
#include "$$treeview_hfile$$.h"
#include "$$view_hfile$$.h"
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$CHILD_FRAME_CLASS$$

IMPLEMENT_DYNCREATE($$CHILD_FRAME_CLASS$$, $$CHILD_FRAME_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$CHILD_FRAME_CLASS$$, $$CHILD_FRAME_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$CHILD_FRAME_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
$$ENDIF
$$IF(NODOCVIEW)
		ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
		ON_WM_SETFOCUS()
		ON_WM_CREATE()
$$ENDIF
$$IF( REBAR )
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
		ON_WM_CREATE()
$$ENDIF // (ANY SERVER)
$$ENDIF // REBAR
	//}}AFX_MSG_MAP
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	ON_UPDATE_COMMAND_UI_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnUpdateViewStyles)
	ON_COMMAND_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnViewStyle)
$$ENDIF
$$ENDIF
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$CHILD_FRAME_CLASS$$ construction/destruction

$$CHILD_FRAME_CLASS$$::$$CHILD_FRAME_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: add member initialization code here
	
$$ENDIF
}

$$CHILD_FRAME_CLASS$$::~$$CHILD_FRAME_CLASS$$()
{
}
$$IF(SPLITTER_MDI || PROJTYPE_EXPLORER)

BOOL $$CHILD_FRAME_CLASS$$::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
$$IF(PROJTYPE_EXPLORER)
	// create splitter window
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
		return FALSE;

	if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS($$TREEVIEW_CLASS$$), CSize(100, 100), pContext) ||
		!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS($$VIEW_CLASS$$), CSize(100, 100), pContext))
	{
		m_wndSplitter.DestroyWindow();
		return FALSE;
	}

	return TRUE;
$$ELSE //!PROJTYPE_EXPLORER
	return m_wndSplitter.Create( this,
$$IF(VERBOSE)
		2, 2,                 // TODO: adjust the number of rows, columns
		CSize( 10, 10 ),      // TODO: adjust the minimum pane size
$$ELSE //!VERBOSE
		2, 2,
		CSize( 10, 10 ),
$$ENDIF //VERBOSE
		pContext );
$$ENDIF //PROJTYPE_EXPLORER
}
$$ENDIF //SPLITTER || EXPLORER

BOOL $$CHILD_FRAME_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
$$IF(VERBOSE)
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

$$ENDIF //VERBOSE
	if( !$$CHILD_FRAME_BASE_CLASS$$::PreCreateWindow(cs) )
		return FALSE;

$$IF(CHILD_FRAME_STYLES)
	cs.style = WS_CHILD | WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
		| FWS_ADDTOTITLE$$CHILD_FRAME_STYLE_FLAGS$$;

$$ENDIF //CHILD_FRAME_STYLES
$$IF(NODOCVIEW)
	cs.dwExStyle &= ~WS_EX_CLIENTEDGE;
	cs.lpszClass = AfxRegisterWndClass(0);

$$ENDIF
	return TRUE;
}

$$IF(CHILD_FRAME_MAXIMIZED || CHILD_FRAME_MINIMIZED)
void $$CHILD_FRAME_CLASS$$::ActivateFrame(int nCmdShow)
{
$$IF(VERBOSE)
	// TODO: Modify this function to change how the frame is activated.

$$ENDIF //VERBOSE
$$IF(CHILD_FRAME_MAXIMIZED)
	nCmdShow = SW_SHOWMAXIMIZED;
$$ENDIF //CHILD_FRAME_MAXIMIZED
$$IF(CHILD_FRAME_MINIMIZED)
	nCmdShow = SW_SHOWMINIMIZED;
$$ENDIF //CHILD_FRAME_MINIMIZED
	$$CHILD_FRAME_BASE_CLASS$$::ActivateFrame(nCmdShow);
}
$$ENDIF //CHILD_FRAME_MAXIMIZED || CHILD_FRAME_MINIMIZED


/////////////////////////////////////////////////////////////////////////////
// $$CHILD_FRAME_CLASS$$ diagnostics

#ifdef _DEBUG
void $$CHILD_FRAME_CLASS$$::AssertValid() const
{
	$$CHILD_FRAME_BASE_CLASS$$::AssertValid();
}

void $$CHILD_FRAME_CLASS$$::Dump(CDumpContext& dc) const
{
	$$CHILD_FRAME_BASE_CLASS$$::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$CHILD_FRAME_CLASS$$ message handlers
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
$$VIEW_CLASS$$* $$CHILD_FRAME_CLASS$$::GetRightPane()
{
	CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
	$$VIEW_CLASS$$* pView = DYNAMIC_DOWNCAST($$VIEW_CLASS$$, pWnd);
	return pView;
}

void $$CHILD_FRAME_CLASS$$::OnUpdateViewStyles(CCmdUI* pCmdUI)
{
$$IF(VERBOSE)
	// TODO: customize or extend this code to handle choices on the
	// View menu.
$$ENDIF //VERBOSE

	$$VIEW_CLASS$$* pView = GetRightPane(); 

$$IF(VERBOSE)
	// if the right-hand pane hasn't been created or isn't a view,
	// disable commands in our range
$$ENDIF //VERBOSE

	if (pView == NULL)
		pCmdUI->Enable(FALSE);
	else
	{
		DWORD dwStyle = pView->GetStyle() & LVS_TYPEMASK;

$$IF(VERBOSE)
		// if the command is ID_VIEW_LINEUP, only enable command
		// when we're in LVS_ICON or LVS_SMALLICON mode

$$ENDIF //VERBOSE
		if (pCmdUI->m_nID == ID_VIEW_LINEUP)
		{
			if (dwStyle == LVS_ICON || dwStyle == LVS_SMALLICON)
				pCmdUI->Enable();
			else
				pCmdUI->Enable(FALSE);
		}
		else
		{
$$IF(VERBOSE)
			// otherwise, use dots to reflect the style of the view
$$ENDIF //VERBOSE
			pCmdUI->Enable();
			BOOL bChecked = FALSE;

			switch (pCmdUI->m_nID)
			{
			case ID_VIEW_DETAILS:
				bChecked = (dwStyle == LVS_REPORT);
				break;

			case ID_VIEW_SMALLICON:
				bChecked = (dwStyle == LVS_SMALLICON);
				break;

			case ID_VIEW_LARGEICON:
				bChecked = (dwStyle == LVS_ICON);
				break;

			case ID_VIEW_LIST:
				bChecked = (dwStyle == LVS_LIST);
				break;

			default:
				bChecked = FALSE;
				break;
			}

			pCmdUI->SetRadio(bChecked ? 1 : 0);
		}
	}
}


void $$CHILD_FRAME_CLASS$$::OnViewStyle(UINT nCommandID)
{
$$IF(VERBOSE)
	// TODO: customize or extend this code to handle choices on the
	// View menu.
$$ENDIF //VERBOSE
	$$VIEW_CLASS$$* pView = GetRightPane();

$$IF(VERBOSE)
	// if the right-hand pane has been created and is a $$VIEW_CLASS$$,
	// process the menu commands...
$$ENDIF //VERBOSE
	if (pView != NULL)
	{
		DWORD dwStyle = -1;

		switch (nCommandID)
		{
		case ID_VIEW_LINEUP:
			{
$$IF(VERBOSE)
				// ask the list control to snap to grid
$$ENDIF //VERBOSE
				CListCtrl& refListCtrl = pView->GetListCtrl();
				refListCtrl.Arrange(LVA_SNAPTOGRID);
			}
			break;

$$IF(VERBOSE)
		// other commands change the style on the list control
$$ENDIF //VERBOSE
		case ID_VIEW_DETAILS:
			dwStyle = LVS_REPORT;
			break;

		case ID_VIEW_SMALLICON:
			dwStyle = LVS_SMALLICON;
			break;

		case ID_VIEW_LARGEICON:
			dwStyle = LVS_ICON;
			break;

		case ID_VIEW_LIST:
			dwStyle = LVS_LIST;
			break;
		}

$$IF(VERBOSE)
		// change the style; window will repaint automatically
$$ENDIF //VERBOSE
		if (dwStyle != -1)
			pView->ModifyStyle(LVS_TYPEMASK, dwStyle);
	}
}
$$ENDIF
$$ENDIF
$$IF(NODOCVIEW)
void $$CHILD_FRAME_CLASS$$::OnFileClose() 
{
$$IF(VERBOSE)
	// To close the frame, just send a WM_CLOSE, which is the equivalent
	// choosing close from the system menu.
$$ENDIF

	SendMessage(WM_CLOSE);
}

int $$CHILD_FRAME_CLASS$$::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// create a view to occupy the client area of the frame
	if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW, 
		CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
	{
		TRACE0("Failed to create view window\n");
		return -1;
	}

	return 0;
}

void $$CHILD_FRAME_CLASS$$::OnSetFocus(CWnd* pOldWnd) 
{
	CMDIChildWnd::OnSetFocus(pOldWnd);

	m_wndView.SetFocus();
}

BOOL $$CHILD_FRAME_CLASS$$::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo) 
{
	// let the view have first crack at the command
	if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;
	
	// otherwise, do default handling
	return CMDIChildWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

$$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dialog.cpp ===
// $$dlg_ifile$$.cpp : implementation file
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$dlg_hfile$$.h"
$$IF(AUTOMATION)
#include "$$dlgautoproxy_hfile$$.h"
$$ENDIF //AUTOMATION

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

$$IF(ABOUT)
/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

$$ENDIF //ABOUT
/////////////////////////////////////////////////////////////////////////////
// $$DLG_CLASS$$ dialog
$$IF(AUTOMATION)

IMPLEMENT_DYNAMIC($$DLG_CLASS$$, $$DLG_BASE_CLASS$$);
$$ENDIF //AUTOMATION

$$DLG_CLASS$$::$$DLG_CLASS$$(CWnd* pParent /*=NULL*/)
	: $$DLG_BASE_CLASS$$($$DLG_CLASS$$::IDD, pParent)
{
	//{{AFX_DATA_INIT($$DLG_CLASS$$)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
$$IF(VERBOSE)
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
$$ENDIF
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
$$IF(AUTOMATION)
	m_pAutoProxy = NULL;
$$ENDIF //AUTOMATION
}
$$IF(AUTOMATION)

$$DLG_CLASS$$::~$$DLG_CLASS$$()
{
$$IF(VERBOSE)
	// If there is an automation proxy for this dialog, set
	//  its back pointer to this dialog to NULL, so it knows
	//  the dialog has been deleted.
$$ENDIF //VERBOSE
	if (m_pAutoProxy != NULL)
		m_pAutoProxy->m_pDialog = NULL;
}
$$ENDIF //AUTOMATION

void $$DLG_CLASS$$::DoDataExchange(CDataExchange* pDX)
{
	$$DLG_BASE_CLASS$$::DoDataExchange(pDX);
	//{{AFX_DATA_MAP($$DLG_CLASS$$)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP($$DLG_CLASS$$, $$DLG_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$DLG_CLASS$$)
$$IF(ABOUT)
	ON_WM_SYSCOMMAND()
$$ENDIF
$$IF(HELP)
	ON_WM_DESTROY()
$$ENDIF
$$IF(AUTOMATION)
	ON_WM_CLOSE()
$$ENDIF
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$DLG_CLASS$$ message handlers

BOOL $$DLG_CLASS$$::OnInitDialog()
{
	$$DLG_BASE_CLASS$$::OnInitDialog();
$$IF(ABOUT)

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}
$$ENDIF //ABOUT

$$IF(VERBOSE)
	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
$$ENDIF //VERBOSE
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}
$$IF(ABOUT)

void $$DLG_CLASS$$::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		$$DLG_BASE_CLASS$$::OnSysCommand(nID, lParam);
	}
}
$$ENDIF //ABOUT
$$IF(HELP)

void $$DLG_CLASS$$::OnDestroy()
{
	WinHelp(0L, HELP_QUIT);
	$$DLG_BASE_CLASS$$::OnDestroy();
}
$$ENDIF //HELP

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void $$DLG_CLASS$$::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		$$DLG_BASE_CLASS$$::OnPaint();
	}
}

$$IF(VERBOSE)
// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
$$ENDIF
HCURSOR $$DLG_CLASS$$::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
$$IF(AUTOMATION)
$$IF(VERBOSE)

// Automation servers should not exit when a user closes the UI
//  if a controller still holds on to one of its objects.  These
//  message handlers make sure that if the proxy is still in use,
//  then the UI is hidden but the dialog remains around if it
//  is dismissed.
$$ENDIF //VERBOSE

void $$DLG_CLASS$$::OnClose() 
{
	if (CanExit())
		$$DLG_BASE_CLASS$$::OnClose();
}

void $$DLG_CLASS$$::OnOK() 
{
	if (CanExit())
		$$DLG_BASE_CLASS$$::OnOK();
}

void $$DLG_CLASS$$::OnCancel() 
{
	if (CanExit())
		$$DLG_BASE_CLASS$$::OnCancel();
}

BOOL $$DLG_CLASS$$::CanExit()
{
$$IF(VERBOSE)
	// If the proxy object is still around, then the automation
	//  controller is still holding on to this application.  Leave
	//  the dialog around, but hide its UI.
$$ENDIF //VERBOSE
	if (m_pAutoProxy != NULL)
	{
		ShowWindow(SW_HIDE);
		return FALSE;
	}

	return TRUE;
}
$$ENDIF //AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\cntritem.cpp ===
// $$cntritem_ifile$$.cpp : implementation of the $$CNTRITEM_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"

$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
#include "$$doc_hfile$$.h"
#include "$$view_hfile$$.h"
#include "$$cntritem_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$CNTRITEM_CLASS$$ implementation

IMPLEMENT_SERIAL($$CNTRITEM_CLASS$$, $$CNTRITEM_BASE_CLASS$$, 0)

$$IF(CRichEditView)
$$CNTRITEM_CLASS$$::$$CNTRITEM_CLASS$$(REOBJECT* preo, $$DOC_CLASS$$* pContainer)
	: $$CNTRITEM_BASE_CLASS$$(preo, pContainer)
$$ELSE //!CRichEditView
$$CNTRITEM_CLASS$$::$$CNTRITEM_CLASS$$($$DOC_CLASS$$* pContainer)
	: $$CNTRITEM_BASE_CLASS$$(pContainer)
$$ENDIF //CRichEditView
{
$$IF(VERBOSE)
	// TODO: add one-time construction code here
	
$$ENDIF
}

$$CNTRITEM_CLASS$$::~$$CNTRITEM_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: add cleanup code here
	
$$ENDIF
}
$$IF(!CRichEditView)

void $$CNTRITEM_CLASS$$::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	$$CNTRITEM_BASE_CLASS$$::OnChange(nCode, dwParam);
$$IF(VERBOSE)

	// When an item is being edited (either in-place or fully open)
	//  it sends OnChange notifications for changes in the state of the
	//  item or visual appearance of its content.

	// TODO: invalidate the item by calling UpdateAllViews
	//  (with hints appropriate to your application)

	GetDocument()->UpdateAllViews(NULL);
		// for now just update ALL views/no hints
$$ENDIF
}

BOOL $$CNTRITEM_CLASS$$::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);
$$IF(VERBOSE)

	// During in-place activation $$CNTRITEM_CLASS$$::OnChangeItemPosition
	//  is called by the server to change the position of the in-place
	//  window.  Usually, this is a result of the data in the server
	//  document changing such that the extent has changed or as a result
	//  of in-place resizing.
	//
	// The default here is to call the base class, which will call
	//  $$CNTRITEM_BASE_CLASS$$::SetItemRects to move the item
	//  to the new position.
$$ENDIF

	if (!$$CNTRITEM_BASE_CLASS$$::OnChangeItemPosition(rectPos))
		return FALSE;

$$IF(VERBOSE)
	// TODO: update any cache you may have of the item's rectangle/extent

$$ENDIF
	return TRUE;
}

$$IF(!ACTIVE_DOC_CONTAINER)
void $$CNTRITEM_CLASS$$::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);
$$IF(VERBOSE)

	// During in-place activation, $$CNTRITEM_CLASS$$::OnGetItemPosition
	//  will be called to determine the location of this item.  The default
	//  implementation created from AppWizard simply returns a hard-coded
	//  rectangle.  Usually, this rectangle would reflect the current
	//  position of the item relative to the view used for activation.
	//  You can obtain the view by calling $$CNTRITEM_CLASS$$::GetActiveView.

	// TODO: return correct rectangle (in pixels) in rPosition
$$ENDIF

	rPosition.SetRect(10, 10, 210, 210);
}
$$ENDIF

void $$CNTRITEM_CLASS$$::OnActivate()
{
$$IF(!ACTIVE_DOC_CONTAINER)
    // Allow only one inplace activate item per frame
    $$VIEW_CLASS$$* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    $$CNTRITEM_BASE_CLASS$$::OnActivate();
$$ENDIF
}

void $$CNTRITEM_CLASS$$::OnDeactivateUI(BOOL bUndoable)
{
	$$CNTRITEM_BASE_CLASS$$::OnDeactivateUI(bUndoable);

    // Hide the object if it is not an outside-in object
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void $$CNTRITEM_CLASS$$::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

$$IF(VERBOSE)
	// Call base class first to read in $$CNTRITEM_BASE_CLASS$$ data.
	// Since this sets up the m_pDocument pointer returned from
	//  $$CNTRITEM_CLASS$$::GetDocument, it is a good idea to call
	//  the base class Serialize first.
$$ENDIF
	$$CNTRITEM_BASE_CLASS$$::Serialize(ar);

$$IF(VERBOSE)
	// now store/retrieve data specific to $$CNTRITEM_CLASS$$
$$ENDIF
	if (ar.IsStoring())
	{
$$IF(VERBOSE)
		// TODO: add storing code here
$$ENDIF
	}
	else
	{
$$IF(VERBOSE)
		// TODO: add loading code here
$$ENDIF
	}
}
$$IF(CONTAINER_SERVER)

BOOL $$CNTRITEM_CLASS$$::CanActivate()
{
$$IF(VERBOSE)
	// Editing in-place while the server itself is being edited in-place
	//  does not work and is not supported.  So, disable in-place
	//  activation in this case.
$$ENDIF
	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(COleServerDoc)));
	if (pDoc->IsInPlaceActive())
		return FALSE;

$$IF(VERBOSE)
	// otherwise, rely on default behavior
$$ENDIF
	return COleClientItem::CanActivate();
}
$$ENDIF
$$ENDIF //!CRichEditView

/////////////////////////////////////////////////////////////////////////////
// $$CNTRITEM_CLASS$$ diagnostics

#ifdef _DEBUG
void $$CNTRITEM_CLASS$$::AssertValid() const
{
	$$CNTRITEM_BASE_CLASS$$::AssertValid();
}

void $$CNTRITEM_CLASS$$::Dump(CDumpContext& dc) const
{
	$$CNTRITEM_BASE_CLASS$$::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\childfrm.h ===
// $$child_frame_hfile$$.h : interface of the $$CHILD_FRAME_CLASS$$ class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

$$IF(PROJTYPE_EXPLORER)
class $$VIEW_CLASS$$;
$$ENDIF
$$IF(NODOCVIEW)
#include "$$wndview_hfile$$.h"
$$ENDIF

class $$CHILD_FRAME_CLASS$$ : public $$CHILD_FRAME_BASE_CLASS$$
{
	DECLARE_DYNCREATE($$CHILD_FRAME_CLASS$$)
public:
	$$CHILD_FRAME_CLASS$$();

// Attributes
$$IF(SPLITTER_MDI || PROJTYPE_EXPLORER)
protected:
	CSplitterWnd m_wndSplitter;
$$ENDIF //SPLITTER_MDI || EXPLORER
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$CHILD_FRAME_CLASS$$)
$$IF(SPLITTER_MDI || CHILD_FRAME_STYLES || PROJTYPE_EXPLORER || NODOCVIEW)
	public:
$$ENDIF
$$IF(SPLITTER_MDI || PROJTYPE_EXPLORER )
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
$$ENDIF //SPLITTER_MDI || PROJTYPE_EXPLORER
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
$$IF(CHILD_FRAME_MAXIMIZED || CHILD_FRAME_MINIMIZED)
	virtual void ActivateFrame(int nCmdShow);
$$ENDIF
$$IF(NODOCVIEW)
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
$$ENDIF
	//}}AFX_VIRTUAL

// Implementation
public:
$$IF(NODOCVIEW)
	// view for the client area of the frame.
	$$WNDVIEW_CLASS$$ m_wndView;
$$ENDIF
	virtual ~$$CHILD_FRAME_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
protected:
	$$VIEW_CLASS$$* GetRightPane();
$$ENDIF	// CListView
$$ENDIF // PROJTYPE_EXPLORER
// Generated message map functions
protected:
$$IF( REBAR )
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	CToolBar m_wndToolBar;
$$ENDIF // (ANY SERVER)
$$ENDIF // REBAR
	//{{AFX_MSG($$CHILD_FRAME_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
$$ENDIF
$$IF(NODOCVIEW)
	afx_msg void OnFileClose();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
$$ENDIF
	//}}AFX_MSG
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	afx_msg void OnUpdateViewStyles(CCmdUI* pCmdUI);
	afx_msg void OnViewStyle(UINT nCommandID);
$$ENDIF
$$ENDIF
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dlgres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by $$ROOT$$.RC
//
$$IF(PROJTYPE_DLG)
#define IDR_MAINFRAME					128
$$IF(ABOUT)
#define IDM_ABOUTBOX					0x0010
#define IDD_ABOUTBOX					100
$$ENDIF //ABOUT
$$IF(AUTOMATION)
#define IDP_OLE_INIT_FAILED				100
$$ENDIF //AUTOMATION
$$IF(ABOUT)
#define IDS_ABOUTBOX					101
$$ENDIF //ABOUT	
#define IDD_$$SAFE_ROOT$$_DIALOG				102
$$ENDIF //PROJTYPE_DLG
$$IF(SOCKETS)
$$IF(PROJTYPE_DLG)
#define IDP_SOCKETS_INIT_FAILED			103
$$ELSE //!PROJTYPE_DLG (i.e., PROJTYPE_DLL)
#define IDP_SOCKETS_INIT_FAILED			101
$$ENDIF //PROJTYPE_DLG
$$ENDIF //SOCKETS

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

$$IF(PROJTYPE_DLL || PROJTYPE_OCX)
#define _APS_NEXT_RESOURCE_VALUE	$$START_RES$$
#define _APS_NEXT_CONTROL_VALUE		$$START_RES$$
#define _APS_NEXT_SYMED_VALUE		$$START_RES$$
$$ELSE
#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
$$ENDIF
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dlgproxy.h ===
// $$dlgautoproxy_hfile$$.h : header file
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$DLG_CLASS$$;

/////////////////////////////////////////////////////////////////////////////
// $$DLGAUTOPROXY_CLASS$$ command target

class $$DLGAUTOPROXY_CLASS$$ : public $$DLGAUTOPROXY_BASE_CLASS$$
{
	DECLARE_DYNCREATE($$DLGAUTOPROXY_CLASS$$)

	$$DLGAUTOPROXY_CLASS$$();           // protected constructor used by dynamic creation

// Attributes
public:
	$$DLG_CLASS$$* m_pDialog;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$DLGAUTOPROXY_CLASS$$)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~$$DLGAUTOPROXY_CLASS$$();

	// Generated message map functions
	//{{AFX_MSG($$DLGAUTOPROXY_CLASS$$)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE($$DLGAUTOPROXY_CLASS$$)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH($$DLGAUTOPROXY_CLASS$$)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dlgroot.h ===
// $$root$$.h : main header file for the $$ROOT$$ application
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$:
// See $$root$$.cpp for the implementation of this class
//

class $$APP_CLASS$$ : public $$APP_BASE_CLASS$$
{
public:
	$$APP_CLASS$$();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$APP_CLASS$$)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG($$APP_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dlgroot.cpp ===
// $$root$$.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$dlg_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$

BEGIN_MESSAGE_MAP($$APP_CLASS$$, $$APP_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$APP_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
$$ENDIF
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ construction

$$APP_CLASS$$::$$APP_CLASS$$()
{
$$IF(VERBOSE)	
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
$$ENDIF
}

/////////////////////////////////////////////////////////////////////////////
// The one and only $$APP_CLASS$$ object

$$APP_CLASS$$ theApp;

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ initialization

BOOL $$APP_CLASS$$::InitInstance()
{
$$IF(SOCKETS)
	if (!AfxSocketInit())
	{
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //SOCKETS
$$IF(AUTOMATION)
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //AUTOMATION
$$IF(OLECTL)
	AfxEnableControlContainer();

$$ENDIF //OLECTL
	// Standard initialization
$$IF(VERBOSE)
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.
$$ENDIF

$$IF(3D)
#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

$$ENDIF //3D
$$IF(AUTOMATION)
$$IF(VERBOSE)
	// Parse the command line to see if launched as OLE server
$$ENDIF
	if (RunEmbedded() || RunAutomated())
	{
$$IF(VERBOSE)
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
$$ENDIF
		COleTemplateServer::RegisterAll();
	}
	else
	{
$$IF(VERBOSE)
		// When a server application is launched stand-alone, it is a good idea
		//  to update the system registry in case it has been damaged.
$$ENDIF
		COleObjectFactory::UpdateRegistryAll();
	}

$$ENDIF //AUTOMATION
	$$DLG_CLASS$$ dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
$$IF(VERBOSE)
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
$$ENDIF
	}
	else if (nResponse == IDCANCEL)
	{
$$IF(VERBOSE)
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
$$ENDIF
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dllroot.h ===
// $$root$$.h : main header file for the $$ROOT$$ DLL
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$
// See $$root$$.cpp for the implementation of this class
//

class $$APP_CLASS$$ : public $$APP_BASE_CLASS$$
{
public:
	$$APP_CLASS$$();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$APP_CLASS$$)
$$IF(SOCKETS || AUTOMATION)
	public:
	virtual BOOL InitInstance();
$$ENDIF //SOCKETS || AUTOMATION
	//}}AFX_VIRTUAL

	//{{AFX_MSG($$APP_CLASS$$)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\doc.cpp ===
// $$doc_ifile$$.cpp : implementation of the $$DOC_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"

$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
#include "$$doc_hfile$$.h"
$$IF(CONTAINER || CONTAINER_SERVER)
#include "$$cntritem_hfile$$.h"
$$ENDIF
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#include "$$srvritem_hfile$$.h"
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$

IMPLEMENT_DYNCREATE($$DOC_CLASS$$, $$DOC_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$DOC_CLASS$$, $$DOC_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$DOC_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
$$ENDIF
	//}}AFX_MSG_MAP
$$IF(CONTAINER || CONTAINER_SERVER)
	// Enable default OLE container implementation
$$IF(!CRichEditView)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, $$DOC_BASE_CLASS$$::OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, $$DOC_BASE_CLASS$$::OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, $$DOC_BASE_CLASS$$::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, $$DOC_BASE_CLASS$$::OnEditConvert)
$$ENDIF //!CRichEditView
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, $$DOC_BASE_CLASS$$::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, $$DOC_BASE_CLASS$$::OnEditLinks)
	ON_UPDATE_COMMAND_UI_RANGE(ID_OLE_VERB_FIRST, ID_OLE_VERB_LAST, $$DOC_BASE_CLASS$$::OnUpdateObjectVerbMenu)
$$ENDIF
$$IF(MAPI)
	ON_COMMAND(ID_FILE_SEND_MAIL, OnFileSendMail)
	ON_UPDATE_COMMAND_UI(ID_FILE_SEND_MAIL, OnUpdateFileSendMail)
$$ENDIF //MAPI
END_MESSAGE_MAP()

$$IF(AUTOMATION)
BEGIN_DISPATCH_MAP($$DOC_CLASS$$, $$DOC_BASE_CLASS$$)
	//{{AFX_DISPATCH_MAP($$DOC_CLASS$$)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//      DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

$$IF(VERBOSE)
// Note: we add support for IID_I$$Safe_root$$ to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {$$DISPIID_CLSID_ODL$$}
$$ENDIF //VERBOSE
static const IID IID_I$$Safe_root$$ =
$$DISPIID_CLSID$$;

BEGIN_INTERFACE_MAP($$DOC_CLASS$$, $$DOC_BASE_CLASS$$)
	INTERFACE_PART($$DOC_CLASS$$, IID_I$$Safe_root$$, Dispatch)
END_INTERFACE_MAP()

$$ENDIF //AUTOMATION
/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ construction/destruction

$$DOC_CLASS$$::$$DOC_CLASS$$()
{
$$IF(COMPFILE)
$$IF(VERBOSE)
	// Use OLE compound files
$$ENDIF
	EnableCompoundFile();

$$ENDIF //COMPFILE
$$IF(VERBOSE)
	// TODO: add one-time construction code here

$$ENDIF
$$IF(AUTOMATION)
	EnableAutomation();

	AfxOleLockApp();
$$ENDIF
}

$$DOC_CLASS$$::~$$DOC_CLASS$$()
{
$$IF(AUTOMATION)
	AfxOleUnlockApp();
$$ENDIF
}

BOOL $$DOC_CLASS$$::OnNewDocument()
{
	if (!$$DOC_BASE_CLASS$$::OnNewDocument())
		return FALSE;
$$IF(PROJTYPE_SDI)
$$IF(CEditView)

	((CEditView*)m_viewList.GetHead())->SetWindowText(NULL);
$$ENDIF //CEditView
$$ENDIF //PROJTYPE_SDI

$$IF(VERBOSE)
	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

$$ENDIF
	return TRUE;
}
$$IF(CRichEditView)

$$CNTRITEM_BASE_CLASS$$* $$DOC_CLASS$$::CreateClientItem(REOBJECT* preo) const
{
	// cast away constness of this
	return new $$CNTRITEM_CLASS$$(preo, ($$DOC_CLASS$$*) this);
}
$$ENDIF //CRichEditView
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ server implementation

COleServerItem* $$DOC_CLASS$$::OnGetEmbeddedItem()
{
$$IF(VERBOSE)
	// OnGetEmbeddedItem is called by the framework to get the COleServerItem
	//  that is associated with the document.  It is only called when necessary.

$$ENDIF
	$$SRVRITEM_CLASS$$* pItem = new $$SRVRITEM_CLASS$$(this);
	ASSERT_VALID(pItem);
	return pItem;
}
$$ENDIF
$$IF(ACTIVE_DOC_SERVER)

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ Active Document server implementation

CDocObjectServer *$$DOC_CLASS$$::GetDocObjectServer(LPOLEDOCUMENTSITE pDocSite)
{
	return new CDocObjectServer(this, pDocSite);
}
$$ENDIF


$$IF(!DB_NO_FILE)

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ serialization

void $$DOC_CLASS$$::Serialize(CArchive& ar)
{
$$IF(CEditView)
$$IF(VERBOSE)
	// CEditView contains an edit control which handles all serialization
$$ENDIF //VERBOSE
	((CEditView*)m_viewList.GetHead())->SerializeRaw(ar);
$$ELSE
	if (ar.IsStoring())
	{
$$IF(VERBOSE)
		// TODO: add storing code here
$$ENDIF
	}
	else
	{
$$IF(VERBOSE)
		// TODO: add loading code here
$$ENDIF
	}
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(VERBOSE)

	// Calling the base class $$DOC_BASE_CLASS$$ enables serialization
	//  of the container document's COleClientItem objects.
$$ENDIF
$$IF(CRichEditView)
	// TODO: set CRichEditDoc::m_bRTF = FALSE if you are serializing as text
$$ENDIF //CEditView
	$$DOC_BASE_CLASS$$::Serialize(ar);
$$ENDIF // Container
$$ENDIF // CEditView
}
$$ENDIF //!DB_NO_FILE

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ diagnostics

#ifdef _DEBUG
void $$DOC_CLASS$$::AssertValid() const
{
	$$DOC_BASE_CLASS$$::AssertValid();
}

void $$DOC_CLASS$$::Dump(CDumpContext& dc) const
{
	$$DOC_BASE_CLASS$$::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\doc.h ===
// $$doc_hfile$$.h : interface of the $$DOC_CLASS$$ class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF

$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)

class $$SRVRITEM_CLASS$$;
$$ENDIF // SERVERS

class $$DOC_CLASS$$ : public $$DOC_BASE_CLASS$$
{
protected: // create from serialization only
	$$DOC_CLASS$$();
	DECLARE_DYNCREATE($$DOC_CLASS$$)

// Attributes
public:
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	$$SRVRITEM_CLASS$$* GetEmbeddedItem()
		{ return ($$SRVRITEM_CLASS$$*)$$DOC_BASE_CLASS$$::GetEmbeddedItem(); }
$$ENDIF
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
	$$RECSET_CLASS$$ $$RECSET_VARIABLE$$;
$$ENDIF

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$DOC_CLASS$$)
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	protected:
	virtual COleServerItem* OnGetEmbeddedItem();
$$ENDIF
	public:
	virtual BOOL OnNewDocument();
$$IF(!DB_NO_FILE)
	virtual void Serialize(CArchive& ar);
$$ENDIF
	//}}AFX_VIRTUAL
$$IF(CRichEditView)
	virtual $$CNTRITEM_BASE_CLASS$$* CreateClientItem(REOBJECT* preo) const;
$$ENDIF //CRichEditView

// Implementation
public:
	virtual ~$$DOC_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
$$IF(ACTIVE_DOC_SERVER)
	virtual CDocObjectServer* GetDocObjectServer(LPOLEDOCUMENTSITE pDocSite);
$$ENDIF

// Generated message map functions
protected:
	//{{AFX_MSG($$DOC_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
$$IF(AUTOMATION)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH($$DOC_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
$$ENDIF
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
$$ENDIF
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\dllroot.cpp ===
// $$root$$.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
$$IF(EXTDLL)
#include <afxdllx.h>
$$ELSE // !EXTDLL
#include "$$root$$.h"
$$ENDIF //!EXTDLL

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

$$IF(EXTDLL)
$$ELSE
//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//
$$ENDIF

$$IF(EXTDLL)
static AFX_EXTENSION_MODULE $$safe_root$$DLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
$$IF(VERBOSE)
	// Remove this if you use lpReserved
$$ENDIF
	UNREFERENCED_PARAMETER(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("$$ROOT$$.DLL Initializing!\n");
		
$$IF(VERBOSE)
		// Extension DLL one-time initialization
$$ENDIF
		if (!AfxInitExtensionModule($$safe_root$$DLL, hInstance))
			return 0;

$$IF(VERBOSE)
		// Insert this DLL into the resource chain
		// NOTE: If this Extension DLL is being implicitly linked to by
		//  an MFC Regular DLL (such as an ActiveX Control)
		//  instead of an MFC application, then you will want to
		//  remove this line from DllMain and put it in a separate
		//  function exported from this Extension DLL.  The Regular DLL
		//  that uses this Extension DLL should then explicitly call that
		//  function to initialize this Extension DLL.  Otherwise,
		//  the CDynLinkLibrary object will not be attached to the
		//  Regular DLL's resource chain, and serious problems will
		//  result.

$$ENDIF
		new CDynLinkLibrary($$safe_root$$DLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("$$ROOT$$.DLL Terminating!\n");
$$IF(VERBOSE)
		// Terminate the library before destructors are called
$$ENDIF
		AfxTermExtensionModule($$safe_root$$DLL);
	}
$$IF(VERBOSE)
	return 1;   // ok
$$ELSE
	return 1;
$$ENDIF
}
$$ELSE //!EXTDLL
/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$

BEGIN_MESSAGE_MAP($$APP_CLASS$$, $$APP_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$APP_CLASS$$)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ construction

$$APP_CLASS$$::$$APP_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
$$ENDIF
}

/////////////////////////////////////////////////////////////////////////////
// The one and only $$APP_CLASS$$ object

$$APP_CLASS$$ theApp;
$$IF(AUTOMATION || SOCKETS)

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ initialization

BOOL $$APP_CLASS$$::InitInstance()
{
$$IF(SOCKETS)
	if (!AfxSocketInit())
	{
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //SOCKETS
$$IF(AUTOMATION)
	// Register all OLE server (factories) as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleObjectFactory::RegisterAll();

$$ENDIF //AUTOMATION
	return TRUE;
}
$$ENDIF //AUTOMATION || SOCKETS
$$IF(AUTOMATION)

/////////////////////////////////////////////////////////////////////////////
// Special entry points required for inproc servers

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return AfxDllCanUnloadNow();
}

// by exporting DllRegisterServer, you can use regsvr.exe
STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	COleObjectFactory::UpdateRegistryAll();
	return S_OK;
}
$$ENDIF //AUTOMATION
$$ENDIF //EXTDLL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\frame.cpp ===
// $$frame_ifile$$.cpp : implementation of the $$FRAME_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$frame_hfile$$.h"
$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)
#include "$$treeview_hfile$$.h"
#include "$$view_hfile$$.h"
$$ENDIF
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$FRAME_CLASS$$

$$IF(PROJTYPE_MDI || NODOCVIEW)
IMPLEMENT_DYNAMIC($$FRAME_CLASS$$, $$FRAME_BASE_CLASS$$)
$$ELSE
IMPLEMENT_DYNCREATE($$FRAME_CLASS$$, $$FRAME_BASE_CLASS$$)
$$ENDIF

BEGIN_MESSAGE_MAP($$FRAME_CLASS$$, $$FRAME_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$FRAME_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
$$ENDIF
	ON_WM_CREATE()
$$IF(PROJTYPE_SDI)
$$IF(NODOCVIEW)
	ON_WM_SETFOCUS()
$$ENDIF 
$$ENDIF 
	//}}AFX_MSG_MAP
$$IF(HELP)
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, $$FRAME_BASE_CLASS$$::OnHelpFinder)
	ON_COMMAND(ID_HELP, $$FRAME_BASE_CLASS$$::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, $$FRAME_BASE_CLASS$$::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, $$FRAME_BASE_CLASS$$::OnHelpFinder)
$$ENDIF
$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	ON_UPDATE_COMMAND_UI_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnUpdateViewStyles)
	ON_COMMAND_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnViewStyle)
$$ENDIF
$$ENDIF
$$ENDIF
END_MESSAGE_MAP()
$$IF(STATUSBAR)

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
$$IF(DO_KANA)
	ID_INDICATOR_KANA,
$$ENDIF	// DO_KANA
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};
$$ENDIF //STATUSBAR

/////////////////////////////////////////////////////////////////////////////
// $$FRAME_CLASS$$ construction/destruction

$$FRAME_CLASS$$::$$FRAME_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: add member initialization code here
	
$$ENDIF
}

$$FRAME_CLASS$$::~$$FRAME_CLASS$$()
{
}

int $$FRAME_CLASS$$::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if ($$FRAME_BASE_CLASS$$::OnCreate(lpCreateStruct) == -1)
		return -1;
$$IF(PROJTYPE_SDI)
$$IF(NODOCVIEW)
	// create a view to occupy the client area of the frame
	if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
		CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
	{
		TRACE0("Failed to create view window\n");
		return -1;
	}
$$ENDIF 
$$ENDIF //SDI + NODOCVIEW
$$IF(TOOLBAR)
	
$$IF(REBAR)
	if (!m_wndToolBar.CreateEx(this) ||
$$ELSE
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
$$ENDIF //REBAR
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}
$$IF(REBAR)
$$IF( CONTAINER || CONTAINER_SERVER)
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() & ~CBRS_HIDE_INPLACE);
$$ENDIF // ANY CONTAINER
	if (!m_wndDlgBar.Create(this, IDR_MAINFRAME, 
		CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
	{
		TRACE0("Failed to create dialogbar\n");
		return -1;		// fail to create
	}

	if (!m_wndReBar.Create(this) ||
		!m_wndReBar.AddBar(&m_wndToolBar) ||
		!m_wndReBar.AddBar(&m_wndDlgBar))
	{
		TRACE0("Failed to create rebar\n");
		return -1;      // fail to create
	}
$$IF( CONTAINER || CONTAINER_SERVER)
	m_wndReBar.SetBarStyle(m_wndReBar.GetBarStyle() & ~CBRS_HIDE_INPLACE);
$$ENDIF// ANY CONTAINER
$$ENDIF //REBAR
$$ENDIF //TOOLBAR
$$IF(STATUSBAR)

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}
$$ENDIF //STATUSBAR
$$IF(TOOLBAR)

$$IF(REBAR)
$$IF(VERBOSE)
	// TODO: Remove this if you don't want tool tips
$$ENDIF
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	m_wndDlgBar.SetBarStyle(m_wndDlgBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);
$$ENDIF//MINI_SERVER || FULL_SERVER || CONTAINER_SERVER
$$ELSE
$$IF(VERBOSE)
	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
$$ENDIF
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
$$ENDIF //REBAR
$$ENDIF //TOOLBAR	

	return 0;
}
$$IF(SPLITTER_SDI || PROJTYPE_EXPLORER )
$$IF(PROJTYPE_SDI)

BOOL $$FRAME_CLASS$$::OnCreateClient(LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
$$IF(PROJTYPE_EXPLORER)
	// create splitter window
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
		return FALSE;

	if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS($$TREEVIEW_CLASS$$), CSize(100, 100), pContext) ||
		!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS($$VIEW_CLASS$$), CSize(100, 100), pContext))
	{
		m_wndSplitter.DestroyWindow();
		return FALSE;
	}

	return TRUE;
$$ELSE //!PROJTYPE_EXPLORER
	return m_wndSplitter.Create(this,
$$IF(VERBOSE)
		2, 2,               // TODO: adjust the number of rows, columns
		CSize(10, 10),      // TODO: adjust the minimum pane size
$$ELSE //!VERBOSE
		2, 2,
		CSize(10, 10),
$$ENDIF //VERBOSE
		pContext);
$$ENDIF //PROJTYPE_EXPLORER
}
$$ENDIF //SDI
$$ENDIF //SPLITTER || EXPLORER

BOOL $$FRAME_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !$$FRAME_BASE_CLASS$$::PreCreateWindow(cs) )
		return FALSE;
$$IF(VERBOSE)
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

$$ENDIF //VERBOSE
$$IF(FRAME_STYLES)
	cs.style = WS_OVERLAPPED | WS_CAPTION | FWS_ADDTOTITLE
		$$FRAME_STYLE_FLAGS$$;

$$ENDIF //FRAME_STYLES
$$IF(PROJTYPE_SDI)
$$IF(NODOCVIEW)
	cs.dwExStyle &= ~WS_EX_CLIENTEDGE;
	cs.lpszClass = AfxRegisterWndClass(0);
$$ENDIF 
$$ENDIF //SDI + NODOCVIEW
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// $$FRAME_CLASS$$ diagnostics

#ifdef _DEBUG
void $$FRAME_CLASS$$::AssertValid() const
{
	$$FRAME_BASE_CLASS$$::AssertValid();
}

void $$FRAME_CLASS$$::Dump(CDumpContext& dc) const
{
	$$FRAME_BASE_CLASS$$::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$FRAME_CLASS$$ message handlers
$$IF(PROJTYPE_SDI)
$$IF(NODOCVIEW)
void $$FRAME_CLASS$$::OnSetFocus(CWnd* pOldWnd)
{
	// forward focus to the view window
	m_wndView.SetFocus();
}

BOOL $$FRAME_CLASS$$::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// let the view have first crack at the command
	if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// otherwise, do default handling
	return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}
$$ENDIF 
$$ENDIF //SDI + NODOCVIEW

$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
$$VIEW_CLASS$$* $$FRAME_CLASS$$::GetRightPane()
{
	CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
	$$VIEW_CLASS$$* pView = DYNAMIC_DOWNCAST($$VIEW_CLASS$$, pWnd);
	return pView;
}

void $$FRAME_CLASS$$::OnUpdateViewStyles(CCmdUI* pCmdUI)
{
$$IF(VERBOSE)
	// TODO: customize or extend this code to handle choices on the
	// View menu.
$$ENDIF //VERBOSE

	$$VIEW_CLASS$$* pView = GetRightPane(); 

$$IF(VERBOSE)
	// if the right-hand pane hasn't been created or isn't a view,
	// disable commands in our range
$$ENDIF //VERBOSE

	if (pView == NULL)
		pCmdUI->Enable(FALSE);
	else
	{
		DWORD dwStyle = pView->GetStyle() & LVS_TYPEMASK;

$$IF(VERBOSE)
		// if the command is ID_VIEW_LINEUP, only enable command
		// when we're in LVS_ICON or LVS_SMALLICON mode

$$ENDIF //VERBOSE
		if (pCmdUI->m_nID == ID_VIEW_LINEUP)
		{
			if (dwStyle == LVS_ICON || dwStyle == LVS_SMALLICON)
				pCmdUI->Enable();
			else
				pCmdUI->Enable(FALSE);
		}
		else
		{
$$IF(VERBOSE)
			// otherwise, use dots to reflect the style of the view
$$ENDIF //VERBOSE
			pCmdUI->Enable();
			BOOL bChecked = FALSE;

			switch (pCmdUI->m_nID)
			{
			case ID_VIEW_DETAILS:
				bChecked = (dwStyle == LVS_REPORT);
				break;

			case ID_VIEW_SMALLICON:
				bChecked = (dwStyle == LVS_SMALLICON);
				break;

			case ID_VIEW_LARGEICON:
				bChecked = (dwStyle == LVS_ICON);
				break;

			case ID_VIEW_LIST:
				bChecked = (dwStyle == LVS_LIST);
				break;

			default:
				bChecked = FALSE;
				break;
			}

			pCmdUI->SetRadio(bChecked ? 1 : 0);
		}
	}
}


void $$FRAME_CLASS$$::OnViewStyle(UINT nCommandID)
{
$$IF(VERBOSE)
	// TODO: customize or extend this code to handle choices on the
	// View menu.
$$ENDIF //VERBOSE
	$$VIEW_CLASS$$* pView = GetRightPane();

$$IF(VERBOSE)
	// if the right-hand pane has been created and is a $$VIEW_CLASS$$,
	// process the menu commands...
$$ENDIF //VERBOSE
	if (pView != NULL)
	{
		DWORD dwStyle = -1;

		switch (nCommandID)
		{
		case ID_VIEW_LINEUP:
			{
$$IF(VERBOSE)
				// ask the list control to snap to grid
$$ENDIF //VERBOSE
				CListCtrl& refListCtrl = pView->GetListCtrl();
				refListCtrl.Arrange(LVA_SNAPTOGRID);
			}
			break;

$$IF(VERBOSE)
		// other commands change the style on the list control
$$ENDIF //VERBOSE
		case ID_VIEW_DETAILS:
			dwStyle = LVS_REPORT;
			break;

		case ID_VIEW_SMALLICON:
			dwStyle = LVS_SMALLICON;
			break;

		case ID_VIEW_LARGEICON:
			dwStyle = LVS_ICON;
			break;

		case ID_VIEW_LIST:
			dwStyle = LVS_LIST;
			break;
		}

$$IF(VERBOSE)
		// change the style; window will repaint automatically
$$ENDIF //VERBOSE
		if (dwStyle != -1)
			pView->ModifyStyle(LVS_TYPEMASK, dwStyle);
	}
}
$$ENDIF
$$ENDIF
$$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\ipframe.cpp ===
// $$ipframe_ifile$$.cpp : implementation of the $$IPFRAME_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$ipframe_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$IPFRAME_CLASS$$

IMPLEMENT_DYNCREATE($$IPFRAME_CLASS$$, $$IPFRAME_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$IPFRAME_CLASS$$, $$IPFRAME_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$IPFRAME_CLASS$$)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
$$IF(HELP)
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, $$IPFRAME_BASE_CLASS$$::OnHelpFinder)
	ON_COMMAND(ID_HELP, $$IPFRAME_BASE_CLASS$$::OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, $$IPFRAME_BASE_CLASS$$::OnHelpFinder)
	ON_COMMAND(ID_CONTEXT_HELP, $$IPFRAME_BASE_CLASS$$::OnContextHelp)
$$ENDIF
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$IPFRAME_CLASS$$ construction/destruction

$$IPFRAME_CLASS$$::$$IPFRAME_CLASS$$()
{
}

$$IPFRAME_CLASS$$::~$$IPFRAME_CLASS$$()
{
}

int $$IPFRAME_CLASS$$::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if ($$IPFRAME_BASE_CLASS$$::OnCreate(lpCreateStruct) == -1)
		return -1;

$$IF(VERBOSE)
	// CResizeBar implements in-place resizing.
$$ENDIF
	if (!m_wndResizeBar.Create(this))
	{
		TRACE0("Failed to create resize bar\n");
		return -1;      // fail to create
	}

$$IF(VERBOSE)
	// By default, it is a good idea to register a drop-target that does
	//  nothing with your frame window.  This prevents drops from
	//  "falling through" to a container that supports drag-drop.
$$ENDIF
	m_dropTarget.Register(this);

	return 0;
}

$$IF(TOOLBAR)
$$IF(VERBOSE)
// OnCreateControlBars is called by the framework to create control bars on the
//  container application's windows.  pWndFrame is the top level frame window of
//  the container and is always non-NULL.  pWndDoc is the doc level frame window
//  and will be NULL when the container is an SDI application.  A server
//  application can place MFC control bars on either window.
$$ENDIF
BOOL $$IPFRAME_CLASS$$::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc)
{
$$IF(VERBOSE)
	// Remove this if you use pWndDoc
$$ENDIF
	UNREFERENCED_PARAMETER(pWndDoc);

$$IF(VERBOSE)
	// Set owner to this window, so messages are delivered to correct app
$$ENDIF
	m_wndToolBar.SetOwner(this);

$$IF(VERBOSE)
	// Create toolbar on client's frame window
$$ENDIF
$$IF(REBAR)
	if (!m_wndToolBar.CreateEx(pWndFrame) ||
$$ELSE
	if (!m_wndToolBar.CreateEx(pWndFrame, TBSTYLE_FLAT,WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
$$ENDIF
$$IF(PROJTYPE_MDI)
		!m_wndToolBar.LoadToolBar(IDR_$$DOC$$TYPE_SRVR_IP))
$$ELSE
		!m_wndToolBar.LoadToolBar(IDR_SRVR_INPLACE))
$$ENDIF
	{
		TRACE0("Failed to create toolbar\n");
		return FALSE;
	}

$$IF(REBAR)
$$IF(VERBOSE)
	// Set owner to this window, so messages are delivered to correct app
$$ENDIF
	m_wndDlgBar.SetOwner(this);

$$IF(VERBOSE)
	// Create dialog bar on client's frame window
$$ENDIF
$$IF(PROJTYPE_MDI)
	if (!m_wndDlgBar.Create(pWndFrame, IDR_$$DOC$$TYPE_SRVR_IP, 
$$ELSE
	if (!m_wndDlgBar.Create(pWndFrame, IDR_SRVR_INPLACE,
$$ENDIF
		CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
	{
		TRACE0("Failed to create dialogbar\n");
		return FALSE;
	}

$$IF(VERBOSE)
	// Set the owner of this window, so messages are delivered to correct app
$$ENDIF
	m_wndReBar.SetOwner(this);

$$IF(VERBOSE)
	// Create a rebar on client's frame window
$$ENDIF
	if (!m_wndReBar.Create(pWndFrame) ||
		!m_wndReBar.AddBar(&m_wndToolBar) ||
		!m_wndReBar.AddBar(&m_wndDlgBar))
	{
		TRACE0("Failed to create rebar\n");
		return FALSE;
	}

$$IF(VERBOSE)
	// TODO: Remove this if you don't want tool tips
$$ENDIF
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);
	m_wndDlgBar.SetBarStyle(m_wndDlgBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);
$$ELSE
$$IF(VERBOSE)
	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
$$ENDIF
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->DockControlBar(&m_wndToolBar);
$$ENDIF

	return TRUE;
}

$$ENDIF //TOOLBAR
BOOL $$IPFRAME_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
$$IF(VERBOSE)
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

$$ENDIF //VERBOSE
	return $$IPFRAME_BASE_CLASS$$::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// $$IPFRAME_CLASS$$ diagnostics

#ifdef _DEBUG
void $$IPFRAME_CLASS$$::AssertValid() const
{
	$$IPFRAME_BASE_CLASS$$::AssertValid();
}

void $$IPFRAME_CLASS$$::Dump(CDumpContext& dc) const
{
	$$IPFRAME_BASE_CLASS$$::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$IPFRAME_CLASS$$ commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\frame.h ===
// $$frame_hfile$$.h : interface of the $$FRAME_CLASS$$ class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)

class $$VIEW_CLASS$$;
$$ELIF(NODOCVIEW)

#include "$$wndview_hfile$$.h"
$$ENDIF
$$ENDIF 

$$IF(PROJTYPE_MDI)
class $$FRAME_CLASS$$ : public $$FRAME_BASE_CLASS$$
{
	DECLARE_DYNAMIC($$FRAME_CLASS$$)
public:
	$$FRAME_CLASS$$();
$$ELSE // SDI
class $$FRAME_CLASS$$ : public $$FRAME_BASE_CLASS$$
{
	
$$IF(NODOCVIEW)
public:
	$$FRAME_CLASS$$();
protected: 
	DECLARE_DYNAMIC($$FRAME_CLASS$$)
$$ELSE
protected: // create from serialization only
	$$FRAME_CLASS$$();
	DECLARE_DYNCREATE($$FRAME_CLASS$$)
$$ENDIF
$$ENDIF // PROJTYPEMDI

// Attributes
$$IF(SPLITTER_SDI || PROJTYPE_EXPLORER)
$$IF(PROJTYPE_SDI)
protected:
	CSplitterWnd m_wndSplitter;
$$ENDIF 
$$ENDIF //SPLITTER_SDI
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$FRAME_CLASS$$)
$$IF(SPLITTER_SDI || FRAME_STYLES || PROJTYPE_EXPLORER)
	public:
$$ENDIF
$$IF(SPLITTER_SDI || PROJTYPE_EXPLORER)
$$IF(PROJTYPE_SDI)
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
$$ENDIF 
$$ENDIF
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
$$IF(NODOCVIEW)
$$IF(PROJTYPE_SDI)
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
$$ENDIF 
$$ENDIF
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~$$FRAME_CLASS$$();
$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	$$VIEW_CLASS$$* GetRightPane();
$$ENDIF	// CListView
$$ENDIF	// PROJTYPE_EXPLORER
$$ENDIF	// PROJTYPE_SDI
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
$$IF(TOOLBAR || STATUSBAR || REBAR)

protected:  // control bar embedded members
$$IF(STATUSBAR)	
	CStatusBar  m_wndStatusBar;
$$ENDIF //STATUSBAR
$$IF(TOOLBAR)
	CToolBar    m_wndToolBar;
$$ENDIF //TOOLBAR
$$IF(REBAR)
	CReBar      m_wndReBar;
	CDialogBar      m_wndDlgBar;
$$ENDIF //REBAR
$$ENDIF //TOOLBAR || STATUSBAR || REBAR
$$IF(NODOCVIEW)
$$IF(PROJTYPE_SDI)
	$$WNDVIEW_CLASS$$    m_wndView;
$$ENDIF 
$$ENDIF

// Generated message map functions
protected:
	//{{AFX_MSG($$FRAME_CLASS$$)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
$$IF(NODOCVIEW)
$$IF(PROJTYPE_SDI)
	afx_msg void OnSetFocus(CWnd *pOldWnd);
$$ENDIF 
$$ENDIF
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
$$ENDIF
	//}}AFX_MSG
$$IF(PROJTYPE_EXPLORER)
$$IF(PROJTYPE_SDI)
$$IF(CListView)
	afx_msg void OnUpdateViewStyles(CCmdUI* pCmdUI);
	afx_msg void OnViewStyle(UINT nCommandID);
$$ENDIF
$$ENDIF
$$ENDIF
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\recset.cpp ===
// $$recset_hfile$$.cpp : implementation of the $$RECSET_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$recset_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$RECSET_CLASS$$ implementation

$$IF(!OLEDB)
$$IF(DAO)
IMPLEMENT_DYNAMIC($$RECSET_CLASS$$, CDaoRecordset)
$$ELSE
IMPLEMENT_DYNAMIC($$RECSET_CLASS$$, CRecordset)
$$ENDIF

$$IF(DAO)
$$RECSET_CLASS$$::$$RECSET_CLASS$$(CDaoDatabase* pdb)
	: CDaoRecordset(pdb)
$$ELSE
$$RECSET_CLASS$$::$$RECSET_CLASS$$(CDatabase* pdb)
	: CRecordset(pdb)
$$ENDIF
{
	//{{AFX_FIELD_INIT($$RECSET_CLASS$$)
$$RECSET_VAR_BINDINGS$$
	//}}AFX_FIELD_INIT
	m_nDefaultType = $$DB_TABLE_TYPE$$;$$PARAM_VAR_BINDINGS$$
$$IF(DAO)
$$IF(DB_NO_DETECT)
	m_bCheckCacheForDirtyFields = FALSE;
$$ENDIF // DB_NO_DETECT
$$ENDIF // DAO
}

$$IF(DAO)
CString $$RECSET_CLASS$$::GetDefaultDBName()
{
	return _T("$$DB_CONNECT$$");
}

$$ELSE
CString $$RECSET_CLASS$$::GetDefaultConnect()
{
	return _T("ODBC;DSN=$$DB_CONNECT$$");
}
$$ENDIF

CString $$RECSET_CLASS$$::GetDefaultSQL()
{
	return _T("$$DB_SOURCE$$");
}

$$IF(DAO)
void $$RECSET_CLASS$$::DoFieldExchange(CDaoFieldExchange* pFX)
$$ELSE
void $$RECSET_CLASS$$::DoFieldExchange(CFieldExchange* pFX)
$$ENDIF
{
	//{{AFX_FIELD_MAP($$RECSET_CLASS$$)
$$IF(DAO)
	pFX->SetFieldType(CDaoFieldExchange::outputColumn);
$$ELSE
	pFX->SetFieldType(CFieldExchange::outputColumn);
$$ENDIF
$$RECSET_RFX$$
	//}}AFX_FIELD_MAP$$PARAM_RFX$$
}

/////////////////////////////////////////////////////////////////////////////
// $$RECSET_CLASS$$ diagnostics

#ifdef _DEBUG
void $$RECSET_CLASS$$::AssertValid() const
{
$$IF(DAO)
	CDaoRecordset::AssertValid();
$$ELSE
	CRecordset::AssertValid();
$$ENDIF
}

void $$RECSET_CLASS$$::Dump(CDumpContext& dc) const
{
$$IF(DAO)
	CDaoRecordset::Dump(dc);
$$ELSE
	CRecordset::Dump(dc);
$$ENDIF
}
#endif //_DEBUG
$$ENDIF //OLEDB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by $$ROOT$$.RC
//
$$IF(PROJTYPE_MDI)
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#define IDR_$$DOC$$TYPE_SRVR_IP		4
#define IDR_$$DOC$$TYPE_SRVR_EMB		5
$$ENDIF//MINI_SERVER || FULL_SERVER || CONTAINER_SERVER
$$IF(CONTAINER || CONTAINER_SERVER)
#define IDR_$$DOC$$TYPE_CNTR_IP		6
$$ENDIF//CONTAINER || CONTAINER_SERVER
$$ELSE //MDI
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#define IDR_SRVR_INPLACE			4
#define IDR_SRVR_EMBEDDED			5
$$ENDIF//MINI_SERVER || FULL_SERVER || CONTAINER_SERVER
$$IF(CONTAINER || CONTAINER_SERVER)
#define IDR_CNTR_INPLACE			6
$$ENDIF//CONTAINER || CONTAINER_SERVER
$$ENDIF//!MDI
#define IDD_ABOUTBOX				100
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
#define IDD_$$SAFE_ROOT$$_FORM			101
$$ENDIF
$$IF(CONTAINER || MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || AUTOMATION)
#define IDP_OLE_INIT_FAILED			100
$$IF(MINI_SERVER)
#define IDP_USE_INSERT_OBJECT		101
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
#define IDP_FAILED_TO_CREATE		102
#define ID_CANCEL_EDIT_CNTR			32768
$$ENDIF
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#define ID_CANCEL_EDIT_SRVR			32769
$$ENDIF
$$ENDIF
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#define IDP_FAILED_OPEN_DATABASE	103
$$ENDIF
$$IF(SOCKETS)
#define IDP_SOCKETS_INIT_FAILED		104
$$ENDIF //SOCKETS
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
#define ID_VIEW_ARRANGE				127
$$ENDIF 
$$ENDIF 
#define IDR_MAINFRAME				128
#define IDR_$$DOC$$TYPE				129

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
$$IF(3D)
#define _APS_3D_CONTROLS			1
$$ENDIF //3D
$$IF(PROJTYPE_DLL || PROJTYPE_OCX)
#define _APS_NEXT_RESOURCE_VALUE	$$START_RES$$
#define _APS_NEXT_CONTROL_VALUE		$$START_RES$$
#define _APS_NEXT_SYMED_VALUE		$$START_RES$$
$$ELSE
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
$$ENDIF //(PROJTYPE_DLL || PROJTYPE_OCX)
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\recset.h ===
// $$recset_hfile$$.h : interface of the $$RECSET_CLASS$$ class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

$$IF(!OLEDB)
$$IF(DAO)
class $$RECSET_CLASS$$ : public CDaoRecordset
$$ELSE
class $$RECSET_CLASS$$ : public CRecordset
$$ENDIF
{
public:
$$IF(DAO)
	$$RECSET_CLASS$$(CDaoDatabase* pDatabase = NULL);
$$ELSE
	$$RECSET_CLASS$$(CDatabase* pDatabase = NULL);
$$ENDIF
	DECLARE_DYNAMIC($$RECSET_CLASS$$)

// Field/Param Data
$$IF(DAO)
	//{{AFX_FIELD($$RECSET_CLASS$$, CDaoRecordset)
$$ELSE
	//{{AFX_FIELD($$RECSET_CLASS$$, CRecordset)
$$ENDIF
$$RECSET_VARS$$
	//}}AFX_FIELD$$PARAM_VARS$$

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$RECSET_CLASS$$)
	public:
$$IF(DAO)
	virtual CString GetDefaultDBName();		// REVIEW:  Get a comment here
$$ELSE
	virtual CString GetDefaultConnect();	// Default connection string
$$ENDIF
	virtual CString GetDefaultSQL(); 	// default SQL for Recordset
$$IF(DAO)
	virtual void DoFieldExchange(CDaoFieldExchange* pFX);	// RFX support
$$ELSE
	virtual void DoFieldExchange(CFieldExchange* pFX);	// RFX support
$$ENDIF
	//}}AFX_VIRTUAL

// Implementation
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

};

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
$$ELSE  // !!OLEDB --> OLEDB
class $$DB_TABLECLASS$$
{
public:
	$$DB_TABLECLASS$$()
	{
		memset( (void*)this, 0, sizeof(*this) );
	};

$$DB_VARSINFO$$

BEGIN_COLUMN_MAP($$DB_TABLECLASS$$)
$$DB_COLSINFO$$
END_COLUMN_MAP()

};

class $$RECSET_CLASS$$ : public CCommand<CAccessor<$$DB_TABLECLASS$$> >
{
public:

	HRESULT Open()
	{
		CDataSource db;
		CSession	session;
		HRESULT		hr;

		CDBPropSet	dbinit(DBPROPSET_DBINIT);
$$DB_OPEN$$
		hr = db.OpenWithServiceComponents("$$DB_CONNECT$$", &dbinit);
		if (FAILED(hr))
			return hr;

		hr = session.Open(db);
		if (FAILED(hr))
			return hr;

		CDBPropSet	propset(DBPROPSET_ROWSET);
		propset.AddProperty(DBPROP_CANFETCHBACKWARDS, true);
		propset.AddProperty(DBPROP_IRowsetScroll, true);
		propset.AddProperty(DBPROP_IRowsetChange, true);
		propset.AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE | DBPROPVAL_UP_INSERT | DBPROPVAL_UP_DELETE );

		hr = CCommand<CAccessor<$$DB_TABLECLASS$$> >::Open(session, "$$DB_SOURCE$$", &propset);
		if (FAILED(hr))
			return hr;

		return MoveNext();
	}

};

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
$$ENDIF // !OLEDB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\ipframe.h ===
// $$ipframe_hfile$$.h : interface of the $$IPFRAME_CLASS$$ class
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$IPFRAME_CLASS$$ : public $$IPFRAME_BASE_CLASS$$
{
	DECLARE_DYNCREATE($$IPFRAME_CLASS$$)
public:
	$$IPFRAME_CLASS$$();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$IPFRAME_CLASS$$)
$$IF(TOOLBAR)
	public:
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
$$ENDIF
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~$$IPFRAME_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
$$IF(TOOLBAR)
	CToolBar    m_wndToolBar;
$$IF(REBAR)
	CDialogBar m_wndDlgBar;
	CReBar m_wndReBar;
$$ENDIF
$$ENDIF
	COleDropTarget	m_dropTarget;
	COleResizeBar   m_wndResizeBar;

// Generated message map functions
protected:
	//{{AFX_MSG($$IPFRAME_CLASS$$)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\root.cpp ===
// $$root$$.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$frame_hfile$$.h"
$$IF(MDICHILD)
#include "$$child_frame_hfile$$.h"
$$ENDIF //MDICHILD
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#include "$$ipframe_hfile$$.h"
$$ENDIF
$$IF(CRecordView || CDaoRecordView ||COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
$$IF(!NODOCVIEW)
#include "$$doc_hfile$$.h"
$$IF(PROJTYPE_EXPLORER)
#include "$$treeview_hfile$$.h"
$$ELSE
#include "$$view_hfile$$.h"
$$ENDIF
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$

BEGIN_MESSAGE_MAP($$APP_CLASS$$, $$APP_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$APP_CLASS$$)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
$$ENDIF
$$IF(NODOCVIEW)
$$IF(PROJTYPE_MDI)
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
$$ENDIF //PROJTYPE_MDI
$$ENDIF //NODOCVIEW
	//}}AFX_MSG_MAP
$$IF(!NODOCVIEW)
$$IF(!DB_NO_FILE)
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, $$APP_BASE_CLASS$$::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, $$APP_BASE_CLASS$$::OnFileOpen)
$$ENDIF //!DB_NO_FILE
$$ENDIF //!NODOCVIEW
$$IF(PRINT)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, $$APP_BASE_CLASS$$::OnFilePrintSetup)
$$ENDIF //PRINT
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ construction

$$APP_CLASS$$::$$APP_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
$$ENDIF
}

$$IF(ATL_SUPPORT)
// ATL Module object
CComModule _Module;

$$ENDIF
/////////////////////////////////////////////////////////////////////////////
// The one and only $$APP_CLASS$$ object

$$APP_CLASS$$ theApp;
$$IF(FULL_SERVER || MINI_SERVER || CONTAINER_SERVER || AUTOMATION)

$$IF(VERBOSE)
// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {$$APP_CLSID_REG$$}
$$ENDIF
static const CLSID clsid =
$$APP_CLSID$$;
$$ENDIF

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ initialization

BOOL $$APP_CLASS$$::InitInstance()
{
$$IF(OLEDB)
	CoInitialize(NULL);
$$ENDIF // OLEDB
$$IF(SOCKETS)
	if (!AfxSocketInit())
	{
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //SOCKETS
$$IF(CONTAINER || CONTAINER_SERVER || MINI_SERVER || FULL_SERVER || AUTOMATION)
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //CONTAINER || CONTAINER_SERVER || MINI_SERVER || FULL_SERVER || AUTOMATION
$$IF(OLECTL)
	AfxEnableControlContainer();

$$ENDIF //OLECTL
	// Standard initialization
$$IF(VERBOSE)
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.
$$ENDIF
$$IF(3D)

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif
$$ENDIF //3D

	// Change the registry key under which our settings are stored.
$$IF(VERBOSE)
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
$$ENDIF
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

$$IF(!NODOCVIEW)
	LoadStdProfileSettings($$SIZE_MRU$$);  // Load standard INI file options (including MRU)
$$ENDIF

$$IF(NODOCVIEW)
$$IF(VERBOSE)
	// To create the main window, this code creates a new frame window
	// object and then sets it as the application's main window object.
$$ENDIF

$$IF( PROJTYPE_MDI )
	CMDIFrameWnd* pFrame = new CMainFrame;
$$ELIF( NODOCVIEW )
	CMainFrame* pFrame = new CMainFrame;
$$ELSE // SDI with doc view.
	CRuntimeClass* pClass = RUNTIME_CLASS(CMainFrame);
	CFrameWnd* pFrame = (CFrameWnd*) pClass->CreateObject();
	ASSERT_KINDOF(CFrameWnd, pFrame);
$$ENDIF
	m_pMainWnd = pFrame;

$$IF(PROJTYPE_SDI)
$$IF(!NODOCVIEW)
	// load the frame against an empty context

	CCreateContext context;
$$ELSE
	// create and load the frame with its resources
$$ENDIF

	pFrame->LoadFrame(IDR_MAINFRAME,
		WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, NULL,
$$IF(!NODOCVIEW)
		&context);
$$ELSE
		NULL);
$$ENDIF

$$ELSE // MDI
	// create main MDI frame window
	if (!pFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;

	// try to load shared MDI menus and accelerator table
$$IF(VERBOSE)
	//TODO: add additional member variables and load calls for
	//	additional menu types your application may need. 
$$ENDIF

	HINSTANCE hInst = AfxGetResourceHandle();
	m_hMDIMenu  = ::LoadMenu(hInst, MAKEINTRESOURCE(IDR_$$DOC$$TYPE));
	m_hMDIAccel = ::LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_$$DOC$$TYPE));
$$ENDIF // PROJTYPE_SDI

$$ELSE // NODOCVIEW
$$IF(VERBOSE)
	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.
$$ELSE
	// Register document templates
$$ENDIF
$$IF(PROJTYPE_MDI)

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_$$DOC$$TYPE,
$$ELSE

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
$$ENDIF
		RUNTIME_CLASS($$DOC_CLASS$$),
$$IF(PROJTYPE_MDI)
$$IF(MDICHILD)
		RUNTIME_CLASS($$CHILD_FRAME_CLASS$$), // custom MDI child frame
$$ELSE //!MDICHILD
		RUNTIME_CLASS(CMDIChildWnd),          // standard MDI child frame
$$ENDIF //MDICHILD
$$ELSE //!MDI
		RUNTIME_CLASS($$FRAME_CLASS$$),       // main SDI frame window
$$ENDIF
$$IF(PROJTYPE_EXPLORER)
		RUNTIME_CLASS($$TREEVIEW_CLASS$$));
$$ELSE
		RUNTIME_CLASS($$VIEW_CLASS$$));
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(PROJTYPE_MDI)
	pDocTemplate->SetContainerInfo(IDR_$$DOC$$TYPE_CNTR_IP);
$$ELSE
	pDocTemplate->SetContainerInfo(IDR_CNTR_INPLACE);
$$ENDIF
$$ENDIF
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	pDocTemplate->SetServerInfo(
$$IF(PROJTYPE_MDI)
		IDR_$$DOC$$TYPE_SRVR_EMB, IDR_$$DOC$$TYPE_SRVR_IP,
$$ELSE
		IDR_SRVR_EMBEDDED, IDR_SRVR_INPLACE,
$$ENDIF
		RUNTIME_CLASS($$IPFRAME_CLASS$$));
$$ENDIF
	AddDocTemplate(pDocTemplate);
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || AUTOMATION)
$$IF(VERBOSE)

	// Connect the COleTemplateServer to the document template.
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
$$ENDIF
$$IF(PROJTYPE_MDI)
	m_server.ConnectTemplate(clsid, pDocTemplate, FALSE);

$$IF(VERBOSE)
	// Register all OLE server factories as running.  This enables the
	//  OLE libraries to create objects from other applications.
$$ENDIF
	COleTemplateServer::RegisterAll();
$$IF(VERBOSE)
		// Note: MDI applications register all server objects without regard
		//  to the /Embedding or /Automation on the command line.
$$ENDIF
$$ELSE //!MDI
	m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);
$$IF(VERBOSE)
		// Note: SDI applications register server objects only if /Embedding
		//   or /Automation is present on the command line.
$$ENDIF
$$ENDIF
$$ENDIF

$$IF(PROJTYPE_MDI)
	// create main MDI Frame window
	$$FRAME_CLASS$$* pMainFrame = new $$FRAME_CLASS$$;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

$$IF(!MINI_SERVER)
$$// call DragAcceptFiles only if there's a suffix.
$$//  In an MDI app, this should occur immediately after setting m_pMainWnd
$$IF(HAS_SUFFIX)
	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

$$ENDIF //SUFFIX
$$ENDIF //!MINI_SERVER
$$ENDIF //MDI
$$IF(!MINI_SERVER)
$$IF(HAS_SUFFIX)
	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

$$ENDIF //SUFFIX
$$ENDIF //!MINI_SERVER
$$ENDIF // NODOCVIEW
$$IF(!NODOCVIEW)
	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);
$$ENDIF

$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || AUTOMATION)
$$IF(VERBOSE)
	// Check to see if launched as OLE server
$$ENDIF
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
$$IF(!PROJTYPE_MDI)
$$IF(VERBOSE)
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
$$ENDIF //VERBOSE
		COleTemplateServer::RegisterAll();

$$ENDIF //!MDI
		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

$$IF(VERBOSE)
	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
$$ENDIF
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
$$IF(ACTIVE_DOC_SERVER)
	m_server.UpdateRegistry(OAT_DOC_OBJECT_SERVER);
$$ELSE
	m_server.UpdateRegistry(OAT_INPLACE_SERVER);
$$ENDIF	// ACTIVE_DOC_SERVER
$$ELIF(AUTOMATION)
	m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
$$ENDIF
$$IF(AUTOMATION)
	COleObjectFactory::UpdateRegistryAll();
$$ENDIF

$$ENDIF //MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || AUTOMATION
$$IF(MINI_SERVER)
$$IF(VERBOSE)
	// When a mini-server is run stand-alone the registry is updated and the
	//  user is instructed to use the Insert Object dialog in a container
	//  to use the server.  Mini-servers do not have stand-alone user interfaces.
$$ENDIF //VERBOSE
	AfxMessageBox(IDP_USE_INSERT_OBJECT);
	return FALSE;
$$ELSE //!MINI_SERVER
$$IF(!NODOCVIEW)
	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;
$$ENDIF
$$IF(PROJTYPE_MDI)
$$IF(VERBOSE)

	// The main window has been initialized, so show and update it.
$$ENDIF
$$IF(NODOCVIEW)
	pFrame->ShowWindow($$SW_ARG$$);
	pFrame->UpdateWindow();
$$ELSE
	pMainFrame->ShowWindow($$SW_ARG$$);
	pMainFrame->UpdateWindow();
$$ENDIF
$$ELIF(PROJTYPE_SDI)
$$IF(VERBOSE)

	// The one and only window has been initialized, so show and update it.
$$ENDIF
$$IF(!NODOCVIEW)
	m_pMainWnd->ShowWindow($$SW_ARG$$);
	m_pMainWnd->UpdateWindow();
$$ELSE
	pFrame->ShowWindow($$SW_ARG$$);
	pFrame->UpdateWindow();
$$ENDIF
$$// call DragAcceptFiles only if there's a suffix.
$$//  In an SDI app, this should occur after ProcessShellCommand
$$IF(HAS_SUFFIX)

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();
$$ENDIF //SUFFIX
$$ENDIF //MDI/SDI

	return TRUE;
$$ENDIF //!MINI_SERVER
}

$$IF(NODOCVIEW)
/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ message handlers

$$IF(PROJTYPE_MDI)
$$IF(NODOCVIEW)
int $$APP_CLASS$$::ExitInstance() 
{
$$IF(VERBOSE)
	//TODO: handle additional resources you may have added
$$ENDIF
	if (m_hMDIMenu != NULL)
		FreeResource(m_hMDIMenu);
	if (m_hMDIAccel != NULL)
		FreeResource(m_hMDIAccel);

	return CWinApp::ExitInstance();
}
$$ENDIF // NODOCVIEW
$$ENDIF // PROJTYPE_MDI

$$IF(PROJTYPE_MDI || !NODOCVIEW ) // We don't want this for SDI without DOC View
void $$APP_CLASS$$::OnFileNew() 
{
$$IF(PROJTYPE_SDI)
	CString strUntitled;
	CFrameWnd* pFrameWnd = DYNAMIC_DOWNCAST(CFrameWnd, m_pMainWnd);
	if (pFrameWnd != NULL)
	{
$$IF(VERBOSE)
		//TODO: close and destroy any file-specific data you've got
		// in memory. Once done, execute the following if statement
		// to reset the title of the frame window.
$$ENDIF

		if (strUntitled.LoadString(AFX_IDS_UNTITLED))
			pFrameWnd->UpdateFrameTitleForDocument(strUntitled);
		else
			pFrameWnd->UpdateFrameTitleForDocument(NULL);
	}
$$ELSE
	CMainFrame* pFrame = STATIC_DOWNCAST(CMainFrame, m_pMainWnd);

	// create a new MDI child window
	pFrame->CreateNewChild(
		RUNTIME_CLASS(CChildFrame), IDR_$$DOC$$TYPE, m_hMDIMenu, m_hMDIAccel);
$$ENDIF // PROJTYPE_SDI
}
$$ENDIF // PROJTYPE_MDI || !NODOCVIEW


$$ENDIF

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void $$APP_CLASS$$::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	$$root$$.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

$$IF(ATL_SUPPORT)
#include <atlimpl.cpp>
$$ENDIF

$$IF(OLEDB)
CComModule _Module;
#include <atlimpl.cpp>
$$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\srvritem.cpp ===
// $$srvritem_ifile$$.cpp : implementation of the $$SRVRITEM_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"

$$IF(CRecordView || CDaoRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
#include "$$doc_hfile$$.h"
#include "$$srvritem_hfile$$.h"
$$IF(CONTAINER_SERVER)
#include "$$cntritem_hfile$$.h"
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$SRVRITEM_CLASS$$ implementation

IMPLEMENT_DYNAMIC($$SRVRITEM_CLASS$$, $$SRVRITEM_BASE_CLASS$$)

$$SRVRITEM_CLASS$$::$$SRVRITEM_CLASS$$($$DOC_CLASS$$* pContainerDoc)
	: $$SRVRITEM_BASE_CLASS$$(pContainerDoc, TRUE)
{
$$IF(VERBOSE)
	// TODO: add one-time construction code here
	//  (eg, adding additional clipboard formats to the item's data source)
$$ENDIF
}

$$SRVRITEM_CLASS$$::~$$SRVRITEM_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: add cleanup code here
$$ENDIF
}

void $$SRVRITEM_CLASS$$::Serialize(CArchive& ar)
{
$$IF(VERBOSE)
	// $$SRVRITEM_CLASS$$::Serialize will be called by the framework if
	//  the item is copied to the clipboard.  This can happen automatically
	//  through the OLE callback OnGetClipboardData.  A good default for
	//  the embedded item is simply to delegate to the document's Serialize
	//  function.  If you support links, then you will want to serialize
	//  just a portion of the document.

$$ENDIF
	if (!IsLinkedItem())
	{
		$$DOC_CLASS$$* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pDoc->Serialize(ar);
	}
}

BOOL $$SRVRITEM_CLASS$$::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
{
$$IF(VERBOSE)
	// Most applications, like this one, only handle drawing the content
	//  aspect of the item.  If you wish to support other aspects, such
	//  as DVASPECT_THUMBNAIL (by overriding OnDrawEx), then this
	//  implementation of OnGetExtent should be modified to handle the
	//  additional aspect(s).

$$ENDIF
	if (dwDrawAspect != DVASPECT_CONTENT)
		return $$SRVRITEM_BASE_CLASS$$::OnGetExtent(dwDrawAspect, rSize);
$$IF(VERBOSE)

	// $$SRVRITEM_CLASS$$::OnGetExtent is called to get the extent in
	//  HIMETRIC units of the entire item.  The default implementation
	//  here simply returns a hard-coded number of units.
$$ENDIF

	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

$$IF(VERBOSE)
	// TODO: replace this arbitrary size

$$ENDIF
	rSize = CSize(3000, 3000);   // 3000 x 3000 HIMETRIC units

	return TRUE;
}

BOOL $$SRVRITEM_CLASS$$::OnDraw(CDC* pDC, CSize& rSize)
{
$$IF(VERBOSE)
	// Remove this if you use rSize
$$ENDIF
	UNREFERENCED_PARAMETER(rSize);

	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

$$IF(VERBOSE)
	// TODO: set mapping mode and extent
	//  (The extent is usually the same as the size returned from OnGetExtent)
$$ENDIF
	pDC->SetMapMode(MM_ANISOTROPIC);
	pDC->SetWindowOrg(0,0);
	pDC->SetWindowExt(3000, 3000);

$$IF(VERBOSE)
	// TODO: add drawing code here.  Optionally, fill in the HIMETRIC extent.
	//  All drawing takes place in the metafile device context (pDC).

$$IF(CONTAINER_SERVER)
	// TODO: also draw embedded $$CNTRITEM_CLASS$$ objects.

$$ENDIF
$$ENDIF
$$IF(CONTAINER_SERVER)
	// The following code draws the first item at an arbitrary position.

	// TODO: remove this code when your real drawing code is complete

	POSITION pos = pDoc->GetStartPosition();
	$$CNTRITEM_CLASS$$* pItem = ($$CNTRITEM_CLASS$$*)pDoc->GetNextClientItem(pos);
	if (pItem != NULL)
		pItem->Draw(pDC, CRect(10, 10, 1010, 1010));
$$ENDIF
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// $$SRVRITEM_CLASS$$ diagnostics

#ifdef _DEBUG
void $$SRVRITEM_CLASS$$::AssertValid() const
{
	$$SRVRITEM_BASE_CLASS$$::AssertValid();
}

void $$SRVRITEM_CLASS$$::Dump(CDumpContext& dc) const
{
	$$SRVRITEM_BASE_CLASS$$::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\srvritem.h ===
// $$srvritem_hfile$$.h : interface of the $$SRVRITEM_CLASS$$ class
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$SRVRITEM_CLASS$$ : public $$SRVRITEM_BASE_CLASS$$
{
	DECLARE_DYNAMIC($$SRVRITEM_CLASS$$)

// Constructors
public:
	$$SRVRITEM_CLASS$$($$DOC_CLASS$$* pContainerDoc);

// Attributes
	$$DOC_CLASS$$* GetDocument() const
		{ return ($$DOC_CLASS$$*)$$SRVRITEM_BASE_CLASS$$::GetDocument(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$SRVRITEM_CLASS$$)
	public:
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
	virtual BOOL OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize);
	//}}AFX_VIRTUAL

// Implementation
public:
	~$$SRVRITEM_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\root.h ===
// $$root$$.h : main header file for the $$ROOT$$ application
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$:
// See $$root$$.cpp for the implementation of this class
//

class $$APP_CLASS$$ : public $$APP_BASE_CLASS$$
{
public:
	$$APP_CLASS$$();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$APP_CLASS$$)
	public:
	virtual BOOL InitInstance();
$$IF(PROJTYPE_MDI)
$$IF(NODOCVIEW)
	virtual int ExitInstance();
$$ENDIF
$$ENDIF
	//}}AFX_VIRTUAL

// Implementation
$$IF(FULL_SERVER || MINI_SERVER || CONTAINER_SERVER || AUTOMATION)
	COleTemplateServer m_server;
$$IF(VERBOSE)
		// Server object for document creation
$$ENDIF
$$ENDIF
$$IF(NODOCVIEW)
$$IF(PROJTYPE_MDI)
protected:
	HMENU m_hMDIMenu;
	HACCEL m_hMDIAccel;
$$ENDIF

public:
$$ENDIF
	//{{AFX_MSG($$APP_CLASS$$)
	afx_msg void OnAppAbout();
$$IF(NODOCVIEW)
$$IF(PROJTYPE_MDI)
	afx_msg void OnFileNew();
$$ENDIF
$$ENDIF
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

$$IF(VBX)
/////////////////////////////////////////////////////////////////////////////
// VB-Event extern declarations

//{{AFX_VBX_REGISTER()
//}}AFX_VBX_REGISTER
$$ENDIF //VBX

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
$$IF(CTreeView || CListView || PROJTYPE_EXPLORER)
#include <afxcview.h>
$$ENDIF //CTreeView || CListView
$$IF(PROJTYPE_DLL)

#ifndef _AFX_NO_OLE_SUPPORT
$$ENDIF //PROJTYPE_DLL
$$IF(CONTAINER || MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || PROJTYPE_DLL)
#include <afxole.h>         // MFC OLE classes
$$IF(CONTAINER || CONTAINER_SERVER || PROJTYPE_DLL)
#include <afxodlgs.h>       // MFC OLE dialog classes
$$ENDIF
$$ENDIF
$$IF(AUTOMATION || PROJTYPE_DLL || OLECTL)
#include <afxdisp.h>        // MFC Automation classes
$$ENDIF
$$IF(ACTIVE_DOC_SERVER)
#include <afxdocob.h>
$$ENDIF
$$IF(PROJTYPE_DLL)
#endif // _AFX_NO_OLE_SUPPORT

$$ENDIF //PROJTYPE_DLL
$$// Include database headers.  For a DLL or app which just includes database
$$//  headers (no database view), conditionally include DAO and ODBC.
$$//  If an actual view is used, always & only include the corresponding header.
$$// First, actual view is used:
$$IF(CRecordView)
#include <afxdb.h>			// MFC ODBC database classes
$$ELIF(CDaoRecordView)
#include <afxdao.h>			// MFC DAO database classes
$$ELIF(DB || PROJTYPE_DLL)
$$// Here, minimal DB support is requested, or we're a DLL.  No view is chosen.

#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

$$ENDIF // database/DLL options
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
$$IF(CHtmlView)
#include <afxhtml.h>			// MFC HTML view support
$$ENDIF

$$IF(SOCKETS)
#include <afxsock.h>		// MFC socket extensions
$$ENDIF //SOCKETS
$$IF(CRichEditView)
#include <afxrich.h>		// MFC rich edit classes
$$ENDIF //CRichEditView
$$IF(ATL_SUPPORT)
#include <atlbase.h>
extern CComModule _Module;
$$ENDIF
$$IF(OLEDB)
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atldbcli.h>
#include <afxoledb.h>
$$ENDIF
$$IF(PROJTYPE_DLG)
$$IF(AUTOMATION)

$$IF(VERBOSE)
// This macro is the same as IMPLEMENT_OLECREATE, except it passes TRUE
//  for the bMultiInstance parameter to the COleObjectFactory constructor.
//  We want a separate instance of this application to be launched for
//  each automation proxy object requested by automation controllers.
$$ENDIF //VERBOSE
#ifndef IMPLEMENT_OLECREATE2
#define IMPLEMENT_OLECREATE2(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	AFX_DATADEF COleObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), TRUE, _T(external_name)); \
	const AFX_DATADEF GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };
#endif // IMPLEMENT_OLECREATE2
$$ENDIF //AUTOMATION
$$ENDIF //PROJTYPE_DLG

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\treeview.cpp ===
// $$treeview_ifile$$.cpp : implementation of the $$TREEVIEW_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$doc_hfile$$.h"
#include "$$treeview_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$

IMPLEMENT_DYNCREATE($$TREEVIEW_CLASS$$, $$TREEVIEW_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$TREEVIEW_CLASS$$, $$TREEVIEW_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$TREEVIEW_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
$$ENDIF
	//}}AFX_MSG_MAP
$$IF(PRINT)
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, $$TREEVIEW_BASE_CLASS$$::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, $$TREEVIEW_BASE_CLASS$$::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, $$TREEVIEW_BASE_CLASS$$::OnFilePrintPreview)
$$ENDIF //PRINT
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ construction/destruction

$$TREEVIEW_CLASS$$::$$TREEVIEW_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: add construction code here

$$ENDIF
}

$$TREEVIEW_CLASS$$::~$$TREEVIEW_CLASS$$()
{
}

BOOL $$TREEVIEW_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
$$IF(VERBOSE)
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

$$ENDIF //VERBOSE
	return $$TREEVIEW_BASE_CLASS$$::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ drawing

void $$TREEVIEW_CLASS$$::OnDraw(CDC* pDC)
{
	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
$$IF(VERBOSE)

	// TODO: add draw code for native data here
$$ENDIF //VERBOSE
}

$$IF(PRINT)

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ printing

BOOL $$TREEVIEW_CLASS$$::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void $$TREEVIEW_CLASS$$::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
$$IF(VERBOSE)
	// TODO: add extra initialization before printing
$$ENDIF //VERBOSE
}

void $$TREEVIEW_CLASS$$::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
$$IF(VERBOSE)
	// TODO: add cleanup after printing
$$ENDIF //VERBOSE
}
$$ENDIF //PRINT

void $$TREEVIEW_CLASS$$::OnInitialUpdate()
{
	$$TREEVIEW_BASE_CLASS$$::OnInitialUpdate();
$$IF(VERBOSE)

	// TODO: You may populate your TreeView with items by directly accessing
	//  its tree control through a call to GetTreeCtrl().
$$ENDIF //VERBOSE
}

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ diagnostics

#ifdef _DEBUG
void $$TREEVIEW_CLASS$$::AssertValid() const
{
	$$TREEVIEW_BASE_CLASS$$::AssertValid();
}

void $$TREEVIEW_CLASS$$::Dump(CDumpContext& dc) const
{
	$$TREEVIEW_BASE_CLASS$$::Dump(dc);
}

$$DOC_CLASS$$* $$TREEVIEW_CLASS$$::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS($$DOC_CLASS$$)));
	return ($$DOC_CLASS$$*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\wndview.cpp ===
// $$wndview_ifile$$.cpp : implementation of the $$WNDVIEW_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$wndview_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$WNDVIEW_CLASS$$

$$WNDVIEW_CLASS$$::$$WNDVIEW_CLASS$$()
{
}

$$WNDVIEW_CLASS$$::~$$WNDVIEW_CLASS$$()
{
}


BEGIN_MESSAGE_MAP($$WNDVIEW_CLASS$$,$$WNDVIEW_BASE_CLASS$$ )
	//{{AFX_MSG_MAP($$WNDVIEW_CLASS$$)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// $$WNDVIEW_CLASS$$ message handlers

BOOL $$WNDVIEW_CLASS$$::PreCreateWindow(CREATESTRUCT& cs) 
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	cs.dwExStyle |= WS_EX_CLIENTEDGE;
	cs.style &= ~WS_BORDER;
	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, 
		::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

	return TRUE;
}

void $$WNDVIEW_CLASS$$::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
$$IF(VERBOSE)
	// TODO: Add your message handler code here
$$ENDIF
	
	// Do not call CWnd::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\treeview.h ===
// $$treeview_hfile$$.h : interface of the $$TREEVIEW_CLASS$$ class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$DOC_CLASS$$;

class $$TREEVIEW_CLASS$$ : public CTreeView
{
protected: // create from serialization only
	$$TREEVIEW_CLASS$$();
	DECLARE_DYNCREATE($$TREEVIEW_CLASS$$)

// Attributes
public:
	$$DOC_CLASS$$* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$TREEVIEW_CLASS$$)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
$$IF(PRINT)
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
$$ENDIF
	virtual void OnInitialUpdate(); // called first time after construct
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~$$TREEVIEW_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG($$TREEVIEW_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in $$treeview_ifile$$.cpp
inline $$DOC_CLASS$$* $$TREEVIEW_CLASS$$::GetDocument()
   { return ($$DOC_CLASS$$*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\wndview.h ===
// $$wndview_hfile$$.h : interface of the $$WNDVIEW_CLASS$$ class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// $$WNDVIEW_CLASS$$ window

class $$WNDVIEW_CLASS$$ : public $$WNDVIEW_BASE_CLASS$$
{
// Construction
public:
	$$WNDVIEW_CLASS$$();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$WNDVIEW_CLASS$$)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~$$WNDVIEW_CLASS$$();

	// Generated message map functions
protected:
	//{{AFX_MSG($$WNDVIEW_CLASS$$)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\view.cpp ===
// $$view_ifile$$.cpp : implementation of the $$VIEW_CLASS$$ class
//

#include "stdafx.h"
#include "$$root$$.h"

$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
#include "$$doc_hfile$$.h"
$$IF(CONTAINER || CONTAINER_SERVER)
#include "$$cntritem_hfile$$.h"
$$ENDIF
#include "$$view_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$

IMPLEMENT_DYNCREATE($$VIEW_CLASS$$, $$VIEW_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$VIEW_CLASS$$, $$VIEW_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$VIEW_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
	ON_WM_DESTROY()
$$IF(!CRichEditView)
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINERS
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	ON_COMMAND(ID_CANCEL_EDIT_SRVR, OnCancelEditSrvr)
$$ENDIF
	//}}AFX_MSG_MAP
$$IF(PRINT)
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, $$VIEW_BASE_CLASS$$::OnFilePrint)
$$IF(!CHtmlView)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, $$VIEW_BASE_CLASS$$::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, $$VIEW_BASE_CLASS$$::OnFilePrintPreview)
$$ENDIF
$$ENDIF //PRINT
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ construction/destruction

$$VIEW_CLASS$$::$$VIEW_CLASS$$()
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
	: $$VIEW_BASE_CLASS$$($$VIEW_CLASS$$::IDD)
$$ENDIF
{
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
	//{{AFX_DATA_INIT($$VIEW_CLASS$$)
		// NOTE: the ClassWizard will add member initialization here
$$IF(|| CRecordView || CDaoRecordView || COleDBRecordView)
	m_pSet = NULL;
$$ENDIF
	//}}AFX_DATA_INIT
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!CRichEditView)
	m_pSelection = NULL;
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINERS
$$IF(VERBOSE)
	// TODO: add construction code here

$$ENDIF
}

$$VIEW_CLASS$$::~$$VIEW_CLASS$$()
{
}
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)

void $$VIEW_CLASS$$::DoDataExchange(CDataExchange* pDX)
{
	$$VIEW_BASE_CLASS$$::DoDataExchange(pDX);
	//{{AFX_DATA_MAP($$VIEW_CLASS$$)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}
$$ENDIF

BOOL $$VIEW_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
$$IF(VERBOSE)
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

$$ENDIF //VERBOSE
$$IF(CEditView)
	BOOL bPreCreated = CEditView::PreCreateWindow(cs);
	cs.style &= ~(ES_AUTOHSCROLL|WS_HSCROLL);	// Enable word-wrapping

	return bPreCreated;
$$ELSE //!CEditView
	return $$VIEW_BASE_CLASS$$::PreCreateWindow(cs);
$$ENDIF //CEditView
}
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
$$ELIF(!CRichEditView)

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ drawing

void $$VIEW_CLASS$$::OnDraw(CDC* pDC)
{
	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	CListCtrl& refCtrl = GetListCtrl();
	refCtrl.InsertItem(0, "Item!");
$$ENDIF
$$ENDIF
$$IF(VERBOSE)
	// TODO: add draw code for native data here
$$ENDIF //VERBOSE
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!ACTIVE_DOC_CONTAINER)
$$IF(!CRichEditView)
$$IF(VERBOSE)
	// TODO: also draw all OLE items in the document

	// Draw the selection at an arbitrary position.  This code should be
	//  removed once your real drawing code is implemented.  This position
	//  corresponds exactly to the rectangle returned by $$CNTRITEM_CLASS$$,
	//  to give the effect of in-place editing.

	// TODO: remove this code when final draw code is complete.
$$ENDIF //VERBOSE

	if (m_pSelection == NULL)
	{
		POSITION pos = pDoc->GetStartPosition();
		m_pSelection = ($$CNTRITEM_CLASS$$*)pDoc->GetNextClientItem(pos);
	}
	if (m_pSelection != NULL)
		m_pSelection->Draw(pDC, CRect(10, 10, 210, 210));
$$ENDIF //!CRichEditView
$$ENDIF //ACTIVE_DOC_CONTAINER
$$ENDIF //CONTAINERS
}
$$ENDIF // !(CFormView || CRecordView || CDaoRecordView)
$$IF(CScrollView || CONTAINER || CONTAINER_SERVER || CRecordView || CDaoRecordView || COleDBRecordView || CListView || CTreeView || CFormView || CHtmlView)

void $$VIEW_CLASS$$::OnInitialUpdate()
{
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
	m_pSet = &GetDocument()->$$RECSET_VARIABLE$$;
$$IF(COleDBRecordView)
	{
		CWaitCursor wait;
		HRESULT hr = m_pSet->Open();
		if (hr != S_OK)
		{
			AfxMessageBox(_T("Record set failed to open."), MB_OK);
$$IF(VERBOSE)
			// Disable the Next and Previous record commands,
			// since attempting to change the current record without an
			// open RecordSet will cause a crash.
$$ENDIF
			m_bOnFirstRecord = TRUE;
			m_bOnLastRecord = TRUE;
		}				
	}
$$ENDIF
$$ENDIF
	$$VIEW_BASE_CLASS$$::OnInitialUpdate();
$$IF(CRecordView || CDaoRecordView || CFormView)
$$IF(PROJTYPE_SDI)
	GetParentFrame()->RecalcLayout();
$$ENDIF
	ResizeParentToFit();
$$ENDIF

$$IF(VERBOSE)
$$IF(CListView)

	// TODO: You may populate your ListView with items by directly accessing
	//  its list control through a call to GetListCtrl().
$$ELIF(CTreeView)

	// TODO: You may populate your TreeView with items by directly accessing
	//  its tree control through a call to GetTreeCtrl().
$$ELIF(CHtmlView)
	// TODO: This code navigates to a popular spot on the web.
	//  change the code to go where you'd like.
$$ENDIF //Views
$$ENDIF //VERBOSE
$$IF(CHtmlView)
	Navigate2(_T("http://www.microsoft.com/visualc/"),NULL,NULL);
$$ENDIF //CHTMLVIEW
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!CRichEditView)

$$IF(VERBOSE)
	// TODO: remove this code when final selection model code is written
$$ENDIF //VERBOSE
	m_pSelection = NULL;    // initialize selection

$$ENDIF //!CRichEditView
$$IF(ACTIVE_DOC_CONTAINER)
	//Active documents should always be activated
	COleDocument* pDoc = (COleDocument*) GetDocument();
	if (pDoc != NULL)
	{
		// activate the first one
		POSITION posItem = pDoc->GetStartPosition();
		if (posItem != NULL)
		{
			CDocItem* pItem = pDoc->GetNextItem(posItem);

			// only if it's an Active document
			COleDocObjectItem *pDocObjectItem =
				DYNAMIC_DOWNCAST(COleDocObjectItem, pItem);

			if (pDocObjectItem != NULL)
			{
				pDocObjectItem->DoVerb(OLEIVERB_SHOW, this);
			}
		}
	}
$$ENDIF
$$IF(CRichEditView)

$$IF(VERBOSE)
	// Set the printing margins (720 twips = 1/2 inch).
$$ENDIF //VERBOSE
	SetMargins(CRect(720, 720, 720, 720));
$$ENDIF	//CRichEditView
$$ENDIF //CONTAINERS
$$IF(CScrollView)
	CSize sizeTotal;
$$IF(VERBOSE)
	// TODO: calculate the total size of this view
$$ENDIF
	sizeTotal.cx = sizeTotal.cy = 100;
	SetScrollSizes(MM_TEXT, sizeTotal);
$$ENDIF
}
$$ENDIF // CScrollView || CONTAINER || CONTAINER_SERVER || CRecordView || CDaoRecordView || CFormView || CHtmlView
$$IF(PRINT)

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ printing

$$IF(!CHtmlView)
BOOL $$VIEW_CLASS$$::OnPreparePrinting(CPrintInfo* pInfo)
{
$$IF(CEditView)
	// default CEditView preparation
	return CEditView::OnPreparePrinting(pInfo);
$$ELSE
$$IF(ACTIVE_DOC_CONTAINER)
	if (!CView::DoPreparePrinting(pInfo))
		return FALSE;
	
	if (!COleDocObjectItem::OnPreparePrinting(this, pInfo))
		return FALSE;

	return TRUE;
$$ELSE
	// default preparation
	return DoPreparePrinting(pInfo);
$$ENDIF // ACTIVE_DOC_CONTAINER
$$ENDIF // CEditView
}

$$IF(!CRichEditView)
$$IF(CEditView)
void $$VIEW_CLASS$$::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)
$$ELSE
void $$VIEW_CLASS$$::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
$$ENDIF //CEditView
{
$$IF(CEditView)
$$IF(VERBOSE)
	// Default CEditView begin printing.
$$ENDIF //VERBOSE
	CEditView::OnBeginPrinting(pDC, pInfo);
$$ELSE
$$IF(VERBOSE)
	// TODO: add extra initialization before printing
$$ENDIF //VERBOSE
$$ENDIF //CEditView
}

$$IF(CEditView)
void $$VIEW_CLASS$$::OnEndPrinting(CDC* pDC, CPrintInfo* pInfo)
$$ELSE
void $$VIEW_CLASS$$::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
$$ENDIF //CEditView
{
$$IF(CEditView)
$$IF(VERBOSE)
	// Default CEditView end printing
$$ENDIF //VERBOSE
	CEditView::OnEndPrinting(pDC, pInfo);
$$ELSE
$$IF(VERBOSE)
	// TODO: add cleanup after printing
$$ENDIF //VERBOSE
$$ENDIF //CEditView
}
$$ENDIF //!CRichEditView
$$ENDIF // !CHtmlView
$$IF(CFormView || ACTIVE_DOC_CONTAINER)

$$IF(ACTIVE_DOC_CONTAINER)
void $$VIEW_CLASS$$::OnPrint(CDC* pDC, CPrintInfo* pInfo)
$$ELSE
void $$VIEW_CLASS$$::OnPrint(CDC* pDC, CPrintInfo* /*pInfo*/)
$$ENDIF
{
$$IF(VERBOSE)
	// TODO: add customized printing code here
$$ENDIF
$$IF(ACTIVE_DOC_CONTAINER)
	if(pInfo->m_bDocObject)
		COleDocObjectItem::OnPrint(this, pInfo, TRUE);
	else
		CView::OnPrint(pDC, pInfo);
$$ENDIF
}
$$ENDIF //CFormView || OLEDOCCONTAINER
$$ENDIF //PRINT
$$IF(CONTAINER || CONTAINER_SERVER)

void $$VIEW_CLASS$$::OnDestroy()
{
$$IF(VERBOSE)
	// Deactivate the item on destruction; this is important
	// when a splitter view is being used.
$$ENDIF
   $$VIEW_BASE_CLASS$$::OnDestroy();
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
   {
      pActiveItem->Deactivate();
      ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
   }
}

$$IF(!CRichEditView)

/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL $$VIEW_CLASS$$::IsSelected(const CObject* pDocItem) const
{
$$IF(VERBOSE)
	// The implementation below is adequate if your selection consists of
	//  only $$CNTRITEM_CLASS$$ objects.  To handle different selection
	//  mechanisms, the implementation here should be replaced.

	// TODO: implement this function that tests for a selected OLE client item

$$ENDIF
	return pDocItem == m_pSelection;
}

void $$VIEW_CLASS$$::OnInsertObject()
{
$$IF(VERBOSE)
	// Invoke the standard Insert Object dialog box to obtain information
	//  for new $$CNTRITEM_CLASS$$ object.
$$ENDIF
	COleInsertDialog dlg;
$$IF(ACTIVE_DOC_CONTAINER)
	if (dlg.DoModal(COleInsertDialog::DocObjectsOnly) != IDOK)
		return;
$$ELSE
	if (dlg.DoModal() != IDOK)
		return;
$$ENDIF

	BeginWaitCursor();

	$$CNTRITEM_CLASS$$* pItem = NULL;
	TRY
	{
$$IF(VERBOSE)
		// Create new item connected to this document.
$$ENDIF
		$$DOC_CLASS$$* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pItem = new $$CNTRITEM_CLASS$$(pDoc);
		ASSERT_VALID(pItem);

$$IF(VERBOSE)
		// Initialize the item from the dialog data.
$$ENDIF
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // any exception will do
		ASSERT_VALID(pItem);
		
$$IF(ACTIVE_DOC_CONTAINER)
		pItem->DoVerb(OLEIVERB_SHOW, this);
$$ELSE
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);
$$ENDIF

		ASSERT_VALID(pItem);
$$IF(VERBOSE)

		// As an arbitrary user interface design, this sets the selection
		//  to the last item inserted.

		// TODO: reimplement selection as appropriate for your application
$$ENDIF

		m_pSelection = pItem;   // set selection to last inserted item
		pDoc->UpdateAllViews(NULL);
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH

	EndWaitCursor();
}

$$IF(VERBOSE)
// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the container (not the server) causes the deactivation.
$$ENDIF
void $$VIEW_CLASS$$::OnCancelEditCntr()
{
	// Close any in-place active item on this view.
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		pActiveItem->Close();
	}
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

$$IF(VERBOSE)
// Special handling of OnSetFocus and OnSize are required for a container
//  when an object is being edited in-place.
$$ENDIF
void $$VIEW_CLASS$$::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();   // don't call the base class
			return;
		}
	}

	$$VIEW_BASE_CLASS$$::OnSetFocus(pOldWnd);
}

void $$VIEW_CLASS$$::OnSize(UINT nType, int cx, int cy)
{
	$$VIEW_BASE_CLASS$$::OnSize(nType, cx, cy);
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->SetItemRects();
}
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINER || CONTAINER_SERVER
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)

/////////////////////////////////////////////////////////////////////////////
// OLE Server support

$$IF(VERBOSE)
// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the server (not the container) causes the deactivation.
$$ENDIF
void $$VIEW_CLASS$$::OnCancelEditSrvr()
{
	GetDocument()->OnDeactivateUI(FALSE);
}
$$ENDIF //SERVERS

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ diagnostics

#ifdef _DEBUG
void $$VIEW_CLASS$$::AssertValid() const
{
	$$VIEW_BASE_CLASS$$::AssertValid();
}

void $$VIEW_CLASS$$::Dump(CDumpContext& dc) const
{
	$$VIEW_BASE_CLASS$$::Dump(dc);
}

$$DOC_CLASS$$* $$VIEW_CLASS$$::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS($$DOC_CLASS$$)));
	return ($$DOC_CLASS$$*)m_pDocument;
}
#endif //_DEBUG
$$IF(CRecordView || CDaoRecordView ||COleDBRecordView)

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ database support
$$IF(CRecordView)
CRecordset* $$VIEW_CLASS$$::OnGetRecordset()
$$ELIF(CDaoRecordView)
CDaoRecordset* $$VIEW_CLASS$$::OnGetRecordset()
$$ELSE
CRowset* $$VIEW_CLASS$$::OnGetRowset()
$$ENDIF
{
	return m_pSet;
}

$$ENDIF //CRecordView || CDaoRecordView

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ message handlers
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
void $$VIEW_CLASS$$::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
$$IF(VERBOSE)
	//TODO: add code to react to the user changing the view style of your window
$$ENDIF
}
$$ENDIF
$$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\template\view.h ===
// $$view_hfile$$.h : interface of the $$VIEW_CLASS$$ class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

$$IF(CONTAINER || CONTAINER_SERVER)
class $$CNTRITEM_CLASS$$;
$$ENDIF
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
class $$RECSET_CLASS$$;
$$ENDIF

class $$VIEW_CLASS$$ : public $$VIEW_BASE_CLASS$$
{
protected: // create from serialization only
	$$VIEW_CLASS$$();
	DECLARE_DYNCREATE($$VIEW_CLASS$$)
$$IF(CRecordView || CDaoRecordView || COleDBRecordView || CFormView)

public:
	//{{AFX_DATA($$VIEW_CLASS$$)
	enum{ IDD = IDD_$$SAFE_ROOT$$_FORM };
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
	$$RECSET_CLASS$$* m_pSet;
$$ENDIF
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA
$$ENDIF

// Attributes
public:
	$$DOC_CLASS$$* GetDocument();
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!CRichEditView)
$$IF(VERBOSE)
	// m_pSelection holds the selection to the current $$CNTRITEM_CLASS$$.
	// For many applications, such a member variable isn't adequate to
	//  represent a selection, such as a multiple selection or a selection
	//  of objects that are not $$CNTRITEM_CLASS$$ objects.  This selection
	//  mechanism is provided just to help you get started.

	// TODO: replace this selection mechanism with one appropriate to your app.
$$ENDIF //VERBOSE
	$$CNTRITEM_CLASS$$* m_pSelection;
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINERS

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL($$VIEW_CLASS$$)
	public:
$$IF(CRecordView)
	virtual CRecordset* OnGetRecordset();
$$ENDIF
$$IF(CDaoRecordView)
	virtual CDaoRecordset* OnGetRecordset();
$$ENDIF
$$IF(COleDBRecordView)
	virtual CRowset* OnGetRowset();
$$ENDIF
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
$$ELIF(!CRichEditView);
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
$$ENDIF // !(CFormView || CRecordView || CDaoRecordView)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
$$ENDIF //CFormView || CRecordView || CDaoRecordView
$$IF(CScrollView || CONTAINER || CONTAINER_SERVER || CRecordView || CDaoRecordView || COleDBRecordView || CTreeView || CListView || CFormView || CHtmlView)
	virtual void OnInitialUpdate(); // called first time after construct
$$ENDIF
$$IF(PRINT)
$$IF(!CHtmlView)
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
$$ENDIF
$$IF(CRichEditView||CHtmlView)
$$ELSE
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
$$ENDIF //!CRichEditView||CHtmlView
$$IF(CFormView || ACTIVE_DOC_CONTAINER)
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
$$ENDIF //CFormView
$$ENDIF //PRINT
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!CRichEditView)
	virtual BOOL IsSelected(const CObject* pDocItem) const;// Container support
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINER || CONTAINER_SERVER
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~$$VIEW_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG($$VIEW_CLASS$$)
$$IF(VERBOSE)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
	afx_msg void OnDestroy();
$$IF(!CRichEditView)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINER || CONTAINER_SERVER
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	afx_msg void OnCancelEditSrvr();
$$ENDIF //SERVERS
	//}}AFX_MSG
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
$$ENDIF
$$ENDIF
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in $$view_ifile$$.cpp
inline $$DOC_CLASS$$* $$VIEW_CLASS$$::GetDocument()
   { return ($$DOC_CLASS$$*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xbgwiz\debug.h ===
#if !defined(AFX_DEBUG_H__FF0FA094_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
#define AFX_DEBUG_H__FF0FA094_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _PSEUDO_DEBUG

#undef TRACE
#undef VERIFY
#undef ASSERT
#undef THIS_FILE
#undef TRACE0
#undef TRACE1
#undef TRACE2
#undef TRACE3


// Note: file names are still ANSI strings (filenames rarely need UNICODE)
BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine);

void Trace(LPCTSTR lpszFormat, ...);

// by default, debug break is asm int 3, or a call to DebugBreak, or nothing
#if defined(_M_IX86)
#define CustomDebugBreak() _asm { int 3 }
#else
#define CustomDebugBreak() DebugBreak()
#endif

#define TRACE              ::Trace
#define THIS_FILE          __FILE__
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && AssertFailedLine(THIS_FILE, __LINE__)) \
		CustomDebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              ::Trace(_T(sz))
#define TRACE1(sz, p1)          ::Trace(_T(sz), p1)
#define TRACE2(sz, p1, p2)      ::Trace(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  ::Trace(_T(sz), p1, p2, p3)

#endif // !_PSEUDO_DEBUG


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEBUG_H__FF0FA094_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xbgwiz\debug.cpp ===
#include "stdafx.h"

#ifdef _PSEUDO_DEBUG   // entire file

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LONG AssertBusy = -1;
LONG AssertReallyBusy = -1;

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
	TCHAR szMessage[_MAX_PATH*2];

	InterlockedDecrement(&AssertReallyBusy);

	// format message into buffer
	wsprintf(szMessage, _T("File %hs, Line %d"),
		lpszFileName, nLine);

	TCHAR szT[_MAX_PATH*2 + 20];
	wsprintf(szT, _T("Assertion Failed: %s\n"), szMessage);
	OutputDebugString(szT);

	if (InterlockedIncrement(&AssertBusy) > 0)
	{
		InterlockedDecrement(&AssertBusy);

		// assert within assert (examine call stack to determine first one)
		DebugBreak();
		return FALSE;
	}

	// active popup window for the current thread
	HWND hWndParent = GetActiveWindow();
	if (hWndParent != NULL)
		hWndParent = GetLastActivePopup(hWndParent);

	// display the assert
	int nCode = ::MessageBox(hWndParent, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

	// cleanup
	InterlockedDecrement(&AssertBusy);

	if (nCode == IDIGNORE)
		return FALSE;   // ignore

	if (nCode == IDRETRY)
		return TRUE;    // will cause DebugBreak

	AfxAbort();     // should not return (but otherwise DebugBreak)
	return TRUE;
}

void Trace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vstprintf(szBuffer, lpszFormat, args);
	ASSERT(nBuf < (sizeof(szBuffer)/sizeof(szBuffer[0])));

	CString strMessage;

	if (AfxGetApp() != NULL)
		strMessage = ((CString) (AfxGetApp()->m_pszExeName)) + _T(": ");
	strMessage += szBuffer;
	OutputDebugString(strMessage);

	va_end(args);
}


#endif // _PSEUDO_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xbgwiz\exe.h ===
#if !defined(AFX_EXE_H__FF0FA08E_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
#define AFX_EXE_H__FF0FA08E_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

// TODO: You may add any other custom AppWizard-wide declarations here.


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXE_H__FF0FA08E_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xbgwiz\exe.cpp ===
// exe.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <afxdllx.h>
#include "exe.h"
#include "exeaw.h"

#include <atlimpl.cpp>

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CComModule _Module;

static AFX_EXTENSION_MODULE XbgDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("EXE.AWX Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(XbgDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(XbgDLL);

		// Register this custom AppWizard with MFCAPWZ.DLL
		SetCustomAppWizClass(&Xbgaw);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("EXE.AWX Terminating!\n");

		// Terminate the library before destructors are called
		AfxTermExtensionModule(XbgDLL);
	}
	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xslwiz\debug.cpp ===
#include "stdafx.h"

#ifdef _PSEUDO_DEBUG   // entire file

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LONG AssertBusy = -1;
LONG AssertReallyBusy = -1;

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
	TCHAR szMessage[_MAX_PATH*2];

	InterlockedDecrement(&AssertReallyBusy);

	// format message into buffer
	wsprintf(szMessage, _T("File %hs, Line %d"),
		lpszFileName, nLine);

	TCHAR szT[_MAX_PATH*2 + 20];
	wsprintf(szT, _T("Assertion Failed: %s\n"), szMessage);
	OutputDebugString(szT);

	if (InterlockedIncrement(&AssertBusy) > 0)
	{
		InterlockedDecrement(&AssertBusy);

		// assert within assert (examine call stack to determine first one)
		DebugBreak();
		return FALSE;
	}

	// active popup window for the current thread
	HWND hWndParent = GetActiveWindow();
	if (hWndParent != NULL)
		hWndParent = GetLastActivePopup(hWndParent);

	// display the assert
	int nCode = ::MessageBox(hWndParent, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

	// cleanup
	InterlockedDecrement(&AssertBusy);

	if (nCode == IDIGNORE)
		return FALSE;   // ignore

	if (nCode == IDRETRY)
		return TRUE;    // will cause DebugBreak

	AfxAbort();     // should not return (but otherwise DebugBreak)
	return TRUE;
}

void Trace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vstprintf(szBuffer, lpszFormat, args);
	ASSERT(nBuf < (sizeof(szBuffer)/sizeof(szBuffer[0])));

	CString strMessage;

	if (AfxGetApp() != NULL)
		strMessage = ((CString) (AfxGetApp()->m_pszExeName)) + _T(": ");
	strMessage += szBuffer;
	OutputDebugString(strMessage);

	va_end(args);
}


#endif // _PSEUDO_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xslwiz\debug.h ===
#if !defined(AFX_DEBUG_H__FF0FA094_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
#define AFX_DEBUG_H__FF0FA094_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _PSEUDO_DEBUG

#undef TRACE
#undef VERIFY
#undef ASSERT
#undef THIS_FILE
#undef TRACE0
#undef TRACE1
#undef TRACE2
#undef TRACE3


// Note: file names are still ANSI strings (filenames rarely need UNICODE)
BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine);

void Trace(LPCTSTR lpszFormat, ...);

// by default, debug break is asm int 3, or a call to DebugBreak, or nothing
#if defined(_M_IX86)
#define CustomDebugBreak() _asm { int 3 }
#else
#define CustomDebugBreak() DebugBreak()
#endif

#define TRACE              ::Trace
#define THIS_FILE          __FILE__
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && AssertFailedLine(THIS_FILE, __LINE__)) \
		CustomDebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              ::Trace(_T(sz))
#define TRACE1(sz, p1)          ::Trace(_T(sz), p1)
#define TRACE2(sz, p1, p2)      ::Trace(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  ::Trace(_T(sz), p1, p2, p3)

#endif // !_PSEUDO_DEBUG


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEBUG_H__FF0FA094_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xslwiz\exe.h ===
#if !defined(AFX_EXE_H__FF0FA08E_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
#define AFX_EXE_H__FF0FA08E_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

// TODO: You may add any other custom AppWizard-wide declarations here.


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXE_H__FF0FA08E_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xbgwiz\exeaw.cpp ===
// exeaw.cpp : implementation file
//

#include "stdafx.h"
#include "exe.h"
#include "exeaw.h"

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This is called immediately after the custom AppWizard is loaded.  Initialize
//  the state of the custom AppWizard here.
void CXbgAppWiz::InitCustomAppWiz()
{
#if 0
	// Create a new dialog chooser; CDialogChooser's constructor initializes
	//  its internal array with pointers to the steps.
	m_pChooser = new CDialogChooser;

	// Add build step to .hpj if there is one
	m_Dictionary[_T("HELP")] = _T("1");

	// Set the maximum number of steps.
	SetNumberOfSteps(LAST_DLG);

	// sets the right language DLL up for us
	m_Dictionary[_T("USE_DEFAULT_LANGUAGE")] = _T("1");
#endif
    SetNumberOfSteps(0);

    m_Dictionary[_T("PROJTYPE_XBOX")] = _T("1");

	// TODO: Add any other custom AppWizard-wide initialization here.
}

// This is called just before the custom AppWizard is unloaded.
void CXbgAppWiz::ExitCustomAppWiz()
{
#if 0
	// Deallocate memory used for the dialog chooser
	ASSERT(m_pChooser != NULL);
	delete m_pChooser;
	m_pChooser = NULL;
#endif

	// TODO: Add code here to deallocate resources used by the custom AppWizard
}

#if 0
// This is called when the user clicks "Create..." on the New Project dialog
//  or "Next" on one of the custom AppWizard's steps.
CAppWizStepDlg* CXbgAppWiz::Next(CAppWizStepDlg* pDlg)
{
	// Delegate to the dialog chooser
	return NULL; //m_pChooser->Next(pDlg);
}

// This is called when the user clicks "Back" on one of the custom
//  AppWizard's steps.
CAppWizStepDlg* CXbgAppWiz::Back(CAppWizStepDlg* pDlg)
{
	// Delegate to the dialog chooser
	return NULL; // m_pChooser->Back(pDlg);
}
#endif

void CXbgAppWiz::GetPlatforms(CStringList& rPlatforms)
{
    POSITION pos = rPlatforms.GetHeadPosition();
	while(pos)
	{
		POSITION posCur = pos;
		CString str = rPlatforms.GetNext(pos);
		if(str != "Xbox")
			rPlatforms.RemoveAt(posCur);
	}
}

void CXbgAppWiz::CustomizeProject(IBuildProject* pProject)
{
	// TODO: Add code here to customize the project.  If you don't wish
	//  to customize project, you may remove this virtual override.

#if 0
    IConfigurations *picfgs;
    if(FAILED(pProject->get_Configurations(&picfgs)))
        picfgs = NULL;
	IConfiguration *picfg;
	long ccfg;
	if(!picfgs || SUCCEEDED(picfgs->get_Count(&ccfg)))
		ccfg = 0;
	for(int icfg = 1; icfg <= ccfg; ++icfg)
	{
		VARIANT v;
		v.vt = VT_I4;
		v.lVal = icfg;
		if(FAILED(picfgs->Item(v, &picfg)))
			picfg = NULL;
		BSTR bstrTool, bstrOpt;
		bstrTool = SysAllocString(L"cl.exe");
		bstrOpt = SysAllocString(L"/WX");
		if(picfg)
		{
			picfg->AddToolSettings(bstrTool, bstrOpt, v);
			picfg->Release();
		}
		SysFreeString(bstrTool);
		SysFreeString(bstrOpt);
	}
	if(picfgs)
		picfgs->Release();
#endif
	
	// This is called immediately after the default Debug and Release
	//  configurations have been created for each platform.  You may customize
	//  existing configurations on this project by using the methods
	//  of IBuildProject and IConfiguration such as AddToolSettings,
	//  RemoveToolSettings, and AddCustomBuildStep. These are documented in
	//  the Developer Studio object model documentation.

	// WARNING!!  IBuildProject and all interfaces you can get from it are OLE
	//  COM interfaces.  You must be careful to release all new interfaces
	//  you acquire.  In accordance with the standard rules of COM, you must
	//  NOT release pProject, unless you explicitly AddRef it, since pProject
	//  is passed as an "in" parameter to this function.  See the documentation
	//  on CCustomAppWiz::CustomizeProject for more information.

    // build a default remote location
    CComBSTR bszProjName;
    CComBSTR bszRmtName;
    pProject->get_Name(&bszProjName);
    CString strProjName(bszProjName);
    bszRmtName = "xe:\\" + strProjName + "\\" + strProjName + ".xbe";

	long lNumConfigs;
	CComPtr<IConfigurations> pConfigs;
	pProject->get_Configurations(&pConfigs);
	pConfigs->get_Count(&lNumConfigs);
	for (long j = 1 ; j < lNumConfigs+1 ; j++)
	{
		CComBSTR bszTool;
		CComBSTR bszSwitch;
		CComVariant Varj = j;
		CComVariant VarDummy;
		//Get each individual configuration
		CComPtr<IConfiguration> pConfig;
		pConfigs->Item(Varj, &pConfig);
		
		CComVariant VarDisp = pConfig;
		CComBSTR bszStr;
		pConfig->get_Name(&bszStr);
		// m_strBuildingConfigurationName = bszStr;

#if 0
		bszTool = "cl.exe";
		bszSwitch = "/D \"_AFXDLL\"";
		pConfig->RemoveToolSettings(bszTool,bszSwitch,VarDummy);
		
		bszTool = "link.exe";
		bszSwitch = "kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib";
		pConfig->AddToolSettings(bszTool,bszSwitch,VarDummy);
#endif
		
		bszTool = "MFC";
		bszSwitch = "0";
		pConfig->AddToolSettings(bszTool,bszSwitch,VarDummy);

		bszTool = "xbox!remotename";
		pConfig->AddToolSettings(bszTool, bszRmtName, VarDummy);

		bszTool = "cl.exe";
		bszSwitch = "/D \"_MBCS\"";
		pConfig->RemoveToolSettings(bszTool,bszSwitch,VarDummy);

		pConfig->MakeCurrentSettingsDefault(VarDummy);
	}
}


// Here we define one instance of the CXbgAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global Xbgaw.
CXbgAppWiz Xbgaw;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xbgwiz\makefile.inc ===
!include $(IDE_ROOT)\makefile.inc

exe.cpp: $(PACKVERCHECK)

exe.res: exe.rc exe.rc2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xslwiz\exe.cpp ===
// exe.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <afxdllx.h>
#include "exe.h"
#include "exeaw.h"

#include <atlimpl.cpp>

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CComModule _Module;

static AFX_EXTENSION_MODULE XslDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("EXE.AWX Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(XslDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(XslDLL);

		// Register this custom AppWizard with MFCAPWZ.DLL
		SetCustomAppWizClass(&Xslaw);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("EXE.AWX Terminating!\n");

		// Terminate the library before destructors are called
		AfxTermExtensionModule(XslDLL);
	}
	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xslwiz\makefile.inc ===
!include $(IDE_ROOT)\makefile.inc

exe.cpp: $(PACKVERCHECK)

exe.res: exe.rc exe.rc2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xbgwiz\exeaw.h ===
#if !defined(AFX_EXEAW_H__FF0FA092_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
#define AFX_EXEAW_H__FF0FA092_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_

// exeaw.h : header file
//

class CDialogChooser;

// All function calls made by mfcapwz.dll to this custom AppWizard (except for
//  GetCustomAppWizClass-- see exe.cpp) are through this class.  You may
//  choose to override more of the CCustomAppWiz virtual functions here to
//  further specialize the behavior of this custom AppWizard.
class CXbgAppWiz : public CCustomAppWiz
{
public:
	//virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
	//virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg);
		
	virtual void InitCustomAppWiz();
	virtual void ExitCustomAppWiz();
	virtual void CustomizeProject(IBuildProject* pProject);
    virtual void GetPlatforms(CStringList& rPlatforms);

protected:
	//CDialogChooser* m_pChooser;
};

// This declares the one instance of the CExeAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global Exeaw.  (Its definition is in exeaw.cpp.)
extern CXbgAppWiz Xbgaw;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXEAW_H__FF0FA092_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xbgwiz\stdafx.h ===
#if !defined(AFX_STDAFX_H__FF0FA090_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
#define AFX_STDAFX_H__FF0FA090_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#pragma warning(disable:4100) // 'unreferenced formal parameter'

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#include "debug.h"			// For ASSERT, VERIFY, and TRACE
#include <customaw.h>		// Custom AppWizard interface
#include <atlbase.h>

extern CComModule _Module;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__FF0FA090_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xslwiz\exeaw.h ===
#if !defined(AFX_EXEAW_H__FF0FA092_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
#define AFX_EXEAW_H__FF0FA092_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_

// exeaw.h : header file
//

class CDialogChooser;

// All function calls made by mfcapwz.dll to this custom AppWizard (except for
//  GetCustomAppWizClass-- see exe.cpp) are through this class.  You may
//  choose to override more of the CCustomAppWiz virtual functions here to
//  further specialize the behavior of this custom AppWizard.
class CXslAppWiz : public CCustomAppWiz
{
public:
	//virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
	//virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg);
		
	virtual void InitCustomAppWiz();
	virtual void ExitCustomAppWiz();
	virtual void CustomizeProject(IBuildProject* pProject);
    virtual void GetPlatforms(CStringList& rPlatforms);

protected:
	//CDialogChooser* m_pChooser;
};

// This declares the one instance of the CExeAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global Exeaw.  (Its definition is in exeaw.cpp.)
extern CXslAppWiz Xslaw;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXEAW_H__FF0FA092_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\cvtypes.h ===
//  CVTYPES.H
//
//  This file contains a common set of base type declarations
//  between multiple CodeView projects.  If you touch this in one
//  project be sure to copy it to all other projects as well.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef CV_PROJECT_BASE_TYPES
#define CV_PROJECT_BASE_TYPES

#if !defined(DOLPHIN)
#include "dbapiver.h"
#endif

#include "types.h"

typedef HANDLE HDEP;
typedef HANDLE HIND;

#if 0

// Phoey.  A Handle is a handle.  Clean up this later.  BryanT - 2/23/96

//  HDEP is a machine dependent size and passes as a general handle.
//  HIND is a machine independent sized handle and is used for things
//      which are passed between machines

#ifdef STRICT
DECLARE_HANDLE(HDEP);
DECLARE_HANDLE(HIND);
#else
typedef HANDLE  HDEP;
typedef HANDLE  HIND;
#endif

#endif

typedef HDEP FAR *  LPHDEP;
typedef HIND FAR *  LPHIND;

// HMEM should be avoided (HDEP should be used instead), but for now we'll
// define it for backwards compatibility.

typedef HDEP    HMEM;
typedef HMEM FAR *  LPHMEM;

// These values are used in the SegType field of the Expression Evaluator's
// TI structure, and as the third parameter to the Symbol Handler's
// SHGetNearestHsym function.

#define EECODE      0x01
#define EEDATA      0x02
#define EEANYSEG    0xFFFF

#ifdef STRICT
DECLARE_HANDLE(HPID);
DECLARE_HANDLE(HTID);
#else
typedef HIND    HPID;
typedef HIND    HTID;
#endif

typedef HPID FAR *LPHPID;
typedef HTID FAR *LPHTID;

typedef ULONG   SEGMENT;    // 32-bit compiler doesn't like "_segment"
typedef USHORT  SEG16;
typedef ULONG   SEG32;
typedef SEGMENT FAR * LPSEGMENT;
typedef ULONG   UOFF32;
typedef UOFF32 FAR * LPUOFF32;
typedef USHORT  UOFF16;
typedef UOFF16 FAR * LPUOFF16;
typedef LONG    OFF32;
typedef OFF32 FAR * LPOFF32;
typedef SHORT   OFF16;
typedef OFF16 FAR * LPOFF16;

typedef OFF32   SOFFSET;
typedef UOFF32  UOFFSET;
typedef UOFF32  OFFSET;
typedef SOFFSET FAR * LPSOFFSET;
typedef UOFFSET FAR * LPUOFFSET;
typedef OFFSET FAR * LPOFFSET;

//  address definitions
//  the address packet is always a 16:32 address.

typedef struct {
    UOFF32      off;
    SEGMENT     seg;
} address_t;

#define SegAddrT(a)   ((a).seg)
#define OffAddrT(a)   ((a).off)

#ifdef __cplusplus
void
__inline
AddrTInit(
    address_t * paddrT,
    SEGMENT segSet,
    UOFF32 offSet
    )
{
    SegAddrT(*(paddrT)) = segSet;
    OffAddrT(*(paddrT)) = offSet;
}
#else
#define AddrTInit(paddrT,segSet,offSet)     \
        {                                   \
            SegAddrT(*(paddrT)) = segSet;   \
            OffAddrT(*(paddrT)) = offSet;   \
        }
#endif

typedef struct {
    BYTE    fFlat   :1;         // true if address is flat
    BYTE    fOff32  :1;         // true if offset is 32 bits
    BYTE    fIsLI   :1;         // true if segment is linker index
    BYTE    fReal   :1;         // x86: is segment a real mode address
    BYTE    fSql    :1;         // true if execution context is SQL SP
        BYTE    fJava   :1;                     // true if Java addr
    BYTE    unused  :2;         // unused
} memmode_t;

#define MODE_IS_FLAT(m)     ((m).fFlat)
#define MODE_IS_OFF32(m)    ((m).fOff32)
#define MODE_IS_LI(m)       ((m).fIsLI)
#define MODE_IS_REAL(m)     ((m).fReal)

#ifdef __cplusplus
void
__inline
ModeInit(
    memmode_t *pmode,
    BOOL fFlat,
    BOOL fOff32,
    BOOL fLi,
    BOOL fRealSet
    )
{
    MODE_IS_FLAT(*(pmode))    = (BYTE)fFlat;
    MODE_IS_OFF32(*(pmode))   = (BYTE)fOff32;
    MODE_IS_LI(*(pmode))      = (BYTE)fLi;
    MODE_IS_REAL(*(pmode))    = (BYTE)fRealSet;
    pmode->fSql               = FALSE;
    pmode->fJava              = FALSE;
}
#else
#define ModeInit(pmode,fFlat,fOff32,fLi,fRealSet)   \
        {                                           \
            MODE_IS_FLAT(*(pmode))    = fFlat;      \
            MODE_IS_OFF32(*(pmode))   = fOff32;     \
            MODE_IS_LI(*(pmode))      = fLi;        \
            MODE_IS_REAL(*(pmode))    = fRealSet;   \
            (pmode)->fSql             = FALSE;      \
            (pmode)->fJava            = FALSE;	    \
        }
#endif

#ifdef STRICT
DECLARE_HANDLE(HEMI);
#else
typedef HIND    HEMI;           // Executable Module Index
#endif

typedef struct ADDR {
    address_t   addr;
    HEMI        emi;
    memmode_t   mode;
} ADDR;                     // An address specifier
typedef ADDR *  PADDR;
typedef ADDR *  LPADDR;

#define addrAddr(a)         ((a).addr)
#define emiAddr(a)          ((a).emi)
#define modeAddr(a)         ((a).mode)

#ifdef __cplusplus
void
__inline
AddrInit(
    LPADDR paddr,
    HEMI emiSet,
    SEGMENT segSet,
    UOFF32 offSet,
    BOOL fFlat,
    BOOL fOff32,
    BOOL fLi,
    BOOL fRealSet
    )
{
    AddrTInit( &(addrAddr(*(paddr))), segSet, offSet );
    emiAddr(*(paddr)) = emiSet;
    ModeInit( &(modeAddr(*(paddr))),fFlat,fOff32,fLi,fRealSet);
}
#else
#define AddrInit(paddr,emiSet,segSet,offSet,fFlat,fOff32,fLi,fRealSet)  \
        {                                                               \
            AddrTInit( &(addrAddr(*(paddr))), segSet, offSet );         \
            emiAddr(*(paddr)) = emiSet;                                 \
            ModeInit( &(modeAddr(*(paddr))),(BYTE)(fFlat),(BYTE)(fOff32),(BYTE)(fLi),(BYTE)(fRealSet)); \
        }
#endif

#define ADDR_IS_FLAT(a)     (MODE_IS_FLAT(modeAddr(a)))
#define ADDR_IS_OFF32(a)    (MODE_IS_OFF32(modeAddr(a)))
#define ADDR_IS_LI(a)       (MODE_IS_LI(modeAddr(a)))
#define ADDR_IS_REAL(a)     (MODE_IS_REAL(modeAddr(a)))

#define ADDRSEG16(a)        {ADDR_IS_FLAT(a) = FALSE; ADDR_IS_OFF32(a) = FALSE;}
#define ADDRSEG32(a)        {ADDR_IS_FLAT(a) = FALSE; ADDR_IS_OFF32(a) = TRUE;}
#define ADDRLIN32(a)        {ADDR_IS_FLAT(a) = TRUE;  ADDR_IS_OFF32(a) = TRUE;}

#define GetAddrSeg(a)       ((a).addr.seg)
#define GetAddrOff(a)       ((a).addr.off)
#define SetAddrSeg(a,s)     ((a)->addr.seg=s)
#define SetAddrOff(a,o)     ((a)->addr.off=o)

// Because an ADDR has some filler areas (in the mode and the address_t),
// it's bad to use memcmp two ADDRs to see if they're equal.  Use this
// macro instead.  (I deliberately left out the test for fAddr32(), because
// I think it's probably not necessary when comparing.)
#ifdef __cplusplus
BOOL
__inline
FAddrsEq(
    ADDR &a1,
    ADDR &a2
    )
{
    return
    (GetAddrOff(a1) == GetAddrOff(a2)) &&
    (GetAddrSeg(a1) == GetAddrSeg(a2)) &&
    (ADDR_IS_LI(a1) == ADDR_IS_LI(a2)) &&
    (emiAddr(a1)    == emiAddr(a2));
}
#else
#define FAddrsEq(a1, a2)                        \
    (                                           \
    GetAddrOff(a1) == GetAddrOff(a2) &&         \
    GetAddrSeg(a1) == GetAddrSeg(a2) &&         \
    ADDR_IS_LI(a1) == ADDR_IS_LI(a2) &&         \
    emiAddr(a1)    == emiAddr(a2)               \
    )
#endif

//  address definitions
//  the address packet is always a 16:32 address.

typedef struct FRAME {
    SEG16       SS;
    address_t   BP;
    SEG16       DS;
    memmode_t   mode;
    HPID        PID;
    HTID        TID;
    address_t   SLP;        // Static link pointer
} FRAME;
typedef FRAME *PFRAME;

#define addrFrameSS(a)     ((a).SS)
#define addrFrameBP(a)     ((a).BP)
#define GetFrameBPOff(a)   ((a).BP.off)
#define GetFrameBPSeg(a)   ((a).BP.seg)
#define SetFrameBPOff(a,o) ((a).BP.off = o)
#define SetFrameBPSeg(a,s) ((a).BP.seg = s)
#define GetFrameSLPOff(a)   ((a).SLP.off)
#define GetFrameSLPSeg(a)   ((a).SLP.seg)
#define SetFrameSLPOff(a,o) ((a).SLP.off = o)
#define SetFrameSLPSeg(a,s) ((a).SLP.seg = s)
#define FRAMEMODE(a)       ((a).mode)
#define FRAMEPID(a)        ((a).PID)
#define FRAMETID(a)        ((a).TID)

#define FrameFlat(a)       MODE_IS_FLAT((a).mode)
#define FrameOff32(a)      MODE_IS_OFF32((a).mode)
#define FrameReal(a)       MODE_IS_REAL((a).mode)

//  A few public types related to the linked list manager

typedef HDEP    HLLI;       // A handle to a linked list
typedef HDEP    HLLE;       // A handle to a linked list entry

typedef void (FAR PASCAL * LPFNKILLNODE)(LPVOID);
typedef int  (FAR PASCAL * LPFNFCMPNODE)(LPVOID, LPVOID, LONG );

typedef DWORD          LLF;    // Linked List Flags
#define llfNull         (LLF)0x0
#define llfAscending    (LLF)0x1
#define llfDescending   (LLF)0x2
#define fCmpLT              (-1)
#define fCmpEQ              (0)
#define fCmpGT              (1)

//  EXPCALL indicates that a function should use whatever calling
//      convention is preferable for exported functions.

#define EXPCALL         __stdcall

// copied from winnt.h:

#ifndef PAGE_NOACCESS

#define PAGE_NOACCESS          0x01
#define PAGE_READONLY          0x02
#define PAGE_READWRITE         0x04
#define PAGE_WRITECOPY         0x08
#define PAGE_EXECUTE           0x10
#define PAGE_EXECUTE_READ      0x20
#define PAGE_EXECUTE_READWRITE 0x40
#define PAGE_EXECUTE_WRITECOPY 0x80
#define PAGE_GUARD            0x100
#define PAGE_NOCACHE          0x200

#define MEM_COMMIT           0x1000
#define MEM_RESERVE          0x2000
#define MEM_FREE            0x10000

#define MEM_PRIVATE         0x20000
#define MEM_MAPPED          0x40000
#define MEM_IMAGE         0x1000000

#endif

typedef struct _MEMINFO {
    ADDR    addr;
    ADDR    addrAllocBase;
    UOFF32  uRegionSize;
    DWORD   dwProtect;
    DWORD   dwState;
    DWORD   dwType;
} MEMINFO;
typedef MEMINFO FAR * LPMEMINFO;

//  Return values for mtrcEndian -- big or little endian -- which
//  byte is [0] most or least significat byte

enum _END {
    endBig,
    endLittle
};
typedef DWORD END;

//  Return values for mtrcProcessorType

enum _MPT {
    mptix86  = 1,   // Intel X86
    mptm68k  = 2,   // Mac 68K
    mptdaxp  = 3,   // Alpha AXP
    mptmips  = 4,   // MIPS
    mptmppc  = 5,   // Mac PPC
    mptntppc = 6,   // NT PPC
        mptJavaVM10 = 7,        // Java VM
    mptUnknown
};
typedef DWORD MPT;

#include <dbgver.h>     // For AVS definition and support functions

#endif  // CV_PROJECT_BASE_TYPES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xslwiz\stdafx.h ===
#if !defined(AFX_STDAFX_H__FF0FA090_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
#define AFX_STDAFX_H__FF0FA090_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#pragma warning(disable:4100) // 'unreferenced formal parameter'

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#include "debug.h"			// For ASSERT, VERIFY, and TRACE
#include <customaw.h>		// Custom AppWizard interface
#include <atlbase.h>

extern CComModule _Module;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__FF0FA090_B53D_11D0_AE6D_D8DC2A000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\xslwiz\exeaw.cpp ===
// exeaw.cpp : implementation file
//

#include "stdafx.h"
#include "exe.h"
#include "exeaw.h"

#ifdef _PSEUDO_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This is called immediately after the custom AppWizard is loaded.  Initialize
//  the state of the custom AppWizard here.
void CXslAppWiz::InitCustomAppWiz()
{
#if 0
	// Create a new dialog chooser; CDialogChooser's constructor initializes
	//  its internal array with pointers to the steps.
	m_pChooser = new CDialogChooser;

	// Add build step to .hpj if there is one
	m_Dictionary[_T("HELP")] = _T("1");

	// Set the maximum number of steps.
	SetNumberOfSteps(LAST_DLG);

	// sets the right language DLL up for us
	m_Dictionary[_T("USE_DEFAULT_LANGUAGE")] = _T("1");
#endif
    SetNumberOfSteps(0);

    m_Dictionary[_T("PROJTYPE_XBOX")] = _T("1");
    m_Dictionary[_T("PROJTYPE_LIB")] = _T("TRUE");

	// TODO: Add any other custom AppWizard-wide initialization here.
}

// This is called just before the custom AppWizard is unloaded.
void CXslAppWiz::ExitCustomAppWiz()
{
#if 0
	// Deallocate memory used for the dialog chooser
	ASSERT(m_pChooser != NULL);
	delete m_pChooser;
	m_pChooser = NULL;
#endif

	// TODO: Add code here to deallocate resources used by the custom AppWizard
}

#if 0
// This is called when the user clicks "Create..." on the New Project dialog
//  or "Next" on one of the custom AppWizard's steps.
CAppWizStepDlg* CXslAppWiz::Next(CAppWizStepDlg* pDlg)
{
	// Delegate to the dialog chooser
	return NULL; //m_pChooser->Next(pDlg);
}

// This is called when the user clicks "Back" on one of the custom
//  AppWizard's steps.
CAppWizStepDlg* CXslAppWiz::Back(CAppWizStepDlg* pDlg)
{
	// Delegate to the dialog chooser
	return NULL; // m_pChooser->Back(pDlg);
}
#endif

void CXslAppWiz::GetPlatforms(CStringList& rPlatforms)
{
    POSITION pos = rPlatforms.GetHeadPosition();
	while(pos)
	{
		POSITION posCur = pos;
		CString str = rPlatforms.GetNext(pos);
		if(str != "Xbox")
			rPlatforms.RemoveAt(posCur);
	}
}

void CXslAppWiz::CustomizeProject(IBuildProject* pProject)
{
	// TODO: Add code here to customize the project.  If you don't wish
	//  to customize project, you may remove this virtual override.

#if 0
    IConfigurations *picfgs;
    if(FAILED(pProject->get_Configurations(&picfgs)))
        picfgs = NULL;
	IConfiguration *picfg;
	long ccfg;
	if(!picfgs || SUCCEEDED(picfgs->get_Count(&ccfg)))
		ccfg = 0;
	for(int icfg = 1; icfg <= ccfg; ++icfg)
	{
		VARIANT v;
		v.vt = VT_I4;
		v.lVal = icfg;
		if(FAILED(picfgs->Item(v, &picfg)))
			picfg = NULL;
		BSTR bstrTool, bstrOpt;
		bstrTool = SysAllocString(L"cl.exe");
		bstrOpt = SysAllocString(L"/WX");
		if(picfg)
		{
			picfg->AddToolSettings(bstrTool, bstrOpt, v);
			picfg->Release();
		}
		SysFreeString(bstrTool);
		SysFreeString(bstrOpt);
	}
	if(picfgs)
		picfgs->Release();
#endif
	
	// This is called immediately after the default Debug and Release
	//  configurations have been created for each platform.  You may customize
	//  existing configurations on this project by using the methods
	//  of IBuildProject and IConfiguration such as AddToolSettings,
	//  RemoveToolSettings, and AddCustomBuildStep. These are documented in
	//  the Developer Studio object model documentation.

	// WARNING!!  IBuildProject and all interfaces you can get from it are OLE
	//  COM interfaces.  You must be careful to release all new interfaces
	//  you acquire.  In accordance with the standard rules of COM, you must
	//  NOT release pProject, unless you explicitly AddRef it, since pProject
	//  is passed as an "in" parameter to this function.  See the documentation
	//  on CCustomAppWiz::CustomizeProject for more information.
	long lNumConfigs;
	CComPtr<IConfigurations> pConfigs;
	pProject->get_Configurations(&pConfigs);
	pConfigs->get_Count(&lNumConfigs);
	for (long j = 1 ; j < lNumConfigs+1 ; j++)
	{
		CComBSTR bszTool;
		CComBSTR bszSwitch;
		CComVariant Varj = j;
		CComVariant VarDummy;
		//Get each individual configuration
		CComPtr<IConfiguration> pConfig;
		pConfigs->Item(Varj, &pConfig);
		
		CComVariant VarDisp = pConfig;
		CComBSTR bszStr;
		pConfig->get_Name(&bszStr);
		// m_strBuildingConfigurationName = bszStr;

#if 0
		bszTool = "cl.exe";
		bszSwitch = "/D \"_AFXDLL\"";
		pConfig->RemoveToolSettings(bszTool,bszSwitch,VarDummy);
		
		bszTool = "link.exe";
		bszSwitch = "kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib";
		pConfig->AddToolSettings(bszTool,bszSwitch,VarDummy);
#endif
		
		bszTool = "MFC";
		bszSwitch = "0";
		pConfig->AddToolSettings(bszTool,bszSwitch,VarDummy);
		
                bszTool = "cl.exe";
                bszSwitch = "/D \"_MBCS\"";
                pConfig->RemoveToolSettings(bszTool,bszSwitch,VarDummy);

		pConfig->MakeCurrentSettingsDefault(VarDummy);
	}
}


// Here we define one instance of the CXslAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global Xslaw.
CXslAppWiz Xslaw;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\dbapiver.h ===
#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#define DBG_API_VERSION	6
#define DBG_API_SUBVERSION 4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\dbgver.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbgver.h

Abstract:

Author:

    Kent D. Forschmiedt (a-kentf) 25-Jan-1993

Environment:

    Win32, User Mode

--*/

#if ! defined _DBGVER_
#define _DBGVER_

#include <version.h>

/*
**  DBG_API_VERSION is the major version number used to specify the
**      api version of the debugger or debug dll.  For release versions
**      dlls will export this and debuggers will check against this
**      version to verify that it can use the dll.
**
**      For beta and debug versions, this number will be used in
**      conjunction with minor and revision numbers (probably derived
**      from SLM rmm & rup) to verify compatibility.
**
**      Until the API has stabilized, we will most likely have to
**      rev this version number for every major product release.
**
*/

#include "dbapiver.h"

/*  AVS - Api Version Structure:
**
**      All debug dlls should be prepared to return a pointer to this
**      structure conaining its vital statistics.  The debugger should
**      check first two characters of the dll's name against rgchType
**      and the version numbers as described in the DBG_API_VERSION
**      and show the user an error if any of these tests fail.
**
*/

typedef enum {
    rlvtRelease,
    rlvtBeta,
    rlvtDebug
} RLVT;     // ReLease Version Type

typedef struct _AVS {
    CHAR	rgchType [ 2 ];    // Component name (EE,EM,TL,SH,DM)
    WORD	rlvt;              // ReLease Version Type
    BYTE	iApiVer;           // DBG_API_VERSION
    BYTE	iApiSubVer;        // DBG_API_SUBVERSION
    WORD	iRup;              // Revision number
    DWORD	chBuild;           // Build of revision # (a,b,c,d)
	LSZ		lszTitle;          // User readable text describing the DLL
    MPT		mpt;               // CPU binary is running on
    WORD	iRmj;              // Major version number
    WORD	iRmm;              // Minor version number
} AVS;  // Api Version Structure
typedef AVS FAR *LPAVS;


/*  DBGVersionCheck:
**
**      All debug dlls should provide this API and support the return
**      of a pointer to the structure described above even before
**      initialization takes place.
*/

#if defined(_M_IX86)
#define __dbgver_cpu__ mptix86
#elif defined(_M_MRX000)
#define __dbgver_cpu__ mptmips
#elif defined(_M_ALPHA)
#define __dbgver_cpu__ mptdaxp
#elif defined(_M_PPC)
#define __dbgver_cpu__ mptntppc
#elif defined(_M_MPPC)
#define __dbgver_cpu__ mptmppc
#else
#error( "unknown target machine" );
#endif

#define DEBUG_VERSION(C1,C2,TITLE) \
AVS Avs = {      \
    { C1, C2 },         \
    rlvtDebug,          \
    DBG_API_VERSION,    \
    DBG_API_SUBVERSION, \
    0,                  \
    '\0',               \
    TITLE,              \
    __dbgver_cpu__,     \
    rmj,                \
    rmm,                \
    };

#define RELEASE_VERSION(C1,C2,TITLE)    \
AVS Avs = {      \
    { C1, C2 },         \
    rlvtRelease,        \
    DBG_API_VERSION,    \
    DBG_API_SUBVERSION, \
    0,                  \
    '\0',               \
    TITLE,              \
    __dbgver_cpu__,     \
    rmj,                \
    rmm,                \
};

#undef MINOR
#undef MAJOR

#define DBGVERSIONPROCNAME "OSDebug4VersionCheck"

typedef LPAVS (*DBGVERSIONPROC)(void);
LPAVS WINAPI OSDebug4VersionCheck( void );
LPAVS WINAPI WINDBGVersionCheck( void );


#define DBGVERSIONCHECK() \
    LPAVS WINAPI WINDBGVersionCheck( void ) { return &Avs; } \
    LPAVS WINAPI OSDebug4VersionCheck( void ) { return &Avs; }

#endif // _DBGVER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\eeapi.h ===
/**     eeapi.hxx - Public API to the Expression Evaluator
 *
 *      This file contains all types and APIs that are defined by
 *      the Expression Evaluator and are publicly accessible by
 *      other components.
 *
 *      Before including this file, you must include cvtypes.h and shapi.h
 */


/***    The master copy of this file resides in the CVINC project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 *      The projects known to use this version (1.00.00) are:
 *
 *          Codeview (uses version in CVINC project)
 *          Visual C++
 *          C/C++ expression evaluator (uses version in CVINC project)
 *          Cobol expression evaluator
 *          QC/Windows
 *          Pascal 2.0 expression evaluator
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef EE_API
#define EE_API

#ifdef __cplusplus
#pragma warning(disable: 4200) // "non-standard extension: zero-sized array"
#endif

//  **********************************************************************
//  *                                                                    *
//  *   Initialization Structures                                        *
//  *                                                                    *
//  **********************************************************************

typedef struct {
    void *  (PASCAL *pMHlpvAlloc)( UINT );
    void    (PASCAL *pMHFreeLpv)(void *);
    HEXE    (PASCAL *pSHGetNextExe)(HEXE);
    HEXE    (PASCAL *pSHHexeFromHmod)(HMOD);
    HMOD    (PASCAL *pSHGetNextMod)(HEXE, HMOD);
    PCXT    (PASCAL *pSHGetCxtFromHmod)(HMOD, PCXT);
    PCXT    (PASCAL *pSHSetCxt)(LPADDR, PCXT);
    PCXT    (PASCAL *pSHSetCxtMod)(LPADDR, PCXT);
    HSYM    (PASCAL *pSHFindNameInGlobal)(HSYM, PCXT, HVOID, SHFLAG, PFNCMP, PCXT);
    HSYM    (PASCAL *pSHFindNameInContext)(HSYM, PCXT, HVOID, SHFLAG, PFNCMP, PCXT);
    HSYM    (PASCAL *pSHGoToParent)(PCXT, PCXT);
    HSYM    (PASCAL *pSHHsymFromPcxt)(PCXT);
    HSYM    (PASCAL *pSHNextHsym)(HMOD, HSYM);
    PCXF    (PASCAL *pSHGetFuncCxf)(LPADDR, PCXF);
    char *  (PASCAL *pSHGetModName)(HMOD);
    char *  (PASCAL *pSHGetExeName)(HEXE);
    HEXE    (PASCAL *pSHGethExeFromName)(char *);
    UOFF32  (PASCAL *pSHGetNearestHsym)(LPADDR, HMOD, int, PHSYM);
    SHFLAG  (PASCAL *pSHIsInProlog)(PCXT);
    SHFLAG  (PASCAL *pSHIsAddrInCxt)(PCXT, LPADDR);
    UINT    (PASCAL *pSHModelFromAddr)(PADDR,LPW,LPB,UOFFSET *);
    HSYM    (PASCAL *pSHFindSLink32)( PCXT );

    BOOL    (PASCAL *pSLLineFromAddr) ( LPADDR, unsigned short *, SHOFF *, SHOFF * );
    BOOL    (PASCAL *pSLFLineToAddr)  ( HSF, WORD, LPADDR, SHOFF *, WORD * );
    char *  (PASCAL *pSLNameFromHsf)  ( HSF );
    HMOD    (PASCAL *pSLHmodFromHsf)  ( HEXE, HSF );
    HSF     (PASCAL *pSLHsfFromPcxt)  ( PCXT );
    HSF     (PASCAL *pSLHsfFromFile)  ( HMOD, char * );

    UOFF32  (PASCAL *pPHGetNearestHsym)(LPADDR, HEXE, PHSYM);
    HSYM    (PASCAL *pPHFindNameInPublics)(HSYM, HEXE, HVOID, SHFLAG, PFNCMP);
    HTYPE   (PASCAL *pTHGetTypeFromIndex)(HMOD, THIDX);
    HTYPE   (PASCAL *pTHGetNextType)(HMOD, HTYPE);
    HDEP    (PASCAL *pMHMemAllocate)(UINT);
    HDEP    (PASCAL *pMHMemReAlloc)(HDEP, UINT);
    void    (PASCAL *pMHMemFree)(HDEP);
    HVOID   (PASCAL *pMHMemLock)(HDEP);
    void    (PASCAL *pMHMemUnLock)(HDEP);
    SHFLAG  (PASCAL *pMHIsMemLocked)(HDEP);
    HVOID   (PASCAL *pMHOmfLock)(HVOID);
    void    (PASCAL *pMHOmfUnLock)(HVOID);
    SHFLAG  (PASCAL *pDHExecProc)(LPADDR, SHCALL);
    UINT    (PASCAL *pDHGetDebuggeeBytes)(ADDR, UINT, void *);
    UINT    (PASCAL *pDHPutDebuggeeBytes)(ADDR, UINT, void *);
    PSHREG  (PASCAL *pDHGetReg)(PSHREG, PCXT);
    PSHREG  (PASCAL *pDHSetReg)(PSHREG, PCXT);
    HDEP    (PASCAL *pDHSaveReg)(PCXT);
    void    (PASCAL *pDHRestoreReg)(HDEP, PCXT);
    char   *pin386mode;
    char   *pis_assign;
    void    (PASCAL *pquit)(UINT);
    ushort *pArrayDefault;
    SHFLAG  (PASCAL *pSHCompareRE)(char *, char *);
    SHFLAG  (PASCAL *pSHFixupAddr)(LPADDR);
    SHFLAG  (PASCAL *pSHUnFixupAddr)(LPADDR);
    SHFLAG  (PASCAL *pCVfnCmp)(HVOID, HVOID, char *, SHFLAG);
    SHFLAG  (PASCAL *pCVtdCmp)(HVOID, HVOID, char *, SHFLAG);
    SHFLAG  (PASCAL *pCVcsCmp)(HVOID, HVOID, char *, SHFLAG);
    UINT    (PASCAL *pCVAssertOut)(char *, char *, UINT);
    SHFLAG  (PASCAL *pDHSetupExecute)(LPHIND);
    SHFLAG  (PASCAL *pDHCleanUpExecute)(HIND);
    SHFLAG  (PASCAL *pDHStartExecute)(HIND, LPADDR, BOOL, SHCALL);
    HSYM    (PASCAL *pSHFindNameInTypes)( PCXT, LPSSTR, SHFLAG , PFNCMP , PCXT );
    UINT    (PASCAL *pSYProcessor)(DWORD);
    BOOL    (PASCAL *pTHAreTypesEqual)(HMOD, CV_typ_t, CV_typ_t);
	MPT		(PASCAL *pGetTargetProcessor) (HPID);
	BOOL	(PASCAL *pGetUnicodeStrings) ();
} CVF;  // CodeView kernel Functions exported to the Expression Evaluator
typedef CVF * PCVF;

// DO NOT CHANGE THESE DEFINITIONS FROM __cdecl to CDECL
// Windows.h will define CDECL to an empty string if it has not been defined.
// We will run into bugs if windows.h is included before
// any other header files.


typedef struct {
    short   (__cdecl *pintLoadDS)();
    char  * (__cdecl *pultoa)(ulong, char  *, int);
    char  * (__cdecl *pitoa)(int, char  *, int);
    char  * (__cdecl *pltoa)(long, char  *, int);
    int     (__cdecl *peprintf)(const char *, char *, char *, int);
    int     (__cdecl *psprintf)(char  *, const char *, ...);
    FLOAT10 (__cdecl *p_strtold)( const char  *, char  *  *);
} CRF;  // C Runtime functions exported to the Expression Evaluator
typedef CRF * PCRF;

typedef struct CI {
    char    cbCI;
    char    Version;
    CVF *   pStructCVAPI;
    CRF *   pStructCRuntime;
} CI;
typedef CI * PCI;


typedef struct HDR_TYPE {
    ushort  offname;
    ushort  lenname;
    ushort  offtrail;
} HDR_TYPE;
typedef HDR_TYPE *PHDR_TYPE;

//  **********************************************************************
//  *                                                                    *
//  *   the expr evaluator stuff                                         *
//  *                                                                    *
//  **********************************************************************

typedef HDEP            HSYML;      //* An hsym list
typedef HSYML *         PHSYML;     //* A pointer to a hsym list
typedef uint            EERADIX;
typedef EERADIX *       PEERADIX;
typedef uchar *         PEEFORMAT;
typedef ushort          EESTATUS;
typedef HDEP            EEHSTR;
typedef EEHSTR *        PEEHSTR;
typedef HDEP            HTM;
typedef HTM *           PHTM;
typedef HDEP            HTI;
typedef HTI *           PHTI;
typedef HDEP            HBCIA;      // Base class index array.
typedef HBCIA *         PHBCIA;

// Error return values
#define EENOERROR       0
#define EENOMEMORY      1
#define EEGENERAL       2
#define EEBADADDR       3
#define EECATASTROPHIC  0XFF

typedef enum {
    EEHORIZONTAL,
    EEVERTICAL,
    EEBPADDRESS
} EEDSP;                    // Display format specifier

typedef enum {
    ETIPRIMITIVE,
    ETIARRAY,
    ETIPOINTER,
    ETICLASS,
    ETIFUNCTION
} ETI;
typedef ETI *PETI;

typedef enum {
    EENOTEXP,
    EEAGGREGATE,
    EETYPE,
    EEPOINTER,
    EETYPENOTEXP,
    EETYPEPTR
} EEPDTYP;
typedef EEPDTYP *PEEPDTYP;

typedef struct TML {
    unsigned    cTMListMax;
    unsigned    cTMListAct;
    unsigned    iTMError;
    HDEP        hTMList;
} TML;
typedef TML *PTML;

typedef struct RTMI {
    ushort  fSegType    :1;
    ushort  fAddr       :1;
    ushort  fValue      :1;
    ushort  fSzBits     :1;
    ushort  fSzBytes    :1;
    ushort  fLvalue     :1;
    ushort  fSynthChild :1;
    ushort  fLabel      :1;
    CV_typ_t Type;
} RTMI;
typedef RTMI *    PRI;

typedef struct TMI {
    RTMI        fResponse;
    struct  {
        ushort  SegType    :4;
        ushort  fLvalue    :1;
        ushort  fAddrInReg :1;
        ushort  fBPRel     :1;
        ushort  fFunction  :1;
        ushort  fLData     :1;      // True if expression references local data
        ushort  fGData     :1;      // True if expression references global data
        ushort  fSynthChild:1;
        ushort  fLabel:1;
    };
    union   {
        ADDR    AI;
        ushort  hReg;               // This is really a CV_HREG_e
    };
    ulong       cbValue;
    char        Value[0];
} TMI;
typedef TMI *   PTI;

typedef struct {
    HSYM    hSym;
    CXT     CXT;
} HCS;

typedef struct {
    CXT     CXT;
    ushort  cHCS;
    HCS     rgHCS[0];
} CXTL;

typedef HDEP        HCXTL;
typedef HCXTL * PHCXTL;
typedef CXTL  * PCXTL;

//  Structures for Get/Free HSYMList

//  Search request / response flags for Get/Free HSYMList

#define  HSYMR_lexical  0x0001  // lexical out to function scope
#define  HSYMR_function 0x0002  // function scope
#define  HSYMR_class    0x0004  // class scope
#define  HSYMR_module   0x0008  // module scope
#define  HSYMR_global   0x0010  // global symbol table scope
#define  HSYMR_exe      0x0020  // all other module scope
#define  HSYMR_public   0x0040  // public symbols
#define  HSYMR_nocase   0x8000  // case insensitive
#define  HSYMR_allscopes   \
               (HSYMR_lexical    |\
                HSYMR_function   |\
                HSYMR_class      |\
                HSYMR_module     |\
                HSYMR_global     |\
                HSYMR_exe        |\
                HSYMR_public     |\
                HSYMR_nocase)


//  structure describing HSYM list for a context

typedef struct HSL_LIST {
    ushort      request;        // context that this block statisfies
    struct  {
        ushort  isused      :1; // block contains data if true
        ushort  hascxt      :1; // context packet has been stored
        ushort  complete    :1; // block is complete if true
        ushort  isclass     :1; // context is class if true
    } status;
    HSYM        hThis;          // handle of this pointer if class scope
    ushort      symbolcnt;      // number of symbol handles in this block
    CXT         Cxt;            // context for this block of symbols
    HSYM        hSym[];         // list of symbol handles
} HSL_LIST;
typedef HSL_LIST *PHSL_LIST;


typedef struct HSL_HEAD {
    ushort      size;           // number of bytes in buffer
    ushort      remaining;      // remaining space in buffer
    PHSL_LIST   pHSLList;       // pointer to current context list (EE internal)
    struct  {
        ushort  endsearch   :1; // end of search reached if true
        ushort  fatal       :1; // fatal error if true
    } status;
    ushort      blockcnt;       // number of CXT blocks in buffer
    ushort      symbolcnt;      // number of symbol handles in buffer
    HDEP        restart;        // handle of search restart information
} HSL_HEAD;
typedef HSL_HEAD *PHSL_HEAD;

typedef struct HINDEX_ARRAY {
    ushort      count;              // number of indices in this buffer.
    long        rgIndex[0];
}   HINDEX_ARRAY;
typedef HINDEX_ARRAY    *PHINDEX_ARRAY;

typedef struct {
    void     (PASCAL *pEEFreeStr)(EEHSTR);
    EESTATUS (PASCAL *pEEGetError)(PHTM, EESTATUS, PEEHSTR);
    EESTATUS (PASCAL *pEEParse)(const char *, EERADIX, SHFLAG, PHTM, ushort *);
    EESTATUS (PASCAL *pEEBindTM)(PHTM, PCXT, SHFLAG, SHFLAG);
    EESTATUS (PASCAL *pEEvaluateTM)(PHTM, PFRAME, EEDSP);
    EESTATUS (PASCAL *pEEGetExprFromTM)(PHTM, PEERADIX, PEEHSTR, ushort *);
    EESTATUS (PASCAL *pEEGetValueFromTM)(PHTM, EERADIX, PEEFORMAT, PEEHSTR);
    EESTATUS (PASCAL *pEEGetNameFromTM)(PHTM, PEEHSTR);
    EESTATUS (PASCAL *pEEGetTypeFromTM)(PHTM, EEHSTR, PEEHSTR, ulong);
    EESTATUS (PASCAL *pEEFormatCXTFromPCXT)(PCXT, PEEHSTR);
    void     (PASCAL *pEEFreeTM)(PHTM);
    EESTATUS (PASCAL *pEEParseBP)(char *, EERADIX, SHFLAG, PCXF, PTML, ulong, ushort *, SHFLAG);
    void     (PASCAL *pEEFreeTML)(PTML);
    EESTATUS (PASCAL *pEEInfoFromTM)(PHTM, PRI, PHTI);
    void     (PASCAL *pEEFreeTI)(PHTI);
    EESTATUS (PASCAL *pEEGetCXTLFromTM)(PHTM, PHCXTL);
    void     (PASCAL *pEEFreeCXTL)(PHCXTL);
    EESTATUS (PASCAL *pEEAssignTMToTM)(PHTM, PHTM);
    EEPDTYP  (PASCAL *pEEIsExpandable)(PHTM);
    SHFLAG   (PASCAL *pEEAreTypesEqual)(PHTM, PHTM);
    EESTATUS (PASCAL *pEEcChildrenTM)(PHTM, long *, PSHFLAG);
    EESTATUS (PASCAL *pEEGetChildTM)(PHTM, long, PHTM, ushort *, EERADIX, SHFLAG);
    EESTATUS (PASCAL *pEEDereferenceTM)(PHTM, PHTM, ushort *, SHFLAG);
    EESTATUS (PASCAL *pEEcParamTM)(PHTM, ushort *, PSHFLAG);
    EESTATUS (PASCAL *pEEGetParmTM)(PHTM, ushort, PHTM, ushort *, SHFLAG);
    EESTATUS (PASCAL *pEEGetTMFromHSYM)(HSYM, PCXT, PHTM, ushort *, SHFLAG, SHFLAG);
    void     (PASCAL *pEEFormatAddress)(PADDR, char *);
    EESTATUS (PASCAL *pEEGetHSYMList)(PHSYML, PCXT, ushort, uchar *, SHFLAG);
    void     (PASCAL *pEEFreeHSYMList)(PHSYML);
    EESTATUS (PASCAL *pEEGetExtendedTypeInfo)(PHTM, PETI);
    EESTATUS (PASCAL *pEEGetAccessFromTM)(PHTM, PEEHSTR, ulong);
    BOOL     (PASCAL *pEEEnableAutoClassCast)(BOOL);
    void     (PASCAL *pEEInvalidateCache)(void);
    EESTATUS (PASCAL *pEEcSynthChildTM)(PHTM, long *);
    EESTATUS (PASCAL *pEEGetBCIA)(PHTM, PHBCIA);
    void     (PASCAL *pEEFreeBCIA)(PHBCIA);
    SHFLAG   (PASCAL *pfnCmp)(HVOID, HVOID, char *, SHFLAG);
    SHFLAG   (PASCAL *ptdCmp)(HVOID, HVOID, char *, SHFLAG);
    SHFLAG   (PASCAL *pcsCmp)(HVOID, HVOID, char *, SHFLAG);
	MPT		 (PASCAL *pEESetTarget)(MPT);
	void (PASCAL *pEEUnload)();
} EXF;
typedef EXF * PEXF;

typedef struct EI {
    char    cbEI;
    char    Version;
    PEXF    pStructExprAPI;
    char    Language;
    char   *IdCharacters;
    char   *EETitle;
    char   *EESuffixes;
    char   *Assign;             // length prefixed assignment operator
} EI;
typedef EI * PEI;

// FNEEINIT is the prototype for the EEInitializeExpr function
typedef VOID EXPCALL FNEEINIT(CI *, EI *);
typedef FNEEINIT *  PFNEEINIT;
typedef FNEEINIT *  LPFNEEINIT;

// This is the only EE function that's actually exported from the DLL
FNEEINIT EEInitializeExpr;

#endif // EE_API
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\dbc.h ===
//--------------------------------------------------------------------
// DBC.H
//
// This contains a list of all the debugger callback notifications.
//
// There are multiple users of this file.  To use it, you must
// define a DECL_DBC macro to extract the pieces of information that
// you are interested in from this file.  For example, if you want
// the numerical value, name (as a string), and fRequest flag for
// each callback, you could write the following:
//
//  typedef struct {
//      DBC     dbc;
//      LPCSTR  lszDbc;
//      BOOL    fRequest;
//  } DBCINFO;
//
//  #define DECL_DBC(name, fRequest, dbct) { dbc##name, "dbc" #name, fRequest },
//
//  DBCINFO rgdbcinfo[] = {
//      #include "dbc.h"
//  };
//
//  #undef DECL_DBC
//--------------------------------------------------------------------

DECL_DBC(Nil,             FALSE, dbctStop)

DECL_DBC(Bpt,             FALSE, dbctStop)
DECL_DBC(CheckBpt,        TRUE,  dbctContinue)
DECL_DBC(SendBpt,         FALSE, dbctContinue)

DECL_DBC(WatchPoint,      FALSE, dbctStop)
DECL_DBC(CheckWatchPoint, TRUE,  dbctContinue)
DECL_DBC(SendWatchPoint,  FALSE, dbctContinue)

DECL_DBC(MsgBpt,          FALSE, dbctStop)
DECL_DBC(CheckMsgBpt,     TRUE,  dbctContinue)
DECL_DBC(SendMsgBpt,      FALSE, dbctContinue)

DECL_DBC(AsyncStop,       FALSE, dbctStop)     // Async stop has completed
DECL_DBC(EntryPoint,      FALSE, dbctStop)
DECL_DBC(LoadComplete,    FALSE, dbctStop)
DECL_DBC(Signal,          FALSE, dbctStop)
DECL_DBC(Exception,       FALSE, dbctMaybeContinue)

DECL_DBC(ExecuteDone,     FALSE, dbctStop)

DECL_DBC(Step,            FALSE, dbctStop)

DECL_DBC(CanStep,         TRUE,  dbctContinue)

DECL_DBC(NewProc,         FALSE, dbctContinue)
DECL_DBC(ProcTerm,        FALSE, dbctStop)
DECL_DBC(DeleteProc,      FALSE, dbctContinue)

DECL_DBC(CreateThread,    TRUE,  dbctStop)
DECL_DBC(ThreadTerm,      FALSE, dbctStop)
DECL_DBC(DeleteThread,    FALSE, dbctContinue)

DECL_DBC(ModLoad,         TRUE,	 dbctContinue)
DECL_DBC(ModFree,         FALSE, dbctContinue)
DECL_DBC(SegLoad,         FALSE, dbctContinue)

DECL_DBC(InfoAvail,       FALSE, dbctContinue) // i.e. OutputDebugString
DECL_DBC(InfoReq,         TRUE,  dbctContinue) // i.e. InputDebugString
DECL_DBC(Error,           FALSE, dbctStop)     // misc error reporting
DECL_DBC(ServiceDone,     FALSE, dbctStop)     // SystemService reporting completion

DECL_DBC(LastAddr,        TRUE,  dbctContinue) // get last address in source line

DECL_DBC(EmChange,        FALSE, dbctContinue)

DECL_DBC(CodeChanged,     FALSE, dbctContinue)
DECL_DBC(MemoryChanged,   FALSE, dbctContinue)

DECL_DBC(ThreadBlocked,   FALSE, dbctStop)

DECL_DBC(FlipScreen,      FALSE, dbctContinue)
DECL_DBC(HardMode,        FALSE, dbctContinue)
DECL_DBC(SoftMode,        FALSE, dbctContinue)

DECL_DBC(RemoteQuit,      FALSE, dbctStop)     // Might these be the same thing?
DECL_DBC(CommError,       FALSE, dbctStop)
DECL_DBC(ExitedFunction, TRUE,	dbctContinue)
						// We just exited a function (either stepped
                        // a RET, or stepped over a CALL)
                        //   wParam = nothing
                        //   lParam = LPADDR, points to some address
                        //       in the function we just exited; NOT
                        //       necessarily the very beginning of the func

DECL_DBC(SQLThread,       FALSE, dbctStop)

DECL_DBC(Max,             FALSE, dbctStop)

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\odtypes.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    odtypes.h

Abstract:

Author:

    David J. Gilman (davegi) 05-Apr-1992

Environment:

    Win32, User Mode


--*/

#if ! defined _ODTYPES_
#define _ODTYPES_

#include "types.h"
#include "cvtypes.h"

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif


//  If the following definitions do not produce a 32 bit type on your
//  platform, please fix it.
//

typedef void FAR * HANDLE32;
typedef HANDLE32 FAR * LPHANDLE32;

#if !defined(DECLARE_HANDLE32)
#ifdef STRICT
#define DECLARE_HANDLE32(name) struct name##__32 { int unused; }; typedef struct name##__32 FAR *name
#else
#define DECLARE_HANDLE32(name) typedef HANDLE32 name
#endif
#endif
//

typedef void FAR * HANDLE32;
typedef HANDLE32 FAR * LPHANDLE32;

#if !defined(DECLARE_HANDLE32)
#ifdef STRICT
#define DECLARE_HANDLE32(name) struct name##__32 { int unused; }; typedef struct name##__32 FAR *name
#else
#define DECLARE_HANDLE32(name) typedef HANDLE32 name
#endif
#endif

#ifdef STRICT

    DECLARE_HANDLE32(HTL);
    DECLARE_HANDLE32(HEM);
    DECLARE_HANDLE32(HOSDFILE);

#else

    typedef HIND HTL;               // handle to a transport layer
    typedef HIND HEM;               // handle to an execution model
    typedef HIND HOSDFILE;

#endif

typedef HTL  FAR *LPHTL;
typedef HEM  FAR *LPHEM;
typedef HEMI FAR *LPHEMI;


typedef char FAR *  LSZ;

#define OSDAPI WINAPI
#define OSDAPIV WINAPIV


//
// Error status codes
//

#define DECL_XOSD(n,v,s) n = v,

enum {
#include "xosd.h"
};
typedef LONG XOSD;
typedef XOSD FAR *LPXOSD;

#undef DECL_XOSD


//
// Debugger callback types
//

typedef enum DBCT {     // debugger callback types
    dbctStop,           // debuggee has stopped -- no more dbc's will be sent
    dbctContinue,       // debuggee is continuing to run
    dbctMaybeContinue,  // debuggee may or may not continue, depending on other
                        //  information.  Interpretation is DBC-specific.
} DBCT;

//
// Debugger callbacks
//

#define DECL_DBC(name, fRequest, dbct)  dbc##name,


typedef enum {
        #include "dbc.h"
} _DBC;

typedef DWORD DBC;

#undef DECL_DBC

//
// Debugger services export table
//

typedef struct {
    PVOID      (OSDAPI *  lpfnMHAlloc)        ( size_t );
    PVOID      (OSDAPI *  lpfnMHRealloc)      ( LPVOID, size_t );
    VOID       (OSDAPI *  lpfnMHFree)         ( LPVOID );

    HLLI       (OSDAPI *  lpfnLLInit)         ( DWORD,
                                                LLF,
                                                LPFNKILLNODE,
                                                LPFNFCMPNODE );
    HLLE       (OSDAPI *  lpfnLLCreate)       ( HLLI );
    VOID       (OSDAPI *  lpfnLLAdd)          ( HLLI, HLLE );
    VOID       (OSDAPI *  lpfnLLInsert)       ( HLLI, HLLE, DWORD );
    BOOL       (OSDAPI *  lpfnLLDelete)       ( HLLI, HLLE );
    HLLE       (OSDAPI *  lpfnLLNext)         ( HLLI, HLLE );
    DWORD      (OSDAPI *  lpfnLLDestroy)      ( HLLI );
    HLLE       (OSDAPI *  lpfnLLFind)         ( HLLI,
                                                HLLE,
                                                LPVOID,
                                                DWORD );
    DWORD      (OSDAPI *  lpfnLLSize)         ( HLLI );
    PVOID      (OSDAPI *  lpfnLLLock)         ( HLLE );
    VOID       (OSDAPI *  lpfnLLUnlock)       ( HLLE );
    HLLE       (OSDAPI *  lpfnLLLast)         ( HLLI );
    VOID       (OSDAPI *  lpfnLLAddHead)      ( HLLI, HLLE );
    BOOL       (OSDAPI *  lpfnLLRemove)       ( HLLI, HLLE );

    int        (OSDAPI *  lpfnLBAssert)       ( LPSTR, LPSTR, DWORD);
    int        (OSDAPI *  lpfnLBQuit)         ( DWORD );

    LPSTR      (OSDAPI *  lpfnSHGetSymbol)    ( LPADDR  addr1,
                                                LPADDR  addr2,
                                                SHORT   sop, // should be SOP
                                                LPVOID  lpodr // should be LPODR
                                              );
    DWORD      (OSDAPI * lpfnSHGetPublicAddr) ( LPADDR, LSZ );
#ifdef NT_BUILD_ONLY
    LPSTR      (OSDAPI * lpfnSHAddrToPublicName)(LPADDR, LPADDR);
#else
    LPSTR      (OSDAPI * lpfnSHAddrToPublicName)(LPADDR);
#endif
    LPVOID     (OSDAPI * lpfnSHGetDebugData)  ( HIND );

// BUGBUG kentf   this gets implemented!!!!! Soon!!!!!
    // DWORD      (OSDAPI *  lpfnSHLocateSymbolFile)( LPSTR, DWORD );

    PVOID      (OSDAPI *  lpfnSHLpGSNGetTable)( HIND );

#ifdef NT_BUILD_ONLY
    BOOL       (OSDAPI *  lpfnSHWantSymbols)  ( HIND );
#endif

    DWORD      (OSDAPI *  lpfnDHGetNumber)    ( LPSTR, LPLONG );
    MPT        (OSDAPI *  lpfnGetTargetProcessor)( HPID );
    LONG       (OSDAPI *  lpfnGetSet)         ( LPTSTR, LPTSTR, LPDWORD,
                                                BYTE*, DWORD, BOOL );

    PVOID      lpSHF;                  // really LPSHF

} DBF;  // DeBugger callback Functions

typedef DBF FAR *LPDBF;

// Thread State bits
typedef enum {
   tstRunnable   = 0,        // New thread, has not run yet.
   tstStopped    = 1,        // Thread is at a debug event
   tstRunning    = 2,        // Thread is currently running/runnable
   tstExiting    = 3,        // Thread is in the process of exiting
   tstDead       = 4,        // Thread is no longer schedulable
   tstRunMask    = 0xf,

   tstExcept1st  = 0x10,     // Thread is at first chance exception
   tstExcept2nd  = 0x20,     // Thread is at second change exception
   tstRip        = 0x30,     // Thread is in a RIP state
   tstExceptionMask = 0xf0,

   tstFrozen     = 0x100,    // Thread has been frozen by Debugger
   tstSuspended  = 0x200,    // Thread has been frozen by Other
   tstBlocked    = 0x300,    // Thread is blocked on something
                             // (i.e. a semaphore)
   tstSuspendMask= 0xf00,

   tstCritSec    = 0x1000,   // Thread is currently in a critical
                             // section.
   tstOtherMask  = 0xf000
} TSTATE;


// Process state bits
typedef enum {
    pstRunning = 0,
    pstStopped = 1,
    pstExited  = 2,
    pstDead    = 3
} PSTATE;


//
// Debug metrics.
//

enum _MTRC {
    mtrcProcessorType,
    mtrcProcessorLevel,
    mtrcEndian,
    mtrcThreads,
    mtrcCRegs,
    mtrcCFlags,
    mtrcExtRegs,
    mtrcExtFP,
    mtrcExtMMU,
    mtrcPidSize,
    mtrcTidSize,
    mtrcExceptionHandling,
    mtrcAssembler,
    mtrcAsync,
    mtrcAsyncStop,
    mtrcBreakPoints,
    mtrcReturnStep,
    mtrcShowDebuggee,
    mtrcHardSoftMode,
    mtrcRemote,
    mtrcOleRpc,         // Supports OLE Remote Procedure Call debugging?
    mtrcNativeDebugger, // Supports low-level debugging (eg MacsBug)
    mtrcOSVersion,
    mtrcMultInstances,
    mtrcTidValue // HACK for IDE
};
typedef DWORD MTRC;


enum _BPTS {
    bptsExec     = 0x0001,
    bptsDataC    = 0x0002,
    bptsDataW    = 0x0004,
    bptsDataR    = 0x0008,
    bptsRegC     = 0x0010,
    bptsRegW     = 0x0020,
    bptsRegR     = 0x0040,
    bptsMessage  = 0x0080,
    bptsMClass   = 0x0100,
    bptsRange    = 0x0200,
    bptsDataExec = 0x0400,
    bptsPrologOk = 0x0800   // BP in prolog is harmless
};
typedef DWORD BPTS;

enum {
    asyncRun    = 0x0001,   // Debuggee runs asynchronously from debugger
    asyncMem    = 0x0002,   // Can read/write memory asynchronously
    asyncStop   = 0x0004,   // Can stop/restart debuggee asynchronously
    asyncBP     = 0x0008,   // Can change breakpoints asynchronously
    asyncKill   = 0x0010,   // Can kill child asynchronously
    asyncWP     = 0x0020,   // Can change watchpoints asyncronously
    asyncSpawn  = 0x0040,   // Can spawn another process asynchronously
};
typedef DWORD ASYNC;

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//
// Types which we can't seem to escape
//

typedef struct {
    BYTE b[10];
} REAL10;
typedef REAL10 FAR * LPREAL10;



//
// Packet supplied to shell by dbcCanStep
//
//
typedef struct _CANSTEP {
    DWORD   Flags;

	union {
		UOFF32  PrologOffset;		// when flags == CANSTEP_YES
		UOFF32	ThunkSize;			// when flags == CANSTEP_THUNK_OVER
	};
	
} CANSTEP;

typedef CANSTEP FAR *LPCANSTEP;

#define CANSTEP_NO			0x00000000
#define CANSTEP_YES			0x00000001
#define CANSTEP_THUNK		0x00000002
#define CANSTEP_THUNK_OVER	0x00000003	// a step-over thunk

/*
 *  This structure is used in communicating a stop event to the EM.  It
 *      contains the most basic of information about the stopped thread.
 *      A "frame" pointer, a program counter and bits describing the type
 *      of segment stopped in.
 */

typedef struct _BPR {
    DWORD       dwNotify;       /* Tag to identify BP #          */
    UOFFSET     offEIP;         /* Program Counter offset        */
    UOFFSET     offEBP;         /* Frame pointer offset          */
    UOFFSET     offESP;         /* Stack pointer offset          */
    SEGMENT     segCS;          /* Program counter seletor       */
    SEGMENT     segSS;          /* Frame & Stack pointer offset  */
    DWORD       fFlat:1;
    DWORD       fOff32:1;
    DWORD       fReal:1;
} BPR; // BreakPoint Return

typedef BPR FAR *LPBPR;


//
// Exception reporting packet
//
//
typedef struct _EPR {
    BPR   bpr;
    DWORD dwFirstChance;
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD NumberParameters;
    DWORD ExceptionInformation[];
} EPR; // Exception Return

typedef EPR FAR *LPEPR;

//
// Structure passed with dbcInfoAvail
//
typedef struct _INFOAVAIL {
    DWORD   fReply;
    DWORD   fUniCode;
    BYTE    buffer[];   // the string
} INFOAVAIL; // InfoAvail return
typedef INFOAVAIL FAR * LPINFOAVAIL;

//
// Structure returned via dbcMsg*
//
typedef struct _MSGI {
    DWORD dwMessage;
    DWORD dwMask;
    ADDR  addr;
    CHAR  rgch [ ];
} MSGI;     // MeSsaGe Info
typedef MSGI FAR *LPMSGI;

//
// function information; derived from
// FPO, PDATA or whatever else there may be.
//
// This will contain information pertaining to the block
// containing the address specified in OSDGetFunctionInformation().
// It may be a nested block; it need not be an entire function.
//
typedef struct _FUNCTION_INFORMATION {
    ADDR    AddrStart;          // fixedup addresses
    ADDR    AddrPrologEnd;
    ADDR    AddrEnd;            // end of function
    //ADDR    FilterAddress;      // Address of exception filter
} FUNCTION_INFORMATION, *LPFUNCTION_INFORMATION;

#endif // _ODTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\symapi.h ===
#ifndef _SYMAPI_H_
#define _SYMAPI_H_
//	New interface for SAPI

//	If someone feels like turning this into IDL, be my guest.

interface ISymbolHandler /* : public IUnknown */
{
    virtual SHE     SHAddDll             (LSZ, BOOL) =0;          // Changed for NT
    virtual SHE     SHAddDllsToProcess   (VOID) =0;
    virtual SHE     SHLoadDll            (LSZ, BOOL) =0;
    virtual VOID    SHUnloadDll          (HEXE) =0;
    virtual UOFFSET SHGetDebugStart      (HSYM) =0;
    virtual LSZ     SHGetSymName         (HSYM, LSZ) =0;
    virtual BOOL    SHAddrFromHsym       (PADDR, HSYM) =0;        // Changed for NT
    virtual HMOD    SHHModGetNextGlobal  (HEXE *, HMOD) =0;
    virtual int     SHModelFromAddr      (PADDR, LPW, LPB, UOFFSET *) =0;
    virtual int     SHPublicNameToAddr   (PADDR, PADDR, LSZ) =0;
    virtual LSZ     SHGetSymbol          (LPADDR, LPADDR, SOP, LPODR) =0;
    virtual BOOL    SHGetPublicAddr      (PADDR, LSZ) =0;
    virtual BOOL    SHIsLabel            (HSYM) =0;

    virtual VOID    SHSetDebuggeeDir     (LSZ) =0;
    virtual BOOL    SHAddrToLabel        (PADDR, LSZ) =0;

    virtual int     SHGetSymLoc          (HSYM, LSZ, UINT, PCXT) =0;
    virtual BOOL    SHFIsAddrNonVirtual  (PADDR) =0;
    virtual BOOL    SHIsFarProc          (HSYM) =0;

    virtual HEXE    SHGetNextExe         (HEXE) =0;
    virtual HEXE    SHHexeFromHmod       (HMOD) =0;
    virtual HMOD    SHGetNextMod         (HEXE, HMOD) =0;
    virtual PCXT    SHGetCxtFromHmod     (HMOD, PCXT) =0;
    virtual PCXT    SHSetCxt             (PADDR, PCXT) =0;
    virtual PCXT    SHSetCxtMod          (PADDR, PCXT) =0;
    virtual HSYM    SHFindNameInGlobal   (HSYM,
                                             PCXT,
                                             LPSSTR,
                                             SHFLAG,
                                             PFNCMP,
                                             PCXT
                                            ) =0;
    virtual HSYM    SHFindNameInContext  (HSYM,
                                             PCXT,
                                             LPSSTR,
                                             SHFLAG,
                                             PFNCMP,
                                             PCXT
                                            ) =0;
    virtual HSYM    SHGoToParent         (PCXT, PCXT) =0;
    virtual HSYM    SHHsymFromPcxt       (PCXT) =0;
    virtual HSYM    SHNextHsym           (HMOD, HSYM) =0;
    virtual LPCH    SHGetModName         (HMOD) =0;
    virtual LPCH    SHGetExeName         (HEXE) =0;
    virtual HEXE    SHGethExeFromName    (LPCH) =0;
    virtual UOFF32  SHGetNearestHsym     (PADDR, HMOD, int, PHSYM) =0;
    virtual SHFLAG  SHIsInProlog         (PCXT) =0;
    virtual SHFLAG  SHIsAddrInCxt        (PCXT, PADDR) =0;
    virtual SHFLAG  SHCompareRE          (LPCH, LPCH, BOOL) =0;
    virtual BOOL    SHFindSymbol         (LSZ, PADDR, LPASR) =0;
    virtual UOFF32  PHGetNearestHsym     (PADDR, HEXE, PHSYM) =0;
    virtual HSYM    PHFindNameInPublics  (HSYM, HEXE, LPSSTR, SHFLAG, PFNCMP) =0;
    virtual HTYPE   THGetTypeFromIndex   (HMOD, THIDX) =0;
    virtual HTYPE   THGetNextType        (HMOD, HTYPE) =0;
    virtual LPVOID  SHLpGSNGetTable      (HEXE) =0;
    virtual BOOL    SHCanDisplay         (HSYM) =0;

    //  Source Line handler API Exports

    virtual BOOL    SLLineFromAddr       (LPADDR, LPW, SHOFF *, SHOFF *) =0;
    virtual BOOL    SLFLineToAddr        (HSF, WORD, LPADDR, SHOFF *, WORD *) =0;
    virtual LPCH    SLNameFromHsf        (HSF) =0;
    virtual LPCH    SLNameFromHmod       (HMOD, WORD) =0;
    virtual BOOL    SLFQueryModSrc       (HMOD) =0;
    virtual HMOD    SLHmodFromHsf        (HEXE, HSF) =0;
    virtual HSF     SLHsfFromPcxt        (PCXT) =0;
    virtual HSF     SLHsfFromFile        (HMOD, LSZ) =0;

    virtual int     SLCAddrFromLine      (HEXE, HMOD, LSZ, WORD, LPSLP *) =0;
    virtual VOID    SHFree               (PVOID) =0;
    virtual VOID    SHUnloadSymbolHandler(BOOL) =0;
// REVIEW: piersh
#ifdef NT_BUILD_ONLY
    virtual SHE     SHGetExeTimeStamp    (LPSTR, ULONG *) =0;
#else
    virtual SHE     SHGetExeTimeStamp    (LPSTR, ULONG* Time, ULONG* Check) =0;
#endif
    virtual VOID    SHPdbNameFromExe     (LSZ, LSZ, UINT) =0;
    virtual LPDEBUGDATA SHGetDebugData   (HEXE) =0;
    virtual BOOL    SHIsThunk            (HSYM, THUNK_ORDINAL*, ULONG* length) =0;
    virtual HSYM    SHFindSymInExe       (HEXE, LPSSTR, BOOL) =0;
    virtual HSYM    SHFindSLink32        (PCXT) =0;
    virtual BOOL    SHIsDllLoaded        (HEXE) =0;

// Entries added for NT work.

    virtual LSZ     SHGetModule          (PADDR, LSZ) =0;
    virtual PCXT    SHGetCxtFromHexe     (HEXE, PCXT) =0;
    virtual LPCH    SHGetModNameFromHexe (HEXE) =0;
    virtual LPCH    SHGetSymFName        (HEXE) =0;
    virtual HEXE    SHGethExeFromModuleName (LPCH) =0;
    virtual LSZ     SHLszGetErrorText    (SHE) =0;
    virtual BOOL    SHWantSymbols        (HEXE) =0;
    virtual HSYM    SHFindNameInTypes    ( PCXT, LPSSTR, SHFLAG, PFNCMP, PCXT ) =0;

// Entries added for separate type pools work
    virtual BOOL    THAreTypesEqual      (HMOD, CV_typ_t, CV_typ_t) =0;

// LoadDllEx is for V7 only (right now)
	virtual SHE     SHLoadDllEx          (LSZ	szName,
											 BOOL	fLoading,
											 ULONG	TimeStamp,
											 ULONG	CheckSum,
											 ULONG	LoadAddress,
											 HEXE*	lphexe) =0;
											 
// Entries for Edit and Continue work
    virtual LSZ     SHGetSrcPath (HMOD) =0;
    virtual LSZ     SHGetObjPath (HMOD) =0;
    virtual LSZ     SHGetCompileEnv (HMOD) =0;
    virtual BOOL    SHModSupportsEC(HMOD) =0;
    virtual BOOL    SHExeSupportsEC (HEXE) =0;
    virtual BOOL    SHModLinkedFromLib (HMOD) =0;

    virtual BOOL    SHModFromHmod ( HMOD, PHANDLE ) =0;	// get the underlying Pdb Mod
    virtual BOOL    SHFlushModSyms( HMOD ) =0;	// flush symbols for mod
    virtual void    SHUseAltPdb ( PFNPDBOpenValidateEx ) =0;
};

typedef ISymbolHandler* (__cdecl *LPFNSHINIT2)( KNF*, HPID hpid, HTID htid );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\enc.h ===
#ifndef _ENC_H_
#define _ENC_H_

#if !defined(PROXY_IMPL)
#define PROXY_IMPORT_EXPORT   __declspec(dllimport)
#else
#define PROXY_IMPORT_EXPORT   __declspec(dllexport)
#endif

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

// REVIEW: defined some random facility
#define FACILITY_ENC 101    
#define E_MEMMAP        MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 1 )
#define E_INITMEMALLOC  MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 2 )
#define E_EXPORTPUB     MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 3 )
#define E_FIXUP         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 4 )
#define E_MEMWRITE      MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 5 )
#define E_STACKWRITE    MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 6 )
#define E_OBJOPEN       MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 7 )
#define E_THUNKWRITE    MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 8 )
#define E_NOPDBSUPPORT  MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 9 )
#define E_TYPEPACKFAILED MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 10 )

//
//  Stack editing error code are between FIRST_SE_ERROR and LAST_SE_ERROR
//
#define E_SPNOTCANONICAL	MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 11 )

#define FIRST_SE_ERROR E_SPNOTCANONICAL

#define E_EXCEPTIONSTATE	MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 12 )
#define E_LOCALVARCHANGE	MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 13 )
#define E_IPNOTINEDIT		MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 14 )
#define E_FUNCSIGCHANGE     MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 15 )
#define E_FRAMESIZECHANGE   MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 16 )
#define E_LOCALREQCONDES    MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 17 )
#define E_UNSAFEFRAMECOND   MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 18 )
#define E_CANTFINDLINE      MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 19 )
#define E_DUPLICATEVAR      MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 20 )
#define E_FUNCBYTEMATCH     MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 21 )
#define E_REGISTERSPILL		MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 22 )

#define LAST_SE_ERROR E_REGISTERSPILL

#define E_NAMETYPECHANGE    MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 30 )
#define E_MISSINGSYMBOL     MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 31 )
#define E_IMAGEBASE         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ENC, 32 )

//
// PAY ATTENTION: have you updated LAST_SE_ERROR!
//

#define S_IPPOSCHANGE		MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ENC, 40 )
#define S_IPPOSNOCHANGE		MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ENC, 41 )
#define S_IPPOSCHANGEEH	    MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ENC, 42 )
#define S_NOCODECHANGE      MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ENC, 43 )

interface Sapi;

namespace enc {

    interface EditHelper;
    interface ImageEdit;

    interface EditHelper
    {
        virtual bool ReadImage(     // read bytes from the image
            PADDR paddr, 
            ULONG cb, 
            BYTE* pb ) PURE;
        virtual bool WriteImage(    // write bytes to the image
            PADDR paddr, 
            ULONG cb, 
            BYTE* pb ) PURE;
        virtual bool FixupAddr(         // convert seg:off to flat addr
            PADDR paddr ) PURE;
        virtual bool UnFixupAddr(       // convert flat addr to seg:off
            PADDR paddr ) PURE;
        virtual DWORD ImageBase(
            HANDLE hexe ) PURE;
/*
        virtual bool GetRegDesc(      // calls into OSD
            HPID hpid,
            HTID htid,
            DWORD ird,
            LPRD lprd
            ) PURE;
        virtual bool ReadRegister(    // calls into OSD
            HPID hpid,
            HTID htid,
            DWORD dwid,
            LPVOID lpValue
            ) PURE;

        virtual bool WriteRegister(    // calls into OSD
            HPID hpid,
            HTID htid,
            DWORD dwId,
            LPVOID lpValue
            ) PURE;
*/
        virtual void Trace( int level, const char* ) PURE;

        virtual bool FindImage(   // return full path and base addr for named DLL
            const char* name, 
            char fullPath[ _MAX_PATH ],    // out
            PADDR paddrBase ) PURE;              // out
    };

	struct MemUpdate {
		ADDR		 addr;
		RefPtr< SimpleArray< BYTE > > data;
	};
	typedef SimpleArray< MemUpdate > MemUpList;
	typedef RefPtr< MemUpList > RefMUList;

    interface EnumLink: public Enum {
        virtual void get( LPCSTR* pszExePath, 
			LPCSTR* pszCwd,
			LPCSTR* pszCmd,
			LPCSTR* pszOutFile ) pure;
    };

    interface Enc
    {
        PROXY_IMPORT_EXPORT 
            static Enc* theEnc();

        virtual HRESULT FInit( const char* szLogFile, EditHelper* phelper, ISymbolHandler* psapi ) PURE;

        virtual HRESULT pushNewEdit() PURE;
        virtual HRESULT InsertObject( HANDLE hmod, const char *szObjPath ) PURE;
        virtual HRESULT ApplyCurrentEdit() PURE;

        virtual HRESULT PopEdit() PURE;
        virtual void Close() PURE;

        virtual ImageEdit* currentEdit() PURE;
        static BOOL PASCAL PDBOpenValidateEx(char* szPDB, char* szPathOrig,
                char* szSearchPath, char* szMode,   ULONG sig, ULONG age,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
        PROXY_IMPORT_EXPORT 
        static BOOL PDBOpen(char* szPDB, char* szMode, ULONG sigInitial,
                    OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);

		//
		// methods to support stack frame editing
		//
		virtual bool FEditReplacesAddr( const PADDR paIp, bool fTop ) PURE;
		virtual HRESULT UpdateIpToEditIp( 
            PADDR   paIp,         // [IN, OUT] current IP
            PADDR   paBp,         // [IN]
            PADDR   paSp,         // [IN]
            PADDR   paEH,         // [IN, OUT]
            bool    fTos,		  // true if this frame is at top of stack
            ULONG linenumHint,    // if non-zero then probably the right source line after the edit
			RefMUList& rlist) PURE;
        //
        // enum for each exe touched by the current set of edits
        //
        virtual bool getEnumLink( EnumLink** ppenum ) PURE;
        virtual bool isEditedObject( HANDLE hmod ) PURE;
        virtual HRESULT ReloadImage( HANDLE hexe ) PURE;
        virtual bool isEditedImage( HANDLE hexe ) PURE;
    };

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\sherror.h ===
/*++

    This file contains the symbolic names and test for SH errors

--*/

DECL_STR( sheNone,                 0, "symbols loaded"               )
DECL_STR( sheNoSymbols,            1, "no symbols loaded"            )
DECL_STR( sheFutureSymbols,        2, "symbol format not supported"  )
DECL_STR( sheMustRelink,           3, "symbol format not supported"  )
DECL_STR( sheNotPacked,            4, "must run cvpack on symbols"   )
DECL_STR( sheOutOfMemory,          5, "out of memory"                )
DECL_STR( sheCorruptOmf,           6, "symbol information corrumpt"  )
DECL_STR( sheFileOpen,             7, "could not open symbol file"   )
DECL_STR( sheSuppressSyms,         8, "symbol loading suppressed"    )
DECL_STR( sheDeferSyms,            9, "symbol loading deferred"      )
DECL_STR( sheSymbolsConverted,    10, "symbols converted & loaded"   )
DECL_STR( sheBadTimeStamp,        11, "has mismatched timestamps"    )
DECL_STR( sheBadChecksum,         12, "has mismatched checksums"     )
DECL_STR( shePdbNotFound,         13, "can't find/open pdb file"     )
DECL_STR( shePdbBadSig,           14, "internal pdb signature doesn't match sym handler" )
DECL_STR( shePdbInvalidAge,       15, "pdb info doesn't match image" )
DECL_STR( shePdbOldFormat,        16, "pdb format is obsolete"       )
DECL_STR( sheConvertTIs,          17, "16 bit data must be converted to 32 bit")  // NB09 format, needs conversion to 32-bit type indices
DECL_STR( sheJavaInvalidClass,    18, "Invalid Java class"           )  // the class given is invalid
DECL_STR( sheJavaNoCurrentProcess,19, "No Java process"              )  // no current process
DECL_STR( sheJavaInvalidFile,     20, "Invalid Java file"            )  // the file given is invalid
DECL_STR( sheExportsConverted,    21, "exports loaded"               )

//
// Last resort error returned by SHLszGetErrorText()
// always the last one...
//
DECL_STR( sheMax,                22, "unknown symbol handler error" )  // marker for count of she's
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\comenvi.h ===
#ifndef __COMENVI_H__
#define __COMENVI_H__

//
// Class to interpret a buffer containing a list of null
// strings. List is terminated with a 0.
//

template <class T>
inline const T* EndStr( const T* sz );

template <class T>
class StrList   // input must be formatted correctly
{
public:
    StrList( const T* pStart )
        : m_first( pStart )
    {
        for ( m_end = pStart; m_end != 0 && *m_end != 0; m_end = EndStr( m_end ) )
            ;
    }

    unsigned long Count() const {
        unsigned long i=0;
        for ( iterator it = begin(); it != end(); ++it )
            ++i;
        return i;
    }

    typedef const T* _Nodeptr;

    class iterator  // based on STL forward iterator
    {
    public:
	    iterator()
		    {}
	    iterator(_Nodeptr _P)
		    : _Ptr(_P) {}
	    const T& operator*() const
		    {return *_Ptr; }
//	    const T* operator->() const
//		    {return (&**this); }
	    iterator& operator++()
		    {_Ptr = EndStr( _Ptr );
		    return (*this); }
	    iterator operator++(int)
		    {iterator _Tmp = *this;
		    ++*this;
		    return (_Tmp); }
	    bool operator==(const iterator& _X) const
		    {return (_Ptr == _X._Ptr); }
	    bool operator!=(const iterator& _X) const
		    {return (!(*this == _X)); }
	    _Nodeptr _Mynode() const
		    {return (_Ptr); }
    private:
        _Nodeptr _Ptr;
    };

    iterator begin() { return iterator( m_first ); }
    iterator end() { return iterator( m_end ); }
    iterator begin() const { return iterator( m_first ); }
    iterator end() const { return iterator( m_end ); }

    bool empty() const { return begin() == end(); }

private:

    const T* m_first;
    const T* m_end;
};

typedef StrList<_TCHAR> tcStrList;
inline const _TCHAR* EndStr( const _TCHAR* sz ) { return sz+_tcslen(sz)+1; }

//
//	Class to interpret a buffer containing environment data
//
//  Format:
//			[<tag>'\0'<value>'\0']*
//			'\0'
//
//	The environ contains a list of 0 or more tag-value pairs,
//  each of which is a '\0' terminated string. A '\0' terminates
//  the entire list. Thus the trivial environ is a single '\0'.
//
class StrEnviron
{
public:
    StrEnviron( const _TCHAR* pStart, const _TCHAR* pEnd = 0 )
        : m_strlist( pStart )
    {
        assert( pEnd == 0 || &*m_strlist.end() <= pEnd );
        assert( m_strlist.Count() % 2 == 0 );
        // REVIEW: how about some way to test these in release?
    }
    
    const _TCHAR* szValueForTag( const _TCHAR* szTag ) const {
        if ( szTag != 0 ) {
            tcStrList::iterator itEnd = m_strlist.end();
            for ( tcStrList::iterator it = m_strlist.begin(); it != itEnd; ++it )
            {
                assert( *it != 0 );
                if ( _tcscmp( &*it++, szTag ) == 0 ) {
                    return &*(it);
                }
            }
        }
        return 0;
    }

    bool empty() const { return m_strlist.empty(); }
    unsigned long Count() const { return m_strlist.Count()/2; }
#ifdef _OSTREAM_
    void Dump( ostream& o )
    {
        tcStrList::iterator itEnd = m_strlist.end();
        for ( tcStrList::iterator it = m_strlist.begin(); it != itEnd; ++it ) {
            o << &*it++ << " " << &*it << '\n';
        }
    }
#endif
private:
    tcStrList m_strlist;
};

//
// Class to interpret the environment data in a COMPILESYM record
//
// This field contains an ST followed by an environment
//
class CompEnviron: public StrEnviron
{
public:
    CompEnviron( const unsigned char* st, const unsigned char* pEnd ) 
        : StrEnviron( st + *st + 1 < pEnd  
        ? reinterpret_cast< const char* >( st ) + *st + 1 
        : 0 )
    {}
};

#define ENC_CWD "cwd" /* <the current working directory>*/
#define ENC_CL  "cl"  /*<full pathname to cl.exe> */
#define ENC_SRC "src" /*<full pathname to the source file>*/
#define ENC_CMD "cmd" /*<command line to reinvoke cl.exe with for an edit-n-continue recompile> */



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\od.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Od.h

Abstract:

    This file contains types and prototypes which are exposed
    to all OSDebug components and clients.

Author:

    Kent Forschmiedt (kentf) 10-Sep-1993

Environment:

    Win32, User Mode

--*/

#if ! defined _OD_
#define _OD_

#include "odtypes.h"

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//     Constants and other magic

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
//     OSDebug types and status codes
//

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


typedef XOSD (OSDAPI *LPFNSVC) ( DBC, HPID, HTID, LPARAM, LPARAM );
typedef XOSD (OSDAPI *TLFUNC)();
typedef XOSD (OSDAPI *EMFUNC)();

// callback for EM or TL to get and set workspace params
typedef LONG (OSDAPI * LPGETSETPROFILEPROC)(
    LPTSTR      KeyName,        // SubKey name (must be relative)
    LPTSTR      ValueName,      // value name
    DWORD*      dwType,         // type of data (valid only in the case of Set)
    BYTE*       Data,           // pointer to data
    DWORD       cbData,         // size of data (in bytes)
    BOOL        fSet            // TRUE = setting, FALSE = getting
    );

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
//     OSDebug API set
//

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
//     OSDebug Initialization/Termination
//


XOSD
OSDAPI
OSDInit(
    LPDBF lpdbf
    );

XOSD
OSDAPI
OSDTerm(
    VOID
    );



//
//     EM Management
//


enum {
    emNative,
    emNonNative
};
typedef DWORD EMTYPE;

#define EMISINFOSIZE 80
typedef struct _EMIS {
    DWORD fCanSetup;
    DWORD dwMaxPacket;
    DWORD dwOptPacket;
    DWORD dwInfoSize;
    TCHAR rgchInfo[EMISINFOSIZE];
} EMIS;
typedef EMIS * LPEMIS;

typedef struct _EMSS {
    //
    // emfSetup is called to tell the EM to fetch workspace
    // values from the shell.
    //

    // The EM may support three phases of setup;
    // Load, interact and save.
    // Load means call GetSet for each workspace parameter
    //  with fSet == FALSE.  The value will be returned, and
    //  the EM must remember it.
    // Interact means allow the user to perform configuration
    //  operations, like clicking things in a dialog.  The new
    //  values are remembered by the EM.
    // Save means the EM will call GetSet with fSet == TRUE for
    //  each configuration value; the shell-provided GetSet
    //  will store these as workspace values.
    //
    DWORD fLoad;
    DWORD fInteractive;
    DWORD fSave;
    LPVOID lpvPrivate;

    //
    // lParam is an instance or "this" value supplied by the shell,
    // and is only used when calling lpfnGetSet().
    //
    LPARAM lParam;

    LPGETSETPROFILEPROC lpfnGetSet;
} EMSS;
typedef EMSS * LPEMSS;


XOSD
OSDAPI
OSDAddEM(
    EMFUNC emfunc,
    LPDBF lpdbf,
    LPHEM lphem,
    EMTYPE emtype
    );

XOSD
OSDAPI
OSDDeleteEM(
    HEM hem
    );

XOSD
OSDAPI
OSDGetCurrentEM(
    HPID hpid,
    HTID htid,
    LPHEM lphem
    );

XOSD
OSDAPI
OSDNativeOnly(
    HPID hpid,
    HTID htid,
    DWORD fNativeOnly
    );

XOSD
OSDAPI
OSDUseEM(
    HPID hpid,
    HEM hem
    );

XOSD
OSDAPI
OSDDiscardEM(
    HPID hpid,
    HTID htid,
    HEM hem
    );

XOSD
OSDAPI
OSDDiscardTL(
        HPID    hpid,
        HTL             htl
        );

XOSD
OSDAPI
OSDEMGetInfo(
    HEM hem,
    LPEMIS lpemis
    );

XOSD
OSDAPI
OSDEMSetup(
    HEM hem,
    LPEMSS lpemss
    );



//
//     TL Management
//

#define TLISINFOSIZE 80
typedef struct _TLIS {
    DWORD fCanSetup;
    DWORD dwMaxPacket;
    DWORD dwOptPacket;
    DWORD dwInfoSize;
    DWORD fRemote;
    MPT   mpt;
    MPT   mptRemote;
    TCHAR rgchInfo[TLISINFOSIZE];
} TLIS;
typedef TLIS * LPTLIS;

typedef struct _TLSS {
    DWORD fLoad;
    DWORD fInteractive;
    DWORD fSave;
    LPVOID lpvPrivate;
    LPARAM lParam;
    LPGETSETPROFILEPROC lpfnGetSet;
    MPT mpt;
    BOOL fRMAttached;
} TLSS;
typedef TLSS * LPTLSS;



XOSD
OSDAPI
OSDAddTL(
    TLFUNC tlfunc,
    LPDBF lpdbf,
    LPHTL lphtl
    );

XOSD
OSDAPI
OSDStartTL(
    HTL htl
    );

XOSD
OSDAPI
OSDDeleteTL(
    HTL htl
    );

XOSD
OSDAPI
OSDTLGetInfo(
    HTL htl,
    LPTLIS lptlis
    );

XOSD
OSDAPI
OSDTLSetup(
    HTL htl,
    LPTLSS lptlss
    );

XOSD
OSDAPI
OSDDisconnect(
    HPID hpid,
    HTID htid
    );

//
//     Process, thread management
//

XOSD
OSDAPI
OSDCreateHpid(
    LPFNSVC lpfnsvcCallBack,
    HEM hemNative,
    HTL htl,
    LPHPID lphpid
    );

XOSD
OSDAPI
OSDDestroyHpid(
    HPID hpid
    );

XOSD
OSDAPI
OSDDestroyHtid(
    HPID hpid,
    HTID htid
    );


#define IDSTRINGSIZE 10
#define STATESTRINGSIZE 60
typedef struct _PST {
    DWORD dwProcessID;
    DWORD dwProcessState;
    TCHAR rgchProcessID[IDSTRINGSIZE];
    TCHAR rgchProcessState[STATESTRINGSIZE];
} PST;
typedef PST * LPPST;

typedef struct _TST {
    DWORD dwThreadID;
    DWORD dwSuspendCount;
    DWORD dwSuspendCountMax;
    DWORD dwPriority;
    DWORD dwPriorityMax;
    DWORD dwState;
    DWORD dwTeb;
    TCHAR rgchThreadID[IDSTRINGSIZE];
    TCHAR rgchState[STATESTRINGSIZE];
    TCHAR rgchPriority[STATESTRINGSIZE];
} TST;
typedef TST * LPTST;

XOSD
OSDAPI
OSDGetThreadStatus(
    HPID hpid,
    HTID htid,
    LPTST lptst
    );

XOSD
OSDAPI
OSDGetProcessStatus(
    HPID hpid,
    LPPST lppst
    );

XOSD
OSDAPI
OSDFreezeThread(
    HPID hpid,
    HTID htid,
    DWORD fFreeze
    );

XOSD
OSDAPI
OSDSetThreadPriority(
    HPID hpid,
    HTID htid,
    DWORD dwPriority
    );


//
//     Address manipulation
//
enum {
    adrCurrent,
    adrPC,
    adrBase,
    adrStack,
    adrData,
    adrTlsBase,
    adrBaseProlog
};
typedef DWORD ADR;


XOSD
OSDAPI
OSDGetAddr(
    HPID hpid,
    HTID htid,
    ADR adr,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDSetAddr(
    HPID hpid,
    HTID htid,
    ADR adr,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDFixupAddr(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDUnFixupAddr(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDSetEmi(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDRegisterEmi(
    HPID hpid,
    HEMI hemi,
    LPTSTR lsz
    );

XOSD
OSDAPI
OSDUnRegisterEmi(
    HPID hpid,
    HEMI hemi
    );

XOSD
OSDAPI
OSDCompareAddrs(
    HPID hpid,
    LPADDR lpaddr1,
    LPADDR lpaddr2,
    LPDWORD lpdwResult
    );


XOSD
OSDAPI
OSDGetMemoryInformation(
    HPID hpid,
    HTID htid,
    LPMEMINFO lpMemInfo
    );


XOSD
OSDAPI
OSDGetTimeStamp(
    HPID    hpid,
    HTID    htid,
    LPTSTR  Image,
    ULONG*  TimeStamp,  OPTIONAL
    ULONG*  CheckSum    OPTIONAL
    );


XOSD
OSDAPI
OSDCreateUserCrashDump(
	HPID	hpid,
	LPTSTR	szFileName
	);

//
//     Module lists
//

typedef struct _MODULE_LIST {
    DWORD           Count;
} MODULE_LIST;
typedef struct _MODULE_LIST * LPMODULE_LIST;

typedef struct _MODULE_ENTRY {
    DWORD   Flat;
    DWORD   Real;
    DWORD   Segment;
    DWORD   Selector;
    DWORD   Base;
    DWORD   Limit;
    DWORD   Type;
    DWORD   SectionCount;
    HEMI    Emi;
    TCHAR   Name[ MAX_PATH ];
} MODULE_ENTRY;
typedef struct _MODULE_ENTRY * LPMODULE_ENTRY;

#define ModuleListCount(m)                      ((m)->Count)
#define FirstModuleEntry(m)                     ((LPMODULE_ENTRY)((m)+1))
#define NextModuleEntry(e)                      ((e)+1)
#define NthModuleEntry(m,n)                     (FirstModuleEntry(m)+(n))

#define ModuleEntryFlat(e)                      ((e)->Flat)
#define ModuleEntryReal(e)                      ((e)->Real)
#define ModuleEntrySegment(e)                   ((e)->Segment)
#define ModuleEntrySelector(e)                  ((e)->Selector)
#define ModuleEntryBase(e)                      ((e)->Base)
#define ModuleEntryLimit(e)                     ((e)->Limit)
#define ModuleEntryType(e)                      ((e)->Type)
#define ModuleEntrySectionCount(e)              ((e)->SectionCount)
#define ModuleEntryName(e)                      ((e)->Name)
#define ModuleEntryEmi(e)                       ((e)->Emi)



XOSD
OSDAPI
OSDGetModuleList(
    HPID hpid,
    HTID htid,
    LPTSTR lszModuleName,
    LPMODULE_LIST * lplpModuleList
    );




//
//     Target Application load/unload
//

typedef struct _SPAWNORPHAN {
    DWORD   dwPid;          // pid of newly spawned process (0 on some systems)
    CHAR    rgchErr[512];   // error string, or "" for successful spawn
} SPAWNORPHAN;  // Data returned from OSDSpawnOrphan
typedef SPAWNORPHAN *LPSPAWNORPHAN;

XOSD
OSDAPI
OSDSpawnOrphan (
    HPID hpid,
    LPCTSTR lszRemoteExe,
    LPCTSTR lszCmdLine,
    LPCTSTR lszRemoteDir,
    LPSPAWNORPHAN FAR lpso,
    DWORD   dwFlags
    );


// Bit flags for dwFlags in ProgramLoad
#define ulfMultiProcess             0x0001L     // OS2, NT, and ?MAC?
#define ulfMinimizeApp              0x0002L     // Win32
#define ulfNoActivate               0x0004L     // Win32
#define ulfInheritHandles           0x0008L     // Win32  (DM only?)
#define ulfWowVdm                   0x0010L     // Win32
#define ulfJavaDebugUsingBrowser    0x0020L     // debug Java program using browser (instead of stand-alone)
#define ulfSqlDebug                 0x0040L     // SQL debugging wanted

XOSD
OSDAPI
OSDProgramLoad(
    HPID hpid,
    LPTSTR lszRemoteExe,
    LPTSTR lszArgs,
    LPTSTR lszWorkingDir,
    LPTSTR lszDebugger,
    DWORD dwFlags
    );

XOSD
OSDAPI
OSDProgramFree(
    HPID hpid
    );

XOSD
OSDAPI
OSDDebugActive(
    HPID hpid,
    LPVOID lpvData,
    DWORD cbData
    );

XOSD
OSDAPI
OSDSetPath(
    HPID hpid,
    DWORD fSet,
    LPTSTR lszPath
    );




//
//     Target execution control
//

typedef struct _EXOP {
    BYTE fSingleThread;
    BYTE fStepOver;
    BYTE fQueryStep;
    BYTE fInitialBP;
    BYTE fPassException;
    BYTE fSetFocus;
    BYTE fReturnValues;       // send back dbcExitedFunction
	BYTE fGo;				  // => ConsumeAllProcessEvents () before going
} EXOP;
typedef EXOP * LPEXOP;



XOSD
OSDAPI
OSDGo(
    HPID hpid,
    HTID htid,
    LPEXOP lpexop
    );

XOSD
OSDAPI
OSDSingleStep(
    HPID hpid,
    HTID htid,
    LPEXOP lpexop
    );

XOSD
OSDAPI
OSDRangeStep(
    HPID hpid,
    HTID htid,
    LPADDR lpaddrMin,
    LPADDR lpaddrMax,
    LPEXOP lpexop
    );

XOSD
OSDAPI
OSDReturnStep(
    HPID hpid,
    HTID htid,
    LPEXOP lpexop
    );

XOSD
OSDAPI
OSDAsyncStop(
    HPID hpid,
    DWORD fSetFocus
    );



//
//     Target function evaluation
//

XOSD
OSDAPI
OSDSetupExecute(
    HPID hpid,
    HTID htid,
    LPHIND lphind
    );

XOSD
OSDAPI
OSDStartExecute(
    HPID hpid,
    HIND hind,
    LPADDR lpaddr,
    DWORD fIgnoreEvents,
    DWORD fFar
    );

XOSD
OSDAPI
OSDCleanUpExecute(
    HPID hpid,
    HIND hind
    );



//
//     Target information
//

XOSD
OSDAPI
OSDGetDebugMetric(
    HPID hpid,
    HTID htid,
    MTRC mtrc,
    LPVOID lpv
    );



//
//     Target memory and objects
//


XOSD
OSDAPI
OSDReadMemory(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbRead
    );

XOSD
OSDAPI
OSDWriteMemory(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbWritten
    );

XOSD
OSDAPI
OSDGetObjectLength(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPUOFFSET lpuoffStart,
    LPUOFFSET lpuoffLength
    );

XOSD
OSDGetFunctionInformation(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPFUNCTION_INFORMATION lpFunctionInformation
    );



//
//     Target register manipulation
//


/*
**  Register types --- flags describing recommendations on
**      register display
*/

enum {
    rtProcessMask   = 0x03,     // Mask for processor type bits
                                // these are enumerates, not bitfields.
    rtCPU           = 0x01,     // Central Processing Unit
    rtFPU           = 0x02,     // Floating Point Unit

    rtProcessorMask = 0x040C, 
    rtMMX           = 0x04,     // Original MMX regs
    rtKatmai        = 0x08,     // Katmai regs
    rtWillamette    = 0x0C,     // Willamette
    rt3DNow         = 0x0400,   // 3DNow regs

    rtGroupMask     = 0xf0,     // Which group(s) register falls into
                                // Bitfields
    rtInvisible     = 0x10,     // Recommend no display
    rtRegular       = 0x20,     // Recommend regular display
    rtExtended      = 0x40,     // Recommend extended display
    rtSpecial       = 0x80,     // Special and hidden regs, e.g. kernel mode

    rtFmtTypeMask   = 0xf00,    // Mask of display formats
                                // these are enumerates, not bitfields.
    rtInteger       = 0x100,    // Unsigned integer format
    rtFloat         = 0x200,    // Floating point format
    rtAddress       = 0x300,    // Address format
//  rtCANNOTUSE     = 0x400,    // Used above for 3DNow

    rtMiscMask      = 0xf000,   // misc info
                                // Bitfields
    rtPC            = 0x1000,   // this is the PC
    rtFrame         = 0x2000,   // this reg affects the stack frame
    rtNewLine       = 0x4000,   // print a newline when listing

    rtFlags             = 0x8000    // Flags register (cast is to avoid warning)
};
typedef DWORD RT;   // Register Types

#define rtFmtTypeShift  8

enum {
    ftProcessMask   = 0x0f,     // Mask for processor type bits
                                // these are enumerates, not bitfields.
    ftCPU           = 0x01,     // Central Processing Unit
    ftFPU           = 0x02,     // Floating Point Unit
    ftMMU           = 0x03,     // Memory Manager Unit

    ftGroupMask     = 0xf0,     // Which group(s) register falls into
                                // Bitfields
    ftInvisible     = 0x10,     // Recommend no display
    ftRegular       = 0x20,     // Recommend regular display
    ftExtended      = 0x40,     // Recommend extended display
    ftSpecial       = 0x80,     // Special and hidden regs, e.g. kernel mode

    ftFmtTypeMask   = 0xf00,    // Mask of display formats
                                // these are enumerates, not bitfields.
    ftInteger       = 0x100,    // Unsigned integer format
    ftFloat         = 0x200,    // Floating point format
    ftAddress       = 0x300,    // Address format

    ftMiscMask      = 0xf000,   // misc info
                                // Bitfields
    ftPC            = 0x1000,   // this is the PC
    ftFrame         = 0x2000,   // this reg affects the stack frame
    ftNewLine       = 0x4000    // print a newline when listing
};
typedef DWORD FT;   // Flag Types

#define ftFmtTypeShift  8

/*
**  Register description:  This structure contains the description for
**      a register on the machine.  Note that dwId must be used to get
**      the value for this register but a different index is used to get
**      this description structure.
*/

typedef struct {
    LPTSTR      lszName;        /* Pointer into EM for registers name   */
    RT          rt;             /* Register Type flags                  */
    DWORD       dwcbits;        /* Number of bits in the register       */
    DWORD       dwGrp;
    DWORD       dwId;           /* Value to use with Read/Write Register*/
} RD;               // Register Description
typedef RD * LPRD;

/*
**  Flag Data description: This structure contains the description for
**      a flag on the machine.  Note that the dwId field contains the
**      value to be used with Read/Write register to get the register which
**      contains this flag.
*/
typedef struct _FD {
    LPTSTR         lszName;
    FT          ft;
    DWORD       dwcbits;
    DWORD       dwGrp;
    DWORD       dwId;
} FD;
typedef FD * LPFD;


XOSD
OSDAPI
OSDGetRegDesc(
    HPID hpid,
    HTID htid,
    DWORD ird,
    LPRD lprd
    );

XOSD
OSDAPI
OSDGetFlagDesc(
    HPID hpid,
    HTID htid,
    DWORD ifd,
    LPFD lpfd
    );

XOSD
OSDAPI
OSDReadRegister(
    HPID hpid,
    HTID htid,
    DWORD dwid,
    LPVOID lpValue
    );

XOSD
OSDAPI
OSDWriteRegister(
    HPID hpid,
    HTID htid,
    DWORD dwId,
    LPVOID lpValue
    );

XOSD
OSDAPI
OSDReadFlag(
    HPID hpid,
    HTID htid,
    DWORD dwId,
    LPVOID lpValue
    );

XOSD
OSDAPI
OSDWriteFlag(
    HPID hpid,
    HTID htid,
    DWORD dwId,
    LPVOID lpValue
    );

XOSD
OSDAPI
OSDSaveRegs(
    HPID hpid,
    HTID htid,
    LPHIND lphReg
    );

XOSD
OSDAPI
OSDRestoreRegs(
    HPID hpid,
    HTID htid,
    HIND hregs
    );





//
//     Breakpoints
//

enum {
    bptpExec,
    bptpDataC,
    bptpDataW,
    bptpDataR,
    bptpDataExec,
    bptpRegC,
    bptpRegW,
    bptpRegR,
    bptpMessage,
    bptpMClass,
    bptpInt,
    bptpRange
};
typedef DWORD BPTP;

enum {
    bpnsStop,
    bpnsContinue,
    bpnsCheck,
    bpnsMax             // donc for mac dm
};
typedef DWORD BPNS;

typedef struct _BPIS {
    BPTP   bptp;
    BPNS   bpns;
    DWORD  fOneThd;
    HTID   htid;
    union {
        struct {
            ADDR addr;
        } exec;
        struct {
            ADDR addr;
            DWORD cb;
            BOOL fEmulate;
        } data; 
        struct {
            DWORD dwId;
        } reg;
        struct {
            ADDR addr;
            DWORD imsg;
            DWORD cmsg;
        } msg;
        struct {
            ADDR addr;
            DWORD dwmask;
        } mcls;
        struct {
            DWORD ipt;
        } ipt;
        struct {
            ADDR addr;
            DWORD cb;
        } rng;
    };
} BPIS;
typedef BPIS * LPBPIS;

typedef struct _BPS {
    DWORD cbpis;
    DWORD cmsg;
    DWORD fSet;
        //    BPIS   rgbpis[];
    //    DWORD  rgdwMessage[];
    //    XOSD   rgxosd[];
    //    DWORD  rgdwNotification[];
} BPS;
typedef BPS * LPBPS;

#define RgBpis(B)         ((LPBPIS)(((LPBPS)(B)) + 1))
#define DwMessage(B)      ((LPDWORD)(RgBpis((B)) + ((LPBPS)(B))->cbpis))
#define RgXosd(B)         ((LPXOSD)(DwMessage((B)) + ((LPBPS)(B))->cmsg))
#define DwNotification(B) ((LPDWORD)(RgXosd((B)) + ((LPBPS)(B))->cbpis))
#define SizeofBPS(B)      ( sizeof(BPS) +                                    \
                          (((LPBPS)(B))->cbpis *                             \
                            (sizeof(BPIS) + sizeof(XOSD) + sizeof(DWORD))) + \
                          (((LPBPS)(B))->cmsg * sizeof(DWORD)) )

XOSD
OSDAPI
OSDBreakpoint(
    HPID hpid,
    LPBPS lpbps
    );






//
//     Assembly, Unassembly
//

enum {
    dopNone     = 0x00000000,
    dopAddr     = 0x00000001,   // put address (w/ seg) in front of disassm
    dopFlatAddr = 0x00000002,   // put flat address (no seg)
    dopOpcode   = 0x00000004,   // dump the Opcode
    dopOperands = 0x00000008,   // dump the Operands
    dopRaw      = 0x00000010,   // dump the raw code bytes
    dopEA       = 0x00000020,   // calculate the effective address
    dopSym      = 0x00000040,   // output symbols
    dopUpper    = 0x00000080,   // force upper case for all chars except syms
    dopHexUpper = 0x00000100    // force upper case for all hex constants
                                // (implied true if dopUpper is set)
};
typedef DWORD DOP;              // Disassembly OPtions


typedef struct _SDI {
    DOP    dop;              // Disassembly OPtions (see above)
    ADDR   addr;             // The address to disassemble
    BOOL   fAssocNext;       // This instruction is associated w/ the next one
    BOOL   fIsBranch;
    BOOL   fIsCall;
    BOOL   fJumpTable;
    ADDR   addrEA0;          // First effective address
    ADDR   addrEA1;          // Second effective address
    ADDR   addrEA2;          // Third effective address
    DWORD  cbEA0;            // First effective address size
    DWORD  cbEA1;            // Second effective address size
    DWORD  cbEA2;            // Third effective address size
    LONG   ichAddr;
    LONG   ichBytes;
    LONG   ichOpcode;
    LONG   ichOperands;
    LONG   ichComment;
    LONG   ichEA0;
    LONG   ichEA1;
    LONG   ichEA2;
    LPTSTR lpch;
} SDI;  // Structured DiSsassembly
typedef SDI *LPSDI;

XOSD
OSDAPI
OSDUnassemble(
    HPID hpid,
    HTID htid,
    LPSDI lpsdi
    );

XOSD
OSDAPI
OSDGetPrevInst(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPUOFFSET lpuoff
    );

XOSD
OSDAPI
OSDAssemble(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPTSTR lsz
    );




//
//     Stack tracing
//

XOSD
OSDAPI
OSDGetFrame(
    HPID hpid,
    HTID htid,
    DWORD cFrame,
    LPHTID lphtid
    );





//
//     Target host file i/o
//

XOSD
OSDAPI
OSDMakeFileHandle(
    HPID hpid,
    LPARAM lPrivateHandle,
    HOSDFILE * lphosdFile
    );

XOSD
OSDAPI
OSDDupFileHandle(
    HOSDFILE hosdFile,
    HOSDFILE * lphosdDup
    );


XOSD
OSDAPI
OSDCloseFile(
    HOSDFILE hosdFile
    );

XOSD
OSDAPI
OSDSeekFile(
    HOSDFILE hosdFile,
    DWORD dwLocationLo,
    DWORD dwLocationHi,
    DWORD dwOrigin
    );

XOSD
OSDAPI
OSDReadFile(
    HOSDFILE hosdFile,
    LPBYTE lpbBuffer,
    DWORD cbData,
    LPDWORD lpcbBytesRead
    );

XOSD
OSDAPI
OSDWriteFile(
    HOSDFILE hosdFile,
    LPBYTE lpbBuffer,
    DWORD cbData,
    LPDWORD lpdwBytesWritten
    );





//
//     Exception handling
//

//
// These are the actions which the debugger may take
// in response to an exception raised in the debuggee.
//
typedef enum _EXCEPTION_FILTER_DEFAULT {
    efdIgnore,
    efdNotify,
    efdCommand,
    efdStop
} EXCEPTION_FILTER_DEFAULT;
typedef EXCEPTION_FILTER_DEFAULT * LPEXCEPTION_FILTER_DEFAULT;

//
// commands understood by OSDGetExceptionState
//

typedef enum _EXCEPTION_CONTROL {
    exfFirst,
    exfNext,
    exfSpecified
} EXCEPTION_CONTROL;
typedef EXCEPTION_CONTROL * LPEXCEPTION_CONTROL;

//
// Exception information packet
//
#define EXCEPTION_STRING_SIZE 60
typedef struct _EXCEPTION_DESCRIPTION {
    DWORD                    dwExceptionCode;
    EXCEPTION_FILTER_DEFAULT efd;
    TCHAR                    rgchDescription[EXCEPTION_STRING_SIZE];
} EXCEPTION_DESCRIPTION;
typedef EXCEPTION_DESCRIPTION * LPEXCEPTION_DESCRIPTION;

XOSD
OSDAPI
OSDGetExceptionState(
    HPID hpid,
    HTID htid,
    LPEXCEPTION_DESCRIPTION lpExd,
    EXCEPTION_CONTROL exf
    );

XOSD
OSDAPI
OSDSetExceptionState (
    HPID hpid,
    HTID htid,
    LPEXCEPTION_DESCRIPTION lpExd
    );



//
//     Message information
//

enum {
    msgMaskNone  = 0x0,
    msgMaskWin   = 0x1,
    msgMaskInit  = 0x2,
    msgMaskInput = 0x4,
    msgMaskMouse = 0x8,
    msgMaskSys   = 0x10,
    msgMaskClip  = 0x20,
    msgMaskNC    = 0x40,
    msgMaskDDE   = 0x80,
    msgMaskOther = 0x100,
    msgMaskAll   = 0x0FFF,
};


typedef struct _MESSAGEINFO {
    DWORD   dwMsg;         //  Message number
    LPTSTR  lszMsgText;    //  Message Text
    DWORD   dwMsgMask;     //  Message mask
} MESSAGEINFO;
typedef struct _MESSAGEINFO *LPMESSAGEINFO;

//
//  MSG Map structure
//
typedef struct _MESSAGEMAP {
    DWORD          dwCount;      //  Number of elements
    LPMESSAGEINFO  lpMsgInfo;    //  Pointer to array
} MESSAGEMAP;
typedef struct _MESSAGEMAP *LPMESSAGEMAP;

XOSD
OSDAPI
OSDGetMessageMap(
    HPID hpid,
    HTID htid,
    LPMESSAGEMAP * lplpMessageMap
    );


typedef struct _MASKINFO {
    DWORD dwMask;
    LPTSTR lszMaskText;
} MASKINFO;
typedef MASKINFO * LPMASKINFO;

typedef struct _MASKMAP {
    DWORD dwCount;
    LPMASKINFO lpMaskInfo;
} MASKMAP;
typedef MASKMAP * LPMASKMAP;

XOSD
OSDAPI
OSDGetMessageMaskMap(
    HPID hpid,
    HTID htid,
    LPMASKMAP * lplpMaskMap
    );




//
//     Miscellaneous control functions
//

XOSD
OSDAPI
OSDShowDebuggee(
    HPID hpid,
    DWORD fShow
    );





//
//     Communication and synchronization with DM
//

XOSD
OSDAPI
OSDInfoReply(
    HPID hpid,
    HTID htid,
    LPVOID lpvData,
    DWORD cbData
    );


XOSD
OSDAPI
OSDContinue(
    HPID hpid,
    HTID htid
    );





//
//     OS Specific info and control
//

typedef struct _TASKENTRY {
    DWORD dwProcessID;
    TCHAR szProcessName[MAX_PATH];
} TASKENTRY;
typedef TASKENTRY * LPTASKENTRY;

typedef struct _TASKLIST {
    DWORD dwCount;
    LPTASKENTRY lpTaskEntry;
} TASKLIST;
typedef TASKLIST * LPTASKLIST;


XOSD
OSDAPI
OSDGetTaskList(
    HPID hpid,
    LPTASKLIST * lplpTaskList
    );


#include "ssvc.h"
#define FIRST_PRIVATE_SSVC 0x8000

XOSD
OSDAPI
OSDSystemService(
    HPID hpid,
    HTID htid,
    SSVC ssvc,
    LPVOID lpvData,
    DWORD cbData,
    LPDWORD lpcbReturned
    );




enum {
    dbmSoftMode,
    dbmHardMode
};

typedef DWORD DBM;

typedef struct _DBMI {
    HWND hWndFrame;
    HWND hWndMDIClient;
    HANDLE hAccelTable;
} DBMI;

XOSD
OSDAPI
OSDSetDebugMode(
    HPID hpid,
    DBM dbmService,
    LPVOID lpvData,
    DWORD cbData
    );


#define TL_ERROR_BUFFER_LENGTH  1024

XOSD
OSDAPI
OSDGetLastTLError(
    HTL     hTL,
    HPID    hpid,
    LPSTR   Buffer,
    ULONG   Length
    );

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
//    OSDebug notifications
//

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Data passed with dbc messages
//

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _OD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\tlui.h ===
#ifndef __TLUI_H__
#define __TLUI_H__

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

// Function prototype for the help callback function
typedef VOID (PASCAL * LPFNINVOKEHELP)(DWORD dwHelpId);

// Transport Layer UI Structure
typedef struct _TLUI
{
	HWND hwnd;
	HINSTANCE hmod;
	LPFNINVOKEHELP lpfnInvokeHelp;	// should be NULL if no help support available.
} TLUI;

// Transport Layer Command Line Structure
typedef struct _TLCL
{
	HWND hwnd;	// should be NULL to specify command line
	LPSTR *argv;
	LONG argc;
} TLCL;

// This declaration comes from afxpriv.h, the value for WM_COMMANDHELP should match the
// one in that file. We also need these values in some of the C only transport dlls
// so I am duplicating it here.

#ifndef __AFXPRIV_H__
#define WM_COMMANDHELP  0x365
#endif

#define IDD_TL_WIN32_SERIAL			0x0f80
#define IDD_TL_MAC_SERIAL			0x0f81
#define IDD_TL_PMAC_SERIAL			0x0f82

//#define IDD_TL_WIN32_ADSP			0x0f83
#define IDD_TL_MAC_ADSP				0x0f84
#define IDD_TL_PMAC_ADSP			0x0f85

#define IDD_TL_WIN32_TCPIP			0x0f86
#define IDD_TL_MAC_TCPIP			0x0f87
#define IDD_TL_PMAC_TCPIP			0x0f88

#define IDD_EM_MAC_SETUP			0x0F91

#endif // __TLUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\shapi.h ===
//  shapi.h - Public API to the Symbol Handler
//
//    This file contains all types and APIs that are defined by
//    the Symbol Handler and are publicly accessible by other
//    components.
//
//    Before including this file, you must include cvtypes.h.


//  The master copy of this file resides in the CVINC project.
//    All Microsoft projects are required to use the master copy without
//    modification.  Modification of the master version or a copy
//    without consultation with all parties concerned is extremely
//    risky.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef SH_API
#define SH_API

#define DECL_STR(n, v, s) n = v,
typedef enum {                  // Error returns from some SH functions
#include "sherror.h"
} SHE;
#undef DECL_STR

enum {
  sopNone  =  0,
  sopData  =  1,
  sopStack =  2,
  sopReg   =  4,
  sopLab   =  8,
  sopFcn   = 16,
  sopExact = 32
};
typedef short SOP;              // Symbol OPtions

typedef enum {
    fstNone,
    fstSymbol,
    fstPublic
} FST;                          // Function Symbol Type

typedef enum {
    fcdUnknown,
    fcdNear,
    fcdFar,
    fcdData
} FCD;                          // Function Call Distance (near/far/unknown)

typedef enum {
    fptUnknown,
    fptPresent,
    fptOmitted
} FPT;                          // Frame Pointer Type

typedef struct _ODR {
    FST     fst;
    FCD     fcd;
    FPT     fpt;
    WORD    cbProlog;
    DWORD   dwDeltaOff;
    LSZ     lszName;
} ODR;                          // OSDebug Return type
typedef ODR *LPODR;


typedef enum {
    astNone,
    astAddress,
    astRegister,
    astBaseOff
} AST;                          // Assembler symbol return Types

typedef struct _ASR {
    AST ast;
    union {
        struct {
            FCD  fcd;
            ADDR addr;
        };
        WORD   ireg;
        OFFSET off;
    };
} ASR;      // Assembler Symbol Return structure
typedef ASR *LPASR;

typedef HEMI            SHEMI;
typedef unsigned int    SHFLAG; // A TRUE/FALSE flag var
typedef SHFLAG *        PSHFLAG;
typedef SEGMENT         SHSEG;  // A segment/selector value
typedef UOFFSET         SHOFF;  // An offset value

typedef void *          HVOID;  // Generic handle type
typedef HIND            HMOD;   // A module handle
typedef HIND            HGRP;   // A group handle (sub group of module
                                //   currently either a seg or filename)
typedef HVOID           HPROC;  // A handle to a procedure
typedef HVOID           HBLK;   // A handle to a block.
typedef HVOID           HSF;    // A handle to source file table
typedef HIND            HEXE;   // An Executable file handle
typedef HVOID           HTYPE;  // A handle to a type
typedef HVOID           HSYM;   // A handle to a symbol
typedef HIND            HPDS;   // A handle to a process

typedef HSYM *          PHSYM;

typedef CV_typ_t        THIDX;

typedef struct CXT {
    ADDR  addr;
    HMOD  hMod;
    HGRP  hGrp;
    HPROC hProc;
    HBLK  hBlk;
} CXT;                          // General Symbol context pkt
typedef CXT *PCXT;

typedef struct CXF {
    CXT   cxt;
    FRAME Frame;
} CXF;                          // Symbol context pkt locked to a frame ptr
typedef CXF *PCXF;

typedef enum {
    SHFar,
    SHNear
} SHCALL;

typedef struct SHREG {
    unsigned short      hReg;
    union {
        unsigned char   Byte1;
        struct {
            unsigned short  Byte2;
            unsigned short  Byte2High;
        };
        struct {
            unsigned long Byte4;
            unsigned long Byte4High;
        };
        float  Byte4f;		// New field at DECs request
        double      Byte8;
        unsigned __int64 Byte8i;
        FLOAT10     Byte10;
    };
} SHREG;
typedef SHREG *PSHREG;

typedef struct _SLP {
    ADDR    addr;
    SHOFF   cb;
} SLP;                          // Source Line Pair (used by SLCAddrFromLine)
typedef SLP * LPSLP;

//  structure defining parameters of symbol to be searched for.  The address
//  of this structure is passed on the the EE's symbol compare routine.  Any
//  additional data required by the EE's routine must follow this structure.

typedef struct _SSTR {          // string with length byte and pointer to data
    LPB             lpName;     // pointer to the string itself
    unsigned char   cb;         // length byte
    unsigned char   searchmask; // mask to control symbol searching
    unsigned short  symtype;    // symbol types to be checked
    unsigned char * pRE;        // pointer to regular expression
} SSTR;
typedef SSTR *LPSSTR;

#define SSTR_proc       0x0001  // compare only procs with correct type
#define SSTR_data       0x0002  // compare only global data with correct type
#define SSTR_RE         0x0004  // compare using regular expression
#define SSTR_NoHash     0x0008  // do a linear search of the table
#define SSTR_symboltype 0x0010  // pass only symbols of symtype to the
                                //  comparison function.

#define SHpCXTFrompCXF(a)   (&((a)->cxt))
#define SHpFrameFrompCXF(a) (&(a)->Frame)
#define SHHMODFrompCXT(a)   ((a)->hMod)
#define SHHPROCFrompCXT(a)  ((a)->hProc)
#define SHHBLKFrompCXT(a)   ((a)->hBlk)
#define SHpADDRFrompCXT(a)  (&((a)->addr))
#define SHPAddrFromPCxf(a)  (SHpADDRFrompCXT(SHpCXTFrompCXF(a)))

#define SHIsCXTMod(a)       ((a)->hMod  && !(a)->hProc  && !(a)->hBlk)
#define SHIsCXTProc(a)      ((a)->hMod  &&  (a)->hProc  && !(a)->hBlk)
#define SHIsCXTBlk(a)       ((a)->hMod  &&  (a)->hProc  &&  (a)->hBlk)

#define SHHGRPFrompCXT(a)   ((a)->hGrp)

// comparison prototype
typedef SHFLAG  (FAR PASCAL *PFNCMP) (HVOID, HVOID, LSZ, SHFLAG);
typedef SHE     (FAR PASCAL *PFNVALIDATEEXE) (UINT, PVOID, LPSTR);
typedef BOOL    (FAR PASCAL *PFNVALIDATEDEBUGINFOFILE) (LPCSTR szFile, ULONG * errcode );

// definitions needed from pdb.h
typedef ULONG SIG;
typedef ULONG AGE;
struct PDB;
typedef struct PDB PDB;
typedef long EC;
#ifndef __PDB_INCLUDED__
enum { cbErrMax = 1024 };
#endif

typedef BOOL    (FAR PASCAL *PFNPDBOpenValidateEx) (
    /*const*/ char* szPDB,
    /*const*/ char* szPathOrig,
    /*const*/ char* szSearchPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    EC* pec,
    char szError[cbErrMax],
    PDB** pppdb);


#define LPFNSYM     PASCAL *
#define LPFNSYMC    CDECL *

typedef struct omap_tag {
    DWORD       rva;
    DWORD       rvaTo;
} OMAP, *LPOMAP;

typedef struct {
    DWORD Offset;
    DWORD Size;
    DWORD Flags;
} SECSTART, *LPSECSTART;

typedef struct _tagDEBUGDATA {
    union {
        PIMAGE_RUNTIME_FUNCTION_ENTRY lpRtf;          // Runtime function table - fpo or pdata
    PFPO_DATA lpFpo;
    };
    DWORD       cRtf;           // Count of rtf entries
    LPOMAP      lpOmapFrom;     // Omap table - From Source
    DWORD       cOmapFrom;      // Count of omap entries - From Source
    LPOMAP      lpOmapTo;       // Omap table - To Source
    DWORD       cOmapTo;        // Count of omap entries - To Source
    LPSECSTART  lpSecStart;     // Original section table (pre-Lego)
    SHE         she;
	DWORD       dwOrigAlign;    // Original section alignment (pre-Lego)
} DEBUGDATA, *LPDEBUGDATA;

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancilliary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    LSZ     szMod;                      // exe/dll
    LSZ     szLib;                      // lib if appropriate
    LSZ     szObj;                      // object file
    LSZ *   rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    _TCHAR  szValidatedFile[_MAX_PATH]; // output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

typedef struct _KNF {
    int   cb;

    PVOID (LPFNSYM lpfnMHAlloc)     (UINT);
    PVOID (LPFNSYM lpfnMHRealloc)   (PVOID, UINT);
    VOID  (LPFNSYM lpfnMHFree)      (PVOID);
    PVOID (LPFNSYM lpfnMHAllocHuge) (LONG, UINT);
    VOID  (LPFNSYM lpfnMHFreeHuge)  (PVOID);

    HDEP  (LPFNSYM lpfnMMAllocHmem) (UINT);
    VOID  (LPFNSYM lpfnMMFreeHmem)  (HDEP);
    PVOID (LPFNSYM lpfnMMLock)      (HDEP);
    VOID  (LPFNSYM lpfnMMUnlock)    (HDEP);

    HLLI  (LPFNSYM lpfnLLInit)      (DWORD, LLF, LPFNKILLNODE, LPFNFCMPNODE);
    HLLE  (LPFNSYM lpfnLLCreate)    (HLLI);
    VOID  (LPFNSYM lpfnLLAdd)       (HLLI, HLLE);
    VOID  (LPFNSYM lpfnLLAddHead)   (HLLI, HLLE);
    VOID  (LPFNSYM lpfnLLInsert)    (HLLI, HLLE, DWORD);
    BOOL  (LPFNSYM lpfnLLDelete)    (HLLI, HLLE);
    BOOL  (LPFNSYM lpfnLLRemove)    (HLLI, HLLE);
    DWORD (LPFNSYM lpfnLLDestroy)   (HLLI);
    HLLE  (LPFNSYM lpfnLLNext)      (HLLI, HLLE);
    HLLE  (LPFNSYM lpfnLLFind)      (HLLI, HLLE, PVOID, DWORD);
    HLLE  (LPFNSYM lpfnLLLast)      (HLLI);
    DWORD (LPFNSYM lpfnLLSize)      (HLLI);
    PVOID (LPFNSYM lpfnLLLock)      (HLLE);
    VOID  (LPFNSYM lpfnLLUnlock)    (HLLE);

    BOOL  (LPFNSYM lpfnLBPrintf)    (LPCH, LPCH, DWORD);
    BOOL  (LPFNSYM lpfnLBQuit)      (DWORD);

        UINT  (LPFNSYM lpfnSYOpen)      (LSZ);
    VOID  (LPFNSYM lpfnSYClose)     (UINT);
    UINT  (LPFNSYM lpfnSYReadFar)   (UINT, LPB, UINT);
    LONG  (LPFNSYM lpfnSYSeek)      (UINT, LONG, UINT);
    BOOL  (LPFNSYM lpfnSYFixupAddr) (PADDR);
    BOOL  (LPFNSYM lpfnSYUnFixupAddr)(PADDR);
    UINT  (LPFNSYM lpfnSYProcessor) (DWORD);

// Added/Changed for NT merge.

//    VOID  (LPFNSYM lpfn_searchenv)  (LSZ, LSZ, LSZ);
//    UINT  (LPFNSYMC lpfnsprintf)    (LSZ, LSZ, ...);
//    VOID  (LPFNSYM lpfn_splitpath)  (LSZ, LSZ, LSZ, LSZ, LSZ);
//    LSZ   (LPFNSYM lpfn_fullpath)   (LSZ, LSZ, UINT);
//    VOID  (LPFNSYM lpfn_makepath)   (LSZ, LSZ, LSZ, LSZ, LSZ);
//    UINT  (LPFNSYM lpfnstat)        (LSZ, LPCH);

    LONG  (LPFNSYM lpfnSYTell)          (UINT);
    UINT  (LPFNSYM lpfnSYFindExeFile)   (LSZ, LSZ, UINT, PVOID, PFNVALIDATEEXE);
    VOID  (LPFNSYM lpfnLoadedSymbols)   (SHE, HPID, LSZ);
    BOOL  (LPFNSYM lpfnSYGetDefaultShe) (LSZ, SHE *);

// Added for separate type pool work

    BOOL  (LPFNSYM pfnSYFindDebugInfoFile) ( PSEARCHDEBUGINFO );
    BOOL  (WINAPI * lpfnGetRegistryRoot)            ( LPTSTR, LPDWORD );

#ifdef NT_BUILD_ONLY
// Added for WinDbg back port 
    BOOL    (LPFNSYM lpfnSetProfileString)(LPCSTR, LPCSTR);
    BOOL    (LPFNSYM lpfnGetProfileString)(LPCSTR, LPSTR, ULONG, ULONG *);
#endif

} KNF;  // KerNel Functions exported to the Symbol Handler
typedef KNF *LPKNF;

typedef struct _SHF {
    int     cb;
    HPDS    (LPFNSYM pSHCreateProcess)      (VOID);
    VOID    (LPFNSYM pSHSetHpid)            (HPID);
    BOOL    (LPFNSYM pSHDeleteProcess)      (HPDS);
    HPDS    (LPFNSYM pSHChangeProcess)      (HPDS);
    SHE     (LPFNSYM pSHAddDll)             (LSZ, BOOL);          // Changed for NT
    SHE     (LPFNSYM pSHAddDllsToProcess)   (VOID);
    SHE     (LPFNSYM pSHLoadDll)            (LSZ, BOOL);
    VOID    (LPFNSYM pSHUnloadDll)          (HEXE);
    UOFFSET (LPFNSYM pSHGetDebugStart)      (HSYM);
    LSZ     (LPFNSYM pSHGetSymName)         (HSYM, LSZ);
    BOOL    (LPFNSYM pSHAddrFromHsym)       (PADDR, HSYM);        // Changed for NT
    HMOD    (LPFNSYM pSHHModGetNextGlobal)  (HEXE *, HMOD);
    int     (LPFNSYM pSHModelFromAddr)      (PADDR, LPW, LPB, UOFFSET *);
    int     (LPFNSYM pSHPublicNameToAddr)   (PADDR, PADDR, LSZ);
    LSZ     (LPFNSYM pSHGetSymbol)          (LPADDR, LPADDR, SOP, LPODR);
    BOOL    (LPFNSYM pSHGetPublicAddr)      (PADDR, LSZ);
    BOOL    (LPFNSYM pSHIsLabel)            (HSYM);

    VOID    (LPFNSYM pSHSetDebuggeeDir)     (LSZ);
//    VOID    (LPFNSYM pSHSetUserDir)         (LSZ);                // Deleted for NT
    BOOL    (LPFNSYM pSHAddrToLabel)        (PADDR, LSZ);

    int     (LPFNSYM pSHGetSymLoc)          (HSYM, LSZ, UINT, PCXT);
    BOOL    (LPFNSYM pSHFIsAddrNonVirtual)  (PADDR);
    BOOL    (LPFNSYM pSHIsFarProc)          (HSYM);

    HEXE    (LPFNSYM pSHGetNextExe)         (HEXE);
    HEXE    (LPFNSYM pSHHexeFromHmod)       (HMOD);
    HMOD    (LPFNSYM pSHGetNextMod)         (HEXE, HMOD);
    PCXT    (LPFNSYM pSHGetCxtFromHmod)     (HMOD, PCXT);
    PCXT    (LPFNSYM pSHSetCxt)             (PADDR, PCXT);
    PCXT    (LPFNSYM pSHSetCxtMod)          (PADDR, PCXT);
    HSYM    (LPFNSYM pSHFindNameInGlobal)   (HSYM,
                                             PCXT,
                                             LPSSTR,
                                             SHFLAG,
                                             PFNCMP,
                                             PCXT
                                            );
    HSYM    (LPFNSYM pSHFindNameInContext)  (HSYM,
                                             PCXT,
                                             LPSSTR,
                                             SHFLAG,
                                             PFNCMP,
                                             PCXT
                                            );
    HSYM    (LPFNSYM pSHGoToParent)         (PCXT, PCXT);
    HSYM    (LPFNSYM pSHHsymFromPcxt)       (PCXT);
    HSYM    (LPFNSYM pSHNextHsym)           (HMOD, HSYM);
    PCXF    (LPFNSYM pSHGetFuncCXF)         (PADDR, PCXF);
    LPCH    (LPFNSYM pSHGetModName)         (HMOD);
    LPCH    (LPFNSYM pSHGetExeName)         (HEXE);
    HEXE    (LPFNSYM pSHGethExeFromName)    (LPCH);
    UOFF32  (LPFNSYM pSHGetNearestHsym)     (PADDR, HMOD, int, PHSYM);
    SHFLAG  (LPFNSYM pSHIsInProlog)         (PCXT);
    SHFLAG  (LPFNSYM pSHIsAddrInCxt)        (PCXT, PADDR);
    SHFLAG  (LPFNSYM pSHCompareRE)          (LPCH, LPCH, BOOL);
    BOOL    (LPFNSYM pSHFindSymbol)         (LSZ, PADDR, LPASR);
    UOFF32  (LPFNSYM pPHGetNearestHsym)     (PADDR, HEXE, PHSYM);
    HSYM    (LPFNSYM pPHFindNameInPublics)  (HSYM, HEXE, LPSSTR, SHFLAG, PFNCMP);
    HTYPE   (LPFNSYM pTHGetTypeFromIndex)   (HMOD, THIDX);
    HTYPE   (LPFNSYM pTHGetNextType)        (HMOD, HTYPE);
    PVOID   (LPFNSYM pSHLpGSNGetTable)      (HEXE);
    BOOL    (LPFNSYM pSHCanDisplay)         (HSYM);

    //  Source Line handler API Exports

    BOOL    (LPFNSYM pSLLineFromAddr)       (LPADDR, LPW, SHOFF *, SHOFF *);
    BOOL    (LPFNSYM pSLFLineToAddr)        (HSF, WORD, LPADDR, SHOFF *, WORD *);
    LPCH    (LPFNSYM pSLNameFromHsf)        (HSF);
    LPCH    (LPFNSYM pSLNameFromHmod)       (HMOD, WORD);
    BOOL    (LPFNSYM pSLFQueryModSrc)       (HMOD);
    HMOD    (LPFNSYM pSLHmodFromHsf)        (HEXE, HSF);
    HSF     (LPFNSYM pSLHsfFromPcxt)        (PCXT);
    HSF     (LPFNSYM pSLHsfFromFile)        (HMOD, LSZ);

    int     (LPFNSYM pSLCAddrFromLine)      (HEXE, HMOD, LSZ, WORD, LPSLP *);
    VOID    (LPFNSYM pSHFree)               (PVOID);
    VOID    (LPFNSYM pSHUnloadSymbolHandler)(BOOL);
// REVIEW: piersh
#ifdef NT_BUILD_ONLY
    SHE     (LPFNSYM pSHGetExeTimeStamp)    (LPSTR, ULONG *);
#else
    SHE     (LPFNSYM pSHGetExeTimeStamp)    (LPSTR, ULONG* Time, ULONG* Check);
#endif
    VOID    (LPFNSYM pSHPdbNameFromExe)     (LSZ, LSZ, UINT);
    LPVOID  (LPFNSYM pSHGetDebugData)   (HEXE);
    BOOL    (LPFNSYM pSHIsThunk)            (HSYM, THUNK_ORDINAL*, ULONG* length);
    HSYM    (LPFNSYM pSHFindSymInExe)       (HEXE, LPSSTR, BOOL);
    HSYM    (LPFNSYM pSHFindSLink32)        (PCXT);
    BOOL    (LPFNSYM pSHIsDllLoaded)        (HEXE);

// Entries added for NT work.

    LSZ     (LPFNSYM pSHGetModule)          (PADDR, LSZ);
    PCXT    (LPFNSYM pSHGetCxtFromHexe)     (HEXE, PCXT);
    LPCH    (LPFNSYM pSHGetModNameFromHexe) (HEXE);
    LPCH    (LPFNSYM pSHGetSymFName)        (HEXE);
    HEXE    (LPFNSYM pSHGethExeFromModuleName) (LPCH);
    LSZ     (LPFNSYM pSHLszGetErrorText)    (SHE);
    BOOL    (LPFNSYM pSHWantSymbols)        (HEXE);
    HSYM    (LPFNSYM pSHFindNameInTypes)    ( PCXT, LPSSTR, SHFLAG, PFNCMP, PCXT );

// Entries added for separate type pools work
    BOOL    (LPFNSYM pTHAreTypesEqual)      (HMOD, CV_typ_t, CV_typ_t);

// LoadDllEx is for V7 only (right now)
	SHE     (LPFNSYM pSHLoadDllEx)          (LSZ	szName,
											 BOOL	fLoading,
											 ULONG	TimeStamp,
											 ULONG	CheckSum,
											 ULONG	LoadAddress,
											 HEXE*	lphexe);
											 
// Entries for Edit and Continue work
    LSZ     (LPFNSYM pSHGetSrcPath) (HMOD);
    LSZ     (LPFNSYM pSHGetObjPath) (HMOD);
    LSZ     (LPFNSYM pSHGetCompileEnv) (HMOD);
    BOOL    (LPFNSYM pSHModSupportsEC)(HMOD);
    BOOL    (LPFNSYM pSHExeSupportsEC) (HEXE);
    BOOL    (LPFNSYM pSHModLinkedFromLib) (HMOD);

    BOOL    (LPFNSYM pSHModFromHmod) ( HMOD, PHANDLE );	// get the underlying Pdb Mod
    BOOL    (LPFNSYM pSHFlushModSyms)( HMOD );	// flush symbols for mod
    void    (LPFNSYM pSHUseAltPdb) ( PFNPDBOpenValidateEx );

} SHF;  // Symbol Handler Functions
typedef SHF *LPSHF;

// FNSHINIT is the prototype for the SHInit function

typedef BOOL EXPCALL FNSHINIT(LPSHF *, LPKNF);

typedef FNSHINIT * LPFNSHINIT;
typedef FNSHINIT * PFNSHINIT;

typedef BOOL    (* LPFNSHUNINIT)(VOID);
typedef BOOL    (* LPFNSHSTARTBACKGROUND)(VOID);
typedef BOOL    (* LPFNSHSTOPBACKGROUND)(VOID);

// This is the only SH function that's actually exported from the DLL
FNSHINIT SHInit;

#endif // SH_API
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\crefobj.h ===
/*
 * CRefCountedObj
 *
 */

#pragma once

#if !defined(_CRefCountedObj_h)
#define _CRefCountedObj_h

#if defined(_DEBUG)
#define	Debug(x)	x
#else
#define	Debug(x)
#endif

// handles ref counted garbage collection and dyncasting

class CRefCountedObj {
private:
    unsigned	_cUses;

public:

    CRefCountedObj() {
        _cUses = 0;
        }

	// copy ctor, does not copy usage count of object being copied from
	CRefCountedObj ( const CRefCountedObj & ) {
		_cUses = 0;
		}

    // virtual dtor should cause all descendents of CRefCountedObj have to have a virtual dtor
    virtual ~CRefCountedObj() { }

	CRefCountedObj & operator= ( const CRefCountedObj & ) {
		return *this;
		}

	unsigned CUses() {
		return _cUses;
		}

    void Use() {
        _cUses++;
        }

    bool FUnUse() {
        return !(--_cUses);
        }
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\csymbuf.h ===
#ifndef _CSYMBUF_H_
#define _CSYMBUF_H_

#pragma warning( disable: 4786 )

class FuncBuffer;
typedef PROCSYM* PPROCSYM;
typedef PROCSYM32* PPROCSYM32;

//
// SymBuffer
//  understands the representation of cv symbolic information
//  as stored in an object file section. This object supplies
//  an interpretation of an existing buffer, it does not manage
//  the memory itself.
//

class SymBuffer 
{
public:
    typedef unsigned long ULONG;
    typedef ULONG SigType;
    SymBuffer( PB pbFirst = 0, CB cb = 0 ) : m_first( 0 ), m_last( 0 ), m_start( 0 )
    {
        Reset( pbFirst, cb );
    }
    void Reset( PB pbFirst, CB cb ) // set new buffer extent
    {
        m_sigSymsT = 0;
        assert( cb >= 0 );
        if ( pbFirst > 0 ) {
      	    m_sigSymsT = *reinterpret_cast<SigType*>(pbFirst);
            if ( m_sigSymsT == CV_SIGNATURE_C11 ) {
                m_first = reinterpret_cast<PSYM>(pbFirst+sizeof(SigType));
            } else {
                m_first = reinterpret_cast<PSYM>(pbFirst);
            }
        }
        m_last = reinterpret_cast<PSYM>(pbFirst+cb);
        m_start = pbFirst;
    }

    typedef PSYM _Nodeptr;

    class iterator  // based on STL forward iterator
    {
    public:
	    iterator()
		    {}
	    iterator(_Nodeptr _P)
		    : _Ptr(_P) {}
	    SYMTYPE& operator*() const
		    {return *_Ptr; }
	    SYMTYPE* operator->() const
		    {return (&**this); }
	    iterator& operator++()
		    {_Ptr = NextSym(_Ptr);
		    return (*this); }
	    iterator operator++(int)
		    {iterator _Tmp = *this;
		    ++*this;
		    return (_Tmp); }
	    bool operator==(const iterator& _X) const
		    {return (_Ptr == _X._Ptr); }
	    bool operator!=(const iterator& _X) const
		    {return (!(*this == _X)); }
	    _Nodeptr _Mynode() const
		    {return (_Ptr); }
    private:
        _Nodeptr _Ptr;
    };

    iterator findNextProcSyms( iterator it, FuncBuffer& rfb );
    iterator findNextFileSym( iterator it );

    iterator begin() { return iterator( m_first ); }
    iterator end() { return iterator( m_last ); }
    iterator begin() const { return iterator( m_first ); }
    iterator end() const { return iterator( m_last ); }

    bool empty() const { return begin() == end(); }
    
    CB offSym( PSYM psym ) 
    { 
        return asPb(psym)-pbfirst(); 
    }
    PSYM cvsymOff( CB off )
    {
        return asPsym( pbfirst()+off );
    }
    SigType signature() { return m_sigSymsT; }

    template <class T> 
    bool findSym( int s, T** t )
    {
        for ( iterator it = begin(); it != end(); ++it ) {
            if ( it->rectyp == s ) {
                if ( t ) *t = reinterpret_cast<T*>(&*it);
                return true;
            }
        }
        return false;
    }

    template <class T> 
    bool findNextSym( int s, T** t, iterator& it )
    {
        for ( ; it != end(); ++it ) {
            if ( it->rectyp == s ) {
                if ( t ) *t = reinterpret_cast<T*>(&*it);
                return true;
            }
        }
        return false;
    }
    CB Count() { return PB( m_last ) - m_start; }
    PB Base() { return m_start; }
    virtual PB pbStart() { return m_start; }
    void updateOffsets();
    void updateTypeServer( USHORT itsm );

protected:
     _Nodeptr first() const { return m_first; }
     _Nodeptr last() const { return m_last; }
     PB pbfirst() const { return asPb(m_first); }
    static inline PB asPb( PSYM psym ) { return reinterpret_cast<PB>( psym ); }
    static inline PSYM asPsym( PB pb ) { return reinterpret_cast<PSYM>( pb ); }
   
private:
    friend FuncBuffer;
    PB m_start;
    _Nodeptr m_first;
    _Nodeptr m_last;  // actually, one past the last byte of the buffer
    SigType m_sigSymsT;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\types.h ===
/**		types.h - Generic types
 *
 *		This file contains generic types such as USHORT, ushort,
 *		WORD, etc., which are not directly related to CodeView.
 *		Every attempt is made to define them in such a way as they
 *		will not conflict with the standard header files such as
 *		windows.h and os2.h.
 */


/***	The master copy of this file resides in the CVINC project.
 *		All Microsoft projects are required to use the master copy without
 *		modification.  Modification of the master version or a copy
 *		without consultation with all parties concerned is extremely
 *		risky.
 *
 *		The projects known to use this file are:
 *
 *			CodeView (uses version in CVINC project)
 *			C/C++ expression evaluator (uses version in CVINC project)
 *			Symbol Handler (uses version in CVINC project)
 *			Stump (OSDebug) (uses version in CVINC project)
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef CVINC_TYPES /* whole file */
#define CVINC_TYPES

#ifdef HOST32	/* { */

#define _export

#ifndef LOADDS
#define	LOADDS
#endif

#ifndef PASCAL
#define PASCAL __stdcall
#endif

#ifndef CDECL
#define	CDECL _cdecl
#endif

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif

#ifndef far
#define far
#endif

#ifndef FAR
#define	FAR far
#endif

#ifndef near
#define near
#endif

#ifndef NEAR
#define NEAR near
#endif

#ifndef _HUGE_
#define _HUGE_
#endif

// Use SEGBASED for based on a segment [e.g. SEGBASED(__segname("_CODE"))]
#ifndef SEGBASED
#define SEGBASED(x)
#endif

/*
**	This set of functions need to be expanded to deal with
**	unicode and other problems.
*/

// These #defines are taken care of by windowsx.h

#ifndef _INC_WINDOWSX

#define _ncalloc    calloc
#define _nexpand    expand
#define _ffree      free
#define _fmalloc    malloc
#define _fmemccpy   _memccpy
#define _fmemchr    memchr
#define _fmemcmp    memcmp
#define _fmemcpy    memcpy
#define _fmemicmp   _memicmp
#define _fmemmove   memmove
#define _fmemset    memset
#define _fmsize     _msize
#define _frealloc   realloc
#define _fstrcat    strcat
#define _fstrchr    strchr
#define _fstrcmp    strcmp
#define _fstrcpy    strcpy
#define _fstrcspn   strcspn
#define _fstrdup    _strdup
#define _fstricmp   _stricmp
#define _fstrlen    strlen
#define _fstrlwr    _strlwr
#define _fstrncat   strncat
#define _fstrncmp   strncmp
#define _fstrncpy   strncpy
#define _fstrnicmp  _strnicmp
#define _fstrnset   _strnset
#define _fstrpbrk   strpbrk
#define _fstrrchr   strrchr
#define _fstrrev    _strrev
#define _fstrset    _strset
#define _fstrspn    strspn
#define _fstrstr    strstr
#define _fstrtok    strtok
#define _fstrupr    _strupr
#define _nfree      free
#define _nmalloc    malloc
#define _nmsize     msize
#define _nrealloc   realloc
#define _nstrdup    _strdup
#define hmemcpy     memcpy

#endif

#define FP_OFF(x) x

#else	// !HOST32 }{

#ifndef LOADDS
#define LOADDS _loadds
#endif

#ifndef PASCAL
#define PASCAL _pascal
#endif

#ifndef CDECL
#define	CDECL _cdecl
#endif

#ifndef FASTCALL
#define FASTCALL _fastcall
#endif

#ifndef FAR
#define FAR _far
#endif

#ifndef NEAR
#define NEAR _near
#endif

#ifndef _HUGE_
#define _HUGE_ _huge
#endif

// Use SEGBASED for based on a segment [e.g. SEGBASED(__segname("_CODE"))]
#ifndef SEGBASED
#define SEGBASED(x) _based(x)
#endif

#endif	// HOST32 }

#ifndef INTERRUPT
#define INTERRUPT _interrupt
#endif

#ifndef LOCAL
#ifdef DEBUGVER
#define LOCAL
#else
#define LOCAL static
#endif
#endif

#ifndef GLOBAL
#define GLOBAL
#endif

#ifndef INLINE
#define INLINE __inline
#endif

//
// Things that come from either windows.h or os2.h
//

#if !defined(LOWORD) && !defined(OS2_INCLUDED)

	#define VOID			void

	typedef unsigned char	BYTE;

	typedef int				BOOL;

	#define LONG			long

#endif

//
// Things that come from windows.h and cwindows.h
//

#if !defined(LOWORD)

#if defined ( _WIN32 ) || defined ( _M_MPPC ) || defined ( _M_M68K )
	typedef void *			HANDLE;
#else
	typedef unsigned int	HANDLE;
#endif

	typedef HANDLE			HWND;
	typedef char FAR *		LPSTR;

	typedef unsigned short	WORD;
	typedef unsigned long	DWORD;


#endif

#if !defined ( WIN32 ) && !defined ( WIN32S ) && !defined ( WIN )

    typedef unsigned long       DWORD;
    typedef int                 BOOL;
    typedef unsigned char       BYTE;
    typedef unsigned short      WORD;
    typedef float               FLOAT;
    typedef FLOAT               *PFLOAT;
    typedef BOOL near           *PBOOL;
    typedef BOOL far            *LPBOOL;
    typedef BYTE near           *PBYTE;
    typedef BYTE far            *LPBYTE;
    typedef int near            *PINT;
    typedef int far             *LPINT;
    typedef WORD near           *PWORD;
    typedef WORD far            *LPWORD;
    typedef long far            *LPLONG;
    typedef DWORD near          *PDWORD;
    typedef DWORD far           *LPDWORD;
    typedef void far            *LPVOID;

    typedef int                 INT;
    typedef unsigned int        UINT;
    typedef unsigned int        *PUINT;

    typedef HANDLE FAR          *LPHANDLE;

#endif


//
// Things that come from os2.h
//

#if !defined(OS2_INCLUDED)

	#define CHAR			char

	typedef	unsigned char	UCHAR;
	typedef short			SHORT;
	typedef int				INT;
	typedef unsigned short	USHORT;
	typedef unsigned int	UINT;
	typedef unsigned long	ULONG;

	typedef char *			PCH;

#endif

#if !defined(LOWORD)

	#define LOWORD(l)	((WORD)(l))
	#define HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xFFFF))

#endif

#ifndef NULL
	#define	NULL		((void *) 0)
#endif

#if !defined(TRUE) || !defined(FALSE)
	#undef TRUE
	#undef FALSE

	#define FALSE		0
	#define TRUE		1
#endif

#if !defined(fTrue) || !defined(fFalse)
	#undef fTrue
	#undef fFalse

	#define fFalse		0
	#define fTrue		1
#endif

#ifndef min
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#endif

#ifndef Unreferenced
#define	Unreferenced(a) ((void)a)
#endif

typedef unsigned short ushort;
typedef unsigned char  uchar;
typedef unsigned long  ulong;
typedef unsigned int   uint;

typedef void *		PV;
typedef void FAR *	LPV;

typedef char *		SZ;
typedef char FAR *	LSZ;
typedef char FAR *	LPCH;

typedef BOOL FAR *	LPF;
typedef BYTE FAR *	LPB;
typedef WORD FAR *  LPW;
typedef DWORD FAR * LPDW;
typedef LONG FAR *	LPL;
typedef ULONG FAR *	LPUL;
typedef USHORT FAR *LPUS;
typedef DWORD FAR *	LPDWORD;

typedef short		SWORD;

typedef UINT		WPARAM;
typedef LONG		LPARAM;

#ifdef HOST32
typedef ULONG		IWORD;
#else
typedef USHORT		IWORD;
#endif

#endif /* CVINC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\bsc.h ===
//
// bsc.h
//
// interface to browser information in a .PDB file
//

#ifndef __BSC_INCLUDED__
#define __BSC_INCLUDED__

#include <pdb.h>

typedef ULONG  IINST;
typedef ULONG  IREF;
typedef ULONG  IDEF;
typedef USHORT IMOD;

#define irefNil  ((IREF)-1)
#define idefNil  ((IDEF)-1)
#define iinstNil ((IINST)-1)

#define HTARGET ULONG

// The constant IINST value for the "Globals" class
#define IINST_GLOBALS	0xFFFF0001
#define isTheGlobalIinst(iinst) ((iinst) == IINST_GLOBALS)

typedef USHORT LINE;
typedef BYTE   TYP;
typedef USHORT ATR;
typedef ULONG MBF;

enum OPERATION
{
	addOp,
	delOp,
	changeOp,
	refreshAllOp,
	noOp
};

struct IinstInfo
{
	IINST m_iinst;
	SZ_CONST m_szName; // REVIEW: must be deleted (use Ni instead)!
	NI	m_ni; 
};

struct NiQ
{
    IINST m_iinstOld;
	IinstInfo m_iInfoNew;
	OPERATION m_op;
	TYP		m_typ;
};

typedef BOOL (*pfnNotifyChange) (NiQ * rgQ, ULONG cQ, HTARGET hTarget);

#define OUT

PdbInterface Bsc
{
	// open by name or by .pdb 
	static  PDBAPI(BOOL) open(PDB* ppdb, OUT Bsc** ppbsc);
	static 	PDBAPI(BOOL) open(SZ szName, OUT Bsc** ppbsc);
	virtual BOOL close() pure;

	// primitives for getting the information that underlies a handle
	virtual BOOL iinstInfo(IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR *patr) pure;
	virtual BOOL irefInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL idefInfo(IDEF idef, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL imodInfo(IMOD imod, OUT SZ *pszModule) pure;
	virtual SZ   szFrTyp(TYP typ) pure;
	virtual SZ   szFrAtr(ATR atr) pure;

	// primitives for managing object instances (iinst)
	virtual BOOL getIinstByvalue(SZ sz, TYP typ, ATR atr, OUT IINST *piinst) pure;
	virtual BOOL getOverloadArray(SZ sz, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;	
	virtual BOOL getUsedByArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getUsesArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getBaseArray(IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getDervArray(IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst)  pure;
	virtual BOOL getMembersArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;

	// primitives for getting definition and reference information	
	virtual BOOL getDefArray(IINST iinst, OUT IREF **ppidef, OUT ULONG *pciidef) pure;
	virtual BOOL getRefArray(IINST iinst, OUT IREF **ppiref, OUT ULONG *pciiref) pure;

	// primitives for managing source module contents
	virtual BOOL getModuleContents(IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getModuleByName(SZ sz, OUT IMOD *pimod) pure;
	virtual BOOL getAllModulesArray(OUT IMOD **ppimod, OUT ULONG *pcimod) pure;
	
	// call this when a computed array is no longer required
	virtual void disposeArray(void *pAnyArray) pure;

	// call this to get a pretty form of a decorated name	
	virtual SZ  formatDname(SZ szDecor) pure;
	
	// call this to do category testing on instances
	virtual BOOL fInstFilter(IINST iinst, MBF mbf) pure;

	// primitives for converting index types
	virtual IINST iinstFrIref(IREF) pure;
	virtual IINST iinstFrIdef(IDEF) pure;
	virtual IINST iinstContextIref(IREF) pure;

	// general size information
	virtual	BOOL getStatistics(struct BSC_STAT *) pure;
	virtual	BOOL getModuleStatistics(IMOD, struct BSC_STAT *) pure;

	// case sensitivity functions
	virtual BOOL fCaseSensitive() pure;
	virtual BOOL setCaseSensitivity(BOOL) pure;

	// handy common queries which can be optimized
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IinstInfo **ppiinstinfo, OUT ULONG *pciinst) pure;

	// needed for no compile browser
	// get parameters (iinst must be a function type)
	virtual SZ  getParams (IINST iinst) pure;
	virtual USHORT getNumParam (IINST iinst) pure;
	virtual SZ getParam (IINST iinst, USHORT index) pure;
	// get return type/variable type
	virtual SZ  getType (IINST iinst) pure;
	// register call back for notification
	// THIS SHOULD BE DELETED SOON!
	virtual BOOL regNotify (pfnNotifyChange pNotify) pure;
	// register to make sure that NCB will create change queue
	virtual BOOL regNotify () pure;
	virtual BOOL getQ (OUT NiQ ** ppQ, OUT ULONG * pcQ) pure;
	virtual BOOL checkParams (IINST iinst, SZ * pszParam, ULONG cParam) pure;
	virtual BOOL fHasMembers (IINST iinst, MBF mbf) pure;
	
	// needed for class view for optimization
	virtual SZ szFrNi (NI ni) pure;
	virtual BOOL niFrIinst (IINST iinst, NI *ni) pure;
	virtual BOOL lock() pure;
	virtual BOOL unlock() pure;
};

struct BSC_STAT
{
	ULONG	cDef;
	ULONG	cRef;
	ULONG	cInst;
	ULONG	cMod;
	ULONG	cUseLink;
	ULONG	cBaseLink;
};

// these are the bit values for Bsc::instInfo()

// this is the type part of the result, it describes what sort of object
// we are talking about.  Note the values are sequential -- the item will
// be exactly one of these things
//

#define INST_TYP_FUNCTION       0x01
#define INST_TYP_LABEL          0x02
#define INST_TYP_PARAMETER      0x03
#define INST_TYP_VARIABLE       0x04
#define INST_TYP_CONSTANT       0x05
#define INST_TYP_MACRO          0x06
#define INST_TYP_TYPEDEF        0x07
#define INST_TYP_STRUCNAM       0x08
#define INST_TYP_ENUMNAM        0x09
#define INST_TYP_ENUMMEM        0x0A
#define INST_TYP_UNIONNAM       0x0B
#define INST_TYP_SEGMENT        0x0C
#define INST_TYP_GROUP          0x0D
#define INST_TYP_PROGRAM        0x0E
#define INST_TYP_CLASSNAM       0x0F
#define INST_TYP_MEMFUNC        0x10
#define INST_TYP_MEMVAR         0x11
#define INST_TYP_INCL           0x12
#define INST_TYP_MSGMAP         0x13
#define INST_TYP_MSGITEM        0x14
#define INST_TYP_DIALOGID       0x15 // dialog ID for MFC
// idl stuff
#define INST_TYP_IDL_ATTR       0x16 // idl attributes are stored as iinst
#define INST_TYP_IDL_COCLASS    0x17
#define INST_TYP_IDL_IFACE      0x18
#define INST_TYP_IDL_DISPIFACE  0x19
#define INST_TYP_IDL_LIBRARY    0x1A
#define	INST_TYP_IDL_MODULE     0x1B
#define INST_TYP_IDL_IMPORT     0x1C
#define INST_TYP_IDL_IMPORTLIB  0x1D
#define INST_TYP_IDL_MFCCOMMENT 0x1E // idl interface/dispinterface can have mfc comment
// java stuff
#define INST_TYP_JAVA_IFACE     0x1F // java (NOT COM) interfaces
// 0x20 to 0x30 left for Java
// some more C++ stuff
#define INST_TYP_TEMPLATE       0x31
#define INST_TYP_NAMESPACE      0x32
#define INST_TYP_IMPORT         0x33
#define INST_TYP_BASECLASS      0x34

// these are the attributes values, they describes the storage
// class and/or scope of the instance.  Any combination of the bits
// might be set by some language compiler, but there are some combinations
// that don't make sense.

#define INST_ATR_LOCAL       0x001
#define INST_ATR_STATIC      0x002
#define INST_ATR_SHARED      0x004
#define INST_ATR_NEAR        0x008
#define INST_ATR_COMMON      0x010
#define INST_ATR_DECL_ONLY   0x020
#define INST_ATR_PUBLIC      0x040
#define INST_ATR_NAMED       0x080
#define INST_ATR_MODULE      0x100
#define INST_ATR_VIRTUAL     0x200
#define INST_ATR_PRIVATE     0x400
#define INST_ATR_PROTECT     0x800

#define IMODE_VIRTUAL        0x001
#define IMODE_PRIVATE        0x002
#define IMODE_PUBLIC         0x004
#define IMODE_PROTECT        0x008

#define mbfNil       0x000
#define mbfVars      0x001
#define mbfFuncs     0x002
#define mbfMacros    0x004
#define mbfTypes     0x008
#define mbfClass     0x010
#define mbfIncl      0x020
#define mbfMsgMap    0x040
#define mbfDialogID  0x080
#define mbfLibrary   0x100
#define mbfImport    0x200
#define mbfTemplate  0x400
#define mbfNamespace 0x800
#define mbfAll       0xFFF

// BOB = browser object, general index holder 

typedef ULONG BOB;

#define bobNil 0L

typedef USHORT CLS;

#define clsMod  1
#define clsInst 2
#define clsRef  3
#define clsDef  4

#define BobFrClsIdx(cls, idx)  ((((ULONG)(cls)) << 28) | (idx))
#define ClsOfBob(bob)	(CLS)((bob) >> 28)

#define ImodFrBob(bob)	((IMOD) ((bob) & 0xfffffffL))
#define IinstFrBob(bob)	((IINST)((bob) & 0xfffffffL))
#define IrefFrBob(bob)	((IREF) ((bob) & 0xfffffffL))
#define IdefFrBob(bob)	((IDEF) ((bob) & 0xfffffffL))

#define BobFrMod(x)  (BobFrClsIdx(clsMod,  (x)))
#define BobFrInst(x) (BobFrClsIdx(clsInst, (x)))
#define BobFrRef(x)  (BobFrClsIdx(clsRef,  (x)))
#define BobFrDef(x)  (BobFrClsIdx(clsDef,  (x)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\debugger\xosd.h ===
//
// xosdNone must be 0.  The rest do not matter
//

DECL_XOSD(xosdNone,                 0, "No Error")

DECL_XOSD(xosdContinue,             1, "Continue processing EMF")
DECL_XOSD(xosdPunt,                 2, "Pass to next EM")

DECL_XOSD(xosdGeneral,              3, "API failed")
#ifdef DEBUG
DECL_XOSD(xosdUnknown,              4, "xosdUnknown Should be xosdGeneral")
#else
DECL_XOSD(xosdUnknown,				4, "General Debugger error")
#endif
DECL_XOSD(xosdUnsupported,          5, "Feature not available")
DECL_XOSD(xosdInvalidHandle,        6, "Invalid handle passed to API")
DECL_XOSD(xosdInvalidParameter,     7, "Invalid parameter")
DECL_XOSD(xosdDuplicate,            8, "Duplicate EM or TL")
DECL_XOSD(xosdInUse,                9, "EM or TL is in use")
DECL_XOSD(xosdOutOfMemory,         10, "Insufficient memory available")
DECL_XOSD(xosdFileNotFound,        11, "File not found")
DECL_XOSD(xosdAccessDenied,        12, "Access denied")

DECL_XOSD(xosdBadProcess,          13, "Inappropriate or nonexistent process")
DECL_XOSD(xosdBadThread,           14, "Inappropriate or nonexistent thread")
DECL_XOSD(xosdBadAddress,          15, "Invalid address")
DECL_XOSD(xosdInvalidBreakPoint,   16, "nonexistent breakpoint")

DECL_XOSD(xosdBadVersion,          17, "Debugger component versions mismatched")

DECL_XOSD(xosdQueueEmpty,          18, "Queue Empty - no error")
DECL_XOSD(xosdProcRunning,         19, "Operation invalid when process is running")

DECL_XOSD(xosdRead,                20, "Read Failure")
DECL_XOSD(xosdWrite,               21, "Write Failure")

DECL_XOSD(xosdIORedirSyntax,       22, "Syntax error in IO redirection")
DECL_XOSD(xosdIORedirBadFile,      23, "Cannot redirect with this file")
DECL_XOSD(xosdAllThreadsSuspended, 24, "All threads are suspended")

#ifdef DEBUG
DECL_XOSD(xosdAttachDeadlock,      25, "Attach deadlock: This should be a dbcError")
#else
DECL_XOSD(xosdAttachDeadlock,      25, "Error attaching to process")
#endif

DECL_XOSD(xosdEndOfStack,          26, "end of stack")

#ifdef DEBUG
DECL_XOSD(xosdAsmTooFew,           40, "Assembler - Too Few")
DECL_XOSD(xosdAsmTooMany,          41, "Assembler - Too Many")
DECL_XOSD(xosdAsmSize,             42, "Assembler - Size")
DECL_XOSD(xosdAsmBadRange,         43, "Assembler - BadRange")
DECL_XOSD(xosdAsmOverFlow,         44, "Assembler - OverFlow")
DECL_XOSD(xosdAsmSyntax,           45, "Assembler - Syntax")
DECL_XOSD(xosdAsmBadOpcode,        46, "Assembler - Bad Opcode")
DECL_XOSD(xosdAsmExtraChars,       47, "Assembler - Extra Chars")
DECL_XOSD(xosdAsmOperand,          48, "Assembler - Operand")
DECL_XOSD(xosdAsmBadSeg,           49, "Assembler - Bad Seg")
DECL_XOSD(xosdAsmBadReg,           50, "Assembler - Bad Reg")
DECL_XOSD(xosdAsmDivide,           51, "Assembler - Divide")
DECL_XOSD(xosdAsmSymbol,           52, "Assembler - Symbol")
#else
DECL_XOSD(xosdAsmTooFew,           40, "Assembler")
DECL_XOSD(xosdAsmTooMany,          41, "Assembler")
DECL_XOSD(xosdAsmSize,             42, "Assembler")
DECL_XOSD(xosdAsmBadRange,         43, "Assembler")
DECL_XOSD(xosdAsmOverFlow,         44, "Assembler")
DECL_XOSD(xosdAsmSyntax,           45, "Assembler")
DECL_XOSD(xosdAsmBadOpcode,        46, "Assembler")
DECL_XOSD(xosdAsmExtraChars,       47, "Assembler")
DECL_XOSD(xosdAsmOperand,          48, "Assembler")
DECL_XOSD(xosdAsmBadSeg,           49, "Assembler")
DECL_XOSD(xosdAsmBadReg,           50, "Assembler")
DECL_XOSD(xosdAsmDivide,           51, "Assembler")
DECL_XOSD(xosdAsmSymbol,           52, "Assembler")
#endif

DECL_XOSD(xosdLineNotConnected,    70, "Not connected")
DECL_XOSD(xosdCannotConnect,       71, "cannot connect")
DECL_XOSD(xosdCantOpenComPort,     72, "can't open com port")
DECL_XOSD(xosdBadComParameters,    73, "bad com params")
DECL_XOSD(xosdBadPipeServer,       74, "bad pipe server")
DECL_XOSD(xosdBadPipeName,         75, "bad pipe name")
DECL_XOSD(xosdNotRemote,           76, "not remote")




DECL_XOSD(xosdCannotStep,          90, "cannot step")   //donc for mac dm
DECL_XOSD(xosdInvalidRegister,     91, "invalid register")      // donc for mac dm
DECL_XOSD(xosdOpenFailed,          92, "open failed") // donc for mac dm
DECL_XOSD(xosdBadFormat,           93, "bad format") // donc for mac dm
DECL_XOSD(xosdLoadChild,           94, "load child") // donc for mac dm
DECL_XOSD(xosdBPGeneral,           95, "BP General") // donc for mac dm
DECL_XOSD(xosdOutOfThreads,        96, "out of threads") // donc for mac dm


DECL_XOSD(xosdSyntax,             100, "Syntax")   // for mac em
DECL_XOSD(xosdTooManyObjects,     101, "too many objects")  // for mac em
DECL_XOSD(xosdNotFound,           102, "not found")  // for mac em
DECL_XOSD(xosdInvalidFunction,    103, "invalid function") // for mac em
DECL_XOSD(xosdInvalidTID,         104, "invalid TID") // for mac em
DECL_XOSD(xosdInvalidMTE,         105, "invalid MTE") // for mac em
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */


/***    The master copy of this file resides in the langapi project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 *      When this file is modified, the corresponding documentation file
 *      omfdeb.doc in the langapi project must be updated.
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned short  _2BYTEPAD;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#if CC_LAZYSYMS
#define CV_SIGNATURE_LAZY       3L  // used only in PDB: see obj file for actual symbols
#define CV_SIGNATURE_RESERVED   4L  // All signatures from 4 to 64K are reserved
#else
#define CV_SIGNATURE_RESERVED   3L  // All signatures from 3 to 64K are reserved
#endif

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7       // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))
#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))






// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types

typedef enum TYPE_ENUM_e {
    T_NOTYPE        = 0x0000,   // uncharacterized type (no type)
    T_ABS           = 0x0001,   // absolute symbol
    T_SEGMENT       = 0x0002,   // segment type
    T_VOID          = 0x0003,   // void
    T_PVOID         = 0x0103,   // near pointer to void
    T_PFVOID        = 0x0203,   // far pointer to void
    T_PHVOID        = 0x0303,   // huge pointer to void
    T_32PVOID       = 0x0403,   // 16:32 near pointer to void
    T_32PFVOID      = 0x0503,   // 16:32 far pointer to void
    T_64PVOID       = 0x0603,   // 64 bit pointer to void
    T_CURRENCY      = 0x0004,   // BASIC 8 byte currency value
    T_NBASICSTR     = 0x0005,   // Near BASIC string
    T_FBASICSTR     = 0x0006,   // Far BASIC string
    T_NOTTRANS      = 0x0007,   // type not translated by cvpack
    T_BIT           = 0x0060,   // bit
    T_PASCHAR       = 0x0061,   // Pascal CHAR



//      Character types


    T_CHAR          = 0x0010,   // 8 bit signed
    T_UCHAR         = 0x0020,   // 8 bit unsigned
    T_PCHAR         = 0x0110,   // near pointer to 8 bit signed
    T_PUCHAR        = 0x0120,   // near pointer to 8 bit unsigned
    T_PFCHAR        = 0x0210,   // far pointer to 8 bit signed
    T_PFUCHAR       = 0x0220,   // far pointer to 8 bit unsigned
    T_PHCHAR        = 0x0310,   // huge pointer to 8 bit signed
    T_PHUCHAR       = 0x0320,   // huge pointer to 8 bit unsigned
    T_32PCHAR       = 0x0410,   // 16:32 near pointer to 8 bit signed
    T_32PUCHAR      = 0x0420,   // 16:32 near pointer to 8 bit unsigned
    T_32PFCHAR      = 0x0510,   // 16:32 far pointer to 8 bit signed
    T_32PFUCHAR     = 0x0520,   // 16:32 far pointer to 8 bit unsigned
    T_64PCHAR       = 0x0610,   // 64 bit pointer to 8 bit signed
    T_64PUCHAR      = 0x0620,   // 64 bit pointer to 8 bit unsigned




//      really a character types

    T_RCHAR         = 0x0070,   // really a char
    T_PRCHAR        = 0x0170,   // 16:16 near pointer to a real char
    T_PFRCHAR       = 0x0270,   // 16:16 far pointer to a real char
    T_PHRCHAR       = 0x0370,   // 16:16 huge pointer to a real char
    T_32PRCHAR      = 0x0470,   // 16:32 near pointer to a real char
    T_32PFRCHAR     = 0x0570,   // 16:32 far pointer to a real char
    T_64PRCHAR      = 0x0670,   // 64 bit pointer to a real char



//      really a wide character types

    T_WCHAR         = 0x0071,   // wide char
    T_PWCHAR        = 0x0171,   // 16:16 near pointer to a wide char
    T_PFWCHAR       = 0x0271,   // 16:16 far pointer to a wide char
    T_PHWCHAR       = 0x0371,   // 16:16 huge pointer to a wide char
    T_32PWCHAR      = 0x0471,   // 16:32 near pointer to a wide char
    T_32PFWCHAR     = 0x0571,   // 16:32 far pointer to a wide char
    T_64PWCHAR      = 0x0671,   // 64 bit pointer to a wide char


//      8 bit int types


    T_INT1          = 0x0068,   // 8 bit signed int
    T_UINT1         = 0x0069,   // 8 bit unsigned int
    T_PINT1         = 0x0168,   // near pointer to 8 bit signed int
    T_PUINT1        = 0x0169,   // near pointer to 8 bit unsigned int
    T_PFINT1        = 0x0268,   // far pointer to 8 bit signed int
    T_PFUINT1       = 0x0269,   // far pointer to 8 bit unsigned int
    T_PHINT1        = 0x0368,   // huge pointer to 8 bit signed int
    T_PHUINT1       = 0x0369,   // huge pointer to 8 bit unsigned int

    T_32PINT1       = 0x0468,   // 16:32 near pointer to 8 bit signed int
    T_32PUINT1      = 0x0469,   // 16:32 near pointer to 8 bit unsigned int
    T_32PFINT1      = 0x0568,   // 16:32 far pointer to 8 bit signed int
    T_32PFUINT1     = 0x0569,   // 16:32 far pointer to 8 bit unsigned int
    T_64PINT1       = 0x0668,   // 64 bit pointer to 8 bit signed int
    T_64PUINT1      = 0x0669,   // 64 bit pointer to 8 bit unsigned int


//      16 bit short types


    T_SHORT         = 0x0011,   // 16 bit signed
    T_USHORT        = 0x0021,   // 16 bit unsigned
    T_PSHORT        = 0x0111,   // near pointer to 16 bit signed
    T_PUSHORT       = 0x0121,   // near pointer to 16 bit unsigned
    T_PFSHORT       = 0x0211,   // far pointer to 16 bit signed
    T_PFUSHORT      = 0x0221,   // far pointer to 16 bit unsigned
    T_PHSHORT       = 0x0311,   // huge pointer to 16 bit signed
    T_PHUSHORT      = 0x0321,   // huge pointer to 16 bit unsigned

    T_32PSHORT      = 0x0411,   // 16:32 near pointer to 16 bit signed
    T_32PUSHORT     = 0x0421,   // 16:32 near pointer to 16 bit unsigned
    T_32PFSHORT     = 0x0511,   // 16:32 far pointer to 16 bit signed
    T_32PFUSHORT    = 0x0521,   // 16:32 far pointer to 16 bit unsigned
    T_64PSHORT      = 0x0611,   // 64 bit pointer to 16 bit signed
    T_64PUSHORT     = 0x0621,   // 64 bit pointer to 16 bit unsigned




//      16 bit int types


    T_INT2          = 0x0072,   // 16 bit signed int
    T_UINT2         = 0x0073,   // 16 bit unsigned int
    T_PINT2         = 0x0172,   // near pointer to 16 bit signed int
    T_PUINT2        = 0x0173,   // near pointer to 16 bit unsigned int
    T_PFINT2        = 0x0272,   // far pointer to 16 bit signed int
    T_PFUINT2       = 0x0273,   // far pointer to 16 bit unsigned int
    T_PHINT2        = 0x0372,   // huge pointer to 16 bit signed int
    T_PHUINT2       = 0x0373,   // huge pointer to 16 bit unsigned int

    T_32PINT2       = 0x0472,   // 16:32 near pointer to 16 bit signed int
    T_32PUINT2      = 0x0473,   // 16:32 near pointer to 16 bit unsigned int
    T_32PFINT2      = 0x0572,   // 16:32 far pointer to 16 bit signed int
    T_32PFUINT2     = 0x0573,   // 16:32 far pointer to 16 bit unsigned int
    T_64PINT2       = 0x0672,   // 64 bit pointer to 16 bit signed int
    T_64PUINT2      = 0x0673,   // 64 bit pointer to 16 bit unsigned int




//      32 bit long types


    T_LONG          = 0x0012,   // 32 bit signed
    T_ULONG         = 0x0022,   // 32 bit unsigned
    T_PLONG         = 0x0112,   // near pointer to 32 bit signed
    T_PULONG        = 0x0122,   // near pointer to 32 bit unsigned
    T_PFLONG        = 0x0212,   // far pointer to 32 bit signed
    T_PFULONG       = 0x0222,   // far pointer to 32 bit unsigned
    T_PHLONG        = 0x0312,   // huge pointer to 32 bit signed
    T_PHULONG       = 0x0322,   // huge pointer to 32 bit unsigned

    T_32PLONG       = 0x0412,   // 16:32 near pointer to 32 bit signed
    T_32PULONG      = 0x0422,   // 16:32 near pointer to 32 bit unsigned
    T_32PFLONG      = 0x0512,   // 16:32 far pointer to 32 bit signed
    T_32PFULONG     = 0x0522,   // 16:32 far pointer to 32 bit unsigned
    T_64PLONG       = 0x0612,   // 64 bit pointer to 32 bit signed
    T_64PULONG      = 0x0622,   // 64 bit pointer to 32 bit unsigned




//      32 bit int types


    T_INT4          = 0x0074,   // 32 bit signed int
    T_UINT4         = 0x0075,   // 32 bit unsigned int
    T_PINT4         = 0x0174,   // near pointer to 32 bit signed int
    T_PUINT4        = 0x0175,   // near pointer to 32 bit unsigned int
    T_PFINT4        = 0x0274,   // far pointer to 32 bit signed int
    T_PFUINT4       = 0x0275,   // far pointer to 32 bit unsigned int
    T_PHINT4        = 0x0374,   // huge pointer to 32 bit signed int
    T_PHUINT4       = 0x0375,   // huge pointer to 32 bit unsigned int

    T_32PINT4       = 0x0474,   // 16:32 near pointer to 32 bit signed int
    T_32PUINT4      = 0x0475,   // 16:32 near pointer to 32 bit unsigned int
    T_32PFINT4      = 0x0574,   // 16:32 far pointer to 32 bit signed int
    T_32PFUINT4     = 0x0575,   // 16:32 far pointer to 32 bit unsigned int
    T_64PINT4       = 0x0674,   // 64 bit pointer to 32 bit signed int
    T_64PUINT4      = 0x0675,   // 64 bit pointer to 32 bit unsigned int




//      64 bit quad types


    T_QUAD          = 0x0013,   // 64 bit signed
    T_UQUAD         = 0x0023,   // 64 bit unsigned
    T_PQUAD         = 0x0113,   // near pointer to 64 bit signed
    T_PUQUAD        = 0x0123,   // near pointer to 64 bit unsigned
    T_PFQUAD        = 0x0213,   // far pointer to 64 bit signed
    T_PFUQUAD       = 0x0223,   // far pointer to 64 bit unsigned
    T_PHQUAD        = 0x0313,   // huge pointer to 64 bit signed
    T_PHUQUAD       = 0x0323,   // huge pointer to 64 bit unsigned
    T_32PQUAD       = 0x0413,   // 16:32 near pointer to 64 bit signed
    T_32PUQUAD      = 0x0423,   // 16:32 near pointer to 64 bit unsigned
    T_32PFQUAD      = 0x0513,   // 16:32 far pointer to 64 bit signed
    T_32PFUQUAD     = 0x0523,   // 16:32 far pointer to 64 bit unsigned
    T_64PQUAD       = 0x0613,   // 64 bit pointer to 64 bit signed
    T_64PUQUAD      = 0x0623,   // 64 bit pointer to 64 bit unsigned



//      64 bit int types


    T_INT8          = 0x0076,   // 64 bit signed int
    T_UINT8         = 0x0077,   // 64 bit unsigned int
    T_PINT8         = 0x0176,   // near pointer to 64 bit signed int
    T_PUINT8        = 0x0177,   // near pointer to 64 bit unsigned int
    T_PFINT8        = 0x0276,   // far pointer to 64 bit signed int
    T_PFUINT8       = 0x0277,   // far pointer to 64 bit unsigned int
    T_PHINT8        = 0x0376,   // huge pointer to 64 bit signed int
    T_PHUINT8       = 0x0377,   // huge pointer to 64 bit unsigned int

    T_32PINT8       = 0x0476,   // 16:32 near pointer to 64 bit signed int
    T_32PUINT8      = 0x0477,   // 16:32 near pointer to 64 bit unsigned int
    T_32PFINT8      = 0x0576,   // 16:32 far pointer to 64 bit signed int
    T_32PFUINT8     = 0x0577,   // 16:32 far pointer to 64 bit unsigned int
    T_64PINT8       = 0x0676,   // 64 bit pointer to 64 bit signed int
    T_64PUINT8      = 0x0677,   // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types


    T_OCT           = 0x0014,   // 128 bit signed
    T_UOCT          = 0x0024,   // 128 bit unsigned
    T_POCT          = 0x0114,   // near pointer to 128 bit signed
    T_PUOCT         = 0x0124,   // near pointer to 128 bit unsigned
    T_PFOCT         = 0x0214,   // far pointer to 128 bit signed
    T_PFUOCT        = 0x0224,   // far pointer to 128 bit unsigned
    T_PHOCT         = 0x0314,   // huge pointer to 128 bit signed
    T_PHUOCT        = 0x0324,   // huge pointer to 128 bit unsigned

    T_32POCT        = 0x0414,   // 16:32 near pointer to 128 bit signed
    T_32PUOCT       = 0x0424,   // 16:32 near pointer to 128 bit unsigned
    T_32PFOCT       = 0x0514,   // 16:32 far pointer to 128 bit signed
    T_32PFUOCT      = 0x0524,   // 16:32 far pointer to 128 bit unsigned
    T_64POCT        = 0x0614,   // 64 bit pointer to 128 bit signed
    T_64PUOCT       = 0x0624,   // 64 bit pointer to 128 bit unsigned

//      128 bit int types


    T_INT16         = 0x0078,   // 128 bit signed int
    T_UINT16        = 0x0079,   // 128 bit unsigned int
    T_PINT16        = 0x0178,   // near pointer to 128 bit signed int
    T_PUINT16       = 0x0179,   // near pointer to 128 bit unsigned int
    T_PFINT16       = 0x0278,   // far pointer to 128 bit signed int
    T_PFUINT16      = 0x0279,   // far pointer to 128 bit unsigned int
    T_PHINT16       = 0x0378,   // huge pointer to 128 bit signed int
    T_PHUINT16      = 0x0379,   // huge pointer to 128 bit unsigned int

    T_32PINT16      = 0x0478,   // 16:32 near pointer to 128 bit signed int
    T_32PUINT16     = 0x0479,   // 16:32 near pointer to 128 bit unsigned int
    T_32PFINT16     = 0x0578,   // 16:32 far pointer to 128 bit signed int
    T_32PFUINT16    = 0x0579,   // 16:32 far pointer to 128 bit unsigned int
    T_64PINT16      = 0x0678,   // 64 bit pointer to 128 bit signed int
    T_64PUINT16     = 0x0679,   // 64 bit pointer to 128 bit unsigned int





//      32 bit real types


    T_REAL32        = 0x0040,   // 32 bit real
    T_PREAL32       = 0x0140,   // near pointer to 32 bit real
    T_PFREAL32      = 0x0240,   // far pointer to 32 bit real
    T_PHREAL32      = 0x0340,   // huge pointer to 32 bit real
    T_32PREAL32     = 0x0440,   // 16:32 near pointer to 32 bit real
    T_32PFREAL32    = 0x0540,   // 16:32 far pointer to 32 bit real
    T_64PREAL32     = 0x0640,   // 64 bit pointer to 32 bit real



//      48 bit real types


    T_REAL48        = 0x0044,   // 48 bit real
    T_PREAL48       = 0x0144,   // near pointer to 48 bit real
    T_PFREAL48      = 0x0244,   // far pointer to 48 bit real
    T_PHREAL48      = 0x0344,   // huge pointer to 48 bit real
    T_32PREAL48     = 0x0444,   // 16:32 near pointer to 48 bit real
    T_32PFREAL48    = 0x0544,   // 16:32 far pointer to 48 bit real
    T_64PREAL48     = 0x0644,   // 64 bit pointer to 48 bit real




//      64 bit real types


    T_REAL64        = 0x0041,   // 64 bit real
    T_PREAL64       = 0x0141,   // near pointer to 64 bit real
    T_PFREAL64      = 0x0241,   // far pointer to 64 bit real
    T_PHREAL64      = 0x0341,   // huge pointer to 64 bit real
    T_32PREAL64     = 0x0441,   // 16:32 near pointer to 64 bit real
    T_32PFREAL64    = 0x0541,   // 16:32 far pointer to 64 bit real
    T_64PREAL64     = 0x0641,   // 64 bit pointer to 64 bit real




//      80 bit real types


    T_REAL80        = 0x0042,   // 80 bit real
    T_PREAL80       = 0x0142,   // near pointer to 80 bit real
    T_PFREAL80      = 0x0242,   // far pointer to 80 bit real
    T_PHREAL80      = 0x0342,   // huge pointer to 80 bit real
    T_32PREAL80     = 0x0442,   // 16:32 near pointer to 80 bit real
    T_32PFREAL80    = 0x0542,   // 16:32 far pointer to 80 bit real
    T_64PREAL80     = 0x0642,   // 64 bit pointer to 80 bit real




//      128 bit real types


    T_REAL128       = 0x0043,   // 128 bit real
    T_PREAL128      = 0x0143,   // near pointer to 128 bit real
    T_PFREAL128     = 0x0243,   // far pointer to 128 bit real
    T_PHREAL128     = 0x0343,   // huge pointer to 128 bit real
    T_32PREAL128    = 0x0443,   // 16:32 near pointer to 128 bit real
    T_32PFREAL128   = 0x0543,   // 16:32 far pointer to 128 bit real
    T_64PREAL128    = 0x0643,   // 64 bit pointer to 128 bit real




//      32 bit complex types


    T_CPLX32        = 0x0050,   // 32 bit complex
    T_PCPLX32       = 0x0150,   // near pointer to 32 bit complex
    T_PFCPLX32      = 0x0250,   // far pointer to 32 bit complex
    T_PHCPLX32      = 0x0350,   // huge pointer to 32 bit complex
    T_32PCPLX32     = 0x0450,   // 16:32 near pointer to 32 bit complex
    T_32PFCPLX32    = 0x0550,   // 16:32 far pointer to 32 bit complex
    T_64PCPLX32     = 0x0650,   // 64 bit pointer to 32 bit complex




//      64 bit complex types


    T_CPLX64        = 0x0051,   // 64 bit complex
    T_PCPLX64       = 0x0151,   // near pointer to 64 bit complex
    T_PFCPLX64      = 0x0251,   // far pointer to 64 bit complex
    T_PHCPLX64      = 0x0351,   // huge pointer to 64 bit complex
    T_32PCPLX64     = 0x0451,   // 16:32 near pointer to 64 bit complex
    T_32PFCPLX64    = 0x0551,   // 16:32 far pointer to 64 bit complex
    T_64PCPLX64     = 0x0651,   // 64 bit pointer to 64 bit complex




//      80 bit complex types


    T_CPLX80        = 0x0052,   // 80 bit complex
    T_PCPLX80       = 0x0152,   // near pointer to 80 bit complex
    T_PFCPLX80      = 0x0252,   // far pointer to 80 bit complex
    T_PHCPLX80      = 0x0352,   // huge pointer to 80 bit complex
    T_32PCPLX80     = 0x0452,   // 16:32 near pointer to 80 bit complex
    T_32PFCPLX80    = 0x0552,   // 16:32 far pointer to 80 bit complex
    T_64PCPLX80     = 0x0652,   // 64 bit pointer to 80 bit complex




//      128 bit complex types


    T_CPLX128       = 0x0053,   // 128 bit complex
    T_PCPLX128      = 0x0153,   // near pointer to 128 bit complex
    T_PFCPLX128     = 0x0253,   // far pointer to 128 bit complex
    T_PHCPLX128     = 0x0353,   // huge pointer to 128 bit real
    T_32PCPLX128    = 0x0453,   // 16:32 near pointer to 128 bit complex
    T_32PFCPLX128   = 0x0553,   // 16:32 far pointer to 128 bit complex
    T_64PCPLX128    = 0x0653,   // 64 bit pointer to 128 bit complex




//      boolean types


    T_BOOL08        = 0x0030,   // 8 bit boolean
    T_BOOL16        = 0x0031,   // 16 bit boolean
    T_BOOL32        = 0x0032,   // 32 bit boolean
    T_BOOL64        = 0x0033,   // 64 bit boolean
    T_PBOOL08       = 0x0130,   // near pointer to  8 bit boolean
    T_PBOOL16       = 0x0131,   // near pointer to 16 bit boolean
    T_PBOOL32       = 0x0132,   // near pointer to 32 bit boolean
    T_PBOOL64       = 0x0133,   // near pointer to 64 bit boolean
    T_PFBOOL08      = 0x0230,   // far pointer to  8 bit boolean
    T_PFBOOL16      = 0x0231,   // far pointer to 16 bit boolean
    T_PFBOOL32      = 0x0232,   // far pointer to 32 bit boolean
    T_PFBOOL64      = 0x0233,   // far pointer to 64 bit boolean
    T_PHBOOL08      = 0x0330,   // huge pointer to  8 bit boolean
    T_PHBOOL16      = 0x0331,   // huge pointer to 16 bit boolean
    T_PHBOOL32      = 0x0332,   // huge pointer to 32 bit boolean
    T_PHBOOL64      = 0x0333,   // huge pointer to 64 bit boolean

    T_32PBOOL08     = 0x0430,   // 16:32 near pointer to 8 bit boolean
    T_32PFBOOL08    = 0x0530,   // 16:32 far pointer to 8 bit boolean
    T_32PBOOL16     = 0x0431,   // 16:32 near pointer to 18 bit boolean
    T_32PFBOOL16    = 0x0531,   // 16:32 far pointer to 16 bit boolean
    T_32PBOOL32     = 0x0432,   // 16:32 near pointer to 32 bit boolean
    T_32PFBOOL32    = 0x0532,   // 16:32 far pointer to 32 bit boolean
    T_32PBOOL64     = 0x0433,   // 16:32 near pointer to 64 bit boolean
    T_32PFBOOL64    = 0x0533,   // 16:32 far pointer to 64 bit boolean

    T_64PBOOL08     = 0x0630,   // 64 bit pointer to 8 bit boolean
    T_64PBOOL16     = 0x0631,   // 64 bit pointer to 18 bit boolean
    T_64PBOOL32     = 0x0632,   // 64 bit pointer to 32 bit boolean
    T_64PBOOL64     = 0x0633,   // 64 bit pointer to 64 bit boolean


    T_NCVPTR        = 0x01f0,   // CV Internal type for created near pointers
    T_FCVPTR        = 0x02f0,   // CV Internal type for created far pointers
    T_HCVPTR        = 0x03f0,   // CV Internal type for created huge pointers
    T_32NCVPTR      = 0x04f0,   // CV Internal type for created near 32-bit pointers
    T_32FCVPTR      = 0x05f0,   // CV Internal type for created far 32-bit pointers
    T_64NCVPTR      = 0x06f0,   // CV Internal type for created near 64-bit pointers

} TYPE_ENUM_e;

/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */


typedef enum LEAF_ENUM_e {
    // leaf indices starting records but referenced from symbol records

    LF_MODIFIER_16t     = 0x0001,
    LF_POINTER_16t      = 0x0002,
    LF_ARRAY_16t        = 0x0003,
    LF_CLASS_16t        = 0x0004,
    LF_STRUCTURE_16t    = 0x0005,
    LF_UNION_16t        = 0x0006,
    LF_ENUM_16t         = 0x0007,
    LF_PROCEDURE_16t    = 0x0008,
    LF_MFUNCTION_16t    = 0x0009,
    LF_VTSHAPE          = 0x000a,
    LF_COBOL0_16t       = 0x000b,
    LF_COBOL1           = 0x000c,
    LF_BARRAY_16t       = 0x000d,
    LF_LABEL            = 0x000e,
    LF_NULL             = 0x000f,
    LF_NOTTRAN          = 0x0010,
    LF_DIMARRAY_16t     = 0x0011,
    LF_VFTPATH_16t      = 0x0012,
    LF_PRECOMP_16t      = 0x0013,       // not referenced from symbol
    LF_ENDPRECOMP       = 0x0014,       // not referenced from symbol
    LF_OEM_16t          = 0x0015,       // oem definable type string
    LF_TYPESERVER       = 0x0016,       // not referenced from symbol

    // leaf indices starting records but referenced only from type records

    LF_SKIP_16t         = 0x0200,
    LF_ARGLIST_16t      = 0x0201,
    LF_DEFARG_16t       = 0x0202,
    LF_LIST             = 0x0203,
    LF_FIELDLIST_16t    = 0x0204,
    LF_DERIVED_16t      = 0x0205,
    LF_BITFIELD_16t     = 0x0206,
    LF_METHODLIST_16t   = 0x0207,
    LF_DIMCONU_16t      = 0x0208,
    LF_DIMCONLU_16t     = 0x0209,
    LF_DIMVARU_16t      = 0x020a,
    LF_DIMVARLU_16t     = 0x020b,
    LF_REFSYM           = 0x020c,

    LF_BCLASS_16t       = 0x0400,
    LF_VBCLASS_16t      = 0x0401,
    LF_IVBCLASS_16t     = 0x0402,
    LF_ENUMERATE        = 0x0403,
    LF_FRIENDFCN_16t    = 0x0404,
    LF_INDEX_16t        = 0x0405,
    LF_MEMBER_16t       = 0x0406,
    LF_STMEMBER_16t     = 0x0407,
    LF_METHOD_16t       = 0x0408,
    LF_NESTTYPE_16t     = 0x0409,
    LF_VFUNCTAB_16t     = 0x040a,
    LF_FRIENDCLS_16t    = 0x040b,
    LF_ONEMETHOD_16t    = 0x040c,
    LF_VFUNCOFF_16t     = 0x040d,

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
    LF_TI16_MAX         = 0x1000,

    LF_MODIFIER         = 0x1001,
    LF_POINTER          = 0x1002,
    LF_ARRAY            = 0x1003,
    LF_CLASS            = 0x1004,
    LF_STRUCTURE        = 0x1005,
    LF_UNION            = 0x1006,
    LF_ENUM             = 0x1007,
    LF_PROCEDURE        = 0x1008,
    LF_MFUNCTION        = 0x1009,
    LF_COBOL0           = 0x100a,
    LF_BARRAY           = 0x100b,
    LF_DIMARRAY         = 0x100c,
    LF_VFTPATH          = 0x100d,
    LF_PRECOMP          = 0x100e,       // not referenced from symbol
    LF_OEM              = 0x100f,       // oem definable type string

    // leaf indices starting records but referenced only from type records

    LF_SKIP             = 0x1200,
    LF_ARGLIST          = 0x1201,
    LF_DEFARG           = 0x1202,
    LF_FIELDLIST        = 0x1203,
    LF_DERIVED          = 0x1204,
    LF_BITFIELD         = 0x1205,
    LF_METHODLIST       = 0x1206,
    LF_DIMCONU          = 0x1207,
    LF_DIMCONLU         = 0x1208,
    LF_DIMVARU          = 0x1209,
    LF_DIMVARLU         = 0x120a,

    LF_BCLASS           = 0x1400,
    LF_VBCLASS          = 0x1401,
    LF_IVBCLASS         = 0x1402,
    LF_FRIENDFCN        = 0x1403,
    LF_INDEX            = 0x1404,
    LF_MEMBER           = 0x1405,
    LF_STMEMBER         = 0x1406,
    LF_METHOD           = 0x1407,
    LF_NESTTYPE         = 0x1408,
    LF_VFUNCTAB         = 0x1409,
    LF_FRIENDCLS        = 0x140a,
    LF_ONEMETHOD        = 0x140b,
    LF_VFUNCOFF         = 0x140c,
    LF_NESTTYPEEX       = 0x140d,
    LF_MEMBERMODIFY     = 0x140e,




    LF_NUMERIC          = 0x8000,
    LF_CHAR             = 0x8000,
    LF_SHORT            = 0x8001,
    LF_USHORT           = 0x8002,
    LF_LONG             = 0x8003,
    LF_ULONG            = 0x8004,
    LF_REAL32           = 0x8005,
    LF_REAL64           = 0x8006,
    LF_REAL80           = 0x8007,
    LF_REAL128          = 0x8008,
    LF_QUADWORD         = 0x8009,
    LF_UQUADWORD        = 0x800a,
    LF_REAL48           = 0x800b,
    LF_COMPLEX32        = 0x800c,
    LF_COMPLEX64        = 0x800d,
    LF_COMPLEX80        = 0x800e,
    LF_COMPLEX128       = 0x800f,
    LF_VARSTRING        = 0x8010,

    LF_OCTWORD          = 0x8017,
    LF_UOCTWORD         = 0x8018,

    LF_PAD0             = 0xf0,
    LF_PAD1             = 0xf1,
    LF_PAD2             = 0xf2,
    LF_PAD3             = 0xf3,
    LF_PAD4             = 0xf4,
    LF_PAD5             = 0xf5,
    LF_PAD6             = 0xf6,
    LF_PAD7             = 0xf7,
    LF_PAD8             = 0xf8,
    LF_PAD9             = 0xf9,
    LF_PAD10            = 0xfa,
    LF_PAD11            = 0xfb,
    LF_PAD12            = 0xfc,
    LF_PAD13            = 0xfd,
    LF_PAD14            = 0xfe,
    LF_PAD15            = 0xff,

} LEAF_ENUM_e;

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_RESERVED    = 0x12  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**     Notes on alignment
 *      Alignment of the fields in most of the type records is done on the
 *      basis of the TYPTYPE record base.  That is why in most of the lf*
 *      records that the CV_typ_t (32-bit types) is located on what appears to
 *      be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *      records that are in a list (lfFieldList, lfMethodList), which are
 *      aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

    Record type         Change (f == field arrangement, p = padding added)
    ----------------------------------------------------------------------
    lfModifer           f
    lfPointer           fp
    lfClass             f
    lfStructure         f
    lfUnion             f
    lfEnum              f
    lfVFTPath           p
    lfPreComp           p
    lfOEM               p
    lfArgList           p
    lfDerived           p
    mlMethod            p   (method list member)
    lfBitField          f
    lfDimCon            f
    lfDimVar            p
    lfIndex             p   (field list member)
    lfBClass            f   (field list member)
    lfVBClass           f   (field list member)
    lfFriendCls         p   (field list member)
    lfFriendFcn         p   (field list member)
    lfMember            f   (field list member)
    lfSTMember          f   (field list member)
    lfVFuncTab          p   (field list member)
    lfVFuncOff          p   (field list member)
    lfNestType          p   (field list member)

    DATASYM32           f
    PROCSYM32           f
    VPATHSYM32          f
    REGREL32            f
    THREADSYM32         f
    PROCSYMMIPS         f


*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t            utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;




//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t    attr;           // method attribute
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record for procedure
    unsigned long   vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    CV_typ16_t      dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
                                    // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
                                    // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
    _2BYTEPAD       pad0;           // internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
    _2BYTEPAD       pad0;       // internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
    S_REGISTER_16t  =  0x0002, // Register variable
    S_CONSTANT_16t  =  0x0003, // constant symbol
    S_UDT_16t       =  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME       =  0x0009, // path to object file name
    S_ENDARG        =  0x000a, // end of argument/return list
    S_COBOLUDT_16t  =  0x000b, // special UDT for cobol that does not symbol pack
    S_MANYREG_16t   =  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry

    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address

    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation

    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start

    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
    S_ALIGN         =  0x0402, // Used for page alignment of symbols
    S_LPROCREF      =  0x0403, // Local Reference to a procedure

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
S_TI16_MAX          =  0x1000,
    S_REGISTER      =  0x1001, // Register variable
    S_CONSTANT      =  0x1002, // constant symbol
    S_UDT           =  0x1003, // User defined type
    S_COBOLUDT      =  0x1004, // special UDT for cobol that does not symbol pack
    S_MANYREG       =  0x1005, // multiple register variable
    S_BPREL32       =  0x1006, // BP-relative
    S_LDATA32       =  0x1007, // Module-local symbol
    S_GDATA32       =  0x1008, // Global data symbol
    S_PUB32         =  0x1009, // a public symbol (CV internal reserved)
    S_LPROC32       =  0x100a, // Local procedure start
    S_GPROC32       =  0x100b, // Global procedure start
    S_VFTABLE32     =  0x100c, // address of virtual function table
    S_REGREL32      =  0x100d, // register relative address
    S_LTHREAD32     =  0x100e, // local thread storage
    S_GTHREAD32     =  0x100f, // global thread storage

    S_LPROCMIPS     =  0x1010, // Local procedure start
    S_GPROCMIPS     =  0x1011, // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC     =  0x1012, // extra frame and proc information
    S_COMPILE2      =  0x1013, // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2      =  0x1014, // multiple register variable
    S_LPROCIA64     =  0x1015, // Local procedure start (IA64)
    S_GPROCIA64     =  0x1016, // Global procedure start (IA64)

    S_RECTYPE_MAX,             // one greater than last
    S_RECTYPE_LAST  = S_RECTYPE_MAX - 1,

} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMPRO   = 0x06,
    CV_CFL_MIPSR4000    = 0x10,
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
} CV_CPU_TYPE_e;


//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO     :1; // frame pointer present
            unsigned char CV_PFLAG_INT       :1; // interrupt return
            unsigned char CV_PFLAG_FAR       :1; // far return
            unsigned char CV_PFLAG_NEVER     :1; // function does not return
            unsigned char CV_PFLAG_NOTREACHED:1; // label isn't fallen into
            unsigned char unused             :3; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER_16t
    CV_typ16_t      typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;

typedef struct MANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG2
    CV_typ_t        typind;     // Type index
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM2;

typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT_16t
    CV_typ16_t      typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT_16t | S_COBOLUDT_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;


typedef struct COMPILESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE2
    struct {
        unsigned long   iLanguage   :  8;   // language index
        unsigned long   fEC         :  1;   // compiled for E/C
        unsigned long   pad         : 23;   // reserved, must be 0
    } flags;
    unsigned short  machine;    // target processor
    unsigned short  verFEMajor; // front end major version #
    unsigned short  verFEMinor; // front end minor version #
    unsigned short  verFEBuild; // front end build version #
    unsigned short  verMajor;   // back end major version #
    unsigned short  verMinor;   // back end minor version #
    unsigned short  verBuild;   // back end build version #
    unsigned char   verSt[1];   // Length-prefixed compiler version string, followed
                                //  by an optional block of zero terminated strings
                                //  terminated with a double zero.
} COMPILESYM;

typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    unsigned char   style;      // CV_GENERIC_STYLE_e return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table          = 0x00, // not executable
    CEXM_MDL_jumptable      = 0x01, // Compiler generated jump table
    CEXM_MDL_datapad        = 0x02, // Data padding for alignment
    CEXM_MDL_native         = 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol          = 0x21, // cobol
    CEXM_MDL_codepad        = 0x22, // Code padding for alignment
    CEXM_MDL_code           = 0x23, // code
    CEXM_MDL_sql            = 0x30, // sql
    CEXM_MDL_pcode          = 0x40, // pcode
    CEXM_MDL_pcode32Mac     = 0x41, // macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;


typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct PROCSYMIA64 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCIA64 or S_LPROCIA64
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned short  retReg;     // Register return value is in
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMIA64;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF, S_DATAREF, or S_LPROCREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ALIGN
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;

typedef struct FRAMEPROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_FRAMEPROC
    unsigned long   cbFrame;    // count of bytes of total frame of procedure
    unsigned long   cbPad;      // count of bytes of padding in the frame
    CV_uoff32_t     offPad;     // offset (relative to frame poniter) to where
                                //  padding starts
    unsigned long   cbSaveRegs; // count of bytes of callee save registers
    CV_uoff32_t     offExHdlr;  // offset of exception handler
    unsigned short  sectExHdlr; // section id of exception handler

    struct {
        unsigned long   fHasAlloca  :  1;   // function uses _alloca()
        unsigned long   fHasSetJmp  :  1;   // function uses setjmp()
        unsigned long   fHasLongJmp :  1;   // function uses longjmp()
        unsigned long   fHasInlAsm  :  1;   // function uses inline asm
        unsigned long   fHasEH      :  1;   // function has EH states
        unsigned long   fInlSpec    :  1;   // function was speced as inline
        unsigned long   fHasSEH     :  1;   // function has SEH
        unsigned long   pad         : 25;   // must be zero
    } flags;
} FRAMEPROCSYM;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below and yet must fit
    // in a byte

    CV_ALLREG_ERR   =   252,
    CV_ALLREG_TEB   =   253,
    CV_ALLREG_TIMER =   254,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

//
//	v-vadimp - do not change the order of the registers below
//    
	
    CV_REG_XMM0     =  154, // XMM registers
    CV_REG_XMM1     =  155,
    CV_REG_XMM2     =  156,
    CV_REG_XMM3     =  157,
    CV_REG_XMM4     =  158,
    CV_REG_XMM5     =  159,
    CV_REG_XMM6     =  160,
    CV_REG_XMM7     =  161,

    CV_REG_XMM00    =  162, // XMM sub-registers
    CV_REG_XMM01    =  163,
    CV_REG_XMM02    =  164,
    CV_REG_XMM03    =  165,
    
    CV_REG_XMM10    =  166,
    CV_REG_XMM11    =  167,
    CV_REG_XMM12    =  168,
    CV_REG_XMM13    =  169,
    
    CV_REG_XMM20    =  170, 
    CV_REG_XMM21    =  171,
    CV_REG_XMM22    =  172,
    CV_REG_XMM23    =  173,
    
    CV_REG_XMM30    =  174,
    CV_REG_XMM31    =  175,
    CV_REG_XMM32    =  176,
    CV_REG_XMM33    =  177,
    
    CV_REG_XMM40    =  178, 
    CV_REG_XMM41    =  179,
    CV_REG_XMM42    =  180,
    CV_REG_XMM43    =  181,
    
    CV_REG_XMM50    =  182,
    CV_REG_XMM51    =  183,
    CV_REG_XMM52    =  184,
    CV_REG_XMM53    =  185,
    
    CV_REG_XMM60    =  186, 
    CV_REG_XMM61    =  187,
    CV_REG_XMM62    =  188,
    CV_REG_XMM63    =  189,
    
    CV_REG_XMM70    =  190,
    CV_REG_XMM71    =  191,
    CV_REG_XMM72    =  192,
    CV_REG_XMM73    =  193,

    CV_REG_XMM0L    =  194, 
    CV_REG_XMM1L    =  195,
    CV_REG_XMM2L    =  196,
    CV_REG_XMM3L    =  197,
    CV_REG_XMM4L    =  198,
    CV_REG_XMM5L    =  199,
    CV_REG_XMM6L    =  200,
    CV_REG_XMM7L    =  201,
    
    CV_REG_XMM0H    =  202, 
    CV_REG_XMM1H    =  203,
    CV_REG_XMM2H    =  204,
    CV_REG_XMM3H    =  205,
    CV_REG_XMM4H    =  206,
    CV_REG_XMM5H    =  207,
    CV_REG_XMM6H    =  208,
    CV_REG_XMM7H    =  209,

    CV_REG_MXCSR	=  211, // XMM status register

    CV_REG_EMM0L    =  220, // XMM sub-registers (WNI integer)
    CV_REG_EMM1L    =  221,
    CV_REG_EMM2L    =  222,
    CV_REG_EMM3L    =  223,
    CV_REG_EMM4L    =  224,
    CV_REG_EMM5L    =  225,
    CV_REG_EMM6L    =  226,
    CV_REG_EMM7L    =  227,

    CV_REG_EMM0H    =  228, 
    CV_REG_EMM1H    =  229,
    CV_REG_EMM2H    =  230,
    CV_REG_EMM3H    =  231,
    CV_REG_EMM4H    =  232,
    CV_REG_EMM5H    =  233,
    CV_REG_EMM6H    =  234,
    CV_REG_EMM7H    =  235,

	// do not change the order of these regs, first one must be even too
	CV_REG_MM00     =  236,
	CV_REG_MM01     =  237,
	CV_REG_MM10     =  238,
	CV_REG_MM11     =  239,
	CV_REG_MM20     =  240,
	CV_REG_MM21     =  241,
	CV_REG_MM30     =  242,
	CV_REG_MM31     =  243,
	CV_REG_MM40     =  244,
	CV_REG_MM41     =  245,
	CV_REG_MM50     =  246,
	CV_REG_MM51     =  247,
	CV_REG_MM60     =  248,
	CV_REG_MM61     =  249,
	CV_REG_MM70     =  250,
	CV_REG_MM71     =  251,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_BrRp     =   512,
    CV_IA64_BrS0     =   513,
    CV_IA64_BrS1     =   514,
    CV_IA64_BrS2     =   515,
    CV_IA64_BrS3     =   516,
    CV_IA64_BrS4     =   517,
    CV_IA64_BrT0     =   518,
    CV_IA64_BrT1     =   519,

    // Predicate Registers

    CV_IA64_Preds     =   768,

    // Banked General Registers

    CV_IA64_IntH0    =   832,
    CV_IA64_IntH1    =   833,
    CV_IA64_IntH2    =   834,
    CV_IA64_IntH3    =   835,
    CV_IA64_IntH4    =   836,
    CV_IA64_IntH5    =   837,
    CV_IA64_IntH6    =   838,
    CV_IA64_IntH7    =   839,
    CV_IA64_IntH8    =   840,
    CV_IA64_IntH9    =   841,
    CV_IA64_IntH10    =   842,
    CV_IA64_IntH11    =   843,
    CV_IA64_IntH12    =   844,
    CV_IA64_IntH13    =   845,
    CV_IA64_IntH14    =   846,
    CV_IA64_IntH15    =   847,

    // Special Registers

    CV_IA64_Ip     =   1016,
    CV_IA64_Umask  =   1017,
    CV_IA64_Cfm    =   1018,
    CV_IA64_Psr    =   1019,

    // Banked General Registers

    CV_IA64_Nats     =   1020,
    CV_IA64_Nats2    =   1021,
    CV_IA64_Nats3    =   1022,

    // General-Purpose Registers

    // INTEGER REGISTER
    CV_IA64_IntZero  =   1024,
    CV_IA64_IntGp    =   1025,
    CV_IA64_IntT0    =   1026,
    CV_IA64_IntT1    =   1027,
    CV_IA64_IntS0    =   1028,
    CV_IA64_IntS1    =   1029,
    CV_IA64_IntS2    =   1030,
    CV_IA64_IntS3    =   1031,
    CV_IA64_IntV0    =   1032,
    CV_IA64_IntAp    =   1033,
    CV_IA64_IntT2    =   1034,
    CV_IA64_IntT3    =   1035,
    CV_IA64_IntSp    =   1036,
    CV_IA64_IntT4    =   1037,
    CV_IA64_IntT5    =   1038,
    CV_IA64_IntT6    =   1039,
    CV_IA64_IntT7    =   1040,
    CV_IA64_IntT8    =   1041,
    CV_IA64_IntT9    =   1042,
    CV_IA64_IntT10   =   1043,
    CV_IA64_IntT11   =   1044,
    CV_IA64_IntT12   =   1045,
    CV_IA64_IntT13   =   1046,
    CV_IA64_IntT14   =   1047,
    CV_IA64_IntT15   =   1048,
    CV_IA64_IntT16   =   1049,
    CV_IA64_IntT17   =   1050,
    CV_IA64_IntT18   =   1051,
    CV_IA64_IntT19   =   1052,
    CV_IA64_IntT20   =   1053,
    CV_IA64_IntT21   =   1054,
    CV_IA64_IntT22   =   1055,

    // Register Stack
    CV_IA64_IntR32   =   1056,
    CV_IA64_IntR33   =   1057,
    CV_IA64_IntR34   =   1058,
    CV_IA64_IntR35   =   1059,
    CV_IA64_IntR36   =   1060,
    CV_IA64_IntR37   =   1061,
    CV_IA64_IntR38   =   1062,
    CV_IA64_IntR39   =   1063,
    CV_IA64_IntR40   =   1064,
    CV_IA64_IntR41   =   1065,
    CV_IA64_IntR42   =   1066,
    CV_IA64_IntR43   =   1067,
    CV_IA64_IntR44   =   1068,
    CV_IA64_IntR45   =   1069,
    CV_IA64_IntR46   =   1070,
    CV_IA64_IntR47   =   1071,
    CV_IA64_IntR48   =   1072,
    CV_IA64_IntR49   =   1073,
    CV_IA64_IntR50   =   1074,
    CV_IA64_IntR51   =   1075,
    CV_IA64_IntR52   =   1076,
    CV_IA64_IntR53   =   1077,
    CV_IA64_IntR54   =   1078,
    CV_IA64_IntR55   =   1079,
    CV_IA64_IntR56   =   1080,
    CV_IA64_IntR57   =   1081,
    CV_IA64_IntR58   =   1082,
    CV_IA64_IntR59   =   1083,
    CV_IA64_IntR60   =   1084,
    CV_IA64_IntR61   =   1085,
    CV_IA64_IntR62   =   1086,
    CV_IA64_IntR63   =   1087,
    CV_IA64_IntR64   =   1088,
    CV_IA64_IntR65   =   1089,
    CV_IA64_IntR66   =   1090,
    CV_IA64_IntR67   =   1091,
    CV_IA64_IntR68   =   1092,
    CV_IA64_IntR69   =   1093,
    CV_IA64_IntR70   =   1094,
    CV_IA64_IntR71   =   1095,
    CV_IA64_IntR72   =   1096,
    CV_IA64_IntR73   =   1097,
    CV_IA64_IntR74   =   1098,
    CV_IA64_IntR75   =   1099,
    CV_IA64_IntR76   =   1100,
    CV_IA64_IntR77   =   1101,
    CV_IA64_IntR78   =   1102,
    CV_IA64_IntR79   =   1103,
    CV_IA64_IntR80   =   1104,
    CV_IA64_IntR81   =   1105,
    CV_IA64_IntR82   =   1106,
    CV_IA64_IntR83   =   1107,
    CV_IA64_IntR84   =   1108,
    CV_IA64_IntR85   =   1109,
    CV_IA64_IntR86   =   1110,
    CV_IA64_IntR87   =   1111,
    CV_IA64_IntR88   =   1112,
    CV_IA64_IntR89   =   1113,
    CV_IA64_IntR90   =   1114,
    CV_IA64_IntR91   =   1115,
    CV_IA64_IntR92   =   1116,
    CV_IA64_IntR93   =   1117,
    CV_IA64_IntR94   =   1118,
    CV_IA64_IntR95   =   1119,
    CV_IA64_IntR96   =   1120,
    CV_IA64_IntR97   =   1121,
    CV_IA64_IntR98   =   1122,
    CV_IA64_IntR99   =   1123,
    CV_IA64_IntR100   =   1124,
    CV_IA64_IntR101   =   1125,
    CV_IA64_IntR102   =   1126,
    CV_IA64_IntR103   =   1127,
    CV_IA64_IntR104   =   1128,
    CV_IA64_IntR105   =   1129,
    CV_IA64_IntR106   =   1130,
    CV_IA64_IntR107   =   1131,
    CV_IA64_IntR108   =   1132,
    CV_IA64_IntR109   =   1133,
    CV_IA64_IntR110   =   1134,
    CV_IA64_IntR111   =   1135,
    CV_IA64_IntR112   =   1136,
    CV_IA64_IntR113   =   1137,
    CV_IA64_IntR114   =   1138,
    CV_IA64_IntR115   =   1139,
    CV_IA64_IntR116   =   1140,
    CV_IA64_IntR117   =   1141,
    CV_IA64_IntR118   =   1142,
    CV_IA64_IntR119   =   1143,
    CV_IA64_IntR120   =   1144,
    CV_IA64_IntR121   =   1145,
    CV_IA64_IntR122   =   1146,
    CV_IA64_IntR123   =   1147,
    CV_IA64_IntR124   =   1148,
    CV_IA64_IntR125   =   1149,
    CV_IA64_IntR126   =   1150,
    CV_IA64_IntR127   =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltZero  =   2048,
    CV_IA64_FltOne   =   2049,
    CV_IA64_FltS0    =   2050,
    CV_IA64_FltS1    =   2051,
    CV_IA64_FltS2    =   2052,
    CV_IA64_FltS3    =   2053,
    CV_IA64_FltT0    =   2054,
    CV_IA64_FltT1    =   2055,
    CV_IA64_FltT2    =   2056,
    CV_IA64_FltT3    =   2057,
    CV_IA64_FltT4    =   2058,
    CV_IA64_FltT5    =   2059,
    CV_IA64_FltT6    =   2060,
    CV_IA64_FltT7    =   2061,
    CV_IA64_FltT8    =   2062,
    CV_IA64_FltT9    =   2063,
    CV_IA64_FltS4    =   2064,
    CV_IA64_FltS5    =   2065,
    CV_IA64_FltS6    =   2066,
    CV_IA64_FltS7    =   2067,
    CV_IA64_FltS8    =   2068,
    CV_IA64_FltS9    =   2069,
    CV_IA64_FltS10   =   2070,
    CV_IA64_FltS11   =   2071,
    CV_IA64_FltS12   =   2072,
    CV_IA64_FltS13   =   2073,
    CV_IA64_FltS14   =   2074,
    CV_IA64_FltS15   =   2075,
    CV_IA64_FltS16   =   2076,
    CV_IA64_FltS17   =   2077,
    CV_IA64_FltS18   =   2078,
    CV_IA64_FltS19   =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32   =   2080,
    CV_IA64_FltF33   =   2081,
    CV_IA64_FltF34   =   2082,
    CV_IA64_FltF35   =   2083,
    CV_IA64_FltF36   =   2084,
    CV_IA64_FltF37   =   2085,
    CV_IA64_FltF38   =   2086,
    CV_IA64_FltF39   =   2087,
    CV_IA64_FltF40   =   2088,
    CV_IA64_FltF41   =   2089,
    CV_IA64_FltF42   =   2090,
    CV_IA64_FltF43   =   2091,
    CV_IA64_FltF44   =   2092,
    CV_IA64_FltF45   =   2093,
    CV_IA64_FltF46   =   2094,
    CV_IA64_FltF47   =   2095,
    CV_IA64_FltF48   =   2096,
    CV_IA64_FltF49   =   2097,
    CV_IA64_FltF50   =   2098,
    CV_IA64_FltF51   =   2099,
    CV_IA64_FltF52   =   2100,
    CV_IA64_FltF53   =   2101,
    CV_IA64_FltF54   =   2102,
    CV_IA64_FltF55   =   2103,
    CV_IA64_FltF56   =   2104,
    CV_IA64_FltF57   =   2105,
    CV_IA64_FltF58   =   2106,
    CV_IA64_FltF59   =   2107,
    CV_IA64_FltF60   =   2108,
    CV_IA64_FltF61   =   2109,
    CV_IA64_FltF62   =   2110,
    CV_IA64_FltF63   =   2111,
    CV_IA64_FltF64   =   2112,
    CV_IA64_FltF65   =   2113,
    CV_IA64_FltF66   =   2114,
    CV_IA64_FltF67   =   2115,
    CV_IA64_FltF68   =   2116,
    CV_IA64_FltF69   =   2117,
    CV_IA64_FltF70   =   2118,
    CV_IA64_FltF71   =   2119,
    CV_IA64_FltF72   =   2120,
    CV_IA64_FltF73   =   2121,
    CV_IA64_FltF74   =   2122,
    CV_IA64_FltF75   =   2123,
    CV_IA64_FltF76   =   2124,
    CV_IA64_FltF77   =   2125,
    CV_IA64_FltF78   =   2126,
    CV_IA64_FltF79   =   2127,
    CV_IA64_FltF80   =   2128,
    CV_IA64_FltF81   =   2129,
    CV_IA64_FltF82   =   2130,
    CV_IA64_FltF83   =   2131,
    CV_IA64_FltF84   =   2132,
    CV_IA64_FltF85   =   2133,
    CV_IA64_FltF86   =   2134,
    CV_IA64_FltF87   =   2135,
    CV_IA64_FltF88   =   2136,
    CV_IA64_FltF89   =   2137,
    CV_IA64_FltF90   =   2138,
    CV_IA64_FltF91   =   2139,
    CV_IA64_FltF92   =   2140,
    CV_IA64_FltF93   =   2141,
    CV_IA64_FltF94   =   2142,
    CV_IA64_FltF95   =   2143,
    CV_IA64_FltF96   =   2144,
    CV_IA64_FltF97   =   2145,
    CV_IA64_FltF98   =   2146,
    CV_IA64_FltF99   =   2147,
    CV_IA64_FltF100   =   2148,
    CV_IA64_FltF101   =   2149,
    CV_IA64_FltF102   =   2150,
    CV_IA64_FltF103   =   2151,
    CV_IA64_FltF104   =   2152,
    CV_IA64_FltF105   =   2153,
    CV_IA64_FltF106   =   2154,
    CV_IA64_FltF107   =   2155,
    CV_IA64_FltF108   =   2156,
    CV_IA64_FltF109   =   2157,
    CV_IA64_FltF110   =   2158,
    CV_IA64_FltF111   =   2159,
    CV_IA64_FltF112   =   2160,
    CV_IA64_FltF113   =   2161,
    CV_IA64_FltF114   =   2162,
    CV_IA64_FltF115   =   2163,
    CV_IA64_FltF116   =   2164,
    CV_IA64_FltF117   =   2165,
    CV_IA64_FltF118   =   2166,
    CV_IA64_FltF119   =   2167,
    CV_IA64_FltF120   =   2168,
    CV_IA64_FltF121   =   2169,
    CV_IA64_FltF122   =   2170,
    CV_IA64_FltF123   =   2171,
    CV_IA64_FltF124   =   2172,
    CV_IA64_FltF125   =   2173,
    CV_IA64_FltF126   =   2174,
    CV_IA64_FltF127   =   2175,

    // Application Registers

    CV_IA64_ApKR0    =   3072,
    CV_IA64_ApKR1    =   3073,
    CV_IA64_ApKR2    =   3074,
    CV_IA64_ApKR3    =   3075,
    CV_IA64_ApKR4    =   3076,
    CV_IA64_ApKR5    =   3077,
    CV_IA64_ApKR6    =   3078,
    CV_IA64_ApKR7    =   3079,
    CV_IA64_AR8      =   3080,
    CV_IA64_AR9      =   3081,
    CV_IA64_AR10     =   3082,
    CV_IA64_AR11     =   3083,
    CV_IA64_AR12     =   3084,
    CV_IA64_AR13     =   3085,
    CV_IA64_AR14     =   3086,
    CV_IA64_AR15     =   3087,
    CV_IA64_RsRSC    =   3088,
    CV_IA64_RsBSP    =   3089,
    CV_IA64_RsBSPSTORE =   3090,
    CV_IA64_RsRNAT   =   3091,
    CV_IA64_AR20     =   3092,
    CV_IA64_AR21     =   3093,
    CV_IA64_AR22     =   3094,
    CV_IA64_AR23     =   3095,
    CV_IA64_AR24     =   3096,
    CV_IA64_AR25     =   3097,
    CV_IA64_AR26     =   3098,
    CV_IA64_AR27     =   3099,
    CV_IA64_AR28     =   3100,
    CV_IA64_AR29     =   3101,
    CV_IA64_AR30     =   3102,
    CV_IA64_AR31     =   3103,
    CV_IA64_ApCCV    =   3104,
    CV_IA64_AR33     =   3105,
    CV_IA64_AR34     =   3106,
    CV_IA64_AR35     =   3107,
    CV_IA64_ApUNAT   =   3108,
    CV_IA64_AR37     =   3109,
    CV_IA64_AR38     =   3110,
    CV_IA64_AR39     =   3111,
    CV_IA64_StFPSR   =   3112,
    CV_IA64_AR41     =   3113,
    CV_IA64_AR42     =   3114,
    CV_IA64_AR43     =   3115,
    CV_IA64_ApITC    =   3116,
    CV_IA64_AR45     =   3117,
    CV_IA64_AR46     =   3118,
    CV_IA64_AR47     =   3119,
    CV_IA64_AR48     =   3120,
    CV_IA64_AR49     =   3121,
    CV_IA64_AR50     =   3122,
    CV_IA64_AR51     =   3123,
    CV_IA64_AR52     =   3124,
    CV_IA64_AR53     =   3125,
    CV_IA64_AR54     =   3126,
    CV_IA64_AR55     =   3127,
    CV_IA64_AR56     =   3128,
    CV_IA64_AR57     =   3129,
    CV_IA64_AR58     =   3130,
    CV_IA64_AR59     =   3131,
    CV_IA64_AR60     =   3132,
    CV_IA64_AR61     =   3133,
    CV_IA64_AR62     =   3134,
    CV_IA64_AR63     =   3135,
    CV_IA64_RsPFS    =   3136,
    CV_IA64_ApLC     =   3137,
    CV_IA64_ApEC     =   3138,
    CV_IA64_AR67   =   3139,
    CV_IA64_AR68   =   3140,
    CV_IA64_AR69   =   3141,
    CV_IA64_AR70   =   3142,
    CV_IA64_AR71   =   3143,
    CV_IA64_AR72   =   3144,
    CV_IA64_AR73   =   3145,
    CV_IA64_AR74   =   3146,
    CV_IA64_AR75   =   3147,
    CV_IA64_AR76   =   3148,
    CV_IA64_AR77   =   3149,
    CV_IA64_AR78   =   3150,
    CV_IA64_AR79   =   3151,
    CV_IA64_AR80   =   3152,
    CV_IA64_AR81   =   3153,
    CV_IA64_AR82   =   3154,
    CV_IA64_AR83   =   3155,
    CV_IA64_AR84   =   3156,
    CV_IA64_AR85   =   3157,
    CV_IA64_AR86   =   3158,
    CV_IA64_AR87   =   3159,
    CV_IA64_AR88   =   3160,
    CV_IA64_AR89   =   3161,
    CV_IA64_AR90   =   3162,
    CV_IA64_AR91   =   3163,
    CV_IA64_AR92   =   3164,
    CV_IA64_AR93   =   3165,
    CV_IA64_AR94   =   3166,
    CV_IA64_AR95   =   3167,
    CV_IA64_AR96   =   3168,
    CV_IA64_AR97   =   3169,
    CV_IA64_AR98   =   3170,
    CV_IA64_AR99   =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // Control Registers

    CV_IA64_ApDCR    =   4096,
    CV_IA64_ApITM    =   4097,
    CV_IA64_ApIVA    =   4098,
    CV_IA64_CR3      =   4099,
    CV_IA64_CR4      =   4100,
    CV_IA64_CR5      =   4101,
    CV_IA64_CR6      =   4102,
    CV_IA64_CR7      =   4103,
    CV_IA64_ApPTA    =   4104,
    CV_IA64_CR9      =   4105,
    CV_IA64_CR10     =   4106,
    CV_IA64_CR11     =   4107,
    CV_IA64_CR12     =   4108,
    CV_IA64_CR13     =   4109,
    CV_IA64_CR14     =   4110,
    CV_IA64_CR15     =   4111,
    CV_IA64_StIPSR   =   4112,
    CV_IA64_StISR    =   4113,
    CV_IA64_StIDA    =   4114,
    CV_IA64_StIIP    =   4115,
    CV_IA64_StIDTR   =   4116,
    CV_IA64_StIITR   =   4117,
    CV_IA64_StIIPA   =   4118,
    CV_IA64_StIFS    =   4119,
    CV_IA64_StIIM    =   4120,
    CV_IA64_StIHA    =   4121,
    CV_IA64_CR26     =   4122,
    CV_IA64_CR27     =   4123,
    CV_IA64_CR28     =   4124,
    CV_IA64_CR29     =   4125,
    CV_IA64_CR30     =   4126,
    CV_IA64_CR31     =   4127,
    CV_IA64_CR32     =   4128,
    CV_IA64_CR33     =   4129,
    CV_IA64_CR34     =   4130,
    CV_IA64_CR35     =   4131,
    CV_IA64_CR36     =   4132,
    CV_IA64_CR37     =   4133,
    CV_IA64_CR38     =   4134,
    CV_IA64_CR39     =   4135,
    CV_IA64_CR40     =   4136,
    CV_IA64_CR41     =   4137,
    CV_IA64_CR42     =   4138,
    CV_IA64_CR43     =   4139,
    CV_IA64_CR44     =   4140,
    CV_IA64_CR45     =   4141,
    CV_IA64_CR46     =   4142,
    CV_IA64_CR47     =   4143,
    CV_IA64_CR48     =   4144,
    CV_IA64_CR49     =   4145,
    CV_IA64_CR50     =   4146,
    CV_IA64_CR51     =   4147,
    CV_IA64_CR52     =   4148,
    CV_IA64_CR53     =   4149,
    CV_IA64_CR54     =   4150,
    CV_IA64_CR55     =   4151,
    CV_IA64_CR56     =   4152,
    CV_IA64_CR57     =   4153,
    CV_IA64_CR58     =   4154,
    CV_IA64_CR59     =   4155,
    CV_IA64_CR60     =   4156,
    CV_IA64_CR61     =   4157,
    CV_IA64_CR62     =   4158,
    CV_IA64_CR63     =   4159,
    CV_IA64_CR64     =   4160,
    CV_IA64_CR65     =   4161,
    CV_IA64_SaLID    =   4162,
    CV_IA64_CR67     =   4163,
    CV_IA64_CR68     =   4164,
    CV_IA64_CR69     =   4165,
    CV_IA64_CR70     =   4166,
    CV_IA64_SaIVR    =   4167,
    CV_IA64_SaTPR    =   4168,
    CV_IA64_CR73     =   4169,
    CV_IA64_CR74     =   4170,
    CV_IA64_SaEOI    =   4171,
    CV_IA64_CR76     =   4172,
    CV_IA64_CR77     =   4173,
    CV_IA64_CR78     =   4174,
    CV_IA64_CR79     =   4175,
    CV_IA64_CR80     =   4176,
    CV_IA64_CR81     =   4177,
    CV_IA64_CR82     =   4178,
    CV_IA64_CR83     =   4179,
    CV_IA64_CR84     =   4180,
    CV_IA64_CR85     =   4181,
    CV_IA64_CR86     =   4182,
    CV_IA64_CR87     =   4183,
    CV_IA64_CR88     =   4184,
    CV_IA64_CR89     =   4185,
    CV_IA64_CR90     =   4186,
    CV_IA64_CR91     =   4187,
    CV_IA64_CR92     =   4188,
    CV_IA64_CR93     =   4189,
    CV_IA64_CR94     =   4190,
    CV_IA64_CR95     =   4191,
    CV_IA64_SaIRR0   =   4192,
    CV_IA64_CR97     =   4193,
    CV_IA64_SaIRR1   =   4194,
    CV_IA64_CR99     =   4195,
    CV_IA64_SaIRR2   =   4196,
    CV_IA64_CR101    =   4197,
    CV_IA64_SaIRR3   =   4198,
    CV_IA64_CR103    =   4199,
    CV_IA64_CR104    =   4200,
    CV_IA64_CR105    =   4201,
    CV_IA64_CR106    =   4202,
    CV_IA64_CR107    =   4203,
    CV_IA64_CR108    =   4204,
    CV_IA64_CR109    =   4205,
    CV_IA64_CR110    =   4206,
    CV_IA64_CR111    =   4207,
    CV_IA64_CR112    =   4208,
    CV_IA64_CR113    =   4209,
    CV_IA64_SaITV    =   4210,
    CV_IA64_CR115    =   4211,
    CV_IA64_SaPMV    =   4212,
    CV_IA64_SaLRR0   =   4213,
    CV_IA64_SaLRR1   =   4214,
    CV_IA64_SaCMCV   =   4215,
    CV_IA64_CR120    =   4216,
    CV_IA64_CR121    =   4217,
    CV_IA64_CR122    =   4218,
    CV_IA64_CR123    =   4219,
    CV_IA64_CR124    =   4220,
    CV_IA64_CR125    =   4221,
    CV_IA64_CR126    =   4222,
    CV_IA64_CR127    =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0     =   5120,
    CV_IA64_Pkr1     =   5121,
    CV_IA64_Pkr2     =   5122,
    CV_IA64_Pkr3     =   5123,
    CV_IA64_Pkr4     =   5124,
    CV_IA64_Pkr5     =   5125,
    CV_IA64_Pkr6     =   5126,
    CV_IA64_Pkr7     =   5127,
    CV_IA64_Pkr8     =   5128,
    CV_IA64_Pkr9     =   5129,
    CV_IA64_Pkr10    =   5130,
    CV_IA64_Pkr11    =   5131,
    CV_IA64_Pkr12    =   5132,
    CV_IA64_Pkr13    =   5133,
    CV_IA64_Pkr14    =   5134,
    CV_IA64_Pkr15    =   5135,

    // Region Registers

    CV_IA64_Rr0      =   6144,
    CV_IA64_Rr1      =   6145,
    CV_IA64_Rr2      =   6146,
    CV_IA64_Rr3      =   6147,
    CV_IA64_Rr4      =   6148,
    CV_IA64_Rr5      =   6149,
    CV_IA64_Rr6      =   6150,
    CV_IA64_Rr7      =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0     =   7168,
    CV_IA64_PFD1     =   7169,
    CV_IA64_PFD2     =   7170,
    CV_IA64_PFD3     =   7171,
    CV_IA64_PFD4     =   7172,
    CV_IA64_PFD5     =   7173,
    CV_IA64_PFD6     =   7174,
    CV_IA64_PFD7     =   7175,

    // Performance Monitor Config Registers

    CV_IA64_PFC0     =   7424,
    CV_IA64_PFC1     =   7425,
    CV_IA64_PFC2     =   7426,
    CV_IA64_PFC3     =   7427,
    CV_IA64_PFC4     =   7428,
    CV_IA64_PFC5     =   7429,
    CV_IA64_PFC6     =   7430,
    CV_IA64_PFC7     =   7431,

    // Instruction Translation Registers

    CV_IA64_TrI0     =   8192,
    CV_IA64_TrI1     =   8193,
    CV_IA64_TrI2     =   8194,
    CV_IA64_TrI3     =   8195,
    CV_IA64_TrI4     =   8196,
    CV_IA64_TrI5     =   8197,
    CV_IA64_TrI6     =   8198,
    CV_IA64_TrI7     =   8199,

    // Data Translation Registers

    CV_IA64_TrD0     =   8320,
    CV_IA64_TrD1     =   8321,
    CV_IA64_TrD2     =   8322,
    CV_IA64_TrD3     =   8323,
    CV_IA64_TrD4     =   8324,
    CV_IA64_TrD5     =   8325,
    CV_IA64_TrD6     =   8326,
    CV_IA64_TrD7     =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0     =   8448,
    CV_IA64_DbI1     =   8449,
    CV_IA64_DbI2     =   8450,
    CV_IA64_DbI3     =   8451,
    CV_IA64_DbI4     =   8452,
    CV_IA64_DbI5     =   8453,
    CV_IA64_DbI6     =   8454,
    CV_IA64_DbI7     =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0     =   8576,
    CV_IA64_DbD1     =   8577,
    CV_IA64_DbD2     =   8578,
    CV_IA64_DbD3     =   8579,
    CV_IA64_DbD4     =   8580,
    CV_IA64_DbD5     =   8581,
    CV_IA64_DbD6     =   8582,
    CV_IA64_DbD7     =   8583,

} CV_HREG_e;

#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\ppcimage.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ppcimage.h

Abstract:

    This is the include file that describes ppc-specific image info

Author:

    James Stulz (v-james)  July 1993

Revision History:

--*/

#ifndef _PPCIMAGE_
#define _PPCIMAGE_

#define IMAGE_FILE_MACHINE_MPPC_601         0x601   // PowerPC 601.
#define IMAGE_FILE_MPPC_DLL                 0x4000

//
// Power Macintosh relocation types
//

#define IMAGE_REL_MPPC_DESCREL              0x0000
#define IMAGE_REL_MPPC_LCALL                0x0001
#define IMAGE_REL_MPPC_DATAREL              0x0002
#define IMAGE_REL_MPPC_JMPADDR              0x0003
#define IMAGE_REL_MPPC_CREATEDESCRREL       0x0004
#define IMAGE_REL_MPPC_DATADESCRREL         0x0005
#define IMAGE_REL_MPPC_TOCREL               0x0006
#define IMAGE_REL_MPPC_SECTION              0x000A
#define IMAGE_REL_MPPC_SECREL               0x000B
#define IMAGE_REL_MPPC_ADDR24               0x000C // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_MPPC_ADDR14               0x000D // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_MPPC_REL24                0x000E // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_MPPC_REL14                0x000F // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_MPPC_CV                   0x0013
#define IMAGE_REL_MPPC_TOCINDIRCALL         0x0022
#define IMAGE_REL_MPPC_TOCCALLREL           0x0025
#define IMAGE_REL_MPPC_PCODECALL            0x0028
#define IMAGE_REL_MPPC_PCODECALLTONATIVE    0x0029
#define IMAGE_REL_MPPC_PCODENEPE            0x002A

#endif // _PPCIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\cvexefmt.h ===
/***    cvexefmt.h - format of CodeView information in exe
 *
 *      Structures, constants, etc. for reading CodeView information
 *      from the executable.
 *
 */


/***    The master copy of this file resides in the LANGAPI project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 */


#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif



//  The following structures and constants describe the format of the
//  CodeView Debug OMF for that will be accepted by CodeView 4.0 and
//  later.  These are executables with signatures of NB05, NB06 and NB08.
//  There is some confusion about the signatures NB03 and NB04 so none
//  of the utilites will accept executables with these signatures.  NB07 is
//  the signature for QCWIN 1.0 packed executables.

//  All of the structures described below must start on a long word boundary
//  to maintain natural alignment.  Pad space can be inserted during the
//  write operation and the addresses adjusted without affecting the contents
//  of the structures.

#ifndef _CV_INFO_INCLUDED
#include "cvinfo.h"
#endif

#ifndef FAR
#if _M_IX86 >= 300
#define FAR
#else
#define FAR far
#endif
#endif


//  Type of subsection entry.

#define sstModule           0x120
#define sstTypes            0x121
#define sstPublic           0x122
#define sstPublicSym        0x123   // publics as symbol (waiting for link)
#define sstSymbols          0x124
#define sstAlignSym         0x125
#define sstSrcLnSeg         0x126   // because link doesn't emit SrcModule
#define sstSrcModule        0x127
#define sstLibraries        0x128
#define sstGlobalSym        0x129
#define sstGlobalPub        0x12a
#define sstGlobalTypes      0x12b
#define sstMPC              0x12c
#define sstSegMap           0x12d
#define sstSegName          0x12e
#define sstPreComp          0x12f   // precompiled types
#define sstPreCompMap       0x130   // map precompiled types in global types
#define sstOffsetMap16      0x131
#define sstOffsetMap32      0x132
#define sstFileIndex        0x133   // Index of file names
#define sstStaticSym        0x134

typedef enum OMFHash {
    OMFHASH_NONE,           // no hashing
    OMFHASH_SUMUC16,        // upper case sum of chars in 16 bit table
    OMFHASH_SUMUC32,        // upper case sum of chars in 32 bit table
    OMFHASH_ADDR16,         // sorted by increasing address in 16 bit table
    OMFHASH_ADDR32          // sorted by increasing address in 32 bit table
} OMFHASH;

//  CodeView Debug OMF signature.  The signature at the end of the file is
//  a negative offset from the end of the file to another signature.  At
//  the negative offset (base address) is another signature whose filepos
//  field points to the first OMFDirHeader in a chain of directories.
//  The NB05 signature is used by the link utility to indicated a completely
//  unpacked file.  The NB06 signature is used by ilink to indicate that the
//  executable has had CodeView information from an incremental link appended
//  to the executable.  The NB08 signature is used by cvpack to indicate that
//  the CodeView Debug OMF has been packed.  CodeView will only process
//  executables with the NB08 signature.


typedef struct OMFSignature {
    char            Signature[4];   // "NBxx"
    long            filepos;        // offset in file
} OMFSignature;



//  directory information structure
//  This structure contains the information describing the directory.
//  It is pointed to by the signature at the base address or the directory
//  link field of a preceeding directory.  The directory entries immediately
//  follow this structure.


typedef struct OMFDirHeader {
    unsigned short  cbDirHeader;    // length of this structure
    unsigned short  cbDirEntry;     // number of bytes in each directory entry
    unsigned long   cDir;           // number of directorie entries
    long            lfoNextDir;     // offset from base of next directory
    unsigned long   flags;          // status flags
} OMFDirHeader;




//  directory structure
//  The data in this structure is used to reference the data for each
//  subsection of the CodeView Debug OMF information.  Tables that are
//  not associated with a specific module will have a module index of
//  oxffff.  These tables are the global types table, the global symbol
//  table, the global public table and the library table.


typedef struct OMFDirEntry {
    unsigned short  SubSection;     // subsection type (sst...)
    unsigned short  iMod;           // module index
    long            lfo;            // large file offset of subsection
    unsigned long   cb;             // number of bytes in subsection
} OMFDirEntry;



//  information decribing each segment in a module

typedef struct OMFSegDesc {
    unsigned short  Seg;            // segment index
    unsigned short  pad;            // pad to maintain alignment
    unsigned long   Off;            // offset of code in segment
    unsigned long   cbSeg;          // number of bytes in segment
} OMFSegDesc;




//  per module information
//  There is one of these subsection entries for each module
//  in the executable.  The entry is generated by link/ilink.
//  This table will probably require padding because of the
//  variable length module name.

typedef struct OMFModule {
    unsigned short  ovlNumber;      // overlay number
    unsigned short  iLib;           // library that the module was linked from
    unsigned short  cSeg;           // count of number of segments in module
    char            Style[2];       // debugging style "CV"
    OMFSegDesc      SegInfo[1];     // describes segments in module
    char            Name[];         // length prefixed module name padded to
                                    // long word boundary
} OMFModule;



//  Symbol hash table format
//  This structure immediately preceeds the global publics table
//  and global symbol tables.

typedef struct  OMFSymHash {
    unsigned short  symhash;        // symbol hash function index
    unsigned short  addrhash;       // address hash function index
    unsigned long   cbSymbol;       // length of symbol information
    unsigned long   cbHSym;         // length of symbol hash data
    unsigned long   cbHAddr;        // length of address hashdata
} OMFSymHash;



//  Global types subsection format
//  This structure immediately preceeds the global types table.
//  The offsets in the typeOffset array are relative to the address
//  of ctypes.  Each type entry following the typeOffset array must
//  begin on a long word boundary.

typedef struct OMFTypeFlags {
    unsigned long   sig     :8;
    unsigned long   unused  :24;
} OMFTypeFlags;


typedef struct OMFGlobalTypes {
    OMFTypeFlags    flags;
    unsigned long   cTypes;         // number of types
    unsigned long   typeOffset[];   // array of offsets to types
} OMFGlobalTypes;




//  Precompiled types mapping table
//  This table should be ignored by all consumers except the incremental
//  packer.


typedef struct OMFPreCompMap {
    CV_typ_t        FirstType;      // first precompiled type index
    CV_typ_t        cTypes;         // number of precompiled types
    unsigned long   signature;      // precompiled types signature
    CV_typ_t        map[];          // mapping of precompiled types
} OMFPreCompMap;



//  Source line to address mapping table.
//  This table is generated by the link/ilink utility from line number
//  information contained in the object file OMF data.  This table contains
//  only the code contribution for one segment from one source file.


typedef struct OMFSourceLine {
    unsigned short  Seg;            // linker segment index
    unsigned short  cLnOff;         // count of line/offset pairs
    unsigned long   offset[1];      // array of offsets in segment
    unsigned short  lineNbr[1];     // array of line lumber in source
} OMFSourceLine;

typedef OMFSourceLine * LPSL;


//  Source file description
//  This table is generated by the linker


typedef struct OMFSourceFile {
    unsigned short  cSeg;           // number of segments from source file
    unsigned short  reserved;       // reserved
    unsigned long   baseSrcLn[1];   // base of OMFSourceLine tables
                                    // this array is followed by array
                                    // of segment start/end pairs followed by
                                    // an array of linker indices
                                    // for each segment in the file
    unsigned short  cFName;         // length of source file name
    char            Name;           // name of file padded to long boundary
} OMFSourceFile;

typedef OMFSourceFile * LPSF;


//  Source line to address mapping header structure
//  This structure describes the number and location of the
//  OMFAddrLine tables for a module.  The offSrcLine entries are
//  relative to the beginning of this structure.


typedef struct OMFSourceModule {
    unsigned short  cFile;          // number of OMFSourceTables
    unsigned short  cSeg;           // number of segments in module
    unsigned long   baseSrcFile[1]; // base of OMFSourceFile table
                                    // this array is followed by array
                                    // of segment start/end pairs followed
                                    // by an array of linker indices
                                    // for each segment in the module
} OMFSourceModule;

typedef OMFSourceModule * LPSM;

//  sstLibraries

typedef struct OMFLibrary {
    unsigned char   cbLibs;     // count of library names
    char            Libs[1];    // array of length prefixed lib names (first entry zero length)
} OMFLibrary;


// sstFileIndex - An index of all of the files contributing to an
//  executable.

typedef struct OMFFileIndex {
    unsigned short  cmodules;       // Number of modules
    unsigned short  cfilerefs;      // Number of file references
    unsigned short  modulelist[1];  // Index to beginning of list of files
                                    // for module i. (0 for module w/o files)
    unsigned short  cfiles[1];      // Number of file names associated
                                    // with module i.
    unsigned long   ulNames[1];     // Offsets from the beginning of this
                                    // table to the file names
    char            Names[];        // The length prefixed names of files
} OMFFileIndex;


//  Offset mapping table
//  This table provides a mapping from logical to physical offsets.
//  This mapping is applied between the logical to physical mapping
//  described by the seg map table.

typedef struct OMFOffsetMap16 {
    unsigned long   csegment;       // Count of physical segments

    // The next six items are repeated for each segment

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned short  rgoffLog[1];    // Array of logical offsets
    short           rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned short  rgoffPhys[1];   // Array of physical offsets
    short           rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap16;

typedef struct OMFOffsetMap32 {
    unsigned long   csection;       // Count of physical sections

    // The next six items are repeated for each section

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned long   rgoffLog[1];    // Array of logical offsets
    long            rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned long   rgoffPhys[1];   // Array of physical offsets
    long            rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap32;

//  Pcode support.  This subsection contains debug information generated
//  by the MPC utility used to process Pcode executables.  Currently
//  it contains a mapping table from segment index (zero based) to
//  frame paragraph.  MPC converts segmented exe's to non-segmented
//  exe's for DOS support.  To avoid backpatching all CV info, this
//  table is provided for the mapping.  Additional info may be provided
//  in the future for profiler support.

typedef struct OMFMpcDebugInfo {
    unsigned short  cSeg;       // number of segments in module
    unsigned short  mpSegFrame[1];  // map seg (zero based) to frame
} OMFMpcDebugInfo;

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for linkers that emit executables with the NB02
//  signature.  Current utilities with the exception of cvpack and cvdump
//  will not accept or emit executables with the NB02 signature.  Cvdump
//  will dump an unpacked executable with the NB02 signature.  Cvpack will
//  read an executable with the NB02 signature but the packed executable
//  will be written with the table format, contents and signature of NB08.





//  subsection type constants

#define SSTMODULE       0x101   // Basic info. about object module
#define SSTPUBLIC       0x102   // Public symbols
#define SSTTYPES        0x103   // Type information
#define SSTSYMBOLS      0x104   // Symbol Data
#define SSTSRCLINES     0x105   // Source line information
#define SSTLIBRARIES    0x106   // Names of all library files used
#define SSTIMPORTS      0x107   // Symbols for DLL fixups
#define SSTCOMPACTED    0x108   // Compacted types section
#define SSTSRCLNSEG     0x109   // Same as source lines, contains segment


typedef struct DirEntry{
    unsigned short  SubSectionType;
    unsigned short  ModuleIndex;
    long            lfoStart;
    unsigned short  Size;
} DirEntry;


//  information decribing each segment in a module

typedef struct oldnsg {
    unsigned short  Seg;            // segment index
    unsigned short  Off;            // offset of code in segment
    unsigned short  cbSeg;          // number of bytes in segment
} oldnsg;


//   old subsection module information

typedef struct oldsmd {
    oldnsg          SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg          arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd;

typedef struct{
    unsigned short  Seg;
    unsigned long   Off;
    unsigned long   cbSeg;
} oldnsg32;

typedef struct {
    oldnsg32        SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg32        arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd32;


// OMFSegMap - This table contains the mapping between the logical segment indices
// used in the symbol table and the physical segments where the program is loaded

typedef struct OMFSegMapFlags {
    union {
        struct {
            unsigned short      fRead   :1;
            unsigned short      fWrite  :1;
            unsigned short      fExecute:1;
            unsigned short      f32Bit  :1;
            unsigned short      res1    :4;
            unsigned short      fSel    :1;
            unsigned short      fAbs    :1;
            unsigned short      res2    :2;
            unsigned short      fGroup  :1;  // OBSOLETE - do not use, debugger will assert
            unsigned short      res3    :3;
        };
        unsigned short fAll;
    };
} OMFSegMapFlags;

typedef struct OMFSegMapDesc {
    OMFSegMapFlags  flags;          // descriptor flags bit field.
    unsigned short  ovl;            // the logical overlay number
    unsigned short  group;          // group index into the descriptor array
    unsigned short  frame;          // logical segment index - interpreted via flags
    unsigned short  iSegName;       // segment or group name - index into sstSegName
    unsigned short  iClassName;     // class name - index into sstSegName
    unsigned long   offset;         // byte offset of the logical within the physical segment
    unsigned long   cbSeg;          // byte count of the logical segment or group
} OMFSegMapDesc;

typedef struct OMFSegMap {
    unsigned short  cSeg;           // total number of segment descriptors
    unsigned short  cSegLog;        // number of logical segment descriptors
    OMFSegMapDesc   rgDesc[0];      // array of segment descriptors
} OMFSegMap;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\fbrdbg.h ===
/* fbrdbg.h 
 * 
 * Definitions used for the FIBER DEBUG system service
 *
 * Steven Steiner 
 * 9/26/96
 */

typedef enum _OFBR {
	OFBR_QUERY_LIST_SIZE =0,
	OFBR_GET_LIST,
	OFBR_SET_FBRCNTX,
	OFBR_DISABLE_FBRS,
	OFBR_ENABLE_FBRS
} OFBR;

typedef struct _OFBRS {
	OFBR	op;
	LPVOID	FbrCntx;
} OFBRS;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\cvr.h ===
// CVR: CodeView Record utilities

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __CVR_INCLUDED__
#define __CVR_INCLUDED__

#ifndef __PDB_INCLUDED__
#include <pdb.h>
#endif
#ifndef _CV_INFO_INCLUDED
#include <cvinfo.h>
#endif
#ifndef _INC_STDDEF
#include <stddef.h>
#endif
#ifndef _WINDOWS_
// get rid of baggage we don't need from windows.h
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif
//#define NOGDI
#define NOUSER
#define NONLS
#include "windows.h"
#endif

typedef BYTE* PB;
typedef long CB;
typedef char* SZ;		// zero terminated string
typedef char* ST;		// length prefixed string
typedef SYMTYPE* PSYM;
typedef SYMTYPE UNALIGNED * PSYMUNALIGNED;
typedef TYPTYPE* PTYPE;

//////////////////////////////////////////////////////////////////////////////
// TII (type index iterator) implementation declarations

typedef ptrdiff_t IB;
typedef TI*		(*PfnTyti)(PTYPE, int, PB*, PB);
typedef TI16*	(*PfnTyti16)(PTYPE, int, PB*, PB);

struct TYTI { // position of type indices within a type record with the given leaf
	unsigned leaf;
	SZ sz;						// leaf type name
	int cib;
	const IB* rgibTI;
	union {						// fn to call if cib == cibFunction
		PfnTyti 	pfn;
		PfnTyti16	pfn16;
	};
	PB  (*pfnPbAfter)(void* pv);	  // end of record fn to call for elements of a field list
};

// all pointers to a TYTI are pointing to const TYTIs
typedef const TYTI *	PTYTI;

struct SYTI { // position of symbol indices within a symbol recoord with the given rectyp
	unsigned rectyp;
	SZ sz;						// symbol rectyp name
	IB	ibName;					// position of symbol name
	ST (*pfnstName)(PSYM psym);	// function to call if name offset variable
	BOOL isGlobal;				// symbol is global
	int cib;
	const IB* rgibTI;
};

// all pointers to a SYTI are pointing to const SYTIs
typedef const SYTI *	PSYTI;

#if	defined(PDB_LIBRARY)
#define CVR_EXPORT
#else
#if defined(CVR_IMP)
#define CVR_EXPORT	__declspec(dllexport)
#else
#define CVR_EXPORT	__declspec(dllimport)
#endif
#endif

#ifndef CVRAPI
#define CVRAPI	 __cdecl
#endif

// functions that are in widenti.cpp
unsigned __fastcall
MapLeaf16To32 ( unsigned leaf16 );

unsigned __fastcall 
MapSymRec16To32 ( unsigned rectyp16 );

// utility functions for determining if type/symbol records may/must be
// converted from 16 to 32 bits.
inline bool fIs16bitTypRec(unsigned leaf)
{
	return leaf < LF_TI16_MAX;
}

inline bool fIs16bitSymRec(unsigned rectyp)
{
	return rectyp < S_TI16_MAX;
}

inline bool fIs16bitRec(PTYPE ptype)
{
	return fIs16bitTypRec ( ptype->leaf );
}

inline bool fIs16bitRec(PSYM psym)
{
	return psym->rectyp < S_TI16_MAX;
}

inline bool fNeeds16bitConversion(PSYM psym)
{
	unsigned rectyp = psym->rectyp;
    return
		rectyp < S_TI16_MAX &&
		MapSymRec16To32(rectyp) != rectyp;
}

inline bool fNeeds16bitConversion(PTYPE ptype)
{
    unsigned leaf = ptype->leaf;
    if (leaf < LF_TI16_MAX) {
		if (leaf == LF_REFSYM) {
			return fNeeds16bitConversion(PSYM(((lfRefSym*)(&ptype->leaf))->Sym));
		}
        return MapLeaf16To32(leaf) != leaf;
    }
    return false;
}

class SymTiIter { // type indices within symbol record iterator
public:
	CVR_EXPORT	SymTiIter(PSYM psym_);
	inline TI&  rti();
	inline BOOL next();

	inline TI16& rti16();
	inline BOOL f16Ti();
	inline unsigned cti();
	inline PB pbEndRecordSansPad();

private:
	PSYM psym;			// current symbol
	int  iib;			// index of current TI in this symbol record
	PSYTI psyti;		// address of symbol->ti-info for current symbol record
};

inline TI& SymTiIter::rti()
{
	return *(TI*)((PB)psym + psyti->rgibTI[iib]);
}

inline TI16& SymTiIter::rti16()
{
	return *(TI16*)((PB)psym + psyti->rgibTI[iib]);
}

inline BOOL	SymTiIter::f16Ti()
{
	return psyti->rectyp < S_TI16_MAX;
}

inline unsigned SymTiIter::cti()
{
	return psyti->cib;
}


inline BOOL SymTiIter::next()
{
	return ++iib < psyti->cib;
}

inline PB SymTiIter::pbEndRecordSansPad()
{
	if (psyti->ibName) {
		PB	pbT = PB(psym) + psyti->ibName;
		return pbT + *pbT + 1;
	}
	else if (psyti->pfnstName) {
		PB	pbT = PB((psyti->pfnstName)(psym));
		return pbT + *pbT + 1;
	}
	else
		return 0;
}

class TypeTiIter { // type indices within type record iterator
public:
	CVR_EXPORT	TypeTiIter(TYPTYPE* ptype);

	inline TI&
	rti();
	
	CVR_EXPORT	BOOL
	next();
	
	PB
	pbFindField(unsigned leaf);

	inline TI16&
	rti16();
	
	inline BOOL
	f16Ti();

	inline PB
	pbCurField();

	inline void
	leafChanged();
	
	BOOL
	nextField();

	CB
	cbPadForCurField();

	PB
	pbEndCurFieldSansPad();

	PB
	pbEndRecordSansPad();

private:
	void
	init();

	PTYPE ptype;		// current type
	USHORT* pleaf;		// leaf part of current type
	unsigned	leaf;	// cached, aligned, no op-size override version of leaf
	PB   pbFnState;		// private state of current iterating fn (iff ptyti->cib == cibFunction)
	PB   pbEnd;			// pointer just past end of type record
	int  iib;  			// index of current TI in this type record
	BOOL isFieldList;	// TRUE if this type record is a LF_FIELDLIST
	TI*  pti;			// address of current TI
	PTYTI ptyti;		// address of type->ti-info for current type record
};

inline TI& TypeTiIter::rti()
{
	return *pti;
}

inline TI16& TypeTiIter::rti16()
{
	return *PTi16(pti);
}

inline BOOL TypeTiIter::f16Ti()
{
	return ptyti->leaf < LF_TI16_MAX;
}

inline PB TypeTiIter::pbCurField()
{
    if (isFieldList && PB(pleaf) < pbEnd)
        return PB(pleaf);
    return 0;
}

// when we widen types, we need to reset the data since we change the
// leaf value of field lists out from under the iterator
inline void TypeTiIter::leafChanged()
{
	leaf = *pleaf;
	init();
}


// utility function protos
CVR_EXPORT BOOL CVRAPI fGetSymName(PSYM psym, OUT ST* pst);
		   BOOL fSymIsGlobal(PSYM psym);
           bool fSymIsData(PSYM);
		   BOOL fGetTypeLeafName(PTYPE ptype, OUT SZ* psz);
CVR_EXPORT BOOL CVRAPI fGetSymRecTypName(PSYM psym, OUT SZ* psz);

////////////////////////////////////////////////////////////////////////////////
// Inline utility functions.

// Return the number of bytes in an ST
inline CB cbForSt(ST st)
{
	return *(PB)st + 1;
}

// Return the number of bytes the type record occupies.
//
inline CB cbForType(PTYPE ptype)
{
	return ptype->len + sizeof(ptype->len);
}

// Return a pointer to the byte just past the end of the type record.
//
inline PB pbEndType(PTYPE ptype)
{
	return (PB)ptype + cbForType(ptype);
}

// Return the number of bytes the symbol record occupies.
//
#define MDALIGNTYPE_	DWORD

inline CB cbAlign_(CB cb)
{
	return ((cb + sizeof(MDALIGNTYPE_) - 1)) & ~(sizeof(MDALIGNTYPE_) - 1);
}

inline bool fIsRefSym(PSYM psym)
{
    unsigned    rectyp = psym->rectyp;
    return rectyp == S_PROCREF || rectyp == S_DATAREF || rectyp == S_LPROCREF;
}

inline CB cbForSym(PSYMUNALIGNED psym)
{
	CB cb = psym->reclen + sizeof(psym->reclen);
	// procrefs also have a hidden length preceeded name following the record
	if (fIsRefSym(psym))
		cb += cbAlign_(cbForSt((ST)((PB)psym + cb)));
	return cb;
}

// Return a pointer to the byte just past the end of the symbol record.
//
inline PB pbEndSym(PSYM psym)
{
	return (PB)psym + cbForSym(psym);
}

inline BOOL fIntroducingVirtual ( CV_methodprop_e mprop )
{
    return mprop == CV_MTintro || mprop == CV_MTpureintro;
}

inline BOOL fVirtual ( CV_methodprop_e mprop )
{
    return
        fIntroducingVirtual ( mprop ) ||
        mprop == CV_MTvirtual ||
        mprop == CV_MTpurevirt
        ;
}


#endif // __CVR_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\macimage.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    macimage.h

IMAGE_SYM_CLASS_FAR_EXTERNAL

Abstract:

    This is the include file that describes all mac-specific image info

Author:

    Bill Joyce (billjoy)  Oct 1992

Revision History:

--*/

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef _MACIMAGE_
#define _MACIMAGE_

#if defined _MSC_VER && _MSC_VER >= 800
#pragma pack(push, 2)
#else
#pragma pack(2)
#endif

#define IMAGE_FILE_MACHINE_M68K 0x268

// Macintosh relocation types
#define IMAGE_REL_M68K_DTOD16        0   // 16-bit data-to-data reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOC16        1   // 16-bit data-to-code reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOD32        2   // 32-bit data-to-data reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOC32        3   // 32-bit data-to-code reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOABSD32     4   // 32-bit data-to-code reference (patch with offset of A5 and add to DFIX)
#define IMAGE_REL_M68K_DTOABSC32     5   // 32-bit data-to-code reference (patch with offset of A5 and add to DFIX)
#define IMAGE_REL_M68K_CTOD16        6   // 16-bit code-to-data reference
#define IMAGE_REL_M68K_CTOC16        7   // 16-bit code-to-code reference
#define IMAGE_REL_M68K_CTOT16        8   // 16-bit code-to-thunk reference
#define IMAGE_REL_M68K_CTOD32        9   // 32-bit code-to-data reference
#define IMAGE_REL_M68K_CTOABSD32     10  // 32-bit code-to-absolute data reference
#define IMAGE_REL_M68K_CTOABSC32     11  // 32-bit code-to-absolute code reference
#define IMAGE_REL_M68K_CTOABST32     12  // 32-bit code-to-absolute thunk reference

#define IMAGE_REL_M68K_MACPROF32     19  // Profiler-specific relocation
#define IMAGE_REL_M68K_PCODETOC32    20  // 32-bit PCode-to-code reference
#define IMAGE_REL_M68K_CTOCS16       21  // 16-bit code space data-to-code reference
#define IMAGE_REL_M68K_CTOABSCS32    22  // 32-bit code space data-to-absolute code reference
#define IMAGE_REL_M68K_CV            23  // Direct 32-bit reference to the symbols virtual address, base not included

#define IMAGE_REL_M68K_DTOU16        25  // 16-bit data-to-unknown
#define IMAGE_REL_M68K_DTOU32        26  // 32-bit data-to-unknown
#define IMAGE_REL_M68K_DTOABSU32     27  // 32-bit data-to-unknown absolute
#define IMAGE_REL_M68K_CTOU16        28  // 16-bit code-to-unknown
#define IMAGE_REL_M68K_CTOABSU32     29  // 32-bit code-to-unknown absolute
#define IMAGE_REL_M68K_DIFF8         30  // Computed 8-bit difference between two symbols
#define IMAGE_REL_M68K_DIFF16        31  // Computed 16-bit difference between two symbols
#define IMAGE_REL_M68K_DIFF32        32  // Computed 32-bit difference between two symbols

#define IMAGE_REL_M68K_CSECTABLEB16       35  // Create a table with csnCODE byte-sized entries
#define IMAGE_REL_M68K_CSECTABLEW16       36  // Create a table with csnCODE word-sized entries
#define IMAGE_REL_M68K_CSECTABLEL16       37  // Create a table with csnCODE long-sized entries
#define IMAGE_REL_M68K_CSECTABLEBABS32    38  // Create a table with csnCODE byte-sized entries
#define IMAGE_REL_M68K_CSECTABLEWABS32    39  // Create a table with csnCODE word-sized entries
#define IMAGE_REL_M68K_CSECTABLELABS32    40  // Create a table with csnCODE long-sized entries
#define IMAGE_REL_M68K_DUPCON16           41  // Duplicate the contributor where this symbol is defined and put it in this PE section
#define IMAGE_REL_M68K_DUPCONABS32        42  // Duplicate the contributor where this symbol is defined and put it in this PE section

#define IMAGE_REL_M68K_PCODESN16          45  // Write the section number of the code where the fixup occurs
#define IMAGE_REL_M68K_PCODETOD24         46  // 24-bit code-to-data ref
#define IMAGE_REL_M68K_PCODETOT24         47  // 24-bit code-to-thunk ref
#define IMAGE_REL_M68K_PCODETOCS24        48  // 24-bit code-to-codespacedata ref
#define IMAGE_REL_M68K_PCODENEPE16        49  // 16-bit NEP elimination fixup
#define IMAGE_REL_M68K_PCODETONATIVE32    50  // 32-bit PCode-to-native reference

// MacProf constants
#define MACPROF_MAX_SECTIONS         2047  
#define MACPROF_CBITSINOFF             21
#define MACPROF_SN_MASK        0xFFE00000  // 11 bits for sn (up to 2047 sections)
#define MACPROF_OFF_MASK       0x001FFFFF  // 21 bits for offset (shifted right once to support sections up to 4 Meg)

// Data section header
typedef struct {
    unsigned long cbNearbss;   // size of near uninitialized data
    unsigned long cbNeardata;  // size of near initialized data
    unsigned long cbFarbss;    // size of near uninitialized data
    unsigned long cbFardata;   // size of near initialized data
} DATASECHDR;


// .resmap structure used by MRC to map resources to their type and ID
typedef struct {
    LONG typRes;                // resource type ("CODE", "DATA", etc)
    short iRes;                 // resource index
} RRM;                          // Raw to Resource Map

#define szsecRESMAP ".resmap"
#define szsecJTABLE ".jtable"
#define szsecDFIX   ".dfix"
#define szsecMSCV   ".mscv"
#define szsecSWAP   ".swap"
#define szsecFARBSS ".farbss"

#if 0 // These are defined in ntimage.h and are only included for reference.

#define IMAGE_SCN_TYPE_REGULAR               0x00000000  //
#define IMAGE_SCN_TYPE_DUMMY                 0x00000001  // Reserved.
#define IMAGE_SCN_TYPE_NO_LOAD               0x00000002  // Reserved.
#define IMAGE_SCN_TYPE_GROUPED               0x00000004  // Used for 16-bit offset code.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
#define IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_OVERLAY                0x00000400  // Section contains an overlay.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

#endif // 0

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.

// MAC section header flags
#define IMAGE_SCN_MEM_PROTECTED              0x00004000  
#define IMAGE_SCN_MEM_FARDATA                0x00008000  
#define IMAGE_SCN_MEM_SYSHEAP                0x00010000  
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000  
#define IMAGE_SCN_MEM_LOCKED                 0x00040000  
#define IMAGE_SCN_MEM_PRELOAD                0x00080000  

// MAC symbol class
// undefine for new win32 headers #define IMAGE_SYM_CLASS_FAR_EXTERNAL		 68
// Now defined in winnt.h

// Misc Symbol Types
// pcode flag currently used only for mac, but can be used easily by anyone
#define IMAGE_SYM_TYPE_PCODE            0x8000

// Data section masks
#define BSS_MASK      (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_FARDATA)
#define DATA_MASK     (IMAGE_SCN_CNT_INITIALIZED_DATA   | IMAGE_SCN_MEM_FARDATA)

#define NBSS          IMAGE_SCN_CNT_UNINITIALIZED_DATA 
#define NDATA         IMAGE_SCN_CNT_INITIALIZED_DATA   
#define FBSS          (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_FARDATA)
#define FDATA         (IMAGE_SCN_CNT_INITIALIZED_DATA   | IMAGE_SCN_MEM_FARDATA)

#define BSS_OR_DATA_MASK (IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA)

// Mac Finder Information layout

// see pg. 9-37 of Inside Macintosh vol. 6
#define	FINDER_FLAG_INVISIBLE	0x40		// fd_Attr1
#define	FINDER_FLAG_SET			0x01		// fd_Attr1
#define FINDER_FLAG_BNDL		0x20		// ditto

#define FINDER_INFO_SIZE			32
typedef struct {
	unsigned char	fd_Type[4];
	unsigned char	fd_Creator[4];
	unsigned char	fd_Attr1;			// Bits 8-15
	unsigned char	fd_Attr2;			// Bits 0-7
	unsigned char	fd_Location[4];
	unsigned char	fd_FDWindow[2];
	unsigned char	fd_OtherStuff[16];
	} FINDERINFO, *PFINDERINFO;


// Apple-II (ProDOS) information.

// default values for newly discovered items
#define	PRODOS_TYPE_FILE	0x04	// corresponds to finder fdType 'TEXT'
#define PRODOS_TYPE_DIR		0x0F
#define PRODOS_AUX_DIR		0x02	// actually 0x0200

// some other finder fdType to prodos FileType mapping values
#define PRODOS_FILETYPE_PSYS	0xFF
#define PRODOS_FILETYPE_PS16	0xB3

#define PRODOS_INFO_SIZE			6
typedef struct
{
	unsigned char pd_FileType[2];
	unsigned char pd_AuxType[4];
} PRODOSINFO, *PPRODOSINFO;

// Directory Access Permissions
#define	DIR_ACCESS_SEARCH			0x01	// See Folders
#define	DIR_ACCESS_READ				0x02	// See Files
#define	DIR_ACCESS_WRITE			0x04	// Make Changes
#define	DIR_ACCESS_OWNER			0x80	// Only for user
											// if he has owner rights
typedef struct _AfpInfo {
	unsigned long		afpi_Signature;			// Signature
	long				afpi_Version;			// Version
	unsigned long		afpi_Id;				// AFP File or directory Id
	unsigned long		afpi_BackupTime;		// Backup time for the file/dir
										// (Volume backup time is stored
										// in the AFP_IdIndex stream)

	FINDERINFO	afpi_FinderInfo;		// Finder Info (32 bytes)
	PRODOSINFO  afpi_ProDosInfo;		// ProDos Info (6 bytes)

	unsigned short		afpi_Attributes;		// Attributes mask (maps ReadOnly)

	unsigned char		afpi_AccessOwner;		// Access mask (SFI vs. SFO)
	unsigned char		afpi_AccessGroup;		// Directories only
	unsigned char		afpi_AccessWorld;
	} AFPINFO, *PAFPINFO;

#define AFP_SERVER_SIGNATURE		(*(unsigned long *)"AFP")
#define	AFP_SERVER_VERSION			0x00010000
#define	BEGINNING_OF_TIME 			0x80000000

//
// Initialize a AFPINFO structure with default values
//
// VOID
// AfpInitAfpInfo(
//		IN	PAFPINFO	pAfpInfo,
//		IN	DWORD		AfpId OPTIONAL, // 0 if we don't yet know the AFP Id
//		IN	BOOLEAN		IsDir
// )
//
#define AfpInitAfpInfo(pAfpInfo,AfpId,IsDir)	\
	memset(pAfpInfo,0,sizeof(AFPINFO)); \
	(pAfpInfo)->afpi_Signature = AFP_SERVER_SIGNATURE; \
	(pAfpInfo)->afpi_Version = AFP_SERVER_VERSION; \
	(pAfpInfo)->afpi_BackupTime = BEGINNING_OF_TIME; \
	(pAfpInfo)->afpi_Id = AfpId; \
	(pAfpInfo)->afpi_Attributes = 0; \
	if (IsDir) \
	{ \
		(pAfpInfo)->afpi_AccessOwner = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_AccessGroup = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_AccessWorld = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_DIR;\
		(pAfpInfo)->afpi_ProDosInfo.pd_AuxType[1] = PRODOS_AUX_DIR;\
	} \
	else \
	{ \
		(pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_FILE; \
	}

#if defined _MSC_VER && _MSC_VER >= 800
#pragma pack(pop)
#else
#pragma pack()
#endif

#endif // _MACIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\mrengine.h ===
// Interface for minimum rebuild engine
//

#if !defined(_mrengine_h)
#define _mrengine_h

// get rid of baggage we don't need from windows.h
#define WIN32_LEAN_AND_MEAN
//#define NOGDI
#define NOUSER
#define NONLS

// include pdb, msf, and nameserver 
#include <pdb.h>
#include <windows.h>
#include <tchar.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <stddef.h>

//
// Get the calling conventions and declspec stuff out of the way
//
#if defined(_X86_) || defined(_M_IX86)
#define	MRECALL			__stdcall
#else
#define MRECALL			__cdecl
#endif

#if defined(MR_ENGINE_STATIC)
#define MREAPI(rtype)		rtype MRECALL
#elif !defined(MR_ENGINE_IMPL)
#define	MREAPI(rtype)		rtype __declspec(dllimport) MRECALL
#else
#define MREAPI(rtype)		rtype __declspec(dllexport) MRECALL
#endif

//
// Our C++ Interfaces
//
PdbInterface                   MREngine;
typedef PdbInterface MREngine  MREngine;
typedef MREngine *			PMREngine;

PdbInterface                   MREDrv;
typedef PdbInterface MREDrv    MREDrv;
typedef MREDrv *			PMREDrv;

PdbInterface                   MRECmp;
typedef PdbInterface MRECmp    MRECmp;
typedef MRECmp *			PMRECmp;

PdbInterface                   MREUtil;
typedef PdbInterface MREUtil   MREUtil;
typedef MREUtil *			PMREUtil;

PdbInterface                   MREFile;
typedef PdbInterface MREFile   MREFile;
typedef MREFile *			PMREFile;

PdbInterface                   MREBag;
typedef PdbInterface MREBag    MREBag;
typedef MREBag *			PMREBag;

PdbInterface                   MRELog;
typedef PdbInterface MRELog    MRELog;
typedef MRELog *			PMRELog;

//
// other interesting things
//
#if !defined(FALSE)
#define FALSE 0
#define TRUE 1
#endif

#if !defined(fFalse)
#define fFalse FALSE
#define fTrue TRUE
#endif

// compile time assert
#if !defined(CASSERT)
	#if defined(_DEBUG)
		#define CASSERT(x) extern char dummyAssert[ (x) ]
	#else
		#define CASSERT(x)
	#endif
#endif

typedef _TCHAR *			SZ;			// String
typedef const _TCHAR *		SZC;		// const String
typedef DWORD				_CB;

#pragma warning(disable:4200)

typedef struct DepData {
	size_t	cb;
	BYTE	rgb[];
	} DepData, *PDepData;

#pragma warning(default:4200)

#if _INTEGRAL_MAX_BITS >= 64
typedef unsigned __int64	QWORD;		// 64-bit unsigned int
#else
typedef ULARGE_INTEGER		QWORD;
#endif

typedef PDB *				PPDB;
typedef NameMap *			PNMP;

typedef enum DEPON {			// depends on bits
	deponName = 0,					// nothing...requires a name
	deponVtshape = 0x1,				// depon virtual functions/bases
	deponShape = 0x2,				// depon size or offsets of class
	deponAll = -1,					// pseudo deps, not stored, but union
									// 	of all the above...
	} DEPON;

// file out-of-date structure/enumerations/flags
typedef enum YNM {	// Yes No Maybe
	ynmNo,
	ynmMaybe,
	ynmYes
	} YNM;
typedef struct SRCTARG *	PSRCTARG;
typedef struct SRCTARG {
	PSRCTARG	psrctargNext;
	BOOL		fCpp;
	SZC			szSrc;
	SZC			szTarg;
	SZC			szOptions;
	DWORD		dwWeightMaybe;
	} SRCTARG, **PPSRCTARG;

typedef struct CAList {		// Compile Action List
	PSRCTARG	pstDoCompile;
	PSRCTARG	pstMaybeCompile;
	PSRCTARG	pstDontCompile;
	PSRCTARG	pstDone;
	PSRCTARG	pstError;
	} CAList, *PCAList;

typedef enum TrgType {
	trgtypeObject,
	trgtypeSbr
	} TrgType;

// inline functions to manipulate lists of SRCTARGs
//
// Insert at a particular pst location, can be anywhere in the list
__inline PPSRCTARG
InsertSrcTarg ( PPSRCTARG ppstAt, PSRCTARG pst ) {
	pst->psrctargNext = *ppstAt;
	*ppstAt = pst;
	return &pst->psrctargNext;
	}

// Delete does a find on the pst then snips from the list
//
__inline void
DeleteSrcTarg ( PPSRCTARG ppstListHead, PSRCTARG pst ) {
	PPSRCTARG	ppstCur = ppstListHead;
	PPSRCTARG	ppstPrev = ppstCur;

	// find the matching pst
	while ( *ppstCur && *ppstCur != pst ) {
		ppstPrev = ppstCur;
		ppstCur = &(*ppstCur)->psrctargNext;
		}
	if ( *ppstCur ) {
		*ppstPrev = (*ppstCur)->psrctargNext;
		}
	}

// Delete a particular pst, given its pst and a pst whose psrctargNext
//	points to pst.
__inline void
DeleteSrcTargAt ( PSRCTARG pst, PPSRCTARG ppstPrev ) {
	*ppstPrev = pst->psrctargNext;
	}

// NextSrcTarg, so simple, no comment
//
__inline PSRCTARG
PstNext ( PSRCTARG pst ) {
	return pst ? pst->psrctargNext : 0;
	}

// Return the address of the last pst (a PPSRCTARG) in the list
//
__inline PPSRCTARG
PpstLast ( PPSRCTARG ppstHead ) {
	PSRCTARG	pst = *ppstHead;
	PPSRCTARG	ppstRet = ppstHead;

	while ( pst = PstNext ( pst ) ) {
		ppstRet = &pst->psrctargNext;
		}

	return ppstRet;
	}
//
// PDB api required by MRE.  Passed in in cases where the caller is using
// a wide bandwidth api to the PDB already.
//
typedef struct MreToPdb {
	PDB *		ppdb;			// the IDB file pdb api
	NameMap *	pnamemap;		// the namemap in the IDB
	TPI *		ptpi;			// the tpi in the PDB
	PDB *		ppdbPdbFile;	// the PDB file pdb api
	void *		pvReserved1;
	void *		pvReserved2;
	} MreToPdb, *PMreToPdb;

#if defined(__cplusplus)

// C++ bindings

// callback functions and datatypes for enumerating files and dependencies
enum EnumType { etSource, etDep };

enum ChgState { chgstUnknown, chgstClass, chgstRude };

// File Status Masks
enum FSM {
	fsmNil = 0,
	fsmOutOfDate = 0x1,
	fsmHasTarget = 0x2,
	fsmIsTarget = 0x4,
	fsmVisited = 0x8,
	fsmIgnoreDep = 0x10,
	fsmInclByPch = 0x20,
	fsmIsPch = 0x40,
	fsmCreatesPch = 0x80,
    fsmFileType = 0x300,
	fsmIsetPch = 0xffff0000,
	};

// File Type so we can infer what to do with dependencies when compiler changes
// and what is valid to do when checking for dependencies.
enum FileType {
    ftC = 0,
    ftCpp = 1,
    ftUnused = 2,
    ftOther = 3,
    };

union MREFT {			// MRE FileTime
	FILETIME	ft;
	QWORD		qwft;
	};

typedef unsigned long	BldId;
const BldId	bldidMax = ULONG_MAX;

struct FILEINFO {
	NI		niFile;			// main index value
	union {
		DWORD	dwStatus;		// file status bits
		// these are not used, just added for reference during debugging...
		struct {
			unsigned	fOutOfDate		: 1;
			unsigned	fHasTarget		: 1;
			unsigned	fIsTarget		: 1;
			unsigned	fVisited		: 1;
			unsigned	fIgnoreDep		: 1;
			unsigned	fInclByPch		: 1;
			unsigned	fIsPch			: 1;
			unsigned	fCreatesPch		: 1;
            unsigned    ftCompiland     : 2;
            unsigned    fUnused         : 6;
			unsigned	isetPch			: 16;
			};
		};
	MREFT	fiTime;			// time stamp
	QWORD	fiSize;			// file size
	NI		niOptions;		// option string (src only)
	NI		niRelated;		// for src, it is the target, for target, it is src
	BldId	bldid;			// tell when (wrt the pdb) last built (src only)
	DWORD	dwReserved;		// internal padding to 8 byte alignment
	};

// make sure the sizes and offsets are what we expect, as well as 8byte alignment
CASSERT(offsetof(FILEINFO, fiTime) == sizeof(NI)+sizeof(DWORD));
CASSERT((sizeof(FILEINFO) & 0x7) == 0);

struct FILESUMMARYINFO {
	DWORD	cFileDeps;
	DWORD	cClasses;
	};
typedef FILESUMMARYINFO	FSI;

struct EnumFile {
	SZC			szFileSrc;
	SZC			szFileTrg;
	FILEINFO	fiSrc;
	FILEINFO	fiTrg;
	FSI			fsiSrc;
	SZC			szOptions;
	void *		pvContext;
	};

struct EnumClass {
	NI			niClass;
	SZC			szClassName;
	DWORD		depon;
	DWORD		cMembersHit;
	DWORD		cMembersBits;
	TI			tiClass;
	void *		pvContext;
	};

// enumfile source (root) file callback
typedef BOOL (MRECALL * PfnFEFSrcCallBack) ( PMREUtil, EnumFile &, EnumType et =etSource );
// enumfile dep file callback
typedef BOOL (MRECALL * PfnFEFDepCallBack) ( PMREUtil, EnumFile &, EnumType et =etDep );
// enumfile all files callback
typedef BOOL (MRECALL * PfnFEFAllCallBack) ( PMREUtil, EnumFile & );
// enumclass callback
typedef BOOL (MRECALL * PfnFEClassCallBack) ( PMREUtil, EnumClass & );

// status (bytes, sizes, etc.)
struct StreamUtilization {
	DWORD	cbUsed;			// actually used by data we need
	DWORD	cbInternal;		// internal size (maps, sets)
	DWORD	cbExternal;		// external size (stream)

	StreamUtilization &
	operator += ( const StreamUtilization & su ) {
		cbUsed += su.cbUsed;
		cbInternal += su.cbInternal;
		cbExternal += su.cbExternal;
		return *this;
		}
	StreamUtilization
	operator + ( const StreamUtilization & su ) {
		StreamUtilization	suNew = *this;
		return suNew += su;
		}

	};

struct MreStats {
	DWORD				cSrcFiles;
	DWORD				cTrgFiles;
	DWORD				cDepFiles;
	DWORD				cClasses;
	DWORD				cBoringClasses;
	DWORD				cDedicatedStreams;
	DWORD				cbFilesInNamemap;
	DWORD				cbClassesInNamemap;
	StreamUtilization	suFileInfo;
	StreamUtilization	suClassInfo;
	StreamUtilization	suPerFileInfo;
	StreamUtilization	suTotal;
	};

PdbInterface MREDrv {  // compiler driver port
    // release this PdbInterface
	virtual BOOL		FRelease() pure;

	// expensive operation!  the driver will call this once per list of
	//	files to compile.
	virtual BOOL		FRefreshFileSysInfo() pure;

	// called by the driver after each successful compilation, this lets the
	//	mr engine know that a file was successfully compiled or not.
	virtual BOOL		FSuccessfulCompile (
							BOOL	fOk,
							SZC		szFileSrc,
							SZC		szFileTarg
							) pure;

	// To check if a file is really out of date wrt our fine grained deps...
	virtual YNM			YnmFileOutOfDate ( SRCTARG & ) pure;

	// alternate way, batch the files up, will segregate files into the
	//	appropriate lists inside of the CAList structure.
	virtual BOOL		FFilesOutOfDate ( PCAList pst ) pure;
							
	// post pass for files we didn't actually compile, but may need to update
	virtual BOOL		FUpdateTargetFile ( SZC szTrg, TrgType ) pure;

	// one-time driver init function.  called once per driver invocation ONLY.
	virtual void		OneTimeInit() pure;
	};

PdbInterface MRECmp {  // compiler front end port
    // release this PdbInterface
	virtual BOOL		FRelease() pure;

	// this method is used to get things rolling on each compiland.
	virtual BOOL		FOpenCompiland (
							OUT PMREFile * ppmrefile,
							IN SZC szFileSrc,
							IN SZC szFileTarg
							) pure;

	// after all is said and done with the compile, this needs to get called
	//	to do folding, propagation, and flattening, after the compiler
	//	has run successfully.
	virtual BOOL		FCloseCompiland ( PMREFile pmrefile, BOOL fCommit ) pure;

	// called when moving to an #include'ed file
	virtual BOOL		FPushFile (
							OUT PMREFile * ppmrefile,
							IN SZC szFile,
							IN HANDLE hFile =INVALID_HANDLE_VALUE
							) pure;

	// called when leaving an #include'ed file.
	//	returns PMREFile of enclosing (previous) file.
	virtual PMREFile	PmrefilePopFile() pure;

	// save/restore the dependencies (at pch create/restore time).
	//	Call FStoreDepData with a pointer to a DepData structure with a valid
	//	size  (the _cb field needs to be included).  The smallest possible
	//	DepBlob size is sizeof(CB).  A good size to start with is probably 8K. 
	//	This call will fill in the actual size of the data so the 
	//	block of memory can be trimmed back if you like.  Likewise, if the
	//	block is not big enough, this will return false with the size needed
	//	filled into the DepData.  If that size is 0, then there is no DepData
	//	to store.
	virtual BOOL		FStoreDepData ( PDepData ) pure;
	virtual BOOL		FRestoreDepData ( PDepData ) pure;

	// tell me a class in not interesting to store deps for (not changing much?)
	virtual void		ClassIsBoring ( NI niClass ) pure;

	};

PdbInterface MREUtil { // utility port, stats, enumerations, etc.
    // release this PdbInterface
	virtual BOOL		FRelease() pure;

	// support for offline tools to dump and otherwise peruse the
	//	mregine storage
	virtual void		EnumSrcFiles (
                            PfnFEFSrcCallBack,
                            SZC szFileSrc = NULL,
                            void * pvContext = NULL
                            ) pure;
	virtual void		EnumDepFiles ( EnumFile &, PfnFEFDepCallBack ) pure;
	virtual void		EnumAllFiles (
                            PfnFEFAllCallBack,
                            SZC szFileSrc = NULL,
                            void * pvContext = NULL
                            ) pure;
	virtual void		EnumClasses (
                            PfnFEClassCallBack,
                            SZC szFileSrc,
                            void * pvContext = NULL
                            ) pure;
	virtual void		SummaryStats ( MreStats & ) pure;

	};

// basically, we have a hierarchy: an MRE has MREFiles which in turn 
//	have MREBags.
// 
PdbInterface MREngine {
	// open methods by pdb * and pdb name
	static MREAPI(BOOL)	FOpen (
		OUT PMREngine *	ppmre,
		PPDB			ppdb,
		PNMP			pnmp,
		BOOL			fWrite,
		BOOL			fClosePdb = fFalse
		);
	static MREAPI(BOOL)	FOpen (
		OUT PMREngine *	ppmre,
		SZC				szPdb,
		EC &			ec,
		_TCHAR			szErr[ cbErrMax ],
		BOOL			fReproSig,
		BOOL			fWrite
		);
	static MREAPI(BOOL) FOpen (
		OUT PMREngine *	ppmre,
		PMreToPdb		pmretopdb,
		BOOL			fWrite,
		BOOL			fClosePdb = fFalse
		);
		

	// remove all MRE related streams from the PDB.
	virtual BOOL		FDelete() pure;

	// close and optionally commit new data
	virtual BOOL		FClose ( BOOL fCommit ) pure;
	
	// get the pdb api we are using
	virtual void		QueryPdbApi ( PDB *& rppdb, NameMap *& rpnamemap ) pure;

	// get the MreLog api
	virtual void		QueryMreLog ( PMRELog & rpmrelog ) pure;

    // get the various PdbInterface ptrs
	virtual void		QueryMreDrv ( PMREDrv & rpmredrv ) pure;
	virtual void		QueryMreCmp ( PMRECmp & rpmrecmp, TPI * ) pure;
	virtual void		QueryMreUtil ( PMREUtil & rpmreutil ) pure;

	// commit the global portions (actually, just write the streams...
	// a PDB/MSF commit must happen as well)
	virtual BOOL		FCommit() pure;

	};

//
// ClassChanged enumeration types for MREFile PdbInterface
//
typedef BOOL (MREFile::* MfnNoteClassTI) ( NI, TI );
typedef BOOL (__cdecl * PfnEnumClassChange) ( NI, PMREFile, MfnNoteClassTI );

PdbInterface MREFile {

	// icc -> mr flags
	//
	// iccfClassMrEdit implies that the class has a change that is detectable
	//	via cv type info changes downstream from the icc.
	//
	// iccfClassRudeEdit implies that something changed in the class that
	//	is not detectable downstream via type info and that at the very least,
	//	any code dependent in any way on the class needs to be recompiled.
	//
	// iccfFileRudeEdit means that something in the header file is rude,
	//	either added, removed, or continuing to be rude.
	//
	// iccfMethodEdit means that a change to class::method needs to be
	//	generated and any code dependent on class::method compiled.
	//
	// iccfAllCodeCompiled is used to detect when all code in a compiland
	//	has been compiled or not.  the incrememtal compiler may skip functions,
	//	in which case, the MR will merge the previous class deps with the new
	//	class deps in order to not lose dependency information.
	enum {
		iccfClassRudeEdit = 0x1,
		iccfClassMrEdit = 0x2,
		iccfFileRudeEdit = 0x4,
		iccfMethodEdit = 0x8,
		iccfAllCodeCompiled = 0x20,
		iccfAnyRude = iccfClassRudeEdit | iccfFileRudeEdit,
		};

	virtual BOOL		FOpenBag ( OUT PMREBag * ppmrebag, NI niNameBag ) pure;
	virtual BOOL		FnoteEndInclude ( DWORD dwFlags ) pure;
	virtual BOOL		FnoteClassMod ( NI niClass, DWORD dwFlags ) pure;
	virtual BOOL		FnoteInlineMethodMod ( 
							NI		niClass,
							SZC		szMember,
							DWORD	dwFlags
							) pure;
	virtual BOOL		FnoteLineDelta ( DWORD dwLineBase, INT delta ) pure;
	virtual void		EnumerateChangedClasses ( PfnEnumClassChange ) pure;
	virtual BOOL		FnoteClassTI ( NI, TI ) pure;
	virtual BOOL		FIsBoring() pure;
	virtual BOOL		FnotePchCreateUse (
							SZC	szPchCreate,
							SZC szPchUse
							) pure;
	};

PdbInterface MREBag {
	virtual BOOL		FAddDep (
							NI		niDep,				// class name's NI
							TI		tiDep,				// class type index
							SZC		szMemberName,		// member name
							DEPON	deponHow,			// how it depends on it
							DWORD	dwLine =0			// where referenced
							) pure;
	virtual BOOL		FClose() pure;
	};

PdbInterface MRELog {
	virtual void		TranslateToText ( BOOL fClear, _TCHAR ** pptch ) pure ;
	virtual void		TranslateToText ( BOOL fClear, FILE * pfile ) pure;
	};


#endif	// __cpluscplus

#if defined(__cplusplus)
extern "C" {
#endif

// C interfaces for MRE
MREAPI(BOOL)		MREFOpenEx (
						OUT PMREngine *	ppmre,
						PMreToPdb		pmretopdb,
						BOOL			fWrite
						);
MREAPI ( BOOL )		MREFOpen (
						OUT PMREngine * ppmre,
						PPDB			ppdb,
						PNMP			pnmp,
						BOOL			fWrite
						);
MREAPI ( BOOL )		MREFOpenByName (
						OUT PMREngine *	ppmre,
						SZC				szPdb,
						EC *			pec,
						_TCHAR			szErr[ cbErrMax ],
						BOOL			fReproSig,
						BOOL			fWrite
						);
MREAPI ( BOOL )		MREFDelete ( PMREngine );
MREAPI ( BOOL )		MREFClose ( PMREngine, BOOL fCommit ) ;
MREAPI ( void )		MREQueryMreDrv ( PMREngine, OUT PMREDrv *);
MREAPI ( void )		MREQueryMreCmp ( PMREngine, OUT PMRECmp *, IN TPI * );
MREAPI ( void )		MREQueryMreUtil ( PMREngine, OUT PMREUtil * );

// C interfaces for MREDrv
MREAPI ( BOOL )		MREDrvFRelease ( PMREDrv );
MREAPI ( BOOL )		MREDrvFRefreshFileSysInfo ( PMREDrv );
MREAPI ( BOOL )		MREDrvFSuccessfulCompile (
						PMREDrv,
						BOOL fOk,
						SZC szFileSrc,
						SZC szFileTarg
						);
#if !defined(NO_YNM)
MREAPI ( YNM )		MREDrvYnmFileOutOfDate ( PMREDrv, SRCTARG * );
#endif

MREAPI ( BOOL )		MREDrvFFilesOutOfDate ( PMREDrv, PCAList pCAList );
MREAPI ( BOOL )		MREDrvFUpdateTargetFile ( PMREDrv, SZC szTrg, TrgType );
MREAPI ( void )		MREDrvOneTimeInit ( PMREDrv );

// C PdbInterface for MRECmp
MREAPI ( BOOL )		MRECmpFRelease ( PMRECmp );
MREAPI ( BOOL )		MRECmpFOpenCompiland (
						PMRECmp,
						OUT PMREFile *	ppmrefile,
						IN SZC			szFileSrc,
						IN SZC			szFileTarg
						);
MREAPI ( BOOL )		MRECmpFCloseCompiland ( PMRECmp, PMREFile, BOOL fCommit );
MREAPI ( BOOL )		MRECmpFPushFile ( 
						PMRECmp,
						OUT PMREFile *	ppmrefile,
						IN SZC			szFile,
						IN HANDLE		hfile
						);
MREAPI ( PMREFile )	MRECmpPmrefilePopFile ( PMRECmp ) ;
MREAPI ( BOOL )		MRECmpFStoreDepData ( PMRECmp, PDepData );
MREAPI ( BOOL )		MRECmpFRestoreDepData ( PMRECmp, PDepData );
MREAPI ( void )		MRECmpClassIsBoring ( PMRECmp, NI );



// C interfaces for MREFile
MREAPI ( BOOL )		MREFileFOpenBag ( PMREFile, OUT PMREBag *, NI );

// C interfaces for MREBag
MREAPI ( BOOL )		MREBagFAddDep (
						PMREBag,
						NI niDep,
						TI tiDep,
						SZC szMemberName,
						DEPON depon
						);
MREAPI ( BOOL )		MREBagFClose ( PMREBag );

#if defined(__cplusplus)
}	// extern "C"
#endif

#endif	// _mrengine_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\sqlprxky.h ===
// SqldprxyKey.h - startup key for sqldprxy

// proxy gets started up with 2 args, the first is the key,
// the 2nd is the event name (which includes the PID to make it unique)
#define SZSQLPROXYKEY	"SqlProxyKeyArg"

void __inline BuildProxyEventName( char *p )
{
	wsprintf(p, "MS.MSDev.Event.Ent.%x", GetCurrentProcessId() );
}

#ifdef DEBUG
#define	szSqlProxyBase	"sqlprxyd"
#else
#define	szSqlProxyBase	"sqlprxy"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\pdb.h ===
// Debug Information API
// Copyright (C) 1993-1996, Microsoft Corp.  All Rights Reserved.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __PDB_INCLUDED__
#define __PDB_INCLUDED__

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef unsigned long DWORD;
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SIG;        // unique (across PDB instances) signature
typedef ULONG   AGE;        // no. of times this instance has been updated

enum {
    PDBIntv50a  = 19970116,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntv     = PDBIntv50a,
};

// cvinfo.h type index, intentionally typedef'ed here to check equivalence.
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;

typedef CV_typ_t        TI;     // PDB name for type index
typedef CV_typ16_t      TI16;   // 16-bit version
typedef unsigned long   NI;     // name index
typedef TI *            PTi;
typedef TI16 *          PTi16;

typedef BYTE            ITSM;   // type server map index
typedef ITSM*           PITSM;
struct _tagSEARCHDEBUGINFO;
typedef BOOL ( __stdcall * PfnFindDebugInfoFile) ( struct _tagSEARCHDEBUGINFO* );

#if CC_LAZYSYMS
#pragma message("using LAZYSYMS")
#endif
#if CC_LAZYLINES
#pragma message("using LAZYLINES")
#endif

enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
};


#define PdbInterface struct
PdbInterface PDB;                  // program database
PdbInterface DBI;                  // debug information within the PDB
PdbInterface Mod;                  // a module within the DBI
PdbInterface TPI;                  // type info within the DBI
PdbInterface GSI;                  // global symbol info
PdbInterface SO;
PdbInterface Stream;               // some named bytestream in the PDB
PdbInterface StreamImage;          // some memory mapped stream
PdbInterface NameMap;              // name mapping
PdbInterface Enum;                 // generic enumerator
PdbInterface EnumNameMap;          // enumerate names within a NameMap
PdbInterface EnumContrib;          // enumerate contributions
PdbInterface Dbg;                  // misc debug data (FPO, OMAP, etc)

typedef PdbInterface PDB PDB;
typedef PdbInterface DBI DBI;
typedef PdbInterface Mod Mod;
typedef PdbInterface TPI TPI;
typedef PdbInterface GSI GSI;
typedef PdbInterface SO SO;
typedef PdbInterface Stream Stream;
typedef PdbInterface StreamImage StreamImage;
typedef PdbInterface NameMap NameMap;
typedef PdbInterface Enum Enum;
typedef PdbInterface EnumStreamNames EnumStreamNames;
typedef PdbInterface EnumNameMap EnumNameMap;
typedef PdbInterface EnumContrib EnumContrib;
typedef PdbInterface WidenTi WidenTi;
typedef PdbInterface Dbg Dbg;
typedef PdbInterface EnumThunk EnumThunk;


typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_ILLEGAL_TYPE_EDIT,   // trying to edit types in read-only mode
    EC_INVALID_EXECUTABLE,  // not recogized as a valid executable
    EC_DBG_NOT_FOUND,       // A required .DBG file was not found
    EC_NO_DEBUG_INFO,       // No recognized debug info found
    EC_MAX
};

#define  pure = 0

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#ifdef PDB_SERVER
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllexport) RTYPE PDBCALL
#elif   defined(PDB_LIBRARY)
#define PDB_IMPORT_EXPORT(RTYPE)    RTYPE PDBCALL
#else
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL
#endif

#define PDBAPI PDB_IMPORT_EXPORT

#ifndef IN
#define IN                  /* in parameter, parameters are IN by default */
#endif
#ifndef OUT
#define OUT                 /* out parameter */
#endif

// type of callback arg to PDB::GetRawBytes
typedef BOOL (PDBCALL *PFNfReadPDBRawBytes)(const void *, long);

// WidenTi interface needs a couple of structures to communicate info back
// and forth.
struct OffMap {
    ULONG       offOld;
    ULONG       offNew;
};
typedef struct OffMap   OffMap;
typedef OffMap *        POffMap;

struct SymConvertInfo {
    ULONG       cbSyms;             // size necessary for converting a block
    ULONG       cSyms;              // count of symbols, necessary to allocate
                                    // mpoffOldoffNew array.
    BYTE *      pbSyms;             // block of symbols (output side)
    OffMap *    rgOffMap;           // OffMap rgOffMap[cSyms]
};
typedef struct SymConvertInfo   SymConvertInfo;
enum { wtiSymsNB09 = 0, wtiSymsNB10 = 1 };

// Filter values for PDBCopyTo
enum { 
    copyRemovePrivate       = 0x00000001,   // remove private debug information
    copyCreateNewSig        = 0x00000002,   // create new signature for target pdb
};

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
};

typedef enum DBGTYPE DBGTYPE;

// Linker data necessary for relinking an image.  Record contains two SZ strings
// off of the end of the record with two offsets from the base 
//
enum VerLinkInfo {
    vliOne = 1,
    vliCur = vliOne,
};

struct LinkInfo {
    ULONG           cb;             // size of the whole record.  computed as
                                    //  sizeof(LinkInfo) + strlen(szCwd) + 1 +
                                    //  strlen(szCommand) + 1
    ULONG           ver;            // version of this record (VerLinkInfo)
    ULONG           offszCwd;       // offset from base of this record to szCwd
    ULONG           offszCommand;   // offset from base of this record
    ULONG           ichOutfile;     // index of start of output file in szCommand
    // The command includes the full path to the linker, the -re and -out:...
    // swithches.
    // A sample might look like the following:
    // "c:\program files\msdev\bin\link.exe -re -out:debug\foo.exe"
    // with ichOutfile being 48.
    // the -out switch is guaranteed to be the last item in the command line.
#ifdef __cplusplus
    VerLinkInfo Ver() const {
        return VerLinkInfo(ver);
    }
    long Cb() const {
        return cb;
    }
    char *     SzCwd() const {
        return (char *)((char *)(this) + offszCwd);
    }
    char *    SzCommand() const {
        return (char *)((char *)(this) + offszCommand);
    }
    char *    SzOutFile() const {
        return SzCommand() + ichOutfile;
    }
    LinkInfo() :
        cb(0), ver(vliCur), offszCwd(0), offszCommand(0), ichOutfile(0)
    {
    }

#endif
};

typedef struct LinkInfo LinkInfo;
typedef LinkInfo *      PLinkInfo;


#ifdef __cplusplus

// C++ Binding

PdbInterface PDB {                 // program database
    enum {
        intv  = PDBIntv,
        intvAlt = PDBIntvAlt
    };
    static PDBAPI(BOOL) OpenValidate(/*const*/ char* szPDB, /*const*/ char* szPath,
                /*const*/ char* szMode, SIG sig, AGE age,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenValidateEx(/*const*/ char* szPDB, /*const*/ char* szPathOrig,
                /*const*/ char* szSearchPath, /*const*/ char* szMode,   SIG sig, AGE age,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) Open(/*const*/ char* szPDB, /*const*/ char* szMode, SIG sigInitial,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenValidate2(/*const*/ char* szPDB, /*const*/ char* szPath,
                /*const*/ char* szMode, SIG sig, AGE age, long cbPage,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenValidateEx2(/*const*/ char* szPDB, /*const*/ char* szPathOrig,
                /*const*/ char* szSearchPath, /*const*/ char* szMode,   SIG sig, AGE age,
                long cbPage, OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenEx(/*const*/ char* szPDB, /*const*/ char* szMode, SIG sigInitial,
                long cbPage, OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenValidate3(const char *szExecutable,const char *szSearchPath,
                OUT EC *pec, OUT char szError[cbErrMax],
                OUT char szDbgPath[PDB_MAX_PATH], OUT DWORD *pfo, OUT DWORD *pcb,
                OUT PDB **pppdb);

    static PDBAPI(BOOL) ExportValidateInterface(INTV intv);
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual EC   QueryLastError(OUT char szError[cbErrMax]) pure;
    virtual char*QueryPDBName(OUT char szPDB[PDB_MAX_PATH]) pure;
    virtual SIG  QuerySignature() pure;
    virtual AGE  QueryAge() pure;
    virtual BOOL CreateDBI(const char* szTarget, OUT DBI** ppdbi) pure;
    virtual BOOL OpenDBI(const char* szTarget, const char* szMode, OUT DBI** ppdbi ) pure;
    virtual BOOL OpenTpi(const char* szMode, OUT TPI** pptpi) pure;

    virtual BOOL Commit() pure;
    virtual BOOL Close() pure;
    virtual BOOL OpenStream(const char* szStream, OUT Stream** ppstream) pure;
    virtual BOOL GetEnumStreamNameMap(OUT Enum** ppenum) pure;
    virtual BOOL GetRawBytes(PFNfReadPDBRawBytes fSnarfRawBytes) pure;
    virtual IMPV QueryPdbImplementationVersion() pure;

    virtual BOOL OpenDBIEx(const char* szTarget, const char* szMode, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn=0) pure;

    virtual BOOL CopyTo(const char *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;

    inline BOOL ValidateInterface()
    {
        return ExportValidateInterface(intv);
    }
};


// Review: a stream directory service would be more appropriate
// than Stream::Delete, ...

PdbInterface Stream {
    virtual long   QueryCb() pure;
    virtual BOOL Read(long off, void* pvBuf, long* pcbBuf) pure;
    virtual BOOL Write(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Replace(void* pvBuf, long cbBuf) pure;
    virtual BOOL Append(void* pvBuf, long cbBuf) pure;
    virtual BOOL Delete() pure;
    virtual BOOL Release() pure;
    virtual BOOL Read2(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Truncate(long cb) pure;
};

PdbInterface StreamImage {
    static PDBAPI(BOOL) open(Stream* pstream, long cb, OUT StreamImage** ppsi);
    virtual long size() pure;
    virtual void* base() pure;
    virtual BOOL noteRead(long off, long cb, OUT void** ppv) pure;
    virtual BOOL noteWrite(long off, long cb, OUT void** ppv) pure;
    virtual BOOL writeBack() pure;
    virtual BOOL release() pure;
};

PdbInterface DBI {             // debug information
    enum { intv = PDBIntv };
    virtual IMPV QueryImplementationVersion() pure;
    virtual INTV QueryInterfaceVersion() pure;
    virtual BOOL OpenMod(const char* szModule, const char* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteMod(const char* szModule) pure;
    virtual BOOL QueryNextMod(Mod* pmod, Mod** ppmodNext) pure;
    virtual BOOL OpenGlobals(OUT GSI **ppgsi) pure;
    virtual BOOL OpenPublics(OUT GSI **ppgsi) pure;
    virtual BOOL AddSec(USHORT isect, USHORT flags, long off, long cb) pure;
    virtual BOOL QueryModFromAddr(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb) pure;
    virtual BOOL QuerySecMap(OUT BYTE* pb, long* pcb) pure;
    virtual BOOL QueryFileInfo(OUT BYTE* pb, long* pcb) pure;
    virtual void DumpMods() pure;
    virtual void DumpSecContribs() pure;
    virtual void DumpSecMap() pure;

    virtual BOOL Close() pure;
    virtual BOOL AddThunkMap(long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                    struct SO* psoSectMap, unsigned nSects,
                    USHORT isectThunkTable, long offThunkTable) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL getEnumContrib(OUT Enum** ppenum) pure;
    virtual BOOL QueryTypeServer( ITSM itsm, OUT TPI** pptpi ) pure;
    virtual BOOL QueryItsmForTi( TI ti, OUT ITSM* pitsm ) pure;
    virtual BOOL QueryNextItsm( ITSM itsm, OUT ITSM *inext ) pure;
    virtual BOOL QueryLazyTypes() pure;
    virtual BOOL SetLazyTypes( BOOL fLazy ) pure;   // lazy is default and can only be turned off
    virtual BOOL FindTypeServers( OUT EC* pec, OUT char szError[cbErrMax] ) pure;
    virtual void DumpTypeServers() pure;
    virtual BOOL OpenDbg(DBGTYPE dbgtype, OUT Dbg **ppdbg) pure;
    virtual BOOL QueryDbgTypes(OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype) pure;
    // apis to support EnC work
    virtual BOOL QueryAddrForSec(OUT USHORT* pisect, OUT long* poff, 
            USHORT imod, long cb, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdb( OUT PDB** pppdb ) pure;
    virtual BOOL AddLinkInfo(IN PLinkInfo ) pure;
    virtual BOOL QueryLinkInfo(PLinkInfo, OUT long * pcb) pure;
    // new to vc6
    virtual AGE  QueryAge() const pure;
    virtual void * QueryHeader() const pure;
};

PdbInterface Mod {             // info for one module within DBI
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BOOL AddTypes(BYTE* pbTypes, long cb) pure;
#if CC_LAZYSYMS
    virtual BOOL AddSymbols(BYTE* pbSym, long cb, unsigned icon) pure;
#else
    virtual BOOL AddSymbols(BYTE* pbSym, long cb) pure;
#endif
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
#if CC_LAZYLINES
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff, ULONG foCoff = 0) pure;
#else
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff) pure;
#endif
    virtual BOOL AddSecContrib(USHORT isect, long off, long cb, ULONG dwCharacteristics) pure;
    virtual BOOL QueryCBName(OUT long* pcb) pure;
    virtual BOOL QueryName(OUT char szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySymbols(BYTE* pbSym, long* pcb) pure;
    virtual BOOL QueryLines(BYTE* pbLines, long* pcb) pure;

    virtual BOOL SetPvClient(void *pvClient) pure;
    virtual BOOL GetPvClient(OUT void** ppvClient) pure;
    virtual BOOL QuerySecContrib(OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual BOOL QueryImod(OUT USHORT* pimod) pure;
    virtual BOOL QueryDBI(OUT DBI** ppdbi) pure;
    virtual BOOL Close() pure;
    virtual BOOL QueryCBFile(OUT long* pcb) pure;
    virtual BOOL QueryFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryTpi(OUT TPI** pptpi) pure; // return this Mod's Tpi
    // apis to support EnC work
    virtual BOOL AddSecContribEx(USHORT isect, long off, long cb, ULONG dwCharacteristics, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QueryItsm(OUT USHORT* pitsm) pure;
    virtual BOOL QuerySrcFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySupportsEC() pure;
};

PdbInterface TPI {             // type info

    enum { intv = PDBIntv };

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;

    virtual BOOL QueryTi16ForCVRecord(BYTE* pb, OUT TI16* pti) pure;
    virtual BOOL QueryCVRecordForTi16(TI16 ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi16(TI16 ti, OUT BYTE** ppb) pure;
    virtual TI16 QueryTi16Min() pure;
    virtual TI16 QueryTi16Mac() pure;

    virtual long QueryCb() pure;
    virtual BOOL Close() pure;
    virtual BOOL Commit() pure;

    virtual BOOL QueryTi16ForUDT(char* sz, BOOL fCase, OUT TI16* pti) pure;
    virtual BOOL SupportQueryTiForUDT() pure;

    // the new versions that truly take 32-bit types
    virtual BOOL fIs16bitTypePool() pure;
    virtual BOOL QueryTiForUDT(char* sz, BOOL fCase, OUT TI* pti) pure;
    virtual BOOL QueryTiForCVRecord(BYTE* pb, OUT TI* pti) pure;
    virtual BOOL QueryCVRecordForTi(TI ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi(TI ti, OUT BYTE** ppb) pure;
    virtual TI   QueryTiMin() pure;
    virtual TI   QueryTiMac() pure;
    virtual BOOL AreTypesEqual( TI ti1, TI ti2 ) pure;
    virtual BOOL IsTypeServed( TI ti ) pure;
};

PdbInterface GSI {
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BYTE* NextSym (BYTE* pbSym) pure;
    virtual BYTE* HashSym (const char* szName, BYTE* pbSym) pure;
    virtual BYTE* NearestSym (USHORT isect, long off, OUT long* pdisp) pure;      //currently only supported for publics
    virtual BOOL Close() pure;
    virtual BOOL getEnumThunk( USHORT isect, long off, OUT EnumThunk** ppenum ) pure;
};


PdbInterface NameMap {
    static PDBAPI(BOOL) open(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
    virtual BOOL close() pure;
    virtual BOOL reinitialize() pure;
    virtual BOOL getNi(const char* sz, OUT NI* pni) pure;
    virtual BOOL getName(NI ni, OUT const char** psz) pure;
    virtual BOOL getEnumNameMap(OUT Enum** ppenum) pure;
    virtual BOOL contains(const char* sz, OUT NI* pni) pure;
    virtual BOOL commit() pure;
    virtual BOOL isValidNi(NI ni) pure;
};

#define __ENUM_INCLUDED__
PdbInterface Enum {
    virtual void release() pure;
    virtual void reset() pure;
    virtual BOOL next() pure;
};

PdbInterface EnumNameMap : Enum {
    virtual void get(OUT const char** psz, OUT NI* pni) pure;
};

PdbInterface EnumContrib : Enum {
    virtual void get(OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual void getCrcs(OUT DWORD* pcrcData, OUT DWORD* pcrcReloc ) pure;
};

PdbInterface EnumThunk: Enum {
	virtual void get( OUT USHORT* pisect, OUT long* poff, OUT long* pcb ) pure;
};

//
// interface to use to widen type indices from 16 to 32 bits
// and store the results in a new location.
//
PdbInterface WidenTi {
public:
    static PDBAPI(BOOL)
    fCreate (
        WidenTi *&,
        unsigned cTypeInitialCache =256,
        BOOL fNB10Syms =wtiSymsNB09
        );

    virtual void
    release() pure;

    virtual BYTE /* TYPTYPE */ *
    pTypeWidenTi ( TI ti16, BYTE /* TYPTYPE */ * ) pure;

    virtual BYTE /* SYMTYPE */ *
    pSymWidenTi ( BYTE /* SYMTYPE */ * ) pure;

    virtual BOOL
    fTypeWidenTiNoCache ( BYTE * pbTypeDst, BYTE * pbTypeSrc, long & cbDst ) pure;

    virtual BOOL
    fSymWidenTiNoCache ( BYTE * pbSymDst, BYTE * pbSymSrc, long & cbDst ) pure;

    virtual BOOL
    fTypeNeedsWidening ( BYTE * pbType ) pure;

    virtual BOOL
    fSymNeedsWidening ( BYTE * pbSym ) pure;

    virtual BOOL
    freeRecord ( void * ) pure;

    // symbol block converters/query.  symbols start at doff from pbSymIn,
    // converted symbols will go at sci.pbSyms + doff, cbSyms are all including
    // doff.
    virtual BOOL
        fQuerySymConvertInfo (
        SymConvertInfo &    sciOut,
        BYTE *              pbSym,
        long                cbSym,
        int                 doff =0
        ) pure;

    virtual BOOL
    fConvertSymbolBlock (
        SymConvertInfo &    sciOut,
        BYTE *              pbSymIn,
        long                cbSymIn,
        int                 doff =0
        ) pure;
};

// interface for managing Dbg data
PdbInterface Dbg {
   // close Dbg Interface
   virtual BOOL Close() pure;
   // return number of elements (NOT bytes)
   virtual long QuerySize() pure;
   // reset enumeration index
   virtual void Reset() pure;
   // skip next celt elements (move enumeration index)
   virtual BOOL Skip(ULONG celt) pure;
   // query next celt elements into user-supplied buffer
   virtual BOOL QueryNext(ULONG celt, OUT void *rgelt) pure;
   // search for an element and fill in the entire struct given a field.
   // Only supported for the following debug types and fields:
   // DBG_FPO              'ulOffStart' field of FPO_DATA
   // DBG_FUNC             'StartingAddress' field of IMAGE_FUNCTION_ENTRY
   // DBG_OMAP             'rva' field of OMAP
   virtual BOOL Find(IN OUT void *pelt) pure;
   // remove debug data
   virtual BOOL Clear() pure;
   // append celt elements
   virtual BOOL Append(ULONG celt, const void *rgelt) pure;
   // replace next celt elements
   virtual BOOL ReplaceNext(ULONG celt, const void *rgelt) pure;
};

#endif  // __cplusplus

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

PDBAPI(BOOL)
PDBOpenValidate(
    /*const*/ char* szPDB,
    /*const*/ char* szPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx(
    /*const*/ char* szPDB,
    /*const*/ char* szPathOrig,
    /*const*/ char* szSearchPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpen(
    /*const*/ char* szPDB,
    /*const*/ char* szMode,
    SIG sigInitial,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

typedef BOOL (PDBCALL *PfnPDBOpen)(
    char*,
    char*,
    SIG,
    EC*,
    char [cbErrMax],
    PDB**);

PDBAPI(BOOL)
PDBOpenValidate2(
    /*const*/ char* szPDB,
    /*const*/ char* szPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx2(
    /*const*/ char* szPDB,
    /*const*/ char* szPathOrig,
    /*const*/ char* szSearchPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpenEx(
    /*const*/ char* szPDB,
    /*const*/ char* szMode,
    SIG sigInitial,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpenValidate3(
    const char *szExecutable,
    const char *szSearchPath,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI(BOOL)
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface()
{
    return PDBExportValidateInterface(PDBIntv);
}

typedef BOOL (PDBCALL *PfnPDBExportValidateInterface)(INTV);

__inline BOOL PDBValidateInterfacePfn(PfnPDBExportValidateInterface pfn)
{
    return (*pfn)(PDBIntv);
}

PDBAPI(EC)     PDBQueryLastError(PDB* ppdb, OUT char szError[cbErrMax]);
PDBAPI(INTV)   PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI(IMPV)   PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI(char*)  PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI(SIG)    PDBQuerySignature(PDB* ppdb);
PDBAPI(AGE)    PDBQueryAge(PDB* ppdb);
PDBAPI(BOOL)   PDBCreateDBI(PDB* ppdb, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenDBIEx(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn);
PDBAPI(BOOL)   PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenTpi(PDB* ppdb, const char* szMode, OUT TPI** pptpi);
PDBAPI(BOOL)   PDBCommit(PDB* ppdb);
PDBAPI(BOOL)   PDBClose(PDB* ppdb);
PDBAPI(BOOL)   PDBOpenStream(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
PDBAPI(BOOL)   PDBCopyTo(PDB* ppdb, const char* szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);

PDBAPI(INTV)   DBIQueryInterfaceVersion(DBI* pdbi);
PDBAPI(IMPV)   DBIQueryImplementationVersion(DBI* pdbi);
PDBAPI(BOOL)   DBIOpenMod(DBI* pdbi, const char* szModule, const char* szFile, OUT Mod** ppmod);
PDBAPI(BOOL)   DBIDeleteMod(DBI* pdbi, const char* szModule);
PDBAPI(BOOL)   DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI(BOOL)   DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIAddSec(DBI* pdbi, USHORT isect, USHORT flags, long off, long cb);
PDBAPI(BOOL)   DBIAddPublic(DBI* pdbi, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb);
PDBAPI(BOOL)   DBIQuerySecMap(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQueryFileInfo(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQuerySupportsEC(DBI* pdbi);
PDBAPI(void)   DBIDumpMods(DBI* pdbi);
PDBAPI(void)   DBIDumpSecContribs(DBI* pdbi);
PDBAPI(void)   DBIDumpSecMap(DBI* pdbi);
PDBAPI(BOOL)   DBIClose(DBI* pdbi);
PDBAPI(BOOL)   DBIAddThunkMap(DBI* pdbi, long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                              struct SO* psoSectMap, unsigned nSects, USHORT isectThunkTable, long offThunkTable);
PDBAPI(BOOL)   DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI(BOOL)   DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI(BOOL)   DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI(BOOL)   DBIQueryNextItsm(DBI* pdbi, ITSM itsm, OUT ITSM *inext );
PDBAPI(BOOL)   DBIQueryLazyTypes(DBI* pdbi);
PDBAPI(BOOL)   DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI(BOOL)   DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI(BOOL)   DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);
PDBAPI(BOOL)   DBIAddLinkInfo(DBI* pdbi, IN PLinkInfo);
PDBAPI(BOOL)   DBIQueryLinkInfo(DBI* pdbi, PLinkInfo, IN OUT long * pcb);

PDBAPI(INTV)   ModQueryInterfaceVersion(Mod* pmod);
PDBAPI(IMPV)   ModQueryImplementationVersion(Mod* pmod);
PDBAPI(BOOL)   ModAddTypes(Mod* pmod, BYTE* pbTypes, long cb);
#if CC_LAZYSYMS
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb, unsigned icon);
#else
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb);
#endif
PDBAPI(BOOL)   ModAddPublic(Mod* pmod, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   ModAddLines(Mod* pmod, const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                           USHORT lineStart, BYTE* pbCoff, long cbCoff);
PDBAPI(BOOL)   ModAddSecContrib(Mod * pmod, USHORT isect, long off, long cb, ULONG dwCharacteristics);
PDBAPI(BOOL)   ModQueryCBName(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySymbols(Mod* pmod, BYTE* pbSym, long* pcb);
PDBAPI(BOOL)   ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb);
PDBAPI(BOOL)   ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI(BOOL)   ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI(BOOL)   ModQuerySecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryImod(Mod* pmod, OUT USHORT* pimod);
PDBAPI(BOOL)   ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI(BOOL)   ModClose(Mod* pmod);
PDBAPI(BOOL)   ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySrcFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySupportsEC(Mod* pmod);
PDBAPI(BOOL)   ModQueryTpi(Mod* pmod, OUT TPI** pptpi);

PDBAPI(INTV)   TypesQueryInterfaceVersion(TPI* ptpi);
PDBAPI(IMPV)   TypesQueryImplementationVersion(TPI* ptpi);
// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)   TypesQueryTiForCVRecordEx(TPI* ptpi, BYTE* pb, OUT TI* pti);
PDBAPI(BOOL)   TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE* pb, IN OUT long* pcb);
PDBAPI(BOOL)   TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE** ppb);
PDBAPI(TI)     TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)     TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(long)   TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)   TypesClose(TPI* ptpi);
PDBAPI(BOOL)   TypesCommit(TPI* ptpi);
PDBAPI(BOOL)   TypesQueryTiForUDTEx(TPI* ptpi, char* sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)   TypesSupportQueryTiForUDT(TPI*);
PDBAPI(BOOL)   TypesfIs16bitTypePool(TPI*);
// Map all old ones to new ones for new compilands.
#define TypesQueryTiForCVRecord     TypesQueryTiForCVRecordEx
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx
#define TypesQueryTiForUDT          TypesQueryTiForUDTEx
PDBAPI(BOOL)    TypesAreTypesEqual( TPI* ptpi, TI ti1, TI ti2 );
PDBAPI(BOOL)    TypesIsTypeServed( TPI* ptpi, TI ti );

PDBAPI(BYTE*)  GSINextSym (GSI* pgsi, BYTE* pbSym);
PDBAPI(BYTE*)  GSIHashSym (GSI* pgsi, const char* szName, BYTE* pbSym);
PDBAPI(BYTE*)  GSINearestSym (GSI* pgsi, USHORT isect, long off,OUT long* pdisp);//currently only supported for publics
PDBAPI(BOOL)   GSIClose(GSI* pgsi);

PDBAPI(long)   StreamQueryCb(Stream* pstream);
PDBAPI(BOOL)   StreamRead(Stream* pstream, long off, void* pvBuf, long* pcbBuf);
PDBAPI(BOOL)   StreamWrite(Stream* pstream, long off, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamReplace(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamAppend(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamDelete(Stream* pstream);
PDBAPI(BOOL)   StreamTruncate(Stream* pstream, long cb);
PDBAPI(BOOL)   StreamRelease(Stream* pstream);

PDBAPI(BOOL)   StreamImageOpen(Stream* pstream, long cb, OUT StreamImage** ppsi);
PDBAPI(void*)  StreamImageBase(StreamImage* psi);
PDBAPI(long)   StreamImageSize(StreamImage* psi);
PDBAPI(BOOL)   StreamImageNoteRead(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageNoteWrite(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageWriteBack(StreamImage* psi);
PDBAPI(BOOL)   StreamImageRelease(StreamImage* psi);

PDBAPI(BOOL)   NameMapOpen(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
PDBAPI(BOOL)   NameMapClose(NameMap* pnm);
PDBAPI(BOOL)   NameMapReinitialize(NameMap* pnm);
PDBAPI(BOOL)   NameMapGetNi(NameMap* pnm, const char* sz, OUT NI* pni);
PDBAPI(BOOL)   NameMapGetName(NameMap* pnm, NI ni, OUT const char** psz);
PDBAPI(BOOL)   NameMapGetEnumNameMap(NameMap* pnm, OUT Enum** ppenum);
PDBAPI(BOOL)   NameMapCommit(NameMap* pnm);

PDBAPI(void)   EnumNameMapRelease(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapReset(EnumNameMap* penum);
PDBAPI(BOOL)   EnumNameMapNext(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapGet(EnumNameMap* penum, OUT const char** psz, OUT NI* pni);

PDBAPI(void)   EnumContribRelease(EnumContrib* penum);
PDBAPI(void)   EnumContribReset(EnumContrib* penum);
PDBAPI(BOOL)   EnumContribNext(EnumContrib* penum);
PDBAPI(void)   EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(void)   EnumContribGetCrcs(EnumContrib* penum, OUT DWORD* pcrcData, OUT DWORD* pcrcReloc);

PDBAPI(SIG)    SigForPbCb(BYTE* pb, long cb, SIG sig);
PDBAPI(void)   TruncStFromSz(char *stDst, const char *szSrc, unsigned cbSrc);

PDBAPI(BOOL)   DbgClose(Dbg *pdbg);
PDBAPI(long)   DbgQuerySize(Dbg *pdbg);
PDBAPI(void)   DbgReset(Dbg *pdbg);
PDBAPI(BOOL)   DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI(BOOL)   DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI(BOOL)   DbgFind(Dbg *pdbg, IN OUT void *pelt);
PDBAPI(BOOL)   DbgClear(Dbg *pdbg);
PDBAPI(BOOL)   DbgAppend(Dbg *pdbg, ULONG celt, const void *rgelt);
PDBAPI(BOOL)   DbgReplaceNext(Dbg *pdbg, ULONG celt, const void *rgelt);

#if __cplusplus
};
#endif

struct SO {
    long off;
    USHORT isect;
    unsigned short pad;
};

#ifndef cbNil
#define cbNil   ((long)-1)
#endif
#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((USHORT)(-1))

#define pdbWrite                "w"
#define pdbRead                 "r"
#define pdbGetTiOnly            "i"
#define pdbGetRecordsOnly       "c"
#define pdbFullBuild            "f"

#endif // __PDB_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\simparray.h ===
#pragma once
#include "crefobj.h"

template <class T>
class SimpleArray : public CRefCountedObj {
protected:
    unsigned    _cT;
    T *         _rgT;

public:
    SimpleArray ( unsigned cT ) {
        if ( cT ) {
            _rgT = new T[cT];
            if ( _rgT ) {
                _cT = cT;
                }
            }
        else {
            _cT = 0;
            _rgT = 0;
            }
        }

    ~SimpleArray() {
        if ( _rgT ) {
            delete [] _rgT;
            }
        _cT = 0;
        _rgT = 0;
        }

    unsigned Count() const {
        return _cT;
        }

    const T * Base() const {
        return _rgT;
        }

    T * Base() {
        return _rgT;
        }

    T & operator[] ( unsigned it ) {
        return _rgT[it];
        }

    const T & operator[] ( unsigned it ) const {
        return _rgT[it];
        }
    };

class SimpleString: public SimpleArray<char>
{
public:
    unsigned Length() const { return strlen( _rgT ); } // # non-nulls
    const char* operator=( const char *str ) {
        return Set( str, strlen( str ) );
    }
    bool operator==( SimpleString& str ) { return *this == str.Base(); }
    bool operator!=( SimpleString& str ) { return !(*this == str); }
    bool operator==( const char* str ) {
        return strcmp( str, Base() ) == 0; 
    }
    bool operator!=( const char* str ) { return !(*this == str); }
    void Clear() {
        assert( Count() > 0 );
        Set( "", 0 );
    }
    const char* Set( const char* str, unsigned len ) {
        Grow( len+1 );
        strncpy( _rgT, str, len );
        _rgT[ len ] = '\0';
        return Base();
    }
    SimpleString( const SimpleString& str ) 
        : SimpleArray<char>( str.Length()+1 ) {
        Set( str.Base(), str.Length()+1 );
    }
    SimpleString( unsigned len = 256 ) : SimpleArray<char>( max( len, 1 ) ) {
        Set( "", 0 );
    }
private:
    bool Grow( unsigned cb ) {
        if ( Count() < cb ) {
            delete [] _rgT;
            _rgT = new char[cb];
            _cT = cb;
        }
        return _rgT != 0;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\simpldis.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simpldis.h

Abstract:

    Generic C language interface to PUMA disassembler.

    This is designed to expose the functionality of the PUMA disassembler
    via a simple C language API.  It is not intended to be as flexible or
    as efficient as using the DIS class interface.  It is intended to provide
    "least common denominator" access to the disassembler for C code which
    does not have stringent performance demands.  A minimum set of types is
    exposed, and they are named so as to minimize the chance of collisions.

Author:

    KentF 16-Jan-1996

--*/


#ifndef _SIMPLDIS_H
#define _SIMPLDIS_H

#ifdef __cplusplus
extern "C" {
#endif

enum _SIMPLE_ARCHITECTURE {
    Simple_Arch_X86,
    Simple_Arch_Mips,
    Simple_Arch_AlphaAxp,
    Simple_Arch_PowerPc
};

//
// enumeration for x86 registers.
// all of the other platforms currently supported
// use an intuitively obvious register numbering
// scheme - e.g. r0..r31 represented as 0..31
//

enum _SIMPLE_REGX86
{
   SimpleRegEax	= 0,
   SimpleRegEcx	= 1,
   SimpleRegEdx	= 2,
   SimpleRegEbx	= 3,
   SimpleRegEsp	= 4,
   SimpleRegEbp	= 5,
   SimpleRegEsi	= 6,
   SimpleRegEdi	= 7,
};

#define SD_STRINGMAX 100

//
// disassembly return structure.  this contains
// all of the data returned from the disassembler.
// it contains no input data, and need not be
// initialized by the caller.
//

typedef struct _SIMPLEDIS {

    DWORD   dwEA0;              // First effective address
    size_t  cbEA0;              // data size
    DWORD   dwEA1;              // Second effective address
    size_t  cbEA1;              // data size
    DWORD   dwEA2;              // Third effective address
    size_t  cbEA2;              // data size
    DWORD   cbMemref;           // size of data at EA0
    DWORD   dwBranchTarget;     // branch target, if IsBranch or IsCall
    DWORD   dwJumpTable;        // jump table for indirect jumps
    DWORD   cbJumpEntry;        // size of each jump table entry
    BOOL    IsCall;
    BOOL    IsBranch;
    BOOL    IsTrap;

    char    szAddress[SD_STRINGMAX];
    char    szRaw[SD_STRINGMAX];
    char    szOpcode[SD_STRINGMAX];
    char    szOperands[SD_STRINGMAX];
    char    szComment[SD_STRINGMAX];
    char    szEA0[SD_STRINGMAX];
    char    szEA1[SD_STRINGMAX];
    char    szEA2[SD_STRINGMAX];

} SIMPLEDIS, *PSIMPLEDIS;



   // Pfncchaddr() is the callback function for symbol lookup.
   // If the address is non-zero, the callback function is called during
   // CchFormatInstr to query the symbol for the supplied address.  If there
   // is no symbol at this address, the callback should return 0.

typedef
size_t (WINAPI *PFNCCHADDR) (
    PVOID pv,
    DWORD addr,
    PCHAR symbol,
    size_t symsize,
    DWORD *displacement
    );


   // Pfncchfixup() is the callback function for symbol lookup.
   // If the address is non-zero, the callback function is called during
   // CchFormatInstr to query the symbol and displacement referenced by
   // operands of the current instruction.  The callback should examine the
   // contents of the memory identified by the supplied address and size and
   // return the name of any symbol targeted by a fixup on this memory and the
   // displacement from that symbol.  If there is no fixup on the specified
   // memory, the callback should return 0.

typedef
size_t (WINAPI *PFNCCHFIXUP) (
    PVOID pv,
    DWORD ipaddr,
    DWORD addr,
    size_t opsize,
    PCHAR symbol,
    size_t symsize,
    DWORD *displacement
    );


typedef
size_t (WINAPI *PFNCCHREGREL) (
    PVOID pv,
    DWORD ipaddr,
    int reg,
    DWORD offset,
    PCHAR symbol,
    size_t symsize,
    DWORD *displacement
    );


typedef
DWORDLONG (WINAPI *PFNQWGETREG) (
    PVOID pv,
    int reg
    );


int
WINAPI
SimplyDisassemble(
    PBYTE           pb,
    const size_t    cbMax,
    const DWORD     Address,
    const int       Architecture,
    PSIMPLEDIS      Sdis,
    PFNCCHADDR      pfnCchAddr,
    PFNCCHFIXUP     pfnCchFixup,
    PFNCCHREGREL    pfnCchRegrel,
    PFNQWGETREG     pfnQwGetreg,
    const PVOID     pv
    );

// Call this when you are done using the disassembler. 
// This frees up any memory allocated by the disassembler.

void 
WINAPI
CleanupDisassembler(
	VOID
	);

#ifdef __cplusplus
}
#endif

#endif // _SIMPLDIS_H

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\vcver.h ===
#ifndef _VC_VER_INC
#define _VC_VER_INC
#ifndef _VC_VER
#define _VC_VER 550
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\sqlpkapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	SQLPKAPI.H
//		SQL specific package interface declarations.

// IMPORTANT: this file is used by debugger components so:
// 1. Needs to be C-parsable ie no C++ luxuries (easier said than done I know)
// 2. Must not require MFC types or headers
// 3. Make sure you use the OLE macros in a C-compatible way (ditto)
// 4. If this changes, the debugger bits will need a rebuild

#ifndef __SQLPKAPI_H__
#define __SQLPKAPI_H__

interface ISqlExec;
interface ISrcDebug;

#ifdef __cplusplus
typedef ISqlExec* LPSQLEXEC;
typedef ISrcDebug* LPSRCDEBUG;
#endif

/////////////////////////////////////////////////////////////////////////////
// ISqlExec

#undef  INTERFACE
#define INTERFACE ISqlExec

enum LoadNotifyType {lntBeforeLoad, lntAfterLoad, lntTerminatingAndRestoringBPs, lntDebugSessionEnding, lntSQLThreadCreated,
			lntProgLoad, lntProgTerm, lntBadDriver};

typedef WORD SPCOOKIE;
typedef SPCOOKIE *PSPCOOKIE;

DECLARE_INTERFACE_(ISqlExec, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// ISqlExec methods

	STDMETHOD_(void, GoSql)(THIS) PURE;
	STDMETHOD_(void, StepIntoSql)(THIS) PURE;
	STDMETHOD_(void, StepOverSql)(THIS) PURE;
	STDMETHOD_(void, AddTmpBpSql)(THIS) PURE;
	STDMETHOD_(void, ToggleBPSql)(THIS) PURE;

	STDMETHOD_(BOOL, DebuggeeLoadNotify)(THIS_ enum LoadNotifyType lnt, LPVOID) PURE;
	STDMETHOD_(BOOL, GetSqlSPInfo)(THIS_ SPCOOKIE Cookie, char *ServerName, char *DBN, char *Name, WORD *cLine, WORD) PURE;
	STDMETHOD_(BOOL, GetSqlLocation)(THIS_ WORD *pline, PSPCOOKIE pCookie, WORD) PURE;

	STDMETHOD_(BOOL, FindSqlSymbol)(THIS_ PVOID pSymInfo, WORD nlvl ) PURE;
	STDMETHOD_(BOOL, SetSqlSymbol)(THIS_ PVOID pSymInfo, WORD nlvl ) PURE;
	STDMETHOD_(UINT, CountSqlLocals)(THIS_ WORD nlvl, BOOL ) PURE;
	STDMETHOD_(BOOL, GetSqlLocalName)(THIS_ char*, WORD, UINT, BOOL ) PURE;

	STDMETHOD_(void, StepToReturnSql)(THIS) PURE;
	STDMETHOD_(void, HackRefCount)(THIS_ int ) PURE;
	STDMETHOD_(void, KillSql)(THIS_ unsigned long, BOOL fAsync ) PURE;

	STDMETHOD_(void*,FindSqlDocument)(THIS_ char*, BOOL) PURE;
	STDMETHOD_(BOOL, GetSqlStack)(THIS_ WORD*, int, PSPCOOKIE, WORD*) PURE;
	STDMETHOD_(BOOL, SetSqlBreakpoint)(THIS_ BOOL, SPCOOKIE, WORD ) PURE;

	STDMETHOD_(BOOL, FindCookie)(THIS_ char* szSrvr, char* szDBN, char* szProc, SPCOOKIE *pCookie) PURE;

	STDMETHOD_(BOOL, ParseSqlPath)(THIS_ char* szPath, char *szServ, char *szDB, char *szSP, int) PURE;
	STDMETHOD_(BOOL, BuildSqlPath)(THIS_ char* szPath, char *szServ, char *szDB, char *szSP, int) PURE;
	STDMETHOD_(BOOL, GetCodeLines)(THIS_ SPCOOKIE, int*pSize, unsigned short** ppList) PURE;

	STDMETHOD_(BOOL, InProcSql)(THIS_ char* szPath) PURE;
    STDMETHOD(LoadDocument)(LPCTSTR szName) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// ISrcDebug

#undef  INTERFACE
#define INTERFACE ISrcDebug

DECLARE_INTERFACE_(ISrcDebug, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// ISrcDebug methods

	STDMETHOD_(BOOL, DebugSystemService)(THIS_ int i1, int i2, int i3, void *pv1, int i4, void *pv2) PURE;
	STDMETHOD_(void, UpdateBPViews)(THIS) PURE;
};


#endif	// __SQLPKAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\sqlguid.h ===
// Interface ID for SQL Execution control

DEFINE_GUID(IID_ISqlExec, 
0xfbca3ca2, 0x6abe, 0x11cf, 0x92, 0x81, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x10);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\ref.h ===
#pragma once

#if !defined(_ref_h)
#define _ref_h 1

#define refNil	0

template <class TARG>
class RefPtr {
  private:
	TARG *	_ptarg;

	// unuse pointer and free if last user
	void Release() {
		if (_ptarg != NULL && _ptarg->FUnUse()) {
			delete _ptarg;
			}

		// put garbage in pointer
		Debug(_ptarg = (TARG *) 0xdadadada);
		}

  public:
	// constructors
	RefPtr<TARG>() {
		_ptarg = NULL;
		}

	RefPtr<TARG>(TARG * ptargNew) {
		_ptarg = ptargNew;
		if (ptargNew != NULL) {
			ptargNew->Use();
			}
		}

	RefPtr<TARG>(const RefPtr<TARG> & rtarg) {
		_ptarg = rtarg._ptarg;
		if (rtarg._ptarg != NULL) {
			rtarg._ptarg->Use();
			}
		}

	// destructor
   ~RefPtr<TARG>() {
		Release();
		}

	// assignment functions (mirror the ctors)
	RefPtr<TARG>& operator=(TARG *ptargNew) {
		if (ptargNew != NULL) {
			ptargNew->Use();
			}

		Release();
		_ptarg = ptargNew;

		return *this;
		}

	RefPtr<TARG>& operator=(const RefPtr<TARG> &rtarg) {
		if (rtarg._ptarg != NULL) {
			rtarg._ptarg->Use();
			}

		Release();
		_ptarg = rtarg._ptarg;

		return *this;
		}

	bool  operator==(TARG *ptarg) const { return  _ptarg == ptarg; }
	bool  operator!=(TARG *ptarg) const { return  _ptarg != ptarg; }
	TARG &operator*()			  const { return *_ptarg;		   }
	TARG *operator->()			  const { return  _ptarg;		   }
		  operator TARG *() 	  const { return  _ptarg;		   }
	};

template <class TARG>
class COMRefPtr {
  private:
	TARG *	_ptarg;

	// unuse pointer and free if last user
	void Release() {
        if (_ptarg != NULL) {
            _ptarg->Release();
            }

		// put garbage in pointer
//		Debug(_ptarg = (TARG *) 0xdadadada);
		}

  public:
	// constructors
	COMRefPtr<TARG>() {
		_ptarg = NULL;
		}

	COMRefPtr<TARG>(TARG * ptargNew) {
		_ptarg = ptargNew;
		if (ptargNew != NULL) {
			ptargNew->AddRef();
			}
		}

	COMRefPtr<TARG>(const RefPtr<TARG> & rtarg) {
		_ptarg = rtarg._ptarg;
		if (rtarg._ptarg != NULL) {
			rtarg._ptarg->AddRef();
			}
		}

	// destructor
   ~COMRefPtr<TARG>() {
		Release();
		}

	// assignment functions (mirror the ctors)
	COMRefPtr<TARG>& operator=(TARG *ptargNew) {
		if (ptargNew != NULL) {
			ptargNew->AddRef();
			}

		Release();
		_ptarg = ptargNew;

		return *this;
		}

	COMRefPtr<TARG>& operator=(const RefPtr<TARG> &rtarg) {
		if (rtarg._ptarg != NULL) {
			rtarg._ptarg->AddRef();
			}

		Release();
		_ptarg = rtarg._ptarg;

		return *this;
		}

	bool  operator==(TARG *ptarg) const { return  _ptarg == ptarg; }
	bool  operator!=(TARG *ptarg) const { return  _ptarg != ptarg; }
	TARG &operator*()			  const { return *_ptarg;		   }
	TARG *operator->()			  const { return  _ptarg;		   }
		  operator TARG *() 	  const { return  _ptarg;		   }
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\vcexcept.h ===
// defined exceptions used by Visual C++
// [created apennell 6/24/97]
// must be kept in sync in both V6 and V7 langapi trees

#pragma once
#if !defined(_vcexcept_h)
#define _vcexcept_h

// the facility code we have chosen is based on the fact that we already
// use an exception of 'msc' when we throw C++ exceptions

#define FACILITY_VISUALCPP  ((LONG)0x6D)

#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)

/////////////////////////////////////////////////////////////////
// define all exceptions here, so we don't mess with each other
/////////////////////////////////////////////////////////////////

// used by CRTs for C++ exceptions, really defined in ehdata.h
//#define EH_EXCEPTION_NUMBER   VcppException( 3<<30, 0x7363 )      // SEV_ERROR, used by CRTs for C++

// used by debugger to do e.g. SetThreadName call
#define EXCEPTION_VISUALCPP_DEBUGGER    VcppException(1<<30, 5000)      // SEV_INFORMATIONAL

#endif	// _vcexcept_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\version.h ===
#include <xboxverp.h>

#define rmj 6
#define rmm 0
#define rup (6000+VER_PRODUCTBUILD)
#define szVerName ""
#define szVerUser "Xbox Team"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\vcbudefs.h ===
// VCBUDEFS.H - standard defs to be used for hungarian notation

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef VCBUDEFS_INCLUDED
#define VCBUDEFS_INCLUDED

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef ULONG	INTV;		// interface version number
typedef ULONG	IMPV;		// implementation version number
typedef ULONG	SIG;		// unique (across PDB instances) signature
typedef ULONG	AGE;		// no. of times this instance has been updated
typedef BYTE*	PB;			// pointer to some bytes
typedef long	CB;			// count of bytes
typedef char*	SZ;			// zero terminated string
typedef const char*	SZ_CONST;// const zero terminated string
typedef char*	PCH;		// char ptr
typedef USHORT	IFILE;		// file index
typedef USHORT	IMOD;		// module index
typedef USHORT	ISECT;		// section index
typedef USHORT	LINE;		// line number
typedef long	OFF;		// offset
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\ncb\bscext.h ===
// bscext.h
//	Extension for the bsc interface
#ifndef __BSCEXT_H__
#define __BSCEXT_H__

#include <bsc.h>

#if CC_MULTIPLE_STORES
#undef IINST_GLOBALS
#undef isTheGlobalIinst

#define IINST_GLOBALS   0x0FFF0001
#define isTheGlobalIinst(iinst)    (((iinst) & 0x0FFFFFFF) == IINST_GLOBALS)

// store type
enum STORE_TYP {
	ST_WIN32, ST_MFC, ST_CRT, ST_CXXRT, 
	// ST_USER must be the last one
	ST_USER
};
#else
#pragma message("Not Using Multiple Stores ...")
#endif	// CC_MULTIPLE_STORES

PdbInterface NcbNameMap;

// NCB language attributes:
#define NCB_LANGUAGE_ALL		0xff
#define NCB_LANGUAGE_CPP		0x01
#define NCB_LANGUAGE_JAVA		0x02
#define NCB_LANGUAGE_ODL		0x04
#define NCB_LANGUAGE_FORTRAN	0x08
#define NCB_LANGUAGE_HTML		0x10

PdbInterface BscEx : public Bsc
{
	virtual BOOL irefEndInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL idefEndInfo(IDEF idef, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL getGlobalsFrImod (IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual void setLanguage (BYTE bLanguage) pure;
	virtual void getLanguage (BYTE * pbLanguage) pure;
	virtual BOOL isModInLang (BYTE bLanguage, IMOD imod) pure;

	// IDL interfaces
	virtual BOOL getIDLAttrib (IINST iinst, OUT IINST **ppiiAttr, OUT ULONG *pciinst) pure;
	virtual BOOL getIDLAttribVal (IINST iiAttr, OUT SZ *pszValue) pure;
	virtual BOOL isIDLAttrib (IINST iinst, SZ szAttrib, OUT IINST *piiAttr, OUT SZ *pszValue) pure;
	virtual BOOL filterInTypeArray (IINST * piinst, ULONG ciinst, TYP type, 
									OUT IINST ** ppiinstOut, OUT ULONG * pciinstOut) pure;
	virtual BOOL filterOutTypeArray (IINST * piinst, ULONG ciinst, TYP type, 
									OUT IINST ** ppiinstOut, OUT ULONG * pciinstOut) pure;
	virtual BOOL getIDLMFCComment (IINST iinst, OUT IINST **ppiiComment, OUT ULONG * pciinst) pure;
	virtual BOOL getIDLMFCCommentClass (IINST iiComment, OUT SZ * pszClass) pure;
	virtual BOOL isIDLMFCComment (IINST iinst, SZ szType, OUT IINST * piiComment, OUT SZ * pszValue) pure;
	// back to general interface

	// get the line number for the declaration
	virtual BOOL ideclInfo(IINST iinst, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL getMapIinst (IINST iiClass, SZ szMapType, OUT IINST **ppIinst, OUT ULONG * pciinst) pure;
	virtual BOOL getAllArray (MBF mbf, OUT IINST ** ppiinst, OUT ULONG * pciinst) pure;
	virtual BOOL isLangInProject (BYTE bLanguage) pure;

#if CC_MULTIPLE_STORES
	// store specific API
	virtual BOOL isExistingStore(SZ szName, OUT STORE_TYP* pst, OUT USHORT* psi) pure;
	virtual SZ   szFrStoreTyp(STORE_TYP st) pure; 
	virtual BOOL getAllStoresArray(OUT NI** ppni, OUT USHORT* pcStores) pure;
#endif	// CC_MULTIPLE_STORES

	// get type with name inserted in proper position
	virtual SZ   getTypeWithName(IINST iinst, SZ szName) pure;

	// Support for searching global array of NIs
	virtual ULONG InitializeNIArrays(NcbNameMap *pncbnmpCurClass, NcbNameMap *pncbnmpCurFunc, BOOL fAddPrebuiltStore) pure;
	virtual void ReleaseNIArrays() pure;
	virtual	BOOL GetInfoOnIndexIntoNIArrays (ULONG uIndex, OUT SZ *psz, OUT TYP *ptyp, OUT ATR *patr, OUT IINST *piinst) pure;
	virtual BOOL GetBestMatch(const SZ szSoFar, long iLength, long *piIndex, SZ *pszUnambiguousMatch) pure;
	virtual BOOL GetEmptyNcbNameMap(BOOL fAllowDuplicates, OUT NcbNameMap ** ppncbnmp) pure;
	virtual BOOL GetClassMembersNameMap(IINST iinst, SZ szTemplateArgs, BOOL fAllowDuplicates, OUT NcbNameMap ** ppncbnmp) pure;
	virtual BOOL GetNameSpaceNameMap(SZ szNS, OUT NcbNameMap ** ppncbnmp) pure;
	
	// compare two IINST if they have the same signature
	virtual BOOL compareIinst (IINST iinst1, IINST iinst2, DWORD * pdwFlags) pure;
};

#endif __BSCEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\include\ssvc.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ssvc.h

Abstract:

    This header contains the enumeration of system services provided
    by OSDebug 4.

Author:

    Kent Forschmiedt (kentf) 09-Oct-1996

Environment:

    Win32, User Mode

--*/



typedef enum {
        ssvcNull = 0,
        ssvcDumpLocalHeap,
        ssvcDumpGlobalHeap,
        ssvcDumpModuleList,
        ssvcCrackLocalHmem,
        ssvcCrackGlobalHmem,
        ssvcKillApplication,
        ssvcFreeLibrary,
        ssvcInput,
        ssvcOutput,
        ssvcOleRpc,             // Enable/disable OLE Remote Procedure Call tracing
                                    // Pass cb = 1, rgb[0] = fEnable.  Before this is
                                    // called the first time, OLE RPC debugging is
                                    // disabled.  Also see mtrcOleRpc.
        ssvcHackFlipScreen,     // Hack for testing: toggle switching previous
                                    // foreground window back to foreground on F8/F10.
        ssvcNativeDebugger,     // Activate remote debugger
        ssvcSetETS,
        ssvcCvtRez2Seg,
        ssvcSqlDebug,
        ssvcFiberDebug,
} SSVC;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\undname\undname.h ===
#if !defined(_M_I86)
    //  The 32-bit compiler

    #define __far
    #define __near
    #define __pascal
    #define __loadds
#endif


typedef char *        pchar_t;
typedef const char *  pcchar_t;

typedef void * ( __cdecl * Alloc_t )( unsigned int );
typedef void   ( __cdecl * Free_t  )( void * );
typedef char * ( __cdecl * GetParameter_t  )( long );


#ifdef  __cplusplus
extern "C"
#endif


#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDName (
#else
pchar_t __cdecl unDName (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
                            unsigned short	// Feature disable flags
                        );

#ifdef  __cplusplus
extern "C"
#endif

#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDNameEx (
#else
pchar_t __cdecl unDNameEx (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
							GetParameter_t,	// Function to get any template parameters
                            unsigned long	// Feature disable flags
                        );
/*
 *  The user may provide a buffer into which the undecorated declaration
 *  is to be placed, in which case, the length field must be specified.
 *  The length is the maximum number of characters (including the terminating
 *  NULL character) which may be written into the user buffer.
 *
 *  If the output buffer is NULL, the length field is ignored, and the
 *  undecorator will allocate a buffer exactly large enough to hold the
 *  resulting declaration.  It is the users responsibility to deallocate
 *  this buffer.
 *
 *  The user may also supply the allocator and deallocator functions if
 *  they wish.  If they do, then all heap actions performed by the routine
 *  will use the provided heap functions.
 *
 *  If the allocator address is NULL, then the routine will default to using
 *  the standard allocator and deallocator functions, 'malloc' and 'free'.
 *
 *  If an error occurs internally, then the routine will return NULL.  If
 *  it was successful, it will return the buffer address provided by the
 *  user, or the address of the buffer allocated on their behalf, if they
 *  specified a NULL buffer address.
 *
 *  If a given name does not have a valid undecoration, the original name
 *  is returned in the output buffer.
 *
 *  Fine selection of a number of undecorator attributes is possible, by
 *  specifying flags (bit-fields) to disable the production of parts of the
 *  complete declaration.  The flags may be OR'ed together to select multiple
 *  disabling of selected fields.  The fields and flags are as follows :-
 */

#define UNDNAME_COMPLETE                (0x0000)    // Enable full undecoration

#define UNDNAME_NO_LEADING_UNDERSCORES  (0x0001)    // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS          (0x0002)    // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS     (0x0004)    // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL     (0x0008)    // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE  (0x0010)    // Disable expansion of the declaration language specifier
  #define   UNDNAME_NO_MS_THISTYPE          (0x0020)    /* NYI */   // Disable expansion of MS keywords on the 'this' type for primary declaration
  #define   UNDNAME_NO_CV_THISTYPE          (0x0040)    /* NYI */   // Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE             (0x0060)    // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS    (0x0080)    // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES     (0x0100)    // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE          (0x0200)    // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL     (0x0400)    // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE           (0x0800)    // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY               (0x1000)    // Crack only the name for primary declaration;
                                                    //  return just [scope::]name.  Does expand template params
#define UNDNAME_TYPE_ONLY               (0x2000)    // Input is just a type encoding; compose an abstract declarator
#define UNDNAME_HAVE_PARAMETERS         (0x4000)    // The real templates parameters are available
#define UNDNAME_NO_ECSU                 (0x8000)    // Suppress enum/class/struct/union
#define UNDNAME_NO_IDENT_CHAR_CHECK     (0x10000)   // Suppress check for IsValidIdentChar
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\DllMain.Cpp ===
// Resource only DLL stub
#include <windows.h>

BOOL WINAPI DllMain (HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\Makefile.inc ===
VSS=\\tkatgfsa01\vss\win32\ss.exe
EDBS=XboxDll.edb XboxDll_A.edb XboxDll_B.edb XboxDll_C.edb
VSS_EDB_DIR="$$/Xbox Localization/SW/VC6_addon/Jpn/EDB/"

Source\IDE\DevDbg.Pkg:  $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\pkgs\Dbg\obj\i386\DevDbg.Pkg
      Copy $? $(@D)

Source\IDE\DevBld.Pkg:  $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\pkgs\bld\src\obj\i386\Devbld.Pkg
      Copy $? $(@D)

Source\XslWz.Awx:       $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\wizards\Xslwiz\obj\i386\XslWz.Awx
      Copy $? $(@D)

Source\IDE\XbgWz.Awx:   $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\wizards\Xbgwiz\obj\i386\XbgWz.Awx
      Copy $? $(@D)

Source\DevShl.Dll:      $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\shell\obj\i386\Devshl.Dll
      Copy $? $(@D)

Source\IDE\DevXbox.Pkg: $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\pkgs\bld\add_ons\Xbox\obj\i386\DevXbox.Pkg
      Copy $? $(@D)

Source\ShXbox.Dll:      $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\debugger\shXbox\osdebug\obj\i386\shXbox.Dll
      Copy $? $(@D)

Source\IDE\MfcApWz.Dll: $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\wizards\appwiz\obj\i386\MfcApWz.Dll
      Copy $? $(@D)

Source\TlXbox.Dll:      $(_NTDRIVE)$(_NTROOT)\Private\VC6AddOn\IDE\debugger\tlxbox\obj\i386\tlxbox.dll
      Copy $? $(@D)

# LocStudio needs to be called once, ignoring the results, so it'll update the .Edb with the
# current path information. It's then called again to do the actual build.

$(EDBS):
      $(VSS) get $(VSS_EDB_DIR)$@ -W -I-

Target\XslWz.Awx:      Pre XboxDLL_C.Edb Source\XslWz.Awx
      Copy XboxDll_C.Edb Source
      -LocStudio\lscmd /U /G %cd%\Source\XboxDLL_C.Edb /S %cd%\Source /T %cd%\Target
      LocStudio\lscmd /U /G %cd%\Source\XboxDLL_C.Edb /S %cd%\Source /T %cd%\Target /O %cd%\Result\Result.Txt
      BinPlace -b Jpn Target\XslWz.Awx

Target\DevShl.Dll:     Pre XboxDLL_B.Edb Source\DevShl.Dll
      Copy XboxDll_B.Edb Source
      -LocStudio\lscmd /U /G %cd%\Source\XboxDLL_B.Edb /S %cd%\Source /T %cd%\Target
      LocStudio\lscmd /U /G %cd%\Source\XboxDLL_B.Edb /S %cd%\Source /T %cd%\Target /O %cd%\Result\Result.Txt
      BinPlace -b Jpn Target\DevShl.Dll

Target\IDE\DevDbg.Pkg Target\IDE\DevBld.Pkg: Pre XboxDLL_A.Edb Source\IDE\DevDbg.Pkg Source\IDE\DevBld.Pkg
      Copy XboxDll_A.Edb Source
      -LocStudio\lscmd /U /G %cd%\Source\XboxDLL_A.Edb /S %cd%\Source /T %cd%\Target
      LocStudio\lscmd /U /G %cd%\Source\XboxDLL_A.Edb /S %cd%\Source /T %cd%\Target /O %cd%\Result\Result.Txt
      BinPlace -b Jpn Target\IDE\DevDbg.Pkg
      BinPlace -b Jpn Target\IDE\DevBld.Pkg

#VCMunge\Jpn\MfcApWz\Bin\MfcApWz.Stb: VCMunge\Jpn\MfcApWz\DllMain.Cpp VCMunge\Jpn\MfcApWz\Res\Script1.Rc
#      cd VCMunge\Jpn\MfcApWz
#      -@md Release > nul 2>&1
#      cl.exe /nologo -I$(BASEDIR)\Public\WSDK\Inc /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" \
#             /Fp".\Release/MfcApwz.pch" /YX /Fo".\Release/" /c "dllmain.cpp"
#      rc.exe /l 0x411 -i$(BASEDIR)\Public\WSDK\Inc -i$(BASEDIR)\Public\WSDK\Inc\ATLMfc \
#             /fo".\Release/script1.res" /i "res" /d "NDEBUG" .\res\script1.rc
#      -@md ..\Bin
#      link.exe /nologo /libpath:$(BASEDIR)\Public\WSDK\Lib /subsystem:windows /dll /incremental:no \
#               /pdb:".\Release/MfcApwz.pdb" /out:"../bin/MfcApwz.stb" ".\Release\dllmain.obj" ".\Release\script1.res"
#      cd ..\..\..

Target\IDE\DevXbox.Pkg Target\IDE\XbgWz.Awx Target\ShXbox.Dll Target\MfcApWz.Dll Target\TlXbox.Dll: Pre \
                                           Source\IDE\DevXbox.Pkg Source\IDE\XbgWz.Awx Source\ShXbox.Dll \
                                           Source\IDE\MfcApWz.Dll Source\TlXbox.Dll XboxDLL.Edb \
                                           VCMunge\Jpn\MfcApWz\Bin\MfcApWz.Stb
      Copy XboxDll.Edb Source
      -LocStudio\lscmd /U /G %cd%\Source\XboxDLL.Edb /S %cd%\Source /T %cd%\Target
      LocStudio\lscmd /U /G %cd%\Source\XboxDLL.Edb /S %cd%\Source /T %cd%\Target /O %cd%\Result\Result.Txt
      Copy Target\IDE\MfcApWz.Dll Target\MfcApWz.Dll
      VCMunge\Tools\rescopy VCMunge\Jpn\Bin\MfcApwz.stb Target\MfcApwz.dll "TEMPLATE":all
      BinPlace -b Jpn Target\IDE\DevXbox.Pkg
      BinPlace -b Jpn Target\IDE\XbgWz.Awx
      BinPlace -b Jpn Target\ShXbox.Dll
      BinPlace -b Jpn Target\MfcApWz.Dll
      BinPlace -b Jpn Target\TlXbox.Dll

!if $(FREEBUILD)
DummyTarget: Target\XslWz.Awx Target\DevShl.Dll Target\IDE\DevDbg.Pkg Target\IDE\DevBld.Pkg Target\IDE\DevXbox.Pkg \
             Target\IDE\XbgWz.Awx Target\ShXbox.Dll Target\MfcApWz.Dll Target\TlXbox.Dll
      Touch DummyTarget
!else
DummyTarget:
!endif

Pre:
      -@md Source\IDE > nul 2>&1
      -@md Target\IDE > nul 2>&1
      -@md Result > nul 2>&1
      -@Del Result\Result.Txt
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\langapi\ncb\ncparse.h ===
#ifndef __NCPARSE_H__
#define __NCPARSE_H__

#include <pdb.h>
#include <vcbudefs.h>
#include <time.h>
#include "bscext.h"

// values of kinds:
#define NCB_KIND_BASECLASS		0x01
#define NCB_KIND_CONTAINMENT	0x02
#define NCB_KIND_IDL_ATTR		0x03
#define NCB_KIND_IDL_CLASSTYPE	0x04

// PROP definition/declaration.
// This information is hidden in last four bits of ATR
#define INST_NCB_ATR_DECL	0x1000
#define INST_NCB_ATR_DEFN	0x2000
#define INST_NCB_ATR_JAVA   0x4000
#define INST_NCB_ATR_FINAL	0x8000

// Overload some of the BSC attribute bits which aren't used for NCBs
#define INST_ATR_CONST	INST_ATR_NEAR

#define NCB_MOD_ATR_NODEP	0x01

#define NCBAttr(x)	((USHORT) (x & 0x0fff))

// Flags for masking while taking crc
#define NCB_MASK_LINENUMS	0x01

PdbInterface NcbParse
{
	// same as Bsc interface
	virtual BOOL close() pure; // close the ncbparse interface

// INTERFACE FOR MODULE LEVEL
	// primitives for getting module information
	
	// same as Bsc interface
	virtual BOOL getModuleByName(SZ sz, OUT IMOD *pimod) pure;
	// same as Bsc interface
	virtual BOOL getModuleContents(IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	// same as Bsc interface
	virtual void disposeArray(void *pAnyArray) pure;

	virtual BOOL openMod (SZ szMod, BOOL bCreate, OUT IMOD * pimod) pure;
	virtual BOOL closeMod (IMOD imod, BOOL bSave) pure;
	virtual BOOL clearModContent (IMOD imod) pure;
	virtual BOOL setModTime (IMOD imod, time_t tStamp) pure;
	virtual BOOL getModTime (IMOD imod, time_t *ptStamp) pure;
	virtual BOOL calculateCRC (IMOD imod, USHORT mask, SIG *pSig) pure;
	
	// set module attributes
	virtual BOOL setModAtr (IMOD imod, BYTE bAtr) pure;
	virtual BOOL getModAtr (IMOD imod, BYTE * pbAtr) pure;

	// check if module is member of a specific target
	virtual BOOL isModInTarget (HTARGET hTarget, IMOD imod) pure;
	virtual BOOL setModAsSrc (HTARGET hTarget, IMOD imod, BOOL bSource) pure;
	virtual BOOL isModTargetSource (HTARGET hTarget, IMOD imod) pure;
	// primitives for adding a target to a module
	virtual BOOL addModToTarget (HTARGET hTarget, IMOD imod, BOOL bProjSrc) pure;

	// primitives for adding an include file
	virtual BOOL addInclToMod (IMOD inclimod, HTARGET hTarget, IMOD imod) pure; 
	virtual BOOL isInclInMod (IMOD inclimod, HTARGET hTarget, IMOD imod) pure;
	// primitives for deleting an include file
	virtual BOOL delInclFrMod (IMOD inclimod, HTARGET hTarget, IMOD imod) pure;

	// primitives for deleting all include files
	virtual BOOL delAllInclFrMod (HTARGET hTarget, IMOD imod) pure;

	// primitives for deleting target from the database
	virtual BOOL delTarget (HTARGET hTarget) pure;

	// primitives for adding a target to the database
	virtual BOOL addTarget (HTARGET hTarget) pure;

	// primitives for deleting file from target
	virtual BOOL delModFrTarget (IMOD imod, HTARGET hTarget) pure;

	// primitives for setting all the include files:
	virtual BOOL getAllInclMod (HTARGET hTarget, IMOD imod, OUT IMOD ** ppimod, OUT ULONG * pcmod) pure;
	virtual BOOL getAllTarget (IMOD imod, OUT HTARGET ** ppTarget, OUT ULONG * pcTarget) pure;
	virtual BOOL getAllFlattenDeps (HTARGET hTarget, IMOD imod, OUT IMOD ** ppimod, OUT ULONG * pcmod, BOOL &bNotifyBuild) pure;
	// primitives for initializing target (ie: needs to do this
	// when target name change, first open a target)
	virtual BOOL mapTargetToSz (HTARGET hTarget, SZ szTarget) pure;
	virtual BOOL mapSzToTarget (SZ szTarget, HTARGET hTarget) pure;
	virtual BOOL imodInfo(IMOD imod, OUT SZ *pszModule) pure;
// INTERFACE FOR OBJECT LEVEL
	// primitives for adding an info
	// IINST is used for containment
	virtual BOOL addProp (SZ szName, TYP typ, ATR atr, IMOD imod, OUT IINST * pinst) pure;
	virtual BOOL setKind (IINST iinst, IINST iinstP, BYTE kind) pure;
	virtual BOOL setLine (IINST iinst, LINE lnStart) pure;
	virtual BOOL setDefn (IINST iinst) pure;
	virtual BOOL delProp (IINST iinst) pure;
	// For function, the 1st param is always return type followed by real params.
	// For variable, the 1st param is always type.
	virtual BOOL addParam (IINST iinst, SZ szName) pure;
	virtual BOOL iinstInfo(IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR *patr) pure ;
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IinstInfo **ppiinstinfo, OUT ULONG *pciinst) pure;
	virtual BOOL getGlobalsArray (MBF mbf, IMOD imod, OUT IinstInfo ** ppiinstinfo, OUT ULONG * pciinst) pure;
// Locking mechanism:
	virtual BOOL lock() pure;
	virtual BOOL unlock() pure;
	virtual BOOL notify() pure; // flush out notification queue!!
	virtual BOOL suspendNotify () pure;
	virtual BOOL resumeNotify() pure;
	virtual void graphBuilt() pure;
	virtual BOOL delUnreachable(HTARGET hTarget) pure;
	virtual BOOL isInit (HTARGET hTarget, IMOD imod) pure;
	virtual BOOL setInit (HTARGET hTarget, IMOD imod, BOOL bInit) pure;
	virtual BOOL notifyImod (OPERATION op, IMOD imod, HTARGET hTarget) pure;
	virtual BOOL notifyIinst (NiQ qItem, HTARGET hTarget, BYTE bLanguage) pure;
	virtual BOOL getBsc (HTARGET hTarget, SZ szTarget, Bsc ** ppBsc) pure;
	virtual BOOL delUninitTarget () pure;
    virtual BOOL imodFrSz (SZ szName, OUT IMOD *pimod) pure;
	virtual BOOL irefInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL targetFiles (HTARGET hTarget, BOOL bSrcProjOnly, OUT IMOD ** ppimod, OUT ULONG * pcimod) pure;
	virtual BOOL setAllInit (HTARGET hTarget, BOOL bInit) pure;
	virtual void setNotifyBuild (IMOD imod, BOOL bNotifyBuild) pure;
	virtual BOOL isNotifyBuild (IMOD imod) pure;
	virtual BOOL notifyArrIinst (NiQ * pArrQ, ULONG uSize, HTARGET hTarget, BYTE bLanguage) pure;

};

/*
PDBAPI (BOOL) OpenNcb (SZ szName, HTARGET hTarget, SZ szTarget, BOOL bWrite, Bsc ** ppBsc);
PDBAPI (BOOL) OpenNcb (PDB * ppdb, HTARGET hTarget, SZ szTarget, Bsc ** ppBsc);
PDBAPI (BOOL) OpenNcb (SZ szName, BOOL bWrite, NcbParse ** ppNcParse);
PDBAPI (BOOL) OpenNcb (PDB * ppdb, NcbParse **ppNcParse);
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\childfrm.Cpp ===
// $$child_frame_ifile$$.cpp : $$CHILD_FRAME_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$child_frame_hfile$$.h"
$$IF(PROJTYPE_EXPLORER)
#include "$$treeview_hfile$$.h"
#include "$$view_hfile$$.h"
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$CHILD_FRAME_CLASS$$

IMPLEMENT_DYNCREATE($$CHILD_FRAME_CLASS$$, $$CHILD_FRAME_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$CHILD_FRAME_CLASS$$, $$CHILD_FRAME_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$CHILD_FRAME_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
$$IF(NODOCVIEW)
		ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
		ON_WM_SETFOCUS()
		ON_WM_CREATE()
$$ENDIF
$$IF( REBAR )
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
		ON_WM_CREATE()
$$ENDIF // (ANY SERVER)
$$ENDIF // REBAR
	//}}AFX_MSG_MAP
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	ON_UPDATE_COMMAND_UI_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnUpdateViewStyles)
	ON_COMMAND_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnViewStyle)
$$ENDIF
$$ENDIF
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$CHILD_FRAME_CLASS$$ NX̍\z/

$$CHILD_FRAME_CLASS$$::$$CHILD_FRAME_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: oR[ḧʒuɒǉĂB
	
$$ENDIF
}

$$CHILD_FRAME_CLASS$$::~$$CHILD_FRAME_CLASS$$()
{
}
$$IF(SPLITTER_MDI || PROJTYPE_EXPLORER)

BOOL $$CHILD_FRAME_CLASS$$::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
$$IF(PROJTYPE_EXPLORER)
	// EBhE쐬܂
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
		return FALSE;

	if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS($$TREEVIEW_CLASS$$), CSize(100, 100), pContext) ||
		!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS($$VIEW_CLASS$$), CSize(100, 100), pContext))
	{
		m_wndSplitter.DestroyWindow();
		return FALSE;
	}

	return TRUE;
$$ELSE //!PROJTYPE_EXPLORER
	return m_wndSplitter.Create( this,
$$IF(VERBOSE)
		2, 2,                 // TODO: sƗ̐𒲐ĂB
		CSize( 10, 10 ),      // TODO: ŏ̋TCY𒲐ĂB
$$ELSE //!VERBOSE
		2, 2,
		CSize( 10, 10 ),
$$ENDIF //VERBOSE
		pContext );
$$ENDIF //PROJTYPE_EXPLORER
}
$$ENDIF //SPLITTER || EXPLORER

BOOL $$CHILD_FRAME_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
$$IF(VERBOSE)
	// TODO: ̈ʒu CREATESTRUCT cs ̐ݒsāAWindow NX܂
	//       X^CύXĂB

$$ENDIF //VERBOSE
	if( !$$CHILD_FRAME_BASE_CLASS$$::PreCreateWindow(cs) )
		return FALSE;

$$IF(CHILD_FRAME_STYLES)
	cs.style = WS_CHILD | WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
		| FWS_ADDTOTITLE$$CHILD_FRAME_STYLE_FLAGS$$;

$$ENDIF //CHILD_FRAME_STYLES
$$IF(NODOCVIEW)
	cs.dwExStyle &= ~WS_EX_CLIENTEDGE;
	cs.lpszClass = AfxRegisterWndClass(0);

$$ENDIF
	return TRUE;
}

$$IF(CHILD_FRAME_MAXIMIZED || CHILD_FRAME_MINIMIZED)
void $$CHILD_FRAME_CLASS$$::ActivateFrame(int nCmdShow)
{
$$IF(VERBOSE)
	// TODO: ̊֐Căt[ANeBuɂ@ύXĂB

$$ENDIF //VERBOSE
$$IF(CHILD_FRAME_MAXIMIZED)
	nCmdShow = SW_SHOWMAXIMIZED;
$$ENDIF //CHILD_FRAME_MAXIMIZED
$$IF(CHILD_FRAME_MINIMIZED)
	nCmdShow = SW_SHOWMINIMIZED;
$$ENDIF //CHILD_FRAME_MINIMIZED
	$$CHILD_FRAME_BASE_CLASS$$::ActivateFrame(nCmdShow);
}
$$ENDIF //CHILD_FRAME_MAXIMIZED || CHILD_FRAME_MINIMIZED


/////////////////////////////////////////////////////////////////////////////
// $$CHILD_FRAME_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$CHILD_FRAME_CLASS$$::AssertValid() const
{
	$$CHILD_FRAME_BASE_CLASS$$::AssertValid();
}

void $$CHILD_FRAME_CLASS$$::Dump(CDumpContext& dc) const
{
	$$CHILD_FRAME_BASE_CLASS$$::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$CHILD_FRAME_CLASS$$ NX̃bZ[Wnh
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
$$VIEW_CLASS$$* $$CHILD_FRAME_CLASS$$::GetRightPane()
{
	CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
	$$VIEW_CLASS$$* pView = DYNAMIC_DOWNCAST($$VIEW_CLASS$$, pWnd);
	return pView;
}

void $$CHILD_FRAME_CLASS$$::OnUpdateViewStyles(CCmdUI* pCmdUI)
{
$$IF(VERBOSE)
	// TODO: ̃R[hύX/gāA View j[̑I
	// 悤ɂĂB
$$ENDIF //VERBOSE

	$$VIEW_CLASS$$* pView = GetRightPane(); 

$$IF(VERBOSE)
	// ẼyC쐬Ȃr[ł͂ȂȂA
	// ͈̔͂ŃR}h𖳌ɂ܂
$$ENDIF //VERBOSE

	if (pView == NULL)
		pCmdUI->Enable(FALSE);
	else
	{
		DWORD dwStyle = pView->GetStyle() & LVS_TYPEMASK;

$$IF(VERBOSE)
		// R}h ID_VIEW_LINEUP Ȃ΁A LVS_ICON or LVS_SMALLICON 
		// [hɂȂꍇÃR}hLɂ܂

$$ENDIF //VERBOSE
		if (pCmdUI->m_nID == ID_VIEW_LINEUP)
		{
			if (dwStyle == LVS_ICON || dwStyle == LVS_SMALLICON)
				pCmdUI->Enable();
			else
				pCmdUI->Enable(FALSE);
		}
		else
		{
$$IF(VERBOSE)
			// łȂ΁Ahbggăr[̃X^C𔽉f܂
$$ENDIF //VERBOSE
			pCmdUI->Enable();
			BOOL bChecked = FALSE;

			switch (pCmdUI->m_nID)
			{
			case ID_VIEW_DETAILS:
				bChecked = (dwStyle == LVS_REPORT);
				break;

			case ID_VIEW_SMALLICON:
				bChecked = (dwStyle == LVS_SMALLICON);
				break;

			case ID_VIEW_LARGEICON:
				bChecked = (dwStyle == LVS_ICON);
				break;

			case ID_VIEW_LIST:
				bChecked = (dwStyle == LVS_LIST);
				break;

			default:
				bChecked = FALSE;
				break;
			}

			pCmdUI->SetRadio(bChecked ? 1 : 0);
		}
	}
}


void $$CHILD_FRAME_CLASS$$::OnViewStyle(UINT nCommandID)
{
$$IF(VERBOSE)
	// TODO: ̃R[hύX/gāA View j[̑I
	// 悤ɂĂB
$$ENDIF //VERBOSE
	$$VIEW_CLASS$$* pView = GetRightPane();

$$IF(VERBOSE)
	// ẼyC쐬 $$VIEW_CLASS$$ Ȃ A
	// j[ R}h܂
$$ENDIF //VERBOSE
	if (pView != NULL)
	{
		DWORD dwStyle = -1;

		switch (nCommandID)
		{
		case ID_VIEW_LINEUP:
			{
$$IF(VERBOSE)
				// Xg Rg[̃ACRObhʒuɍ킹܂
$$ENDIF //VERBOSE
				CListCtrl& refListCtrl = pView->GetListCtrl();
				refListCtrl.Arrange(LVA_SNAPTOGRID);
			}
			break;

$$IF(VERBOSE)
		// ̃R}h̓Xg Rg[̃X^CύX܂
$$ENDIF //VERBOSE
		case ID_VIEW_DETAILS:
			dwStyle = LVS_REPORT;
			break;

		case ID_VIEW_SMALLICON:
			dwStyle = LVS_SMALLICON;
			break;

		case ID_VIEW_LARGEICON:
			dwStyle = LVS_ICON;
			break;

		case ID_VIEW_LIST:
			dwStyle = LVS_LIST;
			break;
		}

$$IF(VERBOSE)
		//X^CύX; EBhE͎Iɍĕ`悵܂
$$ENDIF //VERBOSE
		if (dwStyle != -1)
			pView->ModifyStyle(LVS_TYPEMASK, dwStyle);
	}
}
$$ENDIF
$$ENDIF
$$IF(NODOCVIEW)
void $$CHILD_FRAME_CLASS$$::OnFileClose() 
{
$$IF(VERBOSE)
	// ̃t[ɂ́AWM_CLOSE 𑗂܂B̃bZ[ẂA
	// VXe j[ [] IꍇƓłB
$$ENDIF

	SendMessage(WM_CLOSE);
}

int $$CHILD_FRAME_CLASS$$::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// t[̃NCAg̈Ŝ߂r[쐬܂B
	if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW, 
		CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
	{
		TRACE0("Failed to create view window\n");
		return -1;
	}

	return 0;
}

void $$CHILD_FRAME_CLASS$$::OnSetFocus(CWnd* pOldWnd) 
{
	CMDIChildWnd::OnSetFocus(pOldWnd);

	m_wndView.SetFocus();
}

BOOL $$CHILD_FRAME_CLASS$$::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo) 
{
	// r[ɍŏɃR}h@^܂B
	if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;
	
	// Ȃꍇɂ̓ftHg̏s܂B
	return CMDIChildWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

$$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\childfrm.h ===
// $$child_frame_hfile$$.h : $$CHILD_FRAME_CLASS$$ NX̐錾уC^[tFCX̒`܂B
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

$$IF(PROJTYPE_EXPLORER)
class $$VIEW_CLASS$$;
$$ENDIF
$$IF(NODOCVIEW)
#include "$$wndview_hfile$$.h"
$$ENDIF

class $$CHILD_FRAME_CLASS$$ : public $$CHILD_FRAME_BASE_CLASS$$
{
	DECLARE_DYNCREATE($$CHILD_FRAME_CLASS$$)
public:
	$$CHILD_FRAME_CLASS$$();

// Agr[g
$$IF(SPLITTER_MDI || PROJTYPE_EXPLORER)
protected:
	CSplitterWnd m_wndSplitter;
$$ENDIF //SPLITTER_MDI || EXPLORER
public:

// Iy[V
public:

//I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$CHILD_FRAME_CLASS$$)
$$IF(SPLITTER_MDI || CHILD_FRAME_STYLES || PROJTYPE_EXPLORER || NODOCVIEW)
	public:
$$ENDIF
$$IF(SPLITTER_MDI || PROJTYPE_EXPLORER )
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
$$ENDIF //SPLITTER_MDI || PROJTYPE_EXPLORER
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
$$IF(CHILD_FRAME_MAXIMIZED || CHILD_FRAME_MINIMIZED)
	virtual void ActivateFrame(int nCmdShow);
$$ENDIF
$$IF(NODOCVIEW)
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
$$ENDIF
	//}}AFX_VIRTUAL

// Cve[V
public:
$$IF(NODOCVIEW)
	// t[̃NCAg̈p̃r[
	$$WNDVIEW_CLASS$$ m_wndView;
$$ENDIF
	virtual ~$$CHILD_FRAME_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
protected:
	$$VIEW_CLASS$$* GetRightPane();
$$ENDIF	// CListView
$$ENDIF // PROJTYPE_EXPLORER
// bZ[W }bv֐
protected:
$$IF( REBAR )
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	CToolBar m_wndToolBar;
$$ENDIF // (ANY SERVER)
$$ENDIF // REBAR
	//{{AFX_MSG($$CHILD_FRAME_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
$$IF(NODOCVIEW)
	afx_msg void OnFileClose();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
$$ENDIF
	//}}AFX_MSG
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	afx_msg void OnUpdateViewStyles(CCmdUI* pCmdUI);
	afx_msg void OnViewStyle(UINT nCommandID);
$$ENDIF
$$ENDIF
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\dlgproxy.Cpp ===
// $$dlgautoproxy_ifile$$.cpp : Cve[V t@C
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$dlgautoproxy_hfile$$.h"
#include "$$dlg_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$DLGAUTOPROXY_CLASS$$

IMPLEMENT_DYNCREATE($$DLGAUTOPROXY_CLASS$$, $$DLGAUTOPROXY_BASE_CLASS$$)

$$DLGAUTOPROXY_CLASS$$::$$DLGAUTOPROXY_CLASS$$()
{
	EnableAutomation();
	
	// I[g[V IuWFNgANeBułAAvP[V 
	// sԂɂĂARXgN^ AfxOleLockApp Ăяo܂B
	AfxOleLockApp();

$$IF(VERBOSE)
	// AvP[ṼC EBhE |C^ʂă_CAO
	// փANZX܂BvLV̓|C^_CAOւ̃|C
	// ^ݒ肵A_CAO̖߂|C^̃vLV֐ݒ肵
	// B
$$ENDIF //VERBOSE
	ASSERT (AfxGetApp()->m_pMainWnd != NULL);
	ASSERT_VALID (AfxGetApp()->m_pMainWnd);
	ASSERT_KINDOF($$DLG_CLASS$$, AfxGetApp()->m_pMainWnd);
	m_pDialog = ($$DLG_CLASS$$*) AfxGetApp()->m_pMainWnd;
	m_pDialog->m_pAutoProxy = this;
}

$$DLGAUTOPROXY_CLASS$$::~$$DLGAUTOPROXY_CLASS$$()
{
$$IF(VERBOSE)
	// ׂẴIuWFNgI[g[Vō쐬ꂽꍇɃAvP[V
	// I邽߂ɁAfXgN^ AfxOleUnlockApp Ăяo܂B
	// ̏̊ԂɁAC _CAOj󂵂܂B
$$ENDIF //VERBOSE
	if (m_pDialog != NULL)
		m_pDialog->m_pAutoProxy = NULL;
	AfxOleUnlockApp();
}

void $$DLGAUTOPROXY_CLASS$$::OnFinalRelease()
{
$$IF(VERBOSE)
	// I[g[V IuWFNgɑ΂Ō̎QƂ鎞
	// OnFinalRelease Ăяo܂B{NX͎IɃIuWFN
	// g폜܂B{NXĂяoOɁAIuWFNgŕKvȓ
	// ʂȌ㏈ǉĂB

$$ENDIF //VERBOSE
	$$DLGAUTOPROXY_BASE_CLASS$$::OnFinalRelease();
}

BEGIN_MESSAGE_MAP($$DLGAUTOPROXY_CLASS$$, $$DLGAUTOPROXY_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$DLGAUTOPROXY_CLASS$$)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP($$DLGAUTOPROXY_CLASS$$, $$DLGAUTOPROXY_BASE_CLASS$$)
	//{{AFX_DISPATCH_MAP($$DLGAUTOPROXY_CLASS$$)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// : VBA ^Cv Z[tȃoCfBOT|[g邽߂ IID_I$$Safe_root$$
//  ̃T|[gǉ܂B IID  .ODL t@C̃fBXpb` C^[tFCX 
//  փA^b` GUID ƍvȂ΂Ȃ܂B

// {$$DISPIID_CLSID_ODL$$}
static const IID IID_I$$Safe_root$$ =
$$DISPIID_CLSID$$;

BEGIN_INTERFACE_MAP($$DLGAUTOPROXY_CLASS$$, $$DLGAUTOPROXY_BASE_CLASS$$)
	INTERFACE_PART($$DLGAUTOPROXY_CLASS$$, IID_I$$Safe_root$$, Dispatch)
END_INTERFACE_MAP()

$$IF(VERBOSE)
// IMPLEMENT_OLECREATE2 }N͂̃vWFNg StdAfx.h ɒ`Ă܂B
$$ENDIF //VERBOSE
// {$$APP_CLSID_REG$$}
IMPLEMENT_OLECREATE2($$DLGAUTOPROXY_CLASS$$, "$$Safe_root$$.Application", $$APP_CLSID_MACRO$$)

/////////////////////////////////////////////////////////////////////////////
// $$DLGAUTOPROXY_CLASS$$ bZ[W nh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\cntritem.h ===
// $$cntritem_hfile$$.h : $$CNTRITEM_CLASS$$ NX̐錾уC^[tFCX̒`܂B
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$DOC_CLASS$$;
class $$VIEW_CLASS$$;

class $$CNTRITEM_CLASS$$ : public $$CNTRITEM_BASE_CLASS$$
{
	DECLARE_SERIAL($$CNTRITEM_CLASS$$)

// RXgN^
public:
$$IF(CRichEditView)
	$$CNTRITEM_CLASS$$(REOBJECT* preo = NULL, $$DOC_CLASS$$* pContainer = NULL);
$$ELSE
	$$CNTRITEM_CLASS$$($$DOC_CLASS$$* pContainer = NULL);
$$ENDIF //CRichEditView
$$IF(VERBOSE)
		// : pContainer  NULL ɂ IMPLEMENT_SERIALIZE sƂł܂B
		//  IMPLEMENT_SERIALIZE s߂ɂ̓NXɈ̂ȂRXgN^KvłB
		//  ʏAOLE ACe NULL łȂhLg |C^őgݍ܂Ă܂B
		//
$$ENDIF

// Agr[g
public:
	$$DOC_CLASS$$* GetDocument()
		{ return ($$DOC_CLASS$$*)$$CNTRITEM_BASE_CLASS$$::GetDocument(); }
	$$VIEW_CLASS$$* GetActiveView()
		{ return ($$VIEW_CLASS$$*)$$CNTRITEM_BASE_CLASS$$::GetActiveView(); }

	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$CNTRITEM_CLASS$$)
	public:
$$IF(!CRichEditView)
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
$$ENDIF //!CRichEditView
	protected:
$$IF(!CRichEditView)
$$IF(!ACTIVE_DOC_CONTAINER)
	virtual void OnGetItemPosition(CRect& rPosition);
$$ENDIF
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
$$IF(CONTAINER_SERVER)
	virtual BOOL CanActivate();
$$ENDIF
$$ENDIF //!CRichEditView
	//}}AFX_VIRTUAL

// Cve[V
public:
	~$$CNTRITEM_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
$$IF(!CRichEditView)
	virtual void Serialize(CArchive& ar);
$$ENDIF //!CRichEditView
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\dlgproxy.h ===
// $$dlgautoproxy_hfile$$.h : wb_[ t@C
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$DLG_CLASS$$;

/////////////////////////////////////////////////////////////////////////////
// $$DLGAUTOPROXY_CLASS$$ R}h ^[Qbg

class $$DLGAUTOPROXY_CLASS$$ : public $$DLGAUTOPROXY_BASE_CLASS$$
{
	DECLARE_DYNCREATE($$DLGAUTOPROXY_CLASS$$)

	$$DLGAUTOPROXY_CLASS$$();           // IŎgp protected RXgN^

// Agr[g
public:
	$$DLG_CLASS$$* m_pDialog;

// Iy[V
public:

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂
	//{{AFX_VIRTUAL($$DLGAUTOPROXY_CLASS$$)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Cve[V
protected:
	virtual ~$$DLGAUTOPROXY_CLASS$$();

	// ꂽbZ[W }bv֐
	//{{AFX_MSG($$DLGAUTOPROXY_CLASS$$)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE($$DLGAUTOPROXY_CLASS$$)

	// ꂽ OLE fBXpb` }bv֐
	//{{AFX_DISPATCH($$DLGAUTOPROXY_CLASS$$)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\dialog.h ===
// $$dlg_hfile$$.h : wb_[ t@C
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

$$IF(AUTOMATION)
class $$DLGAUTOPROXY_CLASS$$;

$$ENDIF //AUTOMATION
/////////////////////////////////////////////////////////////////////////////
// $$DLG_CLASS$$ _CAO

class $$DLG_CLASS$$ : public $$DLG_BASE_CLASS$$
{
$$IF(AUTOMATION)
	DECLARE_DYNAMIC($$DLG_CLASS$$);
	friend class $$DLGAUTOPROXY_CLASS$$;

$$ENDIF
// \z
public:
	$$DLG_CLASS$$(CWnd* pParent = NULL);	// W̃RXgN^
$$IF(AUTOMATION)
	virtual ~$$DLG_CLASS$$();
$$ENDIF

// _CAO f[^
	//{{AFX_DATA($$DLG_CLASS$$)
	enum { IDD = IDD_$$SAFE_ROOT$$_DIALOG };
		// : ̈ʒu ClassWizard ɂăf[^ oǉ܂B
	//}}AFX_DATA

	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$DLG_CLASS$$)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV ̃T|[g
	//}}AFX_VIRTUAL

// Cve[V
protected:
$$IF(AUTOMATION)
	$$DLGAUTOPROXY_CLASS$$* m_pAutoProxy;
$$ENDIF
	HICON m_hIcon;
$$IF(AUTOMATION)

	BOOL CanExit();
$$ENDIF //AUTOMATION

	// ꂽbZ[W }bv֐
	//{{AFX_MSG($$DLG_CLASS$$)
	virtual BOOL OnInitDialog();
$$IF(ABOUT)	
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
$$ENDIF
$$IF(HELP)
	afx_msg void OnDestroy();
$$ENDIF
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
$$IF(AUTOMATION)
	afx_msg void OnClose();
	virtual void OnOK();
	virtual void OnCancel();
$$ENDIF //AUTOMATION
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\cntritem.Cpp ===
// $$cntritem_ifile$$.cpp : $$CNTRITEM_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
#include "$$doc_hfile$$.h"
#include "$$view_hfile$$.h"
#include "$$cntritem_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$CNTRITEM_CLASS$$ Cve[V

IMPLEMENT_SERIAL($$CNTRITEM_CLASS$$, $$CNTRITEM_BASE_CLASS$$, 0)

$$IF(CRichEditView)
$$CNTRITEM_CLASS$$::$$CNTRITEM_CLASS$$(REOBJECT* preo, $$DOC_CLASS$$* pContainer)
	: $$CNTRITEM_BASE_CLASS$$(preo, pContainer)
$$ELSE //!CRichEditView
$$CNTRITEM_CLASS$$::$$CNTRITEM_CLASS$$($$DOC_CLASS$$* pContainer)
	: $$CNTRITEM_BASE_CLASS$$(pContainer)
$$ENDIF //CRichEditView
{
$$IF(VERBOSE)
	// TODO: ̏ꏊɍ\zp̃R[hǉĂB
	
$$ENDIF
}

$$CNTRITEM_CLASS$$::~$$CNTRITEM_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: ̏ꏊɌ㏈pR[hǉĂB
	
$$ENDIF
}
$$IF(!CRichEditView)

void $$CNTRITEM_CLASS$$::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	$$CNTRITEM_BASE_CLASS$$::OnChange(nCode, dwParam);
$$IF(VERBOSE)

	// ACeҏWĂ鎞ɂ (gݍݐł JĂĂ)
	// ACȅԂ܂͂̓ẻʕ\̕ύXɑ΂AOnChange
	// ʒm𑗂܂B

	// TODO: UpdateAllViews ĂяoăACe𖳌ɂĂB
	//  (AvP[VL̃qgY)

	GetDocument()->UpdateAllViews(NULL);
		// ׂẴr[qgȂŃAbvf[g܂B
$$ENDIF
}

BOOL $$CNTRITEM_CLASS$$::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);
$$IF(VERBOSE)

	// gݍݐ悪LȊԂ $$CNTRITEM_CLASS$$::OnChangeItemPosition ͑gݍݐ
	// EBhËʒuύX邽߂ɃT[o[ɂČĂяo܂BʏA
	// T[o[ hLg̃f[^ύXƂɂĔ͈͂ςAgݍ
	// ̃TCYύXƂ̌ʂłB
	//
	// ACeVʒuɈړ邽߂Ɋ{
	// NX $$CNTRITEM_BASE_CLASS$$::SetItemRects Ăяo܂B
	//
	//
$$ENDIF

	if (!$$CNTRITEM_BASE_CLASS$$::OnChangeItemPosition(rectPos))
		return FALSE;

$$IF(VERBOSE)
	// TODO: ACe̋`/͈͂̃LbVXVĂB

$$ENDIF
	return TRUE;
}

$$IF(!ACTIVE_DOC_CONTAINER)
void $$CNTRITEM_CLASS$$::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);
$$IF(VERBOSE)

	// gݍݐ悪NĂԁA$$CNTRITEM_CLASS$$::OnGetItemPosition ̓ACe
	// ʒu肷邽߂ɌĂ΂܂BAppWizard ō쐬ꂽftHg̃R[h͒P
	// Ƀn[hR[fBOꂽ`Ԃ܂B
	// ʏA̋`͎gĂr[Ɋ֘AACě݂̈ʒu𔽉f܂B
	// $$CNTRITEM_CLASS$$::GetActiveView ĂяoƂɂăr[𓾂邱Ƃł
	// ܂B

	// TODO: rPosition ɂ̓sNZPʂŐ`ԂĂB
$$ENDIF

	rPosition.SetRect(10, 10, 210, 210);
}
$$ENDIF

void $$CNTRITEM_CLASS$$::OnActivate()
{
$$IF(!ACTIVE_DOC_CONTAINER)
    // t[ƂɈACẽrWAҏW\ɂ܂B
    $$VIEW_CLASS$$* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    $$CNTRITEM_BASE_CLASS$$::OnActivate();
$$ENDIF
}

void $$CNTRITEM_CLASS$$::OnDeactivateUI(BOOL bUndoable)
{
	$$CNTRITEM_BASE_CLASS$$::OnDeactivateUI(bUndoable);

    // IuWFNgAEgTCh C IuWFNgł͂Ȃꍇ͔\ɂ܂B
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void $$CNTRITEM_CLASS$$::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

$$IF(VERBOSE)
	// ŏ̊{NX̌Ăяo $$CNTRITEM_BASE_CLASS$$
	// f[^֓ǂݍ܂܂B$$CNTRITEM_CLASS$$::GetDocument
	// Ԃꂽ m_pDocument |C^ݒ肵Ă{N
	// XĂяočŏ̃VACYsĂB
$$ENDIF
	$$CNTRITEM_BASE_CLASS$$::Serialize(ar);

$$IF(VERBOSE)
	// $$CNTRITEM_CLASS$$ ɑ΂ăf[^̕ۑ/ǂݍ݂s܂B
$$ENDIF
	if (ar.IsStoring())
	{
$$IF(VERBOSE)
		// TODO: ̏ꏊɕۑp̃R[hǉ܂B
$$ENDIF
	}
	else
	{
$$IF(VERBOSE)
		// TODO: ̏ꏊɓǂݍݗp̃R[hǉ܂B
$$ENDIF
	}
}
$$IF(CONTAINER_SERVER)

BOOL $$CNTRITEM_CLASS$$::CanActivate()
{
$$IF(VERBOSE)
	// T[o[ŕҏWĂƂɂ͑gݍݐł̕ҏW
	// T|[gĂ܂B ̏ꍇ͑gݍݐ̋N  
	// 𖳌ɂĂB
$$ENDIF
	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(COleServerDoc)));
	if (pDoc->IsInPlaceActive())
		return FALSE;

$$IF(VERBOSE)
	// ̑̓ftHg̏ɔC܂B
$$ENDIF
	return COleClientItem::CanActivate();
}
$$ENDIF
$$ENDIF //!CRichEditView

/////////////////////////////////////////////////////////////////////////////
// $$CNTRITEM_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$CNTRITEM_CLASS$$::AssertValid() const
{
	$$CNTRITEM_BASE_CLASS$$::AssertValid();
}

void $$CNTRITEM_CLASS$$::Dump(CDumpContext& dc) const
{
	$$CNTRITEM_BASE_CLASS$$::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\dlgroot.Cpp ===
// $$root$$.cpp : AvP[VpNX̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$dlg_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$

BEGIN_MESSAGE_MAP($$APP_CLASS$$, $$APP_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$APP_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ NX̍\z

$$APP_CLASS$$::$$APP_CLASS$$()
{
$$IF(VERBOSE)	
	// TODO: ̈ʒuɍ\zp̃R[hǉĂB
	//  InitInstance ̏dvȏׂċLqĂB
$$ENDIF
}

/////////////////////////////////////////////////////////////////////////////
// B $$APP_CLASS$$ IuWFNg

$$APP_CLASS$$ theApp;

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ NX̏

BOOL $$APP_CLASS$$::InitInstance()
{
$$IF(SOCKETS)
	if (!AfxSocketInit())
	{
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //SOCKETS
$$IF(AUTOMATION)
	// OLE Cȕ
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //AUTOMATION
$$IF(OLECTL)
	AfxEnableControlContainer();

$$ENDIF //OLECTL
	// WIȏ
$$IF(VERBOSE)
	// ̋@\gpAst@C̃TCY
	//  Έȉ̓̏[`̒sKvȂ̂폜
	//  B
$$ENDIF

$$IF(3D)
#ifdef _AFXDLL
	Enable3dControls();			// L DLL  MFC gꍇ͂R[ĂB
#else
	Enable3dControlsStatic();	// MFC ƐÓIɃNꍇ͂R[ĂB
#endif

$$ENDIF //3D
$$IF(AUTOMATION)
$$IF(VERBOSE)
	// OLE T[o[ƂċNĂ鎞ɂ̓R}hC͂܂B
$$ENDIF
	if (RunEmbedded() || RunAutomated())
	{
$$IF(VERBOSE)
		// sƂׂĂ OLE T[o[ t@Ng o^܂B
		//  ̃AvP[VIuWFNg邽߂ OLE Cugp\ɂ܂B
$$ENDIF
		COleTemplateServer::RegisterAll();
	}
	else
	{
$$IF(VERBOSE)
		// VXe WXgĂăT[o[ AvP[VX^h A
		// Nꂽɂ́AVXe WXgXVĂB
$$ENDIF
		COleObjectFactory::UpdateRegistryAll();
	}

$$ENDIF //AUTOMATION
	$$DLG_CLASS$$ dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
$$IF(VERBOSE)
		// TODO: _CAO <OK> ŏꂽ̃R[h
		//       LqĂB
$$ENDIF
	}
	else if (nResponse == IDCANCEL)
	{
$$IF(VERBOSE)
		// TODO: _CAO <ݾ> ŏꂽ̃R[h
		//       LqĂB
$$ENDIF
	}

	// _CAOĂAvP[ṼbZ[W |vJńA
	// AvP[VI邽߂ FALSE ԂĂB
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\dialog.Cpp ===
// $$dlg_ifile$$.cpp : Cve[V t@C
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$dlg_hfile$$.h"
$$IF(AUTOMATION)
#include "$$dlgautoproxy_hfile$$.h"
$$ENDIF //AUTOMATION

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

$$IF(ABOUT)
/////////////////////////////////////////////////////////////////////////////
// AvP[Ṽo[WŎgĂ CAboutDlg _CAO

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// _CAO f[^
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard ͉z֐̃I[o[Ch𐶐܂
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV ̃T|[g
	//}}AFX_VIRTUAL

// Cve[V
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// bZ[W nh܂B
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

$$ENDIF //ABOUT
/////////////////////////////////////////////////////////////////////////////
// $$DLG_CLASS$$ _CAO
$$IF(AUTOMATION)

IMPLEMENT_DYNAMIC($$DLG_CLASS$$, $$DLG_BASE_CLASS$$);
$$ENDIF //AUTOMATION

$$DLG_CLASS$$::$$DLG_CLASS$$(CWnd* pParent /*=NULL*/)
	: $$DLG_BASE_CLASS$$($$DLG_CLASS$$::IDD, pParent)
{
	//{{AFX_DATA_INIT($$DLG_CLASS$$)
		// : ̈ʒu ClassWizard ɂăȍǉ܂B
	//}}AFX_DATA_INIT
$$IF(VERBOSE)
	// : LoadIcon  Win32  DestroyIcon ̃TuV[PXv܂B
$$ENDIF
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
$$IF(AUTOMATION)
	m_pAutoProxy = NULL;
$$ENDIF //AUTOMATION
}
$$IF(AUTOMATION)

$$DLG_CLASS$$::~$$DLG_CLASS$$()
{
$$IF(VERBOSE)
	// ̃_CAOp̃I[g[V vLVꍇ́Ã_CAO
	// ւ̃|C^ NULL ɖ߂܂Aɂă_CAO폜ꂽ
	// 킩܂B
$$ENDIF //VERBOSE
	if (m_pAutoProxy != NULL)
		m_pAutoProxy->m_pDialog = NULL;
}
$$ENDIF //AUTOMATION

void $$DLG_CLASS$$::DoDataExchange(CDataExchange* pDX)
{
	$$DLG_BASE_CLASS$$::DoDataExchange(pDX);
	//{{AFX_DATA_MAP($$DLG_CLASS$$)
		// : ̏ꏊɂ ClassWizard ɂ DDX  DDV ̌Ăяoǉ܂B
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP($$DLG_CLASS$$, $$DLG_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$DLG_CLASS$$)
$$IF(ABOUT)
	ON_WM_SYSCOMMAND()
$$ENDIF
$$IF(HELP)
	ON_WM_DESTROY()
$$ENDIF
$$IF(AUTOMATION)
	ON_WM_CLOSE()
$$ENDIF
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$DLG_CLASS$$ bZ[W nh

BOOL $$DLG_CLASS$$::OnInitDialog()
{
	$$DLG_BASE_CLASS$$::OnInitDialog();
$$IF(ABOUT)

	// "o[W..." j[ڂVXe j[֒ǉ܂B

	// IDM_ABOUTBOX ̓R}h j[͈̔͂łȂ΂Ȃ܂B
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}
$$ENDIF //ABOUT

$$IF(VERBOSE)
	// ̃_CAOp̃ACRݒ肵܂Bt[[N̓AvP[ṼC
	// EBhE_CAOłȂ͎Iɐݒ肵܂B
$$ENDIF //VERBOSE
	SetIcon(m_hIcon, TRUE);			// 傫ACRݒ
	SetIcon(m_hIcon, FALSE);		// ACRݒ
	
	// TODO: ʂȏs͂̏ꏊɒǉĂB
	
	return TRUE;  // TRUE ԂƃRg[ɐݒ肵tH[JX͎܂B
}
$$IF(ABOUT)

void $$DLG_CLASS$$::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		$$DLG_BASE_CLASS$$::OnSysCommand(nID, lParam);
	}
}
$$ENDIF //ABOUT
$$IF(HELP)

void $$DLG_CLASS$$::OnDestroy()
{
	WinHelp(0L, HELP_QUIT);
	$$DLG_BASE_CLASS$$::OnDestroy();
}
$$ENDIF //HELP

// _CAO{bNXɍŏ{^ǉȂ΁AACR`悷
// R[hȉɋLqKv܂BMFC AvP[V document/view
// fgĂ̂ŁȀ̓t[[Nɂ莩Iɏ܂B

void $$DLG_CLASS$$::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // `p̃foCX ReLXg

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// NCAg̋`̈̒
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// ACR`悵܂B
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		$$DLG_BASE_CLASS$$::OnPaint();
	}
}

$$IF(VERBOSE)
// VXéA[U[ŏEBhEhbOĂԁA
// J[\\邽߂ɂĂяo܂B
$$ENDIF
HCURSOR $$DLG_CLASS$$::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
$$IF(AUTOMATION)
$$IF(VERBOSE)

// Rg[IuWFNg 1 ܂ێĂꍇA
// I[g[VT[o[̓[U[ UI ۂɏI
// ܂B̃bZ[W nh̓vLV܂gp
// ǂmFAꂩ UI \ɂȂ܂_CA
// O͂ꂪꂽꍇ̏ꏊɎc܂B
$$ENDIF //VERBOSE

void $$DLG_CLASS$$::OnClose() 
{
	if (CanExit())
		$$DLG_BASE_CLASS$$::OnClose();
}

void $$DLG_CLASS$$::OnOK() 
{
	if (CanExit())
		$$DLG_BASE_CLASS$$::OnOK();
}

void $$DLG_CLASS$$::OnCancel() 
{
	if (CanExit())
		$$DLG_BASE_CLASS$$::OnCancel();
}

BOOL $$DLG_CLASS$$::CanExit()
{
$$IF(VERBOSE)
	// vLV IuWFNg܂cĂꍇAI[g[V	
	// Rg[͂̃AvP[V܂ێĂ܂B 
	// _CAO͎̎͂c܂ UI ͔\ɂȂ܂B
$$ENDIF //VERBOSE
	if (m_pAutoProxy != NULL)
	{
		ShowWindow(SW_HIDE);
		return FALSE;
	}

	return TRUE;
}
$$ENDIF //AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\dlgres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by $$ROOT$$.RC
//
$$IF(PROJTYPE_DLG)
#define IDR_MAINFRAME					128
$$IF(ABOUT)
#define IDM_ABOUTBOX					0x0010
#define IDD_ABOUTBOX					100
$$ENDIF //ABOUT
$$IF(AUTOMATION)
#define IDP_OLE_INIT_FAILED				100
$$ENDIF //AUTOMATION
$$IF(ABOUT)
#define IDS_ABOUTBOX					101
$$ENDIF //ABOUT	
#define IDD_$$SAFE_ROOT$$_DIALOG				102
$$ENDIF //PROJTYPE_DLG
$$IF(SOCKETS)
$$IF(PROJTYPE_DLG)
#define IDP_SOCKETS_INIT_FAILED			103
$$ELSE //!PROJTYPE_DLG (i.e., PROJTYPE_DLL)
#define IDP_SOCKETS_INIT_FAILED			101
$$ENDIF //PROJTYPE_DLG
$$ENDIF //SOCKETS

// ̃ftHgl͐VKIuWFNgp̒lł
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

$$IF(PROJTYPE_DLL || PROJTYPE_OCX)
#define _APS_NEXT_RESOURCE_VALUE	$$START_RES$$
#define _APS_NEXT_CONTROL_VALUE		$$START_RES$$
#define _APS_NEXT_SYMED_VALUE		$$START_RES$$
$$ELSE
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
$$ENDIF
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\DllRoot.Cpp ===
// $$root$$.cpp : DLL p̏̒`s܂B
//

#include "stdafx.h"
$$IF(EXTDLL)
#include <afxdllx.h>
$$ELSE // !EXTDLL
#include "$$root$$.h"
$$ENDIF //!EXTDLL

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

$$IF(EXTDLL)
$$ELSE
//
//	!
//
//		 DLL  MFC DLL ɑ΂ēIɃNꍇA
//		MFC ŌĂяo邱 DLL GNX|[gꂽ
//		ǂ̊֐֐̍ŏɒǉ AFX_MANAGE_STATE 
//		}N܂łȂ΂Ȃ܂B
//
//		:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// ʏ֐̖{̂͂̈ʒuɂ܂
//		}
//
//		̃}Ne֐Ɋ܂܂Ă邱ƁAMFC 
//		ǂ̌ĂяoD悷邱Ƃ͔ɏdvłB
//		͊֐̍ŏ̃Xe[ggłȂ΂
//		ȂƂӖ܂ARXgN^ MFC 
//		DLL ւ̌Ăяos\̂ŁAIu
//		WFNgϐ̐錾OłȂ΂Ȃ܂B
//
//		ڍׂɂĂ MFC eNjJ m[g 33 
//		58 QƂĂB
//
$$ENDIF

$$IF(EXTDLL)
static AFX_EXTENSION_MODULE $$safe_root$$DLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
$$IF(VERBOSE)
	// lpReserved gꍇ͂폜Ă
$$ENDIF
	UNREFERENCED_PARAMETER(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("$$ROOT$$.DLL Initializing!\n");
		
$$IF(VERBOSE)
		// g DLL P񂾂܂B
$$ENDIF
		if (!AfxInitExtensionModule($$safe_root$$DLL, hInstance))
			return 0;

$$IF(VERBOSE)
		//  DLL \[X `FC֑}܂B
		// : g DLL  MFC AvP[Vł͂Ȃ
		//   MFC W DLL (ActiveX Rg[̂悤)
		//   ɈÖٓIɃNꍇA̍s DllMain
		//   폜āÅg DLL GNX|[g
		//   ꂽʂ̊֐֒ǉĂB  
		//   ̊g DLL gpW DLL ͂̊g DLL
		//   邽߂ɖIɂ̊֐Ăяo܂B 
		//   ȊȌꍇ́ACDynLinkLibrary IuWFNg
		//   W DLL ̃\[X `FCփA^b`ꂸA
		//   ̌ʏdȖƂȂ܂B

$$ENDIF
		new CDynLinkLibrary($$safe_root$$DLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("$$ROOT$$.DLL Terminating!\n");
$$IF(VERBOSE)
		// fXgN^ĂяoOɃCuI܂
$$ENDIF
		AfxTermExtensionModule($$safe_root$$DLL);
	}
$$IF(VERBOSE)
	return 1;   // ok
$$ELSE
	return 1;
$$ENDIF
}
$$ELSE //!EXTDLL
/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$

BEGIN_MESSAGE_MAP($$APP_CLASS$$, $$APP_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$APP_CLASS$$)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ ̍\z

$$APP_CLASS$$::$$APP_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: ̈ʒuɍ\zp̃R[hǉĂB
	//  InitInstance ̒̏dvȏׂċLqĂB
$$ENDIF
}

/////////////////////////////////////////////////////////////////////////////
// B $$APP_CLASS$$ IuWFNg

$$APP_CLASS$$ theApp;
$$IF(AUTOMATION || SOCKETS)

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ ̏

BOOL $$APP_CLASS$$::InitInstance()
{
$$IF(SOCKETS)
	if (!AfxSocketInit())
	{
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //SOCKETS
$$IF(AUTOMATION)
	// sƂׂĂ OLE T[o[ t@Ng o^܂B
	// ̃AvP[VIuWFNg邽߂ OLE Cugp\ɂ܂B
	COleObjectFactory::RegisterAll();

$$ENDIF //AUTOMATION
	return TRUE;
}
$$ENDIF //AUTOMATION || SOCKETS
$$IF(AUTOMATION)

/////////////////////////////////////////////////////////////////////////////
// vV[W̃T[o[ŕKvȓʂȃGg |Cg

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return AfxDllCanUnloadNow();
}

// DllRegisterServer ̃GNX|[gɂ regsvr.exe gpł܂
STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	COleObjectFactory::UpdateRegistryAll();
	return S_OK;
}
$$ENDIF //AUTOMATION
$$ENDIF //EXTDLL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\DllRoot.h ===
// $$root$$.h : $$ROOT$$ AvP[ṼC wb_[ t@CłB
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// C V{

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$
// ̃NX̓̒`ɊւĂ $$root$$.cpp t@CQƂĂB
//

class $$APP_CLASS$$ : public $$APP_BASE_CLASS$$
{
public:
	$$APP_CLASS$$();

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$APP_CLASS$$)
$$IF(SOCKETS || AUTOMATION)
	public:
	virtual BOOL InitInstance();
$$ENDIF //SOCKETS || AUTOMATION
	//}}AFX_VIRTUAL

	//{{AFX_MSG($$APP_CLASS$$)
		//  -  ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//         ̈ʒuɐR[hҏWȂłB
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\dlgroot.h ===
// $$root$$.h : $$ROOT$$ AvP[ṼC wb_[ t@CłB
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// C V{

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$:
// ̃NX̓̒`ɊւĂ $$root$$.cpp t@CQƂĂB
//

class $$APP_CLASS$$ : public $$APP_BASE_CLASS$$
{
public:
	$$APP_CLASS$$();

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$APP_CLASS$$)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Cve[V

	//{{AFX_MSG($$APP_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\frame.h ===
// $$frame_hfile$$.h : $$FRAME_CLASS$$ NX̐錾уC^[tFCX̒`܂B
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)


class $$VIEW_CLASS$$;
$$ELIF(NODOCVIEW)


#include "$$wndview_hfile$$.h"
$$ENDIF
$$ENDIF 

$$IF(PROJTYPE_MDI)
class $$FRAME_CLASS$$ : public $$FRAME_BASE_CLASS$$
{
	DECLARE_DYNAMIC($$FRAME_CLASS$$)
public:
	$$FRAME_CLASS$$();
$$ELSE // SDI
class $$FRAME_CLASS$$ : public $$FRAME_BASE_CLASS$$
{
	
$$IF(NODOCVIEW)
public:
	$$FRAME_CLASS$$();
protected: 
	DECLARE_DYNAMIC($$FRAME_CLASS$$)
$$ELSE
protected: // VACY@\݂̂쐬܂B
	$$FRAME_CLASS$$();
	DECLARE_DYNCREATE($$FRAME_CLASS$$)
$$ENDIF
$$ENDIF // PROJTYPEMDI

// Agr[g
$$IF(SPLITTER_SDI || PROJTYPE_EXPLORER)
$$IF(PROJTYPE_SDI)
protected:
	CSplitterWnd m_wndSplitter;
$$ENDIF 
$$ENDIF //SPLITTER_SDI
public:

// Iy[V
public:

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$FRAME_CLASS$$)
$$IF(SPLITTER_SDI || FRAME_STYLES || PROJTYPE_EXPLORER)
	public:
$$ENDIF
$$IF(SPLITTER_SDI || PROJTYPE_EXPLORER)
$$IF(PROJTYPE_SDI)
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
$$ENDIF 
$$ENDIF
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
$$IF(NODOCVIEW)
$$IF(PROJTYPE_SDI)
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
$$ENDIF 
$$ENDIF
	//}}AFX_VIRTUAL

// Cve[V
public:
	virtual ~$$FRAME_CLASS$$();
$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	$$VIEW_CLASS$$* GetRightPane();
$$ENDIF	// CListView
$$ENDIF	// PROJTYPE_EXPLORER
$$ENDIF	// PROJTYPE_SDI
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
$$IF(TOOLBAR || STATUSBAR || REBAR)

protected:  // Rg[ o[po
$$IF(STATUSBAR)	
	CStatusBar  m_wndStatusBar;
$$ENDIF //STATUSBAR
$$IF(TOOLBAR)
	CToolBar    m_wndToolBar;
$$ENDIF //TOOLBAR
$$IF(REBAR)
	CReBar      m_wndReBar;
	CDialogBar      m_wndDlgBar;
$$ENDIF //REBAR
$$ENDIF //TOOLBAR || STATUSBAR || REBAR
$$IF(NODOCVIEW)
$$IF(PROJTYPE_SDI)
	$$WNDVIEW_CLASS$$    m_wndView;
$$ENDIF 
$$ENDIF

// ꂽbZ[W }bv֐
protected:
	//{{AFX_MSG($$FRAME_CLASS$$)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
$$IF(NODOCVIEW)
$$IF(PROJTYPE_SDI)
	afx_msg void OnSetFocus(CWnd *pOldWnd);
$$ENDIF 
$$ENDIF
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG
$$IF(PROJTYPE_EXPLORER)
$$IF(PROJTYPE_SDI)
$$IF(CListView)
	afx_msg void OnUpdateViewStyles(CCmdUI* pCmdUI);
	afx_msg void OnViewStyle(UINT nCommandID);
$$ENDIF
$$ENDIF
$$ENDIF
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\doc.h ===
// $$doc_hfile$$.h : $$DOC_CLASS$$ NX̐錾уC^[tFCX̒`܂B
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF

$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)

class $$SRVRITEM_CLASS$$;
$$ENDIF // SERVERS

class $$DOC_CLASS$$ : public $$DOC_BASE_CLASS$$
{
protected: // VACY@\݂̂쐬܂B
	$$DOC_CLASS$$();
	DECLARE_DYNCREATE($$DOC_CLASS$$)

// Agr[g
public:
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	$$SRVRITEM_CLASS$$* GetEmbeddedItem()
		{ return ($$SRVRITEM_CLASS$$*)$$DOC_BASE_CLASS$$::GetEmbeddedItem(); }
$$ENDIF
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
	$$RECSET_CLASS$$ $$RECSET_VARIABLE$$;
$$ENDIF

// Iy[V
public:

//I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$DOC_CLASS$$)
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	protected:
	virtual COleServerItem* OnGetEmbeddedItem();
$$ENDIF
	public:
	virtual BOOL OnNewDocument();
$$IF(!DB_NO_FILE)
	virtual void Serialize(CArchive& ar);
$$ENDIF
	//}}AFX_VIRTUAL
$$IF(CRichEditView)
	virtual $$CNTRITEM_BASE_CLASS$$* CreateClientItem(REOBJECT* preo) const;
$$ENDIF //CRichEditView

// Cve[V
public:
	virtual ~$$DOC_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
$$IF(ACTIVE_DOC_SERVER)
	virtual CDocObjectServer* GetDocObjectServer(LPOLEDOCUMENTSITE pDocSite);
$$ENDIF

// ꂽbZ[W }bv֐
protected:
	//{{AFX_MSG($$DOC_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
$$IF(AUTOMATION)

	// ꂽ OLE fBXpb` }bv֐
	//{{AFX_DISPATCH($$DOC_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
$$ENDIF
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\frame.Cpp ===
// $$frame_ifile$$.cpp : $$FRAME_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$frame_hfile$$.h"
$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)
#include "$$treeview_hfile$$.h"
#include "$$view_hfile$$.h"
$$ENDIF
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$FRAME_CLASS$$

$$IF(PROJTYPE_MDI || NODOCVIEW)
IMPLEMENT_DYNAMIC($$FRAME_CLASS$$, $$FRAME_BASE_CLASS$$)
$$ELSE
IMPLEMENT_DYNCREATE($$FRAME_CLASS$$, $$FRAME_BASE_CLASS$$)
$$ENDIF

BEGIN_MESSAGE_MAP($$FRAME_CLASS$$, $$FRAME_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$FRAME_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	ON_WM_CREATE()
$$IF(PROJTYPE_SDI)
$$IF(NODOCVIEW)
	ON_WM_SETFOCUS()
$$ENDIF 
$$ENDIF 
	//}}AFX_MSG_MAP
$$IF(HELP)
	// O[o wv R}h
	ON_COMMAND(ID_HELP_FINDER, $$FRAME_BASE_CLASS$$::OnHelpFinder)
	ON_COMMAND(ID_HELP, $$FRAME_BASE_CLASS$$::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, $$FRAME_BASE_CLASS$$::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, $$FRAME_BASE_CLASS$$::OnHelpFinder)
$$ENDIF
$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	ON_UPDATE_COMMAND_UI_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnUpdateViewStyles)
	ON_COMMAND_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnViewStyle)
$$ENDIF
$$ENDIF
$$ENDIF
END_MESSAGE_MAP()
$$IF(STATUSBAR)

static UINT indicators[] =
{
	ID_SEPARATOR,           // Xe[^X C CWP[^
$$IF(DO_KANA)
	ID_INDICATOR_KANA,
$$ENDIF	// DO_KANA
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};
$$ENDIF //STATUSBAR

/////////////////////////////////////////////////////////////////////////////
// $$FRAME_CLASS$$ NX̍\z/

$$FRAME_CLASS$$::$$FRAME_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: ̈ʒuɃȍR[hǉĂB
	
$$ENDIF
}

$$FRAME_CLASS$$::~$$FRAME_CLASS$$()
{
}

int $$FRAME_CLASS$$::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if ($$FRAME_BASE_CLASS$$::OnCreate(lpCreateStruct) == -1)
		return -1;
$$IF(PROJTYPE_SDI)
$$IF(NODOCVIEW)
	// t[̃NCAg̈Ŝ߂r[쐬܂B
	if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
		CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
	{
		TRACE0("Failed to create view window\n");
		return -1;
	}
$$ENDIF 
$$ENDIF //SDI + NODOCVIEW
$$IF(TOOLBAR)

$$IF(REBAR)
	if (!m_wndToolBar.CreateEx(this) ||
$$ELSE
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
$$ENDIF //REBAR
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // 쐬Ɏs
	}
$$IF(REBAR)
$$IF( CONTAINER || CONTAINER_SERVER)
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() & ~CBRS_HIDE_INPLACE);
$$ENDIF // ANY CONTAINER
	if (!m_wndDlgBar.Create(this, IDR_MAINFRAME, 
		CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
	{
		TRACE0("Failed to create dialogbar\n");
		return -1;		// 쐬Ɏs
	}

	if (!m_wndReBar.Create(this) ||
		!m_wndReBar.AddBar(&m_wndToolBar) ||
		!m_wndReBar.AddBar(&m_wndDlgBar))
	{
		TRACE0("Failed to create rebar\n");
		return -1;      // 쐬Ɏs
	}
$$IF( CONTAINER || CONTAINER_SERVER)
	m_wndReBar.SetBarStyle(m_wndReBar.GetBarStyle() & ~CBRS_HIDE_INPLACE);
$$ENDIF// ANY CONTAINER
$$ENDIF //REBAR
$$ENDIF //TOOLBAR
$$IF(STATUSBAR)

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // 쐬Ɏs
	}
$$ENDIF //STATUSBAR
$$IF(TOOLBAR)

$$IF(REBAR)
$$IF(VERBOSE)	
	// TODO: c[ `bvXKvȂꍇA폜ĂB
$$ENDIF
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	m_wndDlgBar.SetBarStyle(m_wndDlgBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);
$$ENDIF//MINI_SERVER || FULL_SERVER || CONTAINER_SERVER
$$ELSE
$$IF(VERBOSE)
	// TODO: c[ o[hbLO\ɂȂꍇ͈ȉ̂Rs폜
	//       ĂB
$$ENDIF
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
$$ENDIF //REBAR
$$ENDIF //TOOLBAR	

	return 0;
}
$$IF(SPLITTER_SDI || PROJTYPE_EXPLORER )
$$IF(PROJTYPE_SDI)

BOOL $$FRAME_CLASS$$::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
$$IF(PROJTYPE_EXPLORER)
	// EBhE쐬܂
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
		return FALSE;

	if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS($$TREEVIEW_CLASS$$), CSize(100, 100), pContext) ||
		!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS($$VIEW_CLASS$$), CSize(100, 100), pContext))
	{
		m_wndSplitter.DestroyWindow();
		return FALSE;
	}

	return TRUE;
$$ELSE //!PROJTYPE_EXPLORER
	return m_wndSplitter.Create( this,
$$IF(VERBOSE)
		2, 2,                 // TODO: sƗ̐𒲐ĂB
		CSize( 10, 10 ),      // TODO: ŏ̋TCY𒲐ĂB
$$ELSE //!VERBOSE
		2, 2,
		CSize( 10, 10 ),
$$ENDIF //VERBOSE
		pContext );
$$ENDIF //PROJTYPE_EXPLORER
}
$$ENDIF //SDI
$$ENDIF //SPLITTER || EXPLORER

BOOL $$FRAME_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !$$FRAME_BASE_CLASS$$::PreCreateWindow(cs) )
		return FALSE;
$$IF(VERBOSE)
	// TODO: ̈ʒu CREATESTRUCT cs CāAWindow NXX^C
	//       CĂB

$$ENDIF //VERBOSE
$$IF(FRAME_STYLES)
	cs.style = WS_OVERLAPPED | WS_CAPTION | FWS_ADDTOTITLE
		$$FRAME_STYLE_FLAGS$$;

$$ENDIF //FRAME_STYLES
$$IF(PROJTYPE_SDI)
$$IF(NODOCVIEW)
	cs.dwExStyle &= ~WS_EX_CLIENTEDGE;
	cs.lpszClass = AfxRegisterWndClass(0);
$$ENDIF 
$$ENDIF //SDI + NODOCVIEW
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// $$FRAME_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$FRAME_CLASS$$::AssertValid() const
{
	$$FRAME_BASE_CLASS$$::AssertValid();
}

void $$FRAME_CLASS$$::Dump(CDumpContext& dc) const
{
	$$FRAME_BASE_CLASS$$::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$FRAME_CLASS$$ bZ[W nh
$$IF(PROJTYPE_SDI)
$$IF(NODOCVIEW)
void $$FRAME_CLASS$$::OnSetFocus(CWnd* pOldWnd)
{
	// r[ EBhEɃtH[JX^܂B
	m_wndView.SetFocus();
}

BOOL $$FRAME_CLASS$$::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// r[ɍŏɃR}h@^܂B
	if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// Ȃꍇɂ̓ftHg̏s܂B
	return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}
$$ENDIF 
$$ENDIF //SDI + NODOCVIEW

$$IF(PROJTYPE_SDI)
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
$$VIEW_CLASS$$* $$FRAME_CLASS$$::GetRightPane()
{
	CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
	$$VIEW_CLASS$$* pView = DYNAMIC_DOWNCAST($$VIEW_CLASS$$, pWnd);
	return pView;
}

void $$FRAME_CLASS$$::OnUpdateViewStyles(CCmdUI* pCmdUI)
{
$$IF(VERBOSE)
	// TODO: ̃R[hύXEgāA View j[̑I
	// 悤ɂĂB
$$ENDIF //VERBOSE

	$$VIEW_CLASS$$* pView = GetRightPane(); 

$$IF(VERBOSE)
	// ẼyC쐬Ȃr[ł͂ȂȂA
	// ͈̔͂ŃR}h𖳌ɂ܂
$$ENDIF //VERBOSE

	if (pView == NULL)
		pCmdUI->Enable(FALSE);
	else
	{
		DWORD dwStyle = pView->GetStyle() & LVS_TYPEMASK;

$$IF(VERBOSE)
		// R}h ID_VIEW_LINEUP Ȃ΁A LVS_ICON or LVS_SMALLICON 
		// [hɂȂꍇÃR}hLɂ܂

$$ENDIF //VERBOSE
		if (pCmdUI->m_nID == ID_VIEW_LINEUP)
		{
			if (dwStyle == LVS_ICON || dwStyle == LVS_SMALLICON)
				pCmdUI->Enable();
			else
				pCmdUI->Enable(FALSE);
		}
		else
		{
$$IF(VERBOSE)
			// łȂ΁Ahbggăr[̃X^C𔽉f܂
$$ENDIF //VERBOSE
			pCmdUI->Enable();
			BOOL bChecked = FALSE;

			switch (pCmdUI->m_nID)
			{
			case ID_VIEW_DETAILS:
				bChecked = (dwStyle == LVS_REPORT);
				break;

			case ID_VIEW_SMALLICON:
				bChecked = (dwStyle == LVS_SMALLICON);
				break;

			case ID_VIEW_LARGEICON:
				bChecked = (dwStyle == LVS_ICON);
				break;

			case ID_VIEW_LIST:
				bChecked = (dwStyle == LVS_LIST);
				break;

			default:
				bChecked = FALSE;
				break;
			}

			pCmdUI->SetRadio(bChecked ? 1 : 0);
		}
	}
}


void $$FRAME_CLASS$$::OnViewStyle(UINT nCommandID)
{
$$IF(VERBOSE)
	// TODO: ̃R[hύXEgāA View j[̑I
	// 悤ɂĂB
$$ENDIF //VERBOSE
	$$VIEW_CLASS$$* pView = GetRightPane();

$$IF(VERBOSE)
	// ẼyC쐬 $$VIEW_CLASS$$ Ȃ A
	// j[ R}h܂
$$ENDIF //VERBOSE
	if (pView != NULL)
	{
		DWORD dwStyle = -1;

		switch (nCommandID)
		{
		case ID_VIEW_LINEUP:
			{
$$IF(VERBOSE)
				// Xg Rg[̃ACRObhʒuɍ킹܂
$$ENDIF //VERBOSE
				CListCtrl& refListCtrl = pView->GetListCtrl();
				refListCtrl.Arrange(LVA_SNAPTOGRID);
			}
			break;

$$IF(VERBOSE)
		// ̃R}h̓Xg Rg[̃X^CύX܂
$$ENDIF //VERBOSE
		case ID_VIEW_DETAILS:
			dwStyle = LVS_REPORT;
			break;

		case ID_VIEW_SMALLICON:
			dwStyle = LVS_SMALLICON;
			break;

		case ID_VIEW_LARGEICON:
			dwStyle = LVS_ICON;
			break;

		case ID_VIEW_LIST:
			dwStyle = LVS_LIST;
			break;
		}

$$IF(VERBOSE)
		// X^CύX; EBhE͎Iɍĕ`悵܂
$$ENDIF //VERBOSE
		if (dwStyle != -1)
			pView->ModifyStyle(LVS_TYPEMASK, dwStyle);
	}
}
$$ENDIF
$$ENDIF
$$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\doc.Cpp ===
// $$doc_ifile$$.cpp : $$DOC_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
#include "$$doc_hfile$$.h"
$$IF(CONTAINER || CONTAINER_SERVER)
#include "$$cntritem_hfile$$.h"
$$ENDIF
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#include "$$srvritem_hfile$$.h"
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$

IMPLEMENT_DYNCREATE($$DOC_CLASS$$, $$DOC_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$DOC_CLASS$$, $$DOC_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$DOC_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG_MAP
$$IF(CONTAINER || CONTAINER_SERVER)
	// ftHg OLE Rei̒`gp\ɂ܂B
$$IF(!CRichEditView)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, $$DOC_BASE_CLASS$$::OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, $$DOC_BASE_CLASS$$::OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, $$DOC_BASE_CLASS$$::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, $$DOC_BASE_CLASS$$::OnEditConvert)
$$ENDIF //!CRichEditView
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, $$DOC_BASE_CLASS$$::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, $$DOC_BASE_CLASS$$::OnEditLinks)
	ON_UPDATE_COMMAND_UI_RANGE(ID_OLE_VERB_FIRST, ID_OLE_VERB_LAST, $$DOC_BASE_CLASS$$::OnUpdateObjectVerbMenu)
$$ENDIF
$$IF(MAPI)
	ON_COMMAND(ID_FILE_SEND_MAIL, OnFileSendMail)
	ON_UPDATE_COMMAND_UI(ID_FILE_SEND_MAIL, OnUpdateFileSendMail)
$$ENDIF //MAPI
END_MESSAGE_MAP()

$$IF(AUTOMATION)
BEGIN_DISPATCH_MAP($$DOC_CLASS$$, $$DOC_BASE_CLASS$$)
	//{{AFX_DISPATCH_MAP($$DOC_CLASS$$)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

$$IF(VERBOSE)
// : VBA oChĂ^Cv Z[tT|[g邽߂ IID_I$$Safe_root$$  ̃T|[gǉ܂B
//        IID ́A.ODL t@C̒̃fBXvC^[tFCXɃA^b`Ă GUID Ƀ}b`Ă 
//       ΂Ȃ܂B 

// {$$DISPIID_CLSID_ODL$$}
$$ENDIF //VERBOSE
static const IID IID_I$$Safe_root$$ =
$$DISPIID_CLSID$$;

BEGIN_INTERFACE_MAP($$DOC_CLASS$$, $$DOC_BASE_CLASS$$)
	INTERFACE_PART($$DOC_CLASS$$, IID_I$$Safe_root$$, Dispatch)
END_INTERFACE_MAP()

$$ENDIF //AUTOMATION
/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ NX̍\z/

$$DOC_CLASS$$::$$DOC_CLASS$$()
{
$$IF(COMPFILE)
$$IF(VERBOSE)
	// OLE t@Cgp܂B
$$ENDIF
	EnableCompoundFile();

$$ENDIF //COMPFILE
$$IF(VERBOSE)
	// TODO: ̈ʒuɂPxĂ΂\zp̃R[hǉĂB

$$ENDIF
$$IF(AUTOMATION)
	EnableAutomation();

	AfxOleLockApp();
$$ENDIF
}

$$DOC_CLASS$$::~$$DOC_CLASS$$()
{
$$IF(AUTOMATION)
	AfxOleUnlockApp();
$$ENDIF
}

BOOL $$DOC_CLASS$$::OnNewDocument()
{
	if (!$$DOC_BASE_CLASS$$::OnNewDocument())
		return FALSE;
$$IF(PROJTYPE_SDI)
$$IF(CEditView)

	((CEditView*)m_viewList.GetHead())->SetWindowText(NULL);
$$ENDIF //CEditView
$$ENDIF //PROJTYPE_SDI

$$IF(VERBOSE)
	// TODO: ̈ʒuɍďǉĂB
	// (SDI hLg͂̃hLgėp܂B)

$$ENDIF
	return TRUE;
}
$$IF(CRichEditView)

$$CNTRITEM_BASE_CLASS$$* $$DOC_CLASS$$::CreateClientItem(REOBJECT* preo) const
{
	// ̃NX const w𖳌ɂ邽߂ɃLXg܂
	return new $$CNTRITEM_CLASS$$(preo, ($$DOC_CLASS$$*) this);
}
$$ENDIF //CRichEditView
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ T[o[ Cve[V

COleServerItem* $$DOC_CLASS$$::OnGetEmbeddedItem()
{
$$IF(VERBOSE)
	// OnGetEmbeddedItem ̓hLgƊ֘AtĂ COleServerItem 
	// 𓾂邽߂Ƀt[[NKvȎɂĂ΂܂B

$$ENDIF
	$$SRVRITEM_CLASS$$* pItem = new $$SRVRITEM_CLASS$$(this);
	ASSERT_VALID(pItem);
	return pItem;
}
$$ENDIF
$$IF(ACTIVE_DOC_SERVER)

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ ActiveX hLg T[o[ Cve[V

CDocObjectServer *$$DOC_CLASS$$::GetDocObjectServer(LPOLEDOCUMENTSITE pDocSite)
{
	return new CDocObjectServer(this, pDocSite);
}
$$ENDIF


$$IF(!DB_NO_FILE)

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ VAC[[V

void $$DOC_CLASS$$::Serialize(CArchive& ar)
{
$$IF(CEditView)
$$IF(VERBOSE)
	// CEditView ׂ͂ẴVAC[[V nĥǂꂩ̃GfBbgRg[܂ł܂B
$$ENDIF //VERBOSE
	((CEditView*)m_viewList.GetHead())->SerializeRaw(ar);
$$ELSE
	if (ar.IsStoring())
	{
$$IF(VERBOSE)
		// TODO: ̈ʒuɕۑp̃R[hǉĂB
$$ENDIF
	}
	else
	{
$$IF(VERBOSE)
		// TODO: ̈ʒuɓǂݍݗp̃R[hǉĂB
$$ENDIF
	}
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(VERBOSE)

	// {NX $$DOC_BASE_CLASS$$ ĂяoƂɂăRei hLg
	// COleClientItem IuWFNg̃VAC[[V\ɂȂ܂B
$$ENDIF
$$IF(CRichEditView)
	// TODO: eLXgƂăVACYꍇ́ACRichEditDoc::m_bRTF ZbgĂB
$$ENDIF //CEditView
	$$DOC_BASE_CLASS$$::Serialize(ar);
$$ENDIF // Container
$$ENDIF // CEditView
}
$$ENDIF //!DB_NO_FILE

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$DOC_CLASS$$::AssertValid() const
{
	$$DOC_BASE_CLASS$$::AssertValid();
}

void $$DOC_CLASS$$::Dump(CDumpContext& dc) const
{
	$$DOC_BASE_CLASS$$::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$DOC_CLASS$$ R}h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\ipframe.h ===
// $$ipframe_hfile$$.h : $$IPFRAME_CLASS$$ NX̐錾уC^[tFCX̒`s܂B
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$IPFRAME_CLASS$$ : public $$IPFRAME_BASE_CLASS$$
{
	DECLARE_DYNCREATE($$IPFRAME_CLASS$$)
public:
	$$IPFRAME_CLASS$$();

// Agr[g
public:

// Iy[V
public:

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$IPFRAME_CLASS$$)
$$IF(TOOLBAR)
	public:
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
$$ENDIF
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Cve[V
public:
	virtual ~$$IPFRAME_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
$$IF(TOOLBAR)
	CToolBar    m_wndToolBar;
$$IF(REBAR)
	CDialogBar m_wndDlgBar;
	CReBar m_wndReBar;
$$ENDIF
$$ENDIF
	COleDropTarget	m_dropTarget;
	COleResizeBar   m_wndResizeBar;

// ꂽbZ[W }bv֐
protected:
	//{{AFX_MSG($$IPFRAME_CLASS$$)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\ipframe.Cpp ===
// $$ipframe_ifile$$.cpp : $$IPFRAME_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$ipframe_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$IPFRAME_CLASS$$

IMPLEMENT_DYNCREATE($$IPFRAME_CLASS$$, $$IPFRAME_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$IPFRAME_CLASS$$, $$IPFRAME_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$IPFRAME_CLASS$$)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
$$IF(HELP)
	// O[o wv R}h
	ON_COMMAND(ID_HELP_FINDER, $$IPFRAME_BASE_CLASS$$::OnHelpFinder)
	ON_COMMAND(ID_HELP, $$IPFRAME_BASE_CLASS$$::OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, $$IPFRAME_BASE_CLASS$$::OnHelpFinder)
	ON_COMMAND(ID_CONTEXT_HELP, $$IPFRAME_BASE_CLASS$$::OnContextHelp)
$$ENDIF
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$IPFRAME_CLASS$$ NX̍\z/

$$IPFRAME_CLASS$$::$$IPFRAME_CLASS$$()
{
}

$$IPFRAME_CLASS$$::~$$IPFRAME_CLASS$$()
{
}

int $$IPFRAME_CLASS$$::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if ($$IPFRAME_BASE_CLASS$$::OnCreate(lpCreateStruct) == -1)
		return -1;

$$IF(VERBOSE)
	// CResizeBar ͖ߍݐł̃TCY̕ύX܂B
$$ENDIF
	if (!m_wndResizeBar.Create(this))
	{
		TRACE0("Failed to create resize bar\n");
		return -1;      // 쐬Ɏs
	}

$$IF(VERBOSE)
	// ftHgŁAhbv ^[Qbgt[EBhEƋɓo^
	// Ȃ̂́AǂlłB "falling through" hbvR
	// eĩhbO Ah hbv T|[gی삵܂B
$$ENDIF
	m_dropTarget.Register(this);

	return 0;
}

$$IF(TOOLBAR)
$$IF(VERBOSE)
// OnCreateControlBars ̓Rei AvP[ṼEBhEɃc[o[쐬邽߂ɁA
// t[[NĂ΂܂BpWndFrame ̓Reĩgbv x̃t[ EBhEŁA
//  NULL ł͂܂BpWndDoc ̓hLg x̃t[ EBhEŃRei SDI
// AvP[V̂Ƃ NULL ɂȂ܂BT[o[ AvP[V͑̃EBhE MFC 
// Rg[ o[zuł܂B
$$ENDIF
BOOL $$IPFRAME_CLASS$$::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc)
{
$$IF(VERBOSE)
	// pWndDoc gp͂폜܂B
$$ENDIF
	UNREFERENCED_PARAMETER(pWndDoc);

$$IF(VERBOSE)
	// bZ[WAvP[Vɓn悤ɁÃEBhEɃI[i[ݒ肵܂B
$$ENDIF
	m_wndToolBar.SetOwner(this);

$$IF(VERBOSE)
	// NCAg̃t[ EBhEɃc[o[쐬B
$$ENDIF
$$IF(REBAR)
	if (!m_wndToolBar.CreateEx(pWndFrame) ||
$$ELSE
	if (!m_wndToolBar.CreateEx(pWndFrame, TBSTYLE_FLAT,WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
$$ENDIF
$$IF(PROJTYPE_MDI)
		!m_wndToolBar.LoadToolBar(IDR_$$DOC$$TYPE_SRVR_IP))
$$ELSE
		!m_wndToolBar.LoadToolBar(IDR_SRVR_INPLACE))
$$ENDIF
	{
		TRACE0("Failed to create toolbar\n");
		return FALSE;
	}

$$IF(REBAR)
$$IF(VERBOSE)
	// ̃EBhẼI[i[ݒ肵AbZ[WAvP[Vɑ悤ɂ܂
$$ENDIF
	m_wndDlgBar.SetOwner(this);

$$IF(VERBOSE)
	// NCAg̃t[ EChEɃ_CAO o[쐬܂
$$ENDIF
$$IF(PROJTYPE_MDI)
	if (!m_wndDlgBar.Create(pWndFrame, IDR_$$DOC$$TYPE_SRVR_IP, 
$$ELSE
	if (!m_wndDlgBar.Create(pWndFrame, IDR_SRVR_INPLACE,
$$ENDIF
		CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
	{
		TRACE0("Failed to create dialogbar\n");
		return FALSE;
	}

$$IF(VERBOSE)
	// ̃EBhẼI[i[ݒ肵AbZ[WAvP[Vɑ悤ɂ܂
$$ENDIF
	m_wndReBar.SetOwner(this);

$$IF(VERBOSE)
	// NCAg̃t[ EChE rebar 쐬܂
$$ENDIF
	if (!m_wndReBar.Create(pWndFrame) ||
		!m_wndReBar.AddBar(&m_wndToolBar) ||
		!m_wndReBar.AddBar(&m_wndDlgBar))
	{
		TRACE0("Failed to create rebar\n");
		return FALSE;
	}

$$IF(VERBOSE)
	// TODO: c[ `bvXKvȂꍇA폜ĂB
$$ENDIF
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);
	m_wndDlgBar.SetBarStyle(m_wndDlgBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);
$$ELSE
$$IF(VERBOSE)
	// TODO: c[ o[hbLO\ɂȂꍇ͈ȉ̂Rs
	//       폜ĂB
$$ENDIF
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->DockControlBar(&m_wndToolBar);
$$ENDIF

	return TRUE;
}

$$ENDIF //TOOLBAR
BOOL $$IPFRAME_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
$$IF(VERBOSE)
	// TODO: ̈ʒu CREATESTRUCT cs C Window NX܂̓X^C
	//       CĂB

$$ENDIF //VERBOSE
	return $$IPFRAME_BASE_CLASS$$::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// $$IPFRAME_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$IPFRAME_CLASS$$::AssertValid() const
{
	$$IPFRAME_BASE_CLASS$$::AssertValid();
}

void $$IPFRAME_CLASS$$::Dump(CDumpContext& dc) const
{
	$$IPFRAME_BASE_CLASS$$::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$IPFRAME_CLASS$$ R}h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by $$ROOT$$.RC
//
$$IF(PROJTYPE_MDI)
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#define IDR_$$DOC$$TYPE_SRVR_IP		4
#define IDR_$$DOC$$TYPE_SRVR_EMB		5
$$ENDIF//MINI_SERVER || FULL_SERVER || CONTAINER_SERVER
$$IF(CONTAINER || CONTAINER_SERVER)
#define IDR_$$DOC$$TYPE_CNTR_IP		6
$$ENDIF//CONTAINER || CONTAINER_SERVER
$$ELSE //MDI
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#define IDR_SRVR_INPLACE			4
#define IDR_SRVR_EMBEDDED			5
$$ENDIF//MINI_SERVER || FULL_SERVER || CONTAINER_SERVER
$$IF(CONTAINER || CONTAINER_SERVER)
#define IDR_CNTR_INPLACE			6
$$ENDIF//CONTAINER || CONTAINER_SERVER
$$ENDIF//!MDI
#define IDD_ABOUTBOX				100
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
#define IDD_$$SAFE_ROOT$$_FORM			101
$$ENDIF
$$IF(CONTAINER || MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || AUTOMATION)
#define IDP_OLE_INIT_FAILED			100
$$IF(MINI_SERVER)
#define IDP_USE_INSERT_OBJECT		101
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
#define IDP_FAILED_TO_CREATE		102
#define ID_CANCEL_EDIT_CNTR			32768
$$ENDIF
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#define ID_CANCEL_EDIT_SRVR			32769
$$ENDIF
$$ENDIF
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#define IDP_FAILED_OPEN_DATABASE	103
$$ENDIF
$$IF(SOCKETS)
#define IDP_SOCKETS_INIT_FAILED		104
$$ENDIF //SOCKETS
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
#define ID_VIEW_ARRANGE				127
$$ENDIF 
$$ENDIF 
#define IDR_MAINFRAME				128
#define IDR_$$DOC$$TYPE				129

// ̃ftHgl͐VKIuWFNgp̒lł
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
$$IF(3D)
#define _APS_3D_CONTROLS			1
$$ENDIF //3D
$$IF(PROJTYPE_DLL || PROJTYPE_OCX)
#define _APS_NEXT_RESOURCE_VALUE	$$START_RES$$
#define _APS_NEXT_CONTROL_VALUE		$$START_RES$$
#define _APS_NEXT_SYMED_VALUE		$$START_RES$$
$$ELSE
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
$$ENDIF //(PROJTYPE_DLL || PROJTYPE_OCX)
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\recset.h ===
// $$recset_hfile$$.h : $$RECSET_CLASS$$ NX̐錾уC^[tFCX̒`܂B
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

$$IF(!OLEDB)
$$IF(DAO)
class $$RECSET_CLASS$$ : public CDaoRecordset
$$ELSE
class $$RECSET_CLASS$$ : public CRecordset
$$ENDIF
{
public:
$$IF(DAO)
	$$RECSET_CLASS$$(CDaoDatabase* pDatabase = NULL);
$$ELSE
	$$RECSET_CLASS$$(CDatabase* pDatabase = NULL);
$$ENDIF
	DECLARE_DYNAMIC($$RECSET_CLASS$$)

// tB[h/p[^ f[^
$$IF(DAO)
	//{{AFX_FIELD($$RECSET_CLASS$$, CDaoRecordset)
$$ELSE
	//{{AFX_FIELD($$RECSET_CLASS$$, CRecordset)
$$ENDIF
$$RECSET_VARS$$
	//}}AFX_FIELD$$PARAM_VARS$$

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂
	//{{AFX_VIRTUAL($$RECSET_CLASS$$)
	public:
$$IF(DAO)
	virtual CString GetDefaultDBName();	// r[: Rg̎擾
$$ELSE
	virtual CString GetDefaultConnect();	// ftHg ̐ڑ
$$ENDIF
	virtual CString GetDefaultSQL(); 	// Recordset  ftHg SQL
$$IF(DAO)
	virtual void DoFieldExchange(CDaoFieldExchange* pFX);	// RFX ̃T|[g
$$ELSE
	virtual void DoFieldExchange(CFieldExchange* pFX);	// RFX ̃T|[g
$$ENDIF
	//}}AFX_VIRTUAL

// Cve[V
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

};

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
$$ELSE  // !!OLEDB --> OLEDB
class $$DB_TABLECLASS$$
{
public:
	$$DB_TABLECLASS$$()
	{
		memset( (void*)this, 0, sizeof(*this) );
	};

$$DB_VARSINFO$$

BEGIN_COLUMN_MAP($$DB_TABLECLASS$$)
$$DB_COLSINFO$$
END_COLUMN_MAP()

};

class $$RECSET_CLASS$$ : public CCommand<CAccessor<$$DB_TABLECLASS$$> >
{
public:

	HRESULT Open()
	{
		CDataSource 	db;
		CSession	session;
		HRESULT		hr;

		CDBPropSet	dbinit(DBPROPSET_DBINIT);
$$DB_OPEN$$
		hr = db.OpenWithServiceComponents("$$DB_CONNECT$$", &dbinit);
		if (FAILED(hr))
			return hr;

		hr = session.Open(db);
		if (FAILED(hr))
			return hr;

		CDBPropSet	propset(DBPROPSET_ROWSET);
		propset.AddProperty(DBPROP_CANFETCHBACKWARDS, true);
		propset.AddProperty(DBPROP_IRowsetScroll, true);
		propset.AddProperty(DBPROP_IRowsetChange, true);
		propset.AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE | DBPROPVAL_UP_INSERT | DBPROPVAL_UP_DELETE );

		hr = CCommand<CAccessor<$$DB_TABLECLASS$$> >::Open(session, "$$DB_SOURCE$$", &propset);

		if (FAILED(hr))
			return hr;

		return MoveNext();
	}

};

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
$$ENDIF // !OLEDB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\recset.Cpp ===
// $$recset_hfile$$.cpp : $$RECSET_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$recset_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$RECSET_CLASS$$ Cve[V

$$IF(!OLEDB)
$$IF(DAO)
IMPLEMENT_DYNAMIC($$RECSET_CLASS$$, CDaoRecordset)
$$ELSE
IMPLEMENT_DYNAMIC($$RECSET_CLASS$$, CRecordset)
$$ENDIF

$$IF(DAO)
$$RECSET_CLASS$$::$$RECSET_CLASS$$(CDaoDatabase* pdb)
	: CDaoRecordset(pdb)
$$ELSE
$$RECSET_CLASS$$::$$RECSET_CLASS$$(CDatabase* pdb)
	: CRecordset(pdb)
$$ENDIF
{
	//{{AFX_FIELD_INIT($$RECSET_CLASS$$)
$$RECSET_VAR_BINDINGS$$
	//}}AFX_FIELD_INIT
	m_nDefaultType = $$DB_TABLE_TYPE$$;$$PARAM_VAR_BINDINGS$$
$$IF(DAO)
$$IF(DB_NO_DETECT)
	m_bCheckCacheForDirtyFields = FALSE;
$$ENDIF // DB_NO_DETECT
$$ENDIF // DAO
}

$$IF(DAO)
CString $$RECSET_CLASS$$::GetDefaultDBName()
{
	return _T("$$DB_CONNECT$$");
}

$$ELSE
CString $$RECSET_CLASS$$::GetDefaultConnect()
{
	return _T("ODBC;DSN=$$DB_CONNECT$$");
}
$$ENDIF

CString $$RECSET_CLASS$$::GetDefaultSQL()
{
	return _T("$$DB_SOURCE$$");
}

$$IF(DAO)
void $$RECSET_CLASS$$::DoFieldExchange(CDaoFieldExchange* pFX)
$$ELSE
void $$RECSET_CLASS$$::DoFieldExchange(CFieldExchange* pFX)
$$ENDIF
{
	//{{AFX_FIELD_MAP($$RECSET_CLASS$$)
$$IF(DAO)
	pFX->SetFieldType(CDaoFieldExchange::outputColumn);
$$ELSE
	pFX->SetFieldType(CFieldExchange::outputColumn);
$$ENDIF
$$RECSET_RFX$$
	//}}AFX_FIELD_MAP$$PARAM_RFX$$
}

/////////////////////////////////////////////////////////////////////////////
// $$RECSET_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$RECSET_CLASS$$::AssertValid() const
{
$$IF(DAO)
	CDaoRecordset::AssertValid();
$$ELSE
	CRecordset::AssertValid();
$$ENDIF
}

void $$RECSET_CLASS$$::Dump(CDumpContext& dc) const
{
$$IF(DAO)
	CDaoRecordset::Dump(dc);
$$ELSE
	CRecordset::Dump(dc);
$$ENDIF
}
#endif //_DEBUG
$$ENDIF //OLEDB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\Root.Cpp ===
// $$root$$.cpp : AvP[VpNX̋@\`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$frame_hfile$$.h"
$$IF(MDICHILD)
#include "$$child_frame_hfile$$.h"
$$ENDIF //MDICHILD
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
#include "$$ipframe_hfile$$.h"
$$ENDIF
$$IF(CRecordView || CDaoRecordView ||COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
$$IF(!NODOCVIEW)
#include "$$doc_hfile$$.h"
$$IF(PROJTYPE_EXPLORER)
#include "$$treeview_hfile$$.h"
$$ELSE
#include "$$view_hfile$$.h"
$$ENDIF
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$

BEGIN_MESSAGE_MAP($$APP_CLASS$$, $$APP_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$APP_CLASS$$)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
$$IF(NODOCVIEW)
$$IF(PROJTYPE_MDI)
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
$$ENDIF //PROJTYPE_MDI
$$ENDIF //NODOCVIEW
	//}}AFX_MSG_MAP
$$IF(!NODOCVIEW)
$$IF(!DB_NO_FILE)
	// W̃t@C{hLg R}h
	ON_COMMAND(ID_FILE_NEW, $$APP_BASE_CLASS$$::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, $$APP_BASE_CLASS$$::OnFileOpen)
$$ENDIF //!DB_NO_FILE
$$ENDIF //!NODOCVIEW
$$IF(PRINT)
	// ẄZbgAbv R}h
	ON_COMMAND(ID_FILE_PRINT_SETUP, $$APP_BASE_CLASS$$::OnFilePrintSetup)
$$ENDIF //PRINT
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ NX̍\z

$$APP_CLASS$$::$$APP_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: ̈ʒuɍ\zpR[hǉĂB
	//  InitInstance ̏dvȏׂċLqĂB
$$ENDIF
}

$$IF(ATL_SUPPORT)
// ATL Module object
CComModule _Module;

$$ENDIF
/////////////////////////////////////////////////////////////////////////////
// B $$APP_CLASS$$ IuWFNg

$$APP_CLASS$$ theApp;
$$IF(FULL_SERVER || MINI_SERVER || CONTAINER_SERVER || AUTOMATION)

$$IF(VERBOSE)
//  ID ͂̃AvP[VvIɃj[NɂȂ悤ɐ܂B
// Aʂ ID w肵Ȃ΁AύXĂ܂܂B

// {$$APP_CLSID_REG$$}
$$ENDIF
static const CLSID clsid =
$$APP_CLSID$$;
$$ENDIF

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ NX̏

BOOL $$APP_CLASS$$::InitInstance()
{
$$IF(OLEDB)
	CoInitialize(NULL);
$$ENDIF // OLEDB
$$IF(SOCKETS)
	if (!AfxSocketInit())
	{
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //SOCKETS
$$IF(CONTAINER || CONTAINER_SERVER || MINI_SERVER || FULL_SERVER || AUTOMATION)
	// OLE Cȕ
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

$$ENDIF //CONTAINER || CONTAINER_SERVER || MINI_SERVER || FULL_SERVER || AUTOMATION
$$IF(OLECTL)
	AfxEnableControlContainer();

$$ENDIF //OLECTL
	// WIȏ
$$IF(VERBOSE)
	// ̋@\gpAst@C̃TCY
	// Έȉ̓̏[`̒sKvȂ
	// 폜ĂB
$$ENDIF
$$IF(3D)

#ifdef _AFXDLL
	Enable3dControls();		// L DLL ̒ MFC gpꍇɂ͂ĂяoĂB
#else
	Enable3dControlsStatic();	// MFC ƐÓIɃNĂꍇɂ͂ĂяoĂB
#endif
$$ENDIF //3D

	// ݒ肪ۑ鉺̃WXg L[ύX܂B
$$IF(VERBOSE)
	// TODO: ̕AЖ܂͏ȂǓK؂Ȃ̂
	// ύXĂB
$$ENDIF
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

$$IF(!NODOCVIEW)
	LoadStdProfileSettings($$SIZE_MRU$$);  // W INI t@C̃IvV[ނ܂ (MRU ܂)
$$ENDIF

$$IF(NODOCVIEW)
$$IF(VERBOSE)
	// C EChE쐬ƂÃR[h͐Vt[ EChE IuWFNg쐬A
	// AvP[ṼC EChEɃZbg܂
$$ENDIF

$$IF( PROJTYPE_MDI )
	CMDIFrameWnd* pFrame = new CMainFrame;
$$ELIF( NODOCVIEW )
	CMainFrame* pFrame = new CMainFrame;
$$ELSE // Doc View ` SDI
	CRuntimeClass* pClass = RUNTIME_CLASS(CMainFrame);
	CFrameWnd* pFrame = (CFrameWnd*) pClass->CreateObject();
	ASSERT_KINDOF(CFrameWnd, pFrame);
$$ENDIF
	m_pMainWnd = pFrame;

$$IF(PROJTYPE_SDI)
$$IF(!NODOCVIEW)
	//  context t[ɓǂݍ݂܂

	CCreateContext context;
$$ELSE
	// t[\[X烍[hč쐬܂
$$ENDIF

	pFrame->LoadFrame(IDR_MAINFRAME,
		WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, NULL, 
$$IF(!NODOCVIEW)
		&context);
$$ELSE
		NULL);
$$ENDIF

$$ELSE // MDI
	// C MDI t[쐬܂
	if (!pFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;

	// ʂ MDI j[ƃANZ[^ e[uǂݍ݂܂
$$IF(VERBOSE)
	//TODO: ǉ̃oϐāAAvP[VKvƂ
	//      ǉ̃j[^Cv̂߂ɌĂяo[hĂB 
$$ENDIF

	HINSTANCE hInst = AfxGetResourceHandle();
	m_hMDIMenu  = ::LoadMenu(hInst, MAKEINTRESOURCE(IDR_$$DOC$$TYPE));
	m_hMDIAccel = ::LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_$$DOC$$TYPE));
$$ENDIF // PROJTYPE_SDI

$$ELSE // NODOCVIEW
$$IF(VERBOSE)
	// AvP[Vp̃hLg ev[go^܂BhLg ev[g
	//  ̓hLgAt[ EBhEƃr[邽߂ɋ@\܂B
$$ELSE
	// hLg ev[go^܂B
$$ENDIF
$$IF(PROJTYPE_MDI)

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_$$DOC$$TYPE,
$$ELSE

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
$$ENDIF
		RUNTIME_CLASS($$DOC_CLASS$$),
$$IF(PROJTYPE_MDI)
$$IF(MDICHILD)
		RUNTIME_CLASS($$CHILD_FRAME_CLASS$$), // JX^ MDI qt[
$$ELSE //!MDICHILD
		RUNTIME_CLASS(CMDIChildWnd),          // W MDI qt[
$$ENDIF //MDICHILD
$$ELSE //!MDI
		RUNTIME_CLASS($$FRAME_CLASS$$),       // C SDI t[ EBhE
$$ENDIF
$$IF(PROJTYPE_EXPLORER)
		RUNTIME_CLASS($$TREEVIEW_CLASS$$));
$$ELSE
		RUNTIME_CLASS($$VIEW_CLASS$$));
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(PROJTYPE_MDI)
	pDocTemplate->SetContainerInfo(IDR_$$DOC$$TYPE_CNTR_IP);
$$ELSE
	pDocTemplate->SetContainerInfo(IDR_CNTR_INPLACE);
$$ENDIF
$$ENDIF
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	pDocTemplate->SetServerInfo(
$$IF(PROJTYPE_MDI)
		IDR_$$DOC$$TYPE_SRVR_EMB, IDR_$$DOC$$TYPE_SRVR_IP,
$$ELSE
		IDR_SRVR_EMBEDDED, IDR_SRVR_INPLACE,
$$ENDIF
		RUNTIME_CLASS($$IPFRAME_CLASS$$));
$$ENDIF
	AddDocTemplate(pDocTemplate);
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || AUTOMATION)
$$IF(VERBOSE)

	// hLg ev[g COleTemplateServer ڑ܂B
	// COleTemplateServer ̓hLg ev[gŎw肳ꂽ
	// g OLE ReiɗvɐVKhLg
	// 쐬܂B
$$ENDIF
$$IF(PROJTYPE_MDI)
	m_server.ConnectTemplate(clsid, pDocTemplate, FALSE);

$$IF(VERBOSE)
	// sƂׂĂ OLE T[o[ t@Ngo^܂B
	// ̃AvP[VIuWFNg邽߂ OLE Cugp\ɂ܂B
$$ENDIF
	COleTemplateServer::RegisterAll();
$$IF(VERBOSE)
		// : MDI AvP[V̓R}hC /Embedding  /Automation 
		//       w肳ĂȂĂׂẴT[o[ IuWFNgo^܂B
$$ENDIF
$$ELSE //!MDI
	m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);
$$IF(VERBOSE)
		// : SDI AvP[V̓R}hC /Embedding  /Automation
		//       w肳Ă鎞T[o[ IuWFNgo^܂B
$$ENDIF
$$ENDIF
$$ENDIF

$$IF(PROJTYPE_MDI)
	// C MDI t[ EBhE쐬
	$$FRAME_CLASS$$* pMainFrame = new $$FRAME_CLASS$$;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

$$IF(!MINI_SERVER)
$$// TtBbNXꍇɂ̂ DragAcceptFiles Ăяo܂B
$$// MDI AvP[Vł́Am_pMainWnd ̐ݒ蒼ɌĂяo܂B
$$IF(HAS_SUFFIX)
	// hbO/hbv ̃I[v܂
	m_pMainWnd->DragAcceptFiles();

$$ENDIF //SUFFIX
$$ENDIF //!MINI_SERVER
$$ENDIF //MDI
$$IF(!MINI_SERVER)
$$IF(HAS_SUFFIX)
	// DDE Execute open gp\ɂ܂B
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

$$ENDIF //SUFFIX
$$ENDIF //!MINI_SERVER
$$ENDIF // NODOCVIEW
$$IF(!NODOCVIEW)
	// DDEAfile open ȂǕW̃VF R}h̃R}hC͂܂B
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);
$$ENDIF

$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || AUTOMATION)
$$IF(VERBOSE)
	// OLE T[o[ƂċNĂ邩mF܂B
$$ENDIF
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
$$IF(!PROJTYPE_MDI)
$$IF(VERBOSE)
		// sƂׂĂ OLE T[o[ t@Ngo^܂B
		// ̃AvP[VIuWFNg邽߂ OLE Cugp\ɂ܂B
$$ENDIF //VERBOSE
		COleTemplateServer::RegisterAll();

$$ENDIF //!MDI
		// AvP[V /Embedding  /Automation ŎsĂ鎞ɂ
		// C EBhE ͕\ł܂B
		return TRUE;
	}

$$IF(VERBOSE)
	// VXe WXgĂăT[o[ AvP[VX^h A
	// Nꂽɂ́AVXe WXgXVĂB
$$ENDIF
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
$$IF(ACTIVE_DOC_SERVER)
	m_server.UpdateRegistry(OAT_DOC_OBJECT_SERVER);
$$ELSE
	m_server.UpdateRegistry(OAT_INPLACE_SERVER);
$$ENDIF	// ACTIVE_DOC_SERVER
$$ELIF(AUTOMATION)
	m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
$$ENDIF
$$IF(AUTOMATION)
	COleObjectFactory::UpdateRegistryAll();
$$ENDIF

$$ENDIF //MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || AUTOMATION
$$IF(MINI_SERVER)
$$IF(VERBOSE)
	// ~jT[o[X^h AŎsĂ鎞AWXg͍XVꃆ[U[̓T[o[
	// gp邽߂ɃReiŃIuWFNg̑}_CAOgp悤w܂B
	// ~jT[o[̓X^h Ã[U[ C^[tFCX܂B
$$ENDIF //VERBOSE
	AfxMessageBox(IDP_USE_INSERT_OBJECT);
	return FALSE;
$$ELSE //!MINI_SERVER
$$IF(!NODOCVIEW)
	// R}hCŃfBXpb` R}hw肵܂B
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;
$$ENDIF
$$IF(PROJTYPE_MDI)
$$IF(VERBOSE)

	// C EBhEꂽ̂ŁA\ƍXVs܂B
$$ENDIF
$$IF(NODOCVIEW)
	pFrame->ShowWindow($$SW_ARG$$);
	pFrame->UpdateWindow();
$$ELSE
	pMainFrame->ShowWindow($$SW_ARG$$);
	pMainFrame->UpdateWindow();
$$ENDIF
$$ELIF(PROJTYPE_SDI)
$$IF(VERBOSE)

	// C EBhEꂽ̂ŁA\ƍXVs܂B
$$ENDIF
$$IF(!NODOCVIEW)
	m_pMainWnd->ShowWindow($$SW_ARG$$);
	m_pMainWnd->UpdateWindow();
$$ELSE
	pFrame->ShowWindow($$SW_ARG$$);
	pFrame->UpdateWindow();
$$ENDIF
$$// TtBbNXꍇ DragAcceptFiles ĂяoĂB
$$// SDI AvP[V̏ꍇ ProcessShellCommand ̌ŌĂяoĂB
$$IF(HAS_SUFFIX)

	// hbO/hbv I[v܂
	m_pMainWnd->DragAcceptFiles();
$$ENDIF //SUFFIX
$$ENDIF //MDI/SDI

	return TRUE;
$$ENDIF //!MINI_SERVER
}

$$IF(NODOCVIEW)
/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ message handlers

$$IF(PROJTYPE_MDI)
$$IF(NODOCVIEW)
int $$APP_CLASS$$::ExitInstance() 
{
$$IF(VERBOSE)
	//TODO: ǉ\[Xꍇɂ͂Ă
$$ENDIF
	if (m_hMDIMenu != NULL)
		FreeResource(m_hMDIMenu);
	if (m_hMDIAccel != NULL)
		FreeResource(m_hMDIAccel);

	return CWinApp::ExitInstance();
}
$$ENDIF // NODOCVIEW
$$ENDIF // PROJTYPE_MDI

$$IF(PROJTYPE_MDI || !NODOCVIEW ) // Doc View `łȂ SDI ł͕Kv܂
void $$APP_CLASS$$::OnFileNew() 
{
$$IF(PROJTYPE_SDI)
	CString strUntitled;
	CFrameWnd* pFrameWnd = DYNAMIC_DOWNCAST(CFrameWnd, m_pMainWnd);
	if (pFrameWnd != NULL)
	{
$$IF(VERBOSE)
		// TODO: ̃t@CŗL̃f[^āAjĂB 
		// xIt[EChẼ^CgZbg邽߂
		//  if sĂB
$$ENDIF

		if (strUntitled.LoadString(AFX_IDS_UNTITLED))
			pFrameWnd->UpdateFrameTitleForDocument(strUntitled);
		else
			pFrameWnd->UpdateFrameTitleForDocument(NULL);
	}
$$ELSE
	CMainFrame* pFrame = STATIC_DOWNCAST(CMainFrame, m_pMainWnd);

	// V MDI qEBhE쐬܂
	pFrame->CreateNewChild(
		RUNTIME_CLASS(CChildFrame), IDR_$$DOC$$TYPE, m_hMDIMenu, m_hMDIAccel);
$$ENDIF // PROJTYPE_SDI
}
$$ENDIF // PROJTYPE_MDI || !NODOCVIEW


$$ENDIF

/////////////////////////////////////////////////////////////////////////////
// AvP[Ṽo[WŎg CAboutDlg _CAO

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// _CAO f[^
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV ̃T|[g
	//}}AFX_VIRTUAL

// Cve[V
protected:
	//{{AFX_MSG(CAboutDlg)
		// bZ[W nh͂܂B
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// bZ[W nh͂܂B
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// _CAOs邽߂̃AvP[V R}h
void $$APP_CLASS$$::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$ bZ[W nh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\srvritem.Cpp ===
// $$srvritem_ifile$$.cpp : $$SRVRITEM_CLASS$$ AvP[VpNX̋@\`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

$$IF(CRecordView || CDaoRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
#include "$$doc_hfile$$.h"
#include "$$srvritem_hfile$$.h"
$$IF(CONTAINER_SERVER)
#include "$$cntritem_hfile$$.h"
$$ENDIF

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$SRVRITEM_CLASS$$ Cve[V

IMPLEMENT_DYNAMIC($$SRVRITEM_CLASS$$, $$SRVRITEM_BASE_CLASS$$)

$$SRVRITEM_CLASS$$::$$SRVRITEM_CLASS$$($$DOC_CLASS$$* pContainerDoc)
	: $$SRVRITEM_BASE_CLASS$$(pContainerDoc, TRUE)
{
$$IF(VERBOSE)
	// TODO: ̈ʒuɂPxĂ΂\zp̃R[hǉĂB
	//  (Ⴆ΁AACe f[^ \[Xp̓ʂȃNbv{[h`̒ǉ)
$$ENDIF
}

$$SRVRITEM_CLASS$$::~$$SRVRITEM_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: ̏ꏊɌ㏈ǉĂB
$$ENDIF
}

void $$SRVRITEM_CLASS$$::Serialize(CArchive& ar)
{
$$IF(VERBOSE)
	// $$SRVRITEM_CLASS$$::Serialize ̓ACeNbv{[hɃRs[
	// ĂƂɂ́At[[NɂČĂ΂܂B OLE R[
	// obN OnGetClipboardData ʂzĎIɍs킹邱Ƃł܂B
	// ߍ݃ACẽftHg͊ȒPȃhLg̃VACY֐̑
	// ܂B
	// NT|[gĂƂ́AhLg̈ꕔVACY܂B

$$ENDIF
	if (!IsLinkedItem())
	{
		$$DOC_CLASS$$* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pDoc->Serialize(ar);
	}
}

BOOL $$SRVRITEM_CLASS$$::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
{
$$IF(VERBOSE)
	// ̃AvP[Vł́AACẽRec AXyNg̕`悾nh܂B
	//  OnDrawEx I[o[ChĂ DVASPECT_THUMBNAIL ő̃AXyNgT|[g
	// ɂ́AOnGetExtent ǉAXyNgnh悤ɕύXĂB
	//
	//

$$ENDIF
	if (dwDrawAspect != DVASPECT_CONTENT)
		return $$SRVRITEM_BASE_CLASS$$::OnGetExtent(dwDrawAspect, rSize);
$$IF(VERBOSE)

	// $$SRVRITEM_CLASS$$::OnGetExtent ̓ACeŜ HIMETRIC Pʂ͈̔͂𓾂
	// ߂ Ă΂܂BftHǵAPɃn[hR[fBOꂽlԂ܂B
	//
$$ENDIF

	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

$$IF(VERBOSE)
	// TODO: KȃTCYɒuĂB

$$ENDIF
	rSize = CSize(3000, 3000);   // 3000 x 3000 HIMETRIC P

	return TRUE;
}

BOOL $$SRVRITEM_CLASS$$::OnDraw(CDC* pDC, CSize& rSize)
{
$$IF(VERBOSE)
	// rSize gpꍇ͂폜Ă
$$ENDIF
	UNREFERENCED_PARAMETER(rSize);

	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

$$IF(VERBOSE)
	// TODO: }bsO [hƔ͈͂̐ݒB
	//  (͈͂͒ʏ OnGetExtent ԂꂽTCYƓł)
$$ENDIF
	pDC->SetMapMode(MM_ANISOTROPIC);
	pDC->SetWindowOrg(0,0);
	pDC->SetWindowExt(3000, 3000);

$$IF(VERBOSE)
	// TODO: ̏ꏊɕ`p̃R[hǉ܂BCӂ HIMETRIC ͈̔͂hԂĂB
	//       ^t@C foCX ReLXg (pDC) ׂ̂Ă`悵܂B

$$IF(CONTAINER_SERVER)
	// TODO: $$CNTRITEM_CLASS$$ ̖ߍ݃IuWFNg`悵ĂB

$$ENDIF
$$ENDIF
$$IF(CONTAINER_SERVER)
	// ȉɎR[h͍ŏ̃ACeKȈʒu֕`悵܂B

	// TODO: ̃R[h͎ۂ̕`p̃R[hm肵폜ĂB

	POSITION pos = pDoc->GetStartPosition();
	$$CNTRITEM_CLASS$$* pItem = ($$CNTRITEM_CLASS$$*)pDoc->GetNextClientItem(pos);
	if (pItem != NULL)
		pItem->Draw(pDC, CRect(10, 10, 1010, 1010));
$$ENDIF
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// $$SRVRITEM_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$SRVRITEM_CLASS$$::AssertValid() const
{
	$$SRVRITEM_BASE_CLASS$$::AssertValid();
}

void $$SRVRITEM_CLASS$$::Dump(CDumpContext& dc) const
{
	$$SRVRITEM_BASE_CLASS$$::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\Script1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by script1.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\Root.h ===
// $$root$$.h : $$ROOT$$ AvP[ṼC wb_[ t@C
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // C V{

/////////////////////////////////////////////////////////////////////////////
// $$APP_CLASS$$:
// ̃NX̓̒`ɊւĂ $$root$$.cpp t@CQƂĂB
//

class $$APP_CLASS$$ : public $$APP_BASE_CLASS$$
{
public:
	$$APP_CLASS$$();

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$APP_CLASS$$)
	public:
	virtual BOOL InitInstance();
$$IF(PROJTYPE_MDI)
$$IF(NODOCVIEW)
	virtual int ExitInstance();
$$ENDIF
$$ENDIF
	//}}AFX_VIRTUAL

// Cve[V
$$IF(FULL_SERVER || MINI_SERVER || CONTAINER_SERVER || AUTOMATION)
	COleTemplateServer m_server;
$$IF(VERBOSE)
		// hLg쐬邽߂̃T[o[ IuWFNg
$$ENDIF
$$ENDIF
$$IF(NODOCVIEW)
$$IF(PROJTYPE_MDI)
protected:
	HMENU m_hMDIMenu;
	HACCEL m_hMDIAccel;
$$ENDIF

public:
$$ENDIF
	//{{AFX_MSG($$APP_CLASS$$)
	afx_msg void OnAppAbout();
$$IF(NODOCVIEW)
$$IF(PROJTYPE_MDI)
	afx_msg void OnFileNew();
$$ENDIF
$$ENDIF
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

$$IF(VBX)
/////////////////////////////////////////////////////////////////////////////
// VB Cxg̊O錾

//{{AFX_VBX_REGISTER()
//}}AFX_VBX_REGISTER
$$ENDIF //VBX

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\stdafx.Cpp ===
// stdafx.cpp : WCN[ht@C܂ރ\[X t@C
//              $$root$$.pch : vRpCσwb_[
//              stdafx.obj : vRpCσ^Cv

#include "stdafx.h"

$$IF(ATL_SUPPORT)
#include <atlimpl.cpp>
$$ENDIF

$$IF(OLEDB)
CComModule _Module;
#include <atlimpl.cpp>
$$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\srvritem.h ===
// $$srvritem_hfile$$.h : $$SRVRITEM_CLASS$$ NX̐錾уC^[tFCX̒`܂B
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$SRVRITEM_CLASS$$ : public $$SRVRITEM_BASE_CLASS$$
{
	DECLARE_DYNAMIC($$SRVRITEM_CLASS$$)

// RXgN^
public:
	$$SRVRITEM_CLASS$$($$DOC_CLASS$$* pContainerDoc);

// Agr[g
	$$DOC_CLASS$$* GetDocument() const
		{ return ($$DOC_CLASS$$*)$$SRVRITEM_BASE_CLASS$$::GetDocument(); }

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$SRVRITEM_CLASS$$)
	public:
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
	virtual BOOL OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize);
	//}}AFX_VIRTUAL

// Cve[V
public:
	~$$SRVRITEM_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual void Serialize(CArchive& ar);   // hLg I/O ɑ΂ăI[o[Ch܂B
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\stdafx.h ===
// stdafx.h : W̃VXe CN[h t@CA
//            ܂͎QƉ񐔂A܂ύXȂ
//            vWFNgp̃CN[h t@CLq܂B
//

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Windows wb_[wǎgpȂX^btO܂B

#include <afxwin.h>         // MFC ̃RAѕWR|[lg
#include <afxext.h>         // MFC ̊g
$$IF(CTreeView || CListView || PROJTYPE_EXPLORER)
#include <afxcview.h>
$$ENDIF //CTreeView || CListView
$$IF(PROJTYPE_DLL)

#ifndef _AFX_NO_OLE_SUPPORT
$$ENDIF //PROJTYPE_DLL
$$IF(CONTAINER || MINI_SERVER || FULL_SERVER || CONTAINER_SERVER || PROJTYPE_DLL)
#include <afxole.h>         // MFC  OLE NX
$$IF(CONTAINER || CONTAINER_SERVER || PROJTYPE_DLL)
#include <afxodlgs.h>       // MFC  OLE _CAO NX
$$ENDIF
$$ENDIF
$$IF(AUTOMATION || PROJTYPE_DLL || OLECTL)
#include <afxdisp.h>        // MFC ̃I[g[V NX
$$ENDIF
$$IF(ACTIVE_DOC_SERVER)
#include <afxdocob.h>
$$ENDIF
$$IF(PROJTYPE_DLL)
#endif // _AFX_NO_OLE_SUPPORT

$$ENDIF //PROJTYPE_DLL
$$// f[^x[X wb_[CN[h܂B f[^x[X wb_[CN[hĂ DLL ܂
$$// AvP[Vɑ΂(f[^x[X r[Ȃ)At DAO  ODBC CN[h܂B
$$// ݂̃r[gpĂ鎞́A ɑΉwb_[̂݃CN[h܂B
$$// ŏ́Ã݂r[gpĂ܂:
$$IF(CRecordView)
#include <afxdb.h>			// MFC ODBC f[^x[X NX
$$ELIF(CDaoRecordView)
#include <afxdao.h>			// MFC DAO f[^x[X NX
$$ELIF(DB || PROJTYPE_DLL)
$$// ̈ʒuōŏx DB T|[gv邩A܂ DLL łBr[͑IĂ܂B

#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC f[^x[X NX
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO f[^x[X NX
#endif // _AFX_NO_DAO_SUPPORT

$$ENDIF // database/DLL options
#include <afxdtctl.h>		// MFC  Internet Explorer 4 R Rg[ T|[g
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC  Windows R Rg[ T|[g
#endif // _AFX_NO_AFXCMN_SUPPORT
$$IF(CHtmlView)
#include <afxhtml.h>			// MFC HTML r[ T|[g
$$ENDIF

$$IF(SOCKETS)
#include <afxsock.h>		// MFC ̃\Pbgg@\
$$ENDIF //SOCKETS
$$IF(CRichEditView)
#include <afxrich.h>		// MFC b` GfBbg NX
$$ENDIF //CRichEditView
$$IF(ATL_SUPPORT)
#include <atlbase.h>
extern CComModule _Module;
$$ENDIF
$$IF(OLEDB)
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atldbcli.h>
#include <afxoledb.h>
$$ENDIF
$$IF(PROJTYPE_DLG)
$$IF(AUTOMATION)

$$IF(VERBOSE)
// ̃}N bMultiInstance p[^p COleObjectFactory RXgN^
// TRUE nȊO IMPLEMENT_OLECREATE ƓłB
// I[g[V Rg[ɂėveI[g[V vLV
// IuWFNgɑ΂ċN悤ɂ̃AvP[ṼCX^X𕪂܂B
$$ENDIF //VERBOSE
#ifndef IMPLEMENT_OLECREATE2
#define IMPLEMENT_OLECREATE2(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	AFX_DATADEF COleObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), TRUE, _T(external_name)); \
	const AFX_DATADEF GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };
#endif // IMPLEMENT_OLECREATE2
$$ENDIF //AUTOMATION
$$ENDIF //PROJTYPE_DLG

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\TreeView.Cpp ===
// $$treeview_ifile$$.cpp : $$TREEVIEW_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

#include "$$doc_hfile$$.h"
#include "$$treeview_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$

IMPLEMENT_DYNCREATE($$TREEVIEW_CLASS$$, $$TREEVIEW_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$TREEVIEW_CLASS$$, $$TREEVIEW_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$TREEVIEW_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//        ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG_MAP
$$IF(PRINT)
	// WR}h
	ON_COMMAND(ID_FILE_PRINT, $$TREEVIEW_BASE_CLASS$$::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, $$TREEVIEW_BASE_CLASS$$::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, $$TREEVIEW_BASE_CLASS$$::OnFilePrintPreview)
$$ENDIF //PRINT
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ NX̍\z/

$$TREEVIEW_CLASS$$::$$TREEVIEW_CLASS$$()
{
$$IF(VERBOSE)
	// TODO: ̏ꏊɍ\zp̃R[hǉĂB

$$ENDIF
}

$$TREEVIEW_CLASS$$::~$$TREEVIEW_CLASS$$()
{
}

BOOL $$TREEVIEW_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
$$IF(VERBOSE)
	// TODO: ̈ʒu CREATESTRUCT cs C Window NX܂̓X^C
	//  CĂB

$$ENDIF //VERBOSE
	return $$TREEVIEW_BASE_CLASS$$::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ NX̕`

void $$TREEVIEW_CLASS$$::OnDraw(CDC* pDC)
{
	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
$$IF(VERBOSE)

	// TODO: ̏ꏊɃlCeBu f[^p̕`R[hǉ܂B
$$ENDIF //VERBOSE
}

$$IF(PRINT)

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ NẌ

BOOL $$TREEVIEW_CLASS$$::OnPreparePrinting(CPrintInfo* pInfo)
{
	// ftHg̈
	return DoPreparePrinting(pInfo);
}

void $$TREEVIEW_CLASS$$::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
$$IF(VERBOSE)
	// TODO: O̓ʂȏǉĂB
$$ENDIF //VERBOSE
}

void $$TREEVIEW_CLASS$$::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
$$IF(VERBOSE)
	// TODO: ̌㏈ǉĂB
$$ENDIF //VERBOSE
}
$$ENDIF //PRINT

void $$TREEVIEW_CLASS$$::OnInitialUpdate()
{
	$$TREEVIEW_BASE_CLASS$$::OnInitialUpdate();
$$IF(VERBOSE)

	// TODO:  GetTreeCtrl() o֐̌ĂяoʂĒڂ̃Xg Rg[
	//  ANZX邱Ƃɂ TreeView ACeŌŒł܂B
$$ENDIF //VERBOSE
}

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$TREEVIEW_CLASS$$::AssertValid() const
{
	$$TREEVIEW_BASE_CLASS$$::AssertValid();
}

void $$TREEVIEW_CLASS$$::Dump(CDumpContext& dc) const
{
	$$TREEVIEW_BASE_CLASS$$::Dump(dc);
}

$$DOC_CLASS$$* $$TREEVIEW_CLASS$$::GetDocument() // fobO o[W̓CCłB
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS($$DOC_CLASS$$)));
	return ($$DOC_CLASS$$*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// $$TREEVIEW_CLASS$$ NX̃bZ[W nh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\WndView.Cpp ===
// $$wndview_ifile$$.cpp : $$WNDVIEW_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"
#include "$$wndview_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$WNDVIEW_CLASS$$

$$WNDVIEW_CLASS$$::$$WNDVIEW_CLASS$$()
{
}

$$WNDVIEW_CLASS$$::~$$WNDVIEW_CLASS$$()
{
}


BEGIN_MESSAGE_MAP($$WNDVIEW_CLASS$$,$$WNDVIEW_BASE_CLASS$$ )
	//{{AFX_MSG_MAP($$WNDVIEW_CLASS$$)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// $$WNDVIEW_CLASS$$ bZ[W nh

BOOL $$WNDVIEW_CLASS$$::PreCreateWindow(CREATESTRUCT& cs) 
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	cs.dwExStyle |= WS_EX_CLIENTEDGE;
	cs.style &= ~WS_BORDER;
	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, 
		::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

	return TRUE;
}

void $$WNDVIEW_CLASS$$::OnPaint() 
{
	CPaintDC dc(this); // `p̃foCX ReLXg
	
$$IF(VERBOSE)
	// TODO: bZ[W nh̃R[hɒǉĂB
$$ENDIF
	
	// `̂߂ CWnd::OnPaint ĂяoĂ͂܂B
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\view.Cpp ===
// $$view_ifile$$.cpp : $$VIEW_CLASS$$ NX̓̒`s܂B
//

#include "stdafx.h"
#include "$$root$$.h"

$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
#include "$$recset_hfile$$.h"
$$ENDIF
#include "$$doc_hfile$$.h"
$$IF(CONTAINER || CONTAINER_SERVER)
#include "$$cntritem_hfile$$.h"
$$ENDIF
#include "$$view_hfile$$.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$

IMPLEMENT_DYNCREATE($$VIEW_CLASS$$, $$VIEW_BASE_CLASS$$)

BEGIN_MESSAGE_MAP($$VIEW_CLASS$$, $$VIEW_BASE_CLASS$$)
	//{{AFX_MSG_MAP($$VIEW_CLASS$$)
$$IF(VERBOSE)
		//  - ClassWizard ͂̈ʒuɃ}bsOp̃}Nǉ܂͍폜܂B
		//    ̈ʒuɐR[hҏWȂłB
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
	ON_WM_DESTROY()
$$IF(!CRichEditView)
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINERS
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	ON_COMMAND(ID_CANCEL_EDIT_SRVR, OnCancelEditSrvr)
$$ENDIF
	//}}AFX_MSG_MAP
$$IF(PRINT)
	// WR}h
	ON_COMMAND(ID_FILE_PRINT, $$VIEW_BASE_CLASS$$::OnFilePrint)
$$IF(!CHtmlView)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, $$VIEW_BASE_CLASS$$::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, $$VIEW_BASE_CLASS$$::OnFilePrintPreview)
$$ENDIF
$$ENDIF //PRINT
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ NX̍\z/

$$VIEW_CLASS$$::$$VIEW_CLASS$$()
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
	: $$VIEW_BASE_CLASS$$($$VIEW_CLASS$$::IDD)
$$ENDIF
{
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
	//{{AFX_DATA_INIT($$VIEW_CLASS$$)
		// : ClassWizard ͂̈ʒuɃȍǉ܂B
$$IF(|| CRecordView || CDaoRecordView || COleDBRecordView)
	m_pSet = NULL;
$$ENDIF
	//}}AFX_DATA_INIT
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!CRichEditView)
	m_pSelection = NULL;
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINERS
$$IF(VERBOSE)
	// TODO: ̏ꏊɍ\zp̃R[hǉĂB

$$ENDIF
}

$$VIEW_CLASS$$::~$$VIEW_CLASS$$()
{
}
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)

void $$VIEW_CLASS$$::DoDataExchange(CDataExchange* pDX)
{
	$$VIEW_BASE_CLASS$$::DoDataExchange(pDX);
	//{{AFX_DATA_MAP($$VIEW_CLASS$$)
		// : ClassWizard ͂̈ʒu DDX  DDV ̌Ăяoǉ܂B
	//}}AFX_DATA_MAP
}
$$ENDIF

BOOL $$VIEW_CLASS$$::PreCreateWindow(CREATESTRUCT& cs)
{
$$IF(VERBOSE)
	// TODO: ̈ʒu CREATESTRUCT cs C Window NX܂̓X^C
	//  CĂB

$$ENDIF //VERBOSE
$$IF(CEditView)
	BOOL bPreCreated = CEditView::PreCreateWindow(cs);
	cs.style &= ~(ES_AUTOHSCROLL|WS_HSCROLL);	// [h bvgp\ɂ܂

	return bPreCreated;
$$ELSE //!CEditView
	return $$VIEW_BASE_CLASS$$::PreCreateWindow(cs);
$$ENDIF //CEditView
}
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
$$ELIF(!CRichEditView)

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ NX̕`

void $$VIEW_CLASS$$::OnDraw(CDC* pDC)
{
	$$DOC_CLASS$$* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	CListCtrl& refCtrl = GetListCtrl();
	refCtrl.InsertItem(0, "Item!");
$$ENDIF
$$ENDIF
$$IF(VERBOSE)
	// TODO: ̏ꏊɃlCeBu f[^p̕`R[hǉ܂B
$$ENDIF //VERBOSE
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!ACTIVE_DOC_CONTAINER)
$$IF(!CRichEditView)
$$IF(VERBOSE)
	// TODO: hLĝׂĂ OLE ACe`悵ĂB

	// I͈͂KȈʒuɕ`悵܂B̃R[h͎ۂ̕`p̃R[h
	// CvgĂ폜ĂBgݍݐҏWLɂ
	// ߂ɁÄʒu $$CNTRITEM_CLASS$$ ԂĂ`ƐmɈv
	// ܂B

	// TODO: ŏIIȕ`p̃R[hm肵Ƃɂ͂̃R[h͍폜ĂB
$$ENDIF //VERBOSE

	if (m_pSelection == NULL)
	{
		POSITION pos = pDoc->GetStartPosition();
		m_pSelection = ($$CNTRITEM_CLASS$$*)pDoc->GetNextClientItem(pos);
	}
	if (m_pSelection != NULL)
		m_pSelection->Draw(pDC, CRect(10, 10, 210, 210));
$$ENDIF //!CRichEditView
$$ENDIF //ACTIVE_DOC_CONTAINER
$$ENDIF //CONTAINERS
}
$$ENDIF // !(CFormView || CRecordView || CDaoRecordView)
$$IF(CScrollView || CONTAINER || CONTAINER_SERVER || CRecordView || CDaoRecordView || COleDBRecordView || CListView || CTreeView || CFormView || CHtmlView)

void $$VIEW_CLASS$$::OnInitialUpdate()
{
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
	m_pSet = &GetDocument()->$$RECSET_VARIABLE$$;
$$IF(COleDBRecordView)
	{
		CWaitCursor wait;
		HRESULT hr = m_pSet->Open();
		if (hr != S_OK)
		{
			AfxMessageBox(_T("Record set failed to open."), MB_OK);
$$IF(VERBOSE)
			// Recordet JɌ݂̃R[hύX悤Ƃ
			// NbV̌ƂȂ邽߁A  O ̃R[h
			// R}hgps\ɂ܂B
$$ENDIF
			m_bOnFirstRecord = TRUE;
			m_bOnLastRecord = TRUE;
		}				
	}
$$ENDIF
$$ENDIF
	$$VIEW_BASE_CLASS$$::OnInitialUpdate();
$$IF(CRecordView || CDaoRecordView || CFormView)
$$IF(PROJTYPE_SDI)
	GetParentFrame()->RecalcLayout();
$$ENDIF
	ResizeParentToFit();
$$ENDIF

$$IF(VERBOSE)
$$IF(CListView)

	// TODO: GetListCtrl() o֐̌ĂяoʂĒڂ̃Xg Rg[
	//  ANZX邱Ƃɂ ListView ACeŌŒł܂B
$$ELIF(CTreeView)

	// TODO:  GetTreeCtrl() o֐̌ĂяoʂĒڂ̃Xg Rg[
	//  ANZX邱Ƃɂ TreeView ACeŌŒł܂B
$$ELIF(CHtmlView)
	// TODO: ̃R[h̓|s[ȃEFbu TCgփirQ[g܂
	// Cӂ̃EFbu TCgɕύXĂ
$$ENDIF //Views
$$ENDIF //VERBOSE
$$IF(CHtmlView)
	Navigate2(_T("http://www.microsoft.com/visualc/"),NULL,NULL);
$$ENDIF //CHTMLVIEW
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!CRichEditView)

$$IF(VERBOSE)
	// TODO: ŏIIȑĨR[hm肵Ƃɂ͂̃R[h͍폜ĂB
$$ENDIF //VERBOSE
	m_pSelection = NULL;    // Ȉ

$$ENDIF //!CRichEditView
$$IF(ACTIVE_DOC_CONTAINER)
	//Active documents should always be activated
	COleDocument* pDoc = (COleDocument*) GetDocument();
	if (pDoc != NULL)
	{
		// activate the first one
		POSITION posItem = pDoc->GetStartPosition();
		if (posItem != NULL)
		{
			CDocItem* pItem = pDoc->GetNextItem(posItem);

			// only if it's an Active document
			COleDocObjectItem *pDocObjectItem =
				DYNAMIC_DOWNCAST(COleDocObjectItem, pItem);

			if (pDocObjectItem != NULL)
			{
				pDocObjectItem->DoVerb(OLEIVERB_SHOW, this);
			}
		}
	}
$$ENDIF
$$IF(CRichEditView)

$$IF(VERBOSE)
	// ̗]ݒ肵܂ (720 twips = 1/2 inch).
$$ENDIF //VERBOSE
	SetMargins(CRect(720, 720, 720, 720));
$$ENDIF	//CRichEditView
$$ENDIF //CONTAINERS
$$IF(CScrollView)
	CSize sizeTotal;
$$IF(VERBOSE)
	// TODO: ̃r[̃TCY̍vvZ܂B
$$ENDIF
	sizeTotal.cx = sizeTotal.cy = 100;
	SetScrollSizes(MM_TEXT, sizeTotal);
$$ENDIF
}
$$ENDIF // CScrollView || CONTAINER || CONTAINER_SERVER || CRecordView || CDaoRecordView || CFormView || CHtmlView
$$IF(PRINT)

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ NẌ

$$IF(!CHtmlView)
BOOL $$VIEW_CLASS$$::OnPreparePrinting(CPrintInfo* pInfo)
{
$$IF(CEditView)
	// ftHg CEditView ̈
	return CEditView::OnPreparePrinting(pInfo);
$$ELSE
$$IF(ACTIVE_DOC_CONTAINER)
	if (!CView::DoPreparePrinting(pInfo))
		return FALSE;
	
	if (!COleDocObjectItem::OnPreparePrinting(this, pInfo))
		return FALSE;

	return TRUE;
$$ELSE
	// ftHg̈
	return DoPreparePrinting(pInfo);
$$ENDIF // ACTIVE_DOC_CONTAINER
$$ENDIF // CEditView
}

$$IF(!CRichEditView)
$$IF(CEditView)
void $$VIEW_CLASS$$::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)
$$ELSE
void $$VIEW_CLASS$$::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
$$ENDIF //CEditView
{
$$IF(CEditView)
$$IF(VERBOSE)
	// ftHg CEditView ňJn܂B
$$ENDIF //VERBOSE
	CEditView::OnBeginPrinting(pDC, pInfo);
$$ELSE
$$IF(VERBOSE)
	// TODO: O̓ʂȏǉĂB
$$ENDIF //VERBOSE
$$ENDIF //CEditView
}

$$IF(CEditView)
void $$VIEW_CLASS$$::OnEndPrinting(CDC* pDC, CPrintInfo* pInfo)
$$ELSE
void $$VIEW_CLASS$$::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
$$ENDIF //CEditView
{
$$IF(CEditView)
$$IF(VERBOSE)
	// ftHg CEditView ̈̌㏈
$$ENDIF //VERBOSE
	CEditView::OnEndPrinting(pDC, pInfo);
$$ELSE
$$IF(VERBOSE)
	// TODO: ̌㏈ǉĂB
$$ENDIF //VERBOSE
$$ENDIF //CEditView
}
$$ENDIF //!CRichEditView
$$ENDIF // !CHtmlView
$$IF(CFormView || ACTIVE_DOC_CONTAINER)

$$IF(ACTIVE_DOC_CONTAINER)
void $$VIEW_CLASS$$::OnPrint(CDC* pDC, CPrintInfo* pInfo)
$$ELSE
void $$VIEW_CLASS$$::OnPrint(CDC* pDC, CPrintInfo* /*pInfo*/)
$$ENDIF
{
$$IF(VERBOSE)
	// TODO: p̃R[hɒǉĂB
$$ENDIF
$$IF(ACTIVE_DOC_CONTAINER)
	if(pInfo->m_bDocObject)
		COleDocObjectItem::OnPrint(this, pInfo, TRUE);
	else
		CView::OnPrint(pDC, pInfo);
$$ENDIF
}
$$ENDIF //CFormView || OLEDOCCONTAINER
$$ENDIF //PRINT
$$IF(CONTAINER || CONTAINER_SERVER)

void $$VIEW_CLASS$$::OnDestroy()
{
$$IF(VERBOSE)
	// ŎɃACeANeBx[g܂; ͕r[
	// gpĂꍇɂ͏dvłB
$$ENDIF
   $$VIEW_BASE_CLASS$$::OnDestroy();
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
   {
      pActiveItem->Deactivate();
      ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
   }
}

$$IF(!CRichEditView)

/////////////////////////////////////////////////////////////////////////////
// OLE NCAg̃T|[gƃR}h

BOOL $$VIEW_CLASS$$::IsSelected(const CObject* pDocItem) const
{
$$IF(VERBOSE)
	// $$CNTRITEM_CLASS$$ IuWFNgō\Ă鎞ɂ
	// ȉɎ@ŏ\łBقȂInhƂɂ
	// ̏ꏊĂB

	// TODO: ̊֐͑Iꂽ OLE NCAg̃ACeɑ΂eXg܂B

$$ENDIF
	return pDocItem == m_pSelection;
}

void $$VIEW_CLASS$$::OnInsertObject()
{
$$IF(VERBOSE)
	// VK $$CNTRITEM_CLASS$$ IuWFNg̏𓾂邽߂
	// WIȃIuWFNg}_CAO {bNXĂяo܂B
$$ENDIF
	COleInsertDialog dlg;
$$IF(ACTIVE_DOC_CONTAINER)
	if (dlg.DoModal(COleInsertDialog::DocObjectsOnly) != IDOK)
		return;
$$ELSE
	if (dlg.DoModal() != IDOK)
		return;
$$ENDIF

	BeginWaitCursor();

	$$CNTRITEM_CLASS$$* pItem = NULL;
	TRY
	{
$$IF(VERBOSE)
		// ̃hLgɐڑꂽVK̃ACe쐬܂B
$$ENDIF
		$$DOC_CLASS$$* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pItem = new $$CNTRITEM_CLASS$$(pDoc);
		ASSERT_VALID(pItem);

$$IF(VERBOSE)
		// _CAO f[^ACe܂B
$$ENDIF
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // Os܂B
		ASSERT_VALID(pItem);

$$IF(ACTIVE_DOC_CONTAINER)
		pItem->DoVerb(OLEIVERB_SHOW, this);
$$ELSE
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);
$$ENDIF

		ASSERT_VALID(pItem);
$$IF(VERBOSE)

		// bIȃ[U[ C^[tFCX̃fUCƂčŌɑ}ꂽ
		// ACeIĂ܂B

		// TODO: AvP[VɓKȑIɂ킹ďĂB
$$ENDIF

		m_pSelection = pItem;   // Ōɑ}ꂽACeI
		pDoc->UpdateAllViews(NULL);
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH

	EndWaitCursor();
}

$$IF(VERBOSE)
// ȉɎR}h nh͑gݍݐҏW𒆎~邽߂̕WI
// L[{[h [U[ C^[tFCXpӂĂ܂BŃRei
// iT[o[ł͂Ȃj́AfBANeBx[VN܂B
$$ENDIF
void $$VIEW_CLASS$$::OnCancelEditCntr()
{
	// ̃r[ɂgݍݐŗLȃACe܂B
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		pActiveItem->Close();
	}
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

$$IF(VERBOSE)
// IuWFNggݍݐŕҏW͂߂Ƃɂ OnSetFocus  OnSize ̓ʂ
// nhOɂ̓ReiKvłB
$$ENDIF
void $$VIEW_CLASS$$::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// r[ɂACeɂ̓tH[JXݒ肷Kv܂B
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();   // {NXĂяoĂ͂܂B
			return;
		}
	}

	$$VIEW_BASE_CLASS$$::OnSetFocus(pOldWnd);
}

void $$VIEW_CLASS$$::OnSize(UINT nType, int cx, int cy)
{
	$$VIEW_BASE_CLASS$$::OnSize(nType, cx, cy);
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->SetItemRects();
}
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINER || CONTAINER_SERVER
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)

/////////////////////////////////////////////////////////////////////////////
// OLE T[o[ T|[g

$$IF(VERBOSE)
// ȉ̃R}hnh͖߂ݕҏWZbVLZX^_[h L[
// {[h [U[ C^tF[Xpӂ܂B
// ŁAT[o[ (Reił͂Ȃ) ́AfBANeBx[VN܂B
$$ENDIF
void $$VIEW_CLASS$$::OnCancelEditSrvr()
{
	GetDocument()->OnDeactivateUI(FALSE);
}
$$ENDIF //SERVERS

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ NX̐ff

#ifdef _DEBUG
void $$VIEW_CLASS$$::AssertValid() const
{
	$$VIEW_BASE_CLASS$$::AssertValid();
}

void $$VIEW_CLASS$$::Dump(CDumpContext& dc) const
{
	$$VIEW_BASE_CLASS$$::Dump(dc);
}

$$DOC_CLASS$$* $$VIEW_CLASS$$::GetDocument() // fobO o[W̓CCłB
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS($$DOC_CLASS$$)));
	return ($$DOC_CLASS$$*)m_pDocument;
}
#endif //_DEBUG
$$IF(CRecordView || CDaoRecordView ||COleDBRecordView)

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ f[^x[X̃T|[g
$$IF(CRecordView)
CRecordset* $$VIEW_CLASS$$::OnGetRecordset()
$$ELIF(CDaoRecordView)
CDaoRecordset* $$VIEW_CLASS$$::OnGetRecordset()
$$ELSE 
CRowset* $$VIEW_CLASS$$::OnGetRowset()
$$ENDIF
{
	return m_pSet;
}

$$ENDIF //CRecordView || CDaoRecordView

/////////////////////////////////////////////////////////////////////////////
// $$VIEW_CLASS$$ NX̃bZ[W nh
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
void $$VIEW_CLASS$$::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
$$IF(VERBOSE)
	// TODO: [U[ɂEChẼr[ X^CύXɑΉR[hǉĂ
$$ENDIF
}
$$ENDIF
$$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\view.h ===
// $$view_hfile$$.h : $$VIEW_CLASS$$ NX̐錾уC^[tFCX̒`܂B
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

$$IF(CONTAINER || CONTAINER_SERVER)
class $$CNTRITEM_CLASS$$;
$$ENDIF
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
class $$RECSET_CLASS$$;
$$ENDIF

class $$VIEW_CLASS$$ : public $$VIEW_BASE_CLASS$$
{
protected: // VACY@\݂̂쐬܂B
	$$VIEW_CLASS$$();
	DECLARE_DYNCREATE($$VIEW_CLASS$$)
$$IF(CRecordView || CDaoRecordView || COleDBRecordView || CFormView)

public:
	//{{AFX_DATA($$VIEW_CLASS$$)
	enum{ IDD = IDD_$$SAFE_ROOT$$_FORM };
$$IF(CRecordView || CDaoRecordView || COleDBRecordView)
	$$RECSET_CLASS$$* m_pSet;
$$ENDIF
	// : ClassWizard ɂĂ̈ʒuɃf[^ oǉ܂B
	//}}AFX_DATA
$$ENDIF

// Agr[g
public:
	$$DOC_CLASS$$* GetDocument();
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!CRichEditView)
$$IF(VERBOSE)
	//  m_pSelection ݂͌ $$CNTRITEM_CLASS$$ ɑ΂IێĂ܂B
	// ̃AvP[Vł̂悤ȃoϐ́ȂI $$CNTRITEM_CLASS$$
	// IuWFNgł͂ȂIuWFNg̑I\ɕ\ł܂B
	// ̋@\͑I@\p悤ƂvO}̗邽
	// ߂ɑgݍ܂Ă܂B

	// TODO: ̑I@AvP[VɓK@ɒuĂB
$$ENDIF //VERBOSE
	$$CNTRITEM_CLASS$$* m_pSelection;
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINERS

// Iy[V
public:

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$VIEW_CLASS$$)
	public:
$$IF(CRecordView)
	virtual CRecordset* OnGetRecordset();
$$ENDIF
$$IF(CDaoRecordView)
	virtual CDaoRecordset* OnGetRecordset();
$$ENDIF
$$IF(COleDBRecordView)
	virtual CRowset* OnGetRowset();
$$ENDIF
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
$$ELIF(!CRichEditView);
	virtual void OnDraw(CDC* pDC);  // ̃r[`悷ۂɃI[o[Ch܂B
$$ENDIF // !(CFormView || CRecordView || CDaoRecordView)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
$$IF(CFormView || CRecordView || CDaoRecordView || COleDBRecordView)
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV ̃T|[g
$$ENDIF //CFormView || CRecordView || CDaoRecordView
$$IF(CScrollView || CONTAINER || CONTAINER_SERVER || CRecordView || CDaoRecordView || COleDBRecordView || CTreeView || CListView || CFormView || CHtmlView)
	virtual void OnInitialUpdate(); // \z̍ŏ̂PxĂяo܂B
$$ENDIF
$$IF(PRINT)
$$IF(!CHtmlView)
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
$$ENDIF
$$IF(CRichEditView||CHtmlView)
$$ELSE
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
$$ENDIF //!CRichEditView||CHtmlView
$$IF(CFormView || ACTIVE_DOC_CONTAINER)
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
$$ENDIF //CFormView
$$ENDIF //PRINT
$$IF(CONTAINER || CONTAINER_SERVER)
$$IF(!CRichEditView)
	virtual BOOL IsSelected(const CObject* pDocItem) const;// Rei T|[g
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINER || CONTAINER_SERVER
	//}}AFX_VIRTUAL

// Cve[V
public:
	virtual ~$$VIEW_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// ꂽbZ[W }bv֐
protected:
	//{{AFX_MSG($$VIEW_CLASS$$)
$$IF(VERBOSE)
		//  -  ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//         ̈ʒuɐR[hҏWȂłB
$$ENDIF
$$IF(CONTAINER || CONTAINER_SERVER)
	afx_msg void OnDestroy();
$$IF(!CRichEditView)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
$$ENDIF //!CRichEditView
$$ENDIF //CONTAINER || CONTAINER_SERVER
$$IF(MINI_SERVER || FULL_SERVER || CONTAINER_SERVER)
	afx_msg void OnCancelEditSrvr();
$$ENDIF //SERVERS
	//}}AFX_MSG
$$IF(PROJTYPE_EXPLORER)
$$IF(CListView)
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
$$ENDIF
$$ENDIF
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // $$view_ifile$$.cpp t@CfobO̎gp܂B
inline $$DOC_CLASS$$* $$VIEW_CLASS$$::GetDocument()
   { return ($$DOC_CLASS$$*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\TreeView.h ===
// $$treeview_hfile$$.h : $$TREEVIEW_CLASS$$ NX̐錾уC^[tFCX̒`܂B
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class $$DOC_CLASS$$;

class $$TREEVIEW_CLASS$$ : public CTreeView
{
protected: // VACY@\݂̂쐬܂B
	$$TREEVIEW_CLASS$$();
	DECLARE_DYNCREATE($$TREEVIEW_CLASS$$)

// Agr[g
public:
	$$DOC_CLASS$$* GetDocument();

// Iy[V
public:

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$TREEVIEW_CLASS$$)
	public:
	virtual void OnDraw(CDC* pDC);  // ̃r[`悷ۂɃI[o[Ch܂B
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
$$IF(PRINT)
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
$$ENDIF
	virtual void OnInitialUpdate(); // \z̍ŏ̂PxĂяo܂B
	//}}AFX_VIRTUAL

// Cve[V
public:
	virtual ~$$TREEVIEW_CLASS$$();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// ꂽbZ[W }bv֐
protected:
	//{{AFX_MSG($$TREEVIEW_CLASS$$)
$$IF(VERBOSE)
		//  -  ClassWizard ͂̈ʒuɃo֐ǉ܂͍폜܂B
		//         ̈ʒuɐR[hҏWȂłB
$$ENDIF
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // $$treeview_ifile$$.cpp t@CfobO̎gp܂B
inline $$DOC_CLASS$$* $$TREEVIEW_CLASS$$::GetDocument()
   { return ($$DOC_CLASS$$*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// $$INSERT_LOCATION_COMMENT$$

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\cm.h ===
/*************************************************************************
	mso96.h

	Owner: rickp
	Copyright (c) 1994 Microsoft Corporation

	The main Office header file.
*************************************************************************/

#ifndef CM_H
#define CM_H

// Basic platform defines, etc.
#include <cmstd.h>


#ifndef RC_INVOKED
	/* REVIEW: what should these pack values be? */
	#if MAC
		#pragma pack(push,1)
	#else
		#pragma pack(push,8)
	#endif
#endif

// Office-global initialization and interfaces
#include <cmuser.h>

// Office Debugging
#include <cmdebug.h>

// Office memory and global variables
#include <cmalloc.h>




// Office Component Integration
#include <CmpMgr.h>



#ifndef RC_INVOKED
	#pragma pack(pop)
#endif

#endif // CM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\Loc\VCMunge\Jpn\MfcApWz\Res\WndView.h ===
// $$wndview_hfile$$.h : $$WNDVIEW_CLASS$$ NX̃C^[tFCX̒`܂B
//
/////////////////////////////////////////////////////////////////////////////

#if !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
#define $$FILE_NAME_SYMBOL$$_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// $$WNDVIEW_CLASS$$ EBhE

class $$WNDVIEW_CLASS$$ : public $$WNDVIEW_BASE_CLASS$$
{
// RXgN^
public:
	$$WNDVIEW_CLASS$$();

// Agr[g
public:

// Iy[V
public:

// I[o[Ch
	// ClassWizard ͉z֐̃I[o[Ch𐶐܂B
	//{{AFX_VIRTUAL($$WNDVIEW_CLASS$$)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Cve[V
public:
	virtual ~$$WNDVIEW_CLASS$$();

	// ꂽbZ[W }bv֐
protected:
	//{{AFX_MSG($$WNDVIEW_CLASS$$)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ V`ꍇɂ́A̍sOɒǉ܂B

#endif // !defined($$FILE_NAME_SYMBOL$$_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\cmdebug.h ===
/*************************************************************************
 	msodebug.h

 	Owner: rickp
 	Copyright (c) 1994 Microsoft Corporation

	Standard debugging definitions for the shared Office libraries.
	Includes asserts, tracing, and other cool stuff like that.
*************************************************************************/

#if !defined(CMDEBUG_H)
#define CMDEBUG_H

#if !defined(CMSTD_H)
#include <cmstd.h>
#endif

#if MAC && !defined(__TYPES__)
#include <macos\types.h>
#endif

#if defined(__cplusplus)
extern "C" {
#endif

/*************************************************************************
	Random useful macros
*************************************************************************/

#if DEBUG
	#define Debug(e) e
	#define DebugOnly(e) e
	#define DebugElse(s, t)	s
#else
	#define Debug(e)
	#define DebugOnly(e)
	#define DebugElse(s, t) t
#endif


/****************************************************************************
   This enum contains the Debug "Messages" that are sent to the FDebugMessage
   Method
 ****************************************************************** JIMMUR **/
enum
{
	msodmWriteBe = 1, /* write out the BE record for this object */

	/* Here begin drawing only debug messages */
	msodmDgvRcvOfHsp = 2001,
		/* Ask a DGV for the bounding rectangle (if any) of an HSP.
			Assumes lParam is really a pointer to an MSODGDB, looks at the
			hsp field thereof and fills out the rcv field. */
	msodmDgsWriteBePvAnchor,
		/* Write out the BE record for a host allocated pvAnchor. */
	msodmDgsWriteBePvClient,
		/* Write out the BE record for any host allocated client data. */
	msodmDgvsAfterMouseInsert,
		/* Passed to IMsoDrawingViewSite after a shape is interactively
			inserted with the mouse. lParam is really the inserted HSP. */
	msodmDgvsAfterMarquee,
		/* Passed to IMsoDrawingViewSite after one drags out a rectangle
			with the pointer tool selecting zero or more shapes. */
	msodmIsNotMso96,
		/* Returns FALSE if the specified object is implemented by MSO96.DLL.
			Allows sleazy up-casts, for example, from IMsoDrawingView *
			to DGV *. */
	msodmGetHdesShape,
		/* Ask a DGVs for its m_hdesShape (in *(MSOHDES *)lParam).  Returns
			FALSE if it filled out an HDES. */
	msodmGetHdesSelection,
		/* Ask a DGVs for its m_hdesSelection (in *(MSOHDES *)lParam).
			Returns FALSE if it filled out an HDES. */
	msodmDguiWriteBeForDgc,
		/* Ask a DGUI to write BEs for a DGC it allocated. */
	msodmDgsWriteBeTxid,
		/* Write out the BE record for the attached text of a shape. */
	msodmDgsWriteBePvAnchorUndo,
		/* Write out the BE record for a host anchor in the undo stack. */
	msodmDgvsDragDrop,
		/* Let the host know that I just did a drag-drop from this window. */
};

enum
{
   msodmbtDoNotWriteObj = 0,    // Do Not write out the object 
   msodmbtWriteObj,             // Do write out the object and
                                    // embedded pointers
};


enum
{
	msocchBt = 20,						// Maximum size of a Bt description String
};

/* Some debug messages need more arguments than fit through
	the arguments to FDebugMethod.  For these there are various
	MSODMBfoo structs, usually defined near the objects they're passed
	to. */


/****************************************************************************
    Interface debug routine
 ****************************************************************** JIMMUR **/
#if DEBUG
   #define MSODEBUGMETHOD  MSOMETHOD_(BOOL, FDebugMessage) (THIS_ HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam) PURE;

   #define MSODEBUGMETHODIMP MSOMETHODIMP_(BOOL) FDebugMessage (HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam); \
         static BOOL FCheckObject(LPVOID pv, int cb);
			
	#define MSOMACDEBUGMETHODIMP MSOMACPUB	 MSOMETHODIMP_(BOOL) FDebugMessage (HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam); \
         static BOOL FCheckObject(LPVOID pv, int cb);

   #define DEBUGMETHOD(cn,bt) STDMETHODIMP_(BOOL) cn::FDebugMessage \
         (HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam) \
         { \
            if (msodmWriteBE == message) \
               {  \
                  return MsoFSaveBe(hinst,lParam,(void*)this,sizeof(cn),bt); \
               } \
            return FALSE; \
         }
 #else
   #define MSODEBUGMETHOD  MSOMETHOD_(BOOL, FDebugMessage) (THIS_ HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam) PURE;

   #define MSODEBUGMETHODIMP MSOMETHODIMP_(BOOL) FDebugMessage (HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam);
			
   #define MSOMACDEBUGMETHODIMP MSOMACPUB MSOMETHODIMP_(BOOL) FDebugMessage (HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam);
	
   #define DEBUGMETHOD(cn,bt)  STDMETHODIMP_(BOOL) cn::FDebugMessage (HMSOINST, \
         UINT, WPARAM, LPARAM) { return TRUE; }
#endif



/*************************************************************************
	Enabling/disabling debug options
*************************************************************************/

enum
{
	msodcAsserts = 0,	/* asserts enabled */
	msodcPushAsserts = 1, /* push asserts enabled */
	msodcMemoryFill = 2,	/* memory fills enabled */
	msodcMemoryFillCheck = 3,	/* check memory fills */
	msodcTrace = 4,	/* trace output */
	msodcHeap = 5,	/* heap checking */
	msodcMemLeakCheck = 6,
	msodcMemTrace = 7,	/* memory allocation trace */
	msodcGdiNoBatch = 8,	/* don't batch GDI calls */
	msodcShakeMem = 9,	/* shake memory on allocations */
	msodcReports = 10,	/* report output enabled */
	msodcMsgTrace = 11,	/* WLM message trace - MAC only */
	msodcWlmValidate = 12,	/* WLM parameter validation - MAC only */
	msodcGdiNoExcep = 13,  /* Don't call GetObjectType for debug */
	msodcDisplaySlowTests = 14, /* Do slow (O(n^2) and worse) Drawing debug checks */
	msodcDisplayAbortOften = 15, /* Check for aborting redraw really often. */
	msodcDisplayAbortNever = 16, /* Don't abort redraw */
	msodcPurgedMaxSmall = 17,
	msodcSpare18 = 18, /* USE ME */
	msodcSpare19 = 19, /* USE ME */
	msodcSpare20 = 20, /* USE ME */
	msodcSpare21 = 21, /* USE ME */
	msodcSpare22 = 22, /* USE ME */
	msodcMax = 23,
};


#if DEBUG
	#define MsoFGetDebugCheck(dc)	(TRUE)
#else
	#define MsoFGetDebugCheck(dc)	(FALSE)
#endif

/*************************************************************************
	Debugger breaks
*************************************************************************/

/* Breaks into the debugger.  Works (more or less) on all supported
 	systems. */
#if X86
	#define MsoDebugBreakInline() {__asm int 3}
#elif MAC
	#define MsoDebugBreakInline() Debugger()
#else
	#define MsoDebugBreakInline() \
		{ \
		__try { DebugBreak(); } \
		__except(EXCEPTION_EXECUTE_HANDLER) { OutputDebugStringA("DebugBreak"); } \
		}
#endif

/*	A version of debug break that you can actually call, instead of the
	above inline weirdness we use in most cases.  Can therefore be used in
	expressions. Returns 0 */
#if DEBUG
	MSOAPI_(int) MsoDebugBreak(void);
#else
	#define MsoDebugBreak() (0)
#endif


/*************************************************************************
	Assertion failures
*************************************************************************/

#if !defined(MSO_NO_ASSERTS)

/*	Displays the assert message, including flushing any assert stack.
	szFile and li are the filename and line number of the failure,
	and szMsg is an optional message to display with the assert.
	Returns FALSE if the caller should break into the debugger. */
#if DEBUG
	MSOAPI_(BOOL) MsoFAssert(const CHAR* szFile, int li, const CHAR* szMsg);
#else
	#define MsoFAssert(szFile, li, szMsg) (TRUE)
#endif

/*	Same as MsoFAssert above, except an optional title string can be
	displayed. */
#if DEBUG
	MSOAPI_(BOOL) MsoFAssertTitle(const CHAR* szTitle,
			const CHAR* szFile, int li, const CHAR* szMsg);
#else
	#define MsoFAssertTitle(szTitle, szFile, li, szMsg) (TRUE)
#endif

/*	Same as MsoFAssertTitle above, except you can pass in your own 
	MessageBox flags */
#if DEBUG
	MSOAPIXX_(BOOL) MsoFAssertTitleMb(const CHAR* szTitle,
			const CHAR* szFile, int li, const CHAR* szMsg, UINT mb);
#else
	#define MsoFAssertTitleMb(szTitle, szFile, li, szMsg, mb) (TRUE)
#endif

/*	Same as MsoFAssertTitleMb above, except you can pass in your own 
	assert output type */
#if DEBUG
	MSOAPI_(BOOL) MsoFAssertTitleAsoMb(int iaso, const CHAR* szTitle,
			const CHAR* szFile, int li, const CHAR* szMsg, UINT mb);
#else
	#define MsoFAssertTitleAsoMb(iaso, szTitle, szFile, li, szMsg, mb) (TRUE)
#endif

/*	To save space used by debug strings, you must declare the assert data
	in any file that uses asserts */
#if DEBUG
	#define AssertData static const CHAR vszAssertFile[] = __FILE__;
#else
	#define AssertData
#endif



/*	The actual guts of the assert.  if the flag f is FALSE, then we kick
	of the assertion failure, displaying the optional message szMsg along
	with the filename and line number of the failure */
#if !DEBUG
	#define AssertMsg(f, szMsg)
	#define AssertMsgInline(f, szMsg)
	#define AssertMsgTemplate(f, szMsg)
#else
	#define AssertMsg(f, szMsg) \
		do { \
		if (!(f) && \
				!MsoFAssert(vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
	#define AssertMsgInline(f, szMsg) \
		do { \
		if (!(f) && \
				!MsoFAssert(__FILE__, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
	// Template inlines don't like the inline __asm for some reason
	#define AssertMsgTemplate(f, szMsg) \
		do { \
		if (!(f) && \
				!MsoFAssert(__FILE__, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreak(); \
		} while (0)
#endif


/*	Tells if the Office is currently displaying an alert message box */
#if !DEBUG
	#define MsoFInAssert() (FALSE)
#else
	MSOAPI_(BOOL) MsoFInAssert(void);
#endif

/*	Random compatability versions of the assert macros */

#define VSZASSERT AssertData
#if MSO_ASSERT_EXP
	#define Assert(f) AssertMsg((f), #f)
	#define AssertInline(f) AssertMsgInline((f), #f)
	#define AssertTemplate(f) AssertMsgTemplate((f), #f)
#else
	#define Assert(f) AssertMsg((f), NULL)
	#define AssertInline(f) AssertMsgInline((f), NULL)
	#define AssertTemplate(f) AssertMsgTemplate((f), NULL)
#endif
#define AssertExp(f) AssertMsg((f), #f)
#define AssertSz(f, szMsg) AssertMsg((f), szMsg)


/*************************************************************************
	Verification failures
*************************************************************************/

/*	Like Assert, except the test is still made in the ship version
 	of the application.  Especially useful for tests that have
 	required side-effects. */

#if !DEBUG
	#define VerifyMsg(f, szMsg) (f)
	#define VerifyMsgInline(f, szMsg) (f)
#else
	#define VerifyMsg(f, szMsg) \
		do { \
		if (!(f) && \
				!MsoFAssert(vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
	#define VerifyMsgInline(f, szMsg) \
		do { \
		if (!(f) && \
				!MsoFAssert(__FILE__, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
#endif

#if MSO_ASSERT_EXP
	#define Verify(f) VerifyMsg((f), #f)
#else
	#define Verify(f) VerifyMsg((f), NULL)
#endif	
#define VerifyExp(f) VerifyMsg((f), #f)
#define SideAssert(f) Verify(f)
#define AssertDo(f) Verify(f)

/*************************************************************************
	Untested notifications
*************************************************************************/

#if !DEBUG
	#define UntestedMsg(szMsg)
#else
	#define UntestedMsg(szMsg) \
		do { \
		if ( \
				!MsoFAssertTitle("Untested", vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
#endif

#define Untested() UntestedMsg(NULL)


/*************************************************************************
	Unreached notifications
*************************************************************************/

#if !DEBUG
	#define UnreachedMsg(szMsg)
#else
	#define UnreachedMsg(szMsg) \
		do { \
		if ( \
				!MsoFAssertTitle("Unreached", vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
#endif

#define Unreached() UnreachedMsg(NULL)


/*************************************************************************
	Scratch GDI Objects
*************************************************************************/

/*	Routines to ensure only single access to global scratch GDI objects */

#if !DEBUG

	#define MsoUseScratchObj(hobj, szObjName)
	#define MsoReleaseScratchObj(hobj, szObjName)
	#define UseScratchDC(hdc)
	#define ReleaseScratchDC(hdc)
	#define UseScratchRgn(hrgn)
	#define ReleaseScratchRgn(hrgn)

#else

	/* mask that contains unused bits in the handle */
	#if MAC
		#define msohInUse (0x00000003)
		#define MsoFObjInUse(hobj) (((int)(hobj)&msohInUse)==0)
	#else
		#define msohInUse (0xffffffff)
		// REVIEW: any handle bits we can rely on to make this test more correct?
		#define MsoFObjInUse(hobj) (GetObjectType(hobj) != 0)
	#endif

	#define MsoUseScratchObj(hobj, szObjName) \
			do { \
			if (MsoFObjInUse(hobj) && \
					!MsoFAssert(vszAssertFile, __LINE__, "Scratch " szObjName " " #hobj " already in use")) \
				MsoDebugBreakInline(); \
			*(int*)&(hobj) ^= msohInUse; \
			} while (0)

	#define MsoReleaseScratchObj(hobj, szObjName) \
			do { \
			if (!MsoFObjInUse(hobj) && \
					!MsoFAssert(vszAssertFile, __LINE__, "Scratch " szObjName " " #hobj " not in use")) \
				MsoDebugBreakInline(); \
			*(int*)&(hobj) ^= msohInUse; \
			} while (0)

	#define UseScratchDC(hdc) MsoUseScratchObj(hdc, "DC")
	#define ReleaseScratchDC(hdc) MsoReleaseScratchObj(hdc, "DC")
	#define UseScratchRgn(hrgn) MsoUseScratchObj(hrgn, "region")
	#define ReleaseScratchRgn(hrgn) MsoReleaseScratchObj(hrgn, "region")

#endif


/*************************************************************************
	Reports
*************************************************************************/

#else // MSO_NO_ASSERTS

	/* When MSO_NO_ASSERTS is defined, we still need to define something for
		these special ones because they can be used inside our headers. */
	#define AssertMsgInline(f, szMsg)
	#define AssertMsgTemplate(f, szMsg)

#endif // MSO_NO_ASSERTS


/*************************************************************************
	Tracing
*************************************************************************/


/*************************************************************************
	Debug fills
*************************************************************************/

enum
{
	msomfSentinel,	/* sentinel fill value */
	msomfFree,	/* free fill value */
	msomfNew,	/* new fill value */
	msomfMax
};

/*	Fills the memory pointed to by pv with the fill value lFill.  The
	area is assumed to be cb bytes in length.  Does nothing in the
	non-debug build */
#if DEBUG
	MSOAPIXX_(void) MsoDebugFillValue(void* pv, int cb, DWORD lFill);
#else
	#define MsoDebugFillValue(pv, cb, lFill)
#endif

/*	In the debug version, used to fill the area of memory pointed to by
	pv with a the standard fill value specified by mf.  The memory is 
	assumed to be cb bytes long. */
#if DEBUG
	MSOAPI_(void) MsoDebugFill(void* pv, int cb, int mf);
#else
	#define MsoDebugFill(pv, cb, mf)
#endif

/*	Checks the area given by pv and cb are filled with the debug fill
	value lFill. */
#if DEBUG
	MSOAPIXX_(BOOL) MsoFCheckDebugFillValue(void* pv, int cb, DWORD lFill);
#else
	#define MsoFCheckDebugFillValue(pv, cb, lFill) (TRUE)
#endif

/*	Checks the area given by pv and cb are filled with the debug fill
	of type mf. */
#if DEBUG
	MSOAPIXX_(BOOL) MsoFCheckDebugFill(void* pv, int cb, int mf);
#else
	#define MsoFCheckDebugFill(pv, cb, mf) (TRUE)
#endif

/* Returns the fill value corresponding to the given fill value type mf. */
#if DEBUG
	MSOAPI_(DWORD) MsoLGetDebugFillValue(int mf);
#else
	#define MsoLGetDebugFillValue(mf) ((DWORD)0)
#endif

/*	Sets the fill value to lFill for the given memory fill type mf.
	Returns the previous fill value. */
#if DEBUG
	MSOAPI_(DWORD) MsoSetDebugFillValue(int mf, DWORD lFill);
#else
	#define MsoSetDebugFillValue(mf, lFill) ((DWORD)0)
#endif

#define MsoDebugFillLocal(l) MsoDebugFill(&(l), sizeof(l), msomfFree)

/*************************************************************************
	Debug APIs
*************************************************************************/

/*************************************************************************
	Standard debugging UI for controlling Office debug options from
	within the app.
*************************************************************************/

/*************************************************************************
	Debug Monitors
*************************************************************************/

#if defined(__cplusplus)
}
#endif


#endif // CMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\cmstd.h ===
/*************************************************************************
	msostd.h

	Owner: rickp
	Copyright (c) 1994 Microsoft Corporation

	Standard common definitions shared by all office stuff
*************************************************************************/

#if !defined(CMSTD_H)
#define CMSTD_H

/*************************************************************************
	make sure we have our processor type set up right - note that we
	now have three - count 'em, three - different symbols defined for
	each processor we support (e.g., X86, _X86_, and _M_IX386)
*************************************************************************/

#if !defined(PPCMAC) && !defined(PPCLIB) && !defined(X86) && !defined(M68K)

	#if defined(_M_IX86)
		#define X86 1
	#elif defined(_M_MPPC)
		#define PPCMAC 1
	#endif

#endif

/*************************************************************************
	Pull in standard Windows and C definitions.
*************************************************************************/

/*	make sure the compiler generates intrinsic calls of all crt functions,
	or else we'll pull in a ton of crt stuff we probably don't want. */
#ifndef RC_INVOKED
	#include <string.h>
	#pragma intrinsic(strcpy, strcat, strlen, memcpy, memset, memcmp)
#endif

#define OEMRESOURCE

#include <windows.h>
#if !defined(RC_INVOKED)
	#include <ole2.h>
#endif

#define MsoMemcpy memcpy
#define MsoMemset memset
#define MsoMemmove memmove

/*************************************************************************
	Pre-processor magic to simplify Mac vs. Windows expressions.
*************************************************************************/

#if MAC
	#define Mac(foo) foo
	#define MacElse(mac, win) mac
	#define NotMac(foo)
	#define Win(foo)
	#define WinMac(win,mac) mac
#else
	#define Mac(foo)
	#define MacElse(mac, win) win
	#define NotMac(foo) foo
	#define Win(foo) foo
	#define WinMac(win,mac) win
#endif


/*************************************************************************
	Calling conventions 

	If you futz with these, check the cloned copies in inc\msosdm.h
	
*************************************************************************/

// define these as nothing since we are not a dll anymore
#define MSOPUB
#define MSOPUBDATA

/* used for interface that rely on using the OS (stdcall) convention */
#define MSOSTDAPICALLTYPE __stdcall

/* used for interfaces that don't depend on using the OS (stdcall) convention */
#define MSOAPICALLTYPE __stdcall

#if defined(__cplusplus)
	#define MSOEXTERN_C extern "C"
#else
	#define MSOEXTERN_C 
#endif

#define MSOAPI_(t) MSOEXTERN_C MSOPUB t MSOAPICALLTYPE 
#define MSOSTDAPI_(t) MSOEXTERN_C MSOPUB t MSOSTDAPICALLTYPE 
#define MSOAPIX_(t) MSOEXTERN_C MSOPUBX t MSOAPICALLTYPE 
#define MSOSTDAPIX_(t) MSOEXTERN_C MSOPUBX t MSOSTDAPICALLTYPE 

#if MAC
	#define MSOPUBXX	
	#define MSOAPIMX_(t) MSOAPI_(t)
	#define MSOAPIXX_(t) MSOAPIX_(t) 
#else
	#define MSOPUBXX MSOPUB
	#define MSOAPIMX_(t) MSOAPIX_(t)
	#define MSOAPIXX_(t) MSOAPI_(t)
#endif

#define MSOMETHOD(m)      STDMETHOD(m)
#define MSOMETHOD_(t,m)   STDMETHOD_(t,m)
#define MSOMETHODIMP      STDMETHODIMP
#define MSOMETHODIMP_(t)  STDMETHODIMP_(t)

/* Interfaces derived from IUnknown behave in funny ways on the Mac */
#if MAC && MSO_NATIVE_MACOLE
#define BEGIN_MSOINTERFACE BEGIN_INTERFACE
#else
#define BEGIN_MSOINTERFACE
#endif


// Deal with "split" DLLs for the Mac PPC Build
#if MAC &&      MACDLLSPLIT
	#define MSOMACPUB MSOPUB
	#define MSOMACPUBDATA  MSOPUBDATA
	#define MSOMACAPI_(t)  MSOAPI_(t)
	#define MSOMACAPIX_(t) MSOAPIX_(t)
#else
	#define MSOMACPUB 
	#define MSOMACPUBDATA
	#define MSOMACAPI_(t) t
	#define MSOMACAPIX_(t) t 
#endif
	
#if X86 && !DEBUG
	#define MSOPRIVCALLTYPE __fastcall
#else
	#define MSOPRIVCALLTYPE __cdecl
#endif

#if MAC
#define MSOCONSTFIXUP(t) t 
#else
#define MSOCONSTFIXUP(t) const t 
#endif



/*************************************************************************
	Common #define section
*************************************************************************/

/* All Microsoft Office specific Apple events should use MSO_EVENTCLASS 
	as the EventClass of their Apple Events */
	
// TODO: This value needs to be okay'd by Word, Excel, PowerPoint, Access and
//              possibly Apple
	
#if MAC
#define MSO_EVENTCLASS '_mso'
#define MSO_WPARAM 'wprm'
#define MSO_LPARAM 'lprm'
#define MSO_NSTI 'nsti'
#endif

// NA means not applicable. Use NA to help document parameters to functions.
#undef  NA
#define NA 0L

/* End of common #define section */


#endif // CMSTD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\cmpmgr.h ===
/****************************************************************************
	CmpMgr.h

	Owner: ClarG
 	Copyright (c) 1995 Microsoft Corporation

	This file contains the exported interfaces and declarations for 
	Office Component Integration.
****************************************************************************/

#ifndef CMPMGR_H
#define CMPMGR_H

#include <cm.h>		// this drags in all component manager include files


// if THREADLEVEL_COMPMGRS, then there is one CompMgr per thread, otherwise
// there is one per process (meaning that there is only one thread).
#if MAC
// WLM 30 has simple implementations of TLS and CriticalSection apis
#define THREADLEVEL_COMPMGRS 1   
#else
#define THREADLEVEL_COMPMGRS 1
#endif

#define InvalidTlsIndex		(DWORD)0xFFFFFFFF   // invalid TLS index


/****************************************************************************
	Component integration structures and constants
****************************************************************************/

// Component registration flags
enum
	{
	msocrfNeedIdleTime         = 1,  // needs idle time
	msocrfNeedPeriodicIdleTime = 2,  // needs idle time every N milliseconds
	msocrfPreTranslateKeys     = 4,  // must process keyboard msgs 
	                                 // before translation
	msocrfPreTranslateAll      = 8,  // must process all msgs 
	                                 // before translation
	msocrfNeedSpecActiveNotifs = 16, // needs to be notified for special 
	                                 // activation changes (currently, this will
	                                 // notify comp if ExclusiveBorderSpace
	                                 // or ExclusiveActivation mode changes)
	                                 // Top-level comps should reg this flag.
	msocrfNeedTopActiveNotifs  = msocrfNeedSpecActiveNotifs, // old name
	msocrfNeedAllActiveNotifs  = 32, // needs to be notified for every
	                                 // change in activation state
	msocrfExclusiveBorderSpace = 64, // needs exclusive border space when 
	                                 // active (normally only used by TopLevel
	                                 // Mac components)
	msocrfExclusiveActivation = 128, // comp becomes exclusively active 
	                                 // when activated
	};

// Component registration advise flags (see msocstate enumeration)
enum
	{
	msocadvfModal              = 1,  // needs modal state change notification
	                                 //  (must be registered by components
	                                 //   managing a toplevel window)												
	msocadvfRedrawOff          = 2,  // needs redrawOff state change notif
	msocadvfWarningsOff        = 4,  // needs warningsOff state change notif
	msocadvfRecording          = 8,  // needs Recording state change notif
	};

// Component registration information
typedef struct _MSOCRINFO
	{
	ULONG cbSize;             // size of MSOCRINFO structure in bytes.
	ULONG uIdleTimeInterval;  // If msocrfNeedPeriodicIdleTime is registered
	                          // in grfcrf, component needs to perform
	                          // periodic idle time tasks during an idle phase
	                          // every uIdleTimeInterval milliseconds.
	DWORD grfcrf;             // bit flags taken from msocrf values (above)
	DWORD grfcadvf;           // bit flags taken from msocadvf values (above)
	} MSOCRINFO;



// Component Host flags
enum
	{
	msochostfExclusiveBorderSpace = 1,  // needs exclusive border space when 
	                                    // active (normally only used by 
	                                    // TopLevel Mac hosts)
	};

// Component Host information
typedef struct _MSOCHOSTINFO
	{
	ULONG cbSize;             // size of MSOCHOSTINFO structure in bytes.
	DWORD grfchostf;          // bit flags taken from msochostf values (above)
	} MSOCHOSTINFO;


// idle flags, passed to IMsoComponent::FDoIdle and 
// IMsoStdComponentMgr::FDoIdle.
enum
	{
	msoidlefPeriodic    = 1,  // periodic idle tasks
	msoidlefNonPeriodic = 2,  // any nonperiodic idle task
	msoidlefPriority    = 4,  // high priority, nonperiodic idle tasks
	msoidlefAll         = -1  // all idle tasks
	};


// Reasons for pushing a message loop, passed to 
// IMsoComponentManager::FPushMessageLoop and 
// IMsoComponentHost::FPushMessageLoop.  The host should remain in message
// loop until IMsoComponent::FContinueMessageLoop 
// (or IMsoStdComponentMgr::FContinueMessageLoop) returns FALSE.
enum
	{
	msoloopFocusWait = 1,  // component is activating host 
	msoloopDoEvents  = 2,  // component is asking host to process messages
	msoloopDebug     = 3,  // component has entered debug mode
	msoloopModalForm = 4   // component is displaying a modal form  
	};


/* msocstate values: state IDs passed to 
	IMsoComponent::OnEnterState, 
	IMsoComponentManager::OnComponentEnterState/FOnComponentExitState/FInState,
	IMsoComponentHost::OnComponentEnterState,
	IMsoStdComponentMgr::OnHostEnterState/FOnHostExitState/FInState.
	When the host or a component is notified through one of these methods that 
	another entity (component or host) is entering or exiting a state 
	identified by one of these state IDs, the host/component should take
	appropriate action:
		msocstateModal (modal state):
			If app is entering modal state, host/component should disable
			its toplevel windows, and reenable them when app exits this
			state.  Also, when this state is entered or exited, host/component
			should notify approprate inplace objects via 
			IOleInPlaceActiveObject::EnableModeless.
		msocstateRedrawOff (redrawOff state):
			If app is entering redrawOff state, host/component should disable
			repainting of its windows, and reenable repainting when app exits
			this state.
		msocstateWarningsOff (warningsOff state):
			If app is entering warningsOff state, host/component should disable
			the presentation of any user warnings, and reenable this when
			app exits this state.
		msocstateRecording (Recording state):
			Used to notify host/component when Recording is turned on or off. */
enum
	{
	msocstateModal       = 1, // modal state; disable toplevel windows
	msocstateRedrawOff   = 2, // redrawOff state; disable window repainting
	msocstateWarningsOff = 3, // warningsOff state; disable user warnings
	msocstateRecording   = 4, // Recording state
	};


/*             ** Comments on State Contexts **
	IMsoComponentManager::FCreateSubComponentManager allows one to create a 
	hierarchical tree of component managers.  This tree is used to maintain 
	multiple contexts with regard to msocstateXXX states.  These contexts are 
	referred to as 'state contexts'.
	Each component manager in the tree defines a state context.  The
	components registered with a particular component manager or any of its
	descendents live within that component manager's state context.  Calls
	to IMsoComponentManager::OnComponentEnterState/FOnComponentExitState
	can be used to	affect all components, only components within the component
	manager's state context, or only those components that are outside of the
	component manager's state context.  IMsoComponentManager::FInState is used
	to query the state of the component manager's state context at its root.

   msoccontext values: context indicators passed to 
	IMsoComponentManager::OnComponentEnterState/FOnComponentExitState.
	These values indicate the state context that is to be affected by the
	state change. 
	In IMsoComponentManager::OnComponentEnterState/FOnComponentExitState,
	the comp mgr informs only those components/host that are within the
	specified state context. */
enum
	{
	msoccontextAll    = 0, // all state contexts in state context tree
	msoccontextMine   = 1, // component manager's state context
	msoccontextOthers = 2, // all other state contexts outside of comp mgr's
	};


/*     ** WM_MOUSEACTIVATE Note (for top level compoenents and host) **
	If the active (or tracking) comp's reg info indicates that it
	wants mouse messages, then no MA_xxxANDEAT value should be returned 
	from WM_MOUSEACTIVATE, so that the active (or tracking) comp will be able
	to process the resulting mouse message.  If one does not want to examine
	the reg info, no MA_xxxANDEAT value should be returned from 
	WM_MOUSEACTIVATE if any comp is active (or tracking).
	One can query the reg info of the active (or tracking) component at any
	time via IMsoComponentManager::FGetActiveComponent. */

/* msogac values: values passed to 
	IMsoComponentManager::FGetActiveComponent. */ 
enum
	{
	msogacActive    = 0, // retrieve true active component
	msogacTracking   = 1, // retrieve tracking component
	msogacTrackingOrActive = 2, // retrieve tracking component if one exists,
	                            // otherwise retrieve true active component
	};

/* msocWindow values: values passed to IMsoComponent::HwndGetWindow. */ 
enum
	{
	msocWindowFrameToplevel = 0,
		/* MDI Apps should return the MDI frame (not MDI client) or App frame
			window, and SDI Apps should return the frame window which hosts the
			component. Basically it should be the topmost window which owns the
			component. For a toolbar set this will be the toplevel owner of
			TBS::m_hwnd. */

	msocWindowFrameOwner = 1,
		/* This is the window which owns the component. It could be same as
			the window obtained by msocWindowFrameTopLevel or be an owned window
			of that window. For a toolbar set this will be TBS::m_hwnd. */

	msocWindowComponent = 2,
		/* This is the "main" window of the component (if it has one). */

	msocWindowDlgOwner = 3,
		/* Caller wishes to display a dialog to be parented by the component.
			Component should return a window suitable for use as the dialog's
			owner window. */  
	};

/****************************************************************************
	Defines the IMsoComponent interface

	Any component that needs idle time, the ability to process
	messages before they are translated 
	(for example, to call TranslateAccelerator or IsDialogMessage),
	notification about modal states,
	or the ability push message loops 
	must implement this interface and register with the Component Manager.
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoComponent

DECLARE_INTERFACE_(IMsoComponent, IUnknown)
	{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoComponent is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Give component a chance to process the message pMsg before it is
		translated and dispatched. Component can do TranslateAccelerator,
		do IsDialogMessage, modify pMsg, or take some other action.
		Return TRUE if the message is consumed, FALSE otherwise. */
	MSOMETHOD_(BOOL, FPreTranslateMessage) (THIS_ MSG *pMsg) PURE;

#if MAC
	/* Give Macintosh component a chance to process the event pEvt
		before it is processed by the host. 
		Return TRUE if the event is consumed, FALSE otherwise.
		(WLM components can simply return FALSE.) */
	MSOMETHOD_(BOOL, FPreProcessMacEvent) (THIS_ EventRecord *pEvt) PURE;
#endif // MAC
	
	/* Notify component when app enters or exits (as indicated by fEnter)
		the state identified by uStateID (a value from msocstate enumeration).
		Component should take action depending on value of uStateID
		(see msocstate comments, above).
		
		Note: If n calls are made with TRUE fEnter, component should consider 
		the state to be in effect until n calls are made with FALSE fEnter.
		
		Note: Components should be aware that it is possible for this method to
		be called with FALSE fEnter more	times than it was called with TRUE 
		fEnter (so, for example, if component is maintaining a state counter
		(incremented when this method is called with TRUE fEnter, decremented
		when called with FALSE fEnter), the counter should not be decremented
		for FALSE fEnter if it is already at zero.)  */
	MSOMETHOD_(void, OnEnterState) (THIS_ ULONG uStateID, BOOL fEnter) PURE;

	/* Notify component when the host application gains or loses activation.
		If fActive is TRUE, the host app is being activated and dwOtherThreadID
		is the ID of the thread owning the window being deactivated.
		If fActive is FALSE, the host app is being deactivated and 
		dwOtherThreadID is the ID of the thread owning the window being 
		activated.
		Note: this method is not called when both the window being activated
		and the one being deactivated belong to the host app. */
	MSOMETHOD_(void, OnAppActivate) (THIS_ 
		BOOL fActive, DWORD dwOtherThreadID) PURE;
	
	/* Notify the active component that it has lost its active status because
		the host or another component has become active. */
	MSOMETHOD_(void, OnLoseActivation) (THIS) PURE;

	/* Notify component when a new object is being activated.
		If pic is non-NULL, then it is the component that is being activated.
		In this case, fSameComponent is TRUE if pic is the same component as
		the callee of this method, and pcrinfo is the reg info of pic.
		If pic is NULL and fHostIsActivating is TRUE, then the host is the
		object being activated, and pchostinfo is its host info.
		If pic is NULL and fHostIsActivating is FALSE, then there is no current
		active object.

		If pic is being activated and pcrinfo->grf has the 
		msocrfExclusiveBorderSpace bit set, component should hide its border
		space tools (toolbars, status bars, etc.);
		component should also do this if host is activating and 
		pchostinfo->grfchostf has the msochostfExclusiveBorderSpace bit set.
		In either of these cases, component should unhide its border space
		tools the next time it is activated.

		If pic is being activated and pcrinfo->grf has the
		msocrfExclusiveActivation bit is set, then pic is being activated in
		"ExclusiveActive" mode.  
		Component should retrieve the top frame window that is hosting pic
		(via pic->HwndGetWindow(msocWindowFrameToplevel, 0)).  
		If this window is different from component's own top frame window, 
			component should disable its windows and do other things it would do
			when receiving OnEnterState(msocstateModal, TRUE) notification. 
		Otherwise, if component is top-level, 
			it should refuse to have its window activated by appropriately
			processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
		Component should remain in one of these states until the 
		ExclusiveActive mode ends, indicated by a future call to 
		OnActivationChange with ExclusiveActivation bit not set or with NULL
		pcrinfo. */
	MSOMETHOD_(void, OnActivationChange) (THIS_ 
		IMsoComponent *pic, 
		BOOL fSameComponent,
		const MSOCRINFO *pcrinfo,
		BOOL fHostIsActivating,
		const MSOCHOSTINFO *pchostinfo, 
		DWORD dwReserved) PURE;

	/* Give component a chance to do idle time tasks.  grfidlef is a group of
		bit flags taken from the enumeration of msoidlef values (above),
		indicating the type of idle tasks to perform.  
		Component may periodically call IMsoComponentManager::FContinueIdle; 
		if this method returns FALSE, component should terminate its idle 
		time processing and return.  
		Return TRUE if more time is needed to perform the idle time tasks, 
		FALSE otherwise.
		Note: If a component reaches a point where it has no idle tasks
		and does not need FDoIdle calls, it should remove its idle task
		registration via IMsoComponentManager::FUpdateComponentRegistration.
		Note: If this method is called on while component is performing a 
		tracking operation, component should only perform idle time tasks that
		it deems are appropriate to perform during tracking. */
	MSOMETHOD_(BOOL, FDoIdle) (THIS_ DWORD grfidlef) PURE;
	
	/* Called during each iteration of a message loop that the component
		pushed. uReason and pvLoopData are the reason and the component private 
		data that were passed to IMsoComponentManager::FPushMessageLoop.
		This method is called after peeking the next message in the queue
		(via PeekMessage) but before the message is removed from the queue.
		The peeked message is passed in the pMsgPeeked param (NULL if no
		message is in the queue).  This method may be additionally called when
		the next message has already been removed from the queue, in which case
		pMsgPeeked is passed as NULL.
		Return TRUE if the message loop should continue, FALSE otherwise.
		If FALSE is returned, the component manager terminates the loop without
		removing pMsgPeeked from the queue. */
	MSOMETHOD_(BOOL, FContinueMessageLoop) (THIS_ 
		ULONG uReason, void *pvLoopData, MSG *pMsgPeeked) PURE;

	/* Called when component manager wishes to know if the component is in a
		state in which it can terminate.  If fPromptUser is FALSE, component
		should simply return TRUE if it can terminate, FALSE otherwise.
		If fPromptUser is TRUE, component should return TRUE if it can
		terminate without prompting the user; otherwise it should prompt the
		user, either 1.) asking user if it can terminate and returning TRUE
		or FALSE appropriately, or 2.) giving an indication as to why it
		cannot terminate and returning FALSE. */
	MSOMETHOD_(BOOL, FQueryTerminate) (THIS_ BOOL fPromptUser) PURE;
	
	/* Called when component manager wishes to terminate the component's
		registration.  Component should revoke its registration with component
		manager, release references to component manager and perform any
		necessary cleanup. */
	MSOMETHOD_(void, Terminate) (THIS) PURE;
	
	/* Called to retrieve a window associated with the component, as specified
		by dwWhich, a msocWindowXXX value (see msocWindow, above).
		dwReserved is reserved for future use and should be zero.
		Component should return the desired window or NULL if no such window
		exists. */
	MSOMETHOD_(HWND, HwndGetWindow) (THIS_ 
		DWORD dwWhich, DWORD dwReserved) PURE;
	};


/****************************************************************************
	Defines the IMsoComponentManager interface

	A component manager is an object implementing the IMsoComponentManager
	interface.  The component manager coordinates components with its message
	loop for proper distribution of idle time and pre-translation message
	processing.	
	It also coordinates modalities and the pushing of message loops.
	The host application can implement its own component manager and register
	it via MsoFSetComponentManager or it can make use of the office supplied
	component manager via MsoFCreateStdComponentManager.
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoComponentManager

DECLARE_INTERFACE_(IMsoComponentManager, IUnknown)
	{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* Return in *ppvObj an implementation of interface iid for service
		guidService (same as IServiceProvider::QueryService).
		Return NOERROR if the requested service is supported, otherwise return
		NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE). */
	MSOMETHOD(QueryService) (THIS_
		REFGUID guidService, REFIID iid, void **ppvObj) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoComponentManager is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Register component piComponent and its registration info pcrinfo with
		this component manager.  Return in *pdwComponentID a cookie which will
		identify the component when it calls other IMsoComponentManager
		methods.
		Return TRUE if successful, FALSE otherwise. */
	MSOMETHOD_(BOOL, FRegisterComponent) (THIS_
		IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, 
		DWORD *pdwComponentID) PURE;
	
	/* Undo the registration of the component identified by dwComponentID
		(the cookie returned from the FRegisterComponent method).
		Return TRUE if successful, FALSE otherwise. */
	MSOMETHOD_(BOOL, FRevokeComponent) (THIS_ DWORD dwComponentID) PURE;
	
	/* Update the registration info of the component identified by
		dwComponentID (the cookie returned from FRegisterComponent) with the
		new registration information pcrinfo.
		Typically this is used to update the idle time registration data, but
		can be used to update other registration data as well.
		Return TRUE if successful, FALSE otherwise. */
	MSOMETHOD_(BOOL, FUpdateComponentRegistration) (THIS_ 
		DWORD dwComponentID, const MSOCRINFO *pcrinfo) PURE;
	
	/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) has been activated.
		The active component gets the	chance to process messages before they
		are dispatched (via IMsoComponent::FPreTranslateMessage) and typically
		gets first crack at idle time after the host.
		This method fails if another component is already Exclusively Active.
		In this case, FALSE is returned and SetLastError is set to 
		msoerrACompIsXActive (comp usually need not take any special action
		in this case).
		Return TRUE if successful. */
	MSOMETHOD_(BOOL, FOnComponentActivate) (THIS_ DWORD dwComponentID) PURE;

	
	/* Called to inform component manager that  component identified by 
		dwComponentID (cookie returned from FRegisterComponent) wishes
		to perform a tracking operation (such as mouse tracking).
		The component calls this method with fTrack == TRUE to begin the
		tracking operation and with fTrack == FALSE to end the operation.
		During the tracking operation the component manager routes messages
		to the tracking component (via IMsoComponent::FPreTranslateMessage)
		rather than to the active component.  When the tracking operation ends,
		the component manager should resume routing messages to the active
		component.  
		Note: component manager should perform no idle time processing during a
		      tracking operation other than give the tracking component idle
		      time via IMsoComponent::FDoIdle.
		Note: there can only be one tracking component at a time.
		Return TRUE if successful, FALSE otherwise.  */
	MSOMETHOD_(BOOL, FSetTrackingComponent) (THIS_ 
		DWORD dwComponentID, BOOL fTrack) PURE;

	/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) is entering the state
		identified by uStateID (msocstateXXX value).  (For convenience when
		dealing with sub CompMgrs, the host can call this method passing 0 for
		dwComponentID.)  
		Component manager should notify all other interested components within
		the state context indicated by uContext (a msoccontextXXX value),
		excluding those within the state context of a CompMgr in rgpicmExclude,
		via IMsoComponent::OnEnterState (see "Comments on State Contexts", 
		above).
		Component Manager should also take appropriate action depending on the 
		value of uStateID (see msocstate comments, above).
		dwReserved is reserved for future use and should be zero.

		rgpicmExclude (can be NULL) is an array of cpicmExclude CompMgrs (can
		include root CompMgr and/or sub CompMgrs); components within the state
		context of a CompMgr appearing in this	array should NOT be notified of 
		the state change (note: if uContext	is msoccontextMine, the only 
		CompMgrs in rgpicmExclude that are checked for exclusion are those that 
		are sub CompMgrs of this Component Manager, since all other CompMgrs 
		are outside of this Component Manager's state context anyway.)

		Note: Calls to this method are symmetric with calls to 
		FOnComponentExitState. 
		That is, if n OnComponentEnterState calls are made, the component is
		considered to be in the state until n FOnComponentExitState calls are
		made.  Before revoking its registration a component must make a 
		sufficient number of FOnComponentExitState calls to offset any
		outstanding OnComponentEnterState calls it has made.

		Note: inplace objects should not call this method with
		uStateID == msocstateModal when entering modal state. Such objects
		should call IOleInPlaceFrame::EnableModeless instead. */
	MSOMETHOD_(void, OnComponentEnterState) (THIS_ 
		DWORD dwComponentID, 
		ULONG uStateID, 
		ULONG uContext,
		ULONG cpicmExclude,
		IMsoComponentManager **rgpicmExclude, 
		DWORD dwReserved) PURE;
	
	/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) is exiting the state
		identified by uStateID (a msocstateXXX value).  (For convenience when
		dealing with sub CompMgrs, the host can call this method passing 0 for
		dwComponentID.)
		uContext, cpicmExclude, and rgpicmExclude are as they are in 
		OnComponentEnterState.
		Component manager	should notify all appropriate interested components
		(taking into account uContext, cpicmExclude, rgpicmExclude) via
		IMsoComponent::OnEnterState (see "Comments on State Contexts", above). 
		Component Manager should also take appropriate action depending on
		the value of uStateID (see msocstate comments, above).
		Return TRUE if, at the end of this call, the state is still in effect
		at the root of this component manager's state context
		(because the host or some other component is still in the state),
		otherwise return FALSE (ie. return what FInState would return).
		Caller can normally ignore the return value.
		
		Note: n calls to this method are symmetric with n calls to 
		OnComponentEnterState (see OnComponentEnterState comments, above). */
	MSOMETHOD_(BOOL, FOnComponentExitState) (THIS_ 
		DWORD dwComponentID, 
		ULONG uStateID, 
		ULONG uContext,
		ULONG cpicmExclude,
		IMsoComponentManager **rgpicmExclude) PURE;

	/* Return TRUE if the state identified by uStateID (a msocstateXXX value)
		is in effect at the root of this component manager's state context, 
		FALSE otherwise (see "Comments on State Contexts", above).
		pvoid is reserved for future use and should be NULL. */
	MSOMETHOD_(BOOL, FInState) (THIS_ ULONG uStateID, void *pvoid) PURE;
	
	/* Called periodically by a component during IMsoComponent::FDoIdle.
		Return TRUE if component can continue its idle time processing, 
		FALSE if not (in which case component returns from FDoIdle.) */
	MSOMETHOD_(BOOL, FContinueIdle) (THIS) PURE;

	/* Component identified by dwComponentID (cookie returned from 
		FRegisterComponent) wishes to push a message loop for reason uReason.
		uReason is one the values from the msoloop enumeration (above).
		pvLoopData is data private to the component.
		The component manager should push its message loop, 
		calling IMsoComponent::FContinueMessageLoop(uReason, pvLoopData)
		during each loop iteration (see IMsoComponent::FContinueMessageLoop
		comments).  When IMsoComponent::FContinueMessageLoop returns FALSE, the
		component manager terminates the loop. */
	MSOMETHOD_(BOOL, FPushMessageLoop) (THIS_ 
		DWORD dwComponentID, ULONG uReason, void *pvLoopData) PURE;

	/* Cause the component manager to create a "sub" component manager, which
		will be one of its children in the hierarchical tree of component
		managers used to maintiain state contexts (see "Comments on State
		Contexts", above).
		piunkOuter is the controlling unknown (can be NULL), riid is the
		desired IID, and *ppvObj returns	the created sub component manager.
		piunkServProv (can be NULL) is a ptr to an object supporting
		IServiceProvider interface to which the created sub component manager
		will delegate its IMsoComponentManager::QueryService calls. 
		(see objext.h or docobj.h for definition of IServiceProvider).
		Returns TRUE if successful. */
	MSOMETHOD_(BOOL, FCreateSubComponentManager) (THIS_ 
		IUnknown *piunkOuter, 
		IUnknown *piunkServProv,
		REFIID riid, 
		void **ppvObj) PURE;

	/* Return in *ppicm an AddRef'ed ptr to this component manager's parent
		in the hierarchical tree of component managers used to maintain state
		contexts (see "Comments on State	Contexts", above).
		Returns TRUE if the parent is returned, FALSE if no parent exists or
		some error occurred. */
	MSOMETHOD_(BOOL, FGetParentComponentManager) (THIS_ 
		IMsoComponentManager **ppicm) PURE;

	/* Return in *ppic an AddRef'ed ptr to the current active or tracking
		component (as indicated by dwgac (a msogacXXX value)), and
		its registration information in *pcrinfo.  ppic and/or pcrinfo can be
		NULL if caller is not interested these values.  If pcrinfo is not NULL,
		caller should set pcrinfo->cbSize before calling this method.
		Returns TRUE if the component indicated by dwgac exists, FALSE if no 
		such component exists or some error occurred.
		dwReserved is reserved for future use and should be zero. */

	MSOMETHOD_(BOOL, FGetActiveComponent) (THIS_ 
		DWORD dwgac, 
		IMsoComponent **ppic, 
		MSOCRINFO *pcrinfo,
		DWORD dwReserved) PURE;
	};


/****************************************************************************
	Defines the IMsoStdComponentMgr interface

	IMsoStdComponentMgr is an interface exposed by the office supplied
	standard component manager, created by MsoFCreateStdComponentMgr.
	The host application uses this interface to communicate directly with
	the standard component manager and indirectly with registered components.
	By making appropriate calls to this interface and implementing
	IMsoComponentHost the host can avoid implementing its own 
	IMsoComponentManager interface.
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoStdComponentMgr

DECLARE_INTERFACE_(IMsoStdComponentMgr, IUnknown)
	{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoStdComponentMgr is a reference counted interface, 
	   MsoDWGetChkMemCounter is used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Set *pchostinfo as the host info.  Can be called multiple times.
		Returns TRUE if successful. */
	MSOMETHOD_(BOOL, FSetHostInfo) (THIS_ 
		const MSOCHOSTINFO *pchostinfo) PURE;

	/* Host calls this method to give the active component a chance to
		process messages before they are translated and dispatched.
		The host need not call this method if no component is active.
		When this method is called on message pMsg, StdComponentMgr in turn 
		calls IMsoComponent::FPreTranslateMessage on the active component if
		its registration info indicates that it is interested.  
		Returns TRUE if message is consumed, in which case the host should
		perform no further processing on the message.  
		Returns FALSE otherwise. */
	MSOMETHOD_(BOOL, FPreTranslateMessage) (THIS_ MSG *pMsg) PURE;

#if MAC
	/* On Macintosh, host calls this method to give the active component a 
		chance to process events before they are processed by the host.
		The host need not call this method if no component is active.
		When this method is called on event pEvt, StdComponentMgr in turn 
		calls IMsoComponent::FPreProcessMacEvent on the active component if
		its registration info indicates that it is interested.  
		Returns TRUE if event is consumed, in which case the host should
		perform no further processing on the event.  
		Returns FALSE otherwise. */
	MSOMETHOD_(BOOL, FPreProcessMacEvent) (THIS_ EventRecord *pEvt) PURE;
#endif // MAC

	/* Called by host to notify StdComponentMgr that one of the host's windows
		has been activated.  This causes the current active component to lose
		its active status.  However, host should not assume that the component
		is no longer active until 
		IMsoComponentHost::OnComponentActivate(NULL) is called.
		This method fails if a component is already Exclusively Active.
		In this case, FALSE is returned and SetLastError is set to 
		msoerrACompIsXActive (host usually need not take any special action
		in this case).
		Returns TRUE if successful. */
	MSOMETHOD_(BOOL, FOnHostActivate) (THIS) PURE;

	/* Called by host to notify StdComponentMgr that host is entering the 
		state identified by uStateID (a msocstateXXX value).
		StdComponentMgr in turn notifies all interested components excluding
		those within the context of a CompMgr appearing in rgpicmExclude (an
		array (can be NULL) of cpicmExclude CompMgrs (can include root CompMgr 
		and/or sub CompMgrs)).
		dwReserved is reserved for future use and should be zero.
		Note: Calls to this method are symmetric with FOnHostExitState calls.
		That is, if n OnHostEnterState calls are made, the host is
		considered to be in the state until n FOnHostExitState calls are
		made. */
	MSOMETHOD_(void, OnHostEnterState) (THIS_ 
		ULONG uStateID, 
		ULONG cpicmExclude,
		IMsoComponentManager **rgpicmExclude, 
		DWORD dwReserved) PURE;

	/* Called by host to notify StdComponentMgr that host is exiting the state 
		identified by uStateID (a msocstateXXX value).  
		StdComponentMgr in turn notifies  all interested components excluding
		those within the context of a CompMgr appearing in rgpicmExclude (an
		array (can be NULL) of cpicmExclude CompMgrs (can include root CompMgr 
		and/or sub CompMgrs)).
		Returns TRUE if the state is still in effect at the end of this call
		(because some component is still in the state), otherwise returns 
		FALSE (ie. returns what FInState would return).  Caller can normally
		ignore the return value.
		Note: n calls to this method are symmetric with n calls to 
		OnHostEnterState (see OnHostEnterState comments, above). */
	MSOMETHOD_(BOOL, FOnHostExitState) (THIS_ 
		ULONG uStateID,
		ULONG cpicmExclude,
		IMsoComponentManager **rgpicmExclude) PURE;

	/* Returns TRUE if state identified by uStateID (a value from msocstate
		enumeration) is in effect, FALSE otherwise.
		pvoid is reserved for future use and should be NULL. */
	MSOMETHOD_(BOOL, FInState) (THIS_ ULONG uStateID, void *pvoid) PURE;
	
	/* Called by host to give registered components the chance to perform idle
		time tasks of the type indicated by grfidlef, a group of bit flags
		taken from the enumeration of msoidlef values (above).
		During a component tracking operation, StdComponentMgr only gives the
		tracking component idle time.
		Returns TRUE if any component needs more time to perform the idle time
		tasks, FALSE otherwise. */
	MSOMETHOD_(BOOL, FDoIdle) (THIS_ DWORD grfidlef) PURE;

	/* Called by host just before it enters the 'wait mode' resulting from a
		call to WaitMessage, GetMessage, or MsgWaitForMultipleObjects.  Such a
		'wait mode' would prevent any components from receiving periodic idle 
		time.  If any registered components need periodic idle time, StdCompMgr
		starts an appropriate timer.  The resulting WM_TIMER message will cause
		the host	to exit the 'wait mode', allowing the processing of periodic 
		idle time tasks when the host calls IMsoStdComponentMgr::FDoIdle. */
	MSOMETHOD_(void, OnWaitForMessage) (THIS) PURE;

	/* Called by host during each iteration of a message loop that a component 
		pushed.
		This method is to be called after peeking the next message in the queue
		(via PeekMessage) but before the message is removed from the queue.
		The peeked message is passed in the pMsgPeeked param (NULL if no 
		message is in the queue).  If this method is additionally called when
		the next message has already been removed from the queue, pMsgPeeked 
		should be passed as NULL.
		StdComponentMgr in turn calls IMsoComponent::FContinueMessageLoop
		on the component, and returns the value returned by that call. 
		Returns TRUE if the message loop should continue, FALSE otherwise.
		If FALSE is returned, the loop should be terminated without removing
		pMsgPeeked from the queue. */
	MSOMETHOD_(BOOL, FContinueMessageLoop) (THIS_ MSG *pMsgPeeked) PURE;

	/* Called by host to determine if all registered components can terminate.
		StdComponentMgr asks each component whether it can terminate via
		IMsoComponent::FQueryTerminate(fPromptUser).  If all components
		return TRUE, then StdComponentMgr returns TRUE.  If any one of the
		components returns FALSE, then StdComponentMgr immediately returns
		FALSE without asking any more components. */
	MSOMETHOD_(BOOL, FQueryTerminate) (THIS_ BOOL fPromptUser) PURE;

	/* Called by host to terminate the StdComponentMgr.
		If fRevoke is TRUE and StdComponentMgr is registered as the current
		thread's component manager, this registration is revoked.
		Then, for each registered component, StdComponentMgr calls 
		IMsoComponent::Terminate and revokes its registration. */
	MSOMETHOD_(void, Terminate) (THIS_ BOOL fRevoke) PURE;
	};


/****************************************************************************
	Defines the IMsoComponentHost interface

	IMsoComponentHost is a host implemented interface that the standard
	component manager uses to communicate with the host.  By implementing
	this interface and making use of the standard component manager, the host
	can avoid having to implement its own component manager. 
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoComponentHost

DECLARE_INTERFACE_(IMsoComponentHost, IUnknown)
	{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* StdComponentMgr delegates calls to IMsoComponentManager::QueryService
		to the host by calling this method.
		Return in *ppvObj an implementation of interface iid for service
		guidService (same as IServiceProvider::QueryService).
		Return NOERROR if the requested service is supported, otherwise return
		NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE). */
	MSOMETHOD(QueryService) (THIS_
		REFGUID guidService, REFIID iid, void **ppvObj) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoComponentHost is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Called when component pic is activated (or should be treated as active
		by virtue of beginning a "tracking" operation 
		(see IMsoComponentManager::FSetTrackingComponent)).  
		pcrinfo contains component's registration information.  
		fTracking indicates whether the component is in tracking mode or not.
		If pic is NULL (in which case pcrinfo will be NULL), then this 
		indicates that no component is active.  
		When a component is active and its registration info indicates that it
		needs to process untranslated messages, the host must call 
		IMsoStdComponentMgr::FPreTranslateMessage for each appropriate message
		retrieved from the queue before processing it, so that the active 
		component gets a chance to process the message appropriately.
		(A simple host could avoid examining the component's registration info,
		 and simply call IMsoStdComponentMgr::FPreTranslateMessage for all
		 retrieved messages.)
		If the component is in tracking mode, as indicated by fTracking, then
		the host app should perform no idle time processing other than to give
		the tracking component idle time via IMsoStdComponentMgr::FDoIdle,
		until the tracking operation is completed (communicated to host via a
		subsequent call to OnComponentActivate with fTracking == FALSE).

		Additionally, if pic is nonNULL and fTracking is FALSE, then host 
		should check if pcrinfo->grfcrf has the ExclusiveActive or 
		ExclusiveBorderSpace bit set.  
		
		If ExclusiveBorderSpace bit is set, then host should hide its border
		space tools (toolbars, status bars, etc.) and not show them again until
		the host is reactivated.
		
		If ExclusiveActivation bit is set, then pic is being activated in
		"ExclusiveActive" mode.
		Host should retrieve the top frame window that is hosting pic 
		(via pic->HwndGetWindow(msocWindowFrameToplevel, 0)).  
		If this window is different from host's own top frame window, 
			host should disable its windows and do other things it would do
			when receiving OnComponentEnterState(msocstateModal, TRUE)
			notification. 
		Otherwise, 
			host should refuse to have its window activated by appropriately
			processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
		Host should remain in this state until the ExclusiveActive mode ends, 
		indicated by a future call to OnComponentActivate (with FALSE 
		fTracking) with ExclusiveActivation bit not set or NULL pcrinfo. */
	MSOMETHOD_(void, OnComponentActivate) (THIS_
		IMsoComponent *pic, const MSOCRINFO *pcrinfo, BOOL fTracking) PURE;
	
	/* Notify host that a component is entering or exiting (indicated by 
		fEnter) the state identified by uStateID (a msocstateXXX value).  
		Host should take action depending on value of uStateID (see msocstate
		comments, above). 
		
		Note: If n calls are made with TRUE fEnter, the host should consider
		the state to be in effect until n calls are made with FALSE fEnter.

		Note: Hosts should be aware that it is possible for this method to
		be called with FALSE fEnter more	times than it was called with TRUE 
		fEnter (so, for example, if host is maintaining a state counter
		(incremented when this method is called with TRUE fEnter, decremented
		when called with FALSE fEnter), the counter should not be decremented
		for FALSE fEnter if it is already at zero.)  */
	MSOMETHOD_(void, OnComponentEnterState) (THIS_
		ULONG uStateID, BOOL fEnter) PURE;
	
	/* Called periodically by StdComponentMgr during 
		IMsoStdComponentMgr::FDoIdle.
		Return TRUE if idle time processing can continue, FALSE if not. */
	MSOMETHOD_(BOOL, FContinueIdle) (THIS) PURE;

	/* Called by StdComponentMgr when a component wishes to push a message
		loop for reason uReason.
		uReason is one the values from the msoloop enumeration (above).
		The host should push its message loop, calling
		IMsoStdComponentMgr::FContinueMessageLoop during each loop iteration 
		(see IMsoStdComponentMgr::FContinueMessageLoop comments).
		When IMsoStdComponentMgr::FContinueMessageLoop returns FALSE, the host
		should terminate the loop. */
	MSOMETHOD_(BOOL, FPushMessageLoop) (THIS_ ULONG uReason) PURE;
	};



/****************************************************************************
	Structures and constants for simple recording.
****************************************************************************/

// Simple recorder context values passed to IMsoSimpleRecorder::FGetContext
enum
	{
	msosrctxCommandBars = 0,			// pv will be the IMsoToolbarSet object
	msosrctxEscher = 1,
	msosrctxDrawing = 2,
	msosrctxDrawingSelection = 3,
	msosrctxDrawingSchemeColor = 4,
	msosrctxDrawingDefault = 5,
	};

/****************************************************************************
	Defines the IMsoSimpleRecorder interface
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoSimpleRecorder

DECLARE_INTERFACE_(IMsoSimpleRecorder, IUnknown)
{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoSimpleRecorder is a reference counted interface, 
	   MsoDWGetChkMemCounter is used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Returns a string specifying the position of the requested context
	   in the host's object model.  The context is specified by msosrctx, 
	   and the additional value pv if needed to disambiguate different 
	   objects of that type.  The string buffer should have room for
	   255 characters.  Returns TRUE if successful, FALSE otherwise. */
	MSOMETHOD_(BOOL, FGetContext)(THIS_ int msosrctx, void *pv, WCHAR *wz) PURE;

	/* Asks the host to record a line of text at the current position
	   in the recorder stream.  Returns TRUE if the line was successfully
	   recorded, FALSE otherwise. */
	MSOMETHOD_(BOOL, FRecordLine)(THIS_ WCHAR *wz) PURE;

	/* Returns TRUE if the host currently has recording turned on, and
	   FALSE otherwise. */
	MSOMETHOD_(BOOL, FRecording)(THIS) PURE;
};



/****************************************************************************
	Global DLL API's
****************************************************************************/

/* Called by host application to register picm as the component manager for
	the calling thread.  Standard reference counting rules apply.  
	picm can be NULL, indicating that the currently	registered component 
	manager should be revoked.
	If there is a previously registered component manager it is Released.
	Returns TRUE if successful. */
MSOAPI_(BOOL) MsoFSetComponentManager(IMsoComponentManager *picm);

/* Return in *ppicm an AddRef'ed pointer to the currently registered
	component manager for the calling thread.
	Returns TRUE if successful. */
MSOAPI_(BOOL) MsoFGetComponentManager(IMsoComponentManager **ppicm);

/* Create an object which has the Office supplied standard implementation
	of IMsoStdComponentMgr and IMsoComponentManager, and return it in *ppvObj.
	piUnkOuter is the controlling unknown for aggregation (can be NULL).
	pich (cannot be NULL) is the pointer to the IMsoComponentHost
	that will use the object.
	riid is the id of the desired interface.
	If fRegister is TRUE, the created object is registered as the calling
	thread's component manager.
	Returns TRUE if successful. */
MSOAPI_(BOOL) MsoFCreateStdComponentManager(
	IUnknown *piUnkOuter,
	IMsoComponentHost *pich,
	BOOL fRegister,
	REFIID riid,
	void **ppvObj);

///////////////////////////////////////////////////////////////////////////////
// DevStudio Change
//
// Since MSOffice is a DLL, they get process/thread attach/detach messages,
// but this is now a statically linked library, so we have to have these API
// called at process/thread init/term time in order to handle our TLS data.
MSOAPI_(BOOL) CMLibInit(HINSTANCE hinstHost);
MSOAPI_(void) CMLibTerm();


#endif // CMPMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\cmalloc.h ===
/*************************************************************************
 	msoalloc.h

 	Owner: rickp
 	Copyright (c) 1994 Microsoft Corporation

	Standard memory manager routines for the Office world.
*************************************************************************/

#if !defined(CMALLOC_H)
#define CMALLOC_H

/*************************************************************************
	The Plex data structure.  A plex is a low-overhead implementation
	of a varible-sized array.
*************************************************************************/

/* The generic plex structure itself */
typedef struct MSOPX
{
	/* WARNING: the following must line up with the MSOTPX template and
		the MsoPxStruct macro */
	WORD iMac, iMax;	/* used size, and total allocated size */
	unsigned cbItem:16,	/* size of each data item */
		dAlloc:15,	/* amount to grow by when reallocating larger */
		fUseCount:1;	/* if items in the plex should be use-counted */
	int dg;	/* data group to allocate out of */
	BYTE* rg;	/* the data */
} MSOPX;


/*	Handy macro for declaring a named Plex structure - must line up with
	the MSOPX structure */
#define MsoPxStruct(TYP,typ) \
		struct \
		{ \
		WORD i##typ##Mac, i##typ##Max; \
		unsigned cbItem:16, \
			dAlloc:15, \
			fUseCount:1; \
		int dg; \
		TYP *rg##typ; \
		}

/* Handy macro for enumerating over all the items in a plex ppl, using loop
	variables p and pMac */
#define FORPX(p, pMac, ppl, T) \
		for ((pMac) = ((p) = (T*)((MSOPX*)(ppl))->rg) + ((MSOPX*)(ppl))->iMac; \
			 (p) < (pMac); (p)++)

/* Handy macro for enumerating over all the items in a plex ppl backwards,
	using loop variables p and pMac */
#define FORPX2(p, pMac, ppl, T) \
		for ((p) = ((pMac) = (T*)((MSOPX*)(ppl))->rg) + ((MSOPX*)(ppl))->iMac - 1; \
			 (p) >= (pMac); (p)--)


/*************************************************************************
	Creation and destruction
*************************************************************************/

MSOAPI_(BOOL) MsoFInitPx(void* pvPx, int dAlloc, int iMax);

/*************************************************************************
	Lookups
*************************************************************************/

typedef int (MSOPRIVCALLTYPE* MSOPFNSGNPX)(const void*, const void*);

MSOAPIXX_(void*) MsoPLookupPx(void* pvPx, const void* pvItem, MSOPFNSGNPX pfnSgn);
MSOAPI_(BOOL) MsoFLookupPx(void* pvPx, const void* pvItem, int* pi, MSOPFNSGNPX pfnSgn);

MSOAPI_(int) MsoFLookupSortPx(void* pvPx, const void* pvItem, int* pi, MSOPFNSGNPX pfnSgn);


/*************************************************************************
	Adding items
*************************************************************************/

#define MsoFAppendPx(pvPx, pv) (MsoIAppendPx(pvPx, pv) >= 0)
MSOAPI_(int) MsoIAppendPx(void* pvPx, const void* pv);
MSOAPI_(int) MsoIAppendPx(void* pvPx, const void* pv);
MSOAPI_(int) MsoIAppendUniquePx(void* pvPx, const void* pv, MSOPFNSGNPX pfnSgn);

MSOAPI_(int) MsoIInsertSortPx(void* pvPx, const void* pv, MSOPFNSGNPX pfnSgn);
MSOAPI_(BOOL) MsoFInsertPx(void* pvPx, const void* pv, int i);
MSOAPIXX_(BOOL) MsoFInsertExPx(void* pvPx, const void* pv, int i);

/*************************************************************************
	Removing items
*************************************************************************/

MSOAPI_(int) MsoFRemovePx(void* pvPx, int i, int c);
MSOAPI_(void) MsoDeletePx(void* pvPx, int i, int c);


/*************************************************************************
	Miscellaneous shuffling around
*************************************************************************/

MSOAPIXX_(void) MsoMovePx(void* pvPx, int iFrom, int iTo);
MSOAPI_(BOOL) MsoFCompactPx(void* pvPx, BOOL fFull);
MSOAPI_(BOOL) MsoFResizePx(void* pvPx, int iMac, int iIns);
MSOAPI_(BOOL) MsoFGrowPx(void* pvPx, int iMac);
MSOAPI_(void) MsoStealPx(void *pvPxSrc, void *pvPxDest);
MSOMACAPI_(void) MsoEmptyPx(void *pvPx);
MSOMACAPI_(BOOL) MsoFClonePx(void *pvPxSrc, void *pvPxDest, int dg);


/*************************************************************************
	Plex with use count items utilities
*************************************************************************/

MSOAPI_(int) MsoIIncUsePx(void* pvPx, int i);
MSOAPI_(int) MsoIDecUsePx(void* pvPx, int i);

/*************************************************************************
	Debug stuff
*************************************************************************/

#if DEBUG
	MSOAPI_(BOOL) MsoFValidPx(const void* pvPx);
	MSOAPI_(BOOL) MsoFWritePxBe2(void* pvPx, LPARAM lParam, BOOL fSaveObj, 
											BOOL fAllocHasSize);
#else
	#define MsoFValidPx(pvPx) (TRUE)
#endif



/*************************************************************************
	Plex class template - this is basically a big inline class wrapper 
	around the C plex interface.
*************************************************************************/

#ifdef __cplusplus

template <class S> class MSOTPX
{
public:
	/* WARNING: the following must line up exactly with the MSOPX structure */
	WORD iMac, iMax;	/* used size, and total allocated size */
	unsigned cbItem:16,	/* size of each data item */
		dAlloc:15,	/* amount to grow by when reallocating larger */
		fUseCount:1;	/* if items in the plex should be use-counted */
	int dg;	/* data group to allocate out of */
	S* rg;	/* the data */

	/* Unexciting constructor. */
	inline MSOTPX<S>(void) 
	{ iMax = iMac = 0; cbItem = sizeof(S); rg = NULL; }

	/* Destructor to deallocate memory */
	inline ~MSOTPX<S>(void) 
	{ if (rg) free(rg); }

	inline BOOL FValid(void) const
	{ return MsoFValidPx(this); }

	inline BOOL FInit(int dAlloc, int iMax)
	{ return MsoFInitPx(this, dAlloc, iMax); }

	inline int IMax(void) const
	{ return iMax; }

	inline int IMac(void) const
	{ return iMac; }

	inline S* PGet(int i) const
	{  return &rg[i]; }

	inline void Get(S* p, int i) const
	{	AssertMsgTemplate(i >=0 && i < iMac, NULL); *p = rg[i]; }

	inline void Put(S* p, int i)
	{	AssertMsgTemplate(i >=0 && i < iMac, NULL); rg[i] = *p; }

	// plex[i] has exactly the same semantics and performance as plex.rg[i]
	inline S& operator[](int i)
	{	AssertMsgTemplate(i >=0 && i < iMac, NULL); return rg[i]; }

	inline S* PLookup(S* pItem, MSOPFNSGNPX pfnSgn)
	{ return (S*)MsoPLookupPx(this, pItem, pfnSgn); }

	inline BOOL FLookup(S* pItem, int* pi, MSOPFNSGNPX pfnSgn)
	{ return MsoFLookupPx(this, pItem, pi, pfnSgn); }

	inline BOOL FLookupSort(S* pItem, int* pi, MSOPFNSGNPX pfnSgn)
	{ return MsoFLookupSortPx(this, pItem, pi, pfnSgn); }

	inline int FAppend(S* p)
	{ return MsoIAppendPx(this, p) != -1; }

	inline int IAppend(S* p)
	{ return MsoIAppendPx(this, p); }

	inline int IAppendUnique(S* p, MSOPFNSGNPX pfnSgn)
	{ return MsoIAppendUniquePx(this, p, pfnSgn); }

	inline BOOL FInsert(S* p, int i)
	{ return MsoFInsertPx(this, p, i); }

	inline int FInsertEx(S* p, int i)
	{ return MsoFInsertExPx(this, p, i); }

	inline int IInsertSort(S* p, MSOPFNSGNPX pfnSgn)
	{ return MsoIInsertSortPx(this, p, pfnSgn); }

	inline int FRemove(int i, int c)
	{ return MsoFRemovePx(this, i, c); }

	inline void Delete(int i, int c)
	{ MsoDeletePx(this, i, c); }

	inline void Move(int iFrom, int iTo)
	{ MsoMovePx(this, iFrom, iTo); }

	inline BOOL FCompact(BOOL fFull)
	{ return MsoFCompactPx(this, fFull); }

	inline BOOL FResize(int iMac, int iIns)
	{ return MsoFResizePx(this, iMac, iIns); }

	inline BOOL FReplace(S* p, int i)
	{ 
		if (i >= iMac && !FSetIMac(i+1))
			return FALSE; 
		rg[i] = *p;
		return TRUE;
	}

	inline BOOL FSetIMac(int iMac)
	{ return MsoFResizePx(this, iMac, -1); }

	inline BOOL FSetIMax(int iMax)
	{ return MsoFGrowPx(this, iMax); }

	inline int IIncUse(int i)
	{ return MsoIIncUsePx(this, i); }

	inline int IDecUse(int i)
	{ return MsoIDecUsePx(this, i); }

	inline void Steal(void *pvPxSrc)
	{ MsoStealPx(pvPxSrc, this); }

	inline void Empty()
	{ MsoEmptyPx(this); }

	inline BOOL FClone(void *pvPxDest, int dg)
	{ return MsoFClonePx(this, pvPxDest, dg); }

#if DEBUG
	inline BOOL FWriteBe(LPARAM lParam, BOOL fSaveObj)
	{ return MsoFWritePxBe2(this, lParam, fSaveObj, TRUE); }
#endif

};

#endif /* __cplusplus */


#endif /* CMALLOC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\cmguids.h ===
/****************************************************************************
	MsoGUIDs.h

	Owner: DavePa
	Copyright (c) 1994 Microsoft Corporation

	This file defines (if INIT_MSO_GUIDS is defined) or declares all the 
	OLE GUIDs exported by Office.

	Office Development has reserved GUIDs in the range:
		000Cxxxx-0000-0000-C000-000000000046

****************************************************************************/

#ifndef CMGUIDS_H
#define CMGUIDS_H

/* If INIT_MSO_GUIDS is defined then we're going to define all the GUIDS, 
	otherwise we'll just declare them.  Office GUIDS are specified by
	a category 0x00-0xFF and an index 0x00-0xFF. */
#undef DEFINE_MSO_GUID


#ifdef INIT_MSO_GUIDS

	#define DEFINE_MSO_GUID(name, bCategory, bIndex) \
		EXTERN_C const GUID name = {0x000C0000 | MAKEWORD(bIndex, bCategory), \
													  0, 0, {0xC0,0,0,0,0,0,0,0x46}}
#else

	#define DEFINE_MSO_GUID(name, bCategory, bIndex) \
		EXTERN_C const GUID name
		
#endif


/****************************************************************************
	Office GUIDS are specified by a category 0x00-0xFF and an index 0x00-0xFF. 
****************************************************************************/

// Category 6: Component Integration GUIDs
DEFINE_MSO_GUID(IID_IMsoComponent,              0x06, 0x00);
DEFINE_MSO_GUID(IID_IMsoComponentManager,       0x06, 0x01);
DEFINE_MSO_GUID(IID_IMsoStdComponentMgr,        0x06, 0x02);
DEFINE_MSO_GUID(IID_IMsoComponentHost,          0x06, 0x03);
DEFINE_MSO_GUID(IID_IMsoInPlaceComponent,       0x06, 0x04);
DEFINE_MSO_GUID(IID_IMsoInPlaceComponentSite,   0x06, 0x05);
DEFINE_MSO_GUID(IID_IMsoComponentUIManager,     0x06, 0x06);
DEFINE_MSO_GUID(IID_IMsoSimpleRecorder,         0x06, 0x07);
DEFINE_MSO_GUID(SID_SMsoComponentUIManager,     0x06, 0x08);
DEFINE_MSO_GUID(SID_SMsoSimpleRecorder,         0x06, 0x09);
DEFINE_MSO_GUID(IID_IMsoInPlaceComponentUIManager, 0x06, 0x0A);
DEFINE_MSO_GUID(SID_SMsoComponentManager,       0x06, 0x0B);

#endif	// CMGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\cmuser.h ===
/****************************************************************************
	MsoUser.h

	Owner: DavePa
 	Copyright (c) 1994 Microsoft Corporation

	Declarations for common functions and interfaces required for apps
	to use the Office DLL.
****************************************************************************/

#ifndef CMUSER_H
#define CMUSER_H

#ifndef MSO_NO_INTERFACES
interface IMsoControlContainer;
#endif // MSO_NO_INTERFACES


/****************************************************************************
	The ISimpleUnknown interface is a variant on IUnknown which supports
	QueryInterface but not reference counts.  All objects of this type
	are owned by their primary user and freed in an object-specific way.
	Objects are allowed to extend themselves by supporting other interfaces
	(or other versions of the primary interface), but these interfaces
	cannot be freed without the knowledge and cooperation of the object's 
	owner.  Hey, it's just like a good old fashioned data structure except
	now you can extend the interfaces.
****************************************************************** DAVEPA **/

#undef  INTERFACE
#define INTERFACE  ISimpleUnknown

DECLARE_INTERFACE(ISimpleUnknown)
{
	/* ISimpleUnknown's QueryInterface has the same semantics as the one in
		IUnknown, except that QI(IUnknown) succeeds if and only if the object
		also supports any real IUnknown interfaces, QI(ISimpleUnknown) always
		succeeds, and there is no implicit AddRef when an non-IUnknown-derived
		interface is requested.  If an object supports both IUnknown-derived
		and ISimpleUnknown-derived interfaces, then it must implement a 
		reference count, but all active ISimpleUnknown-derived interfaces count
		as a single reference count. */
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
};


/****************************************************************************
	HMSOINST is an opaque reference to an Office instance record.  Each
	thread of each EXE or DLL that uses Office must call MsoFInitOffice
	to init Office and get an HMSOINST.

	not anymore -- now it is just something that we ignore and if caller
	passes a pointer, we don't use it. erickn
****************************************************************** DAVEPA **/
#ifndef HMSOINST
typedef void* HMSOINST;  // just make this an ignorable pointer - erickn
#endif

#endif // CMUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\icapexp.h ===
/*****************************************************************************/
/*                                                                           */
/*    ICAPEXP.H -- Exports from ICAP.DLL				     */
/*									     */
/*    Copyright (C) 1995 by Microsoft Corp.				     */
/*    All rights reserved						     */
/*									     */
/*****************************************************************************/

#ifndef __ICAPEXP_H__
#define __ICAPEXP_H__

#ifndef PROFILE
#define PROFILE 1		// define this as zero to macro-out the API
#endif

#if PROFILE

#ifdef __cplusplus
extern "C"
{
#endif

int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling

int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling

#ifdef __cplusplus
}
#endif

#else // NOT PROFILE

#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0

#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0

#endif // NOT PROFILE

#endif  // __ICAPEXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\ime32.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1985-92, Microsoft Corporation

Module Name:

    ime.h

Abstract:

    Procedure declarations, constant definitions and macros for the IME
    component.

--*/

#ifndef _IME_
#define _IME_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#ifdef KOREA     // BeomOh - 10/05/92
#define CP_HWND                 0
#define CP_OPEN                 1
#define CP_DIRECT               2
#define CP_LEVEL                3

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)
#endif // KOREA

//
//      Virtual Keys
//
#ifdef KOREA    // BeomOh - 9/29/92
#define VK_FINAL        0x18    /* dummy VK to make final on mouse down */
#define VK_CONVERT      0x1C
#define VK_NONCONVERT   0x1D
#define VK_ACCEPT       0x1E
#define VK_MODECHANGE   0x1F
#else // KOREA
#define VK_DBE_ALPHANUMERIC              0x0f0
#define VK_DBE_KATAKANA                  0x0f1
#define VK_DBE_HIRAGANA                  0x0f2
#define VK_DBE_SBCSCHAR                  0x0f3
#define VK_DBE_DBCSCHAR                  0x0f4
#define VK_DBE_ROMAN                     0x0f5
#define VK_DBE_NOROMAN                   0x0f6
#define VK_DBE_ENTERWORDREGISTERMODE     0x0f7
#define VK_DBE_ENTERIMECONFIGMODE        0x0f8
#define VK_DBE_FLUSHSTRING               0x0f9
#define VK_DBE_CODEINPUT                 0x0fa
#define VK_DBE_NOCODEINPUT               0x0fb
#define VK_DBE_DETERMINESTRING           0x0fc
#endif // KOREA


//
//     switch for wParam of IME_SETCONVERSIONWINDOW
//
#define	MCW_DEFAULT             0x00
#define	MCW_RECT                0x01
#define MCW_WINDOW              0x02
#define MCW_SCREEN              0x04
#define	MCW_VERTICAL            0x08
#define MCW_HIDDEN              0x10

//
//    switch for wParam of IME_SETCONVERSIONMODE
//       and IME_GETCONVERSIONMODE
//
#define IME_MODE_ALPHANUMERIC	0x0001
#ifdef KOREA    // BeomOh - 9/29/92
#define IME_MODE_SBCSCHAR       0x0002
#define IME_MODE_HANJACONVERT   0x0004
#else
#define IME_MODE_KATAKANA	0x0002
#define IME_MODE_HIRAGANA	0x0004
#define IME_MODE_SBCSCHAR	0x0008
#define IME_MODE_DBCSCHAR	0x0010
#define IME_MODE_ROMAN		0x0020
#define IME_MODE_NOROMAN	0x0040
#define IME_MODE_CODEINPUT	0x0080
#define IME_MODE_NOCODEINPUT	0x0100
//
// 0x1, 0x2, 0x4, 0x20, 0x40, 0x80, 0x100 is not for CWIN  ;Internal
// 0x8, 0x10, and below IME_MODE_??? will be use by CWIN   ;Internal
//
#endif

//
//     IME APIs
//
#define IME_GETIMECAPS            0x03
#define IME_SETOPEN               0x04
#define	IME_GETOPEN               0x05
#define IME_GETVERSION            0x07
#define IME_SETCONVERSIONWINDOW   0x08
#ifdef  KOREA
#define IME_MOVEIMEWINDOW         IME_SETCONVERSIONWINDOW
#else
#endif
#define IME_SETCONVERSIONMODE     0x10
#ifdef KOREA    // BeomOh - 10/23/92
#define IME_SET_MODE              0x12
#else
#endif
#define IME_GETCONVERSIONMODE     0x11
#define IME_SENDVKEY              0x13
#define IME_ENTERWORDREGISTERMODE 0x18
#define IME_SETCONVERSIONFONTEX   0x19
#ifdef  KOREA   // 01/12/93 KDLee MSCH
#define IME_GETMNTABLE            0x42  // reserved for HWIN ;Internal
#endif

//#ifdef PEN                                    ;Internal
//#endif                                        ;Internal

#ifdef KOREA    // BeomOh - 9/29/92
//
// IME_CODECONVERT subfunctions
//
#define IME_BANJAtoJUNJA        0x13
#define IME_JUNJAtoBANJA        0x14
#define IME_JOHABtoKS           0x15
#define IME_KStoJOHAB           0x16

//
// IME_AUTOMATA subfunctions
//
#define IMEA_INIT               0x01
#define IMEA_NEXT               0x02
#define IMEA_PREV               0x03

//
// IME_HANJAMODE subfunctions
//
#define IME_REQUEST_CONVERT     0x01
#define IME_ENABLE_CONVERT      0x02

//
// IME_MOVEIMEWINDOW subfunctions
//
#define INTERIM_WINDOW          0x00
#define MODE_WINDOW             0x01
#define HANJA_WINDOW            0x02
#endif // KOREA

//
//







// CTRL_MODIFY is "or" all modify bits, but now only one

//
//    error code
//
#define IME_RS_ERROR            0x01    // genetal error
#define IME_RS_NOIME            0x02    // IME is not installed
#define IME_RS_TOOLONG          0x05    // given string is too long
#define IME_RS_ILLEGAL          0x06    // illegal charactor(s) is string
#define IME_RS_NOTFOUND         0x07    // no (more) candidate
#define IME_RS_NOROOM           0x0a    // no disk/memory space
#define IME_RS_DISKERROR        0x0e    // disk I/O error
#define IME_RS_INVALID          0x11    // Win3.1/NT
#define IME_RS_NEST             0x12    // called nested
#define IME_RS_SYSTEMMODAL      0x13    // called when system mode

//
//   report messge from IME to WinApps
//
#define WM_IME_REPORT		0x0280

//
//   report message parameter for WM_IME_REPORT
//
#define IR_STRINGSTART		0x100
#define IR_STRINGEND		0x101
#define IR_OPENCONVERT		0x120
#define IR_CHANGECONVERT	0x121
#define IR_CLOSECONVERT		0x122
#define IR_FULLCONVERT		0x123
#define IR_IMESELECT		0x130
#define IR_STRING		0x140
#define IR_DBCSCHAR             0x160
#define IR_UNDETERMINE          0x170
#define IR_STRINGEX             0x180   // New for 3.1

#define WM_IMEKEYDOWN           0x290
#define WM_IMEKEYUP             0x291


LRESULT WINAPI SendIMEMessageExA(HWND, LPARAM);
LRESULT WINAPI SendIMEMessageExW(HWND, LPARAM);
#ifdef UNICODE
#define SendIMEMessageEx  SendIMEMessageExW
#else
#define SendIMEMessageEx  SendIMEMessageExA
#endif // !UNICODE

#ifndef _WINDEF_
typedef unsigned int UINT;
#endif // _WINDEF_

//
// IMESTRUCT structure for SendIMEMessageEx
//
typedef struct tagIMESTRUCT {
    UINT     fnc;        // function code
    WPARAM   wParam;     // word parameter
    UINT     wCount;     // word counter
    UINT     dchSource;  // offset to Source from top of memory object
    UINT     dchDest;    // offset to Desrination from top of memory object
    LPARAM   lParam1;
    LPARAM   lParam2;
    LPARAM   lParam3;
} IMESTRUCT,*PIMESTRUCT,NEAR *NPIMESTRUCT,FAR *LPIMESTRUCT;




//
// UNDETERMINESTRING structure for IR_UNDETERMINE
//
typedef struct tagUNDETERMINESTRUCT {
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT,*PUNDETERMINESTRUCT,NEAR *NPUNDETERMINESTRUCT,FAR *LPUNDETERMINESTRUCT;


typedef struct tagSTRINGEXSTRUCT {
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT,NEAR *NPSTRINGEXSTRUCT,FAR *LPSTRINGEXSTRUCT;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _IME_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\objext.h ===
#pragma pack(push, 8) 
//+------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//  
//  File:       objext.h
//  
//  Contents:   header file for Object Extensions interfaces
//  
//-------------------------------------------------------------------------

#ifndef __OBJEXT_H
#define __OBJEXT_H

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

///////////////////////////////////////////////////////////////////////////
//
// forward declares
//
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//
// Object Extension Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  IServiceProvider Interface
//    This interface is implemented by an object that wish to provide "services"
//
//-------------------------------------------------------------------------
#ifndef __IServiceProvider_INTERFACE_DEFINED
#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED
#define __IServiceProvider_INTERFACE_DEFINED__


// { 6d5140c1-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IServiceProvider, 0x6d5140c1, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IServiceProvider
DECLARE_INTERFACE_(IServiceProvider, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IServiceProvider methods ***
    STDMETHOD(QueryService)(THIS_
                /* [in]  */ REFGUID rsid,
                /* [in]  */ REFIID iid,
                /* [out] */ void ** ppvObj) PURE;
};

#endif // __IServiceProvider_INTERFACE_DEFINED__
#endif // __IServiceProvider_INTERFACE_DEFINED

//-------------------------------------------------------------------------
//  IClassDesigner Interface
//    This interface is implemented by a class object that can be customized
//
//-------------------------------------------------------------------------

// { 6d5140d3-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IClassDesigner, 0x6d5140d3, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

typedef DWORD ACTFLAG;
#define ACT_DEFAULT 0x00000000
#define ACT_SHOW    0x00000001

#undef  INTERFACE
#define INTERFACE  IClassDesigner
DECLARE_INTERFACE_(IClassDesigner, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IClassDesigner methods ***
    STDMETHOD(SetSite)(THIS_
               /* [in]  */ IServiceProvider * pSP) PURE;
    STDMETHOD(GetSite)(THIS_
               /* [out] */ IServiceProvider** ppSP) PURE;
    STDMETHOD(GetCompiler)(THIS_
               /* [in]  */ REFIID iid,
               /* [out] */ void **ppvObj) PURE;
    STDMETHOD(ActivateObject)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(IsObjectShowable)(THIS) PURE;
    STDMETHOD(GetExtensibilityObject)(THIS_ 
                      /* [out] */ IDispatch ** ppDisp) PURE;
};

///////////////////////////////////////////////////////////////////////////
//
// Standard Services and Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  SLicensedClassManager
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILicensedClassManager
//-------------------------------------------------------------------------
// { 6d5140d0-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IRequireClasses, 0x6d5140d0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IRequireClasses
DECLARE_INTERFACE_(IRequireClasses, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IRequireClasses methods ***
    STDMETHOD(CountRequiredClasses)(THIS_
                    /* [out] */ ULONG * pcClasses ) PURE;
    STDMETHOD(GetRequiredClasses)(THIS_
                  /* [in]  */ ULONG index,
                  /* [out] */ CLSID * pclsid ) PURE;
};

// { 6d5140d4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILicensedClassManager, 0x6d5140d4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLicensedClassManager  IID_ILicensedClassManager

#undef  INTERFACE
#define INTERFACE  ILicensedClassManager
DECLARE_INTERFACE_(ILicensedClassManager, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILicensedClassManager methods ***
    STDMETHOD(OnChangeInRequiredClasses)(THIS_
                     /* [in] */ IRequireClasses *pRequireClasses) PURE;
};

//-------------------------------------------------------------------------
//  SCreateExtendedTypeLib Service
//    This service is used by components to create a typelib
//    describing controls merged with their extender
//
//  interfaces implemented:
//    ICreateExtendedTypeLib
//-------------------------------------------------------------------------
// { 6d5140d6-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IExtendedTypeLib, 0x6d5140d6, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SExtendedTypeLib IID_IExtendedTypeLib

#undef  INTERFACE
#define INTERFACE  IExtendedTypeLib
DECLARE_INTERFACE_(IExtendedTypeLib, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IExtendedTypeLib ***
    STDMETHOD(CreateExtendedTypeLib)(THIS_
                     /* [in]  */ LPCOLESTR lpstrCtrlLibFileName,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeLib  **pptlib) PURE;

    STDMETHOD(AddRefExtendedTypeLib)(THIS_
                     /* [in]  */ LPCOLESTR lpstrCtrlLibFileName,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD	   dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeLib  **pptlib) PURE;
    STDMETHOD(AddRefExtendedTypeLibOfClsid)(THIS_
                     /* [in]  */ REFCLSID rclsidControl,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeInfo **pptinfo) PURE;
    STDMETHOD(SetExtenderInfo)(THIS_ 
		     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ DWORD     dwReserved) PURE;
};

//-------------------------------------------------------------------------
//  SCreateExtension Service
//    This service is used by Instance customized objects to 
//    create the VBA extension
//
//  interfaces implemented:
//    ICreateExtension
//-------------------------------------------------------------------------

// { 6d5140d2-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ICreateExtension, 0x6d5140d2, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SCreateExtension IID_ICreateExtension

#undef  INTERFACE
#define INTERFACE  ICreateExtension
DECLARE_INTERFACE_(ICreateExtension, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICreateExtension methods ***
    STDMETHOD(CreateExtension)(THIS_
                   /* [in]  */ IUnknown *punkOuter,
                   /* [in]  */ IUnknown *punkBase,
                   /* [in]  */ IUnknown *punkExtender,
                   /* [out] */ IUnknown **ppunkExtension) PURE;
};

//-------------------------------------------------------------------------
//  SCodeNavigate Service.
//    This service let's an extended object show the code module
//    behind it.
//
//  interfaces implemented:
//    ICodeNavigate
//-------------------------------------------------------------------------

// { 6d5140c4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ICodeNavigate, 0x6d5140c4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SCodeNavigate IID_ICodeNavigate

#undef  INTERFACE
#define INTERFACE  ICodeNavigate
DECLARE_INTERFACE_(ICodeNavigate, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICodeNavigate methods ***
    STDMETHOD(DisplayDefaultEventHandler)(THIS_ /* [in] */ LPCOLESTR lpstrObjectName) PURE;
};

//-------------------------------------------------------------------------
//  STrackSelection Service
//    This service is used by the VBA host to help VBA track the
//    currently selected object in the host
//
//  interfaces implemented:
//    ITrackSelection
//-------------------------------------------------------------------------
#define GETOBJS_ALL         1
#define GETOBJS_SELECTED    2

#define SELOBJS_ACTIVATE_WINDOW   1

// { 6d5140c6-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ISelectionContainer, 0x6d5140c6, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  ISelectionContainer
DECLARE_INTERFACE_(ISelectionContainer, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ISelectionContainer methods ***
    STDMETHOD(CountObjects)(THIS_
                /* [in]  */ DWORD dwFlags, 
                /* [out] */ ULONG * pc) PURE;
    STDMETHOD(GetObjects)(THIS_
              /* [in]  */ DWORD dwFlags, 
              /* [in]  */ ULONG cObjects,
              /* [out] */ IUnknown **apUnkObjects) PURE;
    STDMETHOD(SelectObjects)(THIS_
              /* [in] */ ULONG cSelect,
              /* [in] */ IUnknown **apUnkSelect,
              /* [in] */ DWORD dwFlags) PURE;
};

// { 6d5140c5-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ITrackSelection, 0x6d5140c5, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_STrackSelection IID_ITrackSelection

#undef  INTERFACE
#define INTERFACE  ITrackSelection
DECLARE_INTERFACE_(ITrackSelection, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ITrackSelection methods ***
    STDMETHOD(OnSelectChange)(THIS_ 
                  /* [in] */ ISelectionContainer * pSC) PURE;
};

//-------------------------------------------------------------------------
//  SLocalRegistry Service
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILocalRegistry
//-------------------------------------------------------------------------

// { 6d5140d3-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILocalRegistry, 0x6d5140d3, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLocalRegistry IID_ILocalRegistry

#undef  INTERFACE
#define INTERFACE  ILocalRegistry
DECLARE_INTERFACE_(ILocalRegistry, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILocalRegistry methods ***
    STDMETHOD(CreateInstance)(THIS_
                  /* [in]  */ CLSID      clsid,     
                  /* [in]  */ IUnknown * punkOuter,
                  /* [in]  */ REFIID     riid,
                  /* [in]  */ DWORD      dwFlags,
                  /* [out] */ void **    ppvObj ) PURE;
    STDMETHOD(GetTypeLibOfClsid)(THIS_
                 /* [in]  */ CLSID       clsid,
                 /* [out] */ ITypeLib ** ptlib ) PURE;
    STDMETHOD(GetClassObjectOfClsid)(THIS_
                     /* [in]  */ REFCLSID clsid,
                                 /* [in]  */ DWORD    dwClsCtx,
                     /* [in]  */ LPVOID   lpReserved,
                     /* [in]  */ REFIID   riid,
                     /* [out] */ void **  ppcClassObject ) PURE;
};

//-------------------------------------------------------------------------
//  IUIElement interface
//    components can implement services to allow external control of pieces 
//    of their UI by implementing this interface
//
//-------------------------------------------------------------------------
// { 759d0500-d979-11ce-84ec-00aa00614f3e }
DEFINE_GUID(IID_IUIElement, 0x759d0500, 0xd979, 0x11ce, 0x84, 0xec, 0x00, 0xaa, 0x00, 0x61, 0x4f, 0x3e);

#undef  INTERFACE
#define INTERFACE  IUIElement
DECLARE_INTERFACE_(IUIElement, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IUIElement methods ****
    STDMETHOD(Show)(THIS) PURE;
    STDMETHOD(Hide)(THIS) PURE;
    STDMETHOD(IsVisible)(THIS) PURE;
};

//-------------------------------------------------------------------------
//  SProfferService Service
//    VBA provides this service to it's components and hosts to allow
//    them to dynamically provide services.
//
//  interfaces implemented:
//    IProfferService
//-------------------------------------------------------------------------

// {CB728B20-F786-11ce-92AD-00AA00A74CD0}
DEFINE_GUID(IID_IProfferService, 0xcb728b20, 0xf786, 0x11ce, 0x92, 0xad, 0x0, 0xaa, 0x0, 0xa7, 0x4c, 0xd0);
#define SID_SProfferService IID_IProfferService

#undef  INTERFACE
#define INTERFACE  IProfferService
DECLARE_INTERFACE_(IProfferService, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProfferService methods ***
    STDMETHOD(ProfferService)(THIS_ 
                  /* [in]  */ REFGUID rguidService,
                  /* [in]  */ IServiceProvider * psp,
                  /* [out] */ DWORD *pdwCookie) PURE;

    STDMETHOD(RevokeService)(THIS_ /* [in]  */ DWORD dwCookie) PURE;
};

//-------------------------------------------------------------------------
//  SProfferTypelib Service
//    VBA provides this service to it's components and hosts to allow
//    them to add typelibs to the project
//
//  interfaces implemented:
//    IProfferTypelib
//-------------------------------------------------------------------------

// { 718cc500-0a76-11cf-8045-00aa006009fa }
DEFINE_GUID(IID_IProfferTypeLib, 0x718cc500, 0x0A76, 0x11cf, 0x80, 0x45, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SProfferTypeLib IID_IProfferTypeLib

#define CONTROLTYPELIB	(0x00000001)

#undef  INTERFACE
#define INTERFACE  IProfferTypeLib
DECLARE_INTERFACE_(IProfferTypeLib, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProfferTypelib methods ***
    STDMETHOD(ProfferTypeLib)(THIS_ 
              /* [in]  */ REFGUID guidTypeLib,
              /* [in]  */ UINT    uVerMaj,
              /* [in]  */ UINT    uVerMin,
              /* [in]  */ DWORD   dwFlags) PURE;
};

// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE
//   These interfaces need to be moved to the new olectl.h
//
// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE

// { 468cfb80-b4f9-11cf-80dd-00aa00614895 }
DEFINE_GUID(IID_IProvideDynamicClassInfo, 0x468cfb80, 0xb4f9, 0x11cf, 0x80, 0xdd, 0x00, 0xaa, 0x00, 0x61, 0x48, 0x95);

#undef  INTERFACE
#define INTERFACE  IProvideDynamicClassInfo
DECLARE_INTERFACE_(IProvideDynamicClassInfo, IProvideClassInfo)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProvideDynamicClassInfo ***
    STDMETHOD(GetDynamicClassInfo)(THIS_ ITypeInfo ** ppTI, DWORD * pdwCookie) PURE;
    STDMETHOD(FreezeShape)(void) PURE;
};

// {4D07FC10-F931-11ce-B001-00AA006884E5}
DEFINE_GUID(IID_ICategorizeProperties, 0x4d07fc10, 0xf931, 0x11ce, 0xb0, 0x1, 0x0, 0xaa, 0x0, 0x68, 0x84, 0xe5);

// NOTE : CATID should no longer be used.  Use PROPCAT instead.
// UNDONE,erikc,1/22/96 : remove #ifdef when all components have updated to new typedef.
#ifdef OBJEXT_OLD_CATID
typedef int CATID;
#else
typedef int PROPCAT;
#endif

#undef  INTERFACE
#define INTERFACE  ICategorizeProperties
DECLARE_INTERFACE_(ICategorizeProperties, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICategorizeProperties ***
    STDMETHOD(MapPropertyToCategory)(THIS_ 
                                     /* [in]  */ DISPID dispid,
                                     /* [out] */ PROPCAT* ppropcat) PURE;
    STDMETHOD(GetCategoryName)(THIS_
                               /* [in]  */ PROPCAT propcat, 
                               /* [in]  */ LCID lcid,
                               /* [out] */ BSTR* pbstrName) PURE;
};

typedef ICategorizeProperties FAR* LPCATEGORIZEPROPERTIES;

// category ID: negative values are 'standard' categories,  positive are control-specific
// Note! This is a temporary list!
#ifdef OBJEXT_OLD_CATID
// NOTE : The following #defines should no longer be used.  Use PROPCAT_ instead.
// UNDONE,erikc,1/22/96 : remove #ifdef when all components have updated to new #defines.
#define CI_Nil -1
#define CI_Misc -2
#define CI_Font -3
#define CI_Position -4
#define CI_Appearance -5
#define CI_Behavior -6
#define CI_Data -7
#define CI_List -8
#define CI_Text -9
#define CI_Scale -10
#define CI_DDE -11
#else
#define PROPCAT_Nil -1
#define PROPCAT_Misc -2
#define PROPCAT_Font -3
#define PROPCAT_Position -4
#define PROPCAT_Appearance -5
#define PROPCAT_Behavior -6
#define PROPCAT_Data -7
#define PROPCAT_List -8
#define PROPCAT_Text -9
#define PROPCAT_Scale -10
#define PROPCAT_DDE -11
#endif

//
//  Extra interfaces (chrisz)
//

//+-------------------------------------------------------------------------
//
//  Help service. (robbear)
//
//--------------------------------------------------------------------------

#define HELPINFO_WHATS_THIS_MODE_ON     1

// { 6d5140c7-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(SID_SHelp, 0x6d5140c7, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

// { 6d5140c8-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IHelp, 0x6d5140c8, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IHelp
DECLARE_INTERFACE_(IHelp, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IHelp methods ***
    STDMETHOD(GetHelpFile) (THIS_ BSTR * pbstr) PURE;
    STDMETHOD(GetHelpInfo) (THIS_ DWORD * pdwHelpInfo) PURE;
    STDMETHOD(ShowHelp) (THIS_
                         LPOLESTR szHelp,
                         UINT fuCommand,
                         DWORD dwHelpContext) PURE;
};


//-------------------------------------------------------------------------
//  SApplicationObject Service
//    Host applications proffer their application object as this service.  
//    Various objects implement the "Application" property by returning 
//    this service.
//      
//-------------------------------------------------------------------------

// { 0c539790-12e4-11cf-b661-00aa004cd6d8 }
DEFINE_GUID(SID_SApplicationObject, 0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8);

#endif // __OBJEXT_H

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\image.h ===
#ifndef _IMAGE_H_
#define _IMAGE_H_

#ifdef __cplusplus
extern "C" {
#endif

#define IMAGE_CLASSFILE_SIGNATURE	0xbebafeca	// CafeBabe in Big Endian


enum IMAGE_TYPE {
	IMAGE_TYPE_UNKNOWN,
	IMAGE_TYPE_DOS_STUB,
	IMAGE_TYPE_WIN16_OR_OS2,
	IMAGE_TYPE_WIN32,
	IMAGE_TYPE_CLASSFILE,
	IMAGE_TYPE_CRASHDUMP
};

#include "pshpack4.h"

typedef struct _IMAGE_INFO {

	ULONG	Size;
	ULONG	ImageType;

	union {
		struct {
			ULONG	Subsystem;
			WORD	Characteristics;
			WORD	Machine;
		} Win32;

		struct {
			BOOL	fUserMode;
			WORD	Machine;
		} CrashDump;
	} u;

} IMAGE_INFO;

#include "poppack.h"


BOOL WINAPI
GetImageInfo(
	LPCTSTR		ImageName,
	IMAGE_INFO*	ImageInfo
	);


//
// Is this image a valid Win32 subsystem image
//

#define IS_WIN32_SUBSYSTEM_IMAGE(ii)	\
	((ii).ImageType == IMAGE_TYPE_WIN32 &&	\
	((ii).u.Win32.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI ||	\
	 (ii).u.Win32.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI))

#ifdef __cplusplus
};		// extern "C"
#endif

#endif // _IMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\misc\inc\html_old.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Oct 25 18:49:20 1996
 */
/* Compiler settings for forms3.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __MSHTML_h__
#define __MSHTML_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDataAutoWrapper_FWD_DEFINED__
#define __IDataAutoWrapper_FWD_DEFINED__
typedef interface IDataAutoWrapper IDataAutoWrapper;
#endif 	/* __IDataAutoWrapper_FWD_DEFINED__ */


#ifndef __IReturnInteger_FWD_DEFINED__
#define __IReturnInteger_FWD_DEFINED__
typedef interface IReturnInteger IReturnInteger;
#endif 	/* __IReturnInteger_FWD_DEFINED__ */


#ifndef __IReturnBoolean_FWD_DEFINED__
#define __IReturnBoolean_FWD_DEFINED__
typedef interface IReturnBoolean IReturnBoolean;
#endif 	/* __IReturnBoolean_FWD_DEFINED__ */


#ifndef __IReturnString_FWD_DEFINED__
#define __IReturnString_FWD_DEFINED__
typedef interface IReturnString IReturnString;
#endif 	/* __IReturnString_FWD_DEFINED__ */


#ifndef __IReturnSingle_FWD_DEFINED__
#define __IReturnSingle_FWD_DEFINED__
typedef interface IReturnSingle IReturnSingle;
#endif 	/* __IReturnSingle_FWD_DEFINED__ */


#ifndef __IReturnEffect_FWD_DEFINED__
#define __IReturnEffect_FWD_DEFINED__
typedef interface IReturnEffect IReturnEffect;
#endif 	/* __IReturnEffect_FWD_DEFINED__ */


#ifndef __IUnitMeasurement_FWD_DEFINED__
#define __IUnitMeasurement_FWD_DEFINED__
typedef interface IUnitMeasurement IUnitMeasurement;
#endif 	/* __IUnitMeasurement_FWD_DEFINED__ */


#ifndef __IStyle_FWD_DEFINED__
#define __IStyle_FWD_DEFINED__
typedef interface IStyle IStyle;
#endif 	/* __IStyle_FWD_DEFINED__ */


#ifndef __IElement_FWD_DEFINED__
#define __IElement_FWD_DEFINED__
typedef interface IElement IElement;
#endif 	/* __IElement_FWD_DEFINED__ */


#ifndef __ITxtRange_FWD_DEFINED__
#define __ITxtRange_FWD_DEFINED__
typedef interface ITxtRange ITxtRange;
#endif 	/* __ITxtRange_FWD_DEFINED__ */


#ifndef __ControlElementEvents_FWD_DEFINED__
#define __ControlElementEvents_FWD_DEFINED__
typedef interface ControlElementEvents ControlElementEvents;
#endif 	/* __ControlElementEvents_FWD_DEFINED__ */


#ifndef __IControlElement_FWD_DEFINED__
#define __IControlElement_FWD_DEFINED__
typedef interface IControlElement IControlElement;
#endif 	/* __IControlElement_FWD_DEFINED__ */


#ifndef __IEnumControl_FWD_DEFINED__
#define __IEnumControl_FWD_DEFINED__
typedef interface IEnumControl IEnumControl;
#endif 	/* __IEnumControl_FWD_DEFINED__ */


#ifndef __ITextElement_FWD_DEFINED__
#define __ITextElement_FWD_DEFINED__
typedef interface ITextElement ITextElement;
#endif 	/* __ITextElement_FWD_DEFINED__ */


#ifndef __TextEditEvents_FWD_DEFINED__
#define __TextEditEvents_FWD_DEFINED__
typedef interface TextEditEvents TextEditEvents;
#endif 	/* __TextEditEvents_FWD_DEFINED__ */


#ifndef __ITxtEdit_FWD_DEFINED__
#define __ITxtEdit_FWD_DEFINED__
typedef interface ITxtEdit ITxtEdit;
#endif 	/* __ITxtEdit_FWD_DEFINED__ */


#ifndef __IAutoTxtSiteRange_FWD_DEFINED__
#define __IAutoTxtSiteRange_FWD_DEFINED__
typedef interface IAutoTxtSiteRange IAutoTxtSiteRange;
#endif 	/* __IAutoTxtSiteRange_FWD_DEFINED__ */


#ifndef __IAuto2DSiteRange_FWD_DEFINED__
#define __IAuto2DSiteRange_FWD_DEFINED__
typedef interface IAuto2DSiteRange IAuto2DSiteRange;
#endif 	/* __IAuto2DSiteRange_FWD_DEFINED__ */


#ifndef __DivFixedElementEvents_FWD_DEFINED__
#define __DivFixedElementEvents_FWD_DEFINED__
typedef interface DivFixedElementEvents DivFixedElementEvents;
#endif 	/* __DivFixedElementEvents_FWD_DEFINED__ */


#ifndef __IDivFixed_FWD_DEFINED__
#define __IDivFixed_FWD_DEFINED__
typedef interface IDivFixed IDivFixed;
#endif 	/* __IDivFixed_FWD_DEFINED__ */


#ifndef __ImgEvents_FWD_DEFINED__
#define __ImgEvents_FWD_DEFINED__
typedef interface ImgEvents ImgEvents;
#endif 	/* __ImgEvents_FWD_DEFINED__ */


#ifndef __IImgElement_FWD_DEFINED__
#define __IImgElement_FWD_DEFINED__
typedef interface IImgElement IImgElement;
#endif 	/* __IImgElement_FWD_DEFINED__ */


#ifndef __IBodyElement_FWD_DEFINED__
#define __IBodyElement_FWD_DEFINED__
typedef interface IBodyElement IBodyElement;
#endif 	/* __IBodyElement_FWD_DEFINED__ */


#ifndef __IBodyElementEvents_FWD_DEFINED__
#define __IBodyElementEvents_FWD_DEFINED__
typedef interface IBodyElementEvents IBodyElementEvents;
#endif 	/* __IBodyElementEvents_FWD_DEFINED__ */


#ifndef __IFontElement_FWD_DEFINED__
#define __IFontElement_FWD_DEFINED__
typedef interface IFontElement IFontElement;
#endif 	/* __IFontElement_FWD_DEFINED__ */


#ifndef __AnchorEvents_FWD_DEFINED__
#define __AnchorEvents_FWD_DEFINED__
typedef interface AnchorEvents AnchorEvents;
#endif 	/* __AnchorEvents_FWD_DEFINED__ */


#ifndef __IAnchorElement_FWD_DEFINED__
#define __IAnchorElement_FWD_DEFINED__
typedef interface IAnchorElement IAnchorElement;
#endif 	/* __IAnchorElement_FWD_DEFINED__ */


#ifndef __LabelEvents_FWD_DEFINED__
#define __LabelEvents_FWD_DEFINED__
typedef interface LabelEvents LabelEvents;
#endif 	/* __LabelEvents_FWD_DEFINED__ */


#ifndef __ILabelElement_FWD_DEFINED__
#define __ILabelElement_FWD_DEFINED__
typedef interface ILabelElement ILabelElement;
#endif 	/* __ILabelElement_FWD_DEFINED__ */


#ifndef __IListElement_FWD_DEFINED__
#define __IListElement_FWD_DEFINED__
typedef interface IListElement IListElement;
#endif 	/* __IListElement_FWD_DEFINED__ */


#ifndef __IUListElement_FWD_DEFINED__
#define __IUListElement_FWD_DEFINED__
typedef interface IUListElement IUListElement;
#endif 	/* __IUListElement_FWD_DEFINED__ */


#ifndef __IOListElement_FWD_DEFINED__
#define __IOListElement_FWD_DEFINED__
typedef interface IOListElement IOListElement;
#endif 	/* __IOListElement_FWD_DEFINED__ */


#ifndef __ILIElement_FWD_DEFINED__
#define __ILIElement_FWD_DEFINED__
typedef interface ILIElement ILIElement;
#endif 	/* __ILIElement_FWD_DEFINED__ */


#ifndef __IDivElement_FWD_DEFINED__
#define __IDivElement_FWD_DEFINED__
typedef interface IDivElement IDivElement;
#endif 	/* __IDivElement_FWD_DEFINED__ */


#ifndef __IDDElement_FWD_DEFINED__
#define __IDDElement_FWD_DEFINED__
typedef interface IDDElement IDDElement;
#endif 	/* __IDDElement_FWD_DEFINED__ */


#ifndef __IDTElement_FWD_DEFINED__
#define __IDTElement_FWD_DEFINED__
typedef interface IDTElement IDTElement;
#endif 	/* __IDTElement_FWD_DEFINED__ */


#ifndef __IBRElement_FWD_DEFINED__
#define __IBRElement_FWD_DEFINED__
typedef interface IBRElement IBRElement;
#endif 	/* __IBRElement_FWD_DEFINED__ */


#ifndef __IDListElement_FWD_DEFINED__
#define __IDListElement_FWD_DEFINED__
typedef interface IDListElement IDListElement;
#endif 	/* __IDListElement_FWD_DEFINED__ */


#ifndef __IHRElement_FWD_DEFINED__
#define __IHRElement_FWD_DEFINED__
typedef interface IHRElement IHRElement;
#endif 	/* __IHRElement_FWD_DEFINED__ */


#ifndef __IBlockElement_FWD_DEFINED__
#define __IBlockElement_FWD_DEFINED__
typedef interface IBlockElement IBlockElement;
#endif 	/* __IBlockElement_FWD_DEFINED__ */


#ifndef __IParaElement_FWD_DEFINED__
#define __IParaElement_FWD_DEFINED__
typedef interface IParaElement IParaElement;
#endif 	/* __IParaElement_FWD_DEFINED__ */


#ifndef __IElementCollection_FWD_DEFINED__
#define __IElementCollection_FWD_DEFINED__
typedef interface IElementCollection IElementCollection;
#endif 	/* __IElementCollection_FWD_DEFINED__ */


#ifndef __IOptionsCollection_FWD_DEFINED__
#define __IOptionsCollection_FWD_DEFINED__
typedef interface IOptionsCollection IOptionsCollection;
#endif 	/* __IOptionsCollection_FWD_DEFINED__ */


#ifndef __IHeaderElement_FWD_DEFINED__
#define __IHeaderElement_FWD_DEFINED__
typedef interface IHeaderElement IHeaderElement;
#endif 	/* __IHeaderElement_FWD_DEFINED__ */


#ifndef __IFormElement_FWD_DEFINED__
#define __IFormElement_FWD_DEFINED__
typedef interface IFormElement IFormElement;
#endif 	/* __IFormElement_FWD_DEFINED__ */


#ifndef __SelectElementEvents_FWD_DEFINED__
#define __SelectElementEvents_FWD_DEFINED__
typedef interface SelectElementEvents SelectElementEvents;
#endif 	/* __SelectElementEvents_FWD_DEFINED__ */


#ifndef __ISelectElement_FWD_DEFINED__
#define __ISelectElement_FWD_DEFINED__
typedef interface ISelectElement ISelectElement;
#endif 	/* __ISelectElement_FWD_DEFINED__ */


#ifndef __ISelectionObject_FWD_DEFINED__
#define __ISelectionObject_FWD_DEFINED__
typedef interface ISelectionObject ISelectionObject;
#endif 	/* __ISelectionObject_FWD_DEFINED__ */


#ifndef __IOptionElement_FWD_DEFINED__
#define __IOptionElement_FWD_DEFINED__
typedef interface IOptionElement IOptionElement;
#endif 	/* __IOptionElement_FWD_DEFINED__ */


#ifndef __InputTxtBaseEvents_FWD_DEFINED__
#define __InputTxtBaseEvents_FWD_DEFINED__
typedef interface InputTxtBaseEvents InputTxtBaseEvents;
#endif 	/* __InputTxtBaseEvents_FWD_DEFINED__ */


#ifndef __InputTextEvents_FWD_DEFINED__
#define __InputTextEvents_FWD_DEFINED__
typedef interface InputTextEvents InputTextEvents;
#endif 	/* __InputTextEvents_FWD_DEFINED__ */


#ifndef __TextAreaEvents_FWD_DEFINED__
#define __TextAreaEvents_FWD_DEFINED__
typedef interface TextAreaEvents TextAreaEvents;
#endif 	/* __TextAreaEvents_FWD_DEFINED__ */


#ifndef __IInputHidden_FWD_DEFINED__
#define __IInputHidden_FWD_DEFINED__
typedef interface IInputHidden IInputHidden;
#endif 	/* __IInputHidden_FWD_DEFINED__ */


#ifndef __IInputPassword_FWD_DEFINED__
#define __IInputPassword_FWD_DEFINED__
typedef interface IInputPassword IInputPassword;
#endif 	/* __IInputPassword_FWD_DEFINED__ */


#ifndef __IInputText_FWD_DEFINED__
#define __IInputText_FWD_DEFINED__
typedef interface IInputText IInputText;
#endif 	/* __IInputText_FWD_DEFINED__ */


#ifndef __ITextArea_FWD_DEFINED__
#define __ITextArea_FWD_DEFINED__
typedef interface ITextArea ITextArea;
#endif 	/* __ITextArea_FWD_DEFINED__ */


#ifndef __InputButtonEvents_FWD_DEFINED__
#define __InputButtonEvents_FWD_DEFINED__
typedef interface InputButtonEvents InputButtonEvents;
#endif 	/* __InputButtonEvents_FWD_DEFINED__ */


#ifndef __IInputReset_FWD_DEFINED__
#define __IInputReset_FWD_DEFINED__
typedef interface IInputReset IInputReset;
#endif 	/* __IInputReset_FWD_DEFINED__ */


#ifndef __IInputSubmit_FWD_DEFINED__
#define __IInputSubmit_FWD_DEFINED__
typedef interface IInputSubmit IInputSubmit;
#endif 	/* __IInputSubmit_FWD_DEFINED__ */


#ifndef __IInputButton_FWD_DEFINED__
#define __IInputButton_FWD_DEFINED__
typedef interface IInputButton IInputButton;
#endif 	/* __IInputButton_FWD_DEFINED__ */


#ifndef __MarqueeEvents_FWD_DEFINED__
#define __MarqueeEvents_FWD_DEFINED__
typedef interface MarqueeEvents MarqueeEvents;
#endif 	/* __MarqueeEvents_FWD_DEFINED__ */


#ifndef __IMarquee_FWD_DEFINED__
#define __IMarquee_FWD_DEFINED__
typedef interface IMarquee IMarquee;
#endif 	/* __IMarquee_FWD_DEFINED__ */


#ifndef __CheckboxElementEvents_FWD_DEFINED__
#define __CheckboxElementEvents_FWD_DEFINED__
typedef interface CheckboxElementEvents CheckboxElementEvents;
#endif 	/* __CheckboxElementEvents_FWD_DEFINED__ */


#ifndef __ICheckboxElement_FWD_DEFINED__
#define __ICheckboxElement_FWD_DEFINED__
typedef interface ICheckboxElement ICheckboxElement;
#endif 	/* __ICheckboxElement_FWD_DEFINED__ */


#ifndef __RadioElementEvents_FWD_DEFINED__
#define __RadioElementEvents_FWD_DEFINED__
typedef interface RadioElementEvents RadioElementEvents;
#endif 	/* __RadioElementEvents_FWD_DEFINED__ */


#ifndef __IRadioElement_FWD_DEFINED__
#define __IRadioElement_FWD_DEFINED__
typedef interface IRadioElement IRadioElement;
#endif 	/* __IRadioElement_FWD_DEFINED__ */


#ifndef __IInputElement_FWD_DEFINED__
#define __IInputElement_FWD_DEFINED__
typedef interface IInputElement IInputElement;
#endif 	/* __IInputElement_FWD_DEFINED__ */


#ifndef __ITitleElement_FWD_DEFINED__
#define __ITitleElement_FWD_DEFINED__
typedef interface ITitleElement ITitleElement;
#endif 	/* __ITitleElement_FWD_DEFINED__ */


#ifndef __IMetaElement_FWD_DEFINED__
#define __IMetaElement_FWD_DEFINED__
typedef interface IMetaElement IMetaElement;
#endif 	/* __IMetaElement_FWD_DEFINED__ */


#ifndef __IBaseElement_FWD_DEFINED__
#define __IBaseElement_FWD_DEFINED__
typedef interface IBaseElement IBaseElement;
#endif 	/* __IBaseElement_FWD_DEFINED__ */


#ifndef __ILinkElement_FWD_DEFINED__
#define __ILinkElement_FWD_DEFINED__
typedef interface ILinkElement ILinkElement;
#endif 	/* __ILinkElement_FWD_DEFINED__ */


#ifndef __IIsIndexElement_FWD_DEFINED__
#define __IIsIndexElement_FWD_DEFINED__
typedef interface IIsIndexElement IIsIndexElement;
#endif 	/* __IIsIndexElement_FWD_DEFINED__ */


#ifndef __INextIdElement_FWD_DEFINED__
#define __INextIdElement_FWD_DEFINED__
typedef interface INextIdElement INextIdElement;
#endif 	/* __INextIdElement_FWD_DEFINED__ */


#ifndef __IBaseFontElement_FWD_DEFINED__
#define __IBaseFontElement_FWD_DEFINED__
typedef interface IBaseFontElement IBaseFontElement;
#endif 	/* __IBaseFontElement_FWD_DEFINED__ */


#ifndef __IUnknownElement_FWD_DEFINED__
#define __IUnknownElement_FWD_DEFINED__
typedef interface IUnknownElement IUnknownElement;
#endif 	/* __IUnknownElement_FWD_DEFINED__ */


#ifndef __IPhraseElement_FWD_DEFINED__
#define __IPhraseElement_FWD_DEFINED__
typedef interface IPhraseElement IPhraseElement;
#endif 	/* __IPhraseElement_FWD_DEFINED__ */


#ifndef __ICommentElement_FWD_DEFINED__
#define __ICommentElement_FWD_DEFINED__
typedef interface ICommentElement ICommentElement;
#endif 	/* __ICommentElement_FWD_DEFINED__ */


#ifndef __DocumentEvents_FWD_DEFINED__
#define __DocumentEvents_FWD_DEFINED__
typedef interface DocumentEvents DocumentEvents;
#endif 	/* __DocumentEvents_FWD_DEFINED__ */


#ifndef __IDocument_FWD_DEFINED__
#define __IDocument_FWD_DEFINED__
typedef interface IDocument IDocument;
#endif 	/* __IDocument_FWD_DEFINED__ */


#ifndef __ITable_FWD_DEFINED__
#define __ITable_FWD_DEFINED__
typedef interface ITable ITable;
#endif 	/* __ITable_FWD_DEFINED__ */


#ifndef __ITableCol_FWD_DEFINED__
#define __ITableCol_FWD_DEFINED__
typedef interface ITableCol ITableCol;
#endif 	/* __ITableCol_FWD_DEFINED__ */


#ifndef __ITableSection_FWD_DEFINED__
#define __ITableSection_FWD_DEFINED__
typedef interface ITableSection ITableSection;
#endif 	/* __ITableSection_FWD_DEFINED__ */


#ifndef __ITableRow_FWD_DEFINED__
#define __ITableRow_FWD_DEFINED__
typedef interface ITableRow ITableRow;
#endif 	/* __ITableRow_FWD_DEFINED__ */


#ifndef __ITableCell_FWD_DEFINED__
#define __ITableCell_FWD_DEFINED__
typedef interface ITableCell ITableCell;
#endif 	/* __ITableCell_FWD_DEFINED__ */


#ifndef __ITableCaption_FWD_DEFINED__
#define __ITableCaption_FWD_DEFINED__
typedef interface ITableCaption ITableCaption;
#endif 	/* __ITableCaption_FWD_DEFINED__ */


#ifndef __IDivFlow_FWD_DEFINED__
#define __IDivFlow_FWD_DEFINED__
typedef interface IDivFlow IDivFlow;
#endif 	/* __IDivFlow_FWD_DEFINED__ */


#ifndef __IObjectElement_FWD_DEFINED__
#define __IObjectElement_FWD_DEFINED__
typedef interface IObjectElement IObjectElement;
#endif 	/* __IObjectElement_FWD_DEFINED__ */


#ifndef __ScriptWindowEvents_FWD_DEFINED__
#define __ScriptWindowEvents_FWD_DEFINED__
typedef interface ScriptWindowEvents ScriptWindowEvents;
#endif 	/* __ScriptWindowEvents_FWD_DEFINED__ */


#ifndef __IDocumentDisp_FWD_DEFINED__
#define __IDocumentDisp_FWD_DEFINED__
typedef interface IDocumentDisp IDocumentDisp;
#endif 	/* __IDocumentDisp_FWD_DEFINED__ */


#ifndef __IScriptWindow_FWD_DEFINED__
#define __IScriptWindow_FWD_DEFINED__
typedef interface IScriptWindow IScriptWindow;
#endif 	/* __IScriptWindow_FWD_DEFINED__ */


#ifndef __IMapElement_FWD_DEFINED__
#define __IMapElement_FWD_DEFINED__
typedef interface IMapElement IMapElement;
#endif 	/* __IMapElement_FWD_DEFINED__ */


#ifndef __AreaEvents_FWD_DEFINED__
#define __AreaEvents_FWD_DEFINED__
typedef interface AreaEvents AreaEvents;
#endif 	/* __AreaEvents_FWD_DEFINED__ */


#ifndef __IAreaElement_FWD_DEFINED__
#define __IAreaElement_FWD_DEFINED__
typedef interface IAreaElement IAreaElement;
#endif 	/* __IAreaElement_FWD_DEFINED__ */


#ifndef __IApplet_FWD_DEFINED__
#define __IApplet_FWD_DEFINED__
typedef interface IApplet IApplet;
#endif 	/* __IApplet_FWD_DEFINED__ */


#ifndef __IParam_FWD_DEFINED__
#define __IParam_FWD_DEFINED__
typedef interface IParam IParam;
#endif 	/* __IParam_FWD_DEFINED__ */


#ifndef __IScriptElement_FWD_DEFINED__
#define __IScriptElement_FWD_DEFINED__
typedef interface IScriptElement IScriptElement;
#endif 	/* __IScriptElement_FWD_DEFINED__ */


#ifndef __IFrameSite_FWD_DEFINED__
#define __IFrameSite_FWD_DEFINED__
typedef interface IFrameSite IFrameSite;
#endif 	/* __IFrameSite_FWD_DEFINED__ */


#ifndef __IFrameElement_FWD_DEFINED__
#define __IFrameElement_FWD_DEFINED__
typedef interface IFrameElement IFrameElement;
#endif 	/* __IFrameElement_FWD_DEFINED__ */


#ifndef __IIFrameElement_FWD_DEFINED__
#define __IIFrameElement_FWD_DEFINED__
typedef interface IIFrameElement IIFrameElement;
#endif 	/* __IIFrameElement_FWD_DEFINED__ */


#ifndef __IFrameSetElement_FWD_DEFINED__
#define __IFrameSetElement_FWD_DEFINED__
typedef interface IFrameSetElement IFrameSetElement;
#endif 	/* __IFrameSetElement_FWD_DEFINED__ */


#ifndef __HTMLDlgModelEvents_FWD_DEFINED__
#define __HTMLDlgModelEvents_FWD_DEFINED__
typedef interface HTMLDlgModelEvents HTMLDlgModelEvents;
#endif 	/* __HTMLDlgModelEvents_FWD_DEFINED__ */


#ifndef __IHTMLDlgModel_FWD_DEFINED__
#define __IHTMLDlgModel_FWD_DEFINED__
typedef interface IHTMLDlgModel IHTMLDlgModel;
#endif 	/* __IHTMLDlgModel_FWD_DEFINED__ */


#ifndef __IHTMLDlg_FWD_DEFINED__
#define __IHTMLDlg_FWD_DEFINED__
typedef interface IHTMLDlg IHTMLDlg;
#endif 	/* __IHTMLDlg_FWD_DEFINED__ */


#ifndef __IScrollbar_FWD_DEFINED__
#define __IScrollbar_FWD_DEFINED__
typedef interface IScrollbar IScrollbar;
#endif 	/* __IScrollbar_FWD_DEFINED__ */


#ifndef __ISpinbutton_FWD_DEFINED__
#define __ISpinbutton_FWD_DEFINED__
typedef interface ISpinbutton ISpinbutton;
#endif 	/* __ISpinbutton_FWD_DEFINED__ */


#ifndef __IImage_FWD_DEFINED__
#define __IImage_FWD_DEFINED__
typedef interface IImage IImage;
#endif 	/* __IImage_FWD_DEFINED__ */


#ifndef __ScrollbarEvents_FWD_DEFINED__
#define __ScrollbarEvents_FWD_DEFINED__
typedef interface ScrollbarEvents ScrollbarEvents;
#endif 	/* __ScrollbarEvents_FWD_DEFINED__ */


#ifndef __SpinbuttonEvents_FWD_DEFINED__
#define __SpinbuttonEvents_FWD_DEFINED__
typedef interface SpinbuttonEvents SpinbuttonEvents;
#endif 	/* __SpinbuttonEvents_FWD_DEFINED__ */


#ifndef __ImageEvents_FWD_DEFINED__
#define __ImageEvents_FWD_DEFINED__
typedef interface ImageEvents ImageEvents;
#endif 	/* __ImageEvents_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#include <olectl.h>
interface Font;
interface Picture;
EXTERN_C const GUID CMDSETID_Forms3;


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;


#ifndef __MSForms_LIBRARY_DEFINED__
#define __MSForms_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSForms
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][version][helpfile][helpstring][lcid][control] */ 


typedef /* [uuid] */ 
enum _htmlConstant
    {	htmlNotSet	= 0
    }	htmlConstant;

typedef /* [uuid] */ 
enum _fmDropEffect
    {	fmDropEffectNone	= 0,
	fmDropEffectCopy	= 1,
	fmDropEffectMove	= 2,
	fmDropEffectCopyOrMove	= 3
    }	fmDropEffect;

typedef /* [uuid] */ 
enum _fmAction
    {	fmActionCut	= 0,
	fmActionCopy	= 1,
	fmActionPaste	= 2,
	fmActionDragDrop	= 3
    }	fmAction;

typedef /* [uuid] */ 
enum _fmMode
    {	fmModeInherit	= -2,
	fmModeOn	= -1,
	fmModeOff	= 0
    }	fmMode;

typedef /* [uuid] */ 
enum _fmMousePointer
    {	fmMousePointerDefault	= 0,
	fmMousePointerArrow	= 1,
	fmMousePointerCross	= 2,
	fmMousePointerIBeam	= 3,
	fmMousePointerSizeNS	= 7,
	fmMousePointerSizeNWSE	= 8,
	fmMousePointerSizeWE	= 9,
	fmMousePointerUpArrow	= 10,
	fmMousePointerHourGlass	= 11,
	fmMousePointerNoDrop	= 12,
	fmMousePointerAppStarting	= 13,
	fmMousePointerHelp	= 14,
	fmMousePointerSizeAll	= 15,
	fmMousePointerCustom	= 99
    }	fmMousePointer;

typedef /* [uuid] */ 
enum _fmScrollBars
    {	fmScrollBarsNone	= 0,
	fmScrollBarsHorizontal	= 1,
	fmScrollBarsVertical	= 2,
	fmScrollBarsBoth	= 3
    }	fmScrollBars;

typedef /* [uuid] */ 
enum _fmScrollAction
    {	fmScrollActionNoChange	= 0,
	fmScrollActionLineUp	= 1,
	fmScrollActionLineDown	= 2,
	fmScrollActionPageUp	= 3,
	fmScrollActionPageDown	= 4,
	fmScrollActionBegin	= 5,
	fmScrollActionEnd	= 6,
	fmScrollActionAbsoluteChange	= 7,
	fmScrollActionPropertyChange	= 8,
	fmScrollActionControlRequest	= 9,
	fmScrollActionFocusRequest	= 10
    }	fmScrollAction;

typedef /* [uuid] */ 
enum _fmCycle
    {	fmCycleAllForms	= 0,
	fmCycleCurrentForm	= 2
    }	fmCycle;

typedef /* [uuid] */ 
enum _fmZOrder
    {	fmZOrderFront	= 0,
	fmZOrderBack	= 1
    }	fmZOrder;

typedef /* [uuid] */ 
enum _fmBorderStyle
    {	fmBorderStyleNone	= 0,
	fmBorderStyleSingle	= 1
    }	fmBorderStyle;

typedef /* [uuid] */ 
enum _fmTextAlign
    {	fmTextAlignGeneral	= 0,
	fmTextAlignLeft	= 1,
	fmTextAlignCenter	= 2,
	fmTextAlignRight	= 3
    }	fmTextAlign;

typedef /* [uuid] */ 
enum _fmAlignment
    {	fmAlignmentLeft	= 0,
	fmAlignmentRight	= 1
    }	fmAlignment;

typedef /* [uuid] */ 
enum _fmBorders
    {	fmBordersNone	= 0,
	fmBordersBox	= 1,
	fmBordersLeft	= 2,
	fmBordersTop	= 3
    }	fmBorders;

typedef /* [uuid] */ 
enum _fmBackStyle
    {	fmBackStyleTransparent	= 0,
	fmBackStyleOpaque	= 1
    }	fmBackStyle;

typedef /* [uuid] */ 
enum _fmButtonStyle
    {	fmButtonStylePushButton	= 0,
	fmButtonStyleToggleButton	= 1
    }	fmButtonStyle;

typedef /* [uuid] */ 
enum _fmLayoutEffect
    {	fmLayoutEffectNone	= 0,
	fmLayoutEffectInitiate	= 1,
	fmLayoutEffectRespond	= 2
    }	fmLayoutEffect;

typedef /* [uuid] */ 
enum _fmDragState
    {	fmDragStateEnter	= 0,
	fmDragStateLeave	= 1,
	fmDragStateOver	= 2
    }	fmDragState;

typedef /* [uuid] */ 
enum _fmVerticalScrollBarSide
    {	fmVerticalScrollBarSideRight	= 0,
	fmVerticalScrollBarSideLeft	= 1
    }	fmVerticalScrollBarSide;

typedef /* [uuid] */ 
enum _fmSpecialEffect
    {	fmSpecialEffectFlat	= 0,
	fmSpecialEffectRaised	= 1,
	fmSpecialEffectSunken	= 2,
	fmSpecialEffectEtched	= 3,
	fmSpecialEffectBump	= 4,
	fmSpecialEffectRaisedMono	= 5,
	fmSpecialEffectSunkenMono	= 6
    }	fmSpecialEffect;

typedef /* [uuid] */ 
enum _fmPictureSizeMode
    {	fmPictureSizeModeClip	= 0,
	fmPictureSizeModeStretch	= 1,
	fmPictureSizeModeZoom	= 3
    }	fmPictureSizeMode;

typedef /* [uuid] */ 
enum _fmPictureAlignment
    {	fmPictureAlignmentTopLeft	= 0,
	fmPictureAlignmentTopRight	= 1,
	fmPictureAlignmentCenter	= 2,
	fmPictureAlignmentBottomLeft	= 3,
	fmPictureAlignmentBottomRight	= 4
    }	fmPictureAlignment;

typedef /* [uuid] */ 
enum _fmMultiSelect
    {	fmMultiSelectSingle	= 0,
	fmMultiSelectMulti	= 1,
	fmMultiSelectExtended	= 2
    }	fmMultiSelect;

typedef /* [uuid] */ 
enum _fmListStyle
    {	fmListStylePlain	= 0,
	fmListStyleOption	= 1,
	fmListStyleToggle	= 2,
	fmListStyleMark	= 3
    }	fmListStyle;

typedef /* [uuid] */ 
enum _htmlReadyState
    {	htmlReadyStateUninitialized	= 0,
	htmlReadyStateLoading	= 1,
	htmlReadyStateInteractive	= 3,
	htmlReadyStateComplete	= 4
    }	htmlReadyState;

typedef /* [uuid] */ 
enum _htmlClear
    {	htmlClearNotSet	= 0,
	htmlClearAll	= 1,
	htmlClearLeft	= 2,
	htmlClearRight	= 3
    }	htmlClear;

typedef /* [uuid] */ 
enum _htmlControlAlign
    {	htmlControlAlignNotSet	= 0,
	htmlControlAlignLeft	= 1,
	htmlControlAlignCenter	= 2,
	htmlControlAlignRight	= 3,
	htmlControlAlignTextTop	= 4,
	htmlControlAlignAbsMiddle	= 5,
	htmlControlAlignBaseline	= 6,
	htmlControlAlignAbsBottom	= 7,
	htmlControlAlignBottom	= 8,
	htmlControlAlignMiddle	= 9,
	htmlControlAlignTop	= 10
    }	htmlControlAlign;

typedef /* [uuid] */ 
enum _htmlBlockAlign
    {	htmlBlockAlignNotSet	= 0,
	htmlBlockAlignLeft	= 1,
	htmlBlockAlignCenter	= 2,
	htmlBlockAlignRight	= 3
    }	htmlBlockAlign;

typedef /* [uuid] */ 
enum _htmlUnits
    {	htmlUnitsNotSet	= 0,
	htmlUnitsPoint	= 1,
	htmlUnitsPica	= 2,
	htmlUnitsInch	= 3,
	htmlUnitsCm	= 4,
	htmlUnitsMm	= 5,
	htmlUnitsEm	= 6,
	htmlUnitsEn	= 7,
	htmlUnitsEx	= 8,
	htmlUnitsPixels	= 9,
	htmlUnitsPercent	= 10,
	htmlUnitsRelative	= 11
    }	htmlUnits;

typedef /* [uuid] */ 
enum _htmlDocUnits
    {	htmlDocUnitsPoint	= 1,
	htmlDocUnitsPica	= 2,
	htmlDocUnitsInch	= 3,
	htmlDocUnitsCm	= 4,
	htmlDocUnitsMm	= 5,
	htmlDocUnitsEm	= 6,
	htmlDocUnitsEn	= 7,
	htmlDocUnitsEx	= 8,
	htmlDocUnitsPixels	= 9
    }	htmlDocUnits;

typedef /* [uuid] */ 
enum _styleTextTransform
    {	styleTextTransformNotSet	= 0,
	styleTextTransformLowercase	= 1,
	styleTextTransformUppercase	= 2
    }	styleTextTransform;

typedef /* [uuid] */ 
enum _styleDataRepeat
    {	styleDataRepeatNone	= 0,
	styleDataRepeatInner	= 1
    }	styleDataRepeat;

typedef /* [uuid] */ 
enum _styleOverflow
    {	styleOverflowNone	= 0,
	styleOverflowScrollHoriz	= 1,
	styleOverflowScrollVert	= 2,
	styleOverflowScrollBoth	= 3
    }	styleOverflow;

typedef /* [uuid] */ 
enum _styleLayout
    {	styleLayoutNotSet	= 0,
	styleLayoutFixed	= 1,
	styleLayoutFill	= 2
    }	styleLayout;

typedef /* [uuid] */ 
enum _styleTextDecorationLineThrough
    {	styleTextDecorationLineThroughNotSet	= 0,
	styleTextDecorationLineThroughLineThrough	= 1
    }	styleTextDecorationLineThrough;

typedef /* [uuid] */ 
enum _styleTextDecorationUnderline
    {	styleTextDecorationUnderlineNotSet	= 0,
	styleTextDecorationUnderlineUnderline	= 1
    }	styleTextDecorationUnderline;

typedef /* [uuid] */ 
enum _styleTextDecorationNone
    {	styleTextDecorationNoneNotSet	= 0,
	styleTextDecorationNoneNone	= 1
    }	styleTextDecorationNone;

typedef /* [uuid] */ 
enum _styleFontStyle
    {	styleFontStyleNotSet	= 0,
	styleFontStyleItalic	= 1,
	styleFontStyleOblique	= 2,
	styleFontStyleNone	= 3
    }	styleFontStyle;

typedef /* [uuid] */ 
enum _styleFontVariant
    {	styleFontVariantNotSet	= 0,
	styleFontVariantSmallCaps	= 1,
	styleFontVariantNone	= 2
    }	styleFontVariant;

typedef /* [uuid] */ 
enum _styleFontWeight
    {	styleFontWeightNotSet	= 0,
	styleFontWeight100	= 1,
	styleFontWeight200	= 2,
	styleFontWeight300	= 3,
	styleFontWeight400	= 4,
	styleFontWeight500	= 5,
	styleFontWeight600	= 6,
	styleFontWeight700	= 7,
	styleFontWeight800	= 8,
	styleFontWeight900	= 9,
	styleFontWeightNormal	= 10,
	styleFontWeightBold	= 11,
	styleFontWeightBolder	= 12,
	styleFontWeightLighter	= 13
    }	styleFontWeight;

typedef /* [uuid] */ 
enum _htmlListType
    {	htmlListTypeNotSet	= 0,
	htmlListTypeLargeAlpha	= 1,
	htmlListTypeSmallAlpha	= 2,
	htmlListTypeLargeRoman	= 3,
	htmlListTypeSmallRoman	= 4,
	htmlListTypeNumbers	= 5,
	htmlListTypeDisc	= 6,
	htmlListTypeCircle	= 7,
	htmlListTypeSquare	= 8
    }	htmlListType;

typedef /* [uuid] */ 
enum _cssListStyle
    {	cssListStyleLowerAlpha	= 0,
	cssListStyleUpperAlpha	= 1,
	cssListStyleLowerRoman	= 2,
	cssListStyleUpperRoman	= 3,
	cssListStyleDics	= 4,
	cssListStyleCircle	= 5,
	cssListStyleSquare	= 6,
	cssListStyleDecimal	= 7,
	cssListStyleNone	= 8
    }	cssListStyle;

typedef /* [uuid] */ 
enum _htmlDir
    {	htmlDirLeftToRight	= 0,
	htmlDirRightToLeft	= 1
    }	htmlDir;

typedef /* [uuid] */ 
enum _htmlMethod
    {	htmlMethodNotSet	= 0,
	htmlMethodGet	= 1,
	htmlMethodPost	= 2
    }	htmlMethod;

typedef /* [uuid] */ 
enum _htmlWrap
    {	htmlWrapOff	= 1,
	htmlWrapVirtual	= 2,
	htmlWrapPhysical	= 3
    }	htmlWrap;

typedef /* [uuid] */ 
enum _htmlInput
    {	htmlInputNotSet	= 0,
	htmlInputButton	= 1,
	htmlInputCheckbox	= 2,
	htmlInputFile	= 3,
	htmlInputHidden	= 4,
	htmlInputImage	= 5,
	htmlInputPassword	= 6,
	htmlInputRadio	= 7,
	htmlInputReset	= 8,
	htmlInputSelectOne	= 9,
	htmlInputSelectMultiple	= 10,
	htmlInputSubmit	= 11,
	htmlInputText	= 12,
	htmlInputTextarea	= 13
    }	htmlInput;

typedef /* [uuid] */ 
enum _htmlUnit
    {	htmlUnitCharacter	= 1,
	htmlUnitWord	= 2,
	htmlUnitSentence	= 3,
	htmlUnitStory	= 6
    }	htmlUnit;

typedef /* [uuid] */ 
enum _htmlDirection
    {	htmlDirectionForward	= 99999,
	htmlDirectionBackward	= -99999,
	htmlDirectionLeft	= 1,
	htmlDirectionRight	= 3,
	htmlDirectionUp	= 5,
	htmlDirectionDown	= 7
    }	htmlDirection;

typedef /* [uuid] */ 
enum _htmlLoop
    {	htmlLoopLoopInfinite	= -1
    }	htmlLoop;

typedef /* [uuid] */ 
enum _htmlBGProperties
    {	htmlBGPropertiesNotSet	= 0,
	htmlBGPropertiesFixed	= 1
    }	htmlBGProperties;

typedef /* [uuid] */ 
enum _htmlSelectType
    {	htmlSelectTypeSelectOne	= 1,
	htmlSelectTypeSelectMultiple	= 2
    }	htmlSelectType;

typedef /* [uuid] */ 
enum _htmlSelection
    {	htmlSelectionNone	= 0,
	htmlSelectionText	= 1,
	htmlSelectionControl	= 2,
	htmlSelectionTable	= 3
    }	htmlSelection;

typedef /* [uuid] */ 
enum _htmlFrame
    {	htmlFrameNotSet	= 0,
	htmlFramevoid	= 1,
	htmlFrameabove	= 2,
	htmlFramebelow	= 3,
	htmlFramehsides	= 4,
	htmlFramelhs	= 5,
	htmlFramerhs	= 6,
	htmlFramevsides	= 7,
	htmlFramebox	= 8,
	htmlFrameborder	= 9
    }	htmlFrame;

typedef /* [uuid] */ 
enum _htmlRules
    {	htmlRulesNotSet	= 0,
	htmlRulesnone	= 1,
	htmlRulesgroups	= 2,
	htmlRulesrows	= 3,
	htmlRulescols	= 4,
	htmlRulesall	= 5
    }	htmlRules;

typedef /* [uuid] */ 
enum _htmlCellAlign
    {	htmlCellAlignNotSet	= 0,
	htmlCellAlignLeft	= 1,
	htmlCellAlignCenter	= 2,
	htmlCellAlignRight	= 3,
	htmlCellAlignMiddle	= htmlCellAlignCenter
    }	htmlCellAlign;

typedef /* [uuid] */ 
enum _htmlCellVAlign
    {	htmlCellVAlignNotSet	= 0,
	htmlCellVAlignTop	= 1,
	htmlCellVAlignMiddle	= 2,
	htmlCellVAlignBottom	= 3,
	htmlCellVAlignBaseline	= 4
    }	htmlCellVAlign;

typedef /* [uuid] */ 
enum _htmlCaptionAlign
    {	htmlCaptionAlignNotSet	= 0,
	htmlCaptionAlignLeft	= 1,
	htmlCaptionAlignCenter	= 2,
	htmlCaptionAlignRight	= 3,
	htmlCaptionAlignTop	= 4,
	htmlCaptionAlignBottom	= 5
    }	htmlCaptionAlign;

typedef /* [uuid] */ 
enum _htmlCaptionVAlign
    {	htmlCaptionVAlignNotSet	= 0,
	htmlCaptionVAlignTop	= 1,
	htmlCaptionVAlignBottom	= 2
    }	htmlCaptionVAlign;

typedef /* [uuid] */ 
enum _frameScrolling
    {	frameScrollingyes	= 1,
	frameScrollingno	= 2,
	frameScrollingauto	= 4
    }	frameScrolling;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0001
    {	fmButtonEffectFlat	= 0,
	fmButtonEffectSunken	= 2
    }	fmButtonEffect;

typedef /* [public][public][public][public][public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0002
    {	fmOrientationAuto	= -1,
	fmOrientationVertical	= 0,
	fmOrientationHorizontal	= 1
    }	fmOrientation;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0003
    {	fmSnapPointTopLeft	= 0,
	fmSnapPointTopCenter	= 1,
	fmSnapPointTopRight	= 2,
	fmSnapPointCenterLeft	= 3,
	fmSnapPointCenter	= 4,
	fmSnapPointCenterRight	= 5,
	fmSnapPointBottomLeft	= 6,
	fmSnapPointBottomCenter	= 7,
	fmSnapPointBottomRight	= 8
    }	fmSnapPoint;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0004
    {	fmPicturePositionLeftTop	= 0,
	fmPicturePositionLeftCenter	= 1,
	fmPicturePositionLeftBottom	= 2,
	fmPicturePositionRightTop	= 3,
	fmPicturePositionRightCenter	= 4,
	fmPicturePositionRightBottom	= 5,
	fmPicturePositionAboveLeft	= 6,
	fmPicturePositionAboveCenter	= 7,
	fmPicturePositionAboveRight	= 8,
	fmPicturePositionBelowLeft	= 9,
	fmPicturePositionBelowCenter	= 10,
	fmPicturePositionBelowRight	= 11,
	fmPicturePositionCenter	= 12
    }	fmPicturePosition;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0005
    {	fmDisplayStyleText	= 1,
	fmDisplayStyleList	= 2,
	fmDisplayStyleCombo	= 3,
	fmDisplayStyleCheckBox	= 4,
	fmDisplayStyleOptionButton	= 5,
	fmDisplayStyleToggle	= 6,
	fmDisplayStyleDropList	= 7
    }	fmDisplayStyle;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0006
    {	fmShowListWhenNever	= 0,
	fmShowListWhenButton	= 1,
	fmShowListWhenFocus	= 2,
	fmShowListWhenAlways	= 3
    }	fmShowListWhen;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0007
    {	fmShowDropButtonWhenNever	= 0,
	fmShowDropButtonWhenFocus	= 1,
	fmShowDropButtonWhenAlways	= 2
    }	fmShowDropButtonWhen;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0008
    {	fmEnterFieldBehaviorSelectAll	= 0,
	fmEnterFieldBehaviorRecallSelection	= 1
    }	fmEnterFieldBehavior;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0009
    {	fmDragBehaviorDisabled	= 0,
	fmDragBehaviorEnabled	= 1
    }	fmDragBehavior;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0010
    {	fmMatchEntryFirstLetter	= 0,
	fmMatchEntryComplete	= 1,
	fmMatchEntryNone	= 2
    }	fmMatchEntry;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0011
    {	fmDropButtonStylePlain	= 0,
	fmDropButtonStyleArrow	= 1,
	fmDropButtonStyleEllipsis	= 2,
	fmDropButtonStyleReduce	= 3
    }	fmDropButtonStyle;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0012
    {	fmStyleDropDownCombo	= 0,
	fmStyleDropDownList	= 2
    }	fmStyle;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0013
    {	fmTabOrientationTop	= 0,
	fmTabOrientationBottom	= 1,
	fmTabOrientationLeft	= 2,
	fmTabOrientationRight	= 3
    }	fmTabOrientation;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0014
    {	fmTabStyleTabs	= 0,
	fmTabStyleButtons	= 1,
	fmTabStyleNone	= 2
    }	fmTabStyle;

typedef /* [public][uuid] */ 
enum __MIDL___MIDL__intf_0238_0015
    {	fmIMEModeNoControl	= 0,
	fmIMEModeOn	= 1,
	fmIMEModeOff	= 2,
	fmIMEModeDisable	= 3,
	fmIMEModeHiragana	= 4,
	fmIMEModeKatakana	= 5,
	fmIMEModeKatakanaHalf	= 6,
	fmIMEModeAlphaFull	= 7,
	fmIMEModeAlpha	= 8
    }	fmIMEMode;


EXTERN_C const IID LIBID_MSForms;

#ifndef __IDataAutoWrapper_INTERFACE_DEFINED__
#define __IDataAutoWrapper_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataAutoWrapper
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IDataAutoWrapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDataAutoWrapper : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE clear( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getFormat( 
            /* [in] */ VARIANT format,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *support) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getText( 
            /* [in][optional] */ VARIANT format,
            /* [out][retval] */ BSTR __RPC_FAR *text) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setText( 
            /* [in] */ BSTR text,
            /* [in][optional] */ VARIANT format) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE putInClipboard( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getFromClipboard( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startDrag( 
            /* [in][optional] */ VARIANT okEffect,
            /* [out][retval] */ fmDropEffect __RPC_FAR *effect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataAutoWrapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataAutoWrapper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataAutoWrapper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *clear )( 
            IDataAutoWrapper __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFormat )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [in] */ VARIANT format,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *support);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getText )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [in][optional] */ VARIANT format,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setText )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [in] */ BSTR text,
            /* [in][optional] */ VARIANT format);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putInClipboard )( 
            IDataAutoWrapper __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFromClipboard )( 
            IDataAutoWrapper __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startDrag )( 
            IDataAutoWrapper __RPC_FAR * This,
            /* [in][optional] */ VARIANT okEffect,
            /* [out][retval] */ fmDropEffect __RPC_FAR *effect);
        
        END_INTERFACE
    } IDataAutoWrapperVtbl;

    interface IDataAutoWrapper
    {
        CONST_VTBL struct IDataAutoWrapperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataAutoWrapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataAutoWrapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataAutoWrapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataAutoWrapper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDataAutoWrapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDataAutoWrapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDataAutoWrapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDataAutoWrapper_clear(This)	\
    (This)->lpVtbl -> clear(This)

#define IDataAutoWrapper_getFormat(This,format,support)	\
    (This)->lpVtbl -> getFormat(This,format,support)

#define IDataAutoWrapper_getText(This,format,text)	\
    (This)->lpVtbl -> getText(This,format,text)

#define IDataAutoWrapper_setText(This,text,format)	\
    (This)->lpVtbl -> setText(This,text,format)

#define IDataAutoWrapper_putInClipboard(This)	\
    (This)->lpVtbl -> putInClipboard(This)

#define IDataAutoWrapper_getFromClipboard(This)	\
    (This)->lpVtbl -> getFromClipboard(This)

#define IDataAutoWrapper_startDrag(This,okEffect,effect)	\
    (This)->lpVtbl -> startDrag(This,okEffect,effect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IDataAutoWrapper_clear_Proxy( 
    IDataAutoWrapper __RPC_FAR * This);


void __RPC_STUB IDataAutoWrapper_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDataAutoWrapper_getFormat_Proxy( 
    IDataAutoWrapper __RPC_FAR * This,
    /* [in] */ VARIANT format,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *support);


void __RPC_STUB IDataAutoWrapper_getFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDataAutoWrapper_getText_Proxy( 
    IDataAutoWrapper __RPC_FAR * This,
    /* [in][optional] */ VARIANT format,
    /* [out][retval] */ BSTR __RPC_FAR *text);


void __RPC_STUB IDataAutoWrapper_getText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDataAutoWrapper_setText_Proxy( 
    IDataAutoWrapper __RPC_FAR * This,
    /* [in] */ BSTR text,
    /* [in][optional] */ VARIANT format);


void __RPC_STUB IDataAutoWrapper_setText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDataAutoWrapper_putInClipboard_Proxy( 
    IDataAutoWrapper __RPC_FAR * This);


void __RPC_STUB IDataAutoWrapper_putInClipboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDataAutoWrapper_getFromClipboard_Proxy( 
    IDataAutoWrapper __RPC_FAR * This);


void __RPC_STUB IDataAutoWrapper_getFromClipboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDataAutoWrapper_startDrag_Proxy( 
    IDataAutoWrapper __RPC_FAR * This,
    /* [in][optional] */ VARIANT okEffect,
    /* [out][retval] */ fmDropEffect __RPC_FAR *effect);


void __RPC_STUB IDataAutoWrapper_startDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataAutoWrapper_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DataObject;

class DataObject;
#endif

#ifndef __IReturnInteger_INTERFACE_DEFINED__
#define __IReturnInteger_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReturnInteger
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IReturnInteger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReturnInteger : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ int v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ int __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReturnIntegerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReturnInteger __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReturnInteger __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReturnInteger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReturnInteger __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReturnInteger __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReturnInteger __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReturnInteger __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IReturnInteger __RPC_FAR * This,
            /* [in] */ int v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IReturnInteger __RPC_FAR * This,
            /* [out][retval] */ int __RPC_FAR *p);
        
        END_INTERFACE
    } IReturnIntegerVtbl;

    interface IReturnInteger
    {
        CONST_VTBL struct IReturnIntegerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReturnInteger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReturnInteger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReturnInteger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReturnInteger_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReturnInteger_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReturnInteger_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReturnInteger_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReturnInteger_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IReturnInteger_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IReturnInteger_put_value_Proxy( 
    IReturnInteger __RPC_FAR * This,
    /* [in] */ int v);


void __RPC_STUB IReturnInteger_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReturnInteger_get_value_Proxy( 
    IReturnInteger __RPC_FAR * This,
    /* [out][retval] */ int __RPC_FAR *p);


void __RPC_STUB IReturnInteger_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReturnInteger_INTERFACE_DEFINED__ */


#ifndef __IReturnBoolean_INTERFACE_DEFINED__
#define __IReturnBoolean_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReturnBoolean
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IReturnBoolean;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReturnBoolean : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReturnBooleanVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReturnBoolean __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReturnBoolean __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReturnBoolean __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReturnBoolean __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReturnBoolean __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReturnBoolean __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReturnBoolean __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IReturnBoolean __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IReturnBoolean __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        END_INTERFACE
    } IReturnBooleanVtbl;

    interface IReturnBoolean
    {
        CONST_VTBL struct IReturnBooleanVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReturnBoolean_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReturnBoolean_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReturnBoolean_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReturnBoolean_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReturnBoolean_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReturnBoolean_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReturnBoolean_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReturnBoolean_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IReturnBoolean_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IReturnBoolean_put_value_Proxy( 
    IReturnBoolean __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IReturnBoolean_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReturnBoolean_get_value_Proxy( 
    IReturnBoolean __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IReturnBoolean_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReturnBoolean_INTERFACE_DEFINED__ */


#ifndef __IReturnString_INTERFACE_DEFINED__
#define __IReturnString_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReturnString
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IReturnString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReturnString : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReturnStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReturnString __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReturnString __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReturnString __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReturnString __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReturnString __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReturnString __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReturnString __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IReturnString __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IReturnString __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IReturnStringVtbl;

    interface IReturnString
    {
        CONST_VTBL struct IReturnStringVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReturnString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReturnString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReturnString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReturnString_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReturnString_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReturnString_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReturnString_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReturnString_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IReturnString_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IReturnString_put_value_Proxy( 
    IReturnString __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IReturnString_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReturnString_get_value_Proxy( 
    IReturnString __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IReturnString_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReturnString_INTERFACE_DEFINED__ */


#ifndef __IReturnSingle_INTERFACE_DEFINED__
#define __IReturnSingle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReturnSingle
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IReturnSingle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReturnSingle : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ float v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ float __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReturnSingleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReturnSingle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReturnSingle __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReturnSingle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReturnSingle __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReturnSingle __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReturnSingle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReturnSingle __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IReturnSingle __RPC_FAR * This,
            /* [in] */ float v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IReturnSingle __RPC_FAR * This,
            /* [out][retval] */ float __RPC_FAR *p);
        
        END_INTERFACE
    } IReturnSingleVtbl;

    interface IReturnSingle
    {
        CONST_VTBL struct IReturnSingleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReturnSingle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReturnSingle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReturnSingle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReturnSingle_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReturnSingle_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReturnSingle_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReturnSingle_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReturnSingle_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IReturnSingle_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IReturnSingle_put_value_Proxy( 
    IReturnSingle __RPC_FAR * This,
    /* [in] */ float v);


void __RPC_STUB IReturnSingle_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReturnSingle_get_value_Proxy( 
    IReturnSingle __RPC_FAR * This,
    /* [out][retval] */ float __RPC_FAR *p);


void __RPC_STUB IReturnSingle_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReturnSingle_INTERFACE_DEFINED__ */


#ifndef __IReturnEffect_INTERFACE_DEFINED__
#define __IReturnEffect_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReturnEffect
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IReturnEffect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReturnEffect : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ fmDropEffect v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ fmDropEffect __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReturnEffectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReturnEffect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReturnEffect __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReturnEffect __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReturnEffect __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReturnEffect __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReturnEffect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReturnEffect __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IReturnEffect __RPC_FAR * This,
            /* [in] */ fmDropEffect v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IReturnEffect __RPC_FAR * This,
            /* [out][retval] */ fmDropEffect __RPC_FAR *p);
        
        END_INTERFACE
    } IReturnEffectVtbl;

    interface IReturnEffect
    {
        CONST_VTBL struct IReturnEffectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReturnEffect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReturnEffect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReturnEffect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReturnEffect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReturnEffect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReturnEffect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReturnEffect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReturnEffect_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IReturnEffect_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IReturnEffect_put_value_Proxy( 
    IReturnEffect __RPC_FAR * This,
    /* [in] */ fmDropEffect v);


void __RPC_STUB IReturnEffect_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReturnEffect_get_value_Proxy( 
    IReturnEffect __RPC_FAR * This,
    /* [out][retval] */ fmDropEffect __RPC_FAR *p);


void __RPC_STUB IReturnEffect_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReturnEffect_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ReturnInteger;

class ReturnInteger;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ReturnBoolean;

class ReturnBoolean;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ReturnString;

class ReturnString;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ReturnSingle;

class ReturnSingle;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ReturnEffect;

class ReturnEffect;
#endif

#ifndef __IUnitMeasurement_INTERFACE_DEFINED__
#define __IUnitMeasurement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IUnitMeasurement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IUnitMeasurement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IUnitMeasurement : public IDispatch
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ float v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ float __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_unit( 
            /* [in] */ htmlUnits v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_unit( 
            /* [out][retval] */ htmlUnits __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_unitValue( 
            /* [in] */ float v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_unitValue( 
            /* [out][retval] */ float __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_htmlText( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_htmlText( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnitMeasurementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUnitMeasurement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUnitMeasurement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [in] */ float v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [out][retval] */ float __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_unit )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [in] */ htmlUnits v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unit )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [out][retval] */ htmlUnits __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_unitValue )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [in] */ float v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unitValue )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [out][retval] */ float __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_htmlText )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_htmlText )( 
            IUnitMeasurement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IUnitMeasurementVtbl;

    interface IUnitMeasurement
    {
        CONST_VTBL struct IUnitMeasurementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnitMeasurement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnitMeasurement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnitMeasurement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnitMeasurement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IUnitMeasurement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IUnitMeasurement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IUnitMeasurement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IUnitMeasurement_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IUnitMeasurement_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IUnitMeasurement_put_unit(This,v)	\
    (This)->lpVtbl -> put_unit(This,v)

#define IUnitMeasurement_get_unit(This,p)	\
    (This)->lpVtbl -> get_unit(This,p)

#define IUnitMeasurement_put_unitValue(This,v)	\
    (This)->lpVtbl -> put_unitValue(This,v)

#define IUnitMeasurement_get_unitValue(This,p)	\
    (This)->lpVtbl -> get_unitValue(This,p)

#define IUnitMeasurement_put_htmlText(This,v)	\
    (This)->lpVtbl -> put_htmlText(This,v)

#define IUnitMeasurement_get_htmlText(This,p)	\
    (This)->lpVtbl -> get_htmlText(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IUnitMeasurement_put_value_Proxy( 
    IUnitMeasurement __RPC_FAR * This,
    /* [in] */ float v);


void __RPC_STUB IUnitMeasurement_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IUnitMeasurement_get_value_Proxy( 
    IUnitMeasurement __RPC_FAR * This,
    /* [out][retval] */ float __RPC_FAR *p);


void __RPC_STUB IUnitMeasurement_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IUnitMeasurement_put_unit_Proxy( 
    IUnitMeasurement __RPC_FAR * This,
    /* [in] */ htmlUnits v);


void __RPC_STUB IUnitMeasurement_put_unit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IUnitMeasurement_get_unit_Proxy( 
    IUnitMeasurement __RPC_FAR * This,
    /* [out][retval] */ htmlUnits __RPC_FAR *p);


void __RPC_STUB IUnitMeasurement_get_unit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IUnitMeasurement_put_unitValue_Proxy( 
    IUnitMeasurement __RPC_FAR * This,
    /* [in] */ float v);


void __RPC_STUB IUnitMeasurement_put_unitValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IUnitMeasurement_get_unitValue_Proxy( 
    IUnitMeasurement __RPC_FAR * This,
    /* [out][retval] */ float __RPC_FAR *p);


void __RPC_STUB IUnitMeasurement_get_unitValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IUnitMeasurement_put_htmlText_Proxy( 
    IUnitMeasurement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IUnitMeasurement_put_htmlText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IUnitMeasurement_get_htmlText_Proxy( 
    IUnitMeasurement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IUnitMeasurement_get_htmlText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnitMeasurement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_UnitMeasurement;

class UnitMeasurement;
#endif

#ifndef __IStyle_INTERFACE_DEFINED__
#define __IStyle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStyle
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IStyle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IStyle : public IDispatch
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_backgroundImage( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_backgroundImage( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_color( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_color( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_textAlign( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_textAlign( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_textTransform( 
            /* [in] */ styleTextTransform v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_textTransform( 
            /* [out][retval] */ styleTextTransform __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_height( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_width( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_top( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_left( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_layout( 
            /* [out][retval] */ styleLayout __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_lineHeight( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_letterSpacing( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_dataRepeat( 
            /* [in] */ styleDataRepeat v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_dataRepeat( 
            /* [out][retval] */ styleDataRepeat __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_overflow( 
            /* [in] */ styleOverflow v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_overflow( 
            /* [out][retval] */ styleOverflow __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_paddingTop( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_paddingRight( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_paddingBottom( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_paddingLeft( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_clear( 
            /* [in] */ htmlClear v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_clear( 
            /* [out][retval] */ htmlClear __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_fontSize( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_fontSize( 
            /* [out][retval] */ VARIANT __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_fontFamily( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_fontFamily( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_textDecorationLineThrough( 
            /* [in] */ styleTextDecorationLineThrough v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_textDecorationLineThrough( 
            /* [out][retval] */ styleTextDecorationLineThrough __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_textDecorationUnderline( 
            /* [in] */ styleTextDecorationUnderline v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_textDecorationUnderline( 
            /* [out][retval] */ styleTextDecorationUnderline __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_textDecorationNone( 
            /* [in] */ styleTextDecorationNone v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_textDecorationNone( 
            /* [out][retval] */ styleTextDecorationNone __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_fontStyle( 
            /* [in] */ styleFontStyle v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_fontStyle( 
            /* [out][retval] */ styleFontStyle __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_fontVariant( 
            /* [in] */ styleFontVariant v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_fontVariant( 
            /* [out][retval] */ styleFontVariant __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_backgroundColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_backgroundColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_fontWeight( 
            /* [in] */ styleFontWeight v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_fontWeight( 
            /* [out][retval] */ styleFontWeight __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_marginTop( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_marginRight( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_marginBottom( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_marginLeft( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStyle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStyle __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStyle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStyle __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStyle __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStyle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStyle __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_backgroundImage )( 
            IStyle __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_backgroundImage )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_color )( 
            IStyle __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_color )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_textAlign )( 
            IStyle __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_textAlign )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_textTransform )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleTextTransform v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_textTransform )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleTextTransform __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_top )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_left )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_layout )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleLayout __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lineHeight )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_letterSpacing )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataRepeat )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleDataRepeat v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataRepeat )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleDataRepeat __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_overflow )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleOverflow v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_overflow )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleOverflow __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_paddingTop )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_paddingRight )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_paddingBottom )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_paddingLeft )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_clear )( 
            IStyle __RPC_FAR * This,
            /* [in] */ htmlClear v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_clear )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ htmlClear __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fontSize )( 
            IStyle __RPC_FAR * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fontSize )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fontFamily )( 
            IStyle __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fontFamily )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_textDecorationLineThrough )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleTextDecorationLineThrough v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_textDecorationLineThrough )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleTextDecorationLineThrough __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_textDecorationUnderline )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleTextDecorationUnderline v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_textDecorationUnderline )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleTextDecorationUnderline __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_textDecorationNone )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleTextDecorationNone v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_textDecorationNone )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleTextDecorationNone __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fontStyle )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleFontStyle v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fontStyle )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleFontStyle __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fontVariant )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleFontVariant v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fontVariant )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleFontVariant __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_backgroundColor )( 
            IStyle __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_backgroundColor )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fontWeight )( 
            IStyle __RPC_FAR * This,
            /* [in] */ styleFontWeight v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fontWeight )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ styleFontWeight __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginTop )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginRight )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginBottom )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginLeft )( 
            IStyle __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        END_INTERFACE
    } IStyleVtbl;

    interface IStyle
    {
        CONST_VTBL struct IStyleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStyle_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStyle_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStyle_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStyle_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStyle_put_backgroundImage(This,v)	\
    (This)->lpVtbl -> put_backgroundImage(This,v)

#define IStyle_get_backgroundImage(This,p)	\
    (This)->lpVtbl -> get_backgroundImage(This,p)

#define IStyle_put_color(This,v)	\
    (This)->lpVtbl -> put_color(This,v)

#define IStyle_get_color(This,p)	\
    (This)->lpVtbl -> get_color(This,p)

#define IStyle_put_textAlign(This,v)	\
    (This)->lpVtbl -> put_textAlign(This,v)

#define IStyle_get_textAlign(This,p)	\
    (This)->lpVtbl -> get_textAlign(This,p)

#define IStyle_put_textTransform(This,v)	\
    (This)->lpVtbl -> put_textTransform(This,v)

#define IStyle_get_textTransform(This,p)	\
    (This)->lpVtbl -> get_textTransform(This,p)

#define IStyle_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IStyle_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)

#define IStyle_get_top(This,p)	\
    (This)->lpVtbl -> get_top(This,p)

#define IStyle_get_left(This,p)	\
    (This)->lpVtbl -> get_left(This,p)

#define IStyle_get_layout(This,p)	\
    (This)->lpVtbl -> get_layout(This,p)

#define IStyle_get_lineHeight(This,p)	\
    (This)->lpVtbl -> get_lineHeight(This,p)

#define IStyle_get_letterSpacing(This,p)	\
    (This)->lpVtbl -> get_letterSpacing(This,p)

#define IStyle_put_dataRepeat(This,v)	\
    (This)->lpVtbl -> put_dataRepeat(This,v)

#define IStyle_get_dataRepeat(This,p)	\
    (This)->lpVtbl -> get_dataRepeat(This,p)

#define IStyle_put_overflow(This,v)	\
    (This)->lpVtbl -> put_overflow(This,v)

#define IStyle_get_overflow(This,p)	\
    (This)->lpVtbl -> get_overflow(This,p)

#define IStyle_get_paddingTop(This,p)	\
    (This)->lpVtbl -> get_paddingTop(This,p)

#define IStyle_get_paddingRight(This,p)	\
    (This)->lpVtbl -> get_paddingRight(This,p)

#define IStyle_get_paddingBottom(This,p)	\
    (This)->lpVtbl -> get_paddingBottom(This,p)

#define IStyle_get_paddingLeft(This,p)	\
    (This)->lpVtbl -> get_paddingLeft(This,p)

#define IStyle_put_clear(This,v)	\
    (This)->lpVtbl -> put_clear(This,v)

#define IStyle_get_clear(This,p)	\
    (This)->lpVtbl -> get_clear(This,p)

#define IStyle_put_fontSize(This,v)	\
    (This)->lpVtbl -> put_fontSize(This,v)

#define IStyle_get_fontSize(This,p)	\
    (This)->lpVtbl -> get_fontSize(This,p)

#define IStyle_put_fontFamily(This,v)	\
    (This)->lpVtbl -> put_fontFamily(This,v)

#define IStyle_get_fontFamily(This,p)	\
    (This)->lpVtbl -> get_fontFamily(This,p)

#define IStyle_put_textDecorationLineThrough(This,v)	\
    (This)->lpVtbl -> put_textDecorationLineThrough(This,v)

#define IStyle_get_textDecorationLineThrough(This,p)	\
    (This)->lpVtbl -> get_textDecorationLineThrough(This,p)

#define IStyle_put_textDecorationUnderline(This,v)	\
    (This)->lpVtbl -> put_textDecorationUnderline(This,v)

#define IStyle_get_textDecorationUnderline(This,p)	\
    (This)->lpVtbl -> get_textDecorationUnderline(This,p)

#define IStyle_put_textDecorationNone(This,v)	\
    (This)->lpVtbl -> put_textDecorationNone(This,v)

#define IStyle_get_textDecorationNone(This,p)	\
    (This)->lpVtbl -> get_textDecorationNone(This,p)

#define IStyle_put_fontStyle(This,v)	\
    (This)->lpVtbl -> put_fontStyle(This,v)

#define IStyle_get_fontStyle(This,p)	\
    (This)->lpVtbl -> get_fontStyle(This,p)

#define IStyle_put_fontVariant(This,v)	\
    (This)->lpVtbl -> put_fontVariant(This,v)

#define IStyle_get_fontVariant(This,p)	\
    (This)->lpVtbl -> get_fontVariant(This,p)

#define IStyle_put_backgroundColor(This,v)	\
    (This)->lpVtbl -> put_backgroundColor(This,v)

#define IStyle_get_backgroundColor(This,p)	\
    (This)->lpVtbl -> get_backgroundColor(This,p)

#define IStyle_put_fontWeight(This,v)	\
    (This)->lpVtbl -> put_fontWeight(This,v)

#define IStyle_get_fontWeight(This,p)	\
    (This)->lpVtbl -> get_fontWeight(This,p)

#define IStyle_get_marginTop(This,p)	\
    (This)->lpVtbl -> get_marginTop(This,p)

#define IStyle_get_marginRight(This,p)	\
    (This)->lpVtbl -> get_marginRight(This,p)

#define IStyle_get_marginBottom(This,p)	\
    (This)->lpVtbl -> get_marginBottom(This,p)

#define IStyle_get_marginLeft(This,p)	\
    (This)->lpVtbl -> get_marginLeft(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_backgroundImage_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IStyle_put_backgroundImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_backgroundImage_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IStyle_get_backgroundImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_color_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IStyle_put_color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_color_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IStyle_get_color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_textAlign_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IStyle_put_textAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_textAlign_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IStyle_get_textAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_textTransform_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleTextTransform v);


void __RPC_STUB IStyle_put_textTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_textTransform_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleTextTransform __RPC_FAR *p);


void __RPC_STUB IStyle_get_textTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_height_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_width_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_top_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_left_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_layout_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleLayout __RPC_FAR *p);


void __RPC_STUB IStyle_get_layout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_lineHeight_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_lineHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_letterSpacing_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_letterSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_dataRepeat_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleDataRepeat v);


void __RPC_STUB IStyle_put_dataRepeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_dataRepeat_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleDataRepeat __RPC_FAR *p);


void __RPC_STUB IStyle_get_dataRepeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_overflow_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleOverflow v);


void __RPC_STUB IStyle_put_overflow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_overflow_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleOverflow __RPC_FAR *p);


void __RPC_STUB IStyle_get_overflow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_paddingTop_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_paddingTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_paddingRight_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_paddingRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_paddingBottom_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_paddingBottom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_paddingLeft_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_paddingLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_clear_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ htmlClear v);


void __RPC_STUB IStyle_put_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_clear_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ htmlClear __RPC_FAR *p);


void __RPC_STUB IStyle_get_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_fontSize_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IStyle_put_fontSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_fontSize_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *p);


void __RPC_STUB IStyle_get_fontSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_fontFamily_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IStyle_put_fontFamily_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_fontFamily_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IStyle_get_fontFamily_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_textDecorationLineThrough_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleTextDecorationLineThrough v);


void __RPC_STUB IStyle_put_textDecorationLineThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_textDecorationLineThrough_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleTextDecorationLineThrough __RPC_FAR *p);


void __RPC_STUB IStyle_get_textDecorationLineThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_textDecorationUnderline_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleTextDecorationUnderline v);


void __RPC_STUB IStyle_put_textDecorationUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_textDecorationUnderline_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleTextDecorationUnderline __RPC_FAR *p);


void __RPC_STUB IStyle_get_textDecorationUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_textDecorationNone_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleTextDecorationNone v);


void __RPC_STUB IStyle_put_textDecorationNone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_textDecorationNone_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleTextDecorationNone __RPC_FAR *p);


void __RPC_STUB IStyle_get_textDecorationNone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_fontStyle_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleFontStyle v);


void __RPC_STUB IStyle_put_fontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_fontStyle_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleFontStyle __RPC_FAR *p);


void __RPC_STUB IStyle_get_fontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_fontVariant_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleFontVariant v);


void __RPC_STUB IStyle_put_fontVariant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_fontVariant_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleFontVariant __RPC_FAR *p);


void __RPC_STUB IStyle_get_fontVariant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_backgroundColor_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IStyle_put_backgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_backgroundColor_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IStyle_get_backgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IStyle_put_fontWeight_Proxy( 
    IStyle __RPC_FAR * This,
    /* [in] */ styleFontWeight v);


void __RPC_STUB IStyle_put_fontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_fontWeight_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ styleFontWeight __RPC_FAR *p);


void __RPC_STUB IStyle_get_fontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_marginTop_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_marginTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_marginRight_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_marginRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_marginBottom_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_marginBottom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IStyle_get_marginLeft_Proxy( 
    IStyle __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IStyle_get_marginLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStyle_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Style;

class Style;
#endif

#ifndef __IElement_INTERFACE_DEFINED__
#define __IElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IElement : public IDispatch
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_Class( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_id( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_id( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_parentElement( 
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_style( 
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE scrollIntoView( 
            /* [in][optional] */ VARIANT_BOOL Start) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        END_INTERFACE
    } IElementVtbl;

    interface IElement
    {
        CONST_VTBL struct IElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IElement_put_Class_Proxy( 
    IElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IElement_put_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IElement_get_Class_Proxy( 
    IElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IElement_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IElement_put_id_Proxy( 
    IElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IElement_put_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IElement_get_id_Proxy( 
    IElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IElement_get_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IElement_get_tagName_Proxy( 
    IElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IElement_get_parentElement_Proxy( 
    IElement __RPC_FAR * This,
    /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IElement_get_parentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IElement_get_count_Proxy( 
    IElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IElement_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IElement_get_style_Proxy( 
    IElement __RPC_FAR * This,
    /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IElement_get_style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IElement_scrollIntoView_Proxy( 
    IElement __RPC_FAR * This,
    /* [in][optional] */ VARIANT_BOOL Start);


void __RPC_STUB IElement_scrollIntoView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElement_INTERFACE_DEFINED__ */


#ifndef __ITxtRange_INTERFACE_DEFINED__
#define __ITxtRange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITxtRange
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITxtRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITxtRange : public IDispatch
    {
    public:
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_end( 
            /* [in] */ long v) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_end( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_start( 
            /* [in] */ long v) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_start( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_htmlText( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_htmlText( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE parentElement( 
            /* [in][defaultvalue] */ long Cp,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *Parent) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE commonParentElement( 
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *Parent) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE duplicate( 
            /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *Duplicate) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE inRange( 
            /* [in] */ ITxtRange __RPC_FAR *Range,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *InRange) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE isEqual( 
            /* [in] */ ITxtRange __RPC_FAR *Range,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *IsEqual) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE scrollIntoView( 
            /* [in][defaultvalue] */ VARIANT_BOOL Start) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE collapse( 
            /* [in][defaultvalue] */ VARIANT_BOOL Start) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE expand( 
            /* [in] */ htmlUnit Unit,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *Success) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE move( 
            /* [in] */ htmlUnit Unit,
            /* [in][defaultvalue] */ long Count,
            /* [out][retval][optional] */ long __RPC_FAR *ActualCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE moveStart( 
            /* [in] */ htmlUnit Unit,
            /* [in][defaultvalue] */ long Count,
            /* [out][retval] */ long __RPC_FAR *ActualCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE moveEnd( 
            /* [in] */ htmlUnit Unit,
            /* [in][defaultvalue] */ long Count,
            /* [out][retval] */ long __RPC_FAR *ActualCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setRange( 
            /* [in] */ long Start,
            /* [in] */ long End) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE execCommand( 
            /* [in] */ long cmdID,
            /* [in][optional] */ VARIANT value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE queryStatus( 
            /* [in] */ long cmdID,
            /* [out][retval] */ VARIANT __RPC_FAR *Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE select( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE isEmbed( 
            /* [in][defaultvalue] */ long Cp,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *IsEmbed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITxtRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITxtRange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITxtRange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITxtRange __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_end )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_end )( 
            ITxtRange __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_start )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_start )( 
            ITxtRange __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_htmlText )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_htmlText )( 
            ITxtRange __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            ITxtRange __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *parentElement )( 
            ITxtRange __RPC_FAR * This,
            /* [in][defaultvalue] */ long Cp,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *Parent);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *commonParentElement )( 
            ITxtRange __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *Parent);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *duplicate )( 
            ITxtRange __RPC_FAR * This,
            /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *Duplicate);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *inRange )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ ITxtRange __RPC_FAR *Range,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *InRange);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isEqual )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ ITxtRange __RPC_FAR *Range,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITxtRange __RPC_FAR * This,
            /* [in][defaultvalue] */ VARIANT_BOOL Start);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *collapse )( 
            ITxtRange __RPC_FAR * This,
            /* [in][defaultvalue] */ VARIANT_BOOL Start);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *expand )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ htmlUnit Unit,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *Success);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *move )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ htmlUnit Unit,
            /* [in][defaultvalue] */ long Count,
            /* [out][retval][optional] */ long __RPC_FAR *ActualCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *moveStart )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ htmlUnit Unit,
            /* [in][defaultvalue] */ long Count,
            /* [out][retval] */ long __RPC_FAR *ActualCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *moveEnd )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ htmlUnit Unit,
            /* [in][defaultvalue] */ long Count,
            /* [out][retval] */ long __RPC_FAR *ActualCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setRange )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ long Start,
            /* [in] */ long End);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *execCommand )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ long cmdID,
            /* [in][optional] */ VARIANT value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *queryStatus )( 
            ITxtRange __RPC_FAR * This,
            /* [in] */ long cmdID,
            /* [out][retval] */ VARIANT __RPC_FAR *Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *select )( 
            ITxtRange __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isEmbed )( 
            ITxtRange __RPC_FAR * This,
            /* [in][defaultvalue] */ long Cp,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *IsEmbed);
        
        END_INTERFACE
    } ITxtRangeVtbl;

    interface ITxtRange
    {
        CONST_VTBL struct ITxtRangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITxtRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITxtRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITxtRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITxtRange_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITxtRange_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITxtRange_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITxtRange_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITxtRange_put_end(This,v)	\
    (This)->lpVtbl -> put_end(This,v)

#define ITxtRange_get_end(This,p)	\
    (This)->lpVtbl -> get_end(This,p)

#define ITxtRange_put_start(This,v)	\
    (This)->lpVtbl -> put_start(This,v)

#define ITxtRange_get_start(This,p)	\
    (This)->lpVtbl -> get_start(This,p)

#define ITxtRange_put_htmlText(This,v)	\
    (This)->lpVtbl -> put_htmlText(This,v)

#define ITxtRange_get_htmlText(This,p)	\
    (This)->lpVtbl -> get_htmlText(This,p)

#define ITxtRange_put_text(This,v)	\
    (This)->lpVtbl -> put_text(This,v)

#define ITxtRange_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define ITxtRange_parentElement(This,Cp,Parent)	\
    (This)->lpVtbl -> parentElement(This,Cp,Parent)

#define ITxtRange_commonParentElement(This,Parent)	\
    (This)->lpVtbl -> commonParentElement(This,Parent)

#define ITxtRange_duplicate(This,Duplicate)	\
    (This)->lpVtbl -> duplicate(This,Duplicate)

#define ITxtRange_inRange(This,Range,InRange)	\
    (This)->lpVtbl -> inRange(This,Range,InRange)

#define ITxtRange_isEqual(This,Range,IsEqual)	\
    (This)->lpVtbl -> isEqual(This,Range,IsEqual)

#define ITxtRange_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)

#define ITxtRange_collapse(This,Start)	\
    (This)->lpVtbl -> collapse(This,Start)

#define ITxtRange_expand(This,Unit,Success)	\
    (This)->lpVtbl -> expand(This,Unit,Success)

#define ITxtRange_move(This,Unit,Count,ActualCount)	\
    (This)->lpVtbl -> move(This,Unit,Count,ActualCount)

#define ITxtRange_moveStart(This,Unit,Count,ActualCount)	\
    (This)->lpVtbl -> moveStart(This,Unit,Count,ActualCount)

#define ITxtRange_moveEnd(This,Unit,Count,ActualCount)	\
    (This)->lpVtbl -> moveEnd(This,Unit,Count,ActualCount)

#define ITxtRange_setRange(This,Start,End)	\
    (This)->lpVtbl -> setRange(This,Start,End)

#define ITxtRange_execCommand(This,cmdID,value)	\
    (This)->lpVtbl -> execCommand(This,cmdID,value)

#define ITxtRange_queryStatus(This,cmdID,Value)	\
    (This)->lpVtbl -> queryStatus(This,cmdID,Value)

#define ITxtRange_select(This)	\
    (This)->lpVtbl -> select(This)

#define ITxtRange_isEmbed(This,Cp,IsEmbed)	\
    (This)->lpVtbl -> isEmbed(This,Cp,IsEmbed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE ITxtRange_put_end_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITxtRange_put_end_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE ITxtRange_get_end_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITxtRange_get_end_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE ITxtRange_put_start_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITxtRange_put_start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE ITxtRange_get_start_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITxtRange_get_start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE ITxtRange_put_htmlText_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITxtRange_put_htmlText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE ITxtRange_get_htmlText_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITxtRange_get_htmlText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE ITxtRange_put_text_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITxtRange_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE ITxtRange_get_text_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITxtRange_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_parentElement_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in][defaultvalue] */ long Cp,
    /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *Parent);


void __RPC_STUB ITxtRange_parentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_commonParentElement_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *Parent);


void __RPC_STUB ITxtRange_commonParentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_duplicate_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *Duplicate);


void __RPC_STUB ITxtRange_duplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_inRange_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ ITxtRange __RPC_FAR *Range,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *InRange);


void __RPC_STUB ITxtRange_inRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_isEqual_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ ITxtRange __RPC_FAR *Range,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *IsEqual);


void __RPC_STUB ITxtRange_isEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_scrollIntoView_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in][defaultvalue] */ VARIANT_BOOL Start);


void __RPC_STUB ITxtRange_scrollIntoView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_collapse_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in][defaultvalue] */ VARIANT_BOOL Start);


void __RPC_STUB ITxtRange_collapse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_expand_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ htmlUnit Unit,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *Success);


void __RPC_STUB ITxtRange_expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_move_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ htmlUnit Unit,
    /* [in][defaultvalue] */ long Count,
    /* [out][retval][optional] */ long __RPC_FAR *ActualCount);


void __RPC_STUB ITxtRange_move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_moveStart_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ htmlUnit Unit,
    /* [in][defaultvalue] */ long Count,
    /* [out][retval] */ long __RPC_FAR *ActualCount);


void __RPC_STUB ITxtRange_moveStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_moveEnd_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ htmlUnit Unit,
    /* [in][defaultvalue] */ long Count,
    /* [out][retval] */ long __RPC_FAR *ActualCount);


void __RPC_STUB ITxtRange_moveEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_setRange_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ long Start,
    /* [in] */ long End);


void __RPC_STUB ITxtRange_setRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_execCommand_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ long cmdID,
    /* [in][optional] */ VARIANT value);


void __RPC_STUB ITxtRange_execCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_queryStatus_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in] */ long cmdID,
    /* [out][retval] */ VARIANT __RPC_FAR *Value);


void __RPC_STUB ITxtRange_queryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_select_Proxy( 
    ITxtRange __RPC_FAR * This);


void __RPC_STUB ITxtRange_select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtRange_isEmbed_Proxy( 
    ITxtRange __RPC_FAR * This,
    /* [in][defaultvalue] */ long Cp,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *IsEmbed);


void __RPC_STUB ITxtRange_isEmbed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITxtRange_INTERFACE_DEFINED__ */


#ifndef __ControlElementEvents_DISPINTERFACE_DEFINED__
#define __ControlElementEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: ControlElementEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_ControlElementEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface ControlElementEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct ControlElementEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ControlElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ControlElementEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ControlElementEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ControlElementEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ControlElementEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ControlElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ControlElementEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } ControlElementEventsVtbl;

    interface ControlElementEvents
    {
        CONST_VTBL struct ControlElementEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ControlElementEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ControlElementEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ControlElementEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ControlElementEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ControlElementEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ControlElementEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ControlElementEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ControlElementEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IControlElement_INTERFACE_DEFINED__
#define __IControlElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IControlElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IControlElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IControlElement : public IElement
    {
    public:
        virtual /* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_title( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_visible( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_visible( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_tabIndex( 
            /* [in] */ short v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_tabIndex( 
            /* [out][retval] */ short __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE zOrder( 
            /* [in][optional][defaultvalue] */ fmZOrder zPosition) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_height( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_width( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IControlElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IControlElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IControlElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IControlElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IControlElement __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IControlElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IControlElement __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IControlElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        END_INTERFACE
    } IControlElementVtbl;

    interface IControlElement
    {
        CONST_VTBL struct IControlElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControlElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControlElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IControlElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IControlElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IControlElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IControlElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IControlElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IControlElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IControlElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IControlElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IControlElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IControlElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IControlElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IControlElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IControlElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IControlElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IControlElement_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IControlElement_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IControlElement_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IControlElement_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IControlElement_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IControlElement_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IControlElement_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IControlElement_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IControlElement_put_title_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IControlElement_put_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IControlElement_get_title_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IControlElement_get_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IControlElement_put_visible_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IControlElement_put_visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IControlElement_get_visible_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IControlElement_get_visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IControlElement_put_tabIndex_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [in] */ short v);


void __RPC_STUB IControlElement_put_tabIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IControlElement_get_tabIndex_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [out][retval] */ short __RPC_FAR *p);


void __RPC_STUB IControlElement_get_tabIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IControlElement_setFocus_Proxy( 
    IControlElement __RPC_FAR * This);


void __RPC_STUB IControlElement_setFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlElement_zOrder_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [in][optional][defaultvalue] */ fmZOrder zPosition);


void __RPC_STUB IControlElement_zOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IControlElement_get_height_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IControlElement_get_height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IControlElement_get_width_Proxy( 
    IControlElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IControlElement_get_width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControlElement_INTERFACE_DEFINED__ */


#ifndef __IEnumControl_INTERFACE_DEFINED__
#define __IEnumControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumControl
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IEnumControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumControl : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE next( 
            /* [in] */ ULONG celt,
            /* [out][in] */ IControlElement __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE clone( 
            /* [out] */ IEnumControl __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEnumControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEnumControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEnumControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEnumControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *next )( 
            IEnumControl __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out][in] */ IControlElement __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *skip )( 
            IEnumControl __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *reset )( 
            IEnumControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *clone )( 
            IEnumControl __RPC_FAR * This,
            /* [out] */ IEnumControl __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumControlVtbl;

    interface IEnumControl
    {
        CONST_VTBL struct IEnumControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEnumControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEnumControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEnumControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEnumControl_next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> next(This,celt,rgelt,pceltFetched)

#define IEnumControl_skip(This,celt)	\
    (This)->lpVtbl -> skip(This,celt)

#define IEnumControl_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IEnumControl_clone(This,ppenum)	\
    (This)->lpVtbl -> clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumControl_next_Proxy( 
    IEnumControl __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out][in] */ IControlElement __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumControl_next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumControl_skip_Proxy( 
    IEnumControl __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumControl_skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumControl_reset_Proxy( 
    IEnumControl __RPC_FAR * This);


void __RPC_STUB IEnumControl_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumControl_clone_Proxy( 
    IEnumControl __RPC_FAR * This,
    /* [out] */ IEnumControl __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumControl_clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumControl_INTERFACE_DEFINED__ */


#ifndef __ITextElement_INTERFACE_DEFINED__
#define __ITextElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITextElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITextElement : public IElement
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ITextElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITextElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITextElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITextElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITextElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITextElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITextElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITextElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITextElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITextElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        END_INTERFACE
    } ITextElementVtbl;

    interface ITextElement
    {
        CONST_VTBL struct ITextElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITextElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITextElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITextElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITextElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITextElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITextElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITextElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITextElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TextElement;

class TextElement;
#endif

#ifndef __TextEditEvents_DISPINTERFACE_DEFINED__
#define __TextEditEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: TextEditEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_TextEditEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface TextEditEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct TextEditEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            TextEditEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            TextEditEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            TextEditEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            TextEditEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            TextEditEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            TextEditEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            TextEditEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } TextEditEventsVtbl;

    interface TextEditEvents
    {
        CONST_VTBL struct TextEditEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define TextEditEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define TextEditEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define TextEditEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define TextEditEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define TextEditEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define TextEditEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define TextEditEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __TextEditEvents_DISPINTERFACE_DEFINED__ */


#ifndef __ITxtEdit_INTERFACE_DEFINED__
#define __ITxtEdit_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITxtEdit
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITxtEdit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITxtEdit : public IControlElement
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE createTextRange( 
            /* [in][defaultvalue] */ long begin,
            /* [in][defaultvalue] */ long end,
            /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *range) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE createControlRange( 
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *range) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITxtEditVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITxtEdit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITxtEdit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITxtEdit __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITxtEdit __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            ITxtEdit __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            ITxtEdit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            ITxtEdit __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createTextRange )( 
            ITxtEdit __RPC_FAR * This,
            /* [in][defaultvalue] */ long begin,
            /* [in][defaultvalue] */ long end,
            /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *range);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createControlRange )( 
            ITxtEdit __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *range);
        
        END_INTERFACE
    } ITxtEditVtbl;

    interface ITxtEdit
    {
        CONST_VTBL struct ITxtEditVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITxtEdit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITxtEdit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITxtEdit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITxtEdit_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITxtEdit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITxtEdit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITxtEdit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITxtEdit_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITxtEdit_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITxtEdit_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITxtEdit_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITxtEdit_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITxtEdit_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITxtEdit_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITxtEdit_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITxtEdit_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ITxtEdit_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define ITxtEdit_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define ITxtEdit_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define ITxtEdit_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define ITxtEdit_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define ITxtEdit_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define ITxtEdit_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define ITxtEdit_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define ITxtEdit_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define ITxtEdit_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define ITxtEdit_createTextRange(This,begin,end,range)	\
    (This)->lpVtbl -> createTextRange(This,begin,end,range)

#define ITxtEdit_createControlRange(This,range)	\
    (This)->lpVtbl -> createControlRange(This,range)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ITxtEdit_createTextRange_Proxy( 
    ITxtEdit __RPC_FAR * This,
    /* [in][defaultvalue] */ long begin,
    /* [in][defaultvalue] */ long end,
    /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *range);


void __RPC_STUB ITxtEdit_createTextRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITxtEdit_createControlRange_Proxy( 
    ITxtEdit __RPC_FAR * This,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *range);


void __RPC_STUB ITxtEdit_createControlRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITxtEdit_INTERFACE_DEFINED__ */


#ifndef __IAutoTxtSiteRange_INTERFACE_DEFINED__
#define __IAutoTxtSiteRange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAutoTxtSiteRange
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IAutoTxtSiteRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAutoTxtSiteRange : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE execCommand( 
            /* [in] */ long cmdID,
            /* [in][optional] */ VARIANT value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE queryCommandStatus( 
            /* [in] */ long cmdID,
            /* [out][retval] */ VARIANT __RPC_FAR *Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE select( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE add( 
            /* [in] */ IControlElement __RPC_FAR *item) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE remove( 
            /* [in] */ long index) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][optional] */ long index,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *pdisp) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE scrollIntoView( 
            /* [in] */ VARIANT_BOOL Start) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoTxtSiteRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAutoTxtSiteRange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAutoTxtSiteRange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *execCommand )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ long cmdID,
            /* [in][optional] */ VARIANT value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *queryCommandStatus )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ long cmdID,
            /* [out][retval] */ VARIANT __RPC_FAR *Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *select )( 
            IAutoTxtSiteRange __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *add )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ IControlElement __RPC_FAR *item);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *remove )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ long index);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in][optional] */ long index,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *pdisp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Start);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IAutoTxtSiteRange __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        END_INTERFACE
    } IAutoTxtSiteRangeVtbl;

    interface IAutoTxtSiteRange
    {
        CONST_VTBL struct IAutoTxtSiteRangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoTxtSiteRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAutoTxtSiteRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAutoTxtSiteRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAutoTxtSiteRange_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAutoTxtSiteRange_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAutoTxtSiteRange_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAutoTxtSiteRange_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAutoTxtSiteRange_execCommand(This,cmdID,value)	\
    (This)->lpVtbl -> execCommand(This,cmdID,value)

#define IAutoTxtSiteRange_queryCommandStatus(This,cmdID,Value)	\
    (This)->lpVtbl -> queryCommandStatus(This,cmdID,Value)

#define IAutoTxtSiteRange_select(This)	\
    (This)->lpVtbl -> select(This)

#define IAutoTxtSiteRange_add(This,item)	\
    (This)->lpVtbl -> add(This,item)

#define IAutoTxtSiteRange_remove(This,index)	\
    (This)->lpVtbl -> remove(This,index)

#define IAutoTxtSiteRange_item(This,index,pdisp)	\
    (This)->lpVtbl -> item(This,index,pdisp)

#define IAutoTxtSiteRange_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)

#define IAutoTxtSiteRange_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IAutoTxtSiteRange_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_execCommand_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This,
    /* [in] */ long cmdID,
    /* [in][optional] */ VARIANT value);


void __RPC_STUB IAutoTxtSiteRange_execCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_queryCommandStatus_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This,
    /* [in] */ long cmdID,
    /* [out][retval] */ VARIANT __RPC_FAR *Value);


void __RPC_STUB IAutoTxtSiteRange_queryCommandStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_select_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This);


void __RPC_STUB IAutoTxtSiteRange_select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_add_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This,
    /* [in] */ IControlElement __RPC_FAR *item);


void __RPC_STUB IAutoTxtSiteRange_add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_remove_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This,
    /* [in] */ long index);


void __RPC_STUB IAutoTxtSiteRange_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_item_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This,
    /* [in][optional] */ long index,
    /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *pdisp);


void __RPC_STUB IAutoTxtSiteRange_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_scrollIntoView_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Start);


void __RPC_STUB IAutoTxtSiteRange_scrollIntoView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_get_count_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IAutoTxtSiteRange_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IAutoTxtSiteRange_get_length_Proxy( 
    IAutoTxtSiteRange __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IAutoTxtSiteRange_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAutoTxtSiteRange_INTERFACE_DEFINED__ */


#ifndef __IAuto2DSiteRange_INTERFACE_DEFINED__
#define __IAuto2DSiteRange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAuto2DSiteRange
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IAuto2DSiteRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAuto2DSiteRange : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE execCommand( 
            /* [in] */ long cmdID,
            /* [in][optional] */ VARIANT value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE queryCommandStatus( 
            /* [in] */ long cmdID,
            /* [out][retval] */ VARIANT __RPC_FAR *Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE select( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE add( 
            /* [in] */ IControlElement __RPC_FAR *item) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE remove( 
            /* [in] */ long index) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][optional] */ long index,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *pdisp) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuto2DSiteRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAuto2DSiteRange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAuto2DSiteRange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *execCommand )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in] */ long cmdID,
            /* [in][optional] */ VARIANT value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *queryCommandStatus )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in] */ long cmdID,
            /* [out][retval] */ VARIANT __RPC_FAR *Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *select )( 
            IAuto2DSiteRange __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *add )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in] */ IControlElement __RPC_FAR *item);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *remove )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in] */ long index);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [in][optional] */ long index,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *pdisp);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IAuto2DSiteRange __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        END_INTERFACE
    } IAuto2DSiteRangeVtbl;

    interface IAuto2DSiteRange
    {
        CONST_VTBL struct IAuto2DSiteRangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuto2DSiteRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuto2DSiteRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuto2DSiteRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuto2DSiteRange_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAuto2DSiteRange_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAuto2DSiteRange_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAuto2DSiteRange_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAuto2DSiteRange_execCommand(This,cmdID,value)	\
    (This)->lpVtbl -> execCommand(This,cmdID,value)

#define IAuto2DSiteRange_queryCommandStatus(This,cmdID,Value)	\
    (This)->lpVtbl -> queryCommandStatus(This,cmdID,Value)

#define IAuto2DSiteRange_select(This)	\
    (This)->lpVtbl -> select(This)

#define IAuto2DSiteRange_add(This,item)	\
    (This)->lpVtbl -> add(This,item)

#define IAuto2DSiteRange_remove(This,index)	\
    (This)->lpVtbl -> remove(This,index)

#define IAuto2DSiteRange_item(This,index,pdisp)	\
    (This)->lpVtbl -> item(This,index,pdisp)

#define IAuto2DSiteRange_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IAuto2DSiteRange_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IAuto2DSiteRange_execCommand_Proxy( 
    IAuto2DSiteRange __RPC_FAR * This,
    /* [in] */ long cmdID,
    /* [in][optional] */ VARIANT value);


void __RPC_STUB IAuto2DSiteRange_execCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAuto2DSiteRange_queryCommandStatus_Proxy( 
    IAuto2DSiteRange __RPC_FAR * This,
    /* [in] */ long cmdID,
    /* [out][retval] */ VARIANT __RPC_FAR *Value);


void __RPC_STUB IAuto2DSiteRange_queryCommandStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAuto2DSiteRange_select_Proxy( 
    IAuto2DSiteRange __RPC_FAR * This);


void __RPC_STUB IAuto2DSiteRange_select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAuto2DSiteRange_add_Proxy( 
    IAuto2DSiteRange __RPC_FAR * This,
    /* [in] */ IControlElement __RPC_FAR *item);


void __RPC_STUB IAuto2DSiteRange_add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAuto2DSiteRange_remove_Proxy( 
    IAuto2DSiteRange __RPC_FAR * This,
    /* [in] */ long index);


void __RPC_STUB IAuto2DSiteRange_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IAuto2DSiteRange_item_Proxy( 
    IAuto2DSiteRange __RPC_FAR * This,
    /* [in][optional] */ long index,
    /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *pdisp);


void __RPC_STUB IAuto2DSiteRange_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IAuto2DSiteRange_get_count_Proxy( 
    IAuto2DSiteRange __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IAuto2DSiteRange_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IAuto2DSiteRange_get_length_Proxy( 
    IAuto2DSiteRange __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IAuto2DSiteRange_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuto2DSiteRange_INTERFACE_DEFINED__ */


#ifndef __DivFixedElementEvents_DISPINTERFACE_DEFINED__
#define __DivFixedElementEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: DivFixedElementEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_DivFixedElementEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DivFixedElementEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DivFixedElementEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DivFixedElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DivFixedElementEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DivFixedElementEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DivFixedElementEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DivFixedElementEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DivFixedElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DivFixedElementEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DivFixedElementEventsVtbl;

    interface DivFixedElementEvents
    {
        CONST_VTBL struct DivFixedElementEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DivFixedElementEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DivFixedElementEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DivFixedElementEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DivFixedElementEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DivFixedElementEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DivFixedElementEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DivFixedElementEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DivFixedElementEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IDivFixed_INTERFACE_DEFINED__
#define __IDivFixed_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDivFixed
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IDivFixed;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDivFixed : public IControlElement
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE createControlRange( 
            /* [out][retval] */ IAuto2DSiteRange __RPC_FAR *__RPC_FAR *pdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDivFixedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDivFixed __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDivFixed __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDivFixed __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IDivFixed __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IDivFixed __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IDivFixed __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IDivFixed __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createControlRange )( 
            IDivFixed __RPC_FAR * This,
            /* [out][retval] */ IAuto2DSiteRange __RPC_FAR *__RPC_FAR *pdisp);
        
        END_INTERFACE
    } IDivFixedVtbl;

    interface IDivFixed
    {
        CONST_VTBL struct IDivFixedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDivFixed_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDivFixed_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDivFixed_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDivFixed_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDivFixed_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDivFixed_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDivFixed_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDivFixed_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IDivFixed_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IDivFixed_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IDivFixed_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IDivFixed_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IDivFixed_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IDivFixed_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IDivFixed_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IDivFixed_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IDivFixed_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IDivFixed_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IDivFixed_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IDivFixed_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IDivFixed_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IDivFixed_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IDivFixed_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IDivFixed_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IDivFixed_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IDivFixed_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IDivFixed_createControlRange(This,pdisp)	\
    (This)->lpVtbl -> createControlRange(This,pdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDivFixed_createControlRange_Proxy( 
    IDivFixed __RPC_FAR * This,
    /* [out][retval] */ IAuto2DSiteRange __RPC_FAR *__RPC_FAR *pdisp);


void __RPC_STUB IDivFixed_createControlRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDivFixed_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DivFixed;

class DivFixed;
#endif

#ifndef __ImgEvents_DISPINTERFACE_DEFINED__
#define __ImgEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: ImgEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_ImgEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface ImgEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct ImgEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ImgEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ImgEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ImgEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ImgEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ImgEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ImgEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ImgEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } ImgEventsVtbl;

    interface ImgEvents
    {
        CONST_VTBL struct ImgEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ImgEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ImgEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ImgEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ImgEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ImgEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ImgEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ImgEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ImgEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IImgElement_INTERFACE_DEFINED__
#define __IImgElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImgElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IImgElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImgElement : public IControlElement
    {
    public:
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_border( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_vSpace( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_vSpace( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_hSpace( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_hSpace( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_alt( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_alt( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_isMap( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_isMap( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_src( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_src( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_lowSrc( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_lowSrc( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_useMap( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_useMap( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_vrml( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_vrml( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_dynSrc( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_dynSrc( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ htmlReadyState __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_complete( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_loop( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_loop( 
            /* [out][retval] */ VARIANT __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlControlAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlControlAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onLoad( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onError( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onError( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onAbort( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onAbort( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_language( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImgElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImgElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImgElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IImgElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IImgElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IImgElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IImgElement __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_border )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vSpace )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vSpace )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_hSpace )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_hSpace )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_alt )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_alt )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_isMap )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isMap )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_src )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_src )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_lowSrc )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lowSrc )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_useMap )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_useMap )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vrml )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vrml )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dynSrc )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dynSrc )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ htmlReadyState __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_complete )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_loop )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_loop )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ htmlControlAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ htmlControlAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onLoad )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onError )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onError )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onAbort )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onAbort )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IImgElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IImgElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IImgElementVtbl;

    interface IImgElement
    {
        CONST_VTBL struct IImgElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImgElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImgElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImgElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImgElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IImgElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IImgElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IImgElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IImgElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IImgElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IImgElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IImgElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IImgElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IImgElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IImgElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IImgElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IImgElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IImgElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IImgElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IImgElement_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IImgElement_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IImgElement_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IImgElement_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IImgElement_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IImgElement_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IImgElement_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IImgElement_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IImgElement_get_border(This,p)	\
    (This)->lpVtbl -> get_border(This,p)

#define IImgElement_put_vSpace(This,v)	\
    (This)->lpVtbl -> put_vSpace(This,v)

#define IImgElement_get_vSpace(This,p)	\
    (This)->lpVtbl -> get_vSpace(This,p)

#define IImgElement_put_hSpace(This,v)	\
    (This)->lpVtbl -> put_hSpace(This,v)

#define IImgElement_get_hSpace(This,p)	\
    (This)->lpVtbl -> get_hSpace(This,p)

#define IImgElement_put_alt(This,v)	\
    (This)->lpVtbl -> put_alt(This,v)

#define IImgElement_get_alt(This,p)	\
    (This)->lpVtbl -> get_alt(This,p)

#define IImgElement_put_isMap(This,v)	\
    (This)->lpVtbl -> put_isMap(This,v)

#define IImgElement_get_isMap(This,p)	\
    (This)->lpVtbl -> get_isMap(This,p)

#define IImgElement_put_src(This,v)	\
    (This)->lpVtbl -> put_src(This,v)

#define IImgElement_get_src(This,p)	\
    (This)->lpVtbl -> get_src(This,p)

#define IImgElement_put_lowSrc(This,v)	\
    (This)->lpVtbl -> put_lowSrc(This,v)

#define IImgElement_get_lowSrc(This,p)	\
    (This)->lpVtbl -> get_lowSrc(This,p)

#define IImgElement_put_useMap(This,v)	\
    (This)->lpVtbl -> put_useMap(This,v)

#define IImgElement_get_useMap(This,p)	\
    (This)->lpVtbl -> get_useMap(This,p)

#define IImgElement_put_vrml(This,v)	\
    (This)->lpVtbl -> put_vrml(This,v)

#define IImgElement_get_vrml(This,p)	\
    (This)->lpVtbl -> get_vrml(This,p)

#define IImgElement_put_dynSrc(This,v)	\
    (This)->lpVtbl -> put_dynSrc(This,v)

#define IImgElement_get_dynSrc(This,p)	\
    (This)->lpVtbl -> get_dynSrc(This,p)

#define IImgElement_get_readyState(This,p)	\
    (This)->lpVtbl -> get_readyState(This,p)

#define IImgElement_get_complete(This,p)	\
    (This)->lpVtbl -> get_complete(This,p)

#define IImgElement_put_loop(This,v)	\
    (This)->lpVtbl -> put_loop(This,v)

#define IImgElement_get_loop(This,p)	\
    (This)->lpVtbl -> get_loop(This,p)

#define IImgElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IImgElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IImgElement_get_onLoad(This,p)	\
    (This)->lpVtbl -> get_onLoad(This,p)

#define IImgElement_put_onError(This,v)	\
    (This)->lpVtbl -> put_onError(This,v)

#define IImgElement_get_onError(This,p)	\
    (This)->lpVtbl -> get_onError(This,p)

#define IImgElement_put_onAbort(This,v)	\
    (This)->lpVtbl -> put_onAbort(This,v)

#define IImgElement_get_onAbort(This,p)	\
    (This)->lpVtbl -> get_onAbort(This,p)

#define IImgElement_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define IImgElement_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define IImgElement_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IImgElement_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_border_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IImgElement_get_border_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_vSpace_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IImgElement_put_vSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_vSpace_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IImgElement_get_vSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_hSpace_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IImgElement_put_hSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_hSpace_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IImgElement_get_hSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_alt_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_alt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_alt_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_alt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_isMap_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IImgElement_put_isMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_isMap_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IImgElement_get_isMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_src_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_src_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_src_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_src_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_lowSrc_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_lowSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_lowSrc_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_lowSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_useMap_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_useMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_useMap_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_useMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_vrml_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_vrml_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_vrml_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_vrml_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_dynSrc_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_dynSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_dynSrc_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_dynSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_readyState_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ htmlReadyState __RPC_FAR *p);


void __RPC_STUB IImgElement_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_complete_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IImgElement_get_complete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_loop_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IImgElement_put_loop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_loop_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *p);


void __RPC_STUB IImgElement_get_loop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_align_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ htmlControlAlign v);


void __RPC_STUB IImgElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_align_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ htmlControlAlign __RPC_FAR *p);


void __RPC_STUB IImgElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_onLoad_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_onLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_onError_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_onError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_onError_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_onError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_onAbort_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_onAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_onAbort_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_onAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_language_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_language_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IImgElement_put_name_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IImgElement_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IImgElement_get_name_Proxy( 
    IImgElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IImgElement_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImgElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Img;

class Img;
#endif

#ifndef __IBodyElement_INTERFACE_DEFINED__
#define __IBodyElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBodyElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IBodyElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IBodyElement : public ITxtEdit
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_background( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_background( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_bgProperties( 
            /* [in] */ htmlBGProperties v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_bgProperties( 
            /* [out][retval] */ htmlBGProperties __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_dir( 
            /* [in] */ htmlDir v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_dir( 
            /* [out][retval] */ htmlDir __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_leftMargin( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_topMargin( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_rightMargin( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_bottomMargin( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_noWrap( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_noWrap( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_bgColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_bgColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_link( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_link( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_vLink( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_vLink( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_aLink( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_aLink( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onLoad( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onLoad( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onUnload( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onUnload( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onFocus( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onFocus( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onBlur( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onBlur( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_language( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBodyElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBodyElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBodyElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBodyElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IBodyElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IBodyElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IBodyElement __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createTextRange )( 
            IBodyElement __RPC_FAR * This,
            /* [in][defaultvalue] */ long begin,
            /* [in][defaultvalue] */ long end,
            /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *range);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createControlRange )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *range);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_background )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_background )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bgProperties )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ htmlBGProperties v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bgProperties )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ htmlBGProperties __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dir )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ htmlDir v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dir )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ htmlDir __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_leftMargin )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_topMargin )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rightMargin )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bottomMargin )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_noWrap )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_noWrap )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bgColor )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bgColor )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_link )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_link )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vLink )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vLink )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_aLink )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_aLink )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onLoad )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onLoad )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onUnload )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onUnload )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onFocus )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onFocus )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onBlur )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onBlur )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            IBodyElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            IBodyElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IBodyElementVtbl;

    interface IBodyElement
    {
        CONST_VTBL struct IBodyElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBodyElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBodyElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBodyElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBodyElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBodyElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBodyElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBodyElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBodyElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IBodyElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IBodyElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IBodyElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IBodyElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IBodyElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IBodyElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IBodyElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IBodyElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IBodyElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IBodyElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IBodyElement_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IBodyElement_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IBodyElement_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IBodyElement_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IBodyElement_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IBodyElement_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IBodyElement_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IBodyElement_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IBodyElement_createTextRange(This,begin,end,range)	\
    (This)->lpVtbl -> createTextRange(This,begin,end,range)

#define IBodyElement_createControlRange(This,range)	\
    (This)->lpVtbl -> createControlRange(This,range)


#define IBodyElement_put_background(This,v)	\
    (This)->lpVtbl -> put_background(This,v)

#define IBodyElement_get_background(This,p)	\
    (This)->lpVtbl -> get_background(This,p)

#define IBodyElement_put_bgProperties(This,v)	\
    (This)->lpVtbl -> put_bgProperties(This,v)

#define IBodyElement_get_bgProperties(This,p)	\
    (This)->lpVtbl -> get_bgProperties(This,p)

#define IBodyElement_put_dir(This,v)	\
    (This)->lpVtbl -> put_dir(This,v)

#define IBodyElement_get_dir(This,p)	\
    (This)->lpVtbl -> get_dir(This,p)

#define IBodyElement_get_leftMargin(This,p)	\
    (This)->lpVtbl -> get_leftMargin(This,p)

#define IBodyElement_get_topMargin(This,p)	\
    (This)->lpVtbl -> get_topMargin(This,p)

#define IBodyElement_get_rightMargin(This,p)	\
    (This)->lpVtbl -> get_rightMargin(This,p)

#define IBodyElement_get_bottomMargin(This,p)	\
    (This)->lpVtbl -> get_bottomMargin(This,p)

#define IBodyElement_put_noWrap(This,v)	\
    (This)->lpVtbl -> put_noWrap(This,v)

#define IBodyElement_get_noWrap(This,p)	\
    (This)->lpVtbl -> get_noWrap(This,p)

#define IBodyElement_put_bgColor(This,v)	\
    (This)->lpVtbl -> put_bgColor(This,v)

#define IBodyElement_get_bgColor(This,p)	\
    (This)->lpVtbl -> get_bgColor(This,p)

#define IBodyElement_put_text(This,v)	\
    (This)->lpVtbl -> put_text(This,v)

#define IBodyElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IBodyElement_put_link(This,v)	\
    (This)->lpVtbl -> put_link(This,v)

#define IBodyElement_get_link(This,p)	\
    (This)->lpVtbl -> get_link(This,p)

#define IBodyElement_put_vLink(This,v)	\
    (This)->lpVtbl -> put_vLink(This,v)

#define IBodyElement_get_vLink(This,p)	\
    (This)->lpVtbl -> get_vLink(This,p)

#define IBodyElement_put_aLink(This,v)	\
    (This)->lpVtbl -> put_aLink(This,v)

#define IBodyElement_get_aLink(This,p)	\
    (This)->lpVtbl -> get_aLink(This,p)

#define IBodyElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IBodyElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IBodyElement_put_onLoad(This,v)	\
    (This)->lpVtbl -> put_onLoad(This,v)

#define IBodyElement_get_onLoad(This,p)	\
    (This)->lpVtbl -> get_onLoad(This,p)

#define IBodyElement_put_onUnload(This,v)	\
    (This)->lpVtbl -> put_onUnload(This,v)

#define IBodyElement_get_onUnload(This,p)	\
    (This)->lpVtbl -> get_onUnload(This,p)

#define IBodyElement_put_onFocus(This,v)	\
    (This)->lpVtbl -> put_onFocus(This,v)

#define IBodyElement_get_onFocus(This,p)	\
    (This)->lpVtbl -> get_onFocus(This,p)

#define IBodyElement_put_onBlur(This,v)	\
    (This)->lpVtbl -> put_onBlur(This,v)

#define IBodyElement_get_onBlur(This,p)	\
    (This)->lpVtbl -> get_onBlur(This,p)

#define IBodyElement_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define IBodyElement_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_background_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_background_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_background_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_background_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_bgProperties_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ htmlBGProperties v);


void __RPC_STUB IBodyElement_put_bgProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_bgProperties_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ htmlBGProperties __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_bgProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_dir_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ htmlDir v);


void __RPC_STUB IBodyElement_put_dir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_dir_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ htmlDir __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_dir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_leftMargin_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IBodyElement_get_leftMargin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_topMargin_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IBodyElement_get_topMargin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_rightMargin_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IBodyElement_get_rightMargin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_bottomMargin_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IBodyElement_get_bottomMargin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_noWrap_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IBodyElement_put_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_noWrap_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_bgColor_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_bgColor_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_text_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_text_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_link_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_link_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_link_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_link_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_vLink_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_vLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_vLink_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_vLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_aLink_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_aLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_aLink_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_aLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_align_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IBodyElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_align_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_onLoad_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_onLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_onLoad_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_onLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_onUnload_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_onUnload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_onUnload_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_onUnload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_onFocus_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_onFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_onFocus_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_onFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_onBlur_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_onBlur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_onBlur_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_onBlur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBodyElement_put_language_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBodyElement_put_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBodyElement_get_language_Proxy( 
    IBodyElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBodyElement_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBodyElement_INTERFACE_DEFINED__ */


#ifndef __IBodyElementEvents_DISPINTERFACE_DEFINED__
#define __IBodyElementEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IBodyElementEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_IBodyElementEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IBodyElementEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IBodyElementEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBodyElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBodyElementEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBodyElementEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBodyElementEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBodyElementEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBodyElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBodyElementEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IBodyElementEventsVtbl;

    interface IBodyElementEvents
    {
        CONST_VTBL struct IBodyElementEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBodyElementEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBodyElementEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBodyElementEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBodyElementEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBodyElementEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBodyElementEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBodyElementEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IBodyElementEvents_DISPINTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Body;

class Body;
#endif

#ifndef __IFontElement_INTERFACE_DEFINED__
#define __IFontElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IFontElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IFontElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IFontElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_color( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_color( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_face( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_face( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_size( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_size( 
            /* [out][retval] */ VARIANT __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFontElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFontElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFontElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFontElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IFontElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_color )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_color )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_face )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_face )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_size )( 
            IFontElement __RPC_FAR * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_size )( 
            IFontElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        END_INTERFACE
    } IFontElementVtbl;

    interface IFontElement
    {
        CONST_VTBL struct IFontElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFontElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFontElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFontElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFontElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFontElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFontElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFontElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFontElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IFontElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IFontElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IFontElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IFontElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IFontElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IFontElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IFontElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IFontElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IFontElement_put_color(This,v)	\
    (This)->lpVtbl -> put_color(This,v)

#define IFontElement_get_color(This,p)	\
    (This)->lpVtbl -> get_color(This,p)

#define IFontElement_put_face(This,v)	\
    (This)->lpVtbl -> put_face(This,v)

#define IFontElement_get_face(This,p)	\
    (This)->lpVtbl -> get_face(This,p)

#define IFontElement_put_size(This,v)	\
    (This)->lpVtbl -> put_size(This,v)

#define IFontElement_get_size(This,p)	\
    (This)->lpVtbl -> get_size(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFontElement_put_color_Proxy( 
    IFontElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IFontElement_put_color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFontElement_get_color_Proxy( 
    IFontElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IFontElement_get_color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFontElement_put_face_Proxy( 
    IFontElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IFontElement_put_face_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFontElement_get_face_Proxy( 
    IFontElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IFontElement_get_face_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFontElement_put_size_Proxy( 
    IFontElement __RPC_FAR * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IFontElement_put_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFontElement_get_size_Proxy( 
    IFontElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *p);


void __RPC_STUB IFontElement_get_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFontElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_FontElement;

class FontElement;
#endif

#ifndef __AnchorEvents_DISPINTERFACE_DEFINED__
#define __AnchorEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: AnchorEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_AnchorEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface AnchorEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct AnchorEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            AnchorEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            AnchorEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            AnchorEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            AnchorEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            AnchorEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            AnchorEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            AnchorEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } AnchorEventsVtbl;

    interface AnchorEvents
    {
        CONST_VTBL struct AnchorEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AnchorEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AnchorEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AnchorEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AnchorEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define AnchorEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define AnchorEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define AnchorEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __AnchorEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IAnchorElement_INTERFACE_DEFINED__
#define __IAnchorElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAnchorElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IAnchorElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAnchorElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_href( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_href( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_target( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_target( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_title( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_rel( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_rel( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_rev( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_rev( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_urn( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_urn( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_Methods( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_Methods( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onClick( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onClick( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onMouseOut( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onMouseOut( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onMouseOver( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onMouseOver( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_language( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnchorElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAnchorElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAnchorElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAnchorElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IAnchorElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_href )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_href )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_target )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_target )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_rel )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rel )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_rev )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rev )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_urn )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_urn )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Methods )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Methods )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onClick )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onClick )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onMouseOut )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onMouseOut )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onMouseOver )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onMouseOver )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IAnchorElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IAnchorElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IAnchorElementVtbl;

    interface IAnchorElement
    {
        CONST_VTBL struct IAnchorElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnchorElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnchorElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnchorElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnchorElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAnchorElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAnchorElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAnchorElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAnchorElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IAnchorElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IAnchorElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IAnchorElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IAnchorElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IAnchorElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IAnchorElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IAnchorElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IAnchorElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IAnchorElement_put_href(This,v)	\
    (This)->lpVtbl -> put_href(This,v)

#define IAnchorElement_get_href(This,p)	\
    (This)->lpVtbl -> get_href(This,p)

#define IAnchorElement_put_target(This,v)	\
    (This)->lpVtbl -> put_target(This,v)

#define IAnchorElement_get_target(This,p)	\
    (This)->lpVtbl -> get_target(This,p)

#define IAnchorElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IAnchorElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IAnchorElement_put_rel(This,v)	\
    (This)->lpVtbl -> put_rel(This,v)

#define IAnchorElement_get_rel(This,p)	\
    (This)->lpVtbl -> get_rel(This,p)

#define IAnchorElement_put_rev(This,v)	\
    (This)->lpVtbl -> put_rev(This,v)

#define IAnchorElement_get_rev(This,p)	\
    (This)->lpVtbl -> get_rev(This,p)

#define IAnchorElement_put_urn(This,v)	\
    (This)->lpVtbl -> put_urn(This,v)

#define IAnchorElement_get_urn(This,p)	\
    (This)->lpVtbl -> get_urn(This,p)

#define IAnchorElement_put_Methods(This,v)	\
    (This)->lpVtbl -> put_Methods(This,v)

#define IAnchorElement_get_Methods(This,p)	\
    (This)->lpVtbl -> get_Methods(This,p)

#define IAnchorElement_put_onClick(This,v)	\
    (This)->lpVtbl -> put_onClick(This,v)

#define IAnchorElement_get_onClick(This,p)	\
    (This)->lpVtbl -> get_onClick(This,p)

#define IAnchorElement_put_onMouseOut(This,v)	\
    (This)->lpVtbl -> put_onMouseOut(This,v)

#define IAnchorElement_get_onMouseOut(This,p)	\
    (This)->lpVtbl -> get_onMouseOut(This,p)

#define IAnchorElement_put_onMouseOver(This,v)	\
    (This)->lpVtbl -> put_onMouseOver(This,v)

#define IAnchorElement_get_onMouseOver(This,p)	\
    (This)->lpVtbl -> get_onMouseOver(This,p)

#define IAnchorElement_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define IAnchorElement_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define IAnchorElement_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IAnchorElement_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_href_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_href_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_href_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_href_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_target_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_target_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_title_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_title_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_rel_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_rel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_rel_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_rel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_rev_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_rev_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_rev_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_rev_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_urn_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_urn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_urn_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_urn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_Methods_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_Methods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_Methods_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_Methods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_onClick_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_onClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_onClick_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_onClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_onMouseOut_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_onMouseOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_onMouseOut_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_onMouseOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_onMouseOver_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_onMouseOver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_onMouseOver_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_onMouseOver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_language_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_language_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IAnchorElement_put_name_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IAnchorElement_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IAnchorElement_get_name_Proxy( 
    IAnchorElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IAnchorElement_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnchorElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_AnchorElement;

class AnchorElement;
#endif

#ifndef __LabelEvents_DISPINTERFACE_DEFINED__
#define __LabelEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: LabelEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_LabelEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface LabelEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct LabelEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            LabelEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            LabelEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            LabelEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            LabelEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            LabelEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            LabelEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            LabelEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } LabelEventsVtbl;

    interface LabelEvents
    {
        CONST_VTBL struct LabelEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define LabelEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define LabelEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define LabelEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define LabelEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define LabelEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define LabelEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define LabelEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __LabelEvents_DISPINTERFACE_DEFINED__ */


#ifndef __ILabelElement_INTERFACE_DEFINED__
#define __ILabelElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILabelElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ILabelElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ILabelElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_language( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_for( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_for( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_accessKey( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_accessKey( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE click( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILabelElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILabelElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILabelElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ILabelElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ILabelElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_for )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_for )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_accessKey )( 
            ILabelElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accessKey )( 
            ILabelElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *click )( 
            ILabelElement __RPC_FAR * This);
        
        END_INTERFACE
    } ILabelElementVtbl;

    interface ILabelElement
    {
        CONST_VTBL struct ILabelElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILabelElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILabelElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILabelElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILabelElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILabelElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILabelElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILabelElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILabelElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ILabelElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ILabelElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ILabelElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ILabelElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ILabelElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ILabelElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ILabelElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ILabelElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ILabelElement_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define ILabelElement_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#define ILabelElement_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define ILabelElement_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define ILabelElement_put_for(This,v)	\
    (This)->lpVtbl -> put_for(This,v)

#define ILabelElement_get_for(This,p)	\
    (This)->lpVtbl -> get_for(This,p)

#define ILabelElement_put_accessKey(This,v)	\
    (This)->lpVtbl -> put_accessKey(This,v)

#define ILabelElement_get_accessKey(This,p)	\
    (This)->lpVtbl -> get_accessKey(This,p)

#define ILabelElement_click(This)	\
    (This)->lpVtbl -> click(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILabelElement_put_name_Proxy( 
    ILabelElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILabelElement_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILabelElement_get_name_Proxy( 
    ILabelElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILabelElement_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILabelElement_put_language_Proxy( 
    ILabelElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILabelElement_put_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILabelElement_get_language_Proxy( 
    ILabelElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILabelElement_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILabelElement_put_for_Proxy( 
    ILabelElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILabelElement_put_for_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILabelElement_get_for_Proxy( 
    ILabelElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILabelElement_get_for_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILabelElement_put_accessKey_Proxy( 
    ILabelElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILabelElement_put_accessKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILabelElement_get_accessKey_Proxy( 
    ILabelElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILabelElement_get_accessKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ILabelElement_click_Proxy( 
    ILabelElement __RPC_FAR * This);


void __RPC_STUB ILabelElement_click_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILabelElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_LabelElement;

class LabelElement;
#endif

#ifndef __IListElement_INTERFACE_DEFINED__
#define __IListElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IListElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IListElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IListElement : public IElement
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IListElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IListElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IListElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IListElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IListElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IListElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IListElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IListElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IListElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IListElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IListElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IListElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IListElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IListElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        END_INTERFACE
    } IListElementVtbl;

    interface IListElement
    {
        CONST_VTBL struct IListElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IListElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IListElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IListElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IListElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IListElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IListElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IListElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IListElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IListElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IListElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IListElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IListElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IListElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IListElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IListElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IListElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IListElement_INTERFACE_DEFINED__ */


#ifndef __IUListElement_INTERFACE_DEFINED__
#define __IUListElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IUListElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IUListElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IUListElement : public IListElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_compact( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_compact( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_type( 
            /* [in] */ htmlListType v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ htmlListType __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUListElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUListElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUListElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IUListElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IUListElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_compact )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_compact )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_type )( 
            IUListElement __RPC_FAR * This,
            /* [in] */ htmlListType v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IUListElement __RPC_FAR * This,
            /* [out][retval] */ htmlListType __RPC_FAR *p);
        
        END_INTERFACE
    } IUListElementVtbl;

    interface IUListElement
    {
        CONST_VTBL struct IUListElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUListElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUListElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUListElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUListElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IUListElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IUListElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IUListElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IUListElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IUListElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IUListElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IUListElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IUListElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IUListElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IUListElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IUListElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IUListElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)



#define IUListElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IUListElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IUListElement_put_compact(This,v)	\
    (This)->lpVtbl -> put_compact(This,v)

#define IUListElement_get_compact(This,p)	\
    (This)->lpVtbl -> get_compact(This,p)

#define IUListElement_put_type(This,v)	\
    (This)->lpVtbl -> put_type(This,v)

#define IUListElement_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IUListElement_put_align_Proxy( 
    IUListElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IUListElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IUListElement_get_align_Proxy( 
    IUListElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IUListElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IUListElement_put_compact_Proxy( 
    IUListElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IUListElement_put_compact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IUListElement_get_compact_Proxy( 
    IUListElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IUListElement_get_compact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IUListElement_put_type_Proxy( 
    IUListElement __RPC_FAR * This,
    /* [in] */ htmlListType v);


void __RPC_STUB IUListElement_put_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IUListElement_get_type_Proxy( 
    IUListElement __RPC_FAR * This,
    /* [out][retval] */ htmlListType __RPC_FAR *p);


void __RPC_STUB IUListElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUListElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_UListElement;

class UListElement;
#endif

#ifndef __IOListElement_INTERFACE_DEFINED__
#define __IOListElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOListElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IOListElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOListElement : public IListElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_compact( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_compact( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_start( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_start( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_type( 
            /* [in] */ htmlListType v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ htmlListType __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOListElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOListElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOListElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IOListElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IOListElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_compact )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_compact )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_start )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_start )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_type )( 
            IOListElement __RPC_FAR * This,
            /* [in] */ htmlListType v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IOListElement __RPC_FAR * This,
            /* [out][retval] */ htmlListType __RPC_FAR *p);
        
        END_INTERFACE
    } IOListElementVtbl;

    interface IOListElement
    {
        CONST_VTBL struct IOListElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOListElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOListElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOListElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOListElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IOListElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IOListElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IOListElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IOListElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IOListElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IOListElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IOListElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IOListElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IOListElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IOListElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IOListElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IOListElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)



#define IOListElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IOListElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IOListElement_put_compact(This,v)	\
    (This)->lpVtbl -> put_compact(This,v)

#define IOListElement_get_compact(This,p)	\
    (This)->lpVtbl -> get_compact(This,p)

#define IOListElement_put_start(This,v)	\
    (This)->lpVtbl -> put_start(This,v)

#define IOListElement_get_start(This,p)	\
    (This)->lpVtbl -> get_start(This,p)

#define IOListElement_put_type(This,v)	\
    (This)->lpVtbl -> put_type(This,v)

#define IOListElement_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IOListElement_put_align_Proxy( 
    IOListElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IOListElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IOListElement_get_align_Proxy( 
    IOListElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IOListElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IOListElement_put_compact_Proxy( 
    IOListElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IOListElement_put_compact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IOListElement_get_compact_Proxy( 
    IOListElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IOListElement_get_compact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IOListElement_put_start_Proxy( 
    IOListElement __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IOListElement_put_start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IOListElement_get_start_Proxy( 
    IOListElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IOListElement_get_start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IOListElement_put_type_Proxy( 
    IOListElement __RPC_FAR * This,
    /* [in] */ htmlListType v);


void __RPC_STUB IOListElement_put_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IOListElement_get_type_Proxy( 
    IOListElement __RPC_FAR * This,
    /* [out][retval] */ htmlListType __RPC_FAR *p);


void __RPC_STUB IOListElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOListElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_OListElement;

class OListElement;
#endif

#ifndef __ILIElement_INTERFACE_DEFINED__
#define __ILIElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILIElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ILIElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ILIElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_type( 
            /* [in] */ htmlListType v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ htmlListType __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILIElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILIElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILIElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ILIElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ILIElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_type )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ htmlListType v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ htmlListType __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            ILIElement __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            ILIElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        END_INTERFACE
    } ILIElementVtbl;

    interface ILIElement
    {
        CONST_VTBL struct ILIElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILIElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILIElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILIElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILIElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILIElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILIElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILIElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILIElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ILIElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ILIElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ILIElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ILIElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ILIElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ILIElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ILIElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ILIElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ILIElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define ILIElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define ILIElement_put_type(This,v)	\
    (This)->lpVtbl -> put_type(This,v)

#define ILIElement_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define ILIElement_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define ILIElement_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILIElement_put_align_Proxy( 
    ILIElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB ILIElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILIElement_get_align_Proxy( 
    ILIElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB ILIElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILIElement_put_type_Proxy( 
    ILIElement __RPC_FAR * This,
    /* [in] */ htmlListType v);


void __RPC_STUB ILIElement_put_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILIElement_get_type_Proxy( 
    ILIElement __RPC_FAR * This,
    /* [out][retval] */ htmlListType __RPC_FAR *p);


void __RPC_STUB ILIElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILIElement_put_value_Proxy( 
    ILIElement __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ILIElement_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILIElement_get_value_Proxy( 
    ILIElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ILIElement_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILIElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_LIElement;

class LIElement;
#endif

#ifndef __IDivElement_INTERFACE_DEFINED__
#define __IDivElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDivElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IDivElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDivElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_script( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_script( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_scriptEngine( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_scriptEngine( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_noWrap( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_noWrap( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDivElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDivElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDivElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDivElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IDivElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_script )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_script )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_scriptEngine )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_scriptEngine )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_noWrap )( 
            IDivElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_noWrap )( 
            IDivElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        END_INTERFACE
    } IDivElementVtbl;

    interface IDivElement
    {
        CONST_VTBL struct IDivElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDivElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDivElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDivElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDivElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDivElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDivElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDivElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDivElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IDivElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IDivElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IDivElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IDivElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IDivElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IDivElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IDivElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IDivElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IDivElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IDivElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IDivElement_put_script(This,v)	\
    (This)->lpVtbl -> put_script(This,v)

#define IDivElement_get_script(This,p)	\
    (This)->lpVtbl -> get_script(This,p)

#define IDivElement_put_scriptEngine(This,v)	\
    (This)->lpVtbl -> put_scriptEngine(This,v)

#define IDivElement_get_scriptEngine(This,p)	\
    (This)->lpVtbl -> get_scriptEngine(This,p)

#define IDivElement_put_noWrap(This,v)	\
    (This)->lpVtbl -> put_noWrap(This,v)

#define IDivElement_get_noWrap(This,p)	\
    (This)->lpVtbl -> get_noWrap(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDivElement_put_align_Proxy( 
    IDivElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IDivElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDivElement_get_align_Proxy( 
    IDivElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IDivElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDivElement_put_script_Proxy( 
    IDivElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IDivElement_put_script_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDivElement_get_script_Proxy( 
    IDivElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IDivElement_get_script_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDivElement_put_scriptEngine_Proxy( 
    IDivElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IDivElement_put_scriptEngine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDivElement_get_scriptEngine_Proxy( 
    IDivElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IDivElement_get_scriptEngine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDivElement_put_noWrap_Proxy( 
    IDivElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IDivElement_put_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDivElement_get_noWrap_Proxy( 
    IDivElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IDivElement_get_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDivElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DivElement;

class DivElement;
#endif

#ifndef __IDDElement_INTERFACE_DEFINED__
#define __IDDElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDDElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IDDElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDDElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_noWrap( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_noWrap( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDDElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDDElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDDElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDDElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDDElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDDElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDDElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDDElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IDDElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IDDElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDDElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDDElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IDDElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IDDElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IDDElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IDDElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IDDElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_noWrap )( 
            IDDElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_noWrap )( 
            IDDElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IDDElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IDDElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        END_INTERFACE
    } IDDElementVtbl;

    interface IDDElement
    {
        CONST_VTBL struct IDDElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDDElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDDElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDDElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDDElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDDElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDDElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDDElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDDElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IDDElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IDDElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IDDElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IDDElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IDDElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IDDElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IDDElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IDDElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IDDElement_put_noWrap(This,v)	\
    (This)->lpVtbl -> put_noWrap(This,v)

#define IDDElement_get_noWrap(This,p)	\
    (This)->lpVtbl -> get_noWrap(This,p)

#define IDDElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IDDElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDDElement_put_noWrap_Proxy( 
    IDDElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IDDElement_put_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDDElement_get_noWrap_Proxy( 
    IDDElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IDDElement_get_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDDElement_put_align_Proxy( 
    IDDElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IDDElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDDElement_get_align_Proxy( 
    IDDElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IDDElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDDElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DDElement;

class DDElement;
#endif

#ifndef __IDTElement_INTERFACE_DEFINED__
#define __IDTElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDTElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IDTElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDTElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_noWrap( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_noWrap( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDTElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDTElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDTElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDTElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDTElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDTElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDTElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDTElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IDTElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IDTElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDTElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDTElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IDTElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IDTElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IDTElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IDTElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IDTElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IDTElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IDTElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_noWrap )( 
            IDTElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_noWrap )( 
            IDTElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        END_INTERFACE
    } IDTElementVtbl;

    interface IDTElement
    {
        CONST_VTBL struct IDTElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDTElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDTElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDTElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDTElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDTElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDTElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDTElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDTElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IDTElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IDTElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IDTElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IDTElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IDTElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IDTElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IDTElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IDTElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IDTElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IDTElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IDTElement_put_noWrap(This,v)	\
    (This)->lpVtbl -> put_noWrap(This,v)

#define IDTElement_get_noWrap(This,p)	\
    (This)->lpVtbl -> get_noWrap(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDTElement_put_align_Proxy( 
    IDTElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IDTElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDTElement_get_align_Proxy( 
    IDTElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IDTElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDTElement_put_noWrap_Proxy( 
    IDTElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IDTElement_put_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDTElement_get_noWrap_Proxy( 
    IDTElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IDTElement_get_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDTElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DTElement;

class DTElement;
#endif

#ifndef __IBRElement_INTERFACE_DEFINED__
#define __IBRElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBRElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IBRElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IBRElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_clear( 
            /* [in] */ htmlClear v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_clear( 
            /* [out][retval] */ htmlClear __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBRElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBRElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBRElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBRElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBRElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBRElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBRElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBRElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IBRElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IBRElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IBRElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IBRElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IBRElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IBRElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IBRElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IBRElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IBRElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_clear )( 
            IBRElement __RPC_FAR * This,
            /* [in] */ htmlClear v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_clear )( 
            IBRElement __RPC_FAR * This,
            /* [out][retval] */ htmlClear __RPC_FAR *p);
        
        END_INTERFACE
    } IBRElementVtbl;

    interface IBRElement
    {
        CONST_VTBL struct IBRElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBRElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBRElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBRElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBRElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBRElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBRElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBRElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBRElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IBRElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IBRElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IBRElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IBRElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IBRElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IBRElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IBRElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IBRElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IBRElement_put_clear(This,v)	\
    (This)->lpVtbl -> put_clear(This,v)

#define IBRElement_get_clear(This,p)	\
    (This)->lpVtbl -> get_clear(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBRElement_put_clear_Proxy( 
    IBRElement __RPC_FAR * This,
    /* [in] */ htmlClear v);


void __RPC_STUB IBRElement_put_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBRElement_get_clear_Proxy( 
    IBRElement __RPC_FAR * This,
    /* [out][retval] */ htmlClear __RPC_FAR *p);


void __RPC_STUB IBRElement_get_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBRElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_BRElement;

class BRElement;
#endif

#ifndef __IDListElement_INTERFACE_DEFINED__
#define __IDListElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDListElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IDListElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDListElement : public IListElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_compact( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_compact( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDListElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDListElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDListElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDListElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDListElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDListElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDListElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDListElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IDListElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IDListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDListElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IDListElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IDListElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IDListElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IDListElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IDListElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IDListElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IDListElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_compact )( 
            IDListElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_compact )( 
            IDListElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        END_INTERFACE
    } IDListElementVtbl;

    interface IDListElement
    {
        CONST_VTBL struct IDListElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDListElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDListElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDListElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDListElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDListElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDListElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDListElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDListElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IDListElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IDListElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IDListElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IDListElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IDListElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IDListElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IDListElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IDListElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)



#define IDListElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IDListElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IDListElement_put_compact(This,v)	\
    (This)->lpVtbl -> put_compact(This,v)

#define IDListElement_get_compact(This,p)	\
    (This)->lpVtbl -> get_compact(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDListElement_put_align_Proxy( 
    IDListElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IDListElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDListElement_get_align_Proxy( 
    IDListElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IDListElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDListElement_put_compact_Proxy( 
    IDListElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IDListElement_put_compact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDListElement_get_compact_Proxy( 
    IDListElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IDListElement_get_compact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDListElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DListElement;

class DListElement;
#endif

#ifndef __IHRElement_INTERFACE_DEFINED__
#define __IHRElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHRElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IHRElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IHRElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_color( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_color( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_noShade( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_noShade( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_width( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_size( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHRElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHRElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHRElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHRElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IHRElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_color )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_color )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_noShade )( 
            IHRElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_noShade )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_size )( 
            IHRElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        END_INTERFACE
    } IHRElementVtbl;

    interface IHRElement
    {
        CONST_VTBL struct IHRElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHRElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHRElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHRElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHRElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHRElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHRElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHRElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHRElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IHRElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IHRElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IHRElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IHRElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IHRElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IHRElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IHRElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IHRElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IHRElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IHRElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IHRElement_put_color(This,v)	\
    (This)->lpVtbl -> put_color(This,v)

#define IHRElement_get_color(This,p)	\
    (This)->lpVtbl -> get_color(This,p)

#define IHRElement_put_noShade(This,v)	\
    (This)->lpVtbl -> put_noShade(This,v)

#define IHRElement_get_noShade(This,p)	\
    (This)->lpVtbl -> get_noShade(This,p)

#define IHRElement_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)

#define IHRElement_get_size(This,p)	\
    (This)->lpVtbl -> get_size(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IHRElement_put_align_Proxy( 
    IHRElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IHRElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IHRElement_get_align_Proxy( 
    IHRElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IHRElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IHRElement_put_color_Proxy( 
    IHRElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHRElement_put_color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IHRElement_get_color_Proxy( 
    IHRElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHRElement_get_color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IHRElement_put_noShade_Proxy( 
    IHRElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IHRElement_put_noShade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IHRElement_get_noShade_Proxy( 
    IHRElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IHRElement_get_noShade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IHRElement_get_width_Proxy( 
    IHRElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IHRElement_get_width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IHRElement_get_size_Proxy( 
    IHRElement __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IHRElement_get_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHRElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_HRElement;

class HRElement;
#endif

#ifndef __IBlockElement_INTERFACE_DEFINED__
#define __IBlockElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBlockElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IBlockElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IBlockElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlBlockAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBlockElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBlockElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBlockElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBlockElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBlockElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBlockElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBlockElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBlockElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IBlockElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IBlockElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IBlockElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IBlockElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IBlockElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IBlockElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IBlockElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IBlockElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IBlockElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IBlockElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IBlockElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        END_INTERFACE
    } IBlockElementVtbl;

    interface IBlockElement
    {
        CONST_VTBL struct IBlockElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBlockElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBlockElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBlockElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBlockElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBlockElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBlockElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBlockElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBlockElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IBlockElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IBlockElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IBlockElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IBlockElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IBlockElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IBlockElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IBlockElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IBlockElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IBlockElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IBlockElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBlockElement_put_align_Proxy( 
    IBlockElement __RPC_FAR * This,
    /* [in] */ htmlBlockAlign v);


void __RPC_STUB IBlockElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBlockElement_get_align_Proxy( 
    IBlockElement __RPC_FAR * This,
    /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);


void __RPC_STUB IBlockElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBlockElement_INTERFACE_DEFINED__ */


#ifndef __IParaElement_INTERFACE_DEFINED__
#define __IParaElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IParaElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IParaElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IParaElement : public IBlockElement
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IParaElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IParaElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IParaElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IParaElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IParaElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IParaElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IParaElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IParaElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IParaElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IParaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IParaElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IParaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IParaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IParaElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IParaElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IParaElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IParaElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IParaElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IParaElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        END_INTERFACE
    } IParaElementVtbl;

    interface IParaElement
    {
        CONST_VTBL struct IParaElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParaElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IParaElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IParaElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IParaElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IParaElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IParaElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IParaElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IParaElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IParaElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IParaElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IParaElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IParaElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IParaElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IParaElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IParaElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IParaElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IParaElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IParaElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IParaElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ParaElement;

class ParaElement;
#endif

#ifndef __IElementCollection_INTERFACE_DEFINED__
#define __IElementCollection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IElementCollection
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IElementCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IElementCollection : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE add( 
            /* [in] */ IElement __RPC_FAR *element,
            /* [in][optional] */ VARIANT idref,
            /* [in][optional][defaultvalue] */ VARIANT before) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE remove( 
            /* [in][defaultvalue] */ long index) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][optional] */ VARIANT name,
            /* [in][optional] */ VARIANT index,
            /* [out][retval] */ VARIANT __RPC_FAR *pdisp) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE tags( 
            /* [in] */ VARIANT tagName,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *pdisp) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IElementCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IElementCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IElementCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IElementCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IElementCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IElementCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IElementCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *add )( 
            IElementCollection __RPC_FAR * This,
            /* [in] */ IElement __RPC_FAR *element,
            /* [in][optional] */ VARIANT idref,
            /* [in][optional][defaultvalue] */ VARIANT before);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *remove )( 
            IElementCollection __RPC_FAR * This,
            /* [in][defaultvalue] */ long index);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IElementCollection __RPC_FAR * This,
            /* [in][optional] */ VARIANT name,
            /* [in][optional] */ VARIANT index,
            /* [out][retval] */ VARIANT __RPC_FAR *pdisp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *tags )( 
            IElementCollection __RPC_FAR * This,
            /* [in] */ VARIANT tagName,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *pdisp);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IElementCollection __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IElementCollection __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__newEnum )( 
            IElementCollection __RPC_FAR * This,
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *p);
        
        END_INTERFACE
    } IElementCollectionVtbl;

    interface IElementCollection
    {
        CONST_VTBL struct IElementCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IElementCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IElementCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IElementCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IElementCollection_add(This,element,idref,before)	\
    (This)->lpVtbl -> add(This,element,idref,before)

#define IElementCollection_remove(This,index)	\
    (This)->lpVtbl -> remove(This,index)

#define IElementCollection_item(This,name,index,pdisp)	\
    (This)->lpVtbl -> item(This,name,index,pdisp)

#define IElementCollection_tags(This,tagName,pdisp)	\
    (This)->lpVtbl -> tags(This,tagName,pdisp)

#define IElementCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IElementCollection_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IElementCollection_get__newEnum(This,p)	\
    (This)->lpVtbl -> get__newEnum(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IElementCollection_add_Proxy( 
    IElementCollection __RPC_FAR * This,
    /* [in] */ IElement __RPC_FAR *element,
    /* [in][optional] */ VARIANT idref,
    /* [in][optional][defaultvalue] */ VARIANT before);


void __RPC_STUB IElementCollection_add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IElementCollection_remove_Proxy( 
    IElementCollection __RPC_FAR * This,
    /* [in][defaultvalue] */ long index);


void __RPC_STUB IElementCollection_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IElementCollection_item_Proxy( 
    IElementCollection __RPC_FAR * This,
    /* [in][optional] */ VARIANT name,
    /* [in][optional] */ VARIANT index,
    /* [out][retval] */ VARIANT __RPC_FAR *pdisp);


void __RPC_STUB IElementCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IElementCollection_tags_Proxy( 
    IElementCollection __RPC_FAR * This,
    /* [in] */ VARIANT tagName,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *pdisp);


void __RPC_STUB IElementCollection_tags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IElementCollection_get_length_Proxy( 
    IElementCollection __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IElementCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IElementCollection_get_count_Proxy( 
    IElementCollection __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IElementCollection_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IElementCollection_get__newEnum_Proxy( 
    IElementCollection __RPC_FAR * This,
    /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IElementCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementCollection_INTERFACE_DEFINED__ */


#ifndef __IOptionsCollection_INTERFACE_DEFINED__
#define __IOptionsCollection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOptionsCollection
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IOptionsCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOptionsCollection : public IElementCollection
    {
    public:
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOptionsCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOptionsCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOptionsCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOptionsCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IOptionsCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IOptionsCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IOptionsCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IOptionsCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *add )( 
            IOptionsCollection __RPC_FAR * This,
            /* [in] */ IElement __RPC_FAR *element,
            /* [in][optional] */ VARIANT idref,
            /* [in][optional][defaultvalue] */ VARIANT before);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *remove )( 
            IOptionsCollection __RPC_FAR * This,
            /* [in][defaultvalue] */ long index);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IOptionsCollection __RPC_FAR * This,
            /* [in][optional] */ VARIANT name,
            /* [in][optional] */ VARIANT index,
            /* [out][retval] */ VARIANT __RPC_FAR *pdisp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *tags )( 
            IOptionsCollection __RPC_FAR * This,
            /* [in] */ VARIANT tagName,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *pdisp);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IOptionsCollection __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IOptionsCollection __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__newEnum )( 
            IOptionsCollection __RPC_FAR * This,
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IOptionsCollection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IOptionsCollectionVtbl;

    interface IOptionsCollection
    {
        CONST_VTBL struct IOptionsCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOptionsCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOptionsCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOptionsCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOptionsCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IOptionsCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IOptionsCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IOptionsCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IOptionsCollection_add(This,element,idref,before)	\
    (This)->lpVtbl -> add(This,element,idref,before)

#define IOptionsCollection_remove(This,index)	\
    (This)->lpVtbl -> remove(This,index)

#define IOptionsCollection_item(This,name,index,pdisp)	\
    (This)->lpVtbl -> item(This,name,index,pdisp)

#define IOptionsCollection_tags(This,tagName,pdisp)	\
    (This)->lpVtbl -> tags(This,tagName,pdisp)

#define IOptionsCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IOptionsCollection_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IOptionsCollection_get__newEnum(This,p)	\
    (This)->lpVtbl -> get__newEnum(This,p)


#define IOptionsCollection_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IOptionsCollection_get_name_Proxy( 
    IOptionsCollection __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IOptionsCollection_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOptionsCollection_INTERFACE_DEFINED__ */


#ifndef __IHeaderElement_INTERFACE_DEFINED__
#define __IHeaderElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHeaderElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IHeaderElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IHeaderElement : public IBlockElement
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IHeaderElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeaderElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeaderElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeaderElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHeaderElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHeaderElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHeaderElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHeaderElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IHeaderElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IHeaderElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IHeaderElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IHeaderElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IHeaderElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IHeaderElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IHeaderElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IHeaderElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IHeaderElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IHeaderElement __RPC_FAR * This,
            /* [in] */ htmlBlockAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IHeaderElement __RPC_FAR * This,
            /* [out][retval] */ htmlBlockAlign __RPC_FAR *p);
        
        END_INTERFACE
    } IHeaderElementVtbl;

    interface IHeaderElement
    {
        CONST_VTBL struct IHeaderElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHeaderElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHeaderElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHeaderElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHeaderElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IHeaderElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IHeaderElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IHeaderElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IHeaderElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IHeaderElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IHeaderElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IHeaderElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IHeaderElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IHeaderElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IHeaderElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHeaderElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_HeaderElement;

class HeaderElement;
#endif

#ifndef __IFormElement_INTERFACE_DEFINED__
#define __IFormElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IFormElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IFormElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IFormElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_action( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_action( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_dir( 
            /* [in] */ htmlDir v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_dir( 
            /* [out][retval] */ htmlDir __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_encType( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_encType( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_method( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_method( 
            /* [out][retval] */ VARIANT __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_elements( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_target( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_target( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE submit( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFormElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFormElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFormElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFormElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IFormElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_action )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_action )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dir )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ htmlDir v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dir )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ htmlDir __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_encType )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_encType )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_method )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_method )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_elements )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_target )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_target )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IFormElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IFormElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *submit )( 
            IFormElement __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *reset )( 
            IFormElement __RPC_FAR * This);
        
        END_INTERFACE
    } IFormElementVtbl;

    interface IFormElement
    {
        CONST_VTBL struct IFormElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFormElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFormElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFormElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFormElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFormElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFormElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFormElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFormElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IFormElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IFormElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IFormElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IFormElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IFormElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IFormElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IFormElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IFormElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IFormElement_put_action(This,v)	\
    (This)->lpVtbl -> put_action(This,v)

#define IFormElement_get_action(This,p)	\
    (This)->lpVtbl -> get_action(This,p)

#define IFormElement_put_dir(This,v)	\
    (This)->lpVtbl -> put_dir(This,v)

#define IFormElement_get_dir(This,p)	\
    (This)->lpVtbl -> get_dir(This,p)

#define IFormElement_put_encType(This,v)	\
    (This)->lpVtbl -> put_encType(This,v)

#define IFormElement_get_encType(This,p)	\
    (This)->lpVtbl -> get_encType(This,p)

#define IFormElement_put_method(This,v)	\
    (This)->lpVtbl -> put_method(This,v)

#define IFormElement_get_method(This,p)	\
    (This)->lpVtbl -> get_method(This,p)

#define IFormElement_get_elements(This,p)	\
    (This)->lpVtbl -> get_elements(This,p)

#define IFormElement_put_target(This,v)	\
    (This)->lpVtbl -> put_target(This,v)

#define IFormElement_get_target(This,p)	\
    (This)->lpVtbl -> get_target(This,p)

#define IFormElement_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IFormElement_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#define IFormElement_submit(This)	\
    (This)->lpVtbl -> submit(This)

#define IFormElement_reset(This)	\
    (This)->lpVtbl -> reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFormElement_put_action_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IFormElement_put_action_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFormElement_get_action_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IFormElement_get_action_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFormElement_put_dir_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [in] */ htmlDir v);


void __RPC_STUB IFormElement_put_dir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFormElement_get_dir_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [out][retval] */ htmlDir __RPC_FAR *p);


void __RPC_STUB IFormElement_get_dir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFormElement_put_encType_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IFormElement_put_encType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFormElement_get_encType_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IFormElement_get_encType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFormElement_put_method_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IFormElement_put_method_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFormElement_get_method_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *p);


void __RPC_STUB IFormElement_get_method_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IFormElement_get_elements_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IFormElement_get_elements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFormElement_put_target_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IFormElement_put_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFormElement_get_target_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IFormElement_get_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IFormElement_put_name_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IFormElement_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IFormElement_get_name_Proxy( 
    IFormElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IFormElement_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IFormElement_submit_Proxy( 
    IFormElement __RPC_FAR * This);


void __RPC_STUB IFormElement_submit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IFormElement_reset_Proxy( 
    IFormElement __RPC_FAR * This);


void __RPC_STUB IFormElement_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFormElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_FormElement;

class FormElement;
#endif

#ifndef __SelectElementEvents_DISPINTERFACE_DEFINED__
#define __SelectElementEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: SelectElementEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_SelectElementEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface SelectElementEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct SelectElementEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            SelectElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            SelectElementEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            SelectElementEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            SelectElementEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            SelectElementEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            SelectElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            SelectElementEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } SelectElementEventsVtbl;

    interface SelectElementEvents
    {
        CONST_VTBL struct SelectElementEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SelectElementEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define SelectElementEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define SelectElementEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define SelectElementEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define SelectElementEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define SelectElementEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define SelectElementEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __SelectElementEvents_DISPINTERFACE_DEFINED__ */


#ifndef __ISelectElement_INTERFACE_DEFINED__
#define __ISelectElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISelectElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ISelectElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISelectElement : public IControlElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlControlAlign v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlControlAlign __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_size( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_size( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_multiple( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_multiple( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_options( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onBlur( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onBlur( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onChange( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onChange( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onClick( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onClick( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onFocus( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onFocus( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_selectedIndex( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_selectedIndex( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ htmlSelectType __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISelectElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISelectElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISelectElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ISelectElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            ISelectElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            ISelectElement __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ htmlControlAlign v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ htmlControlAlign __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_size )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_size )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_multiple )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_multiple )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_options )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onBlur )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onBlur )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onChange )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onChange )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onClick )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onClick )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onFocus )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onFocus )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_selectedIndex )( 
            ISelectElement __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_selectedIndex )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            ISelectElement __RPC_FAR * This,
            /* [out][retval] */ htmlSelectType __RPC_FAR *p);
        
        END_INTERFACE
    } ISelectElementVtbl;

    interface ISelectElement
    {
        CONST_VTBL struct ISelectElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISelectElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISelectElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISelectElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISelectElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISelectElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISelectElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISelectElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ISelectElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ISelectElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ISelectElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ISelectElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ISelectElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ISelectElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ISelectElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ISelectElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ISelectElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define ISelectElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define ISelectElement_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define ISelectElement_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define ISelectElement_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define ISelectElement_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define ISelectElement_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define ISelectElement_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define ISelectElement_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define ISelectElement_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define ISelectElement_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define ISelectElement_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define ISelectElement_put_size(This,v)	\
    (This)->lpVtbl -> put_size(This,v)

#define ISelectElement_get_size(This,p)	\
    (This)->lpVtbl -> get_size(This,p)

#define ISelectElement_put_multiple(This,v)	\
    (This)->lpVtbl -> put_multiple(This,v)

#define ISelectElement_get_multiple(This,p)	\
    (This)->lpVtbl -> get_multiple(This,p)

#define ISelectElement_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define ISelectElement_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#define ISelectElement_get_options(This,p)	\
    (This)->lpVtbl -> get_options(This,p)

#define ISelectElement_put_onBlur(This,v)	\
    (This)->lpVtbl -> put_onBlur(This,v)

#define ISelectElement_get_onBlur(This,p)	\
    (This)->lpVtbl -> get_onBlur(This,p)

#define ISelectElement_put_onChange(This,v)	\
    (This)->lpVtbl -> put_onChange(This,v)

#define ISelectElement_get_onChange(This,p)	\
    (This)->lpVtbl -> get_onChange(This,p)

#define ISelectElement_put_onClick(This,v)	\
    (This)->lpVtbl -> put_onClick(This,v)

#define ISelectElement_get_onClick(This,p)	\
    (This)->lpVtbl -> get_onClick(This,p)

#define ISelectElement_put_onFocus(This,v)	\
    (This)->lpVtbl -> put_onFocus(This,v)

#define ISelectElement_get_onFocus(This,p)	\
    (This)->lpVtbl -> get_onFocus(This,p)

#define ISelectElement_put_selectedIndex(This,v)	\
    (This)->lpVtbl -> put_selectedIndex(This,v)

#define ISelectElement_get_selectedIndex(This,p)	\
    (This)->lpVtbl -> get_selectedIndex(This,p)

#define ISelectElement_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define ISelectElement_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_align_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ htmlControlAlign v);


void __RPC_STUB ISelectElement_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_align_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ htmlControlAlign __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_size_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ISelectElement_put_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_size_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_multiple_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ISelectElement_put_multiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_multiple_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_multiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_name_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ISelectElement_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_name_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_options_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB ISelectElement_get_options_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_onBlur_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ISelectElement_put_onBlur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_onBlur_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_onBlur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_onChange_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ISelectElement_put_onChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_onChange_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_onChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_onClick_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ISelectElement_put_onClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_onClick_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_onClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_onFocus_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ISelectElement_put_onFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_onFocus_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_onFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ISelectElement_put_selectedIndex_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ISelectElement_put_selectedIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_selectedIndex_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_selectedIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_length_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISelectElement_get_type_Proxy( 
    ISelectElement __RPC_FAR * This,
    /* [out][retval] */ htmlSelectType __RPC_FAR *p);


void __RPC_STUB ISelectElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISelectElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Select;

class Select;
#endif

#ifndef __ISelectionObject_INTERFACE_DEFINED__
#define __ISelectionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISelectionObject
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ISelectionObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISelectionObject : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE empty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE clear( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE createRange( 
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *range) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ htmlSelection __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISelectionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISelectionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISelectionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISelectionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISelectionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISelectionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISelectionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *empty )( 
            ISelectionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *clear )( 
            ISelectionObject __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createRange )( 
            ISelectionObject __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *range);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            ISelectionObject __RPC_FAR * This,
            /* [out][retval] */ htmlSelection __RPC_FAR *p);
        
        END_INTERFACE
    } ISelectionObjectVtbl;

    interface ISelectionObject
    {
        CONST_VTBL struct ISelectionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISelectionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISelectionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISelectionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISelectionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISelectionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISelectionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISelectionObject_empty(This)	\
    (This)->lpVtbl -> empty(This)

#define ISelectionObject_clear(This)	\
    (This)->lpVtbl -> clear(This)

#define ISelectionObject_createRange(This,range)	\
    (This)->lpVtbl -> createRange(This,range)

#define ISelectionObject_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISelectionObject_empty_Proxy( 
    ISelectionObject __RPC_FAR * This);


void __RPC_STUB ISelectionObject_empty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject_clear_Proxy( 
    ISelectionObject __RPC_FAR * This);


void __RPC_STUB ISelectionObject_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISelectionObject_createRange_Proxy( 
    ISelectionObject __RPC_FAR * This,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *range);


void __RPC_STUB ISelectionObject_createRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISelectionObject_get_type_Proxy( 
    ISelectionObject __RPC_FAR * This,
    /* [out][retval] */ htmlSelection __RPC_FAR *p);


void __RPC_STUB ISelectionObject_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISelectionObject_INTERFACE_DEFINED__ */


#ifndef __IOptionElement_INTERFACE_DEFINED__
#define __IOptionElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOptionElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IOptionElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOptionElement : public IElement
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_selected( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_selected( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_defaultSelected( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_defaultSelected( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_index( 
            /* [in] */ LONG v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_index( 
            /* [out][retval] */ LONG __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Class( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOptionElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOptionElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOptionElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IOptionElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IOptionElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_selected )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_selected )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_defaultSelected )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_defaultSelected )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_index )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ LONG v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_index )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ LONG __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IOptionElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IOptionElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IOptionElementVtbl;

    interface IOptionElement
    {
        CONST_VTBL struct IOptionElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOptionElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOptionElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOptionElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOptionElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IOptionElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IOptionElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IOptionElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IOptionElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IOptionElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IOptionElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IOptionElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IOptionElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IOptionElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IOptionElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IOptionElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IOptionElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IOptionElement_put_selected(This,v)	\
    (This)->lpVtbl -> put_selected(This,v)

#define IOptionElement_get_selected(This,p)	\
    (This)->lpVtbl -> get_selected(This,p)

#define IOptionElement_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IOptionElement_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IOptionElement_put_defaultSelected(This,v)	\
    (This)->lpVtbl -> put_defaultSelected(This,v)

#define IOptionElement_get_defaultSelected(This,p)	\
    (This)->lpVtbl -> get_defaultSelected(This,p)

#define IOptionElement_put_index(This,v)	\
    (This)->lpVtbl -> put_index(This,v)

#define IOptionElement_get_index(This,p)	\
    (This)->lpVtbl -> get_index(This,p)

#define IOptionElement_put_text(This,v)	\
    (This)->lpVtbl -> put_text(This,v)

#define IOptionElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IOptionElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IOptionElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IOptionElement_put_selected_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IOptionElement_put_selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IOptionElement_get_selected_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IOptionElement_get_selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IOptionElement_put_value_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IOptionElement_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IOptionElement_get_value_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IOptionElement_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IOptionElement_put_defaultSelected_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB IOptionElement_put_defaultSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IOptionElement_get_defaultSelected_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IOptionElement_get_defaultSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IOptionElement_put_index_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [in] */ LONG v);


void __RPC_STUB IOptionElement_put_index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IOptionElement_get_index_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [out][retval] */ LONG __RPC_FAR *p);


void __RPC_STUB IOptionElement_get_index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IOptionElement_put_text_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IOptionElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IOptionElement_get_text_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IOptionElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IOptionElement_put_Class_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IOptionElement_put_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IOptionElement_get_Class_Proxy( 
    IOptionElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IOptionElement_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOptionElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_OptionElement;

class OptionElement;
#endif

#ifndef __InputTxtBaseEvents_DISPINTERFACE_DEFINED__
#define __InputTxtBaseEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: InputTxtBaseEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_InputTxtBaseEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface InputTxtBaseEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct InputTxtBaseEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            InputTxtBaseEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            InputTxtBaseEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            InputTxtBaseEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            InputTxtBaseEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            InputTxtBaseEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            InputTxtBaseEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            InputTxtBaseEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } InputTxtBaseEventsVtbl;

    interface InputTxtBaseEvents
    {
        CONST_VTBL struct InputTxtBaseEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define InputTxtBaseEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define InputTxtBaseEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define InputTxtBaseEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define InputTxtBaseEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define InputTxtBaseEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define InputTxtBaseEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define InputTxtBaseEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __InputTxtBaseEvents_DISPINTERFACE_DEFINED__ */


#ifndef __InputTextEvents_DISPINTERFACE_DEFINED__
#define __InputTextEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: InputTextEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_InputTextEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface InputTextEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct InputTextEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            InputTextEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            InputTextEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            InputTextEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            InputTextEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            InputTextEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            InputTextEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            InputTextEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } InputTextEventsVtbl;

    interface InputTextEvents
    {
        CONST_VTBL struct InputTextEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define InputTextEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define InputTextEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define InputTextEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define InputTextEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define InputTextEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define InputTextEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define InputTextEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __InputTextEvents_DISPINTERFACE_DEFINED__ */


#ifndef __TextAreaEvents_DISPINTERFACE_DEFINED__
#define __TextAreaEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: TextAreaEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_TextAreaEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface TextAreaEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct TextAreaEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            TextAreaEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            TextAreaEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            TextAreaEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            TextAreaEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            TextAreaEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            TextAreaEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            TextAreaEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } TextAreaEventsVtbl;

    interface TextAreaEvents
    {
        CONST_VTBL struct TextAreaEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define TextAreaEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define TextAreaEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define TextAreaEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define TextAreaEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define TextAreaEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define TextAreaEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define TextAreaEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __TextAreaEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IInputHidden_INTERFACE_DEFINED__
#define __IInputHidden_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInputHidden
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IInputHidden;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInputHidden : public IControlElement
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ VARIANT __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputHiddenVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputHidden __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputHidden __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInputHidden __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IInputHidden __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IInputHidden __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IInputHidden __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IInputHidden __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IInputHidden __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IInputHiddenVtbl;

    interface IInputHidden
    {
        CONST_VTBL struct IInputHiddenVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputHidden_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputHidden_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputHidden_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputHidden_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInputHidden_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInputHidden_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInputHidden_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IInputHidden_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IInputHidden_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IInputHidden_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IInputHidden_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IInputHidden_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IInputHidden_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IInputHidden_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IInputHidden_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IInputHidden_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IInputHidden_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IInputHidden_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IInputHidden_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IInputHidden_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IInputHidden_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IInputHidden_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IInputHidden_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IInputHidden_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IInputHidden_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IInputHidden_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IInputHidden_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define IInputHidden_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IInputHidden_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IInputHidden_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IInputHidden_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IInputHidden_get_type_Proxy( 
    IInputHidden __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *p);


void __RPC_STUB IInputHidden_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputHidden_put_value_Proxy( 
    IInputHidden __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputHidden_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputHidden_get_value_Proxy( 
    IInputHidden __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputHidden_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputHidden_put_name_Proxy( 
    IInputHidden __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputHidden_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputHidden_get_name_Proxy( 
    IInputHidden __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputHidden_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInputHidden_INTERFACE_DEFINED__ */


#ifndef __IInputPassword_INTERFACE_DEFINED__
#define __IInputPassword_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInputPassword
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IInputPassword;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInputPassword : public IInputHidden
    {
    public:
        virtual /* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_defaultvalue( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_defaultvalue( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_size( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_size( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_maxlength( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_maxlength( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE focus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE blur( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE select( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputPasswordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputPassword __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputPassword __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInputPassword __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IInputPassword __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IInputPassword __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IInputPassword __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_defaultvalue )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_defaultvalue )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_size )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_size )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_maxlength )( 
            IInputPassword __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_maxlength )( 
            IInputPassword __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *focus )( 
            IInputPassword __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *blur )( 
            IInputPassword __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *select )( 
            IInputPassword __RPC_FAR * This);
        
        END_INTERFACE
    } IInputPasswordVtbl;

    interface IInputPassword
    {
        CONST_VTBL struct IInputPasswordVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputPassword_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputPassword_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputPassword_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputPassword_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInputPassword_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInputPassword_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInputPassword_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IInputPassword_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IInputPassword_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IInputPassword_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IInputPassword_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IInputPassword_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IInputPassword_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IInputPassword_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IInputPassword_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IInputPassword_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IInputPassword_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IInputPassword_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IInputPassword_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IInputPassword_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IInputPassword_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IInputPassword_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IInputPassword_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IInputPassword_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IInputPassword_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IInputPassword_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IInputPassword_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define IInputPassword_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IInputPassword_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IInputPassword_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IInputPassword_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)


#define IInputPassword_put_defaultvalue(This,v)	\
    (This)->lpVtbl -> put_defaultvalue(This,v)

#define IInputPassword_get_defaultvalue(This,p)	\
    (This)->lpVtbl -> get_defaultvalue(This,p)

#define IInputPassword_put_size(This,v)	\
    (This)->lpVtbl -> put_size(This,v)

#define IInputPassword_get_size(This,p)	\
    (This)->lpVtbl -> get_size(This,p)

#define IInputPassword_put_maxlength(This,v)	\
    (This)->lpVtbl -> put_maxlength(This,v)

#define IInputPassword_get_maxlength(This,p)	\
    (This)->lpVtbl -> get_maxlength(This,p)

#define IInputPassword_focus(This)	\
    (This)->lpVtbl -> focus(This)

#define IInputPassword_blur(This)	\
    (This)->lpVtbl -> blur(This)

#define IInputPassword_select(This)	\
    (This)->lpVtbl -> select(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputPassword_put_defaultvalue_Proxy( 
    IInputPassword __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputPassword_put_defaultvalue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputPassword_get_defaultvalue_Proxy( 
    IInputPassword __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputPassword_get_defaultvalue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputPassword_put_size_Proxy( 
    IInputPassword __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IInputPassword_put_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputPassword_get_size_Proxy( 
    IInputPassword __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IInputPassword_get_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputPassword_put_maxlength_Proxy( 
    IInputPassword __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IInputPassword_put_maxlength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputPassword_get_maxlength_Proxy( 
    IInputPassword __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IInputPassword_get_maxlength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInputPassword_focus_Proxy( 
    IInputPassword __RPC_FAR * This);


void __RPC_STUB IInputPassword_focus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInputPassword_blur_Proxy( 
    IInputPassword __RPC_FAR * This);


void __RPC_STUB IInputPassword_blur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInputPassword_select_Proxy( 
    IInputPassword __RPC_FAR * This);


void __RPC_STUB IInputPassword_select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInputPassword_INTERFACE_DEFINED__ */


#ifndef __IInputText_INTERFACE_DEFINED__
#define __IInputText_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInputText
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IInputText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInputText : public IInputPassword
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_language( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onBlur( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onBlur( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onFocus( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onFocus( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onChange( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onChange( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onSelect( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onSelect( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputText __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInputText __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInputText __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInputText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInputText __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IInputText __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IInputText __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IInputText __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IInputText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IInputText __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_defaultvalue )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_defaultvalue )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_size )( 
            IInputText __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_size )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_maxlength )( 
            IInputText __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_maxlength )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *focus )( 
            IInputText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *blur )( 
            IInputText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *select )( 
            IInputText __RPC_FAR * This);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onBlur )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onBlur )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onFocus )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onFocus )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onChange )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onChange )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onSelect )( 
            IInputText __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onSelect )( 
            IInputText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IInputTextVtbl;

    interface IInputText
    {
        CONST_VTBL struct IInputTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputText_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInputText_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInputText_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInputText_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IInputText_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IInputText_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IInputText_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IInputText_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IInputText_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IInputText_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IInputText_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IInputText_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IInputText_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IInputText_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IInputText_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IInputText_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IInputText_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IInputText_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IInputText_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IInputText_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IInputText_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IInputText_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IInputText_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IInputText_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define IInputText_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IInputText_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IInputText_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IInputText_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)


#define IInputText_put_defaultvalue(This,v)	\
    (This)->lpVtbl -> put_defaultvalue(This,v)

#define IInputText_get_defaultvalue(This,p)	\
    (This)->lpVtbl -> get_defaultvalue(This,p)

#define IInputText_put_size(This,v)	\
    (This)->lpVtbl -> put_size(This,v)

#define IInputText_get_size(This,p)	\
    (This)->lpVtbl -> get_size(This,p)

#define IInputText_put_maxlength(This,v)	\
    (This)->lpVtbl -> put_maxlength(This,v)

#define IInputText_get_maxlength(This,p)	\
    (This)->lpVtbl -> get_maxlength(This,p)

#define IInputText_focus(This)	\
    (This)->lpVtbl -> focus(This)

#define IInputText_blur(This)	\
    (This)->lpVtbl -> blur(This)

#define IInputText_select(This)	\
    (This)->lpVtbl -> select(This)


#define IInputText_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define IInputText_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define IInputText_put_onBlur(This,v)	\
    (This)->lpVtbl -> put_onBlur(This,v)

#define IInputText_get_onBlur(This,p)	\
    (This)->lpVtbl -> get_onBlur(This,p)

#define IInputText_put_onFocus(This,v)	\
    (This)->lpVtbl -> put_onFocus(This,v)

#define IInputText_get_onFocus(This,p)	\
    (This)->lpVtbl -> get_onFocus(This,p)

#define IInputText_put_onChange(This,v)	\
    (This)->lpVtbl -> put_onChange(This,v)

#define IInputText_get_onChange(This,p)	\
    (This)->lpVtbl -> get_onChange(This,p)

#define IInputText_put_onSelect(This,v)	\
    (This)->lpVtbl -> put_onSelect(This,v)

#define IInputText_get_onSelect(This,p)	\
    (This)->lpVtbl -> get_onSelect(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputText_put_language_Proxy( 
    IInputText __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputText_put_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputText_get_language_Proxy( 
    IInputText __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputText_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputText_put_onBlur_Proxy( 
    IInputText __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputText_put_onBlur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputText_get_onBlur_Proxy( 
    IInputText __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputText_get_onBlur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputText_put_onFocus_Proxy( 
    IInputText __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputText_put_onFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputText_get_onFocus_Proxy( 
    IInputText __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputText_get_onFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputText_put_onChange_Proxy( 
    IInputText __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputText_put_onChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputText_get_onChange_Proxy( 
    IInputText __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputText_get_onChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputText_put_onSelect_Proxy( 
    IInputText __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputText_put_onSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputText_get_onSelect_Proxy( 
    IInputText __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputText_get_onSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInputText_INTERFACE_DEFINED__ */


#ifndef __ITextArea_INTERFACE_DEFINED__
#define __ITextArea_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextArea
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITextArea;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITextArea : public IControlElement
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ VARIANT __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_defaultvalue( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_defaultvalue( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_language( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onBlur( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onBlur( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onFocus( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onFocus( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onChange( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onChange( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onSelect( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onSelect( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_rows( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_rows( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_cols( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_cols( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_wrap( 
            /* [in] */ htmlWrap v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_wrap( 
            /* [out][retval] */ htmlWrap __RPC_FAR *p) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE focus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE blur( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE select( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextAreaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextArea __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextArea __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextArea __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITextArea __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            ITextArea __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            ITextArea __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_defaultvalue )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_defaultvalue )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onBlur )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onBlur )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onFocus )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onFocus )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onChange )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onChange )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onSelect )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onSelect )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_rows )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rows )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_cols )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cols )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_wrap )( 
            ITextArea __RPC_FAR * This,
            /* [in] */ htmlWrap v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_wrap )( 
            ITextArea __RPC_FAR * This,
            /* [out][retval] */ htmlWrap __RPC_FAR *p);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *focus )( 
            ITextArea __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *blur )( 
            ITextArea __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *select )( 
            ITextArea __RPC_FAR * This);
        
        END_INTERFACE
    } ITextAreaVtbl;

    interface ITextArea
    {
        CONST_VTBL struct ITextAreaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextArea_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextArea_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextArea_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextArea_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextArea_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextArea_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextArea_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextArea_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITextArea_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITextArea_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITextArea_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITextArea_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITextArea_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITextArea_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITextArea_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITextArea_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ITextArea_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define ITextArea_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define ITextArea_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define ITextArea_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define ITextArea_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define ITextArea_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define ITextArea_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define ITextArea_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define ITextArea_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define ITextArea_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define ITextArea_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define ITextArea_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define ITextArea_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#define ITextArea_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define ITextArea_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define ITextArea_put_defaultvalue(This,v)	\
    (This)->lpVtbl -> put_defaultvalue(This,v)

#define ITextArea_get_defaultvalue(This,p)	\
    (This)->lpVtbl -> get_defaultvalue(This,p)

#define ITextArea_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define ITextArea_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define ITextArea_put_onBlur(This,v)	\
    (This)->lpVtbl -> put_onBlur(This,v)

#define ITextArea_get_onBlur(This,p)	\
    (This)->lpVtbl -> get_onBlur(This,p)

#define ITextArea_put_onFocus(This,v)	\
    (This)->lpVtbl -> put_onFocus(This,v)

#define ITextArea_get_onFocus(This,p)	\
    (This)->lpVtbl -> get_onFocus(This,p)

#define ITextArea_put_onChange(This,v)	\
    (This)->lpVtbl -> put_onChange(This,v)

#define ITextArea_get_onChange(This,p)	\
    (This)->lpVtbl -> get_onChange(This,p)

#define ITextArea_put_onSelect(This,v)	\
    (This)->lpVtbl -> put_onSelect(This,v)

#define ITextArea_get_onSelect(This,p)	\
    (This)->lpVtbl -> get_onSelect(This,p)

#define ITextArea_put_rows(This,v)	\
    (This)->lpVtbl -> put_rows(This,v)

#define ITextArea_get_rows(This,p)	\
    (This)->lpVtbl -> get_rows(This,p)

#define ITextArea_put_cols(This,v)	\
    (This)->lpVtbl -> put_cols(This,v)

#define ITextArea_get_cols(This,p)	\
    (This)->lpVtbl -> get_cols(This,p)

#define ITextArea_put_wrap(This,v)	\
    (This)->lpVtbl -> put_wrap(This,v)

#define ITextArea_get_wrap(This,p)	\
    (This)->lpVtbl -> get_wrap(This,p)

#define ITextArea_focus(This)	\
    (This)->lpVtbl -> focus(This)

#define ITextArea_blur(This)	\
    (This)->lpVtbl -> blur(This)

#define ITextArea_select(This)	\
    (This)->lpVtbl -> select(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_type_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *p);


void __RPC_STUB ITextArea_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_name_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITextArea_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_name_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITextArea_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_value_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITextArea_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_value_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITextArea_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_defaultvalue_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITextArea_put_defaultvalue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_defaultvalue_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITextArea_get_defaultvalue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_language_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITextArea_put_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_language_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITextArea_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_onBlur_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITextArea_put_onBlur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_onBlur_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITextArea_get_onBlur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_onFocus_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITextArea_put_onFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_onFocus_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITextArea_get_onFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_onChange_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITextArea_put_onChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_onChange_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITextArea_get_onChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_onSelect_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITextArea_put_onSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_onSelect_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITextArea_get_onSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_rows_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITextArea_put_rows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_rows_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITextArea_get_rows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_cols_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITextArea_put_cols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_cols_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITextArea_get_cols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ITextArea_put_wrap_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [in] */ htmlWrap v);


void __RPC_STUB ITextArea_put_wrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ITextArea_get_wrap_Proxy( 
    ITextArea __RPC_FAR * This,
    /* [out][retval] */ htmlWrap __RPC_FAR *p);


void __RPC_STUB ITextArea_get_wrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextArea_focus_Proxy( 
    ITextArea __RPC_FAR * This);


void __RPC_STUB ITextArea_focus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextArea_blur_Proxy( 
    ITextArea __RPC_FAR * This);


void __RPC_STUB ITextArea_blur_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextArea_select_Proxy( 
    ITextArea __RPC_FAR * This);


void __RPC_STUB ITextArea_select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextArea_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_InputText;

class InputText;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TextArea;

class TextArea;
#endif

#ifndef __InputButtonEvents_DISPINTERFACE_DEFINED__
#define __InputButtonEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: InputButtonEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_InputButtonEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface InputButtonEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct InputButtonEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            InputButtonEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            InputButtonEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            InputButtonEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            InputButtonEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            InputButtonEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            InputButtonEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            InputButtonEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } InputButtonEventsVtbl;

    interface InputButtonEvents
    {
        CONST_VTBL struct InputButtonEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define InputButtonEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define InputButtonEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define InputButtonEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define InputButtonEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define InputButtonEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define InputButtonEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define InputButtonEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __InputButtonEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IInputReset_INTERFACE_DEFINED__
#define __IInputReset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInputReset
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IInputReset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInputReset : public IInputHidden
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_language( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onClick( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onClick( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE click( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputResetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputReset __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputReset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInputReset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IInputReset __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IInputReset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IInputReset __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onClick )( 
            IInputReset __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onClick )( 
            IInputReset __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *click )( 
            IInputReset __RPC_FAR * This);
        
        END_INTERFACE
    } IInputResetVtbl;

    interface IInputReset
    {
        CONST_VTBL struct IInputResetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputReset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputReset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputReset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputReset_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInputReset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInputReset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInputReset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IInputReset_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IInputReset_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IInputReset_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IInputReset_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IInputReset_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IInputReset_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IInputReset_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IInputReset_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IInputReset_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IInputReset_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IInputReset_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IInputReset_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IInputReset_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IInputReset_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IInputReset_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IInputReset_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IInputReset_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IInputReset_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IInputReset_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IInputReset_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define IInputReset_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IInputReset_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IInputReset_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IInputReset_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)


#define IInputReset_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define IInputReset_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define IInputReset_put_onClick(This,v)	\
    (This)->lpVtbl -> put_onClick(This,v)

#define IInputReset_get_onClick(This,p)	\
    (This)->lpVtbl -> get_onClick(This,p)

#define IInputReset_click(This)	\
    (This)->lpVtbl -> click(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputReset_put_language_Proxy( 
    IInputReset __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputReset_put_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputReset_get_language_Proxy( 
    IInputReset __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputReset_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IInputReset_put_onClick_Proxy( 
    IInputReset __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IInputReset_put_onClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IInputReset_get_onClick_Proxy( 
    IInputReset __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IInputReset_get_onClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInputReset_click_Proxy( 
    IInputReset __RPC_FAR * This);


void __RPC_STUB IInputReset_click_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInputReset_INTERFACE_DEFINED__ */


#ifndef __IInputSubmit_INTERFACE_DEFINED__
#define __IInputSubmit_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInputSubmit
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IInputSubmit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInputSubmit : public IInputReset
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInputSubmitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputSubmit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputSubmit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInputSubmit __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IInputSubmit __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IInputSubmit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IInputSubmit __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onClick )( 
            IInputSubmit __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onClick )( 
            IInputSubmit __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *click )( 
            IInputSubmit __RPC_FAR * This);
        
        END_INTERFACE
    } IInputSubmitVtbl;

    interface IInputSubmit
    {
        CONST_VTBL struct IInputSubmitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputSubmit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputSubmit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputSubmit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputSubmit_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInputSubmit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInputSubmit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInputSubmit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IInputSubmit_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IInputSubmit_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IInputSubmit_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IInputSubmit_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IInputSubmit_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IInputSubmit_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IInputSubmit_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IInputSubmit_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IInputSubmit_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IInputSubmit_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IInputSubmit_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IInputSubmit_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IInputSubmit_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IInputSubmit_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IInputSubmit_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IInputSubmit_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IInputSubmit_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IInputSubmit_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IInputSubmit_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IInputSubmit_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define IInputSubmit_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IInputSubmit_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IInputSubmit_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IInputSubmit_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)


#define IInputSubmit_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define IInputSubmit_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define IInputSubmit_put_onClick(This,v)	\
    (This)->lpVtbl -> put_onClick(This,v)

#define IInputSubmit_get_onClick(This,p)	\
    (This)->lpVtbl -> get_onClick(This,p)

#define IInputSubmit_click(This)	\
    (This)->lpVtbl -> click(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputSubmit_INTERFACE_DEFINED__ */


#ifndef __IInputButton_INTERFACE_DEFINED__
#define __IInputButton_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInputButton
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IInputButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInputButton : public IInputSubmit
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInputButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputButton __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputButton __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInputButton __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IInputButton __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IInputButton __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IInputButton __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onClick )( 
            IInputButton __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onClick )( 
            IInputButton __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *click )( 
            IInputButton __RPC_FAR * This);
        
        END_INTERFACE
    } IInputButtonVtbl;

    interface IInputButton
    {
        CONST_VTBL struct IInputButtonVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputButton_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInputButton_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInputButton_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInputButton_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IInputButton_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IInputButton_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IInputButton_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IInputButton_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IInputButton_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IInputButton_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IInputButton_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IInputButton_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IInputButton_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IInputButton_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IInputButton_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IInputButton_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IInputButton_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IInputButton_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IInputButton_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IInputButton_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IInputButton_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IInputButton_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IInputButton_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IInputButton_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define IInputButton_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IInputButton_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IInputButton_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IInputButton_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)


#define IInputButton_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define IInputButton_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define IInputButton_put_onClick(This,v)	\
    (This)->lpVtbl -> put_onClick(This,v)

#define IInputButton_get_onClick(This,p)	\
    (This)->lpVtbl -> get_onClick(This,p)

#define IInputButton_click(This)	\
    (This)->lpVtbl -> click(This)



#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputButton_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_InputBtn;

class InputBtn;
#endif

#ifndef __MarqueeEvents_DISPINTERFACE_DEFINED__
#define __MarqueeEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: MarqueeEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_MarqueeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface MarqueeEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct MarqueeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            MarqueeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            MarqueeEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            MarqueeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            MarqueeEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            MarqueeEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            MarqueeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            MarqueeEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } MarqueeEventsVtbl;

    interface MarqueeEvents
    {
        CONST_VTBL struct MarqueeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define MarqueeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define MarqueeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define MarqueeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define MarqueeEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define MarqueeEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define MarqueeEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define MarqueeEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __MarqueeEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IMarquee_INTERFACE_DEFINED__
#define __IMarquee_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMarquee
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IMarquee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMarquee : public IControlElement
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bgColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bgColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlControlAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlControlAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_scrollDelay( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_scrollDelay( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_direction( 
            /* [in] */ htmlDirection v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_direction( 
            /* [out][retval] */ htmlDirection __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_scrollAmount( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_scrollAmount( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_loop( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_loop( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_vspace( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_vspace( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_hspace( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hspace( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarqueeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMarquee __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMarquee __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMarquee __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IMarquee __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IMarquee __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IMarquee __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bgColor )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bgColor )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ htmlControlAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ htmlControlAlign __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_scrollDelay )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_scrollDelay )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_direction )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ htmlDirection v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_direction )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ htmlDirection __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_scrollAmount )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_scrollAmount )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_loop )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_loop )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vspace )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vspace )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_hspace )( 
            IMarquee __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_hspace )( 
            IMarquee __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *start )( 
            IMarquee __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *stop )( 
            IMarquee __RPC_FAR * This);
        
        END_INTERFACE
    } IMarqueeVtbl;

    interface IMarquee
    {
        CONST_VTBL struct IMarqueeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarquee_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarquee_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarquee_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarquee_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMarquee_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMarquee_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMarquee_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMarquee_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IMarquee_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IMarquee_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IMarquee_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IMarquee_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IMarquee_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IMarquee_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IMarquee_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IMarquee_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IMarquee_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IMarquee_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IMarquee_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IMarquee_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IMarquee_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IMarquee_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IMarquee_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IMarquee_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IMarquee_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IMarquee_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IMarquee_put_bgColor(This,v)	\
    (This)->lpVtbl -> put_bgColor(This,v)

#define IMarquee_get_bgColor(This,p)	\
    (This)->lpVtbl -> get_bgColor(This,p)

#define IMarquee_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define IMarquee_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define IMarquee_put_scrollDelay(This,v)	\
    (This)->lpVtbl -> put_scrollDelay(This,v)

#define IMarquee_get_scrollDelay(This,p)	\
    (This)->lpVtbl -> get_scrollDelay(This,p)

#define IMarquee_put_direction(This,v)	\
    (This)->lpVtbl -> put_direction(This,v)

#define IMarquee_get_direction(This,p)	\
    (This)->lpVtbl -> get_direction(This,p)

#define IMarquee_put_scrollAmount(This,v)	\
    (This)->lpVtbl -> put_scrollAmount(This,v)

#define IMarquee_get_scrollAmount(This,p)	\
    (This)->lpVtbl -> get_scrollAmount(This,p)

#define IMarquee_put_loop(This,v)	\
    (This)->lpVtbl -> put_loop(This,v)

#define IMarquee_get_loop(This,p)	\
    (This)->lpVtbl -> get_loop(This,p)

#define IMarquee_put_vspace(This,v)	\
    (This)->lpVtbl -> put_vspace(This,v)

#define IMarquee_get_vspace(This,p)	\
    (This)->lpVtbl -> get_vspace(This,p)

#define IMarquee_put_hspace(This,v)	\
    (This)->lpVtbl -> put_hspace(This,v)

#define IMarquee_get_hspace(This,p)	\
    (This)->lpVtbl -> get_hspace(This,p)

#define IMarquee_start(This)	\
    (This)->lpVtbl -> start(This)

#define IMarquee_stop(This)	\
    (This)->lpVtbl -> stop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMarquee_put_bgColor_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IMarquee_put_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMarquee_get_bgColor_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IMarquee_get_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMarquee_put_align_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [in] */ htmlControlAlign v);


void __RPC_STUB IMarquee_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMarquee_get_align_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [out][retval] */ htmlControlAlign __RPC_FAR *p);


void __RPC_STUB IMarquee_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMarquee_put_scrollDelay_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IMarquee_put_scrollDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMarquee_get_scrollDelay_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IMarquee_get_scrollDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMarquee_put_direction_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [in] */ htmlDirection v);


void __RPC_STUB IMarquee_put_direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMarquee_get_direction_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [out][retval] */ htmlDirection __RPC_FAR *p);


void __RPC_STUB IMarquee_get_direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMarquee_put_scrollAmount_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IMarquee_put_scrollAmount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMarquee_get_scrollAmount_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IMarquee_get_scrollAmount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMarquee_put_loop_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IMarquee_put_loop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMarquee_get_loop_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IMarquee_get_loop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMarquee_put_vspace_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IMarquee_put_vspace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMarquee_get_vspace_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IMarquee_get_vspace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMarquee_put_hspace_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IMarquee_put_hspace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMarquee_get_hspace_Proxy( 
    IMarquee __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IMarquee_get_hspace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarquee_start_Proxy( 
    IMarquee __RPC_FAR * This);


void __RPC_STUB IMarquee_start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarquee_stop_Proxy( 
    IMarquee __RPC_FAR * This);


void __RPC_STUB IMarquee_stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarquee_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Marquee;

class Marquee;
#endif

#ifndef __CheckboxElementEvents_DISPINTERFACE_DEFINED__
#define __CheckboxElementEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: CheckboxElementEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_CheckboxElementEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface CheckboxElementEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct CheckboxElementEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            CheckboxElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            CheckboxElementEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            CheckboxElementEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            CheckboxElementEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            CheckboxElementEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            CheckboxElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            CheckboxElementEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } CheckboxElementEventsVtbl;

    interface CheckboxElementEvents
    {
        CONST_VTBL struct CheckboxElementEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define CheckboxElementEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define CheckboxElementEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define CheckboxElementEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define CheckboxElementEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define CheckboxElementEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define CheckboxElementEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define CheckboxElementEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __CheckboxElementEvents_DISPINTERFACE_DEFINED__ */


#ifndef __ICheckboxElement_INTERFACE_DEFINED__
#define __ICheckboxElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICheckboxElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ICheckboxElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICheckboxElement : public IControlElement
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ VARIANT __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_checked( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_checked( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_defaultChecked( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_defaultChecked( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_language( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onClick( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onClick( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE click( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICheckboxElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICheckboxElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICheckboxElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            ICheckboxElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_checked )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_checked )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_defaultChecked )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_defaultChecked )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onClick )( 
            ICheckboxElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onClick )( 
            ICheckboxElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *click )( 
            ICheckboxElement __RPC_FAR * This);
        
        END_INTERFACE
    } ICheckboxElementVtbl;

    interface ICheckboxElement
    {
        CONST_VTBL struct ICheckboxElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICheckboxElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICheckboxElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICheckboxElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICheckboxElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICheckboxElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICheckboxElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICheckboxElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICheckboxElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ICheckboxElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ICheckboxElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ICheckboxElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ICheckboxElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ICheckboxElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ICheckboxElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ICheckboxElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ICheckboxElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ICheckboxElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define ICheckboxElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define ICheckboxElement_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define ICheckboxElement_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define ICheckboxElement_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define ICheckboxElement_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define ICheckboxElement_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define ICheckboxElement_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define ICheckboxElement_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define ICheckboxElement_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define ICheckboxElement_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define ICheckboxElement_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define ICheckboxElement_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#define ICheckboxElement_put_checked(This,v)	\
    (This)->lpVtbl -> put_checked(This,v)

#define ICheckboxElement_get_checked(This,p)	\
    (This)->lpVtbl -> get_checked(This,p)

#define ICheckboxElement_put_defaultChecked(This,v)	\
    (This)->lpVtbl -> put_defaultChecked(This,v)

#define ICheckboxElement_get_defaultChecked(This,p)	\
    (This)->lpVtbl -> get_defaultChecked(This,p)

#define ICheckboxElement_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define ICheckboxElement_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define ICheckboxElement_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define ICheckboxElement_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define ICheckboxElement_put_onClick(This,v)	\
    (This)->lpVtbl -> put_onClick(This,v)

#define ICheckboxElement_get_onClick(This,p)	\
    (This)->lpVtbl -> get_onClick(This,p)

#define ICheckboxElement_click(This)	\
    (This)->lpVtbl -> click(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_get_type_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *p);


void __RPC_STUB ICheckboxElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_put_name_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ICheckboxElement_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_get_name_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ICheckboxElement_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_put_checked_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ICheckboxElement_put_checked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_get_checked_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ICheckboxElement_get_checked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_put_defaultChecked_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ICheckboxElement_put_defaultChecked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_get_defaultChecked_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ICheckboxElement_get_defaultChecked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_put_value_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ICheckboxElement_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_get_value_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ICheckboxElement_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_put_language_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ICheckboxElement_put_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_get_language_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ICheckboxElement_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_put_onClick_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ICheckboxElement_put_onClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_get_onClick_Proxy( 
    ICheckboxElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ICheckboxElement_get_onClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ICheckboxElement_click_Proxy( 
    ICheckboxElement __RPC_FAR * This);


void __RPC_STUB ICheckboxElement_click_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICheckboxElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CheckboxElement;

class CheckboxElement;
#endif

#ifndef __RadioElementEvents_DISPINTERFACE_DEFINED__
#define __RadioElementEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: RadioElementEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_RadioElementEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface RadioElementEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct RadioElementEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            RadioElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            RadioElementEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            RadioElementEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            RadioElementEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            RadioElementEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            RadioElementEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            RadioElementEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } RadioElementEventsVtbl;

    interface RadioElementEvents
    {
        CONST_VTBL struct RadioElementEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define RadioElementEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define RadioElementEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define RadioElementEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define RadioElementEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define RadioElementEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define RadioElementEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define RadioElementEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __RadioElementEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IRadioElement_INTERFACE_DEFINED__
#define __IRadioElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRadioElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IRadioElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRadioElement : public ICheckboxElement
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IRadioElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRadioElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRadioElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRadioElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IRadioElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IRadioElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IRadioElement __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_checked )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_checked )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_defaultChecked )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_defaultChecked )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_value )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_language )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_language )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onClick )( 
            IRadioElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onClick )( 
            IRadioElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *click )( 
            IRadioElement __RPC_FAR * This);
        
        END_INTERFACE
    } IRadioElementVtbl;

    interface IRadioElement
    {
        CONST_VTBL struct IRadioElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRadioElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRadioElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRadioElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRadioElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRadioElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRadioElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRadioElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRadioElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IRadioElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IRadioElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IRadioElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IRadioElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IRadioElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IRadioElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IRadioElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IRadioElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IRadioElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IRadioElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IRadioElement_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IRadioElement_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IRadioElement_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IRadioElement_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IRadioElement_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IRadioElement_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IRadioElement_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IRadioElement_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define IRadioElement_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#define IRadioElement_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IRadioElement_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#define IRadioElement_put_checked(This,v)	\
    (This)->lpVtbl -> put_checked(This,v)

#define IRadioElement_get_checked(This,p)	\
    (This)->lpVtbl -> get_checked(This,p)

#define IRadioElement_put_defaultChecked(This,v)	\
    (This)->lpVtbl -> put_defaultChecked(This,v)

#define IRadioElement_get_defaultChecked(This,p)	\
    (This)->lpVtbl -> get_defaultChecked(This,p)

#define IRadioElement_put_value(This,v)	\
    (This)->lpVtbl -> put_value(This,v)

#define IRadioElement_get_value(This,p)	\
    (This)->lpVtbl -> get_value(This,p)

#define IRadioElement_put_language(This,v)	\
    (This)->lpVtbl -> put_language(This,v)

#define IRadioElement_get_language(This,p)	\
    (This)->lpVtbl -> get_language(This,p)

#define IRadioElement_put_onClick(This,v)	\
    (This)->lpVtbl -> put_onClick(This,v)

#define IRadioElement_get_onClick(This,p)	\
    (This)->lpVtbl -> get_onClick(This,p)

#define IRadioElement_click(This)	\
    (This)->lpVtbl -> click(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRadioElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RadioElement;

class RadioElement;
#endif

#ifndef __IInputElement_INTERFACE_DEFINED__
#define __IInputElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInputElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IInputElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInputElement : public IControlElement
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInputElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInputElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IInputElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            IInputElement __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            IInputElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            IInputElement __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IInputElement __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        END_INTERFACE
    } IInputElementVtbl;

    interface IInputElement
    {
        CONST_VTBL struct IInputElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInputElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInputElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInputElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IInputElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IInputElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IInputElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IInputElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IInputElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IInputElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IInputElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IInputElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IInputElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IInputElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IInputElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IInputElement_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define IInputElement_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define IInputElement_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define IInputElement_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define IInputElement_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define IInputElement_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define IInputElement_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IInputElement_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Input;

class Input;
#endif

#ifndef __ITitleElement_INTERFACE_DEFINED__
#define __ITitleElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITitleElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITitleElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITitleElement : public IElement
    {
    public:
        virtual /* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITitleElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITitleElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITitleElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITitleElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITitleElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITitleElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITitleElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITitleElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITitleElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITitleElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITitleElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITitleElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITitleElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITitleElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITitleElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITitleElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITitleElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            ITitleElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            ITitleElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } ITitleElementVtbl;

    interface ITitleElement
    {
        CONST_VTBL struct ITitleElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITitleElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITitleElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITitleElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITitleElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITitleElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITitleElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITitleElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITitleElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITitleElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITitleElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITitleElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITitleElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITitleElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITitleElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITitleElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITitleElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ITitleElement_put_text(This,v)	\
    (This)->lpVtbl -> put_text(This,v)

#define ITitleElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE ITitleElement_put_text_Proxy( 
    ITitleElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITitleElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE ITitleElement_get_text_Proxy( 
    ITitleElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITitleElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITitleElement_INTERFACE_DEFINED__ */


#ifndef __IMetaElement_INTERFACE_DEFINED__
#define __IMetaElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMetaElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IMetaElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMetaElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_httpEquiv( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_httpEquiv( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_content( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_content( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_url( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMetaElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMetaElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMetaElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMetaElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IMetaElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_httpEquiv )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_httpEquiv )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_content )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_content )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_url )( 
            IMetaElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_url )( 
            IMetaElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IMetaElementVtbl;

    interface IMetaElement
    {
        CONST_VTBL struct IMetaElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMetaElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMetaElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMetaElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMetaElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMetaElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMetaElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMetaElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMetaElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IMetaElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IMetaElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IMetaElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IMetaElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IMetaElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IMetaElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IMetaElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IMetaElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IMetaElement_put_httpEquiv(This,v)	\
    (This)->lpVtbl -> put_httpEquiv(This,v)

#define IMetaElement_get_httpEquiv(This,p)	\
    (This)->lpVtbl -> get_httpEquiv(This,p)

#define IMetaElement_put_content(This,v)	\
    (This)->lpVtbl -> put_content(This,v)

#define IMetaElement_get_content(This,p)	\
    (This)->lpVtbl -> get_content(This,p)

#define IMetaElement_put_name(This,v)	\
    (This)->lpVtbl -> put_name(This,v)

#define IMetaElement_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#define IMetaElement_put_url(This,v)	\
    (This)->lpVtbl -> put_url(This,v)

#define IMetaElement_get_url(This,p)	\
    (This)->lpVtbl -> get_url(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IMetaElement_put_httpEquiv_Proxy( 
    IMetaElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IMetaElement_put_httpEquiv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IMetaElement_get_httpEquiv_Proxy( 
    IMetaElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IMetaElement_get_httpEquiv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IMetaElement_put_content_Proxy( 
    IMetaElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IMetaElement_put_content_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IMetaElement_get_content_Proxy( 
    IMetaElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IMetaElement_get_content_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IMetaElement_put_name_Proxy( 
    IMetaElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IMetaElement_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IMetaElement_get_name_Proxy( 
    IMetaElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IMetaElement_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IMetaElement_put_url_Proxy( 
    IMetaElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IMetaElement_put_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IMetaElement_get_url_Proxy( 
    IMetaElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IMetaElement_get_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMetaElement_INTERFACE_DEFINED__ */


#ifndef __IBaseElement_INTERFACE_DEFINED__
#define __IBaseElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBaseElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IBaseElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IBaseElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_href( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_href( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_target( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_target( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBaseElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBaseElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBaseElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBaseElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBaseElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBaseElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBaseElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBaseElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IBaseElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IBaseElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IBaseElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IBaseElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IBaseElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IBaseElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IBaseElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IBaseElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IBaseElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_href )( 
            IBaseElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_href )( 
            IBaseElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_target )( 
            IBaseElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_target )( 
            IBaseElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IBaseElementVtbl;

    interface IBaseElement
    {
        CONST_VTBL struct IBaseElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBaseElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBaseElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBaseElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBaseElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBaseElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBaseElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBaseElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBaseElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IBaseElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IBaseElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IBaseElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IBaseElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IBaseElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IBaseElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IBaseElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IBaseElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IBaseElement_put_href(This,v)	\
    (This)->lpVtbl -> put_href(This,v)

#define IBaseElement_get_href(This,p)	\
    (This)->lpVtbl -> get_href(This,p)

#define IBaseElement_put_target(This,v)	\
    (This)->lpVtbl -> put_target(This,v)

#define IBaseElement_get_target(This,p)	\
    (This)->lpVtbl -> get_target(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBaseElement_put_href_Proxy( 
    IBaseElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBaseElement_put_href_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBaseElement_get_href_Proxy( 
    IBaseElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBaseElement_get_href_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBaseElement_put_target_Proxy( 
    IBaseElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBaseElement_put_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBaseElement_get_target_Proxy( 
    IBaseElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBaseElement_get_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBaseElement_INTERFACE_DEFINED__ */


#ifndef __ILinkElement_INTERFACE_DEFINED__
#define __ILinkElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILinkElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ILinkElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ILinkElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_href( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_href( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_title( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_rel( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_rel( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_ref( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_ref( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_type( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILinkElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILinkElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ILinkElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ILinkElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_href )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_href )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_rel )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rel )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ref )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ref )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_type )( 
            ILinkElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            ILinkElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } ILinkElementVtbl;

    interface ILinkElement
    {
        CONST_VTBL struct ILinkElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILinkElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILinkElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILinkElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILinkElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ILinkElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ILinkElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ILinkElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ILinkElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ILinkElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ILinkElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ILinkElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ILinkElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ILinkElement_put_href(This,v)	\
    (This)->lpVtbl -> put_href(This,v)

#define ILinkElement_get_href(This,p)	\
    (This)->lpVtbl -> get_href(This,p)

#define ILinkElement_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define ILinkElement_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define ILinkElement_put_rel(This,v)	\
    (This)->lpVtbl -> put_rel(This,v)

#define ILinkElement_get_rel(This,p)	\
    (This)->lpVtbl -> get_rel(This,p)

#define ILinkElement_put_ref(This,v)	\
    (This)->lpVtbl -> put_ref(This,v)

#define ILinkElement_get_ref(This,p)	\
    (This)->lpVtbl -> get_ref(This,p)

#define ILinkElement_put_type(This,v)	\
    (This)->lpVtbl -> put_type(This,v)

#define ILinkElement_get_type(This,p)	\
    (This)->lpVtbl -> get_type(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILinkElement_put_href_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILinkElement_put_href_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILinkElement_get_href_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILinkElement_get_href_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILinkElement_put_title_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILinkElement_put_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILinkElement_get_title_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILinkElement_get_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILinkElement_put_rel_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILinkElement_put_rel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILinkElement_get_rel_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILinkElement_get_rel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILinkElement_put_ref_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILinkElement_put_ref_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILinkElement_get_ref_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILinkElement_get_ref_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ILinkElement_put_type_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ILinkElement_put_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ILinkElement_get_type_Proxy( 
    ILinkElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ILinkElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkElement_INTERFACE_DEFINED__ */


#ifndef __IIsIndexElement_INTERFACE_DEFINED__
#define __IIsIndexElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IIsIndexElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IIsIndexElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IIsIndexElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_prompt( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_prompt( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_action( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_action( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsIndexElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIsIndexElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIsIndexElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_prompt )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prompt )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_action )( 
            IIsIndexElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_action )( 
            IIsIndexElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IIsIndexElementVtbl;

    interface IIsIndexElement
    {
        CONST_VTBL struct IIsIndexElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsIndexElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIsIndexElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIsIndexElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIsIndexElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIsIndexElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIsIndexElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIsIndexElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIsIndexElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IIsIndexElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IIsIndexElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IIsIndexElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IIsIndexElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IIsIndexElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IIsIndexElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IIsIndexElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IIsIndexElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IIsIndexElement_put_prompt(This,v)	\
    (This)->lpVtbl -> put_prompt(This,v)

#define IIsIndexElement_get_prompt(This,p)	\
    (This)->lpVtbl -> get_prompt(This,p)

#define IIsIndexElement_put_action(This,v)	\
    (This)->lpVtbl -> put_action(This,v)

#define IIsIndexElement_get_action(This,p)	\
    (This)->lpVtbl -> get_action(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IIsIndexElement_put_prompt_Proxy( 
    IIsIndexElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IIsIndexElement_put_prompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IIsIndexElement_get_prompt_Proxy( 
    IIsIndexElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IIsIndexElement_get_prompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IIsIndexElement_put_action_Proxy( 
    IIsIndexElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IIsIndexElement_put_action_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IIsIndexElement_get_action_Proxy( 
    IIsIndexElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IIsIndexElement_get_action_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIsIndexElement_INTERFACE_DEFINED__ */


#ifndef __INextIdElement_INTERFACE_DEFINED__
#define __INextIdElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: INextIdElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_INextIdElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface INextIdElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_n( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_n( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INextIdElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INextIdElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INextIdElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INextIdElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INextIdElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INextIdElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INextIdElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INextIdElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            INextIdElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            INextIdElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            INextIdElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            INextIdElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            INextIdElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            INextIdElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            INextIdElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            INextIdElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            INextIdElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_n )( 
            INextIdElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_n )( 
            INextIdElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } INextIdElementVtbl;

    interface INextIdElement
    {
        CONST_VTBL struct INextIdElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INextIdElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INextIdElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INextIdElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INextIdElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INextIdElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INextIdElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INextIdElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INextIdElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define INextIdElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define INextIdElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define INextIdElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define INextIdElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define INextIdElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define INextIdElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define INextIdElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define INextIdElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define INextIdElement_put_n(This,v)	\
    (This)->lpVtbl -> put_n(This,v)

#define INextIdElement_get_n(This,p)	\
    (This)->lpVtbl -> get_n(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE INextIdElement_put_n_Proxy( 
    INextIdElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB INextIdElement_put_n_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE INextIdElement_get_n_Proxy( 
    INextIdElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB INextIdElement_get_n_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INextIdElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TitleElement;

class TitleElement;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_MetaElement;

class MetaElement;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_BaseElement;

class BaseElement;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_LinkElement;

class LinkElement;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_IsIndexElement;

class IsIndexElement;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_NextIdElement;

class NextIdElement;
#endif

#ifndef __IBaseFontElement_INTERFACE_DEFINED__
#define __IBaseFontElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBaseFontElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IBaseFontElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IBaseFontElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_color( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_color( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_face( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_face( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_size( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_size( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBaseFontElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBaseFontElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBaseFontElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_color )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_color )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_face )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_face )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_size )( 
            IBaseFontElement __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_size )( 
            IBaseFontElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        END_INTERFACE
    } IBaseFontElementVtbl;

    interface IBaseFontElement
    {
        CONST_VTBL struct IBaseFontElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBaseFontElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBaseFontElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBaseFontElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBaseFontElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBaseFontElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBaseFontElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBaseFontElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBaseFontElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IBaseFontElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IBaseFontElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IBaseFontElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IBaseFontElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IBaseFontElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IBaseFontElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IBaseFontElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IBaseFontElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define IBaseFontElement_put_color(This,v)	\
    (This)->lpVtbl -> put_color(This,v)

#define IBaseFontElement_get_color(This,p)	\
    (This)->lpVtbl -> get_color(This,p)

#define IBaseFontElement_put_face(This,v)	\
    (This)->lpVtbl -> put_face(This,v)

#define IBaseFontElement_get_face(This,p)	\
    (This)->lpVtbl -> get_face(This,p)

#define IBaseFontElement_put_size(This,v)	\
    (This)->lpVtbl -> put_size(This,v)

#define IBaseFontElement_get_size(This,p)	\
    (This)->lpVtbl -> get_size(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBaseFontElement_put_color_Proxy( 
    IBaseFontElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBaseFontElement_put_color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBaseFontElement_get_color_Proxy( 
    IBaseFontElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBaseFontElement_get_color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBaseFontElement_put_face_Proxy( 
    IBaseFontElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IBaseFontElement_put_face_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBaseFontElement_get_face_Proxy( 
    IBaseFontElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IBaseFontElement_get_face_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IBaseFontElement_put_size_Proxy( 
    IBaseFontElement __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IBaseFontElement_put_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IBaseFontElement_get_size_Proxy( 
    IBaseFontElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IBaseFontElement_get_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBaseFontElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_BaseFontElement;

class BaseFontElement;
#endif

#ifndef __IUnknownElement_INTERFACE_DEFINED__
#define __IUnknownElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IUnknownElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IUnknownElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IUnknownElement : public IElement
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IUnknownElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUnknownElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUnknownElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUnknownElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IUnknownElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IUnknownElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IUnknownElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IUnknownElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IUnknownElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IUnknownElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IUnknownElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IUnknownElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IUnknownElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IUnknownElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IUnknownElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IUnknownElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IUnknownElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        END_INTERFACE
    } IUnknownElementVtbl;

    interface IUnknownElement
    {
        CONST_VTBL struct IUnknownElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnknownElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnknownElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnknownElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnknownElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IUnknownElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IUnknownElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IUnknownElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IUnknownElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IUnknownElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IUnknownElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IUnknownElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IUnknownElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IUnknownElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IUnknownElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IUnknownElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IUnknownElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUnknownElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_UnknownElement;

class UnknownElement;
#endif

#ifndef __IPhraseElement_INTERFACE_DEFINED__
#define __IPhraseElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPhraseElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IPhraseElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPhraseElement : public IElement
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPhraseElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPhraseElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPhraseElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPhraseElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPhraseElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPhraseElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPhraseElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPhraseElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            IPhraseElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IPhraseElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IPhraseElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IPhraseElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IPhraseElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            IPhraseElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IPhraseElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            IPhraseElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            IPhraseElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        END_INTERFACE
    } IPhraseElementVtbl;

    interface IPhraseElement
    {
        CONST_VTBL struct IPhraseElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhraseElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPhraseElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPhraseElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPhraseElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPhraseElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPhraseElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPhraseElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPhraseElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define IPhraseElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define IPhraseElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define IPhraseElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define IPhraseElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IPhraseElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define IPhraseElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define IPhraseElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define IPhraseElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhraseElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_PhraseElement;

class PhraseElement;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_BlockElement;

class BlockElement;
#endif

#ifndef __ICommentElement_INTERFACE_DEFINED__
#define __ICommentElement_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICommentElement
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ICommentElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICommentElement : public IElement
    {
    public:
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_atomic( 
            /* [in] */ long v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_atomic( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommentElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICommentElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICommentElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICommentElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICommentElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICommentElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICommentElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICommentElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ICommentElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ICommentElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ICommentElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ICommentElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ICommentElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ICommentElement __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ICommentElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ICommentElement __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ICommentElement __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            ICommentElement __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            ICommentElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_atomic )( 
            ICommentElement __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_atomic )( 
            ICommentElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        END_INTERFACE
    } ICommentElementVtbl;

    interface ICommentElement
    {
        CONST_VTBL struct ICommentElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommentElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICommentElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICommentElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICommentElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICommentElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICommentElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICommentElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICommentElement_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ICommentElement_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ICommentElement_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ICommentElement_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ICommentElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ICommentElement_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ICommentElement_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ICommentElement_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ICommentElement_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ICommentElement_put_text(This,v)	\
    (This)->lpVtbl -> put_text(This,v)

#define ICommentElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define ICommentElement_put_atomic(This,v)	\
    (This)->lpVtbl -> put_atomic(This,v)

#define ICommentElement_get_atomic(This,p)	\
    (This)->lpVtbl -> get_atomic(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ICommentElement_put_text_Proxy( 
    ICommentElement __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ICommentElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ICommentElement_get_text_Proxy( 
    ICommentElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ICommentElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE ICommentElement_put_atomic_Proxy( 
    ICommentElement __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ICommentElement_put_atomic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE ICommentElement_get_atomic_Proxy( 
    ICommentElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ICommentElement_get_atomic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICommentElement_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CommentElement;

class CommentElement;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ListElement;

class ListElement;
#endif

#ifndef __DocumentEvents_DISPINTERFACE_DEFINED__
#define __DocumentEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: DocumentEvents
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][hidden] */ 



EXTERN_C const IID DIID_DocumentEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DocumentEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DocumentEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DocumentEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DocumentEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DocumentEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DocumentEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DocumentEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DocumentEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DocumentEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DocumentEventsVtbl;

    interface DocumentEvents
    {
        CONST_VTBL struct DocumentEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DocumentEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DocumentEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DocumentEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DocumentEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DocumentEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DocumentEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DocumentEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DocumentEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IDocument_INTERFACE_DEFINED__
#define __IDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDocument
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_IDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDocument : public IDispatch
    {
    public:
        virtual /* [source][id][propget] */ HRESULT STDMETHODCALLTYPE get_body( 
            /* [out][retval] */ IBodyElement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_activeElement( 
            /* [out][retval] */ VARIANT __RPC_FAR *p) = 0;
        
        virtual /* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE put_zoom( 
            /* [in] */ short v) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_zoom( 
            /* [out][retval] */ short __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_all( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_images( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_applets( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_links( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_forms( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_anchors( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE put_title( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_scripts( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_designMode( 
            /* [in] */ fmMode v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_designMode( 
            /* [out][retval] */ fmMode __RPC_FAR *p) = 0;
        
        virtual /* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE put_defaultUnit( 
            /* [in] */ htmlDocUnits v) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_defaultUnit( 
            /* [out][retval] */ htmlDocUnits __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_selection( 
            /* [out][retval] */ ISelectionObject __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ htmlReadyState __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_frames( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_embeds( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_plugins( 
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_aLinkColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_aLinkColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_bgColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_bgColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_fgColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_fgColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_linkColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_linkColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_vLinkColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_vLinkColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE rangeFromText( 
            /* [in] */ BSTR String,
            /* [in][defaultvalue] */ long count,
            /* [in][defaultvalue] */ long Flags,
            /* [in][optional] */ VARIANT Range,
            /* [out][retval] */ VARIANT __RPC_FAR *pdisp) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE rangeFromElement( 
            /* [in] */ IElement __RPC_FAR *Element,
            /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *foundRange) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE undoAction( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE redoAction( void) = 0;
        
        virtual /* [id] */ BOOL STDMETHODCALLTYPE executeCommand( 
            /* [in] */ int comandID,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [id] */ VARIANT STDMETHODCALLTYPE queryCommandStatus( 
            /* [in] */ int comandID) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE cancelBubble( void) = 0;
        
        virtual /* [id][vararg] */ void STDMETHODCALLTYPE write( 
            /* [in] */ SAFEARRAY __RPC_FAR * psarray) = 0;
        
        virtual /* [id][vararg] */ void STDMETHODCALLTYPE writeln( 
            /* [in] */ SAFEARRAY __RPC_FAR * psarray) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE showModalDialog( 
            /* [in] */ BSTR dialog,
            /* [in] */ VARIANT varArgs,
            /* [out][retval] */ VARIANT __RPC_FAR *ret) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [source][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_body )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IBodyElement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_activeElement )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *p);
        
        /* [bindable][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_zoom )( 
            IDocument __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_zoom )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_all )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_images )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_applets )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_links )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_forms )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_anchors )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IDocument __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_scripts )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_designMode )( 
            IDocument __RPC_FAR * This,
            /* [in] */ fmMode v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_designMode )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ fmMode __RPC_FAR *p);
        
        /* [bindable][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_defaultUnit )( 
            IDocument __RPC_FAR * This,
            /* [in] */ htmlDocUnits v);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_defaultUnit )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ htmlDocUnits __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_selection )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ ISelectionObject __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ htmlReadyState __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_frames )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_embeds )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_plugins )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_aLinkColor )( 
            IDocument __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_aLinkColor )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bgColor )( 
            IDocument __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bgColor )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fgColor )( 
            IDocument __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fgColor )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_linkColor )( 
            IDocument __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_linkColor )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vLinkColor )( 
            IDocument __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vLinkColor )( 
            IDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *rangeFromText )( 
            IDocument __RPC_FAR * This,
            /* [in] */ BSTR String,
            /* [in][defaultvalue] */ long count,
            /* [in][defaultvalue] */ long Flags,
            /* [in][optional] */ VARIANT Range,
            /* [out][retval] */ VARIANT __RPC_FAR *pdisp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *rangeFromElement )( 
            IDocument __RPC_FAR * This,
            /* [in] */ IElement __RPC_FAR *Element,
            /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *foundRange);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *undoAction )( 
            IDocument __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *redoAction )( 
            IDocument __RPC_FAR * This);
        
        /* [id] */ BOOL ( STDMETHODCALLTYPE __RPC_FAR *executeCommand )( 
            IDocument __RPC_FAR * This,
            /* [in] */ int comandID,
            /* [in] */ VARIANT value);
        
        /* [id] */ VARIANT ( STDMETHODCALLTYPE __RPC_FAR *queryCommandStatus )( 
            IDocument __RPC_FAR * This,
            /* [in] */ int comandID);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *cancelBubble )( 
            IDocument __RPC_FAR * This);
        
        /* [id][vararg] */ void ( STDMETHODCALLTYPE __RPC_FAR *write )( 
            IDocument __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * psarray);
        
        /* [id][vararg] */ void ( STDMETHODCALLTYPE __RPC_FAR *writeln )( 
            IDocument __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * psarray);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *showModalDialog )( 
            IDocument __RPC_FAR * This,
            /* [in] */ BSTR dialog,
            /* [in] */ VARIANT varArgs,
            /* [out][retval] */ VARIANT __RPC_FAR *ret);
        
        END_INTERFACE
    } IDocumentVtbl;

    interface IDocument
    {
        CONST_VTBL struct IDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDocument_get_body(This,p)	\
    (This)->lpVtbl -> get_body(This,p)

#define IDocument_get_activeElement(This,p)	\
    (This)->lpVtbl -> get_activeElement(This,p)

#define IDocument_put_zoom(This,v)	\
    (This)->lpVtbl -> put_zoom(This,v)

#define IDocument_get_zoom(This,p)	\
    (This)->lpVtbl -> get_zoom(This,p)

#define IDocument_get_all(This,p)	\
    (This)->lpVtbl -> get_all(This,p)

#define IDocument_get_images(This,p)	\
    (This)->lpVtbl -> get_images(This,p)

#define IDocument_get_applets(This,p)	\
    (This)->lpVtbl -> get_applets(This,p)

#define IDocument_get_links(This,p)	\
    (This)->lpVtbl -> get_links(This,p)

#define IDocument_get_forms(This,p)	\
    (This)->lpVtbl -> get_forms(This,p)

#define IDocument_get_anchors(This,p)	\
    (This)->lpVtbl -> get_anchors(This,p)

#define IDocument_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IDocument_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IDocument_get_scripts(This,p)	\
    (This)->lpVtbl -> get_scripts(This,p)

#define IDocument_put_designMode(This,v)	\
    (This)->lpVtbl -> put_designMode(This,v)

#define IDocument_get_designMode(This,p)	\
    (This)->lpVtbl -> get_designMode(This,p)

#define IDocument_put_defaultUnit(This,v)	\
    (This)->lpVtbl -> put_defaultUnit(This,v)

#define IDocument_get_defaultUnit(This,p)	\
    (This)->lpVtbl -> get_defaultUnit(This,p)

#define IDocument_get_selection(This,p)	\
    (This)->lpVtbl -> get_selection(This,p)

#define IDocument_get_readyState(This,p)	\
    (This)->lpVtbl -> get_readyState(This,p)

#define IDocument_get_frames(This,p)	\
    (This)->lpVtbl -> get_frames(This,p)

#define IDocument_get_embeds(This,p)	\
    (This)->lpVtbl -> get_embeds(This,p)

#define IDocument_get_plugins(This,p)	\
    (This)->lpVtbl -> get_plugins(This,p)

#define IDocument_put_aLinkColor(This,v)	\
    (This)->lpVtbl -> put_aLinkColor(This,v)

#define IDocument_get_aLinkColor(This,p)	\
    (This)->lpVtbl -> get_aLinkColor(This,p)

#define IDocument_put_bgColor(This,v)	\
    (This)->lpVtbl -> put_bgColor(This,v)

#define IDocument_get_bgColor(This,p)	\
    (This)->lpVtbl -> get_bgColor(This,p)

#define IDocument_put_fgColor(This,v)	\
    (This)->lpVtbl -> put_fgColor(This,v)

#define IDocument_get_fgColor(This,p)	\
    (This)->lpVtbl -> get_fgColor(This,p)

#define IDocument_put_linkColor(This,v)	\
    (This)->lpVtbl -> put_linkColor(This,v)

#define IDocument_get_linkColor(This,p)	\
    (This)->lpVtbl -> get_linkColor(This,p)

#define IDocument_put_vLinkColor(This,v)	\
    (This)->lpVtbl -> put_vLinkColor(This,v)

#define IDocument_get_vLinkColor(This,p)	\
    (This)->lpVtbl -> get_vLinkColor(This,p)

#define IDocument_rangeFromText(This,String,count,Flags,Range,pdisp)	\
    (This)->lpVtbl -> rangeFromText(This,String,count,Flags,Range,pdisp)

#define IDocument_rangeFromElement(This,Element,foundRange)	\
    (This)->lpVtbl -> rangeFromElement(This,Element,foundRange)

#define IDocument_undoAction(This)	\
    (This)->lpVtbl -> undoAction(This)

#define IDocument_redoAction(This)	\
    (This)->lpVtbl -> redoAction(This)

#define IDocument_executeCommand(This,comandID,value)	\
    (This)->lpVtbl -> executeCommand(This,comandID,value)

#define IDocument_queryCommandStatus(This,comandID)	\
    (This)->lpVtbl -> queryCommandStatus(This,comandID)

#define IDocument_cancelBubble(This)	\
    (This)->lpVtbl -> cancelBubble(This)

#define IDocument_write(This,psarray)	\
    (This)->lpVtbl -> write(This,psarray)

#define IDocument_writeln(This,psarray)	\
    (This)->lpVtbl -> writeln(This,psarray)

#define IDocument_showModalDialog(This,dialog,varArgs,ret)	\
    (This)->lpVtbl -> showModalDialog(This,dialog,varArgs,ret)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [source][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_body_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IBodyElement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_activeElement_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *p);


void __RPC_STUB IDocument_get_activeElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_zoom_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ short v);


void __RPC_STUB IDocument_put_zoom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_zoom_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ short __RPC_FAR *p);


void __RPC_STUB IDocument_get_zoom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_all_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_all_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_images_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_images_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_applets_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_applets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_links_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_links_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_forms_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_forms_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_anchors_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_anchors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_title_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IDocument_put_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_title_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IDocument_get_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_scripts_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_scripts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_designMode_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ fmMode v);


void __RPC_STUB IDocument_put_designMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_designMode_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ fmMode __RPC_FAR *p);


void __RPC_STUB IDocument_get_designMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_defaultUnit_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ htmlDocUnits v);


void __RPC_STUB IDocument_put_defaultUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_defaultUnit_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ htmlDocUnits __RPC_FAR *p);


void __RPC_STUB IDocument_get_defaultUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_selection_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ ISelectionObject __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_selection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_readyState_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ htmlReadyState __RPC_FAR *p);


void __RPC_STUB IDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_frames_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_frames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_embeds_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_embeds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_plugins_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ IElementCollection __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IDocument_get_plugins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_aLinkColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IDocument_put_aLinkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_aLinkColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IDocument_get_aLinkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_bgColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IDocument_put_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_bgColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IDocument_get_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_fgColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IDocument_put_fgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_fgColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IDocument_get_fgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_linkColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IDocument_put_linkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_linkColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IDocument_get_linkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IDocument_put_vLinkColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IDocument_put_vLinkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IDocument_get_vLinkColor_Proxy( 
    IDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IDocument_get_vLinkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDocument_rangeFromText_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ BSTR String,
    /* [in][defaultvalue] */ long count,
    /* [in][defaultvalue] */ long Flags,
    /* [in][optional] */ VARIANT Range,
    /* [out][retval] */ VARIANT __RPC_FAR *pdisp);


void __RPC_STUB IDocument_rangeFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDocument_rangeFromElement_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ IElement __RPC_FAR *Element,
    /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *foundRange);


void __RPC_STUB IDocument_rangeFromElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDocument_undoAction_Proxy( 
    IDocument __RPC_FAR * This);


void __RPC_STUB IDocument_undoAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDocument_redoAction_Proxy( 
    IDocument __RPC_FAR * This);


void __RPC_STUB IDocument_redoAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ BOOL STDMETHODCALLTYPE IDocument_executeCommand_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ int comandID,
    /* [in] */ VARIANT value);


void __RPC_STUB IDocument_executeCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ VARIANT STDMETHODCALLTYPE IDocument_queryCommandStatus_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ int comandID);


void __RPC_STUB IDocument_queryCommandStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IDocument_cancelBubble_Proxy( 
    IDocument __RPC_FAR * This);


void __RPC_STUB IDocument_cancelBubble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][vararg] */ void STDMETHODCALLTYPE IDocument_write_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * psarray);


void __RPC_STUB IDocument_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][vararg] */ void STDMETHODCALLTYPE IDocument_writeln_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * psarray);


void __RPC_STUB IDocument_writeln_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDocument_showModalDialog_Proxy( 
    IDocument __RPC_FAR * This,
    /* [in] */ BSTR dialog,
    /* [in] */ VARIANT varArgs,
    /* [out][retval] */ VARIANT __RPC_FAR *ret);


void __RPC_STUB IDocument_showModalDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDocument_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_HTMLDocument;

class HTMLDocument;
#endif

#ifndef __ITable_INTERFACE_DEFINED__
#define __ITable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITable
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITable : public IControlElement
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_cols( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_cols( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_border( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_frame( 
            /* [in] */ htmlFrame v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_frame( 
            /* [out][retval] */ htmlFrame __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_rules( 
            /* [in] */ htmlRules v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_rules( 
            /* [out][retval] */ htmlRules __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_cellSpacing( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_cellPadding( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_background( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_background( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bgColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bgColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColorLight( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColorLight( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColorDark( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColorDark( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlControlAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlControlAlign __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE refresh( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_rows( 
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITable __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITable __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITable __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITable __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITable __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITable __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            ITable __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            ITable __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            ITable __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            ITable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            ITable __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_cols )( 
            ITable __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cols )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_border )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_frame )( 
            ITable __RPC_FAR * This,
            /* [in] */ htmlFrame v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_frame )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ htmlFrame __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_rules )( 
            ITable __RPC_FAR * This,
            /* [in] */ htmlRules v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rules )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ htmlRules __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cellSpacing )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cellPadding )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_background )( 
            ITable __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_background )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bgColor )( 
            ITable __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bgColor )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColor )( 
            ITable __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColor )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColorLight )( 
            ITable __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColorLight )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColorDark )( 
            ITable __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColorDark )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            ITable __RPC_FAR * This,
            /* [in] */ htmlControlAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ htmlControlAlign __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *refresh )( 
            ITable __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rows )( 
            ITable __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p);
        
        END_INTERFACE
    } ITableVtbl;

    interface ITable
    {
        CONST_VTBL struct ITableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITable_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITable_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITable_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITable_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITable_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITable_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITable_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITable_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITable_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITable_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITable_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITable_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITable_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ITable_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define ITable_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define ITable_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define ITable_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define ITable_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define ITable_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define ITable_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define ITable_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define ITable_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define ITable_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define ITable_put_cols(This,v)	\
    (This)->lpVtbl -> put_cols(This,v)

#define ITable_get_cols(This,p)	\
    (This)->lpVtbl -> get_cols(This,p)

#define ITable_get_border(This,p)	\
    (This)->lpVtbl -> get_border(This,p)

#define ITable_put_frame(This,v)	\
    (This)->lpVtbl -> put_frame(This,v)

#define ITable_get_frame(This,p)	\
    (This)->lpVtbl -> get_frame(This,p)

#define ITable_put_rules(This,v)	\
    (This)->lpVtbl -> put_rules(This,v)

#define ITable_get_rules(This,p)	\
    (This)->lpVtbl -> get_rules(This,p)

#define ITable_get_cellSpacing(This,p)	\
    (This)->lpVtbl -> get_cellSpacing(This,p)

#define ITable_get_cellPadding(This,p)	\
    (This)->lpVtbl -> get_cellPadding(This,p)

#define ITable_put_background(This,v)	\
    (This)->lpVtbl -> put_background(This,v)

#define ITable_get_background(This,p)	\
    (This)->lpVtbl -> get_background(This,p)

#define ITable_put_bgColor(This,v)	\
    (This)->lpVtbl -> put_bgColor(This,v)

#define ITable_get_bgColor(This,p)	\
    (This)->lpVtbl -> get_bgColor(This,p)

#define ITable_put_borderColor(This,v)	\
    (This)->lpVtbl -> put_borderColor(This,v)

#define ITable_get_borderColor(This,p)	\
    (This)->lpVtbl -> get_borderColor(This,p)

#define ITable_put_borderColorLight(This,v)	\
    (This)->lpVtbl -> put_borderColorLight(This,v)

#define ITable_get_borderColorLight(This,p)	\
    (This)->lpVtbl -> get_borderColorLight(This,p)

#define ITable_put_borderColorDark(This,v)	\
    (This)->lpVtbl -> put_borderColorDark(This,v)

#define ITable_get_borderColorDark(This,p)	\
    (This)->lpVtbl -> get_borderColorDark(This,p)

#define ITable_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define ITable_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define ITable_refresh(This)	\
    (This)->lpVtbl -> refresh(This)

#define ITable_get_rows(This,p)	\
    (This)->lpVtbl -> get_rows(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_cols_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITable_put_cols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_cols_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITable_get_cols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_border_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB ITable_get_border_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_frame_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ htmlFrame v);


void __RPC_STUB ITable_put_frame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_frame_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ htmlFrame __RPC_FAR *p);


void __RPC_STUB ITable_get_frame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_rules_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ htmlRules v);


void __RPC_STUB ITable_put_rules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_rules_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ htmlRules __RPC_FAR *p);


void __RPC_STUB ITable_get_rules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_cellSpacing_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB ITable_get_cellSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_cellPadding_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB ITable_get_cellPadding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_background_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITable_put_background_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_background_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITable_get_background_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_bgColor_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITable_put_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_bgColor_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITable_get_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_borderColor_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITable_put_borderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_borderColor_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITable_get_borderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_borderColorLight_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITable_put_borderColorLight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_borderColorLight_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITable_get_borderColorLight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_borderColorDark_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITable_put_borderColorDark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_borderColorDark_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITable_get_borderColorDark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITable_put_align_Proxy( 
    ITable __RPC_FAR * This,
    /* [in] */ htmlControlAlign v);


void __RPC_STUB ITable_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_align_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ htmlControlAlign __RPC_FAR *p);


void __RPC_STUB ITable_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITable_refresh_Proxy( 
    ITable __RPC_FAR * This);


void __RPC_STUB ITable_refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITable_get_rows_Proxy( 
    ITable __RPC_FAR * This,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB ITable_get_rows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITable_INTERFACE_DEFINED__ */


#ifndef __ITableCol_INTERFACE_DEFINED__
#define __ITableCol_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITableCol
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITableCol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITableCol : public IElement
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_span( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_span( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_width( 
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlCellAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlCellAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_vAlign( 
            /* [in] */ htmlCellVAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_vAlign( 
            /* [out][retval] */ htmlCellVAlign __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableColVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITableCol __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITableCol __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITableCol __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITableCol __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_span )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_span )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ htmlCellAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ htmlCellAlign __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vAlign )( 
            ITableCol __RPC_FAR * This,
            /* [in] */ htmlCellVAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vAlign )( 
            ITableCol __RPC_FAR * This,
            /* [out][retval] */ htmlCellVAlign __RPC_FAR *p);
        
        END_INTERFACE
    } ITableColVtbl;

    interface ITableCol
    {
        CONST_VTBL struct ITableColVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableCol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITableCol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITableCol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITableCol_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITableCol_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITableCol_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITableCol_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITableCol_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITableCol_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITableCol_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITableCol_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITableCol_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITableCol_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITableCol_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITableCol_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITableCol_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ITableCol_put_span(This,v)	\
    (This)->lpVtbl -> put_span(This,v)

#define ITableCol_get_span(This,p)	\
    (This)->lpVtbl -> get_span(This,p)

#define ITableCol_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)

#define ITableCol_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define ITableCol_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define ITableCol_put_vAlign(This,v)	\
    (This)->lpVtbl -> put_vAlign(This,v)

#define ITableCol_get_vAlign(This,p)	\
    (This)->lpVtbl -> get_vAlign(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCol_put_span_Proxy( 
    ITableCol __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITableCol_put_span_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCol_get_span_Proxy( 
    ITableCol __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITableCol_get_span_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCol_get_width_Proxy( 
    ITableCol __RPC_FAR * This,
    /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB ITableCol_get_width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCol_put_align_Proxy( 
    ITableCol __RPC_FAR * This,
    /* [in] */ htmlCellAlign v);


void __RPC_STUB ITableCol_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCol_get_align_Proxy( 
    ITableCol __RPC_FAR * This,
    /* [out][retval] */ htmlCellAlign __RPC_FAR *p);


void __RPC_STUB ITableCol_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCol_put_vAlign_Proxy( 
    ITableCol __RPC_FAR * This,
    /* [in] */ htmlCellVAlign v);


void __RPC_STUB ITableCol_put_vAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCol_get_vAlign_Proxy( 
    ITableCol __RPC_FAR * This,
    /* [out][retval] */ htmlCellVAlign __RPC_FAR *p);


void __RPC_STUB ITableCol_get_vAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITableCol_INTERFACE_DEFINED__ */


#ifndef __ITableSection_INTERFACE_DEFINED__
#define __ITableSection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITableSection
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITableSection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITableSection : public IElement
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlCellAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlCellAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_vAlign( 
            /* [in] */ htmlCellVAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_vAlign( 
            /* [out][retval] */ htmlCellVAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bgColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bgColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableSectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITableSection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITableSection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITableSection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITableSection __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ htmlCellAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ htmlCellAlign __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vAlign )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ htmlCellVAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vAlign )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ htmlCellVAlign __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bgColor )( 
            ITableSection __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bgColor )( 
            ITableSection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } ITableSectionVtbl;

    interface ITableSection
    {
        CONST_VTBL struct ITableSectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableSection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITableSection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITableSection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITableSection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITableSection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITableSection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITableSection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITableSection_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITableSection_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITableSection_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITableSection_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITableSection_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITableSection_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITableSection_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITableSection_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITableSection_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ITableSection_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define ITableSection_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define ITableSection_put_vAlign(This,v)	\
    (This)->lpVtbl -> put_vAlign(This,v)

#define ITableSection_get_vAlign(This,p)	\
    (This)->lpVtbl -> get_vAlign(This,p)

#define ITableSection_put_bgColor(This,v)	\
    (This)->lpVtbl -> put_bgColor(This,v)

#define ITableSection_get_bgColor(This,p)	\
    (This)->lpVtbl -> get_bgColor(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableSection_put_align_Proxy( 
    ITableSection __RPC_FAR * This,
    /* [in] */ htmlCellAlign v);


void __RPC_STUB ITableSection_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableSection_get_align_Proxy( 
    ITableSection __RPC_FAR * This,
    /* [out][retval] */ htmlCellAlign __RPC_FAR *p);


void __RPC_STUB ITableSection_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableSection_put_vAlign_Proxy( 
    ITableSection __RPC_FAR * This,
    /* [in] */ htmlCellVAlign v);


void __RPC_STUB ITableSection_put_vAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableSection_get_vAlign_Proxy( 
    ITableSection __RPC_FAR * This,
    /* [out][retval] */ htmlCellVAlign __RPC_FAR *p);


void __RPC_STUB ITableSection_get_vAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableSection_put_bgColor_Proxy( 
    ITableSection __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableSection_put_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableSection_get_bgColor_Proxy( 
    ITableSection __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableSection_get_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITableSection_INTERFACE_DEFINED__ */


#ifndef __ITableRow_INTERFACE_DEFINED__
#define __ITableRow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITableRow
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITableRow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITableRow : public IElement
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlCellAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlCellAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_vAlign( 
            /* [in] */ htmlCellVAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_vAlign( 
            /* [out][retval] */ htmlCellVAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bgColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bgColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColorLight( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColorLight( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColorDark( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColorDark( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_cells( 
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableRowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITableRow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITableRow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITableRow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITableRow __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ htmlCellAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ htmlCellAlign __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vAlign )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ htmlCellVAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vAlign )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ htmlCellVAlign __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bgColor )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bgColor )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColor )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColor )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColorLight )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColorLight )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColorDark )( 
            ITableRow __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColorDark )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cells )( 
            ITableRow __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p);
        
        END_INTERFACE
    } ITableRowVtbl;

    interface ITableRow
    {
        CONST_VTBL struct ITableRowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableRow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITableRow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITableRow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITableRow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITableRow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITableRow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITableRow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITableRow_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITableRow_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITableRow_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITableRow_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITableRow_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITableRow_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITableRow_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITableRow_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITableRow_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ITableRow_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define ITableRow_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define ITableRow_put_vAlign(This,v)	\
    (This)->lpVtbl -> put_vAlign(This,v)

#define ITableRow_get_vAlign(This,p)	\
    (This)->lpVtbl -> get_vAlign(This,p)

#define ITableRow_put_bgColor(This,v)	\
    (This)->lpVtbl -> put_bgColor(This,v)

#define ITableRow_get_bgColor(This,p)	\
    (This)->lpVtbl -> get_bgColor(This,p)

#define ITableRow_put_borderColor(This,v)	\
    (This)->lpVtbl -> put_borderColor(This,v)

#define ITableRow_get_borderColor(This,p)	\
    (This)->lpVtbl -> get_borderColor(This,p)

#define ITableRow_put_borderColorLight(This,v)	\
    (This)->lpVtbl -> put_borderColorLight(This,v)

#define ITableRow_get_borderColorLight(This,p)	\
    (This)->lpVtbl -> get_borderColorLight(This,p)

#define ITableRow_put_borderColorDark(This,v)	\
    (This)->lpVtbl -> put_borderColorDark(This,v)

#define ITableRow_get_borderColorDark(This,p)	\
    (This)->lpVtbl -> get_borderColorDark(This,p)

#define ITableRow_get_cells(This,p)	\
    (This)->lpVtbl -> get_cells(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableRow_put_align_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [in] */ htmlCellAlign v);


void __RPC_STUB ITableRow_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableRow_get_align_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [out][retval] */ htmlCellAlign __RPC_FAR *p);


void __RPC_STUB ITableRow_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableRow_put_vAlign_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [in] */ htmlCellVAlign v);


void __RPC_STUB ITableRow_put_vAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableRow_get_vAlign_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [out][retval] */ htmlCellVAlign __RPC_FAR *p);


void __RPC_STUB ITableRow_get_vAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableRow_put_bgColor_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableRow_put_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableRow_get_bgColor_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableRow_get_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableRow_put_borderColor_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableRow_put_borderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableRow_get_borderColor_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableRow_get_borderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableRow_put_borderColorLight_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableRow_put_borderColorLight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableRow_get_borderColorLight_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableRow_get_borderColorLight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableRow_put_borderColorDark_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableRow_put_borderColorDark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableRow_get_borderColorDark_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableRow_get_borderColorDark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableRow_get_cells_Proxy( 
    ITableRow __RPC_FAR * This,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB ITableRow_get_cells_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITableRow_INTERFACE_DEFINED__ */


#ifndef __ITableCell_INTERFACE_DEFINED__
#define __ITableCell_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITableCell
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITableCell;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITableCell : public ITxtEdit
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_rowSpan( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_rowSpan( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_colSpan( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_colSpan( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlCellAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlCellAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_vAlign( 
            /* [in] */ htmlCellVAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_vAlign( 
            /* [out][retval] */ htmlCellVAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bgColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bgColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_noWrap( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_noWrap( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_background( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_background( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColor( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColor( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColorLight( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColorLight( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderColorDark( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderColorDark( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableCellVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITableCell __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITableCell __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITableCell __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentElement )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ IElement __RPC_FAR *__RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_style )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ IStyle __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *scrollIntoView )( 
            ITableCell __RPC_FAR * This,
            /* [in][optional] */ VARIANT_BOOL Start);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [hidden][bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_visible )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [hidden][bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_visible )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tabIndex )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ short v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tabIndex )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ short __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setFocus )( 
            ITableCell __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *zOrder )( 
            ITableCell __RPC_FAR * This,
            /* [in][optional][defaultvalue] */ fmZOrder zPosition);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ IUnitMeasurement __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createTextRange )( 
            ITableCell __RPC_FAR * This,
            /* [in][defaultvalue] */ long begin,
            /* [in][defaultvalue] */ long end,
            /* [out][retval] */ ITxtRange __RPC_FAR *__RPC_FAR *range);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createControlRange )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *range);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_rowSpan )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rowSpan )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_colSpan )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_colSpan )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_align )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ htmlCellAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_align )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ htmlCellAlign __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_vAlign )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ htmlCellVAlign v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_vAlign )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ htmlCellVAlign __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bgColor )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bgColor )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_noWrap )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_noWrap )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_background )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_background )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColor )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColor )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColorLight )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColorLight )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_borderColorDark )( 
            ITableCell __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_borderColorDark )( 
            ITableCell __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } ITableCellVtbl;

    interface ITableCell
    {
        CONST_VTBL struct ITableCellVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableCell_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITableCell_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITableCell_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITableCell_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITableCell_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITableCell_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITableCell_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITableCell_put_Class(This,v)	\
    (This)->lpVtbl -> put_Class(This,v)

#define ITableCell_get_Class(This,p)	\
    (This)->lpVtbl -> get_Class(This,p)

#define ITableCell_put_id(This,v)	\
    (This)->lpVtbl -> put_id(This,v)

#define ITableCell_get_id(This,p)	\
    (This)->lpVtbl -> get_id(This,p)

#define ITableCell_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define ITableCell_get_parentElement(This,p)	\
    (This)->lpVtbl -> get_parentElement(This,p)

#define ITableCell_get_count(This,p)	\
    (This)->lpVtbl -> get_count(This,p)

#define ITableCell_get_style(This,p)	\
    (This)->lpVtbl -> get_style(This,p)

#define ITableCell_scrollIntoView(This,Start)	\
    (This)->lpVtbl -> scrollIntoView(This,Start)


#define ITableCell_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define ITableCell_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define ITableCell_put_visible(This,v)	\
    (This)->lpVtbl -> put_visible(This,v)

#define ITableCell_get_visible(This,p)	\
    (This)->lpVtbl -> get_visible(This,p)

#define ITableCell_put_tabIndex(This,v)	\
    (This)->lpVtbl -> put_tabIndex(This,v)

#define ITableCell_get_tabIndex(This,p)	\
    (This)->lpVtbl -> get_tabIndex(This,p)

#define ITableCell_setFocus(This)	\
    (This)->lpVtbl -> setFocus(This)

#define ITableCell_zOrder(This,zPosition)	\
    (This)->lpVtbl -> zOrder(This,zPosition)

#define ITableCell_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define ITableCell_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)


#define ITableCell_createTextRange(This,begin,end,range)	\
    (This)->lpVtbl -> createTextRange(This,begin,end,range)

#define ITableCell_createControlRange(This,range)	\
    (This)->lpVtbl -> createControlRange(This,range)


#define ITableCell_put_rowSpan(This,v)	\
    (This)->lpVtbl -> put_rowSpan(This,v)

#define ITableCell_get_rowSpan(This,p)	\
    (This)->lpVtbl -> get_rowSpan(This,p)

#define ITableCell_put_colSpan(This,v)	\
    (This)->lpVtbl -> put_colSpan(This,v)

#define ITableCell_get_colSpan(This,p)	\
    (This)->lpVtbl -> get_colSpan(This,p)

#define ITableCell_put_align(This,v)	\
    (This)->lpVtbl -> put_align(This,v)

#define ITableCell_get_align(This,p)	\
    (This)->lpVtbl -> get_align(This,p)

#define ITableCell_put_vAlign(This,v)	\
    (This)->lpVtbl -> put_vAlign(This,v)

#define ITableCell_get_vAlign(This,p)	\
    (This)->lpVtbl -> get_vAlign(This,p)

#define ITableCell_put_bgColor(This,v)	\
    (This)->lpVtbl -> put_bgColor(This,v)

#define ITableCell_get_bgColor(This,p)	\
    (This)->lpVtbl -> get_bgColor(This,p)

#define ITableCell_put_noWrap(This,v)	\
    (This)->lpVtbl -> put_noWrap(This,v)

#define ITableCell_get_noWrap(This,p)	\
    (This)->lpVtbl -> get_noWrap(This,p)

#define ITableCell_put_background(This,v)	\
    (This)->lpVtbl -> put_background(This,v)

#define ITableCell_get_background(This,p)	\
    (This)->lpVtbl -> get_background(This,p)

#define ITableCell_put_borderColor(This,v)	\
    (This)->lpVtbl -> put_borderColor(This,v)

#define ITableCell_get_borderColor(This,p)	\
    (This)->lpVtbl -> get_borderColor(This,p)

#define ITableCell_put_borderColorLight(This,v)	\
    (This)->lpVtbl -> put_borderColorLight(This,v)

#define ITableCell_get_borderColorLight(This,p)	\
    (This)->lpVtbl -> get_borderColorLight(This,p)

#define ITableCell_put_borderColorDark(This,v)	\
    (This)->lpVtbl -> put_borderColorDark(This,v)

#define ITableCell_get_borderColorDark(This,p)	\
    (This)->lpVtbl -> get_borderColorDark(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_rowSpan_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITableCell_put_rowSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_rowSpan_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITableCell_get_rowSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_colSpan_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITableCell_put_colSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_colSpan_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITableCell_get_colSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_align_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ htmlCellAlign v);


void __RPC_STUB ITableCell_put_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_align_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ htmlCellAlign __RPC_FAR *p);


void __RPC_STUB ITableCell_get_align_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_vAlign_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ htmlCellVAlign v);


void __RPC_STUB ITableCell_put_vAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_vAlign_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ htmlCellVAlign __RPC_FAR *p);


void __RPC_STUB ITableCell_get_vAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_bgColor_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableCell_put_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_bgColor_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableCell_get_bgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_noWrap_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITableCell_put_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_noWrap_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITableCell_get_noWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_background_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableCell_put_background_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_background_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableCell_get_background_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_borderColor_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableCell_put_borderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_borderColor_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableCell_get_borderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_borderColorLight_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableCell_put_borderColorLight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_borderColorLight_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableCell_get_borderColorLight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITableCell_put_borderColorDark_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITableCell_put_borderColorDark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITableCell_get_borderColorDark_Proxy( 
    ITableCell __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITableCell_get_borderColorDark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITableCell_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Table;

class Table;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TableCol;

class TableCol;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TableSection;

class TableSection;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TableRow;

class TableRow;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TableCell;

class TableCell;
#endif

#ifndef __ITableCaption_INTERFACE_DEFINED__
#define __ITableCaption_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITableCaption
 * at Fri Oct 25 18:49:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ITableCaption;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITableCaption : public ITxtEdit
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_align( 
            /* [in] */ htmlCaptionAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_align( 
            /* [out][retval] */ htmlCaptionAlign __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_vAlign( 
            /* [in] */ htmlCaptionVAlign v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_vAlign( 
            /* [out][retval] */ htmlCaptionVAlign __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableCaptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITableCaption __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITableCaption __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITableCaption __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITableCaption __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITableCaption __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITableCaption __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITableCaption __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Class )( 
            ITableCaption __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [bindable][di