000003, 0x014488, 0x014388, 0x56F000, 0x000B7E, 0x200003, 0x05A403, 0x014488, 0x014388, 0x014188, 0x014188, 0x21E71B, 0x56F000, 0x000B40, 0x0140C5, 0x000003, 0x0D1042, 0x00000D, 0x21E779, 0x014988, 0x21E779, 0x014188, 0x014188, 0x56F000, 0x000B40, 0x0140C5, 0x000003, 0x052402, 0x016F88, 0x014788, 0x0C1EC7, 0x557000, 0x000B70, 0x0C1E87, 0x21E479, 0x200048, 0x557000, 0x000B71, 0x56F000, 0x000B40, 0x200003, 0x052407, 0x20001B, 0x014188, 0x014188, 0x015088, 0x557000, 0x000B53, 0x56F000, 0x000B40, 0x200003, 0x05248C, 0x57F000, 0x000B51, 0x44F000, 0x000B53, 0x200048, 0x44F000, 0x000B9A, 0x46F400, 0x000008, 0x2000D0, 0x210E00, 0x200014, 0x547000, 0x000B52, 0x56F000, 0x000B53, 0x44F000, 0x000B9F, 0x200045, 0x057485, 0x44F41B, 0x155555, 0x56F000, 0x000B52, 0x0140C4, 0x00002F, 0x218500, 0x2000A8, 0x21AF00, 0x44F000, 0x000B71, 0x20004D, 0x05F458, 0x21A500, 0x44F400, 0x000006, 0x2000A0, 0x0C1D2E, 0x44F036, 0x000B52, 0x200040, 0x0140C4, 0x00002F, 0x21C700, 0x0140C8, 0x000001, 0x56F400, 0x000B68, 0x240000, 0x200040, 0x219000, 0x20F800, 0x06D810, 0x000002, 0x575800, 0x0140CC, 0x000001, 0x56F400, 0x000006, 0x200074, 0x200003, 0x05F405, 0x21D800, 0x06D810, 0x000002, 0x575800, 0x56F400, 0x000B68, 0x44F400, 0x000003, 0x200040, 0x219000, 0x56E000, 0x016F80, 0x566000, 0x56F400, 0x000B68, 0x240000, 0x200040, 0x219000, 0x70F000, 0x000B40, 0x56E800, 0x44F000, 0x000B71, 0x200044, 0x566800, 0x00000C, 0x44F400, 0x000001, 0x447000, 0x000B96, 0x00000C, 0x0D1080, 0x000023, 0x200003, 0x05A41B, 0x0D1080, 0xFFFDA2, 0x56F400, 0x000005, 0x44F000, 0x000B40, 0x200045, 0x05F417, 0x56F400, 0x000B68, 0x44F000, 0x000B40, 0x200040, 0x0140C0, 0x000001, 0x21D000, 0x56D000, 0x44D800, 0x200040, 0x44F000, 0x000B7A, 0x45F044, 0x0004A4, 0x200064, 0x566000, 0x050C05, 0x0D1080, 0x000158, 0x0D1080, 0xFFFD86, 0x00000C, 0x45F400, 0xFFFF90, 0x457000, 0x00049F, 0x0D1080, 0x00007C, 0x44F400, 0x000008, 0x447000, 0x00049E, 0x240000, 0x447000, 0x0004B5, 0x50F000, 0x00049E, 0x00000A, 0x507000, 0x00049E, 0x0D1080, 0x000087, 0x20000B, 0x059409, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x44F000, 0x00049F, 0x447000, 0x0004B6, 0x56F000, 0x0004B5, 0x200003, 0x05A40F, 0x56F400, 0x000010, 0x21C400, 0x567000, 0x0004A0, 0x56F000, 0x00049F, 0x567000, 0x0004A1, 0x200040, 0x200022, 0x567000, 0x00049F, 0x050C0E, 0x56F400, 0xFFFF10, 0x21C400, 0x567000, 0x0004A1, 0x56F000, 0x00049F, 0x567000, 0x0004A0, 0x200040, 0x200022, 0x567000, 0x00049F, 0x0D1080, 0x000043, 0x0D1080, 0x00005A, 0x20000B, 0x05940E, 0x44F000, 0x00049F, 0x447000, 0x0004A1, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x44F000, 0x00049F, 0x447000, 0x0004B6, 0x050C05, 0x44F000, 0x00049F, 0x447000, 0x0004A0, 0x56F000, 0x0004A0, 0x44F000, 0x0004A1, 0x21C644, 0x0140C5, 0x000001, 0x052408, 0x0D1080, 0x000128, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x050C1B, 0x200051, 0x200040, 0x200022, 0x200045, 0x057404, 0x208E00, 0x014180, 0x050C05, 0x200055, 0x059403, 0x20CE00, 0x014184, 0x547000, 0x00049F, 0x56F000, 0x00049E, 0x014184, 0x547000, 0x00049E, 0x057787, 0x56F000, 0x0004B5, 0x014185, 0x052403, 0x0D1080, 0x000109, 0x56F000, 0x0004B5, 0x00000C, 0x56F000, 0x00049F, 0x0140C0, 0x0000F0, 0x0C1C08, 0x218400, 0x2C0000, 0x0C1D08, 0x218600, 0x60F400, 0x000B73, 0x62F400, 0x000B79, 0x64F400, 0x000B74, 0x3C0500, 0x70F000, 0x000B97, 0x229500, 0x445800, 0x465A00, 0x06D810, 0x000002, 0x465D00, 0x00000C, 0x70F000, 0x000B40, 0x60F400, 0x000B68, 0x57E800, 0x21FA00, 0x56F000, 0x0004C0, 0x200003, 0x05A545, 0x56F400, 0x000001, 0x567000, 0x0004B7, 0x56F400, 0x000000, 0x44F000, 0x000B73, 0x200045, 0x05A404, 0x240000, 0x447000, 0x0004B7, 0x46F400, 0x000000, 0x60F400, 0x000B74, 0x44F000, 0x000B97, 0x06C410, 0x000008, 0x56D800, 0x200055, 0x05A404, 0x200013, 0x567000, 0x0004B7, 0x000000, 0x56F000, 0x000B7E, 0x200003, 0x05A408, 0x56F000, 0x000B79, 0x200055, 0x05A404, 0x200013, 0x567000, 0x0004B7, 0x300700, 0x0B70C4, 0x000CB2, 0x447000, 0x0004BF, 0x60F413, 0x0004A5, 0x061090, 0x000002, 0x565800, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000036, 0x56F400, 0x000B74, 0x22C400, 0x200040, 0x219000, 0x56F000, 0x000B73, 0x44E000, 0x014F84, 0x0C1D08, 0x200040, 0x0C1D04, 0x547000, 0x0004A2, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x250000, 0x47E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219100, 0x22C400, 0x46F400, 0x000032, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219200, 0x65F400, 0x000F1A, 0x667000, 0x000B41, 0x0D0486, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A417, 0x56F000, 0x000B73, 0x44F000, 0x000B79, 0x014F84, 0x0C1D08, 0x200040, 0x0C1D04, 0x547000, 0x0004A2, 0x250000, 0x47F400, 0x000007, 0x60F400, 0x000483, 0x61F400, 0x000B39, 0x62F400, 0x0004B8, 0x65F400, 0x000F1A, 0x0D0486, 0x60F400, 0x0004A6, 0x66F41B, 0x000CFB, 0x44D800, 0x47F413, 0xD55555, 0x20E800, 0x4EDEC6, 0x218413, 0x44D8DA, 0x20E800, 0x4EDEC6, 0x218400, 0xF0D8DA, 0x44D8DA, 0x47F413, 0xC00000, 0x20E800, 0x4EDEC6, 0x218400, 0x2000DA, 0xF0D800, 0x060A90, 0x000002, 0xF0D8DA, 0x2000DA, 0x0C1DAE, 0x567000, 0x000B7A, 0x050C02, 0x050C00, 0x44F01B, 0x000B7A, 0x234F00, 0x20004C, 0x21FA00, 0x20000B, 0x051402, 0x050C03, 0x0D1080, 0xFFFC33, 0x00000C, 0x60F41B, 0x000B7A, 0x576000, 0x60F400, 0x000B73, 0x62F400, 0x000B79, 0x64F400, 0x000B74, 0x70F000, 0x000B97, 0x229500, 0x576000, 0x576200, 0x06D810, 0x000002, 0x575D00, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000012, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219000, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x066210, 0x000002, 0x575800, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A406, 0x60F400, 0x000B39, 0x060790, 0x000002, 0x575800, 0x00000C, 0x44F000, 0x0004B6, 0x447000, 0x00049F, 0x0D1080, 0xFFFEF8, 0x050A0F, 0x00000C, 0x20001B, 0x015088, 0x015088, 0x014288, 0x014688, 0x014588, 0x014388, 0x014388, 0x56F000, 0x000B7D, 0x014185, 0x05A404, 0x014186, 0x05A402, 0x014288, 0x56F000, 0x000B7D, 0x014486, 0x05A402, 0x014288, 0x56F000, 0x000B7D, 0x014285, 0x052402, 0x014288, 0x014188, 0x014588, 0x014188, 0x56F000, 0x000B4C, 0x44F403, 0x000008, 0x05A402, 0x200048, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x577000, 0x000B51, 0x00000C, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000034, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219000, 0x56E000, 0x219203, 0x05A44B, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x56F400, 0x000B5C, 0x22C400, 0x200040, 0x219100, 0x70E100, 0x0B72D9, 0x000F12, 0x56F400, 0x000B91, 0x22C400, 0x200040, 0x219100, 0x72E100, 0x45D800, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0007B0, 0x0C1D2E, 0x200040, 0x219500, 0x455D00, 0x22C400, 0x46F400, 0x00001F, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219400, 0x4D5C00, 0x0D051E, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A413, 0x56F000, 0x000B8F, 0x200003, 0x05A40F, 0x60F400, 0x000483, 0x380600, 0x79F000, 0x000F13, 0x3A0200, 0x45D800, 0x65F400, 0x000B39, 0x455D00, 0x64F400, 0x00009B, 0x4D5C00, 0x0D051E, 0x00000C, 0x56F400, 0x000016, 0x57F400, 0x000001, 0x70F400, 0x000390, 0x390000, 0x60F400, 0x0000FA, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x00000C, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\AC3Dolby1.h ===
0xD01B40, 0x0002F2, 0x010172, 0xF7F511, 0x050C40, 0x040C37, 0x048AA7, 0x051884, 0x05B7B1, 0x066A4A, 0x0732AE, 0x081385, 0x090FCC, 0x0A2ADB, 0x0B6873, 0x0CCCCD, 0x0E5CA1, 0x101D3F, 0x12149A, 0x144961, 0x16C311, 0x198A13, 0x1CA7D7, 0x2026F3, 0x241347, 0x287A27, 0x2D6A86, 0x32F52D, 0x392CEE, 0x4026E7, 0x47FACD, 0x50C336, 0x5A9DF8, 0x65AC8C, 0x721483, 0x7FFFFF, 0x607000, 0x00062E, 0x20000B, 0x05A406, 0x44F400, 0x008002, 0x447000, 0x000604, 0x050C05, 0x44F400, 0x000002, 0x447000, 0x000604, 0x44F400, 0x00000A, 0x447000, 0x000600, 0x44F400, 0x00060A, 0x447000, 0x000601, 0x44F400, 0x000610, 0x447000, 0x000602, 0x44F400, 0x000616, 0x447000, 0x000603, 0x44F400, 0x00061C, 0x447000, 0x000605, 0x44F400, 0x000622, 0x447000, 0x000606, 0x44F400, 0x000628, 0x447000, 0x000607, 0x44F400, 0x000000, 0x447000, 0x000608, 0x44F400, 0x000100, 0x447000, 0x000609, 0x60F400, 0x00060A, 0x44F400, 0x000000, 0x445800, 0x44F400, 0x000100, 0x445800, 0x44F400, 0x000200, 0x445800, 0x44F400, 0x000300, 0x445800, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x446000, 0x60F400, 0x000610, 0x44F400, 0x000001, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x240000, 0x446000, 0x60F400, 0x000616, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x446000, 0x60F400, 0x00061C, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0x000500, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x60F400, 0x000622, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x60F400, 0x000628, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x62F013, 0x00062E, 0x021ADC, 0x44F400, 0x000001, 0x200045, 0x202941, 0x44F400, 0x00001F, 0x200045, 0x202741, 0x219800, 0x60F400, 0x000305, 0x07E885, 0x050897, 0x60F413, 0x000600, 0x57F400, 0x000016, 0x0D1080, 0x00005B, 0x62F413, 0x000400, 0x20001B, 0x060091, 0x000005, 0x44DA00, 0x20008A, 0x200047, 0x029040, 0x200026, 0x0C1C91, 0x567000, 0x00062F, 0x21A700, 0x212600, 0x2F4013, 0x061790, 0x000009, 0x21C510, 0x000000, 0x21C400, 0x200084, 0x200030, 0x20AE00, 0x202110, 0x20002A, 0x567000, 0x000631, 0x62F413, 0x000500, 0x20001B, 0x060091, 0x000005, 0x44DA00, 0x20008A, 0x200047, 0x029040, 0x200026, 0x0C1C91, 0x567000, 0x000630, 0x21A700, 0x212600, 0x2F4013, 0x061790, 0x000009, 0x21C510, 0x000000, 0x21C400, 0x200084, 0x200030, 0x20AE00, 0x202110, 0x20002A, 0x567000, 0x000632, 0x56F400, 0x000008, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x00000F, 0x60F400, 0x00062F, 0x380400, 0x390000, 0x0D0180, 0x00000C, 0x60F400, 0x000000, 0x068092, 0x000005, 0x44D800, 0x46D0A1, 0x5658E9, 0x575800, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000016, 0x20004D, 0x0D104A, 0x000008, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x0D1080, 0x0000B8, 0x56F000, 0x000636, 0x200003, 0x05A406, 0x0D1080, 0x000150, 0x0D1080, 0x00012F, 0x050C03, 0x0D1080, 0x000153, 0x0D1080, 0x000130, 0x56F000, 0x000637, 0x014085, 0x05A417, 0x66F000, 0x000633, 0x3E0300, 0x60EE00, 0x3E0400, 0x61EE00, 0x66F000, 0x000634, 0x3E0300, 0x70EE00, 0x3E0400, 0x71EE00, 0x46F400, 0x5A827A, 0x62F000, 0x00063C, 0x06D210, 0x000005, 0x44E000, 0x44C9D0, 0x2000D3, 0x564800, 0x66F000, 0x000633, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x3E0100, 0x62EE00, 0x66F000, 0x000638, 0x3E0000, 0x64EE00, 0x3E0200, 0x65EE00, 0x66F000, 0x000634, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x3E0100, 0x72EE00, 0x66F000, 0x000639, 0x3E0000, 0x74EE00, 0x76F400, 0x000002, 0x75EE00, 0x45F400, 0x5A827A, 0x66F000, 0x00063C, 0x06D600, 0x0004A6, 0x44CA00, 0x56C800, 0x57C9A3, 0x564CAB, 0x574D00, 0x61F400, 0x00063D, 0x65F000, 0x00068B, 0x62F400, 0x000671, 0x66F000, 0x000638, 0x3E0000, 0x60EE00, 0x221400, 0x66F000, 0x000639, 0x70EE00, 0x231C00, 0x50F000, 0x00063C, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x0005CA, 0x61F400, 0x00064D, 0x65F000, 0x00068B, 0x62F400, 0x000679, 0x66F000, 0x000638, 0x3E0200, 0x60EE00, 0x221400, 0x66F000, 0x000639, 0x70EE00, 0x231C00, 0x50F000, 0x00063C, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x0005CA, 0x61F400, 0x00065D, 0x65F000, 0x00068C, 0x62F400, 0x000681, 0x66F000, 0x000633, 0x3E0300, 0x60EE00, 0x221400, 0x66F000, 0x000634, 0x70EE00, 0x231C00, 0x50F000, 0x00063C, 0x00000A, 0x211E00, 0x72F400, 0x000005, 0x0BF080, 0x0005CA, 0x66F000, 0x000638, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x66F000, 0x000633, 0x3E0300, 0x62EE00, 0x66F000, 0x000639, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x66F000, 0x000634, 0x3E0300, 0x72EE00, 0x45F400, 0x5A827A, 0x64F000, 0x00063C, 0x06D400, 0x00050A, 0x44CA00, 0x56E000, 0x57E1A3, 0x5648AF, 0x574900, 0x0D1080, 0x0000B4, 0x00000C, 0x205800, 0x44D800, 0x447000, 0x000633, 0x44D800, 0x447000, 0x000634, 0x44D800, 0x447000, 0x000635, 0x57D800, 0x0C1890, 0x001027, 0x507000, 0x000636, 0x0C1890, 0x001019, 0x507000, 0x000637, 0x44D800, 0x447000, 0x000638, 0x44D800, 0x447000, 0x000639, 0x44D800, 0x447000, 0x00063A, 0x57D800, 0x0C1890, 0x002024, 0x507000, 0x00063B, 0x44D800, 0x447000, 0x00063C, 0x00000C, 0xC0958D, 0x000000, 0x7ED4E5, 0xC00000, 0x000000, 0x4FE24A, 0x3F67CC, 0x3F67CC, 0x4FE24A, 0x7FFFFF, 0x855BE8, 0x756638, 0x756638, 0x855BE8, 0x7FFFFF, 0xEA1F92, 0xE2404B, 0xE2404B, 0xEA1F92, 0x7FFFFF, 0x812B1B, 0x7DAC85, 0x7ED594, 0x812A6C, 0x7ED594, 0x4FE24A, 0x3F67CC, 0x579426, 0x55FF7F, 0x579426, 0x4FE24A, 0x3F67CC, 0x579426, 0x55FF7F, 0x579426, 0x823E22, 0x7B876D, 0x7B876D, 0x823E22, 0x7FFFFF, 0xB23B5E, 0x27F74F, 0x27F74F, 0xB23B5E, 0x7FFFFF, 0xC08974, 0x000000, 0x7EED19, 0xC00000, 0x000000, 0x462AF8, 0x378620, 0x378620, 0x462AF8, 0x7FFFFF, 0x84EF9E, 0x763A35, 0x763A35, 0x84EF9E, 0x7FFFFF, 0xE648FE, 0xE4B78A, 0xE4B78A, 0xE648FE, 0x7FFFFF, 0x8112E7, 0x7DDC7F, 0x7EEDAC, 0x811254, 0x7EEDAC, 0x462AF8, 0x378620, 0x511DF3, 0x4EF590, 0x511DF3, 0x462AF8, 0x378620, 0x511DF3, 0x4EF590, 0x511DF3, 0x82101A, 0x7BE2ED, 0x7BE2ED, 0x82101A, 0x7FFFFF, 0xAF2EFC, 0x2C7800, 0x2C7800, 0xAF2EFC, 0x7FFFFF, 0x61F413, 0x00063D, 0x064E90, 0x000002, 0x565900, 0x00000C, 0x60F400, 0x000533, 0x61F400, 0x000000, 0x065A90, 0x000003, 0x07D884, 0x4C5900, 0x56F000, 0x00063B, 0x240000, 0x60F400, 0x00002D, 0x61F445, 0x000041, 0x05A405, 0x60F400, 0x000000, 0x61F400, 0x000014, 0x607000, 0x00068B, 0x617000, 0x00068C, 0x00000C, 0x56F400, 0x000011, 0x57F400, 0x000000, 0x384E00, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x000011, 0x57F400, 0x000001, 0x60F400, 0x00063D, 0x384E00, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x000011, 0x57F400, 0x000002, 0x60F400, 0x00063D, 0x384E00, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x000021, 0x57DA00, 0x51D200, 0xF0B900, 0x06DE10, 0x00000B, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D2, 0x200010, 0x10DD09, 0x444C4C, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D2, 0x200010, 0x21C409, 0x444C4C, 0x03F184, 0x555A00, 0x515A00, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\AC3Dolby2.h ===
0xD01B40, 0x000862, 0x020172, 0x686B56, 0x447000, 0x000965, 0x607000, 0x000968, 0x20000B, 0x05A407, 0x0508DF, 0x0D1080, 0x0007CE, 0x0D1080, 0x00080B, 0x050C05, 0x0D1080, 0x0007D4, 0x0D1080, 0x0007F8, 0x0508D9, 0x62F000, 0x000968, 0x60F400, 0x000FC2, 0x0A72D8, 0x000005, 0x240000, 0x447000, 0x000966, 0x5EE800, 0x021A9F, 0x20000B, 0x05A402, 0x014180, 0x547000, 0x000967, 0x44F000, 0x000966, 0x050952, 0x050811, 0x44F000, 0x000966, 0x0D1080, 0x000802, 0x56F000, 0x000966, 0x014180, 0x44F000, 0x000967, 0x547000, 0x000966, 0x200045, 0x0597D0, 0x0D1080, 0x0007BC, 0x00000C, 0x56F000, 0x000966, 0x44F000, 0x000965, 0x0C1940, 0x008020, 0x547000, 0x000943, 0x56F000, 0x000966, 0x200003, 0x05245A, 0x62F000, 0x000968, 0x60F400, 0x000953, 0x44F400, 0x000080, 0x060690, 0x000002, 0x445800, 0x0212DE, 0x021A94, 0x0C1940, 0x00101B, 0x547000, 0x000936, 0x44F413, 0x000012, 0x0C1940, 0x005021, 0x547000, 0x00093A, 0x02229E, 0x022AD4, 0x0C1940, 0x001021, 0x022A94, 0x0C1940, 0x001022, 0x0222D4, 0x0C1940, 0x001023, 0x547000, 0x00093B, 0x200013, 0x024A94, 0x0C1940, 0x00201A, 0x547000, 0x000947, 0x021AD4, 0x447000, 0x000948, 0x200013, 0x023A94, 0x0C1940, 0x001018, 0x023294, 0x0C1940, 0x001019, 0x547000, 0x000944, 0x023AD4, 0x447000, 0x000946, 0x0232D4, 0x447000, 0x000945, 0x60F413, 0x000932, 0x57F400, 0x000010, 0x0D1080, 0x0002A9, 0x44F400, 0x000000, 0x200045, 0x057400, 0x00000C, 0x30001B, 0x0D1080, 0x0002A1, 0x00000C, 0x44F400, 0x000015, 0x447000, 0x000932, 0x44F400, 0x000953, 0x447000, 0x000933, 0x44F400, 0x00095F, 0x447000, 0x000934, 0x44F400, 0x000959, 0x447000, 0x000935, 0x44F400, 0x00FFFF, 0x447000, 0x000939, 0x44F400, 0x000947, 0x447000, 0x00093C, 0x240000, 0x447000, 0x000937, 0x447000, 0x000938, 0x447000, 0x00093D, 0x447000, 0x00093E, 0x447000, 0x00093F, 0x447000, 0x000940, 0x447000, 0x000941, 0x447000, 0x000942, 0x60F400, 0x00094D, 0x44F400, 0x000000, 0x445800, 0x44F400, 0x000002, 0x445800, 0x44F400, 0x000003, 0x445800, 0x44F400, 0x000004, 0x445800, 0x44F400, 0x000001, 0x445800, 0x44F400, 0x000005, 0x445800, 0x60F400, 0x00095F, 0x44F400, 0x000001, 0x060690, 0x000002, 0x445800, 0x60F400, 0x000959, 0x44F400, 0x00FFFF, 0x060690, 0x000002, 0x445800, 0x00000C, 0x62F000, 0x000968, 0x45F400, 0x000003, 0x0212D6, 0x2000E0, 0x62F400, 0x000F92, 0x210E00, 0x200040, 0x60F400, 0x000080, 0x219A00, 0x70F400, 0x000100, 0x56F400, 0x000007, 0x79EA00, 0x0D0180, 0x200003, 0x052400, 0x00000C, 0x230800, 0x00000A, 0x04C8A0, 0x0461A0, 0x0464A0, 0x0465A0, 0x0004F8, 0x230E00, 0x200022, 0x219800, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x4FE100, 0x5EE078, 0x06D810, 0x000009, 0x45D919, 0x200016, 0x8F8000, 0x8AB868, 0x4FE119, 0x200016, 0xCF1C00, 0xCA1D78, 0x230E00, 0x223022, 0x219800, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x4FE100, 0x5EE078, 0x06D810, 0x000009, 0x45D919, 0x200016, 0x8F8000, 0x8AB868, 0x4FE119, 0x200016, 0xCF1C00, 0xCA1D78, 0x223000, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x45E100, 0x5EE06C, 0x06D810, 0x000009, 0x4FD919, 0x200016, 0x8F8000, 0x8AB878, 0x45E119, 0x200016, 0xCF1C00, 0xCA1D6C, 0x230E00, 0x3A0222, 0x223000, 0x219900, 0x221100, 0x233200, 0x221400, 0x66F400, 0x000F52, 0x204900, 0x223500, 0x045A18, 0x231C00, 0x231D00, 0x205200, 0x5FE000, 0xF4C100, 0x4CDE00, 0x4FD9AE, 0x5EE0BF, 0x06DA10, 0x000020, 0x06D210, 0x000007, 0x8F8016, 0x45E1EE, 0x8AB8CB, 0xCF1C16, 0x4FD9AE, 0xCA1DBF, 0x204900, 0x8F8016, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x4FD9EA, 0xCA0DCF, 0x06D210, 0x000007, 0x8F8016, 0x45E1AE, 0x8AB8BF, 0xCF1C16, 0x4FD9EA, 0xCA1DCF, 0x204900, 0x8F8016, 0x8AA8AE, 0xF4C1BF, 0x4CDE00, 0xCF0C16, 0x4FD9AE, 0xCA0DBF, 0x232F00, 0x234E2A, 0x200032, 0x21B900, 0x219A00, 0x0CCD80, 0xFFFFCA, 0x380200, 0x221400, 0x231C00, 0x235200, 0x66F400, 0x000F52, 0x045811, 0x231900, 0x223500, 0x231D00, 0x205200, 0x5FE000, 0xF4C100, 0x4CDE00, 0x4FC9AE, 0x5EE0BF, 0x200016, 0x8F8000, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x06D210, 0x000010, 0x4FC9EA, 0xCA0DCF, 0x200016, 0x8F8000, 0x8AA8AE, 0xF4C1BF, 0x4CDE00, 0xCF0C16, 0x4FC9AE, 0xCA0DBF, 0x200016, 0x8F8000, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x4FC9EA, 0xCA0DCF, 0x200016, 0x8F8000, 0x8AA8AE, 0x2000BF, 0x05F420, 0x00FFFF, 0x574C16, 0x0461A0, 0x564D00, 0x0464A0, 0x0465A0, 0x00F3B8, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x00001A, 0xF0B900, 0x06DE10, 0x00000A, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D3, 0x10DD00, 0x444C00, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D3, 0x564C00, 0x03F18E, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x000021, 0x57DA00, 0x51D200, 0xF0B900, 0x06DE10, 0x00000B, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D2, 0x200010, 0x10DD09, 0x444C4C, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D2, 0x200010, 0x21C409, 0x444C4C, 0x03F184, 0x555A00, 0x515A00, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C, 0x44C800, 0x2000A0, 0x44C814, 0x200011, 0x06DE10, 0x000005, 0x180CA0, 0x44C8BA, 0x200014, 0x200011, 0x182400, 0x2000BA, 0x00000C, 0x46C813, 0x2000E1, 0x06DE10, 0x000003, 0x46C800, 0x564CE1, 0x566400, 0x00000C, 0x394000, 0x233D00, 0x204900, 0x204D00, 0x045112, 0x045516, 0x06D910, 0x000004, 0x46D900, 0xB0B200, 0x445600, 0x38FF00, 0x231C00, 0x204100, 0x204500, 0x044812, 0x044C16, 0x380200, 0x72F400, 0xFFFFFE, 0x3C0200, 0x76F400, 0xFFFFFE, 0xD08800, 0xD5CAD4, 0x2000F3, 0x5659C8, 0xD088EB, 0x063F90, 0x000005, 0xD5CAD4, 0x575DF3, 0x5659C8, 0xD088EB, 0x575D00, 0x204000, 0x204400, 0x387F00, 0x231A00, 0x231C00, 0x231E00, 0x204100, 0x204500, 0x204000, 0x204A00, 0x204400, 0x204E00, 0x380200, 0x72F400, 0xFFFFFE, 0x3C0200, 0x76F400, 0xFFFFFE, 0xD08800, 0xD5CAD4, 0x2000F3, 0x5679C8, 0xD088EB, 0x063F90, 0x000005, 0xD5CAD4, 0x5F7DF3, 0x5679C8, 0xD088EB, 0x5F7D00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4ED8C8, 0x2000EB, 0x5F64B0, 0x06DA10, 0x000006, 0xF1C0A7, 0x4DDA00, 0x4ED8C8, 0x565CEB, 0x5F64B0, 0x2000A7, 0x565C00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4EE1C8, 0x2000EB, 0x4ED8B0, 0x44D9A7, 0x5F64C8, 0x565CEB, 0x5F65B0, 0x06DA10, 0x00000A, 0xF1C0A7, 0x4DDA00, 0x4EE1C8, 0x565DEB, 0x4ED8B0, 0x44D9A7, 0x5F64C8, 0x565CEB, 0x5F65B0, 0x2000A7, 0x565D00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4EC8A8, 0x2000BB, 0x574DE0, 0x06DA10, 0x000006, 0xF1C0C7, 0x4DDA00, 0x4EC8A8, 0x564CBB, 0x574DE0, 0x2000C7, 0x564C00, 0x00000C, 0xF1C100, 0x4DDA00, 0x4EE1A8, 0x4EE0BB, 0x44C8E0, 0x5755C7, 0x4EE1B8, 0x565CAB, 0x44C9E0, 0x574DC7, 0x06DA10, 0x00000B, 0xF1C100, 0x4DDA00, 0x4EE1A8, 0xC80CBB, 0x44C8E0, 0x5755C7, 0x4EE1B8, 0x565CAB, 0x44C9E0, 0x574DC7, 0x564C00, 0x00000C, 0x56D800, 0x06D910, 0x000007, 0x0C1E01, 0x20003E, 0x23A403, 0x02A048, 0x56D800, 0x575900, 0x205000, 0x00000C, 0x46F400, 0x000001, 0x23AE00, 0x223555, 0x05A40D, 0x22B400, 0x06DC10, 0x000009, 0x56F400, 0x7FFFFF, 0x06DD10, 0x000004, 0x44DC00, 0x200045, 0x027040, 0x544D00, 0x223500, 0x234F00, 0x56E20B, 0x052406, 0x44F400, 0x00000F, 0x200045, 0x027040, 0x546200, 0x218500, 0x06DC10, 0x000004, 0x56E500, 0x218564, 0x544D00, 0x223500, 0x238759, 0x45F400, 0x000002, 0x56E500, 0x45F465, 0xFFFFFE, 0x057417, 0x45F465, 0x000002, 0x059411, 0x204D58, 0x20007D, 0x05744D, 0x0597D6, 0x56E500, 0x45F465, 0xFFFFFE, 0x057413, 0x45F465, 0x000002, 0x059406, 0x204D58, 0x20007D, 0x057442, 0x0597CB, 0x05A7D5, 0x20455C, 0x05A40D, 0x56E500, 0x200054, 0x544D00, 0x56E500, 0x45F450, 0x000002, 0x544500, 0x050FC0, 0x45F454, 0x000002, 0x546500, 0x050FC7, 0x234E00, 0x204D03, 0x05A407, 0x56E200, 0x200054, 0x546200, 0x56E500, 0x200050, 0x546500, 0x56E200, 0x200054, 0x546200, 0x56E500, 0x45F450, 0x000002, 0x546558, 0x050F8B, 0x223500, 0x45E200, 0x06DC10, 0x000005, 0x56E500, 0x200060, 0x218500, 0x544D00, 0x23AE00, 0x223555, 0x05A409, 0x22B400, 0x06DC10, 0x000006, 0x44CD00, 0x06DD10, 0x000002, 0x445C00, 0x000000, 0x00000C, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x200045, 0x05A413, 0x209600, 0x60F400, 0x000180, 0x61F400, 0x000241, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x71E200, 0x06D910, 0x000005, 0x44D900, 0x56E000, 0x0C1E48, 0x545800, 0x050C10, 0x56F000, 0x000B7E, 0x200003, 0x05A40C, 0x60F400, 0x000235, 0x61F400, 0x0002F6, 0x390700, 0x06D910, 0x000005, 0x44D900, 0x56E000, 0x0C1E48, 0x545800, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x000011, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x567000, 0x000912, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x05085C, 0x0D1080, 0x000096, 0x56F000, 0x000B96, 0x200003, 0x057453, 0x0D1080, 0x0000C4, 0x56F000, 0x000B96, 0x200003, 0x05744D, 0x0D1080, 0x00016E, 0x0D1080, 0x0001B1, 0x0D1080, 0x0001F4, 0x240000, 0x447000, 0x000931, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x200045, 0x05A409, 0x0D1080, 0x000146, 0x0D1080, 0x00022F, 0x557000, 0x000931, 0x0D1080, 0x000317, 0x0D1080, 0x00032F, 0x0D1080, 0x00033E, 0x0D1080, 0x000399, 0x0D1080, 0x000355, 0x56F000, 0x000B41, 0x200003, 0x0D100A, 0x000440, 0x0D1080, 0x0003A2, 0x0D1080, 0x0003CF, 0x0D1080, 0x0003EA, 0x0D1080, 0xFFFF81, 0x200013, 0x21101B, 0x00000C, 0x205800, 0x44D800, 0x447000, 0x000B42, 0x44D800, 0x447000, 0x000B43, 0x44D800, 0x447000, 0x000B44, 0x57D800, 0x0C1890, 0x002024, 0x507000, 0x000B7B, 0x0C1890, 0x00101B, 0x507000, 0x000B7E, 0x0C1890, 0x003018, 0x507000, 0x000B7D, 0x44D800, 0x447000, 0x000B45, 0x44D800, 0x447000, 0x000B46, 0x44D800, 0x447000, 0x000B47, 0x57D800, 0x0C1890, 0x006020, 0x507000, 0x000B7C, 0x57D800, 0x0C1890, 0x001023, 0x507000, 0x00023D, 0x0C1890, 0x001022, 0x507000, 0x00023E, 0x0C1890, 0x001021, 0x507000, 0x00023F, 0x0C1890, 0x004018, 0x507000, 0x000240, 0x61D800, 0x380600, 0x204800, 0x57D900, 0x0C1890, 0x00201A, 0x507000, 0x000B4E, 0x57D900, 0x015F8E, 0x577000, 0x000B49, 0x57D800, 0x0C1890, 0x008018, 0x507000, 0x000B41, 0x0C1890, 0x008020, 0x507000, 0x000B40, 0x57D800, 0x0C1890, 0x001018, 0x507000, 0x000B4C, 0x0C1890, 0x001019, 0x507000, 0x000B4A, 0x57D800, 0x577000, 0x000B4B, 0x57E000, 0x577000, 0x000B4D, 0x00000C, 0x44F400, 0x000000, 0x447000, 0x000B96, 0x56F000, 0x000240, 0x44F400, 0x000009, 0x200045, 0x202741, 0x547000, 0x000240, 0x56F000, 0x000B49, 0x44F400, 0x00001F, 0x45F445, 0x000000, 0x202741, 0x200065, 0x202961, 0x547000, 0x000B49, 0x56F000, 0x000B7D, 0x44F400, 0x000007, 0x45F445, 0x000006, 0x05A414, 0x44F465, 0x000003, 0x05A411, 0x45F445, 0x000002, 0x05A40E, 0x44F465, 0x000004, 0x05A40B, 0x45F445, 0x000005, 0x05A408, 0x44F465, 0x000001, 0x05A405, 0x44F400, 0x000002, 0x447000, 0x000B96, 0x547000, 0x000B7D, 0x00000C, 0x56F000, 0x000912, 0x44F400, 0x020765, 0x200045, 0x052406, 0x56F000, 0x000B40, 0x200003, 0x05A45E, 0x00000C, 0x60F413, 0x0004FD, 0x060690, 0x000003, 0x545800, 0x545800, 0x60F413, 0x0005A8, 0x060590, 0x000002, 0x545800, 0x60F413, 0x00057B, 0x062890, 0x000002, 0x545800, 0x60F413, 0x0005AE, 0x065A90, 0x000002, 0x545800, 0x60F413, 0x000608, 0x060590, 0x000002, 0x545800, 0x60F413, 0x00060D, 0x060590, 0x000002, 0x545800, 0x60F413, 0x000509, 0x061090, 0x000002, 0x545800, 0x60F413, 0x000519, 0x060890, 0x000002, 0x545800, 0x60F413, 0x000521, 0x063C90, 0x000002, 0x545800, 0x60F413, 0x00055D, 0x061E90, 0x000002, 0x545800, 0x60F413, 0x000612, 0x060093, 0x000002, 0x545800, 0x44F400, 0x020765, 0x447000, 0x000912, 0x44F400, 0x000000, 0x447000, 0x000B96, 0x61F400, 0x000FC2, 0x71F000, 0x000B7D, 0x44F000, 0x000B7E, 0x5EE900, 0x547040, 0x000B97, 0x547000, 0x000B98, 0x44F01B, 0x000B97, 0x2D0513, 0x2C024D, 0x05945A, 0x44F01B, 0x000B98, 0x2D0613, 0x2C024D, 0x059455, 0x56F000, 0x000B7C, 0x200023, 0x547000, 0x000B99, 0x44F01B, 0x000B7B, 0x2D0313, 0x2C044D, 0x05944B, 0x44F01B, 0x000B99, 0x2D1313, 0x2C034D, 0x059446, 0x56F000, 0x000B7C, 0x0140C4, 0x000024, 0x21DA00, 0x44F000, 0x000B7B, 0x46F400, 0x000006, 0x2344D0, 0x0C1D2E, 0x44F440, 0x000F4C, 0x200040, 0x219100, 0x5EE100, 0x21CF22, 0x218422, 0x200022, 0x577040, 0x000B9A, 0x218500, 0x21E46C, 0x46F400, 0x000008, 0x21A7D0, 0x5070E8, 0x000B9D, 0x457000, 0x000B9B, 0x5170B0, 0x000B9E, 0x477000, 0x000B9C, 0x507000, 0x000B9F, 0x050C03, 0x547000, 0x000B96, 0x00000C, 0x56F400, 0x000914, 0x44F000, 0x000B41, 0x200040, 0x219100, 0x56E100, 0x0C1E01, 0x44F43E, 0x000001, 0x20004C, 0x20291B, 0x45F403, 0x000003, 0x02A068, 0x20006D, 0x027068, 0x56F400, 0x000B61, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x00000C, 0x44F000, 0x000B7D, 0x46F400, 0x000006, 0x44F0D0, 0x000B41, 0x0C1D2E, 0x44F440, 0x000F92, 0x200040, 0x219400, 0x56F000, 0x000B44, 0x4CE400, 0x200040, 0x219100, 0x05E120, 0x56F000, 0x000B42, 0x4CE400, 0x200040, 0x219100, 0x56F000, 0x000B43, 0x4CE400, 0x200040, 0x219200, 0x44F400, 0x000100, 0x46E200, 0x2000D0, 0x240022, 0x210600, 0x2400D0, 0x46E200, 0x2400D2, 0x0C1D2E, 0x44E140, 0x200040, 0x219000, 0x70E200, 0x64F400, 0x0002FD, 0x3C0100, 0x3EFF00, 0x45F400, 0x3FF7CF, 0x56F000, 0x00023F, 0x200003, 0x05A40F, 0x56F000, 0x000B41, 0x44F432, 0x0004FD, 0x200040, 0x219100, 0x47F400, 0x000347, 0x57D900, 0x51D100, 0x0D04E7, 0x555900, 0x516100, 0x050C02, 0x0D04F4, 0x05F420, 0x00FFFF, 0x00000C, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x200045, 0x05A44D, 0x56F000, 0x00023D, 0x200003, 0x05A45B, 0x60F400, 0x0002FD, 0x221400, 0x380100, 0x231C00, 0x44F000, 0x000B41, 0x46F400, 0x00000C, 0x44F4D0, 0x000521, 0x0C1D2E, 0x200040, 0x219100, 0x44F000, 0x000B41, 0x46F400, 0x000006, 0x44F4D0, 0x00055D, 0x0C1D2E, 0x200040, 0x219200, 0x56F000, 0x000240, 0x0140C4, 0x000007, 0x21DA00, 0x234400, 0x46F400, 0x00000F, 0x44F4D0, 0x000814, 0x0C1D2E, 0x200040, 0x219500, 0x3A0300, 0x3EFF00, 0x0D049E, 0x050C13, 0x56F000, 0x00023E, 0x200003, 0x05A40F, 0x60F400, 0x0002FD, 0x221400, 0x380100, 0x231C00, 0x61F400, 0x000509, 0x62F400, 0x000519, 0x65F400, 0x000800, 0x3A0400, 0x3EFF00, 0x0D04BF, 0x00000C, 0x44F000, 0x000B7D, 0x46F400, 0x000006, 0x44F0D0, 0x000B41, 0x0C1D2E, 0x44F440, 0x000F92, 0x200040, 0x219100, 0x4CE100, 0x447000, 0x000913, 0x61F400, 0x0002FD, 0x200013, 0x44D91B, 0x060091, 0x000004, 0x200047, 0x029040, 0x44D98A, 0x60F400, 0x0005A8, 0x70F000, 0x000B41, 0x200032, 0x44E826, 0x566847, 0x029040, 0x21C700, 0x56F400, 0x000914, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x476000, 0x0C1C91, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x000920, 0x0C1D2E, 0x200040, 0x219000, 0x555800, 0x516000, 0x56F400, 0x00091A, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x21A700, 0x212600, 0x2F4013, 0x061790, 0x000008, 0x21C510, 0x21C400, 0x200084, 0x200030, 0x20AE00, 0x202110, 0x20002A, 0x200032, 0x566000, 0x00000C, 0x60F400, 0x0002FD, 0x64F400, 0x0003FD, 0x380100, 0x231C00, 0x44F000, 0x000B41, 0x46F400, 0x000008, 0x44F4D0, 0x00057B, 0x0C1D2E, 0x200040, 0x219100, 0x65F400, 0x0008A2, 0x3A0200, 0x3EFF00, 0x0D049E, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380E00, 0x61F400, 0x0003FD, 0x204800, 0x060490, 0x000009, 0x200013, 0x064090, 0x000004, 0x44D900, 0x200047, 0x029040, 0x200026, 0x565800, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380800, 0x57F400, 0x000002, 0x204800, 0x380600, 0x060290, 0x00000B, 0x221100, 0x044812, 0x06CD10, 0x000006, 0x44DA00, 0x56DA00, 0x200045, 0x029040, 0x565900, 0x20402A, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x62F400, 0x0008AF, 0x390200, 0x45F41B, 0x000001, 0x20A600, 0x060390, 0x00000D, 0x221100, 0x4FDA00, 0x204900, 0x44D100, 0x06C610, 0x000004, 0x44C9C0, 0x44D145, 0x027068, 0x20CE00, 0x204832, 0x218600, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380200, 0x44F400, 0x003200, 0x56E800, 0x200045, 0x20291B, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x000920, 0x0C1D2E, 0x200040, 0x219100, 0x56F400, 0x000608, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x44E100, 0x46F400, 0x7FFFFF, 0x44E0D0, 0x200045, 0x20291B, 0x56F400, 0x00092C, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x62F400, 0x0008AC, 0x390200, 0x20A61B, 0x060390, 0x00000D, 0x221100, 0x4FDA00, 0x204900, 0x44D100, 0x06C610, 0x000004, 0x44C9C0, 0x44D145, 0x027068, 0x20CE00, 0x204832, 0x218600, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380200, 0x44F400, 0x003200, 0x56E800, 0x200045, 0x20291B, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x000920, 0x0C1D2E, 0x200040, 0x219100, 0x56F400, 0x000608, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x44E100, 0x46F400, 0x400000, 0x46E0D0, 0x446055, 0x20291B, 0x56F400, 0x000B7F, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x20AE00, 0x060390, 0x00000A, 0x221100, 0x219900, 0x221200, 0x204900, 0x44D900, 0x445A00, 0x44D900, 0x445A00, 0x204832, 0x00000C, 0x56F400, 0x000B7F, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x00060D, 0x44F000, 0x000B41, 0x200040, 0x219100, 0x56F400, 0x000B84, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x44E01B, 0x56E100, 0x45F442, 0x000001, 0x02A068, 0x576200, 0x446100, 0x00000C, 0x60F400, 0x0002FD, 0x44F000, 0x000B41, 0x46F400, 0x000080, 0x44F4D0, 0x000612, 0x0C1D2E, 0x200040, 0x219100, 0x64F400, 0x0008B2, 0x65F400, 0x000000, 0x0D04FC, 0x00000C, 0x56F000, 0x000931, 0x200003, 0x05A40E, 0x60F400, 0x000000, 0x61F400, 0x000040, 0x221400, 0x223500, 0x62F400, 0x000AB2, 0x66F400, 0x000AF2, 0x3A3F00, 0x0D054D, 0x050C0A, 0x60F400, 0x000000, 0x221400, 0x62F400, 0x0009B2, 0x66F400, 0x000A32, 0x3A7F00, 0x0D053E, 0x00000C, 0x0500A0, 0x0461A0, 0x56F000, 0x000931, 0x200003, 0x05A415, 0x60F400, 0x000000, 0x61F400, 0x000040, 0x64F400, 0x0003FD, 0x65F400, 0x0004FC, 0x62F400, 0x000AB2, 0x66F400, 0x000AF2, 0x382000, 0x231900, 0x3A3F00, 0x3C0300, 0x75F400, 0xFFFFFD, 0x0D0573, 0x050C11, 0x60F400, 0x000000, 0x64F400, 0x0003FD, 0x65F400, 0x0004FC, 0x62F400, 0x0009B2, 0x66F400, 0x000A32, 0x384000, 0x3A7F00, 0x3C0200, 0x75F400, 0xFFFFFE, 0x0D0564, 0x05F420, 0x00FFFF, 0x0461A0, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x60F445, 0x0003FD, 0x05A408, 0x61F400, 0x000180, 0x06B590, 0x000003, 0x44D800, 0x445900, 0x050C07, 0x61F400, 0x000235, 0x060790, 0x000003, 0x44D800, 0x445900, 0x00000C, 0x56F000, 0x000931, 0x200003, 0x05A40A, 0x60F400, 0x000000, 0x384000, 0x0D03EF, 0x60F400, 0x000040, 0x384000, 0x0D03EF, 0x050C05, 0x60F400, 0x000000, 0x388000, 0x0D03EF, 0x00000C, 0x56F000, 0x000B97, 0x44F000, 0x000B41, 0x45F445, 0x000001, 0x05A403, 0x05080D, 0x050C03, 0x457000, 0x000B8F, 0x60F400, 0x000B7F, 0x61F400, 0x0005A3, 0x060590, 0x000003, 0x44D800, 0x445900, 0x00000C, 0x290300, 0x70F000, 0x000B41, 0x60F400, 0x000B7F, 0x56E800, 0x014185, 0x05A410, 0x60F400, 0x00092C, 0x56E800, 0x014185, 0x05A40B, 0x56F000, 0x000B40, 0x014085, 0x05A406, 0x60F400, 0x0005A3, 0x56E800, 0x014185, 0x05A402, 0x290200, 0x60F400, 0x000B8A, 0x516800, 0x00000C, 0x3D1800, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x60F445, 0x000180, 0x05A40C, 0x209600, 0x61F400, 0x000241, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x71E200, 0x0D058B, 0x050C0A, 0x56F000, 0x000B7E, 0x60F403, 0x000235, 0x05A405, 0x61F400, 0x0002F6, 0x390700, 0x0D058B, 0x00000C, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x61F445, 0x000241, 0x05A459, 0x56F400, 0x000B8A, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x000BA5, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x56E000, 0x71E200, 0x219400, 0x223600, 0x56F400, 0x000B5C, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x000B91, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x232E00, 0x014184, 0x0B74C4, 0x000F16, 0x218500, 0x47F4AD, 0x000001, 0x0B74C4, 0x000F12, 0x21E600, 0x209DD0, 0x0C1D2E, 0x46F465, 0x2AAAAB, 0x202978, 0x556000, 0x21A500, 0x21BCE9, 0x0C1D82, 0x200010, 0x200065, 0x202978, 0x556200, 0x223200, 0x205900, 0x3A0000, 0x0D0596, 0x050C11, 0x56F000, 0x000B7E, 0x60F403, 0x000B8F, 0x05A40C, 0x61F400, 0x0002F6, 0x390700, 0x223600, 0x223200, 0x205900, 0x3A0000, 0x3C0600, 0x7DF000, 0x000F13, 0x0D0596, 0x00000C, 0x56F000, 0x000240, 0x0C1D04, 0x21C700, 0x46F400, 0x000003, 0x2000B0, 0x0C1D2E, 0x0140C0, 0x000049, 0x21C600, 0x61F400, 0x000BA0, 0x62F400, 0x000BA5, 0x45F000, 0x000B97, 0x06C510, 0x000003, 0x475900, 0x465A00, 0x57F400, 0x000001, 0x56F000, 0x000B40, 0x200003, 0x05A402, 0x20001B, 0x577000, 0x000B90, 0x00000C, 0x56F400, 0x000012, 0x57F400, 0x000000, 0x70F400, 0x000416, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000012, 0x57F400, 0x000001, 0x60F400, 0x0004FD, 0x70F400, 0x000416, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000012, 0x57F400, 0x000002, 0x60F400, 0x0004FD, 0x70F400, 0x000416, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F400, 0x00000E, 0x60F400, 0x000914, 0x380C00, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000019, 0x57F400, 0x000001, 0x390000, 0x70F400, 0x000080, 0x60F400, 0x000B40, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000015, 0x57F400, 0x000000, 0x70F400, 0x000390, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F400, 0x000016, 0x57F400, 0x000000, 0x70F400, 0x000390, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x447000, 0x000969, 0x56F000, 0x000B97, 0x200045, 0x052407, 0x71F400, 0x000389, 0x380700, 0x60F400, 0x000235, 0x050C07, 0x46F400, 0x0000B5, 0x20D8D0, 0x60F422, 0x000180, 0x211900, 0x56F400, 0x000015, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x44F000, 0x000969, 0x56F000, 0x000B97, 0x200045, 0x052407, 0x71F400, 0x000389, 0x380700, 0x60F400, 0x0002F6, 0x050C07, 0x46F400, 0x0000B5, 0x20D8D0, 0x60F422, 0x000241, 0x211900, 0x56F400, 0x000016, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\ac3dolby5.h ===
0xD01B40, 0x0000BC, 0x050172, 0x7D5E26, 0x607000, 0x000700, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x44F400, 0x400000, 0x4C7000, 0x000000, 0x44F400, 0x5A8279, 0x4C7000, 0x000001, 0x44F400, 0x400000, 0x4C7000, 0x000002, 0x44F400, 0x2D413C, 0x4C7000, 0x000003, 0x44F400, 0x2D413C, 0x4C7000, 0x000004, 0x62F000, 0x000700, 0x000000, 0x000000, 0x0242D5, 0x02429E, 0x200003, 0x05A40B, 0x60F400, 0x000000, 0x380100, 0x4EF000, 0x000000, 0x060590, 0x000004, 0x2000E1, 0x4EE800, 0x5E5800, 0x62F400, 0x000500, 0x66F400, 0x000600, 0x70F400, 0x000100, 0x60F400, 0x000000, 0x64F400, 0x000000, 0x221500, 0x060091, 0x00000C, 0xF08800, 0xF088D0, 0xF088D2, 0xF088D2, 0xC080D2, 0x4EDDD3, 0x22B000, 0x64F400, 0x000000, 0x565A00, 0x565E00, 0x62F413, 0x000500, 0x20001B, 0x060091, 0x000005, 0x44DA00, 0x20008A, 0x200047, 0x029040, 0x200026, 0x0C1C91, 0x567000, 0x000701, 0x21A700, 0x212600, 0x2F4013, 0x061790, 0x000009, 0x21C510, 0x000000, 0x21C400, 0x200084, 0x200030, 0x20AE00, 0x202110, 0x20002A, 0x567000, 0x000703, 0x62F413, 0x000600, 0x20001B, 0x060091, 0x000005, 0x44DA00, 0x20008A, 0x200047, 0x029040, 0x200026, 0x0C1C91, 0x567000, 0x000702, 0x21A700, 0x212600, 0x2F4013, 0x061790, 0x000009, 0x21C510, 0x000000, 0x21C400, 0x200084, 0x200030, 0x20AE00, 0x202110, 0x20002A, 0x567000, 0x000704, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000600, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x00000F, 0x60F400, 0x000701, 0x380400, 0x390000, 0x0D0180, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\AC3Loader.h ===
0x62F400, 
0x000100, 
0x219A00, 
0x3D0100, 
0x014085, 
0x05A50F, 
0x204A00, 
0x204A00, 
0x07DA91, 
0x015185, 
0x0514CE, 
0x014685, 
0x05F454, 
0x014985, 
0x05A48C, 
0x014A85, 
0x05A44B, 
0x014B85, 
0x05A451, 
0x014C85, 
0x05A495, 
0x014D85, 
0x05A498, 
0x014885, 
0x05A45B, 
0x014E85, 
0x05A487, 
0x014F85, 
0x05A482, 
0x050C4C, 
0x000000, 
0x000000, 
0x000000, 
0x000001, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x07DA8E, 
0x230400, 
0x219845, 
0x0508C6, 
0x050C90, 
0x07DA98, 
0x05091F, 
0x050C8D, 
0x07F084, 
0x000116, 
0x0BC448, 
0x077084, 
0x000116, 
0x050C87, 
0x232F00, 
0x0C1D93, 
0x222400, 
0x200048, 
0x07F08E, 
0x000116, 
0x200010, 
0x219100, 
0x050893, 
0x050C5D, 
0x232E00, 
0x014085, 
0x05245A, 
0x3A0100, 
0x3C0000, 
0x0508C0, 
0x050C56, 
0x3A0000, 
0x3C0000, 
0x05089C, 
0x050C52, 
0x61F400, 
0x0001AB, 
0x050C03, 
0x61F400, 
0x0001AF, 
0x06D810, 
0x000004, 
0x44D800, 
0x075984, 
0x000000, 
0x050C47, 
0x3A0000, 
0x3C0100, 
0x3D0000, 
0x05088C, 
0x050C42, 
0x3A0000, 
0x3C0000, 
0x050888, 
0x050C1E, 
0x000224, 
0x00022E, 
0x00024A, 
0x000255, 
0x000260, 
0x00026B, 
0x01408D, 
0x05A408, 
0x21BC00, 
0x64F400, 
0x0001F1, 
0x204900, 
0x07EC96, 
0x0BE680, 
0x050C0F, 
0x230F00, 
0x07F08E, 
0x00019F, 
0x07F084, 
0x00019E, 
0x200014, 
0x05940A, 
0x205248, 
0x075A84, 
0x075A98, 
0x07708C, 
0x00019F, 
0x07708D, 
0x00019E, 
0x200013, 
0x00000C, 
0x56F400, 
0x000004, 
0x00000C, 
0x07F084, 
0x000122, 
0x077084, 
0x00019E, 
0x07F084, 
0x000123, 
0x077084, 
0x00019F, 
0x60F413, 
0x000122, 
0x061E90, 
0x000002, 
0x07588E, 
0x0D1080, 
0x0000CE, 
0x050FCC, 
0x64F400, 
0x0001A2, 
0x220C00, 
0x014080, 
0x219000, 
0x0BF080, 
0x000276, 
0x0BF080, 
0x0002E1, 
0x00000C, 
0x64F400, 
0x0001A2, 
0x220C00, 
0x014080, 
0x219000, 
0x0BF080, 
0x000288, 
0x0BF080, 
0x0002E1, 
0x00000C, 
0x64F400, 
0x0001A2, 
0x220C00, 
0x014080, 
0x219000, 
0x234E00, 
0x014085, 
0x0D1042, 
0x000006, 
0x0BF080, 
0x00029A, 
0x0D10C0, 
0x000004, 
0x0BF080, 
0x0002B1, 
0x0BF080, 
0x0002E1, 
0x00000C, 
0x64F400, 
0x0001A2, 
0x220C00, 
0x0140C0, 
0x001800, 
0x219000, 
0x0BF080, 
0x000276, 
0x0BF080, 
0x0002E1, 
0x00000C, 
0x64F400, 
0x0001A2, 
0x220C00, 
0x0140C0, 
0x001800, 
0x219000, 
0x0BF080, 
0x000288, 
0x0BF080, 
0x0002E1, 
0x00000C, 
0x64F400, 
0x0001A2, 
0x220C00, 
0x0140C0, 
0x002800, 
0x219000, 
0x0BF080, 
0x000276, 
0x0BF080, 
0x0002E1, 
0x00000C, 
0x64F400, 
0x0001A2, 
0x220C00, 
0x0140C0, 
0x002800, 
0x219000, 
0x0BF080, 
0x000288, 
0x0BF080, 
0x0002E1, 
0x00000C, 
0x0BF080, 
0x0002D0, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x005BE0, 
0x075D8C, 
0x075D98, 
0x075D90, 
0x222E00, 
0x0C1E84, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x0002D0, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x005BE2, 
0x075D8C, 
0x075D98, 
0x075D90, 
0x222E00, 
0x0C1E84, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x0002D0, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x004602, 
0x222F00, 
0x0C1E8B, 
0x21E500, 
0x200062, 
0x075D8C, 
0x075D98, 
0x238E00, 
0x0C1E9C, 
0x220400, 
0x200040, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x0002D0, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x000603, 
0x222F00, 
0x0C1E8B, 
0x21E500, 
0x200062, 
0x230F00, 
0x0C1E9D, 
0x21E500, 
0x200062, 
0x075D8C, 
0x230F00, 
0x0C1E89, 
0x234500, 
0x200068, 
0x075D8D, 
0x238E00, 
0x0C1E9C, 
0x220400, 
0x200040, 
0x075D8C, 
0x00000C, 
0x0A96A4, 
0x0002D0, 
0x08F485, 
0x000080, 
0x00000C, 
0x08F496, 
0x000001, 
0x0A9684, 
0x0002D7, 
0x00000C, 
0x0A85AA, 
0x0002FE, 
0x0A8587, 
0x0002DA, 
0x08F485, 
0x000080, 
0x00000C, 
0x228E00, 
0x0140C0, 
0x002800, 
0x08CE14, 
0x0BF080, 
0x0002D5, 
0x20001B, 
0x23AF00, 
0x01408D, 
0x0D104A, 
0x000004, 
0x0BF080, 
0x0002DA, 
0x00000C, 
0x08F485, 
0x000FFF, 
0x08F484, 
0x000001, 
0x08F48A, 
0x000000, 
0x44F400, 
0x004000, 
0x447000, 
0xFFFFD5, 
0x447000, 
0xFFFFD4, 
0x08F497, 
0x000000, 
0x00000C, 
0x050C00,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\ac3dolby6.h ===
0xD01B40, 0x0000C9, 0x060172, 0x87C4B0, 0x607000, 0x000700, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x44F400, 0x7FFFFF, 0x4C7000, 0x000000, 0x4C7000, 0x000005, 0x44F400, 0x5A8279, 0x4C7000, 0x000002, 0x4C7000, 0x000003, 0x44F400, 0x5A8279, 0x4C7000, 0x000006, 0x4C7000, 0x000009, 0x44F400, 0x000000, 0x4C7000, 0x000004, 0x4C7000, 0x000008, 0x4C7000, 0x000001, 0x4C7000, 0x000007, 0x62F000, 0x000700, 0x000000, 0x000000, 0x0242D5, 0x02429E, 0x200003, 0x05A40B, 0x60F400, 0x000000, 0x380100, 0x4EF000, 0x000000, 0x060A90, 0x000004, 0x2000E1, 0x4EE800, 0x5E5800, 0x62F400, 0x000500, 0x66F400, 0x000600, 0x70F400, 0x000100, 0x60F400, 0x000000, 0x64F400, 0x000000, 0x221500, 0x060091, 0x000011, 0xF08800, 0x4EDCD0, 0xF088D8, 0x4EDCD2, 0xF088DA, 0x4EDCD2, 0xF088DA, 0x4EDCD2, 0xF088DA, 0x4EDCD3, 0x4EDDDB, 0x22B000, 0x64F400, 0x000000, 0x565A00, 0x575E00, 0x62F413, 0x000500, 0x20001B, 0x060091, 0x000005, 0x44DA00, 0x20008A, 0x200047, 0x029040, 0x200026, 0x0C1C91, 0x567000, 0x000701, 0x21A700, 0x212600, 0x2F4013, 0x061790, 0x000009, 0x21C510, 0x000000, 0x21C400, 0x200084, 0x200030, 0x20AE00, 0x202110, 0x20002A, 0x567000, 0x000703, 0x62F413, 0x000600, 0x20001B, 0x060091, 0x000005, 0x44DA00, 0x20008A, 0x200047, 0x029040, 0x200026, 0x0C1C91, 0x567000, 0x000702, 0x21A700, 0x212600, 0x2F4013, 0x061790, 0x000009, 0x21C510, 0x000000, 0x21C400, 0x200084, 0x200030, 0x20AE00, 0x202110, 0x20002A, 0x567000, 0x000704, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000600, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x00000F, 0x60F400, 0x000701, 0x380400, 0x390000, 0x0D0180, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\AC3Dolby4.h ===
0xD01B40, 0x0006D3, 0x040172, 0x0FC6C2, 0x447000, 0x0000FB, 0x20000B, 0x05A403, 0x0D1080, 0x0006C0, 0x0D1080, 0x00066C, 0x57F000, 0x0000FB, 0x60F40B, 0x00001F, 0x052412, 0x240000, 0x447000, 0x000B4F, 0x447000, 0x000B50, 0x44F400, 0xF87200, 0x445800, 0x44F400, 0x4E1F00, 0x445800, 0x44F400, 0x000100, 0x445800, 0x44F400, 0x500000, 0x445800, 0x56F000, 0x000B4F, 0x44F003, 0x000B50, 0x05A402, 0x445800, 0x57F400, 0x000010, 0x0D1080, 0x0001A6, 0x44F400, 0x000000, 0x200045, 0x057400, 0x205800, 0x56D800, 0x57F000, 0x0000FB, 0x44F40B, 0x000004, 0x202A40, 0x57F000, 0x000B4F, 0x44F40B, 0x000001, 0x202240, 0x240000, 0x250000, 0x60F400, 0x00001F, 0x0CCC80, 0x000007, 0x0ACC40, 0x219800, 0x44F400, 0x000001, 0x45E800, 0x447000, 0x000B4F, 0x457000, 0x000B50, 0x218400, 0x56F000, 0x0000FB, 0x0D1080, 0x000636, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x06D910, 0x00000A, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x61F400, 0x000D12, 0x46F400, 0x0000FF, 0x06D810, 0x00000E, 0x0C1C90, 0x200056, 0x51D800, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1C90, 0x200056, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x61F41B, 0x000E12, 0x46F400, 0x0000FF, 0x204800, 0x06D810, 0x00000D, 0x21AE5E, 0x44F800, 0x21B900, 0x0C1ED0, 0x200042, 0x4CE900, 0x200043, 0x218F56, 0x219900, 0x0C1ED1, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x000479, 0x0003FA, 0x000417, 0x000434, 0x00043B, 0x000454, 0x00045B, 0x00045E, 0x000461, 0x000464, 0x000467, 0x00046A, 0x00046D, 0x000470, 0x000473, 0x000476, 0x74F400, 0x0003E1, 0x06D810, 0x000086, 0x64DD00, 0x56E000, 0x07EC96, 0x218500, 0x0AE680, 0x44F400, 0x000003, 0x62F4A0, 0x000005, 0x72F040, 0x000002, 0x234F22, 0x39010B, 0x546A00, 0x052404, 0x607000, 0x00000D, 0x050C0E, 0x66F400, 0x000D0A, 0x232400, 0x39024D, 0x05A409, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000D, 0x0C1D24, 0x390000, 0x506600, 0x717013, 0x000002, 0x050CC3, 0x44F400, 0x000005, 0x62F4A0, 0x000008, 0x72F040, 0x000003, 0x234F22, 0x39010B, 0x546A00, 0x052404, 0x607000, 0x00000E, 0x050C0E, 0x66F400, 0x000D0D, 0x232400, 0x39024D, 0x05A409, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000E, 0x0C1D20, 0x390000, 0x506600, 0x717013, 0x000003, 0x050C86, 0x44F400, 0x000007, 0x2000A0, 0x200040, 0x0C1D38, 0x0C1C10, 0x050C5F, 0x44F400, 0x00000B, 0x62F4A0, 0x00000B, 0x72F040, 0x000004, 0x234F22, 0x39010B, 0x66F400, 0x000D10, 0x546A00, 0x052404, 0x607000, 0x00000F, 0x050C08, 0xF0DA00, 0xF0DAD0, 0x66F0D2, 0x00000F, 0x0C1D20, 0x390000, 0x506600, 0x717013, 0x000004, 0x050C46, 0x44F400, 0x00000F, 0x2000A0, 0x200040, 0x0C1D36, 0x0C1C10, 0x050C1F, 0x56F400, 0x040000, 0x050C1B, 0x56F400, 0x020000, 0x050C18, 0x56F400, 0x010000, 0x050C15, 0x56F400, 0x008000, 0x050C12, 0x56F400, 0x004000, 0x050C0F, 0x56F400, 0x002000, 0x050C0C, 0x56F400, 0x001000, 0x050C09, 0x56F400, 0x000800, 0x050C06, 0x56F400, 0x000400, 0x050C03, 0x56F400, 0x000100, 0x200060, 0x565800, 0x00000C, 0x0004C6, 0x0004B2, 0x0004A8, 0x0004BB, 0x00049E, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x56F000, 0x000B56, 0x45F000, 0x000B57, 0x46F400, 0x000010, 0x74F400, 0x00047B, 0x06D810, 0x00002F, 0x64DD00, 0x07EC96, 0x0B74C7, 0x000CFA, 0x0AE680, 0x57F000, 0x000004, 0x01418C, 0x557000, 0x000004, 0x052443, 0x390200, 0x717000, 0x000004, 0x050C14, 0x57F000, 0x000003, 0x01418C, 0x557000, 0x000003, 0x052419, 0x390300, 0x717000, 0x000003, 0x050C0A, 0x57F000, 0x000002, 0x01418C, 0x557000, 0x000002, 0x05240F, 0x390300, 0x717000, 0x000002, 0x200069, 0x50E07C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x21A500, 0x205800, 0x547000, 0x000B56, 0x457000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x00000F, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x057458, 0x607000, 0x000B45, 0x607000, 0x000B55, 0x45F400, 0x0007B0, 0x457000, 0x000B72, 0x56F000, 0x000B40, 0x240003, 0x052409, 0x447000, 0x000B56, 0x447000, 0x000B57, 0x447000, 0x000B9D, 0x0D1080, 0x00008C, 0x0D1080, 0x000129, 0x0D1080, 0x00019E, 0x0D1080, 0x000366, 0x56F000, 0x000B40, 0x014585, 0x052403, 0x0D1080, 0x000393, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x547000, 0x000B58, 0x0D1080, 0x0003D0, 0x56F000, 0x000B40, 0x014585, 0x05A40B, 0x44F000, 0x000B58, 0x45F400, 0x000010, 0x44F0A0, 0x000B9D, 0x0C1D2E, 0x200040, 0x567000, 0x000B9D, 0x0D1080, 0x000008, 0x00000C, 0x44F400, 0x000100, 0x447000, 0x000010, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x05F407, 0x44F013, 0x000B45, 0x447000, 0x000B55, 0x547000, 0x000B9A, 0x60F400, 0x000011, 0x44F400, 0x00000D, 0x445800, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x545800, 0x44F000, 0x000B55, 0x445800, 0x240000, 0x445800, 0x445800, 0x445800, 0x445800, 0x44F413, 0x000009, 0x447000, 0x00001E, 0x44F000, 0x00001E, 0x0C1940, 0x004018, 0x545800, 0x240000, 0x445800, 0x20001B, 0x200013, 0x0C1EDF, 0x21A400, 0x0C1940, 0x008020, 0x20001B, 0x0C1EDF, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x57F013, 0x000B7D, 0x45F40B, 0x000080, 0x052407, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008020, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x57F013, 0x000B7D, 0x20000B, 0x052407, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008020, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x200013, 0x545800, 0x60F400, 0x000011, 0x56F000, 0x000B96, 0x57F400, 0x000608, 0x00000C, 0x62F000, 0x000B45, 0x05F022, 0x000B47, 0x57F400, 0x000010, 0x250000, 0x44F400, 0x000B77, 0x447000, 0x000000, 0x44F400, 0x000000, 0x447000, 0x000B54, 0x61F400, 0x000000, 0x381000, 0x0D0393, 0x61F400, 0x000B54, 0x381000, 0x0D0393, 0x61F400, 0x000B7B, 0x380200, 0x0D0393, 0x61F400, 0x000B7C, 0x380600, 0x0D0393, 0x280400, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380500, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F400, 0x000B7D, 0x380300, 0x0D0393, 0x56F000, 0x000B7D, 0x014185, 0x05A40A, 0x014186, 0x05A408, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F000, 0x000B7D, 0x014486, 0x05A408, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F000, 0x000B7D, 0x014285, 0x052405, 0x61F400, 0x000B4E, 0x380200, 0x0D0393, 0x61F400, 0x000B7E, 0x380100, 0x0D0393, 0x61F400, 0x000B49, 0x380500, 0x0D0393, 0x61F400, 0x000B4C, 0x380100, 0x0D0393, 0x56F000, 0x000B4C, 0x200003, 0x05A405, 0x61F400, 0x000B4D, 0x380800, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280100, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x200013, 0x567000, 0x000002, 0x567000, 0x000003, 0x567000, 0x000004, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00001D, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x70E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x000100, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219500, 0x667000, 0x000B41, 0x0D03F1, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A407, 0x380700, 0x60F400, 0x000489, 0x65F400, 0x000B39, 0x0D03F1, 0x57F000, 0x000002, 0x20000B, 0x05A414, 0x62F400, 0x000005, 0x66F400, 0x000D0A, 0x224E00, 0x44F410, 0x000001, 0x01438C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000D, 0x0C1D24, 0x506600, 0x57F000, 0x000003, 0x20000B, 0x05A414, 0x62F400, 0x000008, 0x66F400, 0x000D0D, 0x224E00, 0x44F410, 0x000002, 0x01438C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000E, 0x0C1D20, 0x506600, 0x57F000, 0x000004, 0x20000B, 0x05A413, 0x62F400, 0x00000B, 0x66F400, 0x000D10, 0x224E00, 0x44F410, 0x000005, 0x01428C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0x66F0D2, 0x00000F, 0x0C1D20, 0x506600, 0x00000C, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x57F000, 0x000B57, 0x45F000, 0x000B56, 0x61F400, 0x000B7F, 0x71F000, 0x000B97, 0x380100, 0x0D036F, 0x61F400, 0x000B84, 0x71F000, 0x000B97, 0x380100, 0x0D036F, 0x61F400, 0x000B4A, 0x380100, 0x0D0393, 0x56F000, 0x000B4A, 0x200003, 0x05A405, 0x61F400, 0x000B4B, 0x380800, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x000B89, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A405, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x56F000, 0x000B7D, 0x0140C5, 0x000002, 0x052412, 0x44F400, 0x000010, 0x447000, 0x00001E, 0x56F000, 0x000B40, 0x200003, 0x052406, 0x61F400, 0x00001E, 0x380500, 0x0D0393, 0x050C05, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x61F400, 0x000B8A, 0x71F000, 0x000B97, 0x380200, 0x0D036F, 0x56F000, 0x000B7E, 0x200003, 0x05A405, 0x61F400, 0x000B8F, 0x380100, 0x0D0393, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000011, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219100, 0x56E100, 0x200003, 0x05A408, 0x56F400, 0x000BA0, 0x22C400, 0x200040, 0x219100, 0x380600, 0x0D0393, 0x205E00, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000023, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219100, 0x56E100, 0x200003, 0x05A41A, 0x22C400, 0x46F400, 0x00001F, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219100, 0x380400, 0x0D03A3, 0x56F400, 0x000B91, 0x22C400, 0x200040, 0x219000, 0x71E000, 0x380700, 0x0D0381, 0x56F400, 0x000B61, 0x22C400, 0x200040, 0x219100, 0x380200, 0x0D0393, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A40C, 0x56F000, 0x000B8F, 0x200003, 0x05A408, 0x61F400, 0x00009B, 0x380400, 0x0D03A3, 0x390200, 0x380700, 0x0D0381, 0x61F400, 0x000B90, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A449, 0x56F400, 0x000002, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000002, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000007, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F400, 0x000B6F, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A44A, 0x61F400, 0x000B73, 0x380600, 0x0D0393, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000011, 0x56F400, 0x000B74, 0x22C400, 0x200040, 0x219100, 0x380400, 0x0D0393, 0x56F400, 0x000004, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A40D, 0x61F400, 0x000B79, 0x380400, 0x0D0393, 0x56F400, 0x000004, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F413, 0x00001E, 0x566100, 0x380100, 0x0D0393, 0x050C01, 0x56F000, 0x000B40, 0x014385, 0x052455, 0x224E00, 0x44F000, 0x000B45, 0x46F444, 0x000010, 0x21C700, 0x21EE00, 0x44F436, 0x000010, 0x200040, 0x21C400, 0x47F0B0, 0x000B9D, 0x0C1D2E, 0x200040, 0x44F070, 0x000B67, 0x21C741, 0x0C1D06, 0x18B000, 0x000B9E, 0x44F054, 0x000B7A, 0x200044, 0x200074, 0x200003, 0x05F41A, 0x014780, 0x44F000, 0x000B67, 0x0C1C06, 0x21C441, 0x200040, 0x567000, 0x000B67, 0x0140C5, 0x0001FF, 0x05F402, 0x00000C, 0x56F000, 0x000B71, 0x21C441, 0x0C1D06, 0x21C441, 0x200040, 0x567000, 0x000B71, 0x60F400, 0x000B6C, 0x56E000, 0x200044, 0x566000, 0x61F400, 0x000B66, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A501, 0x61F400, 0x000B67, 0x380900, 0x0D0393, 0x56F000, 0x000B70, 0x200003, 0x05F49F, 0x44F400, 0x000001, 0x447000, 0x000B5B, 0x61F413, 0x00001E, 0x566100, 0x380100, 0x0D0393, 0x240000, 0x447000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x56F000, 0x000B5B, 0x014180, 0x567000, 0x000B5B, 0x56F000, 0x000B40, 0x014385, 0x052441, 0x240000, 0x447000, 0x00001E, 0x21EE00, 0x015085, 0x05A40B, 0x44F000, 0x000B5B, 0x200040, 0x21E400, 0x567000, 0x000B5B, 0x61F400, 0x00001E, 0x209800, 0x0D0393, 0x224E00, 0x567000, 0x000B59, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x56F000, 0x000B5B, 0x016080, 0x567000, 0x000B5B, 0x240000, 0x447000, 0x00001E, 0x56F000, 0x000B70, 0x0C1D06, 0x44F000, 0x000B5B, 0x200044, 0x0C1C06, 0x06CC10, 0x00000A, 0x61F400, 0x00001E, 0x380800, 0x0D0393, 0x56F000, 0x000B5B, 0x014880, 0x567000, 0x000B5B, 0x56F000, 0x000B70, 0x0C1D06, 0x44F000, 0x000B5B, 0x200044, 0x61F400, 0x00001E, 0x219800, 0x0D0393, 0x56F000, 0x000B67, 0x44F000, 0x000B70, 0x200044, 0x050C0F, 0x56F000, 0x000B67, 0x2E0003, 0x05F40B, 0x240000, 0x447000, 0x00001E, 0x61F400, 0x00001E, 0x380800, 0x0D0393, 0x56F000, 0x000B67, 0x014184, 0x200003, 0x05A40B, 0x06CC10, 0x000009, 0x200013, 0x567000, 0x000010, 0x61F400, 0x000010, 0x380800, 0x0D0361, 0x000000, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x390100, 0x717000, 0x000002, 0x717000, 0x000003, 0x717000, 0x000004, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00001D, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x70E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x000100, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219500, 0x667000, 0x000B41, 0x0D048B, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A407, 0x380700, 0x60F400, 0x000489, 0x65F400, 0x000B39, 0x0D048B, 0x00000C, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x57F000, 0x000B57, 0x45F000, 0x000B56, 0x240000, 0x447000, 0x00001E, 0x56F000, 0x000B6E, 0x015085, 0x059409, 0x015084, 0x547000, 0x000B6E, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x050FD5, 0x200003, 0x05A405, 0x61F400, 0x00001E, 0x219800, 0x0D0393, 0x200013, 0x567000, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x61F400, 0x000001, 0x380100, 0x0D0393, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x21C400, 0x45F400, 0x000010, 0x2000A0, 0x0C1D2E, 0x44F000, 0x000B9D, 0x200040, 0x567000, 0x000B9D, 0x00000C, 0x56F000, 0x000B40, 0x014085, 0x052410, 0x60F000, 0x000B45, 0x205800, 0x05F020, 0x000B47, 0x56F000, 0x000B58, 0x014184, 0x21D81B, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050CDA, 0x014185, 0x05A403, 0x014285, 0x05240F, 0x60F000, 0x000B45, 0x05F020, 0x000B47, 0x70F01B, 0x000B58, 0x55F000, 0x000B5A, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050CC8, 0x014385, 0x052482, 0x56F000, 0x000B59, 0x44F000, 0x000B45, 0x200044, 0x014180, 0x21D800, 0x209000, 0x05F020, 0x000B47, 0x55F000, 0x000B5A, 0x0D03B3, 0x0C1E91, 0x61F000, 0x000B59, 0x556100, 0x0C1C91, 0x44F000, 0x000B9D, 0x250800, 0x2000A0, 0x44F000, 0x000B9B, 0x21C441, 0x200044, 0x230400, 0x200044, 0x209A00, 0x21D800, 0x56F000, 0x000B59, 0x014180, 0x21D000, 0x0D03CA, 0x56F000, 0x000B59, 0x014180, 0x21D000, 0x0C1E91, 0x556000, 0x0C1C91, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x234400, 0x200044, 0x230400, 0x200044, 0x21D800, 0x56F000, 0x000B45, 0x200040, 0x234400, 0x200040, 0x21D000, 0x20001B, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050C45, 0x014485, 0x05240F, 0x05F020, 0x000B47, 0x60F000, 0x000B45, 0x70F000, 0x000B58, 0x57F000, 0x000B5A, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050C15, 0x014585, 0x052413, 0x05F020, 0x000B47, 0x60F000, 0x000B45, 0x70F000, 0x000B58, 0x57F000, 0x000B5A, 0x0D03B3, 0x56F000, 0x000B55, 0x014184, 0x21D000, 0x0C1E91, 0x556000, 0x0C1C91, 0x05F420, 0x00FFFF, 0x00000C, 0x56F400, 0x000015, 0x57F400, 0x000001, 0x70F400, 0x000390, 0x390000, 0x60F400, 0x000100, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x547000, 0x0000FD, 0x447000, 0x0000FE, 0x607000, 0x0000FF, 0x200003, 0x052410, 0x56F400, 0x00000C, 0x70F400, 0x0005DA, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F000, 0x0000FD, 0x60F000, 0x0000FF, 0x44F000, 0x0000FE, 0x45F403, 0x0005DA, 0x052403, 0x457000, 0x000B48, 0x209800, 0x56F000, 0x000B48, 0x219940, 0x547000, 0x000B48, 0x56F400, 0x000009, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F000, 0x0000FD, 0x014585, 0x052409, 0x56F400, 0x00000C, 0x70F400, 0x000122, 0x71F400, 0x000ADE, 0x0BF080, 0x000180, 0x56F400, 0x000019, 0x57F400, 0x000002, 0x390000, 0x70F400, 0x000080, 0x60F400, 0x000B40, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000019, 0x57F400, 0x000000, 0x70F400, 0x000080, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\ac97xmo.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ac97xmo.cpp
 *  Content:    AC97 direct-access media object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/05/01    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"


/****************************************************************************
 *
 *  CAc97MediaObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::CAc97MediaObject"

DWORD CAc97MediaObject::m_dwGlobalRefCount = 0;
CAc97Device *CAc97MediaObject::m_pDevice = NULL;

CAc97MediaObject::CAc97MediaObject
(
    void
)
{
    DPF_ENTER();

    InitializeListHead(&m_lstPending);
    InitializeListHead(&m_lstFree);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CAc97MediaObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::~CAc97MediaObject"

CAc97MediaObject::~CAc97MediaObject
(
    void
)
{
    DPF_ENTER();

    //
    // Flush any remaining packets
    //

    Flush();

    //
    // Free the channel
    //

    RELEASE(m_pChannel);

    //
    // Free resources
    //

    MEMFREE(m_paPackets);

    //
    // Release the shared stuff
    //

    ASSERT(m_dwGlobalRefCount);
    
    if(!--m_dwGlobalRefCount)
    {
        DELETE(m_pDevice);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: channel type.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::Initialize"

HRESULT
CAc97MediaObject::Initialize
(
    DWORD                       dwChannel,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback, 
    LPVOID                      pvCallbackContext
)
{
    HRESULT                     hr              = DS_OK;
    AC97CHANNELTYPE             nChannelType;
    DWORD                       i;
    
    DPF_ENTER();

    m_pfnCallback = pfnCallback;
    m_pvCallbackContext = pvCallbackContext;

    //
    // Set up data shared between all instances of the AC97 XMO
    //

    if(!m_dwGlobalRefCount++)
    {
        ASSERT(!m_pDevice);

        hr = HRFROMP(m_pDevice = NEW(CAc97Device));

        if(SUCCEEDED(hr))
        {
            hr = m_pDevice->Initialize();
        }
    }
    else
    {
        ASSERT(m_pDevice);
    }

    //
    // Create the audio channel
    //

    if(SUCCEEDED(hr))
    {
        switch(dwChannel)
        {
            case DSAC97_CHANNEL_ANALOG:
                nChannelType = AC97_CHANNELTYPE_ANALOG;
                break;

            case DSAC97_CHANNEL_DIGITAL:
                nChannelType = AC97_CHANNELTYPE_DIGITAL;
                break;

            default:
                ASSERTMSG("Invalid channel type");
                break;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(m_pDevice->m_apChannels[nChannelType])
        {
            DPF_ERROR("Channel already open");
            hr = DSERR_INVALIDCALL;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDevice->CreateChannel(nChannelType, &m_pChannel);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pChannel->Initialize(AC97CHANNEL_OBJECTF_STREAM, InterruptCallback, this);
    }

    //
    // Allocate packet data
    //

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_paPackets = MEMALLOC(AC97PACKET, DSAC97_MAX_ATTACHED_PACKETS));
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < DSAC97_MAX_ATTACHED_PACKETS; i++)
        {
            InsertTailListUninit(&m_lstFree, &m_paPackets[i].leListEntry);
        }
    }

    //
    // Set the initial status
    //

    if(SUCCEEDED(hr))
    {
        m_dwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the object supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [in/out]: info data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::GetInfo"

HRESULT
CAc97MediaObject::GetInfo
(
    LPXMEDIAINFO            pInfo
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pInfo)
    {
        DPF_ERROR("XMO info buffer not supplied");
    }

#endif // VALIDATE_PARAMETERS

    ZeroMemory(pInfo, sizeof(*pInfo));

    //
    // Flags are easy
    //
    
    pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC;

    //
    // Input size is just sample-aligment, since that's the smallest amount of
    // data we require to process.
    //

    pInfo->dwInputSize = m_pDevice->m_wfxFormat.nBlockAlign;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Resets the stream to it's default state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::Flush"

HRESULT
CAc97MediaObject::Flush
(
    void
)                                       
{                                           
    PLIST_ENTRY             plePacket;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    //
    // Reset the channel
    //
    
    if(m_pChannel)
    {
        m_pChannel->Flush();
    }

    //
    // Reset our internal packet list
    //

    while((plePacket = m_lstPending.Flink) != &m_lstPending)
    {
        MoveEntryTailList(&m_lstFree, plePacket);
        
        CompletePacket(CONTAINING_RECORD(plePacket, AC97PACKET, leListEntry), XMEDIAPACKET_STATUS_FLUSHED);
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets stream status.
 *
 *  Arguments:
 *      LPDWORD [out]: stream status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::GetStatus"

HRESULT
CAc97MediaObject::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwStatus)
    {
        DPF_ERROR("Status buffer not supplied");
    }

#endif // VALIDATE_PARAMETERS

    *pdwStatus = m_dwStatus;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Submits buffers to the stream.
 *
 *  Arguments:
 *      LPXMEDIAPACKET  [in]: input buffer.
 *      LPXMEDIAPACKET  [in]: output buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::Process"

HRESULT
CAc97MediaObject::Process
(
    LPCXMEDIAPACKET         pxmbSource, 
    LPCXMEDIAPACKET         pxmbDest 
)
{
    HRESULT                 hr                      = DS_OK;
    PLIST_ENTRY             plePacket;
    LPAC97PACKET            pPacket;
    CIrql                   irql;

#ifdef VALIDATE_PARAMETERS

    DWORD                   dwBasePhysicalAddress;
    DWORD                   dwContiguousLength;
    DWORD                   dwPhysicalAddress;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pxmbSource)
    {
        DPF_ERROR("No input buffer supplied");
    }

    if(!pxmbSource->pvBuffer)
    {
        DPF_ERROR("No input data buffer supplied");
    }

    if(!pxmbSource->dwMaxSize)
    {
        DPF_ERROR("No input buffer size");
    }

    if(pxmbSource->dwMaxSize % m_pDevice->m_wfxFormat.nBlockAlign)
    {
        DPF_ERROR("Input buffer size not block-aligned");
    }

    if(pxmbSource->dwMaxSize > 131068)
    {
        DPF_ERROR("Input buffers are restricted to 131068 bytes or less");
    }

    if(pxmbDest)
    {
        DPF_ERROR("AC97 streams are input only");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Get a packet from the free list and add it to the pending list
    //

    irql.Raise();
    
    if((plePacket = MoveHeadTailList(&m_lstPending, &m_lstFree)) == &m_lstFree)
    {
        DPF_ERROR("No free packets");
        hr = DSERR_INVALIDCALL;
    }

    //
    // Initialize the packet data and add it to the pending list
    //

    if(SUCCEEDED(hr))
    {
        pPacket = CONTAINING_RECORD(plePacket, AC97PACKET, leListEntry);
        
        pPacket->xmp = *pxmbSource;

        XMOAcceptPacket(&pPacket->xmp);

        DPF_BLAB("Accepted packet %x", pPacket);
    }

    irql.Lower();

    //
    // Lock packet data
    //

    if(SUCCEEDED(hr))
    {
        MmLockUnlockBufferPages(pPacket->xmp.pvBuffer, pPacket->xmp.dwMaxSize, FALSE);

#ifdef VALIDATE_PARAMETERS

        dwBasePhysicalAddress = MmGetPhysicalAddress(pxmbSource->pvBuffer);
        dwContiguousLength = PAGE_SIZE - BYTE_OFFSET(pxmbSource->pvBuffer); 

        while(dwContiguousLength < pxmbSource->dwMaxSize)
        {
            dwPhysicalAddress = MmGetPhysicalAddress((LPBYTE)pxmbSource->pvBuffer + dwContiguousLength);
            ASSERT(!(dwPhysicalAddress & (PAGE_SIZE - 1)));

            if(dwBasePhysicalAddress + dwContiguousLength != dwPhysicalAddress)
            {
                DPF_ERROR("Packet data submitted to the AC97 XMO must be physically contiguous.  Use XPhysicalAlloc");
                break;
            }

            dwContiguousLength += PAGE_SIZE;
        }

#endif // VALIDATE_PARAMETERS

    }

    //
    // Send the packet to the channel
    //

    if(SUCCEEDED(hr))
    {
        m_pChannel->AttachPacket(pPacket->xmp.pvBuffer, pPacket->xmp.dwMaxSize);
    }

    //
    // Signal a discontinuity to the channel.  This will prevent the channel
    // from playing crap if the stream starves.  It's really low overhead to
    // do this, so better safe than sorry.  As a side effect of this, the
    // AC97 channel will never complain about being starved.  Oh well.
    //

    if(SUCCEEDED(hr))
    {
        m_pChannel->Discontinuity();
    }

    //
    // Start the channel running
    //

    if(SUCCEEDED(hr))
    {
        m_pChannel->Run();
    }

    //
    // Update the status
    //

    if(SUCCEEDED(hr) && IsListEmpty(&m_lstFree))
    {
        ASSERT(XMO_STATUSF_ACCEPT_INPUT_DATA == m_dwStatus);

        m_dwStatus = 0;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CompletePendingPackets
 *
 *  Description:
 *      Completes all packets in the pending list that have been played.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::CompletePendingPackets"

void
CAc97MediaObject::CompletePendingPackets
(
    void
)
{
    PLIST_ENTRY             plePacket;
    LPAC97PACKET            pPacket;
    CIrql                   irql;
    
    DPF_ENTER();

    //
    // Complete the first packet in the list
    //

    irql.Raise();

    if((plePacket = MoveHeadTailList(&m_lstFree, &m_lstPending)) != &m_lstPending)
    {
        pPacket = CONTAINING_RECORD(plePacket, AC97PACKET, leListEntry);
    }
    else
    {
        pPacket = NULL;
    }

    irql.Lower();

    if(pPacket)
    {
        CompletePacket(pPacket, XMEDIAPACKET_STATUS_SUCCESS);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CompletePacket
 *
 *  Description:
 *      Marks a packet as complete.
 *
 *  Arguments:
 *      LPAC97PACKET [in]: packet.
 *      DWORD [in]: status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::CompletePacket"

void
CAc97MediaObject::CompletePacket
(
    LPAC97PACKET            pPacket,
    DWORD                   dwStatus
)
{
    DPF_ENTER();

    DPF_BLAB("Completing packet %x", pPacket);

    //
    // Unlock packet data
    //

    MmLockUnlockBufferPages(pPacket->xmp.pvBuffer, pPacket->xmp.dwMaxSize, TRUE);

    //
    // Update the status to reflect the fact that we have at least one
    // free packet.
    //

    ASSERT(!IsListEmpty(&m_lstFree));
    
    m_dwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA;

    //
    // Finalize completion
    //

    XMOCompletePacket(&pPacket->xmp, pPacket->xmp.dwMaxSize, m_pfnCallback, m_pvCallbackContext, dwStatus);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the channel mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::SetMode"

HRESULT
CAc97MediaObject::SetMode
(
    DWORD                   dwMode
)
{
    HRESULT                 hr              = DS_OK;
    DWORD                   dwSpeakerConfig;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((DSAC97_MODE_PCM != dwMode) && (DSAC97_MODE_ENCODED != dwMode))
    {
        DPF_ERROR("Invalid channel mode");
    }

    if((AC97_CHANNELTYPE_ANALOG == m_pChannel->m_nChannelType) && (DSAC97_MODE_ENCODED == dwMode))
    {
        DPF_ERROR("The analog channel can only output PCM data");
    }

#endif // VALIDATE_PARAMETERS

    if(DSAC97_MODE_PCM != dwMode)
    {
        dwSpeakerConfig = XAudioGetSpeakerConfig();

        if(!(dwSpeakerConfig & DSSPEAKER_ENCODED_VALID))
        {
            DPF_ERROR("Encoded output not enabled");
            hr = DSERR_INVALIDCALL;
        }
    }
    
    if(SUCCEEDED(hr))
    {
        m_pChannel->SetMode(dwMode);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current stream position.
 *
 *  Arguments:
 *      LPDWORD [out]: stream position.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::GetCurrentPosition"

HRESULT
CAc97MediaObject::GetCurrentPosition
(
    LPDWORD                 pdwPosition
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwPosition)
    {
        DPF_ERROR("Failed to supply a position buffer");
    }

#endif // VALIDATE_PARAMETERS

    *pdwPosition = m_pChannel->GetPosition();

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\AC3SuperExec.h ===
0x050C08, 
0x000000, 
0x000001, 
0x000001, 
0x000000, 
0x000000, 
0xCCCCCC, 
0x000000, 
0x240000, 
0x077084, 
0x000004, 
0x077084, 
0x000005, 
0x07F432, 
0xFFFFFF, 
0x07F430, 
0x000001, 
0x07F431, 
0x000001, 
0x0500BB, 
0x05F42A, 
0x000BE0, 
0x0520B8, 
0x0AFA74, 
0x200013, 
0x077088, 
0x000001, 
0x000008, 
0x077088, 
0x000002, 
0x077088, 
0x000003, 
0x56F400, 
0x000000, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x0000A2, 
0x08F485, 
0x000002, 
0x07F08E, 
0x000007, 
0x014180, 
0x07708E, 
0x000007, 
0x08F484, 
0x000001, 
0x200013, 
0x014180, 
0x0A8581, 
0x000031, 
0x44F000, 
0xFFFFB3, 
0x077084, 
0x000005, 
0x08F485, 
0x000002, 
0x07F08E, 
0x000001, 
0x60F403, 
0x000BC0, 
0x052409, 
0x56F400, 
0x00000A, 
0x382000, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000082, 
0x56F000, 
0x000BC1, 
0x60F403, 
0x000300, 
0x05A412, 
0x56F400, 
0x000001, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000076, 
0x07F08F, 
0x000002, 
0x60F400, 
0x000BC0, 
0x0BF080, 
0x000304, 
0x240000, 
0x077084, 
0x000002, 
0x050C1C, 
0x57F000, 
0x000BC3, 
0x60F40B, 
0x000300, 
0x05A417, 
0x44F413, 
0x000005, 
0x0140CD, 
0x000001, 
0x202A41, 
0x44F400, 
0x000006, 
0x0140CD, 
0x000002, 
0x202A41, 
0x200003, 
0x05A40B, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000056, 
0x60F400, 
0x000BC0, 
0x0BF080, 
0x000304, 
0x050C01, 
0x56F000, 
0x000BC2, 
0x60F403, 
0x000300, 
0x05A44F, 
0x56F400, 
0x000002, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000045, 
0x60F400, 
0x000BC0, 
0x07F08F, 
0x000003, 
0x07F084, 
0x000001, 
0x0BF080, 
0x000304, 
0x60F400, 
0x000300, 
0x56F400, 
0x000003, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000034, 
0x07F08F, 
0x000003, 
0x0BF080, 
0x000304, 
0x60F400, 
0x000300, 
0x56F400, 
0x000004, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000027, 
0x07F08F, 
0x000003, 
0x07F084, 
0x000001, 
0x0BF080, 
0x000304, 
0x240000, 
0x077084, 
0x000003, 
0x07F08E, 
0x000001, 
0x014180, 
0x014685, 
0x202113, 
0x07708C, 
0x000001, 
0x56F400, 
0x00000B, 
0x0BF080, 
0x000180, 
0x56F000, 
0xFFFFB3, 
0x07F084, 
0x000005, 
0x200044, 
0x07708C, 
0x000004, 
0x44F400, 
0x0ACDA0, 
0x0C1FF8, 
0x0596C9, 
0x44F400, 
0xBBBBBB, 
0x077084, 
0x000006, 
0x050C00, 
0x050EC3, 
0x050EC2,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\cipher.cpp ===
#include "dsoundi.h"
#include "..\tools\xcodescr\cipher.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\ac97xmo.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ac97xmo.h
 *  Content:    AC97 direct-access media object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/05/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __AC97XMO_H__
#define __AC97XMO_H__

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY      leListEntry;
    XMEDIAPACKET    xmp;
END_DEFINE_STRUCT(AC97PACKET);

#ifdef __cplusplus

//
// AC'97 XMO
//

namespace DirectSound
{

#ifdef VALIDATE_PARAMETERS

    class CAc97MediaObject
        : public XAc97MediaObject, CValidObject<'AC97'>, public CRefCount

#else // VALIDATE_PARAMETERS

    class CAc97MediaObject
        : public XAc97MediaObject, public CRefCount

#endif // VALIDATE_PARAMETERS

    {
    protected:
        static DWORD                m_dwGlobalRefCount;     // Shared reference count
        static CAc97Device *        m_pDevice;              // Shared AC97 device object
                                                        
    protected:                                              
        CAc97Channel *              m_pChannel;             // AC97 channel object
        LIST_ENTRY                  m_lstPending;           // Pending packet list
        LIST_ENTRY                  m_lstFree;              // Free packet list
        LPFNXMEDIAOBJECTCALLBACK    m_pfnCallback;          // Callback function
        LPVOID                      m_pvCallbackContext;    // Callback context
        LPAC97PACKET                m_paPackets;            // Packet pool
        DWORD                       m_dwStatus;             // XMO status

    public:
        CAc97MediaObject(void);
        virtual ~CAc97MediaObject(void);

    public:
        // Initialization
        virtual HRESULT STDMETHODCALLTYPE Initialize(DWORD dwChannel, LPFNXMEDIAOBJECTCALLBACK pfnCallback, LPVOID pvCallbackContext);
    
        // IUnknown methods
        virtual ULONG STDMETHODCALLTYPE AddRef(void);
        virtual ULONG STDMETHODCALLTYPE Release(void);

        // XMediaObject methods
        virtual HRESULT STDMETHODCALLTYPE GetInfo(LPXMEDIAINFO pInfo);
        virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
        virtual HRESULT STDMETHODCALLTYPE Process(LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket);
        virtual HRESULT STDMETHODCALLTYPE Discontinuity(void);
        virtual HRESULT STDMETHODCALLTYPE Flush(void);

        // XAc97MediaObject methods
        virtual HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode);
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD pdwPosition);

    protected:
        // Packet completion
        void CompletePendingPackets(void);
        void CompletePacket(LPAC97PACKET pPacket, DWORD dwStatus);
    
    private:
        // Event handlers
        static void CALLBACK InterruptCallback(LPVOID pvContext);
    };

    __inline ULONG CAc97MediaObject::AddRef(void)
    {
        _ENTER_EXTERNAL_METHOD("CAc97MediaObject::AddRef");
        return CRefCount::AddRef();
    }

    __inline ULONG CAc97MediaObject::Release(void)
    {
        _ENTER_EXTERNAL_METHOD("CAc97MediaObject::Release");
        return CRefCount::Release();
    }

    __inline HRESULT CAc97MediaObject::Discontinuity(void)
    {
        return DS_OK;
    }

    __inline void CAc97MediaObject::InterruptCallback(LPVOID pvContext)
    {
        ((CAc97MediaObject *)pvContext)->CompletePendingPackets();
    }
}

#endif // __cplusplus

#endif // __AC97XMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsapi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsapi.h
 *  Content:    DirectSound API objects and entry points.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/06/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __DSAPI_H__
#define __DSAPI_H__

// #define USE_KEEPALIVE_BUFFERS 1
#define USE_KEEPALIVE_BUFFERS 4

// #define DSAPI_DISABLE_SUBMIX
// #define DSAPI_DISABLE_EFFECTS
// #define DSAPI_DISABLE_LISTENER
// #define DSAPI_DISABLE_3DSOURCE
// #define DSAPI_DISABLE_MIXBINS
// #define DSAPI_DISABLE_VOLUME
// #define DSAPI_DISABLE_PITCH
// #define DSAPI_DISABLE_FILTER
// #define DSAPI_DISABLE_LFO
// #define DSAPI_DISABLE_EG
// #define DSAPI_DISABLE_NOTEOFF

#ifdef DEBUG
#define DS3D_ALLOW_ALGORITHM_SWAP
#endif // DEBUG

//
// Global critical section
//

__inline BOOL DirectSoundEnterCriticalSection(void)
{
    if(PASSIVE_LEVEL != KeGetCurrentIrql())
    {
        return FALSE;
    }

    EnterCriticalSection(&g_DirectSoundCriticalSection); 

    return TRUE;
}

__inline void DirectSoundLeaveCriticalSection(void)
{
    LeaveCriticalSection(&g_DirectSoundCriticalSection);
}

#ifdef __cplusplus

//
// Forward declarations
//

namespace DirectSound
{
    class CMcpxAPU;
    class CMcpxVoiceClient;
    class CMcpxBuffer;
    class CMcpxStream;
}

//
// Validation object and corresponding macros
//

#ifdef VALIDATE_PARAMETERS

namespace DirectSound
{
    template <DWORD dwSignature> class CValidObject
    {
    private:
        const DWORD             m_dwSignature;      // Object signature

    public:
        CValidObject(void);
        virtual ~CValidObject(void);

    public:
        void __AssertValidObject(LPCSTR pszFile, DWORD dwLine, LPCSTR pszFunction);
    };

    template <DWORD dwSignature> CValidObject<dwSignature>::CValidObject(void)
        : m_dwSignature(dwSignature)
    {
    }

    template <DWORD dwSignature> CValidObject<dwSignature>::~CValidObject(void)
    {
    }

    template <DWORD dwSignature> void CValidObject<dwSignature>::__AssertValidObject(LPCSTR pszFile, DWORD dwLine, LPCSTR pszFunction)
    {
        if(!this)
        {
            DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_ERROR, pszFile, dwLine, pszFunction, DPF_LIBRARY);
            DirectSound::CDebug::Print("NULL \"this\" pointer (%x)", this);
        }
        else if(m_dwSignature != dwSignature)
        {
            DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_ERROR, pszFile, dwLine, pszFunction, DPF_LIBRARY);
            DirectSound::CDebug::Print("Invalid \"this\" pointer (%x != %x)", m_dwSignature, dwSignature);
        }
    }
}

#define _AssertValidObject(fname) \
    __AssertValidObject(__FILE__, __LINE__, fname)

#define AssertValidObject() \
    _AssertValidObject(DPF_FNAME)

#else // VALIDATE_PARAMETERS

#define _AssertValidObject(fname)
#define AssertValidObject()

#endif // VALIDATE_PARAMETERS

//
// Automatic (functon-scope) locking mechanism
//

namespace DirectSound
{
    class CAutoLock
    {
    private:
        BOOL                    m_fLocked;

    public:
        CAutoLock(void);
        ~CAutoLock(void);
    };

    __inline CAutoLock::CAutoLock(void)
    {
        m_fLocked = (BOOLEAN)DirectSoundEnterCriticalSection();
    }

    __inline CAutoLock::~CAutoLock(void)
    {
        if(m_fLocked)
        {
            DirectSoundLeaveCriticalSection();
        }
    }
}

#define AutoLock() \
    DirectSound::CAutoLock __AutoLock

//
// API helper macros
//

#define CHECK_FINAL_RELEASE_HRESULT() \
    if(g_fDirectSoundInFinalRelease) \
    { \
        DPF_WARNING("DirectSound is in the final stages of shutting down.  No more API calls are allowed."); \
        return DSERR_GENERIC; \
    }

#define CHECK_FINAL_RELEASE_VOID() \
    if(g_fDirectSoundInFinalRelease) \
    { \
        DPF_WARNING("DirectSound is in the final stages of shutting down.  No more API calls are allowed."); \
        return; \
    }

#define ENTER_EXTERNAL_FUNCTION() \
    AutoLock()

#define _ENTER_EXTERNAL_METHOD(name) \
    AutoLock(); \
    CHECK_FINAL_RELEASE_HRESULT(); \
    _AssertValidObject(name)

#define _ENTER_EXTERNAL_METHOD_VOID(name) \
    AutoLock(); \
    CHECK_FINAL_RELEASE_VOID(); \
    _AssertValidObject(name)

#define ENTER_EXTERNAL_METHOD() \
    _ENTER_EXTERNAL_METHOD(DPF_FNAME)

#define ENTER_EXTERNAL_METHOD_VOID() \
    _ENTER_EXTERNAL_METHOD_VOID(DPF_FNAME)

//
// DirectSound settings
//

namespace DirectSound
{
    class CDirectSoundSettings
        : public CRefCount
    {
    public:
        DWORD               m_dwSpeakerConfig;                      // Speaker configuration
        DSEFFECTIMAGELOC    m_EffectLocations;                      // Effect locations
        BYTE                m_abMixBinHeadroom[DSMIXBIN_COUNT];     // MixBin headroom

    #ifndef MCPX_BOOT_LIB                                           
                                                                
        DS3DLISTENERPARAMS  m_3dParams;                             // 3D parameters

    #endif // MCPX_BOOT_LIB

    public:
        CDirectSoundSettings(void);
        virtual ~CDirectSoundSettings(void);

    public:
        void SetEffectImageLocations(LPCDSEFFECTIMAGELOC pImageLoc);
    };
}

//
// DirectSound implementation
//

namespace DirectSound
{

#ifdef VALIDATE_PARAMETERS

    class CDirectSound
        : public IDirectSound, public CValidObject<'DSND'>, public CRefCount

#else // VALIDATE_PARAMETERS

    class CDirectSound
        : public IDirectSound, public CRefCount

#endif // VALIDATE_PARAMETERS

    {
        friend class CDirectSoundVoice;
        friend class CDirectSoundBuffer;
        friend class CDirectSoundStream;
        friend class CPerfMon;

    public:
        static CDirectSound *       m_pDirectSound;                                 // The one-and-only DirectSound object
                                                                                
    #ifdef DEBUG                                                                    
                                                                                
        static LPVOID               m_pvEncoderImageData;                           // Encoder image data
        static DWORD                m_dwEncoderImageSize;                           // Encoder image size, in bytes
                                                                                
    #endif // DEBUG                                                                 
                                                                                
    protected:                                                                      
        CDirectSoundSettings *      m_pSettings;                                    // Shared settings object
        CMcpxAPU *                  m_pDevice;                                      // Device implementation
        LIST_ENTRY                  m_lst3dVoices;                                  // 3D voice list

    #ifdef USE_KEEPALIVE_BUFFERS

        LPDIRECTSOUNDBUFFER         m_apKeepAliveBuffers[USE_KEEPALIVE_BUFFERS];    // Dummy buffers used to keep the mixbins working

    #endif // USE_KEEPALIVE_BUFFERS

    public:
        CDirectSound(void);
        virtual ~CDirectSound(void);

    public:
        // Initialization
        HRESULT STDMETHODCALLTYPE Initialize(void);

        // IUnknown methods
        ULONG STDMETHODCALLTYPE AddRef(void);
        ULONG STDMETHODCALLTYPE Release(void);

        // IDirectSound methods
        HRESULT STDMETHODCALLTYPE GetCaps(LPDSCAPS pdsc);
        HRESULT STDMETHODCALLTYPE CreateSoundBuffer(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter);
        HRESULT STDMETHODCALLTYPE CreateSoundStream(LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter);
        HRESULT STDMETHODCALLTYPE GetSpeakerConfig(LPDWORD pdwSpeakerConfig);
        HRESULT STDMETHODCALLTYPE DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPCDSEFFECTIMAGELOC pImageLoc, LPDSEFFECTIMAGEDESC *ppImageDesc);
        HRESULT STDMETHODCALLTYPE GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize);
        HRESULT STDMETHODCALLTYPE SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE CommitEffectData(void);
        HRESULT STDMETHODCALLTYPE EnableHeadphones(BOOL fEnable);
        HRESULT STDMETHODCALLTYPE SetMixBinHeadroom(DWORD dwMixBin, DWORD dwHeadroom);
        HRESULT STDMETHODCALLTYPE GetOutputLevels(DSOUTPUTLEVELS *pOutputLevels, BOOL bReset);

        // IDirectSound3dListener methods
        HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DLISTENER pds3dl, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetOrientation(FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetI3DL2Listener(LPCDSI3DL2LISTENER pProperties, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE CommitDeferredSettings(void);

        // IReferenceClock methods
        HRESULT STDMETHODCALLTYPE GetTime(REFERENCE_TIME *prtCurrent);


        // Work, work, work
        void STDMETHODCALLTYPE DoWork(void);

        // 3D
        void STDMETHODCALLTYPE Force3dRecalc(DWORD dwParameterMask = -1);
    };

    __inline ULONG CDirectSound::AddRef(void)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSound::AddRef");
        return CRefCount::AddRef();
    }

#ifndef USE_KEEPALIVE_BUFFERS

    __inline ULONG CDirectSound::Release(void)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSound::Release");
        return CRefCount::Release();
    }

#endif // USE_KEEPALIVE_BUFFERS

#ifndef MCPX_BOOT_LIB

    __inline void CDirectSound::Force3dRecalc(DWORD dwParameterMask)
    {
        m_pSettings->m_3dParams.dwParameterMask |= dwParameterMask;

        CommitDeferredSettings();
    }

#endif // MCPX_BOOT_LIB

}

//
// DirectSound Voice settings
//

namespace DirectSound
{
    class CDirectSoundVoiceSettings
        : public CRefCount
    {
    public:
        DWORD                       m_dwFlags;                          // Voice creation flags
        DSWAVEFORMAT                m_fmt;                              // Voice format
        LONG                        m_lPitch;                           // Voice pitch
        LONG                        m_lVolume;                          // Voice volume
        DWORD                       m_dwHeadroom;                       // Voice headroom
        DWORD                       m_dwMixBinCount;                    // MixBin count
        BYTE                        m_abMixBins[8];                     // MixBin assignments
        LONG                        m_alMixBinVolumes[DSMIXBIN_COUNT];  // MixBin volumes
        CDirectSoundBuffer *        m_pMixinBuffer;                     // Destination buffer for a submix operation
                                                                    
#ifndef MCPX_BOOT_LIB                                               
                                                                    
        LPDS3DSOURCEPARAMS          m_p3dParams;                        // 3D parameters

#endif // MCPX_BOOT_LIB

    public:
        CDirectSoundVoiceSettings(void);
        virtual ~CDirectSoundVoiceSettings(void);

    public:
        // Initialization
        HRESULT Initialize(DWORD dwFlags, LPCWAVEFORMATEX pwfxFormat, LPCDSMIXBINS pMixBins);

        // Format
        BOOL SetFormat(LPCWAVEFORMATEX pwfxFormat, BOOL fAllowMixBins);
    
        // Volume
        void SetVolume(LONG lVolume);
        void SetMixBinVolumes(LPCDSMIXBINS pMixBins);
        void SetHeadroom(DWORD dwHeadroom);

        // Mixbins
        void SetMixBins(LPCDSMIXBINS pMixBins);

        // Submixing
        void SetOutputBuffer(CDirectSoundBuffer *pMixinBuffer);
    };
}

//
// DirectSound Voice base class
//

namespace DirectSound
{
    class CDirectSoundVoice
        : public CRefCount
    {
    public:
        CDirectSound *              m_pDirectSound;     // Parent object
        CMcpxVoiceClient *          m_pVoice;           // Voice implementation
        CDirectSoundVoiceSettings * m_pSettings;        // Voice settings
        LIST_ENTRY                  m_le3dVoice;        // 3D voice list entry

    public:
        CDirectSoundVoice(CDirectSound *pDirectSound);
        virtual ~CDirectSoundVoice(void);

    public:
        // Initialization
        void STDMETHODCALLTYPE Initialize(CMcpxVoiceClient *pVoice, CDirectSoundVoiceSettings *pSettings);
    
        // IDirectSoundBuffer methods
        HRESULT STDMETHODCALLTYPE SetFormat(LPCWAVEFORMATEX pwfxFormat);
        HRESULT STDMETHODCALLTYPE SetVolume(LONG lVolume);
        HRESULT STDMETHODCALLTYPE SetFrequency(DWORD dwFrequency);
        HRESULT STDMETHODCALLTYPE SetPitch(LONG lPitch);
        HRESULT STDMETHODCALLTYPE SetLFO(LPCDSLFODESC pLFODesc);
        HRESULT STDMETHODCALLTYPE SetEG(LPCDSENVELOPEDESC pEnvelopeDesc);
        HRESULT STDMETHODCALLTYPE SetFilter(LPCDSFILTERDESC pFilterDesc);
        HRESULT STDMETHODCALLTYPE SetHeadroom(DWORD dwHeadroom);
        HRESULT STDMETHODCALLTYPE SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer);
        HRESULT STDMETHODCALLTYPE SetMixBins(LPCDSMIXBINS pMixBins);
        HRESULT STDMETHODCALLTYPE SetMixBinVolumes(LPCDSMIXBINS pMixBins);

        // IDirectSound3dBuffer methods
        HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMaxDistance(FLOAT flMaxDistance, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMinDistance(FLOAT flMinDistance, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetRolloffCurve(const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply);
        HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE CommitDeferredSettings(void);
    };
}

//
// DirectSound Buffer settings
//

namespace DirectSound
{
    class CDirectSoundBufferSettings
        : public CDirectSoundVoiceSettings
    {
    public:
        static const WAVEFORMATEX   m_wfxMixDest;           // Submix destination format

    public:
        LPVOID                      m_pvBufferData;         // Buffer audio data
        DWORD                       m_dwBufferSize;         // Buffer audio data size, in bytes
        DWORD                       m_dwPlayStart;          // Play region starting position, in bytes
        DWORD                       m_dwPlayLength;         // Play region length, in bytes
        DWORD                       m_dwLoopStart;          // Loop region starting position, in bytes
        DWORD                       m_dwLoopLength;         // Loop region length, in bytes
        DWORD                       m_dwInputMixBin;        // Submix input mixbin
        LPDSBPOSITIONNOTIFY         m_paNotifies;           // Notification array
        DWORD                       m_dwNotifyCount;        // Count of items in the above array

    public:
        CDirectSoundBufferSettings(void);
        virtual ~CDirectSoundBufferSettings(void);

    public:
        // Initialization
        HRESULT Initialize(LPCDSBUFFERDESC pdsbd);

        // Buffer data
        HRESULT SetBufferData(LPVOID pvBufferData, DWORD dwBufferSize);
        void SetPlayRegion(DWORD dwPlayStart, DWORD dwPlayLength);
        void SetLoopRegion(DWORD dwLoopStart, DWORD dwLoopLength);

        // Notifications
        HRESULT SetNotificationPositions(DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies);
    };
}

//
// DirectSound Buffer
//

namespace DirectSound
{

#ifdef VALIDATE_PARAMETERS

    class CDirectSoundBuffer
        : public IDirectSoundBuffer, public CValidObject<'DSB '>, public CDirectSoundVoice

#else // VALIDATE_PARAMETERS

    class CDirectSoundBuffer
        : public IDirectSoundBuffer, public CDirectSoundVoice

#endif // VALIDATE_PARAMETERS

    {
        friend class CDirectSound;
        friend class CDirectSoundVoice;

    public:
        CDirectSoundBufferSettings *    m_pSettings;            // Buffer settings
        CMcpxBuffer *                   m_pBuffer;              // Buffer implementation

    public:
        CDirectSoundBuffer(CDirectSound *pDirectSound);
        virtual ~CDirectSoundBuffer(void);

    public:
        // Initialization
        HRESULT STDMETHODCALLTYPE Initialize(LPCDSBUFFERDESC pdsbd);
    
        // IUnknown methods
        ULONG STDMETHODCALLTYPE AddRef(void);
        ULONG STDMETHODCALLTYPE Release(void);

        // IDirectSoundBuffer methods
        HRESULT STDMETHODCALLTYPE SetFormat(LPCWAVEFORMATEX pwfxFormat);
        HRESULT STDMETHODCALLTYPE Play(DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE PlayEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE Stop(void);
        HRESULT STDMETHODCALLTYPE StopEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetPlayRegion(DWORD dwPlayStart, DWORD dwPlayLength);
        HRESULT STDMETHODCALLTYPE SetLoopRegion(DWORD dwLoopStart, DWORD dwLoopLength);
        HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
        HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor);
        HRESULT STDMETHODCALLTYPE SetCurrentPosition(DWORD dwPlayCursor);
        HRESULT STDMETHODCALLTYPE SetBufferData(LPVOID pvBufferData, DWORD dwBufferBytes);
        HRESULT STDMETHODCALLTYPE Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetFrequency(DWORD dwFrequency);
        HRESULT STDMETHODCALLTYPE SetVolume(LONG lVolume);
        HRESULT STDMETHODCALLTYPE SetPitch(LONG lPitch);
        HRESULT STDMETHODCALLTYPE SetLFO(LPCDSLFODESC pLFODesc);
        HRESULT STDMETHODCALLTYPE SetEG(LPCDSENVELOPEDESC pEnvelopeDesc);
        HRESULT STDMETHODCALLTYPE SetFilter(LPCDSFILTERDESC pFilterDesc);
        HRESULT STDMETHODCALLTYPE SetHeadroom(DWORD dwHeadroom);
        HRESULT STDMETHODCALLTYPE SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer);
        HRESULT STDMETHODCALLTYPE SetMixBins(LPCDSMIXBINS pMixBins);
        HRESULT STDMETHODCALLTYPE SetMixBinVolumes(LPCDSMIXBINS pMixBins);

        // IDirectSound3dBuffer methods
        HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMaxDistance(FLOAT flMaxDistance, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMinDistance(FLOAT flMinDistance, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetRolloffCurve(const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply);
        HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwFlags);

        // IDirectSoundNotify methods
        HRESULT STDMETHODCALLTYPE SetNotificationPositions(DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies);
    };    

    __inline ULONG CDirectSoundBuffer::AddRef(void)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::AddRef");
        return CRefCount::AddRef();
    }

    __inline ULONG CDirectSoundBuffer::Release(void)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::Release");
        return CRefCount::Release();
    }

    __inline HRESULT CDirectSoundBuffer::SetFormat(LPCWAVEFORMATEX pwfxFormat)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetFormat");
        return CDirectSoundVoice::SetFormat(pwfxFormat);
    }

    __inline HRESULT CDirectSoundBuffer::SetFrequency(DWORD dwFrequency)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetFrequency");
        return CDirectSoundVoice::SetFrequency(dwFrequency);
    }

    __inline HRESULT CDirectSoundBuffer::SetVolume(LONG lVolume)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetVolume");
        return CDirectSoundVoice::SetVolume(lVolume);
    }

    __inline HRESULT CDirectSoundBuffer::SetPitch(LONG lPitch)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetPitch");
        return CDirectSoundVoice::SetPitch(lPitch);
    }

    __inline HRESULT CDirectSoundBuffer::SetLFO(LPCDSLFODESC pLFODesc)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetLFO");
        return CDirectSoundVoice::SetLFO(pLFODesc);
    }

    __inline HRESULT CDirectSoundBuffer::SetEG(LPCDSENVELOPEDESC pEnvelopeDesc)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetEG");
        return CDirectSoundVoice::SetEG(pEnvelopeDesc);
    }

    __inline HRESULT CDirectSoundBuffer::SetFilter(LPCDSFILTERDESC pFilterDesc)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetFilter");
        return CDirectSoundVoice::SetFilter(pFilterDesc);
    }

    __inline HRESULT CDirectSoundBuffer::SetHeadroom(DWORD dwHeadroom)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetHeadroom");
        return CDirectSoundVoice::SetHeadroom(dwHeadroom);
    }

    __inline HRESULT CDirectSoundBuffer::SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetOutputBuffer");
        return CDirectSoundVoice::SetOutputBuffer(pOutputBuffer);
    }

    __inline HRESULT CDirectSoundBuffer::SetMixBins(LPCDSMIXBINS pMixBins)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetMixBins");
        return CDirectSoundVoice::SetMixBins(pMixBins);
    }

    __inline HRESULT CDirectSoundBuffer::SetMixBinVolumes(LPCDSMIXBINS pMixBins)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetMixBinVolumes");
        return CDirectSoundVoice::SetMixBinVolumes(pMixBins);
    }

    __inline HRESULT CDirectSoundBuffer::SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetAllParameters");
        return CDirectSoundVoice::SetAllParameters(pds3db, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetConeAngles");
        return CDirectSoundVoice::SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetConeOrientation");
        return CDirectSoundVoice::SetConeOrientation(x, y, z, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetConeOutsideVolume");
        return CDirectSoundVoice::SetConeOutsideVolume(lConeOutsideVolume, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetMaxDistance(FLOAT flMaxDistance, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetMaxDistance");
        return CDirectSoundVoice::SetMaxDistance(flMaxDistance, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetMinDistance(FLOAT flMinDistance, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetMinDistance");
        return CDirectSoundVoice::SetMinDistance(flMinDistance, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetMode(DWORD dwMode, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetMode");
        return CDirectSoundVoice::SetMode(dwMode, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetPosition");
        return CDirectSoundVoice::SetPosition(x, y, z, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetVelocity");
        return CDirectSoundVoice::SetVelocity(x, y, z, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetDistanceFactor");
        return CDirectSoundVoice::SetDistanceFactor(flDistanceFactor, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetDopplerFactor");
        return CDirectSoundVoice::SetDopplerFactor(flDopplerFactor, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetRolloffFactor");
        return CDirectSoundVoice::SetRolloffFactor(flRolloffFactor, dwFlags);
    }

    __inline HRESULT CDirectSoundBuffer::SetRolloffCurve(const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetRolloffCurve");
        return CDirectSoundVoice::SetRolloffCurve(pflPoints, dwPointCount, dwApply);
    }

    __inline HRESULT CDirectSoundBuffer::SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetI3DL2Source");
        return CDirectSoundVoice::SetI3DL2Source(pds3db, dwFlags);
    }
}

//
// DirectSound Stream settings
//

namespace DirectSound
{
    class CDirectSoundStreamSettings
        : public CDirectSoundVoiceSettings
    {
    public:
        DWORD                       m_dwMaxAttachedPackets; // Maximum number of packets in the queue
        LPFNXMEDIAOBJECTCALLBACK    m_pfnCallback;          // Packet completion callback routine
        LPVOID                      m_pvContext;            // Packet completion callback routine context
   
    public:
        CDirectSoundStreamSettings(void);
        virtual ~CDirectSoundStreamSettings(void);

    public:
        // Initialization
        HRESULT Initialize(LPCDSSTREAMDESC pdssd);
    };
}

//
// DirectSound Stream
//

namespace DirectSound
{

#ifdef VALIDATE_PARAMETERS

    class CDirectSoundStream
        : public IDirectSoundStream, public CValidObject<'DSS '>, public CDirectSoundVoice

#else // VALIDATE_PARAMETERS

    class CDirectSoundStream
        : public IDirectSoundStream, public CDirectSoundVoice

#endif // VALIDATE_PARAMETERS

    {
    public:
        CDirectSoundStreamSettings *    m_pSettings;        // Stream settings
        CMcpxStream *                   m_pStream;          // Stream implementation

    public:
        CDirectSoundStream(CDirectSound *pDirectSound);
        virtual ~CDirectSoundStream(void);

    public:
        // Initialization
        HRESULT STDMETHODCALLTYPE Initialize(LPCDSSTREAMDESC pdssd);
    
        // IUnknown methods
        virtual ULONG STDMETHODCALLTYPE AddRef(void);
        virtual ULONG STDMETHODCALLTYPE Release(void);

        // XMediaObject methods
        virtual HRESULT STDMETHODCALLTYPE GetInfo(LPXMEDIAINFO pInfo);
        virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
        virtual HRESULT STDMETHODCALLTYPE Process(LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket);
        virtual HRESULT STDMETHODCALLTYPE Discontinuity(void);
        virtual HRESULT STDMETHODCALLTYPE Flush(void);

        // IDirectSoundStream methods
        HRESULT STDMETHODCALLTYPE SetFormat(LPCWAVEFORMATEX pwfxFormat);
        HRESULT STDMETHODCALLTYPE SetFrequency(DWORD dwFrequency);
        HRESULT STDMETHODCALLTYPE SetPitch(LONG lPitch);
        HRESULT STDMETHODCALLTYPE SetVolume(LONG lVolume);
        HRESULT STDMETHODCALLTYPE SetLFO(LPCDSLFODESC pLFODesc);
        HRESULT STDMETHODCALLTYPE SetEG(LPCDSENVELOPEDESC pEnvelopeDesc);
        HRESULT STDMETHODCALLTYPE SetFilter(LPCDSFILTERDESC pFilterDesc);
        HRESULT STDMETHODCALLTYPE SetHeadroom(DWORD dwHeadroom);
        HRESULT STDMETHODCALLTYPE SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer);
        HRESULT STDMETHODCALLTYPE SetMixBins(LPCDSMIXBINS pMixBins);
        HRESULT STDMETHODCALLTYPE SetMixBinVolumes(LPCDSMIXBINS pMixBins);
        HRESULT STDMETHODCALLTYPE Pause(DWORD dwPause);
        HRESULT STDMETHODCALLTYPE PauseEx(REFERENCE_TIME rtTimeStamp, DWORD dwPause);
        HRESULT STDMETHODCALLTYPE FlushEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags);

        // IDirectSound3dBuffer methods
        HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMaxDistance(FLOAT flMaxDistance, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMinDistance(FLOAT flMinDistance, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE SetRolloffCurve(const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply);
        HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwFlags);
    };

    __inline ULONG CDirectSoundStream::AddRef(void)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::AddRef");
        return CRefCount::AddRef();
    }

    __inline ULONG CDirectSoundStream::Release(void)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::Release");
        return CRefCount::Release();
    }

    __inline HRESULT CDirectSoundStream::SetFormat(LPCWAVEFORMATEX pwfxFormat)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetFormat");
        return CDirectSoundVoice::SetFormat(pwfxFormat);
    }

    __inline HRESULT CDirectSoundStream::SetFrequency(DWORD dwFrequency)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetFrequency");
        return CDirectSoundVoice::SetFrequency(dwFrequency);
    }

    __inline HRESULT CDirectSoundStream::SetPitch(LONG lPitch)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetPitch");
        return CDirectSoundVoice::SetPitch(lPitch);
    }

    __inline HRESULT CDirectSoundStream::SetVolume(LONG lVolume)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetVolume");
        return CDirectSoundVoice::SetVolume(lVolume);
    }

    __inline HRESULT CDirectSoundStream::SetLFO(LPCDSLFODESC pLFODesc)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetLFO");
        return CDirectSoundVoice::SetLFO(pLFODesc);
    }

    __inline HRESULT CDirectSoundStream::SetEG(LPCDSENVELOPEDESC pEnvelopeDesc)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetEG");
        return CDirectSoundVoice::SetEG(pEnvelopeDesc);
    }

    __inline HRESULT CDirectSoundStream::SetFilter(LPCDSFILTERDESC pFilterDesc)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetFilter");
        return CDirectSoundVoice::SetFilter(pFilterDesc);
    }

    __inline HRESULT CDirectSoundStream::SetHeadroom(DWORD dwHeadroom)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetHeadroom");
        return CDirectSoundVoice::SetHeadroom(dwHeadroom);
    }

    __inline HRESULT CDirectSoundStream::SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetOutputBuffer");
        return CDirectSoundVoice::SetOutputBuffer(pOutputBuffer);
    }

    __inline HRESULT CDirectSoundStream::SetMixBins(LPCDSMIXBINS pMixBins)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetMixBins");
        return CDirectSoundVoice::SetMixBins(pMixBins);
    }

    __inline HRESULT CDirectSoundStream::SetMixBinVolumes(LPCDSMIXBINS pMixBins)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetMixBinVolumes");
        return CDirectSoundVoice::SetMixBinVolumes(pMixBins);
    }

    __inline HRESULT CDirectSoundStream::SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetAllParameters");
        return CDirectSoundVoice::SetAllParameters(pds3db, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetConeAngles");
        return CDirectSoundVoice::SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetConeOrientation");
        return CDirectSoundVoice::SetConeOrientation(x, y, z, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetConeOutsideVolume");
        return CDirectSoundVoice::SetConeOutsideVolume(lConeOutsideVolume, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetMaxDistance(FLOAT flMaxDistance, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetMaxDistance");
        return CDirectSoundVoice::SetMaxDistance(flMaxDistance, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetMinDistance(FLOAT flMinDistance, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetMinDistance");
        return CDirectSoundVoice::SetMinDistance(flMinDistance, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetMode(DWORD dwMode, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetMode");
        return CDirectSoundVoice::SetMode(dwMode, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetPosition");
        return CDirectSoundVoice::SetPosition(x, y, z, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetVelocity");
        return CDirectSoundVoice::SetVelocity(x, y, z, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetDistanceFactor");
        return CDirectSoundVoice::SetDistanceFactor(flDistanceFactor, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetDopplerFactor");
        return CDirectSoundVoice::SetDopplerFactor(flDopplerFactor, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetRolloffFactor");
        return CDirectSoundVoice::SetRolloffFactor(flRolloffFactor, dwFlags);
    }

    __inline HRESULT CDirectSoundStream::SetRolloffCurve(const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetRolloffCurve");
        return CDirectSoundVoice::SetRolloffCurve(pflPoints, dwPointCount, dwApply);
    }

    __inline HRESULT CDirectSoundStream::SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwFlags)
    {
        _ENTER_EXTERNAL_METHOD("CDirectSoundStream::SetI3DL2Source");
        return CDirectSoundVoice::SetI3DL2Source(pds3db, dwFlags);
    }
}

#endif // __cplusplus

#endif // __DSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\drvhlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drvhlp.cpp
 *  Content:    Miscelaneous NT-style driver helper functions and objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/07/01    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

DWORD CFpState::m_dwRefCount = 0;
KFLOATING_SAVE CFpState::m_fps;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dscommon.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscommon.cpp
 *  Content:    DirectSound common source file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/10/01    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"
#include "..\common\dscommon.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsapi.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsapi.cpp
 *  Content:    DirectSound API objects and entry points.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/06/00    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

//
// Hacks to enable or disable certain API features
//

#ifdef DSAPI_DISABLE_SUBMIX
#pragma HACKHACK("Submix API currently disabled")
#endif // DSAPI_DISABLE_SUBMIX

#ifdef DSAPI_DISABLE_EFFECTS
#pragma HACKHACK("Effects API currently disabled")
#endif // DSAPI_DISABLE_EFFECTS

#ifdef DSAPI_DISABLE_LISTENER
#pragma HACKHACK("3D listener API currently disabled")
#endif // DSAPI_DISABLE_LISTENER

#ifdef DSAPI_DISABLE_3DSOURCE
#pragma HACKHACK("3D source API currently disabled")
#endif // DSAPI_DISABLE_3DSOURCE

#ifdef DSAPI_DISABLE_MIXBINS
#pragma HACKHACK("MixBin API currently disabled")
#endif // DSAPI_DISABLE_MIXBINS

#ifdef DSAPI_DISABLE_VOLUME
#pragma HACKHACK("Volume API currently disabled")
#endif // DSAPI_DISABLE_VOLUME

#ifdef DSAPI_DISABLE_PITCH
#pragma HACKHACK("Pitch/frequency API currently disabled")
#endif // DSAPI_DISABLE_PITCH

#ifdef DSAPI_DISABLE_FILTER
#pragma HACKHACK("DLS filter API currently disabled")
#endif // DSAPI_DISABLE_FILTER

#ifdef DSAPI_DISABLE_LFO
#pragma HACKHACK("LFO API currently disabled")
#endif // DSAPI_DISABLE_LFO

#ifdef DSAPI_DISABLE_EG
#pragma HACKHACK("EG API currently disabled")
#endif // DSAPI_DISABLE_EG

#ifdef DSAPI_DISABLE_NOTEOFF
#pragma HACKHACK("NoteOff API currently disabled")
#endif // DSAPI_DISABLE_NOTEOFF

//
// Merge segments
//

#pragma comment(linker, "/merge:DSOUND_RW=DSOUND")
#pragma comment(linker, "/merge:DSOUND_URW=DSOUND")
#pragma comment(linker, "/merge:DSOUND_RD=DSOUND")
#pragma comment(linker, "/section:DSOUND,ERW")

//
// Turn off floating-point normalization in retail builds
//

#ifndef VALIDATE_PARAMETERS

#define NormalizeFloat(a) (a)
#define NormalizeDouble(a) (a)

#endif // VALIDATE_PARAMETERS

//
// Method entry points
//

STDAPI IDirectSound_QueryInterfaceC(LPDIRECTSOUND pDirectSound, const IID *iid, LPVOID *ppvInterface)
{
    ASSERT(pDirectSound);
    ASSERT(ppvInterface);

    IDirectSound_AddRef(pDirectSound);
    *ppvInterface = pDirectSound;

    return DS_OK;
}

STDAPI IDirectSound_QueryInterface(LPDIRECTSOUND pDirectSound, REFIID iid, LPVOID *ppvInterface)
{
    ASSERT(pDirectSound);
    ASSERT(ppvInterface);

    IDirectSound_AddRef(pDirectSound);
    *ppvInterface = pDirectSound;

    return DS_OK;
}

STDAPI IDirectSound_SetCooperativeLevel(LPDIRECTSOUND pDirectSound, HWND hWnd, DWORD dwLevel)
{
    UNREFERENCED_PARAMETER(pDirectSound);
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(dwLevel);
    return DS_OK;
}

STDAPI IDirectSound_Compact(LPDIRECTSOUND pDirectSound)
{
    UNREFERENCED_PARAMETER(pDirectSound);
    return DS_OK;
}

STDAPI_(ULONG) IDirectSound_AddRef(LPDIRECTSOUND pDirectSound)
{
    return ((CDirectSound *)pDirectSound)->AddRef();
}

STDAPI_(ULONG) IDirectSound_Release(LPDIRECTSOUND pDirectSound)
{
    return ((CDirectSound *)pDirectSound)->Release();
}

STDAPI IDirectSound_GetCaps(LPDIRECTSOUND pDirectSound, LPDSCAPS pdsc)
{
    return ((CDirectSound *)pDirectSound)->GetCaps(pdsc);
}

STDAPI IDirectSound_CreateSoundBuffer(LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter)
{
    return ((CDirectSound *)pDirectSound)->CreateSoundBuffer(pdsbd, ppBuffer, pUnkOuter);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSound_CreateSoundStream(LPDIRECTSOUND pDirectSound, LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter)
{
    return ((CDirectSound *)pDirectSound)->CreateSoundStream(pdssd, ppStream, pUnkOuter);
}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSound_GetSpeakerConfig(LPDIRECTSOUND pDirectSound, LPDWORD pdwSpeakerConfig)
{
    return ((CDirectSound *)pDirectSound)->GetSpeakerConfig(pdwSpeakerConfig);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSound_DownloadEffectsImage(LPDIRECTSOUND pDirectSound, LPCVOID pvImageBuffer, DWORD dwImageSize, LPCDSEFFECTIMAGELOC pImageLoc, LPDSEFFECTIMAGEDESC *ppImageDesc)
{

#ifdef DSAPI_DISABLE_EFFECTS

    return DS_OK;

#else // DSAPI_DISABLE_EFFECTS

    return ((CDirectSound *)pDirectSound)->DownloadEffectsImage(pvImageBuffer, dwImageSize, pImageLoc, ppImageDesc);

#endif // DSAPI_DISABLE_EFFECTS
}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSound_GetEffectData(LPDIRECTSOUND pDirectSound, DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize)
{

#ifdef DSAPI_DISABLE_EFFECTS

    ZeroMemory(pvData, dwDataSize);

    return DS_OK;

#else // DSAPI_DISABLE_EFFECTS

    return ((CDirectSound *)pDirectSound)->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);

#endif // DSAPI_DISABLE_EFFECTS

}

STDAPI IDirectSound_SetEffectData(LPDIRECTSOUND pDirectSound, DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_EFFECTS

    return DS_OK;

#else // DSAPI_DISABLE_EFFECTS

    return ((CDirectSound *)pDirectSound)->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);

#endif // DSAPI_DISABLE_EFFECTS

}

STDAPI IDirectSound_CommitEffectData(LPDIRECTSOUND pDirectSound)
{

#ifdef DSAPI_DISABLE_EFFECTS

    return DS_OK;

#else // DSAPI_DISABLE_EFFECTS

    return ((CDirectSound *)pDirectSound)->CommitEffectData();

#endif // DSAPI_DISABLE_EFFECTS

}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSound_EnableHeadphones(LPDIRECTSOUND pDirectSound, BOOL fEnabled)
{
    return ((CDirectSound *)pDirectSound)->EnableHeadphones(fEnabled);
}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSound_SetMixBinHeadroom(LPDIRECTSOUND pDirectSound, DWORD dwMixBin, DWORD dwHeadroom)
{
    return ((CDirectSound *)pDirectSound)->SetMixBinHeadroom(dwMixBin, dwHeadroom);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSound_SetAllParameters(LPDIRECTSOUND pDirectSound, LPCDS3DLISTENER pds3dl, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->SetAllParameters(pds3dl, dwFlags);

#endif // DSAPI_DISABLE_LISTENER

}

STDAPI IDirectSound_SetDistanceFactor(LPDIRECTSOUND pDirectSound, FLOAT flDistanceFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->SetDistanceFactor(flDistanceFactor, dwFlags);

#endif // DSAPI_DISABLE_LISTENER

}

STDAPI IDirectSound_SetDopplerFactor(LPDIRECTSOUND pDirectSound, FLOAT flDopplerFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->SetDopplerFactor(flDopplerFactor, dwFlags);

#endif // DSAPI_DISABLE_LISTENER

}

STDAPI IDirectSound_SetOrientation(LPDIRECTSOUND pDirectSound, FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->SetOrientation(xFront, yFront, zFront, xTop, yTop, zTop, dwFlags);

#endif // DSAPI_DISABLE_LISTENER

}

STDAPI IDirectSound_SetPosition(LPDIRECTSOUND pDirectSound, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->SetPosition(x, y, z, dwFlags);

#endif // DSAPI_DISABLE_LISTENER

}

STDAPI IDirectSound_SetRolloffFactor(LPDIRECTSOUND pDirectSound, FLOAT flRolloffFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->SetRolloffFactor(flRolloffFactor, dwFlags);

#endif // DSAPI_DISABLE_LISTENER

}

STDAPI IDirectSound_SetVelocity(LPDIRECTSOUND pDirectSound, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->SetVelocity(x, y, z, dwFlags);

#endif // DSAPI_DISABLE_LISTENER

}

STDAPI IDirectSound_CommitDeferredSettings(LPDIRECTSOUND pDirectSound)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->CommitDeferredSettings();

#endif // DSAPI_DISABLE_LISTENER

}

STDAPI IDirectSound_SetI3DL2Listener(LPDIRECTSOUND pDirectSound, LPCDSI3DL2LISTENER pds3dl, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_LISTENER

    return DS_OK;

#else // DSAPI_DISABLE_LISTENER

    return ((CDirectSound *)pDirectSound)->SetI3DL2Listener(pds3dl, dwFlags);

#endif // DSAPI_DISABLE_LISTENER

}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSound_GetTime(LPDIRECTSOUND pDirectSound, REFERENCE_TIME *prtCurrent)
{
    return ((CDirectSound *)pDirectSound)->GetTime(prtCurrent);
}


STDAPI IDirectSound_GetOutputLevels(LPDIRECTSOUND pDirectSound, DSOUTPUTLEVELS *pOutputLevels, BOOL bReset)
{
    return ((CDirectSound *)pDirectSound)->GetOutputLevels(pOutputLevels,bReset);
}


STDAPI IDirectSoundBuffer_QueryInterface(LPDIRECTSOUNDBUFFER pBuffer, REFIID iid, LPVOID *ppvInterface)
{
    ASSERT(pBuffer);
    ASSERT(ppvInterface);

    IDirectSoundBuffer_AddRef(pBuffer);
    *ppvInterface = pBuffer;

    return DS_OK;
}

STDAPI IDirectSoundBuffer_QueryInterfaceC(LPDIRECTSOUNDBUFFER pBuffer, const IID *iid, LPVOID *ppvInterface)
{
    ASSERT(pBuffer);
    ASSERT(ppvInterface);

    IDirectSoundBuffer_AddRef(pBuffer);
    *ppvInterface = pBuffer;

    return DS_OK;
}

STDAPI IDirectSoundBuffer_Unlock(LPDIRECTSOUNDBUFFER pBuffer, LPVOID pvLock1, DWORD dwLockSize1, LPVOID pvLock2, DWORD dwLockSize2)
{
    return DS_OK;
}

STDAPI IDirectSoundBuffer_Restore(LPDIRECTSOUNDBUFFER pBuffer)
{
    return DS_OK;
}

STDAPI_(ULONG) IDirectSoundBuffer_AddRef(LPDIRECTSOUNDBUFFER pBuffer)
{
    return ((CDirectSoundBuffer *)pBuffer)->AddRef();
}

STDAPI_(ULONG) IDirectSoundBuffer_Release(LPDIRECTSOUNDBUFFER pBuffer)
{
    return ((CDirectSoundBuffer *)pBuffer)->Release();
}

STDAPI IDirectSoundBuffer_SetFormat(LPDIRECTSOUNDBUFFER pBuffer, LPCWAVEFORMATEX pwfxFormat)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetFormat(pwfxFormat);
}

STDAPI IDirectSoundBuffer_SetFrequency(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwFrequency)
{

#ifdef DSAPI_DISABLE_PITCH

    return DS_OK;

#else // DSAPI_DISABLE_PITCH

    return ((CDirectSoundBuffer *)pBuffer)->SetFrequency(dwFrequency);

#endif // DSAPI_DISABLE_PITCH

}

STDAPI IDirectSoundBuffer_SetVolume(LPDIRECTSOUNDBUFFER pBuffer, LONG lVolume)
{

#ifdef DSAPI_DISABLE_VOLUME

    return DS_OK;

#else // DSAPI_DISABLE_VOLUME

    return ((CDirectSoundBuffer *)pBuffer)->SetVolume(lVolume);

#endif // DSAPI_DISABLE_VOLUME

}

STDAPI IDirectSoundBuffer_SetPitch(LPDIRECTSOUNDBUFFER pBuffer, LONG lPitch)
{

#ifdef DSAPI_DISABLE_PITCH

    return DS_OK;

#else // DSAPI_DISABLE_PITCH

    return ((CDirectSoundBuffer *)pBuffer)->SetPitch(lPitch);

#endif // DSAPI_DISABLE_PITCH

}

STDAPI IDirectSoundBuffer_SetLFO(LPDIRECTSOUNDBUFFER pBuffer, LPCDSLFODESC pLFODesc)
{

#ifdef DSAPI_DISABLE_LFO

    return DS_OK;

#else // DSAPI_DISABLE_LFO

    return ((CDirectSoundBuffer *)pBuffer)->SetLFO(pLFODesc);

#endif // DSAPI_DISABLE_LFO

}

STDAPI IDirectSoundBuffer_SetEG(LPDIRECTSOUNDBUFFER pBuffer, LPCDSENVELOPEDESC pEnvelopeDesc)
{

#ifdef DSAPI_DISABLE_EG

    return DS_OK;

#else // DSAPI_DISABLE_EG

    return ((CDirectSoundBuffer *)pBuffer)->SetEG(pEnvelopeDesc);

#endif // DSAPI_DISABLE_EG

}

STDAPI IDirectSoundBuffer_SetFilter(LPDIRECTSOUNDBUFFER pBuffer, LPCDSFILTERDESC pFilter)
{

#ifdef DSAPI_DISABLE_FILTER

    return DS_OK;

#else // DSAPI_DISABLE_FILTER

    return ((CDirectSoundBuffer *)pBuffer)->SetFilter(pFilter);

#endif // DSAPI_DISABLE_FILTER

}

STDAPI IDirectSoundBuffer_SetHeadroom(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwHeadroom)
{

#ifdef DSAPI_DISABLE_VOLUME

    return DS_OK;

#else // DSAPI_DISABLE_VOLUME

    return ((CDirectSoundBuffer *)pBuffer)->SetHeadroom(dwHeadroom);

#endif // DSAPI_DISABLE_VOLUME

}

STDAPI IDirectSoundBuffer_SetOutputBuffer(LPDIRECTSOUNDBUFFER pBuffer, LPDIRECTSOUNDBUFFER pOutputBuffer)
{

#ifdef DSAPI_DISABLE_SUBMIX

    return DS_OK;

#else // DSAPI_DISABLE_SUBMIX

    return ((CDirectSoundBuffer *)pBuffer)->SetOutputBuffer(pOutputBuffer);

#endif // DSAPI_DISABLE_SUBMIX

}

STDAPI IDirectSoundBuffer_SetMixBins(LPDIRECTSOUNDBUFFER pBuffer, LPCDSMIXBINS pMixBins)
{

#ifdef DSAPI_DISABLE_MIXBINS

    return DS_OK;

#else // DSAPI_DISABLE_MIXBINS

    return ((CDirectSoundBuffer *)pBuffer)->SetMixBins(pMixBins);

#endif // DSAPI_DISABLE_SUBMIX

}

STDAPI IDirectSoundBuffer_SetMixBinVolumes(LPDIRECTSOUNDBUFFER pBuffer, LPCDSMIXBINS pMixBins)
{

#ifdef DSAPI_DISABLE_VOLUME

    return DS_OK;

#else // DSAPI_DISABLE_VOLUME

    return ((CDirectSoundBuffer *)pBuffer)->SetMixBinVolumes(pMixBins);

#endif // DSAPI_DISABLE_VOLUME

}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSoundBuffer_SetAllParameters(LPDIRECTSOUNDBUFFER pBuffer, LPCDS3DBUFFER pds3db, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetAllParameters(pds3db, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetConeAngles(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetConeOrientation(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetConeOrientation(x, y, z, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetConeOutsideVolume(LPDIRECTSOUNDBUFFER pBuffer, LONG lConeOutsideVolume, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetConeOutsideVolume(lConeOutsideVolume, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetMaxDistance(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flMaxDistance, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetMaxDistance(flMaxDistance, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetMinDistance(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flMinDistance, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetMinDistance(flMinDistance, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetMode(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwMode, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetMode(dwMode, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetPosition(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetPosition(x, y, z, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetVelocity(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetVelocity(x, y, z, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetDistanceFactor(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flDistanceFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetDistanceFactor(flDistanceFactor, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetDopplerFactor(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flDopplerFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetDopplerFactor(flDopplerFactor, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetRolloffFactor(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flRolloffFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetRolloffFactor(flRolloffFactor, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetRolloffCurve(LPDIRECTSOUNDBUFFER pBuffer, const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetRolloffCurve(pflPoints, dwPointCount, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundBuffer_SetI3DL2Source(LPDIRECTSOUNDBUFFER pBuffer, LPCDSI3DL2BUFFER pds3db, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundBuffer *)pBuffer)->SetI3DL2Source(pds3db, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSoundBuffer_Play(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->Play(dwReserved1, dwReserved2, dwFlags);
}

STDAPI IDirectSoundBuffer_PlayEx(LPDIRECTSOUNDBUFFER pBuffer, REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->PlayEx(rtTimeStamp, dwFlags);
}

STDAPI IDirectSoundBuffer_Stop(LPDIRECTSOUNDBUFFER pBuffer)
{
    return ((CDirectSoundBuffer *)pBuffer)->Stop();
}

STDAPI IDirectSoundBuffer_StopEx(LPDIRECTSOUNDBUFFER pBuffer, REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_NOTEOFF

    dwFlags = 0;

#endif // DSAPI_DISABLE_NOTEOFF

    return ((CDirectSoundBuffer *)pBuffer)->StopEx(rtTimeStamp, dwFlags);
}

STDAPI IDirectSoundBuffer_SetPlayRegion(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwPlayStart, DWORD dwPlayLength)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetPlayRegion(dwPlayStart, dwPlayLength);
}

STDAPI IDirectSoundBuffer_SetLoopRegion(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwLoopStart, DWORD dwLoopLength)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetLoopRegion(dwLoopStart, dwLoopLength);
}

STDAPI IDirectSoundBuffer_GetStatus(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwStatus)
{
    return ((CDirectSoundBuffer *)pBuffer)->GetStatus(pdwStatus);
}

STDAPI IDirectSoundBuffer_GetCurrentPosition(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor)
{
    return ((CDirectSoundBuffer *)pBuffer)->GetCurrentPosition(pdwPlayCursor, pdwWriteCursor);
}

STDAPI IDirectSoundBuffer_SetCurrentPosition(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwPlayCursor)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetCurrentPosition(dwPlayCursor);
}

STDAPI IDirectSoundBuffer_SetBufferData(LPDIRECTSOUNDBUFFER pBuffer, LPVOID pvBufferData, DWORD dwBufferBytes)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetBufferData(pvBufferData, dwBufferBytes);
}

STDAPI IDirectSoundBuffer_Lock(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->Lock(dwOffset, dwBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
}

STDAPI IDirectSoundBuffer_SetNotificationPositions(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetNotificationPositions(dwNotifyCount, paNotifies);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSoundStream_QueryInterface(LPDIRECTSOUNDSTREAM pStream, REFIID iid, LPVOID *ppvInterface)
{
    ASSERT(pStream);
    ASSERT(ppvInterface);

    IDirectSoundStream_AddRef(pStream);
    *ppvInterface = pStream;

    return DS_OK;
}

STDAPI IDirectSoundStream_QueryInterfaceC(LPDIRECTSOUNDSTREAM pStream, const IID *iid, LPVOID *ppvInterface)
{
    ASSERT(pStream);
    ASSERT(ppvInterface);

    IDirectSoundStream_AddRef(pStream);
    *ppvInterface = pStream;

    return DS_OK;
}

STDAPI IDirectSoundStream_SetFormat(LPDIRECTSOUNDSTREAM pStream, LPCWAVEFORMATEX pwfxFormat)
{
    return ((CDirectSoundStream *)pStream)->SetFormat(pwfxFormat);
}

STDAPI IDirectSoundStream_SetFrequency(LPDIRECTSOUNDSTREAM pStream, DWORD dwFrequency)
{

#ifdef DSAPI_DISABLE_PITCH

    return DS_OK;

#else // DSAPI_DISABLE_PITCH

    return ((CDirectSoundStream *)pStream)->SetFrequency(dwFrequency);

#endif // DSAPI_DISABLE_PITCH

}

STDAPI IDirectSoundStream_SetVolume(LPDIRECTSOUNDSTREAM pStream, LONG lVolume)
{

#ifdef DSAPI_DISABLE_VOLUME

    return DS_OK;

#else // DSAPI_DISABLE_VOLUME

    return ((CDirectSoundStream *)pStream)->SetVolume(lVolume);

#endif // DSAPI_DISABLE_VOLUME

}

STDAPI IDirectSoundStream_SetPitch(LPDIRECTSOUNDSTREAM pStream, LONG lPitch)
{

#ifdef DSAPI_DISABLE_PITCH

    return DS_OK;

#else // DSAPI_DISABLE_PITCH

    return ((CDirectSoundStream *)pStream)->SetPitch(lPitch);

#endif // DSAPI_DISABLE_PITCH

}

STDAPI IDirectSoundStream_SetLFO(LPDIRECTSOUNDSTREAM pStream, LPCDSLFODESC pLFODesc)
{

#ifdef DSAPI_DISABLE_LFO

    return DS_OK;

#else // DSAPI_DISABLE_LFO

    return ((CDirectSoundStream *)pStream)->SetLFO(pLFODesc);

#endif // DSAPI_DISABLE_LFO

}

STDAPI IDirectSoundStream_SetEG(LPDIRECTSOUNDSTREAM pStream, LPCDSENVELOPEDESC pEnvelopeDesc)
{

#ifdef DSAPI_DISABLE_EG

    return DS_OK;

#else // DSAPI_DISABLE_EG

    return ((CDirectSoundStream *)pStream)->SetEG(pEnvelopeDesc);

#endif // DSAPI_DISABLE_EG

}

STDAPI IDirectSoundStream_SetFilter(LPDIRECTSOUNDSTREAM pStream, LPCDSFILTERDESC pFilter)
{

#ifdef DSAPI_DISABLE_FILTER

    return DS_OK;

#else // DSAPI_DISABLE_FILTER

    return ((CDirectSoundStream *)pStream)->SetFilter(pFilter);

#endif // DSAPI_DISABLE_FILTER

}

STDAPI IDirectSoundStream_SetHeadroom(LPDIRECTSOUNDSTREAM pStream, DWORD dwHeadroom)
{

#ifdef DSAPI_DISABLE_VOLUME

    return DS_OK;

#else // DSAPI_DISABLE_VOLUME

    return ((CDirectSoundStream *)pStream)->SetHeadroom(dwHeadroom);

#endif // DSAPI_DISABLE_VOLUME

}

STDAPI IDirectSoundStream_SetOutputBuffer(LPDIRECTSOUNDSTREAM pStream, LPDIRECTSOUNDBUFFER pOutputBuffer)
{

#ifdef DSAPI_DISABLE_SUBMIX

    return DS_OK;

#else // DSAPI_DISABLE_SUBMIX

    return ((CDirectSoundStream *)pStream)->SetOutputBuffer(pOutputBuffer);

#endif // DSAPI_DISABLE_SUBMIX

}

STDAPI IDirectSoundStream_SetMixBins(LPDIRECTSOUNDSTREAM pStream, LPCDSMIXBINS pMixBins)
{

#ifdef DSAPI_DISABLE_MIXBINS

    return DS_OK;

#else // DSAPI_DISABLE_MIXBINS

    return ((CDirectSoundStream *)pStream)->SetMixBins(pMixBins);

#endif // DSAPI_DISABLE_MIXBINS

}

STDAPI IDirectSoundStream_SetMixBinVolumes(LPDIRECTSOUNDSTREAM pStream, LPCDSMIXBINS pMixBins)
{

#ifdef DSAPI_DISABLE_VOLUME

    return DS_OK;

#else // DSAPI_DISABLE_VOLUME

    return ((CDirectSoundStream *)pStream)->SetMixBinVolumes(pMixBins);

#endif // DSAPI_DISABLE_VOLUME

}

STDAPI IDirectSoundStream_SetAllParameters(LPDIRECTSOUNDSTREAM pStream, LPCDS3DBUFFER pds3db, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetAllParameters(pds3db, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetConeAngles(LPDIRECTSOUNDSTREAM pStream, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetConeOrientation(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetConeOrientation(x, y, z, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetConeOutsideVolume(LPDIRECTSOUNDSTREAM pStream, LONG lConeOutsideVolume, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetConeOutsideVolume(lConeOutsideVolume, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetMaxDistance(LPDIRECTSOUNDSTREAM pStream, FLOAT flMaxDistance, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetMaxDistance(flMaxDistance, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetMinDistance(LPDIRECTSOUNDSTREAM pStream, FLOAT flMinDistance, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetMinDistance(flMinDistance, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetMode(LPDIRECTSOUNDSTREAM pStream, DWORD dwMode, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetMode(dwMode, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetPosition(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetPosition(x, y, z, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetVelocity(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetVelocity(x, y, z, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetDistanceFactor(LPDIRECTSOUNDSTREAM pStream, FLOAT flDistanceFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetDistanceFactor(flDistanceFactor, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetDopplerFactor(LPDIRECTSOUNDSTREAM pStream, FLOAT flDopplerFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetDopplerFactor(flDopplerFactor, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetRolloffFactor(LPDIRECTSOUNDSTREAM pStream, FLOAT flRolloffFactor, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetRolloffFactor(flRolloffFactor, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetRolloffCurve(LPDIRECTSOUNDSTREAM pStream, const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetRolloffCurve(pflPoints, dwPointCount, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_SetI3DL2Source(LPDIRECTSOUNDSTREAM pStream, LPCDSI3DL2BUFFER pds3db, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_3DSOURCE

    return DS_OK;

#else // DSAPI_DISABLE_3DSOURCE

    return ((CDirectSoundStream *)pStream)->SetI3DL2Source(pds3db, dwFlags);

#endif // DSAPI_DISABLE_3DSOURCE

}

STDAPI IDirectSoundStream_Pause(LPDIRECTSOUNDSTREAM pStream, DWORD dwPause)
{
    return ((CDirectSoundStream *)pStream)->Pause(dwPause);
}

STDAPI IDirectSoundStream_PauseEx(LPDIRECTSOUNDSTREAM pStream, REFERENCE_TIME rtTimestamp, DWORD dwPause)
{
    return ((CDirectSoundStream *)pStream)->PauseEx(rtTimestamp, dwPause);
}

STDAPI IDirectSoundStream_FlushEx(LPDIRECTSOUNDSTREAM pStream, REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
{

#ifdef DSAPI_DISABLE_NOTEOFF

    dwFlags = 0;

#endif // DSAPI_DISABLE_NOTEOFF

    return ((CDirectSoundStream *)pStream)->FlushEx(rtTimeStamp, dwFlags);
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  DirectSoundCreateInternal
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      CDirectSound ** [out]: DirectSound object.  The caller is responbile
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateInternal"

HRESULT
DirectSoundCreateInternal
(
    CDirectSound **         ppDirectSound
)
{
    CDirectSound *          pDirectSound    = NULL;
    HRESULT                 hr              = DS_OK;
    
    DPF_ENTER();

    //
    // Check to see if the DirectSound object already exists
    //

    if(CDirectSound::m_pDirectSound)
    {
        *ppDirectSound = ADDREF(CDirectSound::m_pDirectSound);
    }
    else
    {
        hr = HRFROMP(pDirectSound = NEW(CDirectSound));

        if(SUCCEEDED(hr))
        {
            hr = pDirectSound->Initialize();
        }

        if(SUCCEEDED(hr))
        {
            *ppDirectSound = pDirectSound;
        }
        else
        {
            RELEASE(pDirectSound);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundCreate
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      LPGUID [in]: unused.  Must be NULL.
 *      LPDIRECTSOUND * [out]: DirectSound object.  The caller is responbile
 *                             for freeing this object with Release.
 *      LPUNKNOWN [in]: unused.  Must be NULL.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreate"

HRESULT
DirectSoundCreate
(
    LPGUID                          pguidDeviceId,
    LPDIRECTSOUND *                 ppDirectSound,
    LPUNKNOWN                       pControllingUnknown
)
{
    CDirectSound *  pDirectSound;
    HRESULT                         hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifdef VALIDATE_PARAMETERS

    if(!IS_NULL_GUID(*pguidDeviceId))
    {
        DPF_ERROR("NULL or GUID_NULL is the only supported device identifier");
    }

    if(!ppDirectSound)
    {
        DPF_ERROR("Failed to supply an LPDIRECTSOUND *");
    }
    
    if(pControllingUnknown)
    {
        DPF_ERROR("Aggregation is not supported");
    }

#endif // VALIDATE_PARAMETERS

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        *ppDirectSound = pDirectSound;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundCreateBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *      LPDIRECTSOUNDBUFFER * [out]: DirectSound Buffer object.  The caller 
 *                                   is responbile for freeing this object 
 *                                   with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateBuffer"

HRESULT
DirectSoundCreateBuffer
(                               
    LPCDSBUFFERDESC                 pdsbd,
    LPDIRECTSOUNDBUFFER *           ppBuffer
)
{
    CDirectSound *  pDirectSound    = NULL;
    HRESULT                         hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->CreateSoundBuffer(pdsbd, ppBuffer, NULL);
    }

    RELEASE(pDirectSound);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundCreateStream
 *
 *  Description:
 *      Creates and initializes a DirectSound Stream object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: stream description.
 *      LPDIRECTSOUNDSTREAM * [out]: DirectSound Stream object.  The caller 
 *                                   is responbile for freeing this object 
 *                                   with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateStream"

HRESULT
DirectSoundCreateStream
(
    LPCDSSTREAMDESC                 pdssd,
    LPDIRECTSOUNDSTREAM *           ppStream
)
{
    CDirectSound *  pDirectSound    = NULL;
    HRESULT                         hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->CreateSoundStream(pdssd, ppStream, NULL);
    }

    RELEASE(pDirectSound);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  DirectSoundDoWork
 *
 *  Description:
 *      Does some work.  Leave me alone.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundDoWork"

void
DirectSoundDoWork
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

#ifdef DEBUG

    //
    // Check for a deferred breakpoint
    //

    if(INTERLOCKED_EXCHANGE(g_fDirectSoundDebugBreak, FALSE))
    {
        DPF_ABSOLUTE("A breakpoint occurred at raised IRQL.  If you're running the Visual C debugger, you probably missed it.");
        BREAK();
    }

#endif // DEBUG

    //
    // Workie, workie
    //

    if(CDirectSound::m_pDirectSound)
    {
        CDirectSound::m_pDirectSound->DoWork();
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  DirectSoundGetSampleTime
 *
 *  Description:
 *      Gets the current sample clock time.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: sample time.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundGetSampleTime"

DWORD
DirectSoundGetSampleTime
(
    void
)
{
    DWORD                   dwSampleTime;
    
    DPF_ENTER();    

    //
    // MASSIVE HACK
    //
    // In order to keep latency and overhead to an absolute minimum, we're 
    // going to read the MCPX sample clock register from here.  This will 
    // prevent us from having to take the critical section or raise IRQL.
    //
    // If the DirectSound object hasn't been created, the sample counter
    // can't be trusted.
    //

    if(CDirectSound::m_pDirectSound)
    {
        MCPX_REG_READ(NV_PAPU_XGSCNT, &dwSampleTime);
    }
    else
    {
        dwSampleTime = 0;
    }

    DPF_LEAVE(dwSampleTime);

    return dwSampleTime;
}


#ifndef MCPX_BOOT_LIB

/****************************************************************************
 *
 *  DirectSoundUseFullHRTF
 *
 *  Description:
 *      Sets up the HRTF 3D filter loader to use the full HRTF table.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundUseFullHRTF"

void
DirectSoundUseFullHRTF
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifndef DS3D_ALLOW_ALGORITHM_SWAP

    if(CHrtfSource::IsValidAlgorithm())
    {
        DPF_ERROR("3D algorithms can't be changed once set");
    }
    else

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    {
        DPF_ABSOLUTE("Using full HRTF 3D algorithm");
    
        CHrtfSource::SetAlgorithm_FullHrtf();

#ifdef DS3D_ALLOW_ALGORITHM_SWAP

        if(CDirectSound::m_pDirectSound)
        {
            CDirectSound::m_pDirectSound->Force3dRecalc();
        }

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  DirectSoundUseLightHRTF
 *
 *  Description:
 *      Sets up the HRTF 3D filter loader to use the light HRTF table.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundUseLightHRTF"

void
DirectSoundUseLightHRTF
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifndef DS3D_ALLOW_ALGORITHM_SWAP

    if(CHrtfSource::IsValidAlgorithm())
    {
        DPF_ERROR("3D algorithms can't be changed once set");
    }
    else

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    {
        DPF_ABSOLUTE("Using light HRTF 3D algorithm");
    
        CHrtfSource::SetAlgorithm_LightHrtf();

#ifdef DS3D_ALLOW_ALGORITHM_SWAP

        if(CDirectSound::m_pDirectSound)
        {
            CDirectSound::m_pDirectSound->Force3dRecalc();
        }

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  DirectSoundUsePan3D
 *
 *  Description:
 *      Sets up the 3D engine to use panning.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundUsePan3D"

void
DirectSoundUsePan3D
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifndef DS3D_ALLOW_ALGORITHM_SWAP

    if(CHrtfSource::IsValidAlgorithm())
    {
        DPF_ERROR("3D algorithms can't be changed once set");
    }
    else

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    {
        DPF_ABSOLUTE("Using pan 3D algorithm");
    
        CHrtfSource::SetAlgorithm_Pan();

#ifdef DS3D_ALLOW_ALGORITHM_SWAP

        if(CDirectSound::m_pDirectSound)
        {
            CDirectSound::m_pDirectSound->Force3dRecalc();
        }

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    }

    DPF_LEAVE_VOID();
}

#endif


/****************************************************************************
 *
 *  DirectSoundOverrideSpeakerConfig
 *
 *  Description:
 *      Allows a game to override the default speaker configuration.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundOverrideSpeakerConfig"

void
DirectSoundOverrideSpeakerConfig
(
    DWORD                   dwSpeakerConfig
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifdef VALIDATE_PARAMETERS

    if(DSSPEAKER_USE_DEFAULT != dwSpeakerConfig)
    {
        if(!DSSPEAKER_IS_VALID(dwSpeakerConfig))
        {
            DPF_ERROR("Invalid speaker configuration");
        }

        if(!DSSPEAKER_IS_VALID_BASIC(dwSpeakerConfig))
        {
            DPF_ERROR("Can't set encoder bits in the speaker config");
        }
    }

    if(CDirectSound::m_pDirectSound)
    {
        DPF_ERROR("Can't call " DPF_FNAME " after the DirectSound object has been created");
    }

#endif // VALIDATE_PARAMETERS

    g_dwDirectSoundOverrideSpeakerConfig = (DSSPEAKER_USE_DEFAULT == dwSpeakerConfig) ? DSSPEAKER_USE_DEFAULT : DSSPEAKER_BASIC(dwSpeakerConfig);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  DirectSoundLoadEncoder
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      LPCVOID [in]: image data.
 *      DWORD [in]: image data size, in bytes.
 *      LPVOID * [out]: image scratch data.
 *      LPDIRECTSOUND * [out]: DirectSound object.  The caller is responbile
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundLoadEncoder"

HRESULT
DirectSoundLoadEncoder
(
    LPCVOID                 pvImageBuffer, 
    DWORD                   dwImageSize, 
    LPVOID *                ppvScratchData, 
    LPDIRECTSOUND *         ppDirectSound
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    //
    // Make sure the DirectSound object doesn't already exist
    //

    if(CDirectSound::m_pDirectSound)
    {
        DPF_ERROR("You must call DirectSoundLoadEncoder before the DirectSound object has been created");
        hr = DSERR_INVALIDCALL;
    }

    //
    // Set the global encoder image pointer
    //

    if(SUCCEEDED(hr))
    {
        CDirectSound::m_pvEncoderImageData = (LPVOID)pvImageBuffer;
        CDirectSound::m_dwEncoderImageSize = dwImageSize;
    }

    //
    // Create the DirectSound object
    //

    if(SUCCEEDED(hr))
    {
        hr = DirectSoundCreate(NULL, ppDirectSound, NULL);
    }

    //
    // Retrieve the scratch image pointer
    //

    if(SUCCEEDED(hr) && ppvScratchData)
    {
        *ppvScratchData = CDirectSound::m_pvEncoderImageData;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // DEBUG

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  XAudioCalculatePitch
 *
 *  Description:
 *      Converts frequency to an MCPX pitch value.
 *
 *  Arguments:
 *      DWORD [in]: frequency, in Hz.
 *
 *  Returns:  
 *      LONG: pitch.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "XAudioCalculatePitch"

LONG
XAudioCalculatePitch
(
    DWORD                   dwFrequency
)
{
    LONG                    lPitch;
   
    DPF_ENTER();
    AutoFpState();

#ifdef VALIDATE_PARAMETERS

    if((dwFrequency < DSBFREQUENCY_MIN) || (dwFrequency > DSBFREQUENCY_MAX))
    {
        DPF_ERROR("Invalid frequency value");
    }

#endif // VALIDATE_PARAMETERS

    if(MCPX_BASEFREQ == dwFrequency)
    {
        lPitch = 0;
    }
    else
    {
        lPitch = RatioToPitch((FLOAT)dwFrequency * MCPX_ONEOVERBASEFREQ);
    }

    DPF_LEAVE(lPitch);

    return lPitch;
}


/****************************************************************************
 *
 *  XAudioCreatePcmFormat
 *
 *  Description:
 *      Creates a PCM wave format structure.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      WORD [in]: count of bits per sample.
 *      LPWAVEFORMATEX [out]: format data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "XAudioCreatePcmFormat"

void 
XAudioCreatePcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    WORD                    wBitsPerSample, 
    LPWAVEFORMATEX          pwfx
)
{
    DPF_ENTER();
    
    CreatePcmFormat(nChannels, nSamplesPerSec, wBitsPerSample, pwfx);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  XAudioCreateAdpcmFormat
 *
 *  Description:
 *      Creates an Xbox ADPCM wave format structure.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPWAVEFORMATEX [out]: format data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "XAudioCreateAdpcmFormat"

void 
XAudioCreateAdpcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    LPXBOXADPCMWAVEFORMAT   pwfx
)
{
    DPF_ENTER();
    
    CreateXboxAdpcmFormat(nChannels, nSamplesPerSec, pwfx);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  XAudioDownloadEffectsImage
 *
 *  Description:
 *      Downloads an effects image to the DSP.
 *
 *  Arguments:
 *      LPCSTR [in]: file or section name.
 *      LPCDSEFFECTIMAGELOC [in]: effect locations.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "XAudioDownloadEffectsImage"

STDAPI
XAudioDownloadEffectsImage
(
    LPCSTR                  pszImageName,
    LPCDSEFFECTIMAGELOC     pEffectLoc,
    DWORD                   dwFlags,
    LPDSEFFECTIMAGEDESC *   ppImageDesc
)
{
    HANDLE                  hImageFile      = NULL;
    LPVOID                  pvImageData     = NULL;
    HRESULT                 hr              = DS_OK;
    DWORD                   dwImageSize;

    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifdef VALIDATE_PARAMETERS

    if(!pszImageName)
    {
        DPF_ERROR("No image name supplied");
    }

    if(dwFlags & ~XAUDIO_DOWNLOADFX_VALID)
    {
        DPF_ERROR("Invalid flags");
    }

#endif // VALIDATE_PARAMETERS

    if(!CDirectSound::m_pDirectSound)
    {
        DPF_ERROR("The DirectSound object must have already been created before calling " DPF_FNAME);
        hr = DSERR_INVALIDCALL;
    }

    //
    // Open the image
    //

    if(SUCCEEDED(hr))
    {
        if(dwFlags & XAUDIO_DOWNLOADFX_XBESECTION)
        {
            if(INVALID_HANDLE_VALUE == (hImageFile = XGetSectionHandle(pszImageName)))
            {
                DPF_ERROR("Can't find image section");
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            if(SUCCEEDED(hr))
            {
                if(!(dwImageSize = XGetSectionSize(hImageFile)))
                {
                    DPF_ERROR("Can't get image size");
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            if(SUCCEEDED(hr))
            {
                if(!(pvImageData = XLoadSectionByHandle(hImageFile)))
                {
                    DPF_ERROR("Can't read image section");
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
        else
        {
            if(INVALID_HANDLE_VALUE == (hImageFile = CreateFile(pszImageName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)))
            {
                DPF_ERROR("Can't find image file");
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            if(SUCCEEDED(hr))
            {
                if(!(dwImageSize = GetFileSize(hImageFile, NULL)))
                {
                    DPF_ERROR("Can't get image size");
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            if(SUCCEEDED(hr))
            {
                hr = HRFROMP(pvImageData = MEMALLOC_NOINIT(BYTE, dwImageSize));
            }

            if(SUCCEEDED(hr))
            {
                if(!ReadFile(hImageFile, pvImageData, dwImageSize, &dwImageSize, NULL))
                {
                    DPF_ERROR("Can't read image file");
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }

    //
    // Download the image
    //
    
    if(SUCCEEDED(hr))
    {
        hr = CDirectSound::m_pDirectSound->DownloadEffectsImage(pvImageData, dwImageSize, pEffectLoc, ppImageDesc);
    }

    //
    // Clean up
    //

    if(dwFlags & XAUDIO_DOWNLOADFX_XBESECTION)
    {
        if(IS_VALID_HANDLE_VALUE(hImageFile))
        {
            XFreeSectionByHandle(hImageFile);
        }
    }
    else
    {
        MEMFREE(pvImageData);
        CLOSE_HANDLE(hImageFile);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  XWaveFileCreateMediaObject
 *
 *  Description:
 *      Creates and initializes a WaveLoader XMO.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      LPCWAVEFORMATEX * [out]: receives a pointer to the file format.  The
 *                               file XMO maintains this data, so the caller
 *                               should not try to free this pointer.
 *      XMediaObject ** [out]: media object.  The caller is responsible for
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "XWaveFileCreateMediaObject"

HRESULT
XWaveFileCreateMediaObject
(
    LPCSTR                  pszFileName, 
    LPCWAVEFORMATEX *       ppwfxFormat, 
    XFileMediaObject **     ppMediaObject
)
{
    CWaveFileMediaObject *  pMediaObject;
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pszFileName)
    {
        DPF_ERROR("No file name specified");
    }

    if(!ppMediaObject)
    {
        DPF_ERROR("No media object pointer supplied");
    }

#endif // VALIDATE_PARAMETERS
    
    hr = HRFROMP(pMediaObject = NEW(CWaveFileMediaObject));

    if(SUCCEEDED(hr))
    {
        hr = pMediaObject->Initialize(pszFileName);
    }

    if(SUCCEEDED(hr) && ppwfxFormat)
    {
        hr = pMediaObject->GetFormat(ppwfxFormat);
    }

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  XWaveFileCreateMediaObjectEx
 *
 *  Description:
 *      Creates and initializes a WaveLoader XMO.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      LPCWAVEFORMATEX * [out]: receives a pointer to the file format.  The
 *                               file XMO maintains this data, so the caller
 *                               should not try to free this pointer.
 *      XMediaObject ** [out]: media object.  The caller is responsible for
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "XWaveFileCreateMediaObjectEx"

HRESULT
XWaveFileCreateMediaObjectEx
(
    LPCSTR                  pszFileName, 
    HANDLE                  hFile,
    XWaveFileMediaObject ** ppMediaObject
)
{
    CWaveFileMediaObject *  pMediaObject;
    HRESULT                 hr;

    DPF_ENTER();
    
#ifdef VALIDATE_PARAMETERS

    if(!pszFileName && !IS_VALID_HANDLE_VALUE(hFile))
    {
        DPF_ERROR("No file name or handle specified");
    }

    if(pszFileName && IS_VALID_HANDLE_VALUE(hFile))
    {
        DPF_ERROR("Both file name and handle specified");
    }

    if(!ppMediaObject)
    {
        DPF_ERROR("No media object pointer supplied");
    }

#endif // VALIDATE_PARAMETERS
    
    hr = HRFROMP(pMediaObject = NEW(CWaveFileMediaObject));

    if(SUCCEEDED(hr))
    {
        if(pszFileName)
        {
            hr = pMediaObject->Initialize(pszFileName);
        }
        else
        {
            hr = pMediaObject->Initialize(hFile);
        }
    }

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  XFileCreateMediaObject
 *
 *  Description:
 *      Creates and initializes a File XMO.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      DWORD [in]: access mask.
 *      DWORD [in]: share mask.
 *      DWORD [in]: creation distribution.
 *      DWORD [in]: attribute mask.
 *      XMediaObject ** [out]: media object.  The caller is responsible for
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "XFileCreateMediaObject"

HRESULT
XFileCreateMediaObject
(
    LPCSTR                  pszFileName, 
    DWORD                   dwDesiredAccess, 
    DWORD                   dwShareMode, 
    DWORD                   dwCreationDisposition, 
    DWORD                   dwFlagsAndAttributes,
    XFileMediaObject **     ppMediaObject
)
{
    CFileMediaObject *      pMediaObject;
    HRESULT                 hr;

    DPF_ENTER();
    
    hr = HRFROMP(pMediaObject = NEW(CFileMediaObject));

    if(SUCCEEDED(hr))
    {
        hr = pMediaObject->Initialize(pszFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, dwFlagsAndAttributes);
    }

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  XFileCreateMediaObject
 *
 *  Description:
 *      Creates and initializes a File XMO.
 *
 *  Arguments:
 *      HANDLE [in]: file handle.
 *      XMediaObject ** [out]: media object.  The caller is responsible for
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "XFileCreateMediaObjectEx"

HRESULT
XFileCreateMediaObjectEx
(
    HANDLE                  hFile,
    XFileMediaObject **     ppMediaObject
)
{
    CFileMediaObject *      pMediaObject;
    HRESULT                 hr;

    DPF_ENTER();
    
    hr = HRFROMP(pMediaObject = NEW(CFileMediaObject));

    if(SUCCEEDED(hr))
    {
        hr = pMediaObject->Initialize(hFile);
    }

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Ac97CreateMediaObject
 *
 *  Description:
 *      Creates and initializes an AC97 Media Object.
 *
 *  Arguments:
 *      DWORD [in]: channel identifier.
 *      XMediaObject ** [out]: receives channel object.  The caller is
 *                             responsible for freeing this object with
 *                             Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Ac97CreateMediaObject"

HRESULT
Ac97CreateMediaObject
(
    DWORD                       dwChannel,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback, 
    LPVOID                      pvCallbackContext,
    XAc97MediaObject **         ppMediaObject
)
{
    CAc97MediaObject *          pMediaObject    = NULL;
    HRESULT                     hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    //
    // Create the AC97 media object
    //

    hr = HRFROMP(pMediaObject = NEW(CAc97MediaObject));
   
    if(SUCCEEDED(hr))
    {
        hr = pMediaObject->Initialize(dwChannel, pfnCallback, pvCallbackContext);
    }

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundDumpMemoryUsage
 *
 *  Description:
 *      Dumps current memory usage to the debugger.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to assert that there is no memory allocated.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundDumpMemoryUsage"

void
DirectSoundDumpMemoryUsage
(
    BOOL                    fAssertNone
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    CMemoryManager::DumpMemoryUsage(fAssertNone);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CDirectSoundSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSettings::CDirectSoundSettings"

CDirectSoundSettings::CDirectSoundSettings
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();

#ifndef MCPX_BOOT_LIB

    m_3dParams.HrtfParams = DirectSoundDefault3DListener;
    m_3dParams.I3dl2Params = DirectSoundI3DL2ListenerPreset_Default;

#endif // MCPX_BOOT_LIB

    //
    // Read the speaker configuration from the EEPROM
    //

#ifndef MCPX_BOOT_LIB

    if(DSSPEAKER_IS_VALID(g_dwDirectSoundOverrideSpeakerConfig))
    {
        m_dwSpeakerConfig = g_dwDirectSoundOverrideSpeakerConfig;
    }
    else
    {
        m_dwSpeakerConfig = XAudioGetSpeakerConfig();
    }

#else // MCPX_BOOT_LIB

    m_dwSpeakerConfig = DSSPEAKER_STEREO;

#endif // MCPX_BOOT_LIB

    //
    // Set default mixbin headroom
    //

    for(i = 0; i < DSMIXBIN_SUBMIX; i++)
    {
        m_abMixBinHeadroom[i] = DSHEADROOM_DEFAULT;
    }

    m_abMixBinHeadroom[DSMIXBIN_SUBMIX] = 0;

    //
    // Set default effect locations
    //

    SetEffectImageLocations(NULL);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSettings::~CDirectSoundSettings"

CDirectSoundSettings::~CDirectSoundSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetEffectImageLocations
 *
 *  Description:
 *      Sets effect indeces.
 *
 *  Arguments:
 *      LPCDSEFFECTIMAGELOC [in]: effect locations.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSettings::SetEffectImageLocations"

void
CDirectSoundSettings::SetEffectImageLocations
(
    LPCDSEFFECTIMAGELOC     pImageLoc
)
{
    DPF_ENTER();

    if(pImageLoc)
    {
        CopyMemory(&m_EffectLocations, pImageLoc, sizeof(*pImageLoc));
    }
    else
    {
        memset(&m_EffectLocations, 0xFF, sizeof(m_EffectLocations));
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CDirectSound
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CDirectSound"

CDirectSound *CDirectSound::m_pDirectSound;

#ifdef DEBUG

LPVOID CDirectSound::m_pvEncoderImageData;
DWORD CDirectSound::m_dwEncoderImageSize;

#endif // DEBUG

CDirectSound::CDirectSound
(
    void
)

#ifdef USE_KEEPALIVE_BUFFERS

:   CRefCount(2)

#endif // USE_KEEPALIVE_BUFFER

{
    DPF_ENTER();

    //
    // Set the global DirectSound object pointer
    //

    m_pDirectSound = this;

    //
    // Initialize defaults
    //

    InitializeListHead(&m_lst3dVoices);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSound
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::~CDirectSound"

CDirectSound::~CDirectSound
(
    void
)
{
    DPF_ENTER();

    //
    // Release performance counters
    //

    CPerfMon::UnregisterCounters();

    //
    // Release the global DirectSound object pointer
    //

    m_pDirectSound = NULL;

    //
    // Free owned objects
    //

    RELEASE(m_pDevice);
    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: reference count.
 *
 ****************************************************************************/

#ifdef USE_KEEPALIVE_BUFFERS

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::Release"

DWORD
CDirectSound::Release
(
    void
)
{
    DWORD                   dwRefCount;
    DWORD                   dwStatus;
    HRESULT                 hr;
    DWORD                   i;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if((dwRefCount = CRefCount::Release()) == NUMELMS(m_apKeepAliveBuffers) + 1)
    {
        //
        // The only references we have left are the keepalive buffers and the
        // artificial one we added at creation.  Go ahead and shut down.
        //

        for(i = 0; i < NUMELMS(m_apKeepAliveBuffers); i++)
        {
            ASSERT(m_apKeepAliveBuffers[i]);

            m_apKeepAliveBuffers[i]->Stop();
        }

        for(i = 0; i < NUMELMS(m_apKeepAliveBuffers); i++)
        {
            ASSERT(m_apKeepAliveBuffers[i]);

            do
            {
                DoWork();
                
                hr = m_apKeepAliveBuffers[i]->GetStatus(&dwStatus);
            }
            while(SUCCEEDED(hr) && (dwStatus & DSBSTATUS_PLAYING));

            RELEASE(m_apKeepAliveBuffers[i]);
        }

        dwRefCount = CRefCount::Release();
        ASSERT(!dwRefCount);
    }

    DPF_LEAVE(dwRefCount);

    return dwRefCount;
}

#endif // USE_KEEPALIVE_BUFFERS


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::Initialize"

HRESULT
CDirectSound::Initialize
(
    void
)
{

#ifdef USE_KEEPALIVE_BUFFERS

    static const WAVEFORMATEX   wfxSilence              = INIT_PCM_WAVEFORMAT(1, 48000, 16);
    static const SHORT          asSilence[32]           = { 0 };
    DSBUFFERDESC                dsbd;
    DSMIXBINVOLUMEPAIR          MixBinVolumePairs[8];
    DSMIXBINS                   MixBins;
    DWORD                       i, z;

#endif // USE_KEEPALIVE_BUFFERS

    HRESULT                     hr;

    DPF_ENTER();

    //
    // Create the shared settings object
    //

    hr = HRFROMP(m_pSettings = NEW(CDirectSoundSettings));

    //
    // Create the device object
    //

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pDevice = NEW(CMcpxAPU(m_pSettings)));
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDevice->Initialize();
    }

#ifdef USE_KEEPALIVE_BUFFERS

    //
    // Create dummy buffers.  The MCPX refuses to output any data at least 
    // one voice writes to the speaker mixbins.  We'll burn voices in order 
    // to write silence to all the mixbins all the time.
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));
        ZeroMemory(&MixBinVolumePairs, sizeof(MixBinVolumePairs));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = (LPWAVEFORMATEX)&wfxSilence;
        dsbd.lpMixBins = &MixBins;

        MixBins.dwMixBinCount = NUMELMS(MixBinVolumePairs);
        MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

        for(i = 0; SUCCEEDED(hr) && (i < NUMELMS(m_apKeepAliveBuffers)); i++)
        {
            for(z = 0; z < NUMELMS(MixBinVolumePairs); z++)
            {
                MixBinVolumePairs[z].dwMixBin = (i * NUMELMS(MixBinVolumePairs)) + z;
            }

            if(DSMIXBIN_SUBMIX == MixBinVolumePairs[NUMELMS(MixBinVolumePairs) - 1].dwMixBin)
            {
                MixBins.dwMixBinCount--;
            }

            hr = CreateSoundBuffer(&dsbd, &m_apKeepAliveBuffers[i], NULL);

            if(SUCCEEDED(hr))
            {
                hr = m_apKeepAliveBuffers[i]->SetBufferData((LPVOID)asSilence, sizeof(asSilence));
            }

            if(SUCCEEDED(hr))
            {
                hr = m_apKeepAliveBuffers[i]->Play(0, 0, DSBPLAY_LOOPING);
            }
        }
    }

#endif // USE_KEEPALIVE_BUFFERS

    //
    // Set up performance counters
    //

    if(SUCCEEDED(hr))
    {
        CPerfMon::RegisterCounters();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets the capabilities of the object.
 *
 *  Arguments:
 *      LPDSCAPS [in/out]: capabilities.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetCaps"

HRESULT
CDirectSound::GetCaps
(
    LPDSCAPS                pdsc
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdsc)
    {
        DPF_ERROR("DSCAPS not supplied");
    }

#endif // VALIDATE_PARAMETERS
    
    pdsc->dwFree2DBuffers = g_dwDirectSoundFree2dVoices;
    pdsc->dwFree3DBuffers = g_dwDirectSoundFree3dVoices;
    pdsc->dwFreeBufferSGEs = g_dwDirectSoundFreeBufferSGEs;
    pdsc->dwMemoryAllocated = g_dwDirectSoundPoolMemoryUsage + g_dwDirectSoundPhysicalMemoryUsage;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  CreateSoundBuffer
 *
 *  Description:
 *      Creates a sound buffer object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.  The caller is expected
 *                                   to free this object with Release.
 *      LPUNKNOWN [in]: controlling unknown.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundBuffer"

HRESULT
CDirectSound::CreateSoundBuffer
(
    LPCDSBUFFERDESC         pdsbd,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPUNKNOWN               pControllingUnknown
)
{
    CDirectSoundBuffer *    pBuffer;
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!ppBuffer)
    {
        DPF_ERROR("Failed to supply an LPDIRECTSOUNDBUFFER *");
    }
    
    if(pControllingUnknown)
    {
        DPF_ERROR("Aggregation is not supported");
    }

#endif // VALIDATE_PARAMETERS

    hr = HRFROMP(pBuffer = NEW(CDirectSoundBuffer(this)));

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pdsbd);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CreateSoundStream
 *
 *  Description:
 *      Creates a sound buffer object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: buffer description.
 *      LPDIRECTSOUNDSTREAM * [out]: buffer object.  The caller is expected
 *                                   to free this object with Release.
 *      LPUNKNOWN [in]: controlling unknown.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundStream"

HRESULT
CDirectSound::CreateSoundStream
(
    LPCDSSTREAMDESC         pdssd,
    LPDIRECTSOUNDSTREAM *   ppStream,
    LPUNKNOWN               pControllingUnknown
)
{
    CDirectSoundStream *    pStream;
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!ppStream)
    {
        DPF_ERROR("Failed to supply an LPDIRECTSOUNDSTREAM *");
    }
    
    if(pControllingUnknown)
    {
        DPF_ERROR("Aggregation is not supported");
    }

#endif // VALIDATE_PARAMETERS

    hr = HRFROMP(pStream = NEW(CDirectSoundStream(this)));

    if(SUCCEEDED(hr))
    {
        hr = pStream->Initialize(pdssd);
    }

    if(SUCCEEDED(hr))
    {
        *ppStream = pStream;
    }
    else
    {
        RELEASE(pStream);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  GetSpeakerConfig
 *
 *  Description:
 *      Gets the current speaker config.
 *
 *  Arguments:
 *      LPDWORD [out]: speaker config.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetSpeakerConfig"

HRESULT
CDirectSound::GetSpeakerConfig
(
    LPDWORD                 pdwSpeakerConfig
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwSpeakerConfig)
    {
        DPF_ERROR("Failed to supply speaker config buffer");
    }

#endif // VALIDATE_PARAMETERS

    *pdwSpeakerConfig = m_pSettings->m_dwSpeakerConfig & ~DSSPEAKER_ENABLE_HEADPHONES;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  DownloadEffectsImage
 *
 *  Description:
 *      Downloads an effects image to the effects processor.
 *
 *  Arguments:
 *      LPCVOID [in]: image data.
 *      DWORD [in]: image data size, in bytes.
 *      LPCDSEFFECTIMAGELOC [in]: effect locations.
 *      LPVOID * [out]: image scratch data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::DownloadEffectsImage"

HRESULT
CDirectSound::DownloadEffectsImage
(
    LPCVOID                 pvImageBuffer, 
    DWORD                   dwImageSize,
    LPCDSEFFECTIMAGELOC     pImageLoc, 
    LPDSEFFECTIMAGEDESC *   ppImageDesc
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pvImageBuffer)
    {
        DPF_ERROR("Failed to supply an image buffer");
    }

    if(dwImageSize <= (DSP_COMMANDBLOCK_SCRATCHOFFSET + sizeof(HOST_TO_DSP_COMMANDBLOCK)))
    {
        DPF_ERROR("Invalid image size");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Save the effect locations
    //

    m_pSettings->SetEffectImageLocations(pImageLoc);

    //
    // Download the image
    //

    hr = m_pDevice->DownloadEffectsImage(pvImageBuffer, dwImageSize, ppImageDesc);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  SetEffectData
 *
 *  Description:
 *      Updates part or all of an effect's data.
 *
 *  Arguments:
 *      DWORD [in]: absolute effect index.
 *      DWORD [in]: offset, in bytes, of the start of the update region.
 *      LPCVOID [in]: data buffer.
 *      DWORD [in]: data buffer size, in bytes.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetEffectData"

HRESULT
CDirectSound::SetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPCVOID                 pvData, 
    DWORD                   dwDataSize,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwOffset & 3)
    {
        DPF_ERROR("Offset must be DWORD-aligned");
    }

    if(!pvData)
    {
        DPF_ERROR("Failed to supply a data buffer");
    }

    if(!dwDataSize)
    {
        DPF_ERROR("Invalid data size");
    }

    if(dwDataSize & 3)
    {
        DPF_ERROR("Data size must be DWORD-aligned");
    }

    if(dwFlags & ~DSFX_VALID)
    {
        DPF_ERROR("Invalid flags");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pDevice->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetEffectData
 *
 *  Description:
 *      Retrieves part or all of an effect's data.
 *
 *  Arguments:
 *      DWORD [in]: absolute effect index.
 *      DWORD [in]: offset, in bytes, of the start of the update region.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetEffectData"

HRESULT
CDirectSound::GetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwOffset & 3)
    {
        DPF_ERROR("Offset must be DWORD-aligned");
    }

    if(!pvData)
    {
        DPF_ERROR("Failed to supply a data buffer");
    }

    if(!dwDataSize)
    {
        DPF_ERROR("Invalid data size");
    }

    if(dwDataSize & 3)
    {
        DPF_ERROR("Data size must be DWORD-aligned");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pDevice->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitEffectData
 *
 *  Description:
 *      Commits deferred effects settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CommitEffectData"

HRESULT 
CDirectSound::CommitEffectData
(
    void
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    hr = m_pDevice->CommitEffectData();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBinHeadroom
 *
 *  Description:
 *      Sets the headroom for a mixbin.
 *
 *  Arguments:
 *      DWORD [in]: mixbin identifier.
 *      DWORD [in]: headroom amount.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetMixBinHeadroom"

HRESULT
CDirectSound::SetMixBinHeadroom
(
    DWORD                   dwMixBin,
    DWORD                   dwHeadroom
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwMixBin >= DSMIXBIN_COUNT)
    {
        DPF_ERROR("Invalid mixbin");
    }

    if((dwHeadroom < DSHEADROOM_MIN) || (dwHeadroom > DSHEADROOM_MAX))
    {
        DPF_ERROR("Invalid headroom value");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the settings object
    //

    m_pSettings->m_abMixBinHeadroom[dwMixBin] = (BYTE)dwHeadroom;
    
    //
    // Update the implementation object
    //

    hr = m_pDevice->SetMixBinHeadroom(dwMixBin);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [in]: properties.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetAllParameters"

HRESULT 
CDirectSound::SetAllParameters
(
    LPCDS3DLISTENER         pParams, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pParams)
    {
        DPF_ERROR("Buffer not supplied");
    }

    if(pParams->dwSize < sizeof(*pParams))
    {
        DPF_ERROR("Structure size too small");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if((pParams->flDistanceFactor < DS3D_MINDISTANCEFACTOR) || (pParams->flDistanceFactor > DS3D_MAXDISTANCEFACTOR))
    {
        DPF_ERROR("Distance factor out of bounds");
    }

    if((pParams->flDopplerFactor < DS3D_MINDOPPLERFACTOR) || (pParams->flDopplerFactor > DS3D_MAXDOPPLERFACTOR))
    {
        DPF_ERROR("Doppler factor out of bounds");
    }

    if((pParams->flRolloffFactor < DS3D_MINROLLOFFFACTOR) || (pParams->flRolloffFactor > DS3D_MAXROLLOFFFACTOR))
    {
        DPF_ERROR("Rolloff factor out of bounds");
    }

    if((!pParams->vOrientFront.x && !pParams->vOrientFront.y && !pParams->vOrientFront.z) || (!pParams->vOrientTop.x && !pParams->vOrientTop.y && !pParams->vOrientTop.z))
    {
        DPF_ERROR("Invalid orientation");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.HrtfParams.vPosition.x = NormalizeFloat(pParams->vPosition.x);
    m_pSettings->m_3dParams.HrtfParams.vPosition.y = NormalizeFloat(pParams->vPosition.y);
    m_pSettings->m_3dParams.HrtfParams.vPosition.z = NormalizeFloat(pParams->vPosition.z);

    m_pSettings->m_3dParams.HrtfParams.vVelocity.x = NormalizeFloat(pParams->vVelocity.x);
    m_pSettings->m_3dParams.HrtfParams.vVelocity.y = NormalizeFloat(pParams->vVelocity.y);
    m_pSettings->m_3dParams.HrtfParams.vVelocity.z = NormalizeFloat(pParams->vVelocity.z);

    m_pSettings->m_3dParams.HrtfParams.vOrientFront.x = NormalizeFloat(pParams->vOrientFront.x);
    m_pSettings->m_3dParams.HrtfParams.vOrientFront.y = NormalizeFloat(pParams->vOrientFront.y);
    m_pSettings->m_3dParams.HrtfParams.vOrientFront.z = NormalizeFloat(pParams->vOrientFront.z);
    
    m_pSettings->m_3dParams.HrtfParams.vOrientTop.x = NormalizeFloat(pParams->vOrientTop.x);
    m_pSettings->m_3dParams.HrtfParams.vOrientTop.y = NormalizeFloat(pParams->vOrientTop.y);
    m_pSettings->m_3dParams.HrtfParams.vOrientTop.z = NormalizeFloat(pParams->vOrientTop.z);

    m_pSettings->m_3dParams.HrtfParams.flDistanceFactor = NormalizeFloat(pParams->flDistanceFactor);
    m_pSettings->m_3dParams.HrtfParams.flRolloffFactor = NormalizeFloat(pParams->flRolloffFactor);
    m_pSettings->m_3dParams.HrtfParams.flDopplerFactor = NormalizeFloat(pParams->flDopplerFactor);

    m_pSettings->m_3dParams.dwParameterMask |= DS3DPARAM_LISTENER_MASK;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets the world's distance factor.
 *
 *  Arguments:
 *      FLOAT [in]: distance factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDistanceFactor"

HRESULT 
CDirectSound::SetDistanceFactor
(
    FLOAT                   flDistanceFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((flDistanceFactor < DS3D_MINDISTANCEFACTOR) || (flDistanceFactor > DS3D_MAXDISTANCEFACTOR))
    {
        DPF_ERROR("Distance factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.HrtfParams.flDistanceFactor = NormalizeFloat(flDistanceFactor);

    m_pSettings->m_3dParams.dwParameterMask |= DS3DPARAM_LISTENER_DISTANCEFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets the world's Doppler factor.
 *
 *  Arguments:
 *      FLOAT [in]: Doppler factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDopplerFactor"

HRESULT 
CDirectSound::SetDopplerFactor
(
    FLOAT                   flDopplerFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((flDopplerFactor < DS3D_MINDOPPLERFACTOR) || (flDopplerFactor > DS3D_MAXDOPPLERFACTOR))
    {
        DPF_ERROR("Doppler factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.HrtfParams.flDopplerFactor = NormalizeFloat(flDopplerFactor);

    m_pSettings->m_3dParams.dwParameterMask |= DS3DPARAM_LISTENER_DOPPLERFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets the world's rolloff factor.
 *
 *  Arguments:
 *      FLOAT [in]: rolloff factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetRolloffFactor"

HRESULT 
CDirectSound::SetRolloffFactor
(
    FLOAT                   flRolloffFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((flRolloffFactor < DS3D_MINROLLOFFFACTOR) || (flRolloffFactor > DS3D_MAXROLLOFFFACTOR))
    {
        DPF_ERROR("Rolloff factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.HrtfParams.flRolloffFactor = NormalizeFloat(flRolloffFactor);

    m_pSettings->m_3dParams.dwParameterMask |= DS3DPARAM_LISTENER_ROLLOFFFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetOrientation
 *
 *  Description:
 *      Sets the listener's orientation.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: front orientation.
 *      REFD3DXVECTOR3 [in]: top orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetOrientation"

HRESULT 
CDirectSound::SetOrientation
(
    FLOAT                   flFrontX, 
    FLOAT                   flFrontY, 
    FLOAT                   flFrontZ, 
    FLOAT                   flTopX, 
    FLOAT                   flTopY, 
    FLOAT                   flTopZ, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if((!flFrontX && !flFrontY && !flFrontZ) || (!flTopX && !flTopY && !flTopZ))
    {
        DPF_ERROR("Invalid orientation");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.HrtfParams.vOrientFront.x = NormalizeFloat(flFrontX);
    m_pSettings->m_3dParams.HrtfParams.vOrientFront.y = NormalizeFloat(flFrontY);
    m_pSettings->m_3dParams.HrtfParams.vOrientFront.z = NormalizeFloat(flFrontZ);

    m_pSettings->m_3dParams.HrtfParams.vOrientTop.x = NormalizeFloat(flTopX);
    m_pSettings->m_3dParams.HrtfParams.vOrientTop.y = NormalizeFloat(flTopY);
    m_pSettings->m_3dParams.HrtfParams.vOrientTop.z = NormalizeFloat(flTopZ);

    m_pSettings->m_3dParams.dwParameterMask |= DS3DPARAM_LISTENER_ORIENTATION;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the listener's position.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetPosition"

HRESULT 
CDirectSound::SetPosition
(
    FLOAT                   flPositionX,
    FLOAT                   flPositionY,
    FLOAT                   flPositionZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.HrtfParams.vPosition.x = NormalizeFloat(flPositionX);
    m_pSettings->m_3dParams.HrtfParams.vPosition.y = NormalizeFloat(flPositionY);
    m_pSettings->m_3dParams.HrtfParams.vPosition.z = NormalizeFloat(flPositionZ);

    m_pSettings->m_3dParams.dwParameterMask |= DS3DPARAM_LISTENER_POSITION;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the listener's velocity.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetVelocity"

HRESULT 
CDirectSound::SetVelocity
(
    FLOAT                   flVelocityX,
    FLOAT                   flVelocityY,
    FLOAT                   flVelocityZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.HrtfParams.vVelocity.x = NormalizeFloat(flVelocityX);
    m_pSettings->m_3dParams.HrtfParams.vVelocity.y = NormalizeFloat(flVelocityY);
    m_pSettings->m_3dParams.HrtfParams.vVelocity.z = NormalizeFloat(flVelocityZ);

    m_pSettings->m_3dParams.dwParameterMask |= DS3DPARAM_LISTENER_VELOCITY;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetI3DL2Listener
 *
 *  Description:
 *      Sets I3DL2 listener properties.
 *
 *  Arguments:
 *      LPCDSI3DL2LISTENER [in]: listener properties.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetI3DL2Listener"

HRESULT
CDirectSound::SetI3DL2Listener
(
    LPCDSI3DL2LISTENER      pParams,
    DWORD                   dwFlags
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();    
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pParams)
    {
        DPF_ERROR("Failed to supply properties");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if((pParams->lRoom < DSI3DL2LISTENER_MINROOM) || (pParams->lRoom > DSI3DL2LISTENER_MAXROOM))
    {
        DPF_ERROR("Invalid lRoom value");
    }

    if((pParams->lRoomHF < DSI3DL2LISTENER_MINROOMHF) || (pParams->lRoomHF > DSI3DL2LISTENER_MAXROOMHF))
    {
        DPF_ERROR("Invalid lRoomHF value");
    }

    if((pParams->flRoomRolloffFactor < DSI3DL2LISTENER_MINROOMROLLOFFFACTOR) || (pParams->flRoomRolloffFactor > DSI3DL2LISTENER_MAXROOMROLLOFFFACTOR))
    {
        DPF_ERROR("Invalid flRoomRolloffFactor value");
    }

    if((pParams->flDecayTime < DSI3DL2LISTENER_MINDECAYTIME) || (pParams->flDecayTime > DSI3DL2LISTENER_MAXDECAYTIME))
    {
        DPF_ERROR("Invalid flDecayTime value");
    }

    if((pParams->flDecayHFRatio < DSI3DL2LISTENER_MINDECAYHFRATIO) || (pParams->flDecayHFRatio > DSI3DL2LISTENER_MAXDECAYHFRATIO))
    {
        DPF_ERROR("Invalid flDecayHFRatio value");
    }

    if((pParams->lReflections < DSI3DL2LISTENER_MINREFLECTIONS) || (pParams->lReflections > DSI3DL2LISTENER_MAXREFLECTIONS))
    {
        DPF_ERROR("Invalid lReflections value");
    }

    if((pParams->flReflectionsDelay < DSI3DL2LISTENER_MINREFLECTIONSDELAY) || (pParams->flReflectionsDelay > DSI3DL2LISTENER_MAXREFLECTIONSDELAY))
    {
        DPF_ERROR("Invalid flReflectionsDelay value");
    }

    if((pParams->lReverb < DSI3DL2LISTENER_MINREVERB) || (pParams->lReverb > DSI3DL2LISTENER_MAXREVERB))
    {
        DPF_ERROR("Invalid lReverb value");
    }

    if((pParams->flReverbDelay < DSI3DL2LISTENER_MINREVERBDELAY) || (pParams->flReverbDelay > DSI3DL2LISTENER_MAXREVERBDELAY))
    {
        DPF_ERROR("Invalid flReverbDelay value");
    }

    if((pParams->flDiffusion < DSI3DL2LISTENER_MINDIFFUSION) || (pParams->flDiffusion > DSI3DL2LISTENER_MAXDIFFUSION))
    {
        DPF_ERROR("Invalid flDiffusion value");
    }

    if((pParams->flDensity < DSI3DL2LISTENER_MINDENSITY) || (pParams->flDensity > DSI3DL2LISTENER_MAXDENSITY))
    {
        DPF_ERROR("Invalid flDensity value");
    }

    if((pParams->flHFReference < DSI3DL2LISTENER_MINHFREFERENCE) || (pParams->flHFReference > DSI3DL2LISTENER_MAXHFREFERENCE))
    {
        DPF_ERROR("Invalid flHFReference value");
    }

#endif // VALIDATE_PARAMETERS

    if(DSFX_IMAGELOC_UNUSED == m_pSettings->m_EffectLocations.dwI3DL2ReverbIndex)
    {
        DPF_ERROR("Can't set I3DL2 listener properties without loading the I3DL2 reverb effect");
        hr = DSERR_INVALIDCALL;
    }

    if(SUCCEEDED(hr))
    {
        m_pSettings->m_3dParams.I3dl2Params.lRoom = pParams->lRoom;
        m_pSettings->m_3dParams.I3dl2Params.lRoomHF = pParams->lRoomHF;
        m_pSettings->m_3dParams.I3dl2Params.flRoomRolloffFactor = NormalizeFloat(pParams->flRoomRolloffFactor);;
        m_pSettings->m_3dParams.I3dl2Params.flDecayTime = NormalizeFloat(pParams->flDecayTime);
        m_pSettings->m_3dParams.I3dl2Params.flDecayHFRatio = NormalizeFloat(pParams->flDecayHFRatio);
        m_pSettings->m_3dParams.I3dl2Params.lReflections = pParams->lReflections;
        m_pSettings->m_3dParams.I3dl2Params.flReflectionsDelay = NormalizeFloat(pParams->flReflectionsDelay);
        m_pSettings->m_3dParams.I3dl2Params.lReverb = pParams->lReverb;
        m_pSettings->m_3dParams.I3dl2Params.flReverbDelay = NormalizeFloat(pParams->flReverbDelay);
        m_pSettings->m_3dParams.I3dl2Params.flDiffusion = NormalizeFloat(pParams->flDiffusion);
        m_pSettings->m_3dParams.I3dl2Params.flDensity = NormalizeFloat(pParams->flDensity);
        m_pSettings->m_3dParams.I3dl2Params.flHFReference = NormalizeFloat(pParams->flHFReference);

        m_pSettings->m_3dParams.dwParameterMask |= DS3DPARAM_LISTENER_I3DL2;

        if(!(dwFlags & DS3D_DEFERRED))
        {
            CommitDeferredSettings();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitDeferredSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CommitDeferredSettings"

HRESULT 
CDirectSound::CommitDeferredSettings
(
    void
)
{
    DWORD                   dwParameterMask;
    PLIST_ENTRY             pleEntry;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    //
    // Recalculate changed 3D listener parameters
    //

    dwParameterMask = m_pDevice->Commit3dSettings();

    //
    // Recalculate all 3D voices
    //

    for(pleEntry = m_lst3dVoices.Flink; pleEntry != &m_lst3dVoices; pleEntry = pleEntry->Flink)
    {
        CONTAINING_RECORD(pleEntry, CDirectSoundVoice, m_le3dVoice)->CommitDeferredSettings();
    }

    //
    // Clear the parameter mask
    //

    m_pSettings->m_3dParams.dwParameterMask &= ~dwParameterMask;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  GetTime
 *
 *  Description:
 *      Gets the current time.
 *
 *  Arguments:
 *      REFERENCE_TIME * [out]: current time.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetTime"

HRESULT
CDirectSound::GetTime
(
    REFERENCE_TIME *        prtCurrent
)
{
    DPF_ENTER();    

#ifdef VALIDATE_PARAMETERS

    if(!prtCurrent)
    {
        DPF_ERROR("Failed to specify a time buffer");
    }

#endif // VALIDATE_PARAMETERS

    KeQuerySystemTime((PLARGE_INTEGER)prtCurrent);

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}

/****************************************************************************
 *
 *  GetTime
 *
 *  Description:
 *      Gets the current EP output levels.
 *
 *  Arguments:
 *      DSOUTPUTLEVELS * [out]: current output levels.
 *      BOOL bReset [in]: Reset peak values
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetOutputLevels"

HRESULT
CDirectSound::GetOutputLevels
(
    DSOUTPUTLEVELS *        pLevels,
    BOOL bReset
)
{
    PDSOUTPUTLEVELS pDspLevels;
    DPF_ENTER();    

#ifdef VALIDATE_PARAMETERS

    if(!pLevels)
    {
        DPF_ERROR("Failed to specify an output level buffer");
    }

#endif // VALIDATE_PARAMETERS

    //
    // map a data struct on top the of EP dsp P ram location where
    // the output levels get cached, twice every 5.33ms
    //

    pDspLevels = (PDSOUTPUTLEVELS) ((PUCHAR) XPCICFG_APU_MEMORY_REGISTER_BASE_0 + 
        NV_PAPU_EPPMEM(0) +
        EP_OFFSET_OUTPUT_LEVELS_ANALOG_PEAK*sizeof(DWORD));

    //
    // copy levels to caller supplied buffer
    //

    memcpy(pLevels, pDspLevels, sizeof(DSOUTPUTLEVELS));

    //
    // if the caller wants to reset the historical max values
    // reset them now
    //

    if (bReset) {

        pDspLevels->dwAnalogLeftTotalPeak = 0;          // analog peak
        pDspLevels->dwAnalogRightTotalPeak = 0;
        pDspLevels->dwDigitalFrontLeftPeak = 0;         // digital peak levels
        pDspLevels->dwDigitalFrontCenterPeak = 0;
        pDspLevels->dwDigitalFrontRightPeak = 0;
        pDspLevels->dwDigitalBackLeftPeak = 0;
        pDspLevels->dwDigitalBackRightPeak = 0;
        pDspLevels->dwDigitalLowFrequencyPeak = 0;

    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  DoWork
 *
 *  Description:
 *      Uh... does some work?
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::DoWork"

void
CDirectSound::DoWork
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD_VOID();

    m_pDevice->DoWork();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  EnableHeadphones
 *
 *  Description:
 *      Enables or disables headphone support.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::EnableHeadphones"

HRESULT
CDirectSound::EnableHeadphones
(
    BOOL                    fEnable
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if(MAKEBOOL(m_pSettings->m_dwSpeakerConfig & DSSPEAKER_ENABLE_HEADPHONES) != MAKEBOOL(fEnable))
    {
        //
        // Set the headphone bit in the speaker config
        //

        if(fEnable)
        {
            m_pSettings->m_dwSpeakerConfig |= DSSPEAKER_ENABLE_HEADPHONES;
        }
        else
        {
            m_pSettings->m_dwSpeakerConfig &= ~DSSPEAKER_ENABLE_HEADPHONES;
        }

        //
        // Update the APU
        //

        hr = m_pDevice->SetSpeakerConfig();

        //
        // Recalculate the whole 3D world
        //

        if(SUCCEEDED(hr))
        {
            m_pSettings->m_3dParams.dwParameterMask = ~0UL;
            
            hr = CommitDeferredSettings();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  CDirectSoundVoiceSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::CDirectSoundVoiceSettings"

CDirectSoundVoiceSettings::CDirectSoundVoiceSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundVoiceSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings"

CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings
(
    void
)
{
    DPF_ENTER();
    
    //
    // Release the output buffer
    //

    if(m_pMixinBuffer)
    {
        SetOutputBuffer(NULL);
    }

#ifndef MCPX_BOOT_LIB

    //
    // Free memory
    //

    MEMFREE(m_p3dParams);

#endif // MCPX_BOOT_LIB

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: voice creation flags.
 *      LPCWAVEFORMATEX [in]: voice format.
 *      LPCDSMIXBINS [in]: mix bin assignments.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::Initialize"

HRESULT
CDirectSoundVoiceSettings::Initialize
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    LPCDSMIXBINS            pMixBins
)
{
    HRESULT                 hr              = DS_OK;
    BOOL                    fSetMixBins;

    DPF_ENTER();

    ASSERT(pwfxFormat);

    //
    // Save flags
    //
    
    m_dwFlags = dwFlags;

    //
    // Set default headroom
    //

    if(m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        m_dwHeadroom = DSBHEADROOM_DEFAULT_SUBMIX;
    }
    else if(m_dwFlags & DSBCAPS_CTRL3D)
    {
        m_dwHeadroom = DSBHEADROOM_DEFAULT_3D;
    }
    else
    {
        m_dwHeadroom = DSBHEADROOM_DEFAULT_2D;
    }

    //
    // Set format.  If mixbins were specified, we won't allow the format
    // to override them.
    //

    fSetMixBins = SetFormat(pwfxFormat, !pMixBins);

    //
    // If SetFormat didn't set the mixbins for us, we'll need to do it now
    //

    if(!fSetMixBins)
    {
        SetMixBins(pMixBins);
    }

    //
    // Set default volume
    //

    SetVolume(DSBVOLUME_MAX);

#ifndef MCPX_BOOT_LIB

    //
    // Allocate 3D parameter data
    //

    if(m_dwFlags & DSBCAPS_CTRL3D)
    {
        hr = HRFROMP(m_p3dParams = MEMALLOC(DS3DSOURCEPARAMS, 1));

        if(SUCCEEDED(hr))
        {
            m_p3dParams->HrtfParams = DirectSoundDefault3DBuffer;
            m_p3dParams->I3dl2Params = DirectSoundDefaultI3DL2Buffer;
            m_p3dParams->dwParameterMask = DS3DPARAM_BUFFER_MASK;
        }
    }

#endif // MCPX_BOOT_LIB

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the voice format.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: voice format.
 *      BOOL [in]: TRUE to allow the format to define the mixbins.
 *
 *  Returns:  
 *      BOOL: TRUE if the voice format changed the mixbin assignments.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetFormat"

BOOL
CDirectSoundVoiceSettings::SetFormat
(
    LPCWAVEFORMATEX         pwfxFormat,
    BOOL                    fAllowMixBins
)
{
    BOOL                    fSetMixBins                                     = FALSE;
    DWORD                   dwChannelMask;
    DSMIXBINS               MixBins;
    DSMIXBINVOLUMEPAIR      MixBinVolumePairs[DSMIXBIN_ASSIGNMENT_MAX];
    
    DPF_ENTER();

    ASSERT(pwfxFormat);

    //
    // Save format.  If MixBins were specified by the format, we'll use those
    // assuming no mixbins were passed to us and the voice is 2D.
    //

    if(dwChannelMask = CreateInternalFormat(&m_fmt, pwfxFormat))
    {
        if(!(m_dwFlags & DSBCAPS_CTRL3D) && fAllowMixBins)
        {
            MixBins.dwMixBinCount = 0;
            MixBins.lpMixBinVolumePairs = MixBinVolumePairs;
            
            while(dwChannelMask && (MixBins.dwMixBinCount < NUMELMS(MixBinVolumePairs)))
            {
                MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin = lsb(dwChannelMask);
                MixBinVolumePairs[MixBins.dwMixBinCount].lVolume = 0;

                MixBins.dwMixBinCount++;

                dwChannelMask &= ~(1UL << MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin);
            }

            SetMixBins(&MixBins);

            fSetMixBins = TRUE;
        }
    }

    //
    // Set default pitch
    //

    m_lPitch = XAudioCalculatePitch(m_fmt.nSamplesPerSec);

    DPF_LEAVE(fSetMixBins);

    return fSetMixBins;
}


/****************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets voice volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetVolume"

void
CDirectSoundVoiceSettings::SetVolume
(
    LONG                    lVolume
)
{
    DPF_ENTER();

    //
    // Apply headroom
    //

    m_lVolume = lVolume - m_dwHeadroom;
    ASSERT(m_lVolume <= DSBVOLUME_MAX);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMixBinVolumes
 *
 *  Description:
 *      Sets the volume of some number of mixbins.
 *
 *  Arguments:
 *      LPCDSMIXBINS [in]: mixbin/volume pairs.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetMixBinVolumes"

void
CDirectSoundVoiceSettings::SetMixBinVolumes
(
    LPCDSMIXBINS            pMixBins
)
{
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(pMixBins);
    ASSERT(pMixBins->dwMixBinCount <= NUMELMS(m_alMixBinVolumes));

    for(i = 0; i < pMixBins->dwMixBinCount; i++)
    {
        ASSERT(pMixBins->lpMixBinVolumePairs[i].dwMixBin < NUMELMS(m_alMixBinVolumes));
        
        m_alMixBinVolumes[pMixBins->lpMixBinVolumePairs[i].dwMixBin] = pMixBins->lpMixBinVolumePairs[i].lVolume;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetHeadroom
 *
 *  Description:
 *      Sets voice headroom.
 *
 *  Arguments:
 *      DWORD [in]: headroom.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetHeadroom"

void
CDirectSoundVoiceSettings::SetHeadroom
(
    DWORD                   dwHeadroom
)
{
    LONG                    lDiff;
    
    DPF_ENTER();

    //
    // Calculate the difference between the old headroom and the new one
    //

    lDiff = m_dwHeadroom - dwHeadroom;

    //
    // Save the new headroom
    //

    m_dwHeadroom = dwHeadroom;
    
    //
    // Update volume
    //

    m_lVolume += lDiff;
    ASSERT(m_lVolume <= DSBVOLUME_MAX);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMixBins
 *
 *  Description:
 *      Sets the mixbins used by the voice.
 *
 *  Arguments:
 *      LPCDSMIXBINS [in]: mixbin assignments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetMixBins"

void
CDirectSoundVoiceSettings::SetMixBins
(
    LPCDSMIXBINS                pMixBins
)
{
    static const LPCDSMIXBINS   apDefaultMixBins[] =
    {
        &DirectSoundDefaultMixBins_Mono,
        &DirectSoundDefaultMixBins_Stereo,
        &DirectSoundDefaultMixBins_4Channel,
        &DirectSoundDefaultMixBins_6Channel,
    };

    DWORD                       i;
    
    DPF_ENTER();

    //
    // If no mixbins were supplied, use defaults
    //

    if(!pMixBins)
    {
        if(m_dwFlags & DSBCAPS_CTRL3D)
        {
            pMixBins = &DirectSoundDefaultMixBins_3D;
        }
        else
        {
            ASSERT(m_fmt.nChannels / 2 < NUMELMS(apDefaultMixBins));
            pMixBins = apDefaultMixBins[m_fmt.nChannels / 2];
        }
    }

    //
    // Set mixbins and volume
    //

    ASSERT(pMixBins);
    ASSERT(pMixBins->dwMixBinCount <= NUMELMS(m_abMixBins));
    
    for(m_dwMixBinCount = 0; m_dwMixBinCount < (BYTE)pMixBins->dwMixBinCount; m_dwMixBinCount++)
    {
        ASSERT(pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].dwMixBin < NUMELMS(m_alMixBinVolumes));
        
        m_abMixBins[m_dwMixBinCount] = (BYTE)pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].dwMixBin;
        m_alMixBinVolumes[m_abMixBins[m_dwMixBinCount]] = pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].lVolume;
    }

    //
    // If we're submixing, the submix bin must be included.  If it wasn't
    // included in the array, we'll add it automatically for "convenience"
    //

    if(m_pMixinBuffer)
    {
        ASSERT(m_pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK);

        for(i = 0; i < m_dwMixBinCount; i++)
        {
            if(m_abMixBins[i] == (BYTE)m_pMixinBuffer->m_pSettings->m_dwInputMixBin)
            {
                break;
            }
        }

        if(i >= m_dwMixBinCount)
        {
            if(m_dwMixBinCount >= NUMELMS(m_abMixBins))
            {
                DPF_ERROR("One mixbin slot must be kept free for submixing.  The last mixbin specified will be lost");
                m_dwMixBinCount = NUMELMS(m_abMixBins) - 1;
            }

            m_abMixBins[m_dwMixBinCount] = (BYTE)m_pMixinBuffer->m_pSettings->m_dwInputMixBin;
            m_alMixBinVolumes[m_abMixBins[m_dwMixBinCount]] = DSBVOLUME_MAX;

            m_dwMixBinCount++;
        }
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetOutputBuffer
 *
 *  Description:
 *      Assignes the output of this voice to another voice instead of the
 *      standard mixbins.
 *
 *  Arguments:
 *      CDirectSoundBuffer * [in]: mixin buffer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetOutputBuffer"

void
CDirectSoundVoiceSettings::SetOutputBuffer
(
    CDirectSoundBuffer *    pOutputBuffer
)
{
    DWORD                   dwMixBin;
    
    DPF_ENTER();

    ASSERT(pOutputBuffer != m_pMixinBuffer);

    //
    // Release the old buffer and update the mixbins
    //

    if(m_pMixinBuffer)
    {
        dwMixBin = m_pMixinBuffer->m_pSettings->m_dwInputMixBin;

        ASSERT(m_dwMixBinCount);
        ASSERT(m_abMixBins[m_dwMixBinCount - 1] == dwMixBin);

        m_dwMixBinCount--;

        RELEASE(m_pMixinBuffer);
    }

    //
    // Save a reference to the new buffer and update the mixbins.  We're 
    // automatically resetting the mixbin count to 0 before dropping the
    // submix bin in for "convienence."  If you call SetOutputBuffer(NULL)
    // after this, you'll have lost whatever mixbins you used to be assigned
    // to.
    //

    if(m_pMixinBuffer = ADDREF(pOutputBuffer))
    {
        dwMixBin = m_pMixinBuffer->m_pSettings->m_dwInputMixBin;

        ASSERT(m_pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK);

        m_dwMixBinCount = 1;
        m_abMixBins[0] = (BYTE)dwMixBin;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CDirectSoundVoice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: parent DirectSound object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::CDirectSoundVoice"

CDirectSoundVoice::CDirectSoundVoice
(
    CDirectSound *          pDirectSound
)
{
    DPF_ENTER();

    //
    // Initialize defaults
    //

    InitializeListHead(&m_le3dVoice);

    //
    // Save a reference to the DirectSound object
    //

    m_pDirectSound = ADDREF(pDirectSound);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundVoice
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::~CDirectSoundVoice"

CDirectSoundVoice::~CDirectSoundVoice
(
    void
)
{
    DPF_ENTER();

    //
    // Remove ourselves from the 3D list
    //

    RemoveEntryList(&m_le3dVoice);

    //
    // Release the voice implementation object
    //

    RELEASE(m_pVoice);

    //
    // Release the shared settings object
    //

    RELEASE(m_pSettings);

    //
    // Release the reference to the DirectSound object
    //

    RELEASE(m_pDirectSound);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      CMcpxVoiceClient * [in]: voice implementation object.
 *      CDirectSoundVoiceSettings * [in]: shared settings object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::Initialize"

void
CDirectSoundVoice::Initialize
(
    CMcpxVoiceClient *          pVoice, 
    CDirectSoundVoiceSettings * pSettings
)
{
    DPF_ENTER();

    //
    // Just save a reference to each
    //

    m_pVoice = ADDREF(pVoice);
    m_pSettings = ADDREF(pSettings);

    //
    // If we're a 3D voice, add ourselves to the 3D voice list
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        InsertTailList(&m_pDirectSound->m_lst3dVoices, &m_le3dVoice);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the voice format.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: new format.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetFormat"

HRESULT 
CDirectSoundVoice::SetFormat
(
    LPCWAVEFORMATEX         pwfxFormat
)
{
    BOOL                    fSetMixBins;
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pwfxFormat)
    {
        DPF_ERROR("Failed to specify a buffer format");
    }

    if(!IsValidFormat(pwfxFormat))
    {
        DPF_ERROR("Invalid voice format");
    }

    if((m_pSettings->m_dwFlags & DSBCAPS_CTRL3D) && (1 != pwfxFormat->nChannels))
    {
        DPF_ERROR("3D voices must be mono");
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call SetFormat on MIXIN or FXIN buffers");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the settings object
    //

    fSetMixBins = m_pSettings->SetFormat(pwfxFormat, TRUE);

    //
    // Update the implementation object
    //

    hr = m_pVoice->SetFormat();

    //
    // In some cases, the mixbins are defined by the format structure
    //
    
    if(SUCCEEDED(hr) && fSetMixBins)
    {
        hr = m_pVoice->SetMixBins();
    }

    //
    // Make sure the pitch is updated as well
    //

    if(SUCCEEDED(hr))
    {
        m_pVoice->SetPitch();
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the buffer playback frequency.
 *
 *  Arguments:
 *      DWORD [in]: frequency in Hz.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetFrequency"

HRESULT 
CDirectSoundVoice::SetFrequency
(
    DWORD                   dwFrequency
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(dwFrequency)
    {
        if((dwFrequency < DSBFREQUENCY_MIN) || (dwFrequency > DSBFREQUENCY_MAX))
        {
            DPF_ERROR("Invalid frequency value");
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Convert frequency to pitch.  0 frequency means use the default.
    //

    if(!dwFrequency)
    {
        dwFrequency = m_pSettings->m_fmt.nSamplesPerSec;
    }

    hr = SetPitch(XAudioCalculatePitch(dwFrequency));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetPitch
 *
 *  Description:
 *      Sets the buffer pitch.
 *
 *  Arguments:
 *      LONG [in]: pitch, in octaves (s3.12).
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetPitch"

HRESULT 
CDirectSoundVoice::SetPitch
(
    LONG                    lPitch
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((lPitch < DSBPITCH_MIN) || (lPitch > DSBPITCH_MAX))
    {
        DPF_ERROR("Invalid pitch value");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the settings object
    //

    m_pSettings->m_lPitch = lPitch;

    //
    // Notify the implementation object of the change
    //

    hr = m_pVoice->SetPitch();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the buffer playback volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetVolume"

HRESULT
CDirectSoundVoice::SetVolume
(
    LONG                    lVolume
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((lVolume < DSBVOLUME_MIN) || (lVolume > DSBVOLUME_MAX))
    {
        DPF_ERROR("Volume value out-of-bounds");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Save the volume to the settings
    //

    m_pSettings->SetVolume(lVolume);
    
    //
    // Notify the implementation object
    //

    hr = m_pVoice->SetVolume();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetLFO
 *
 *  Description:
 *      Sets parameters for one of the low-frequency occilator.
 *
 *  Arguments:
 *      LPCDSLFODESC [in]: common LFO settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetLFO"

HRESULT
CDirectSoundVoice::SetLFO
(
    LPCDSLFODESC            pLfo
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pLfo)
    {
        DPF_ERROR("LFO description not provided");
    }

    if((pLfo->dwLFO < DSLFO_FIRST) && (pLfo->dwLFO > DSLFO_LAST))
    {
        DPF_ERROR("Invalid LFO identifier");
    }

    if((pLfo->dwDelay < DSLFO_DELAY_MIN) || (pLfo->dwDelay > DSLFO_DELAY_MAX))
    {
        DPF_ERROR("Invalid LFO delay value");
    }

    if((pLfo->dwDelta < DSLFO_DELTA_MIN) || (pLfo->dwDelta > DSLFO_DELTA_MAX))
    {
        DPF_ERROR("Invalid LFO delta value");
    }

    if((pLfo->lPitchModulation < DSLFO_PITCHMOD_MIN) || (pLfo->lPitchModulation > DSLFO_PITCHMOD_MAX))
    {
        DPF_ERROR("Invalid LFO pitch modulation value");
    }

    if((pLfo->lFilterCutOffRange < DSLFO_FCRANGE_MIN) || (pLfo->lFilterCutOffRange > DSLFO_FCRANGE_MAX))
    {
        DPF_ERROR("Invalid LFO filter cutoff value");
    }

    if((pLfo->lAmplitudeModulation < DSLFO_AMPMOD_MIN) || (pLfo->lAmplitudeModulation > DSLFO_AMPMOD_MAX))
    {
        DPF_ERROR("Invalid LFO amplitude modulation value");
    }

    if(pLfo->dwLFO != DSLFO_MULTI)
    {
        if(pLfo->lFilterCutOffRange || pLfo->lAmplitudeModulation)
        {
            DPF_WARNING("The pitch LFO doesn not support filter cut-off range or amplitude modulation");
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetLFO(pLfo);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetEG
 *
 *  Description:
 *      Sets parameters for one of the envelope generators.
 *
 *  Arguments:
 *      LPCDSENVELOPEDESC [in]: common envelope settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetEG"

HRESULT
CDirectSoundVoice::SetEG
(
    LPCDSENVELOPEDESC       pEnv
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pEnv)
    {
        DPF_ERROR("Envelope description not provided");
    }

    if((pEnv->dwEG < DSEG_FIRST) || (pEnv->dwEG > DSEG_LAST))
    {
        DPF_ERROR("Invalid envelope generator identifier");
    }

    if((pEnv->dwMode < DSEG_MODE_FIRST) || (pEnv->dwMode > DSEG_MODE_LAST))
    {
        DPF_ERROR("Invalid envelope generator mode");
    }

    if((pEnv->dwDelay < DSEG_DELAY_MIN) || (pEnv->dwDelay > DSEG_DELAY_MAX))
    {
        DPF_ERROR("Invalid envelope delay value");
    }

    if((pEnv->dwAttack < DSEG_ATTACK_MIN) || (pEnv->dwAttack > DSEG_ATTACK_MAX))
    {
        DPF_ERROR("Invalid envelope attack value");
    }

    if((pEnv->dwHold < DSEG_HOLD_MIN) || (pEnv->dwHold > DSEG_HOLD_MAX))
    {
        DPF_ERROR("Invalid envelope hold value");
    }

    if((pEnv->dwDecay < DSEG_DECAY_MIN) || (pEnv->dwDecay > DSEG_DECAY_MAX))
    {
        DPF_ERROR("Invalid envelope decay value");
    }

    if((pEnv->dwRelease < DSEG_RELEASE_MIN) || (pEnv->dwRelease > DSEG_RELEASE_MAX))
    {
        DPF_ERROR("Invalid envelope release value");
    }

    if((pEnv->dwSustain < DSEG_SUSTAIN_MIN) || (pEnv->dwSustain > DSEG_SUSTAIN_MAX))
    {
        DPF_ERROR("Invalid envelope sustain value");
    }

    if((pEnv->lPitchScale < DSEG_PITCHSCALE_MIN) || (pEnv->lPitchScale > DSEG_PITCHSCALE_MAX))
    {
        DPF_ERROR("Invalid envelope pitch scale value");
    }

    if((pEnv->lFilterCutOff < DSEG_FILTERCUTOFF_MIN) || (pEnv->lFilterCutOff > DSEG_FILTERCUTOFF_MAX))
    {
        DPF_ERROR("Invalid envelope filter cutoff value");
    }

    if(pEnv->dwEG != DSEG_MULTI)
    {
        if(pEnv->lPitchScale || pEnv->lFilterCutOff)
        {
            DPF_WARNING("The amplitude envelope doesn not support pitch scale or filter cutoff");
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetEG(pEnv);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetFilter
 *
 *  Description:
 *      Sets parameters for the filter.
 *
 *  Arguments:
 *      LPCDSFILTERDESC [in]: filter settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetFilter"

HRESULT
CDirectSoundVoice::SetFilter
(
    LPCDSFILTERDESC         pFilter
)
{
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pFilter)
    {
        DPF_ERROR("Filter description not provided");
    }

    if((pFilter->dwMode < DSFILTER_MODE_FIRST) || (pFilter->dwMode > DSFILTER_MODE_LAST))
    {
        DPF_ERROR("Invalid filter mode");
    }

    if(pFilter->dwQCoefficient > 7)
    {
        DPF_ERROR("Invalid Q-coefficient value");
    }

    for(i = 0; i < NUMELMS(pFilter->adwCoefficients); i++)
    {
        if(pFilter->adwCoefficients[i] > 0xFFFF)
        {
            DPF_ERROR("Invalid coefficient value (index %lu)", i);
        }
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        if(DSFILTER_MODE_BYPASS == pFilter->dwMode)
        {
            DPF_ERROR("The filter can't be bypassed on a 3D voice");
        }

        for(i = 2; i < NUMELMS(pFilter->adwCoefficients); i++)
        {
            if(pFilter->adwCoefficients[i])
            {
                DPF_ERROR("Only the first 2 coefficients are valid on a 3D voice");
            }
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetFilter(pFilter);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetHeadroom
 *
 *  Description:
 *      Sets voice headroom.
 *
 *  Arguments:
 *      DWORD [in]: headroom, in Millibels.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetHeadroom"

HRESULT
CDirectSoundVoice::SetHeadroom
(
    DWORD                   dwHeadroom
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((dwHeadroom < DSBHEADROOM_MIN) || (dwHeadroom > DSBHEADROOM_MAX))
    {
        DPF_ERROR("Headroom value out-of-bounds");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Save the headroom to the settings
    //

    m_pSettings->SetHeadroom(dwHeadroom);
    
    //
    // Headroom affects voice volume, so notify the implementation object
    //

    hr = m_pVoice->SetVolume();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}    


/****************************************************************************
 *
 *  SetOutputBuffer
 *
 *  Description:
 *      Assignes the output of this voice to another voice instead of the
 *      standard mixbins.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: mixin buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetOutputBuffer"

HRESULT
CDirectSoundVoice::SetOutputBuffer
(
    LPDIRECTSOUNDBUFFER     pOutputBuffer
)
{
    CDirectSoundBuffer *    pMixinBuffer    = (CDirectSoundBuffer *)pOutputBuffer;
    HRESULT                 hr              = DS_OK;

#ifdef VALIDATE_PARAMETERS
    
    static BOOL             fSubMixHeadroom = FALSE;
    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(pMixinBuffer)
    {
        if(!(pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK))
        {
            DPF_ERROR("Output buffer specified is not a MIXIN/FXIN buffer");
        }

        if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
        {
            DPF_ERROR("Can't set the output buffer on MIXIN/FXIN buffers");
        }

        if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
        {
            DPF_ERROR("Can't submix a 3D buffer.  Create a 2D source buffer and a 3D destination buffer.");
        }

        if(1 != m_pSettings->m_fmt.nChannels)
        {
            DPF_ERROR("Can only submix mono source voices");
        }

        if(m_pSettings->m_dwMixBinCount >= NUMELMS(m_pSettings->m_abMixBins))
        {
            DPF_ERROR("Submixed voices must leave one mixbin slot free");
        }

        if(!fSubMixHeadroom)
        {
            if(m_pDirectSound->m_pSettings->m_abMixBinHeadroom[pMixinBuffer->m_pSettings->m_dwInputMixBin])
            {
                DPF_WARNING("The headroom for the mixbin your submix destination is reading from is");
                DPF_WARNING("non-zero.  This will be additive with the headroom that your submix");
                DPF_WARNING("destination is reading to, possibly giving you more headroom that you want.");
                DPF_WARNING("You will only see this warning once.");
                
                fSubMixHeadroom = TRUE;
            }
        }
    }

#endif // VALIDATE_PARAMETERS

    if(pMixinBuffer != m_pSettings->m_pMixinBuffer)
    {
        //
        // Disconnect from the current buffer
        //

        if(m_pSettings->m_pMixinBuffer)
        {
            hr = m_pVoice->DisconnectVoice();
        }
        
        //
        // Update the settings object
        //

        if(SUCCEEDED(hr))
        {
            m_pSettings->SetOutputBuffer(pMixinBuffer);
        }

        //
        // Hand off to the implementation object.  ConnectVoice handles
        // resetting the mixbins and mixbin volumes as well as voice list
        // management.
        //

        if(SUCCEEDED(hr) && pMixinBuffer)
        {
            hr = m_pVoice->ConnectVoice();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBins
 *
 *  Description:
 *      Assigns the output of this voice to specific mixbins.
 *
 *  Arguments:
 *      LPCDSMIXBINS [in]: mixbin assignments.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMixBins"

HRESULT
CDirectSoundVoice::SetMixBins
(
    LPCDSMIXBINS            pMixBins
)
{
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS  

    DWORD                   i;
   
#endif // VALIDATE_PARAMETERS    

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(pMixBins)
    {
        if(pMixBins->dwMixBinCount)
        {
            if(pMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
            {
                DPF_ERROR("No voice can be assigned to more than %lu mix bins", DSMIXBIN_ASSIGNMENT_MAX);
            }
        
            if(pMixBins->dwMixBinCount % m_pSettings->m_fmt.nChannels)
            {
                DPF_ERROR("The mixbin count must be a multiple of the channel count");
            }

            for(i = 0; i < pMixBins->dwMixBinCount; i++)
            {
                if(pMixBins->lpMixBinVolumePairs[i].dwMixBin > DSMIXBIN_LAST)
                {
                    DPF_ERROR("Specified an invalid mixbin");
                }
            }

            if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
            {
                if(pMixBins->dwMixBinCount < DirectSoundRequiredMixBins_3D.dwMixBinCount)
                {
                    DPF_ERROR("MixBin count doesn't include enough mixbins to hold all required for 3D");
                }
            
                for(i = 0; i < DirectSoundRequiredMixBins_3D.dwMixBinCount; i++)
                {
                    if(pMixBins->lpMixBinVolumePairs[i].dwMixBin != DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[i].dwMixBin)
                    {
                        DPF_ERROR("MixBin array does not include the required 3D bins");
                    }
                }
            }
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Save settings
    //

    m_pSettings->SetMixBins(pMixBins);

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetMixBins();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBinVolumes
 *
 *  Description:
 *      Sets the volume of each channel of the voice as it applies to it's
 *      assigned mixbins.
 *
 *  Arguments:
 *      LPCDSMIXBINS [in]: mixbin volume data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMixBinVolumes"

HRESULT
CDirectSoundVoice::SetMixBinVolumes
(
    LPCDSMIXBINS            pMixBins
)
{
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i, z;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pMixBins)
    {
        DPF_ERROR("Failed to supply any volume data");
    }

    if(pMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
    {
        DPF_ERROR("Invalid mixbin count");
    }
    
    for(i = 0; i < pMixBins->dwMixBinCount; i++)
    {
        for(z = 0; z < m_pSettings->m_dwMixBinCount; z++)
        {
            if(pMixBins->lpMixBinVolumePairs[i].dwMixBin == m_pSettings->m_abMixBins[z])
            {
                break;
            }
        }

        if(z >= m_pSettings->m_dwMixBinCount)
        {
            DPF_ERROR("Specified a mixbin the voice is not assigned to at index %lu (mixbin %lu)", i, pMixBins->lpMixBinVolumePairs[i].dwMixBin);
        }
        
        if((pMixBins->lpMixBinVolumePairs[i].lVolume < DSBVOLUME_MIN) || (pMixBins->lpMixBinVolumePairs[i].lVolume > DSBVOLUME_MAX))
        {
            DPF_ERROR("Invalid volume at index %lu", i);
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the volume
    //

    m_pSettings->SetMixBinVolumes(pMixBins);

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetVolume();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifndef MCPX_BOOT_LIB

/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object properties.
 *
 *  Arguments:
 *      LPDS3DBUFFER [in]: object parameters.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetAllParameters"

HRESULT 
CDirectSoundVoice::SetAllParameters
(
    LPCDS3DBUFFER           pParams, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pParams)
    {
        DPF_ERROR("Parameters not supplied");
    }

    if(pParams->dwSize < sizeof(*pParams))
    {
        DPF_ERROR("Invalid structure size");
    }

    if((pParams->dwInsideConeAngle < DS3D_MINCONEANGLE) || (pParams->dwInsideConeAngle > DS3D_MAXCONEANGLE) || (pParams->dwOutsideConeAngle < DS3D_MINCONEANGLE) || (pParams->dwOutsideConeAngle > DS3D_MAXCONEANGLE))
    {
        DPF_ERROR("Invalid cone angle value");
    }

    if(pParams->dwInsideConeAngle > pParams->dwOutsideConeAngle)
    {
        DPF_ERROR("Inside cone angle can't be greater than outside");
    }

    if(!pParams->vConeOrientation.x && !pParams->vConeOrientation.y && !pParams->vConeOrientation.z)
    {
        DPF_ERROR("Invalid cone orientation");
    }
    
    if((pParams->lConeOutsideVolume < DSBVOLUME_MIN) || (pParams->lConeOutsideVolume > DSBVOLUME_MAX))
    {
        DPF_ERROR("Invalid volume level");
    }

    if(!pParams->flMinDistance || !pParams->flMaxDistance)
    {
        DPF_ERROR("Minimum and maximum distance must be non-zero");
    }

    if((pParams->dwMode < DS3DMODE_FIRST) || (pParams->dwMode > DS3DMODE_LAST))
    {
        DPF_ERROR("Invalid mode");
    }

    if((pParams->flDistanceFactor < DS3D_MINDISTANCEFACTOR) || (pParams->flDistanceFactor > DS3D_MAXDISTANCEFACTOR))
    {
        DPF_ERROR("Distance factor out of bounds");
    }

    if((pParams->flDopplerFactor < DS3D_MINDOPPLERFACTOR) || (pParams->flDopplerFactor > DS3D_MAXDOPPLERFACTOR))
    {
        DPF_ERROR("Doppler factor out of bounds");
    }

    if((pParams->flRolloffFactor < DS3D_MINROLLOFFFACTOR) || (pParams->flRolloffFactor > DS3D_MAXROLLOFFFACTOR))
    {
        DPF_ERROR("Rolloff factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.vPosition.x = NormalizeFloat(pParams->vPosition.x);
    m_pSettings->m_p3dParams->HrtfParams.vPosition.y = NormalizeFloat(pParams->vPosition.y);
    m_pSettings->m_p3dParams->HrtfParams.vPosition.z = NormalizeFloat(pParams->vPosition.z);

    m_pSettings->m_p3dParams->HrtfParams.vVelocity.x = NormalizeFloat(pParams->vVelocity.x);
    m_pSettings->m_p3dParams->HrtfParams.vVelocity.y = NormalizeFloat(pParams->vVelocity.y);
    m_pSettings->m_p3dParams->HrtfParams.vVelocity.z = NormalizeFloat(pParams->vVelocity.z);

    m_pSettings->m_p3dParams->HrtfParams.dwInsideConeAngle = pParams->dwInsideConeAngle;
    m_pSettings->m_p3dParams->HrtfParams.dwOutsideConeAngle = pParams->dwOutsideConeAngle;

    m_pSettings->m_p3dParams->HrtfParams.vConeOrientation.x = NormalizeFloat(pParams->vConeOrientation.x);
    m_pSettings->m_p3dParams->HrtfParams.vConeOrientation.y = NormalizeFloat(pParams->vConeOrientation.y);
    m_pSettings->m_p3dParams->HrtfParams.vConeOrientation.z = NormalizeFloat(pParams->vConeOrientation.z);

    m_pSettings->m_p3dParams->HrtfParams.lConeOutsideVolume = pParams->lConeOutsideVolume;
    
    m_pSettings->m_p3dParams->HrtfParams.flMinDistance = NormalizeFloat(pParams->flMinDistance);
    m_pSettings->m_p3dParams->HrtfParams.flMaxDistance = NormalizeFloat(pParams->flMaxDistance);
    
    m_pSettings->m_p3dParams->HrtfParams.dwMode = pParams->dwMode;
    
    m_pSettings->m_p3dParams->HrtfParams.flDistanceFactor = NormalizeFloat(pParams->flDistanceFactor);
    m_pSettings->m_p3dParams->HrtfParams.flRolloffFactor = NormalizeFloat(pParams->flRolloffFactor);
    m_pSettings->m_p3dParams->HrtfParams.flDopplerFactor = NormalizeFloat(pParams->flDopplerFactor);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_MASK;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets the sound cone's angles.
 *
 *  Arguments:
 *      DWORD [in]: inside angle.
 *      DWORD [in]: outside angle.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetConeAngles"

HRESULT 
CDirectSoundVoice::SetConeAngles
(
    DWORD                   dwInside, 
    DWORD                   dwOutside, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((dwInside < DS3D_MINCONEANGLE) || (dwInside > DS3D_MAXCONEANGLE) || (dwOutside < DS3D_MINCONEANGLE) || (dwOutside > DS3D_MAXCONEANGLE))
    {
        DPF_ERROR("Invalid cone angle value");
    }

    if(dwInside > dwOutside)
    {
        DPF_ERROR("Inside cone angle can't be greater than outside");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.dwInsideConeAngle = dwInside;
    m_pSettings->m_p3dParams->HrtfParams.dwOutsideConeAngle = dwOutside;

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_CONEANGLES;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets the sound cone's orientation.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetConeOrientation"

HRESULT 
CDirectSoundVoice::SetConeOrientation
(
    FLOAT                   flOrientationX,
    FLOAT                   flOrientationY,
    FLOAT                   flOrientationZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!flOrientationX && !flOrientationY && !flOrientationZ)
    {
        DPF_ERROR("Invalid cone orientation");
    }
    
    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.vConeOrientation.x = NormalizeFloat(flOrientationX);
    m_pSettings->m_p3dParams->HrtfParams.vConeOrientation.y = NormalizeFloat(flOrientationY);
    m_pSettings->m_p3dParams->HrtfParams.vConeOrientation.z = NormalizeFloat(flOrientationZ);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_CONEORIENTATION;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets the sound cone's outside volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetConeOutsideVolume"

HRESULT 
CDirectSoundVoice::SetConeOutsideVolume
(
    LONG                    lVolume, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((lVolume < DSBVOLUME_MIN) || (lVolume > DSBVOLUME_MAX))
    {
        DPF_ERROR("Invalid volume level");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.lConeOutsideVolume = lVolume;

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_CONEOUTSIDEVOLUME;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the objects maximum distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: maximum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMaxDistance"

HRESULT 
CDirectSoundVoice::SetMaxDistance
(
    FLOAT                   flMaxDistance, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((flMaxDistance < DS3D_MINMAXDISTANCE) || (flMaxDistance > DS3D_MAXMAXDISTANCE))
    {
        DPF_ERROR("Invalid max distance value");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

    if(flMaxDistance < m_pSettings->m_p3dParams->HrtfParams.flMinDistance)
    {
        DPF_ERROR("flMaxDistance must be >= flMinDistance");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.flMaxDistance = NormalizeFloat(flMaxDistance);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_MAXDISTANCE;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the objects minimum distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: minimum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMinDistance"

HRESULT 
CDirectSoundVoice::SetMinDistance
(
    FLOAT                   flMinDistance, 
    DWORD                   dwFlags
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((flMinDistance < DS3D_MINMINDISTANCE) || (flMinDistance > DS3D_MAXMINDISTANCE))
    {
        DPF_ERROR("Invalid min distance value");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

    if(flMinDistance > m_pSettings->m_p3dParams->HrtfParams.flMaxDistance)
    {
        DPF_ERROR("MinDistance must be <= MaxDistance");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.flMinDistance = NormalizeFloat(flMinDistance);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_MINDISTANCE;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the objects mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMode"

HRESULT 
CDirectSoundVoice::SetMode
(
    DWORD                   dwMode, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((dwMode < DS3DMODE_FIRST) || (dwMode > DS3DMODE_LAST))
    {
        DPF_ERROR("Invalid mode");
    }
    
    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    //
    // There is no parameter bit for mode since what's recalculated is based
    // on the mode change
    //
    
    m_pSettings->m_p3dParams->HrtfParams.dwMode = dwMode;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the objects position.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetPosition"

HRESULT 
CDirectSoundVoice::SetPosition
(
    FLOAT                   flPositionX,
    FLOAT                   flPositionY,
    FLOAT                   flPositionZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.vPosition.x = NormalizeFloat(flPositionX);
    m_pSettings->m_p3dParams->HrtfParams.vPosition.y = NormalizeFloat(flPositionY);
    m_pSettings->m_p3dParams->HrtfParams.vPosition.z = NormalizeFloat(flPositionZ);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_POSITION;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the objects velocity.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetVelocity"

HRESULT 
CDirectSoundVoice::SetVelocity
(
    FLOAT                   flVelocityX,
    FLOAT                   flVelocityY,
    FLOAT                   flVelocityZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.vVelocity.x = NormalizeFloat(flVelocityX);
    m_pSettings->m_p3dParams->HrtfParams.vVelocity.y = NormalizeFloat(flVelocityY);
    m_pSettings->m_p3dParams->HrtfParams.vVelocity.z = NormalizeFloat(flVelocityZ);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_VELOCITY;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets the world's distance factor.
 *
 *  Arguments:
 *      FLOAT [in]: distance factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetDistanceFactor"

HRESULT 
CDirectSoundVoice::SetDistanceFactor
(
    FLOAT                   flDistanceFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((flDistanceFactor < DS3D_MINDISTANCEFACTOR) || (flDistanceFactor > DS3D_MAXDISTANCEFACTOR))
    {
        DPF_ERROR("Distance factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.flDistanceFactor = NormalizeFloat(flDistanceFactor);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_DISTANCEFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets the world's Doppler factor.
 *
 *  Arguments:
 *      FLOAT [in]: Doppler factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetDopplerFactor"

HRESULT 
CDirectSoundVoice::SetDopplerFactor
(
    FLOAT                   flDopplerFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((flDopplerFactor < DS3D_MINDOPPLERFACTOR) || (flDopplerFactor > DS3D_MAXDOPPLERFACTOR))
    {
        DPF_ERROR("Doppler factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.flDopplerFactor = NormalizeFloat(flDopplerFactor);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_DOPPLERFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets the source's rolloff factor.
 *
 *  Arguments:
 *      FLOAT [in]: rolloff factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetRolloffFactor"

HRESULT 
CDirectSoundVoice::SetRolloffFactor
(
    FLOAT                   flRolloffFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((flRolloffFactor < DS3D_MINROLLOFFFACTOR) || (flRolloffFactor > DS3D_MAXROLLOFFFACTOR))
    {
        DPF_ERROR("Rolloff factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->HrtfParams.flRolloffFactor = NormalizeFloat(flRolloffFactor);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_ROLLOFFFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetRolloffCurve
 *
 *  Description:
 *      Sets the source's rolloff curve.
 *
 *  Arguments:
 *      const FLOAT * [in]: point array.
 *      DWORD [in]: point count.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetRolloffCurve"

HRESULT 
CDirectSoundVoice::SetRolloffCurve
(
    const FLOAT *           pflPoints, 
    DWORD                   dwPointCount, 
    DWORD                   dwFlags
)
{

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(pflPoints && dwPointCount)
    {
        for(i = 0; i < dwPointCount; i++)
        {
            if((pflPoints[i] < 0.0f) || (pflPoints[i] > 1.0f))
            {
                DPF_ERROR("Rolloff curve points must be between 0 and 1");
            }
        }
    }
    else if((!pflPoints && dwPointCount) || (pflPoints && !dwPointCount))
    {
        DPF_ERROR("Point array and count most both be valid or NULL");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->paflRolloffPoints = pflPoints;
    m_pSettings->m_p3dParams->dwRolloffPointCount = dwPointCount;

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_ROLLOFFFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetI3DL2Source
 *
 *  Description:
 *      Sets I3DL2 source parameters.
 *
 *  Arguments:
 *      LPCDSI3DL2BUFFER [in]: source parameters.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetI3DL2Source"

HRESULT
CDirectSoundVoice::SetI3DL2Source
(
    LPCDSI3DL2BUFFER        pParams,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pParams)
    {
        DPF_ERROR("Failed to supply parameters");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if((pParams->lDirect < DSI3DL2BUFFER_MINDIRECT) || (pParams->lDirect > DSI3DL2BUFFER_MAXDIRECT))
    {
        DPF_ERROR("Invalid lDirect value");
    }

    if((pParams->lDirectHF < DSI3DL2BUFFER_MINDIRECTHF) || (pParams->lDirectHF > DSI3DL2BUFFER_MAXDIRECTHF))
    {
        DPF_ERROR("Invalid lDirectHF value");
    }

    if((pParams->lRoom < DSI3DL2BUFFER_MINROOM) || (pParams->lRoom > DSI3DL2BUFFER_MAXROOM))
    {
        DPF_ERROR("Invalid lRoom value");
    }

    if((pParams->lRoomHF < DSI3DL2BUFFER_MINROOMHF) || (pParams->lRoomHF > DSI3DL2BUFFER_MAXROOMHF))
    {
        DPF_ERROR("Invalid lRoomHF value");
    }

    if((pParams->flRoomRolloffFactor < DSI3DL2BUFFER_MINROOMROLLOFFFACTOR) || (pParams->flRoomRolloffFactor > DSI3DL2BUFFER_MAXROOMROLLOFFFACTOR))
    {
        DPF_ERROR("Invalid flRoomRolloffFactor value");
    }

    if((pParams->Obstruction.lHFLevel < DSI3DL2BUFFER_MINOBSTRUCTION) || (pParams->Obstruction.lHFLevel > DSI3DL2BUFFER_MAXOBSTRUCTION))
    {
        DPF_ERROR("Invalid Obstruction.lHFLevel value");
    }

    if((pParams->Obstruction.flLFRatio < DSI3DL2BUFFER_MINOBSTRUCTIONLFRATIO) || (pParams->Obstruction.flLFRatio > DSI3DL2BUFFER_MAXOBSTRUCTIONLFRATIO))
    {
        DPF_ERROR("Invalid Obstruction.flLFRatio value");
    }

    if((pParams->Occlusion.lHFLevel < DSI3DL2BUFFER_MINOCCLUSION) || (pParams->Occlusion.lHFLevel > DSI3DL2BUFFER_MAXOCCLUSION))
    {
        DPF_ERROR("Invalid Occlusion.lHFLevel value");
    }

    if((pParams->Occlusion.flLFRatio < DSI3DL2BUFFER_MINOCCLUSIONLFRATIO) || (pParams->Occlusion.flLFRatio > DSI3DL2BUFFER_MAXOCCLUSIONLFRATIO))
    {
        DPF_ERROR("Invalid Occlusion.flLFRatio value");
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_p3dParams->I3dl2Params.lDirect = pParams->lDirect;
    m_pSettings->m_p3dParams->I3dl2Params.lDirectHF = pParams->lDirectHF;
    m_pSettings->m_p3dParams->I3dl2Params.lRoom = pParams->lRoom;
    m_pSettings->m_p3dParams->I3dl2Params.lRoomHF = pParams->lRoomHF;
    m_pSettings->m_p3dParams->I3dl2Params.flRoomRolloffFactor = NormalizeFloat(pParams->flRoomRolloffFactor);
    
    m_pSettings->m_p3dParams->I3dl2Params.Obstruction.lHFLevel = pParams->Obstruction.lHFLevel;
    m_pSettings->m_p3dParams->I3dl2Params.Obstruction.flLFRatio = NormalizeFloat(pParams->Obstruction.flLFRatio);

    m_pSettings->m_p3dParams->I3dl2Params.Occlusion.lHFLevel = pParams->Occlusion.lHFLevel;
    m_pSettings->m_p3dParams->I3dl2Params.Occlusion.flLFRatio = NormalizeFloat(pParams->Occlusion.flLFRatio);

    m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_I3DL2;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CommitDeferredSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::CommitDeferredSettings"

HRESULT 
CDirectSoundVoice::CommitDeferredSettings
(
    void
)
{
    DWORD                   dwParameterMask;

    DPF_ENTER();

    //
    // Include the changed listener parameters in the 3D parameter mask
    //
    
    m_pSettings->m_p3dParams->dwParameterMask |= m_pDirectSound->m_pSettings->m_3dParams.dwParameterMask;

    //
    // Apply changes to the voice
    //
    
    dwParameterMask = m_pVoice->Commit3dSettings();

    //
    // Clear the parameter mask
    //

    m_pSettings->m_p3dParams->dwParameterMask &= ~dwParameterMask;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  CDirectSoundBufferSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::CDirectSoundBufferSettings"

const WAVEFORMATEX CDirectSoundBufferSettings::m_wfxMixDest = INIT_PCM_WAVEFORMAT_EX(1, 48000, 24, 32);

CDirectSoundBufferSettings::CDirectSoundBufferSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundBufferSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::~CDirectSoundBufferSettings"

CDirectSoundBufferSettings::~CDirectSoundBufferSettings
(
    void
)
{
    DPF_ENTER();
    
    //
    // Free the data buffer
    //
    
    SetBufferData(NULL, 0);

    //
    // Free notifications
    //

    SetNotificationPositions(0, NULL);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::Initialize"

HRESULT
CDirectSoundBufferSettings::Initialize
(
    LPCDSBUFFERDESC         pdsbd
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    //
    // Hand off to the base class
    //

    hr = CDirectSoundVoiceSettings::Initialize(pdsbd->dwFlags, (pdsbd->dwFlags & DSBCAPS_SUBMIXMASK) ? &m_wfxMixDest : pdsbd->lpwfxFormat, pdsbd->lpMixBins);

    //
    // Save the input mixbin
    //

    if(SUCCEEDED(hr))
    {
        if(pdsbd->dwFlags & DSBCAPS_FXIN)
        {
            m_dwInputMixBin = pdsbd->dwInputMixBin;
        }
        else if(pdsbd->dwFlags & DSBCAPS_MIXIN)
        {
            m_dwInputMixBin = DSMIXBIN_SUBMIX;
        }
    }
    
    //
    // Initialize buffer data
    //

    if(SUCCEEDED(hr))
    {
        if(pdsbd->dwBufferBytes)
        {
            hr = SetBufferData(NULL, pdsbd->dwBufferBytes);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetBufferData
 *
 *  Description:
 *      Sets buffer data pointers.
 *
 *  Arguments:
 *      LPVOID [in]: data buffer.
 *      LPVOID [in]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::SetBufferData"

HRESULT
CDirectSoundBufferSettings::SetBufferData
(
    LPVOID                  pvDataBuffer,
    DWORD                   dwBufferBytes
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    
    //
    // Free the existing buffer
    //

    if(m_dwFlags & DSBCAPS_APPALLOCBUFFER)
    {
        m_pvBufferData = NULL;
    }
    else
    {
        MEMFREE(m_pvBufferData);
    }

    //
    // Allocate the new buffer (or just save the pointer)
    //

    if(m_dwBufferSize = dwBufferBytes)
    {
        if(pvDataBuffer)
        {
            m_dwFlags |= DSBCAPS_APPALLOCBUFFER;

            m_pvBufferData = pvDataBuffer;
        }
        else
        {
            m_dwFlags &= ~DSBCAPS_APPALLOCBUFFER;
        
            hr = HRFROMP(m_pvBufferData = MEMALLOC_NOINIT(BYTE, m_dwBufferSize));
        }
    }

    //
    // Reset the buffer offsets
    //

    SetPlayRegion(0, m_dwBufferSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetPlayRegion
 *
 *  Description:
 *      Sets buffer play region.
 *
 *  Arguments:
 *      DWORD [in]: starting position of the play region.
 *      DWORD [in]: length, in bytes, of the play region.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::SetPlayRegion"

void
CDirectSoundBufferSettings::SetPlayRegion
(
    DWORD                   dwPlayStart,
    DWORD                   dwPlayLength
)
{
    DPF_ENTER();

    ASSERT(dwPlayStart + dwPlayLength <= m_dwBufferSize);
    
    m_dwPlayStart = dwPlayStart;
    m_dwPlayLength = dwPlayLength;

    SetLoopRegion(0, dwPlayLength);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetLoopRegion
 *
 *  Description:
 *      Sets buffer loop region.
 *
 *  Arguments:
 *      DWORD [in]: starting position of the loop region.
 *      DWORD [in]: length, in bytes, of the loop region.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::SetLoopRegion"

void
CDirectSoundBufferSettings::SetLoopRegion
(
    DWORD                   dwLoopStart,
    DWORD                   dwLoopLength
)
{
    DPF_ENTER();

    ASSERT(dwLoopStart + dwLoopLength <= m_dwBufferSize);
    ASSERT(dwLoopStart + dwLoopLength <= m_dwPlayLength);
    
    m_dwLoopStart = dwLoopStart;
    m_dwLoopLength = dwLoopLength;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets notification positions.
 *
 *  Arguments:
 *      DWORD [in]: notification count.
 *      LPCDSBPOSITIONNOTIFY [in]: notification array.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::SetNotificationPositions"

HRESULT
CDirectSoundBufferSettings::SetNotificationPositions
(
    DWORD                   dwNotifyCount,
    LPCDSBPOSITIONNOTIFY    paNotifies
)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   i       = 0;
    DSBPOSITIONNOTIFY       NotifyT;

    DPF_ENTER();

    //
    // Free any existing notifications
    //

    MEMFREE(m_paNotifies);

    //
    // Save the new notification count
    //

    m_dwNotifyCount = dwNotifyCount;

    //
    // Make a copy of the notification array and put it into ascending order
    //

    if(dwNotifyCount)
    {
        hr = HRFROMP(m_paNotifies = MEMALLOC_NOINIT(DSBPOSITIONNOTIFY, dwNotifyCount));

        if(SUCCEEDED(hr))
        {
            CopyMemory(m_paNotifies, paNotifies, sizeof(*paNotifies) * dwNotifyCount);
        }

        if(SUCCEEDED(hr))
        {
            while(i < m_dwNotifyCount - 1)
            {
                if(m_paNotifies[i].dwOffset > m_paNotifies[i + 1].dwOffset)
                {
                    NotifyT = m_paNotifies[i];
                    m_paNotifies[i] = m_paNotifies[i + 1];
                    m_paNotifies[i + 1] = NotifyT;

                    i = 0;
                }
                else
                {
                    i++;
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CDirectSoundBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: parent DirectSound object
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::CDirectSoundBuffer"

CDirectSoundBuffer::CDirectSoundBuffer
(
    CDirectSound *      pDirectSound
)
:   CDirectSoundVoice(pDirectSound)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::~CDirectSoundBuffer"

CDirectSoundBuffer::~CDirectSoundBuffer
(
    void
)
{
    DPF_ENTER();

    //
    // Free the buffer implementation
    //

    RELEASE(m_pBuffer);

    //
    // Free settings
    //

    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::Initialize"

HRESULT
CDirectSoundBuffer::Initialize
(
    LPCDSBUFFERDESC         pdsbd
)
{                                   
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(!pdsbd)
    {
        DPF_ERROR("DSBUFFERDESC not supplied");
    }

    if(sizeof(*pdsbd) < pdsbd->dwSize)
    {
        DPF_ERROR("DSBUFFERDESC size not valid");
    }

    if(pdsbd->dwFlags & ~DSBCAPS_VALID)
    {
        DPF_ERROR("Specified invalid flags (%lx)", pdsbd->dwFlags & ~DSBCAPS_VALID);
    }

    if(pdsbd->dwFlags & DSBCAPS_SUBMIXMASK)
    {
        if(pdsbd->dwFlags & DSBCAPS_LOCDEFER)
        {
            DPF_ERROR("MIXIN/FXIN buffers can't be LOCDEFER");
        }

        if(pdsbd->dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
        {
            DPF_ERROR("MIXIN/FXIN buffers can't have CTRLPOSITIONNOTIFY");
        }

        if(pdsbd->lpwfxFormat)
        {
            DPF_ERROR("lpwfxFormat for MIXIN/FXIN buffers must be NULL");
        }

        if(pdsbd->dwBufferBytes)
        {
            DPF_ERROR("dwBufferBytes for MIXIN/FXIN buffers must be 0");
        }
    }
    else
    {
        if(!pdsbd->lpwfxFormat)
        {
            DPF_ERROR("Failed to specify a buffer format");
        }

        if(!IsValidFormat(pdsbd->lpwfxFormat))
        {
            DPF_ERROR("Invalid buffer format");
        }

        if(pdsbd->dwBufferBytes && ((pdsbd->dwBufferBytes < DSBSIZE_MIN) || (pdsbd->dwBufferBytes > DSBSIZE_MAX)))
        {
            DPF_ERROR("Buffer size out-of-bounds");
        }
    
        if(pdsbd->dwBufferBytes && (pdsbd->dwBufferBytes % pdsbd->lpwfxFormat->nBlockAlign))
        {
            DPF_ERROR("Buffer size not a multiple of the sample size");
        }

        if((pdsbd->dwFlags & DSBCAPS_CTRL3D) && (1 != pdsbd->lpwfxFormat->nChannels))
        {
            DPF_ERROR("3D voices must be mono");
        }
    }

    if((pdsbd->dwFlags & DSBCAPS_CTRL3D) && !CHrtfSource::IsValidAlgorithm())
    {
        DPF_ERROR("You must call one of the 3D algorithm initialization functions (DirectSoundUseLightHRTF, DirectSoundUseFullHRTF, DirectSoundUsePan3D) before creating a 3D buffer");
    }

    if(pdsbd->lpMixBins)
    {
        if(pdsbd->lpMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
        {
            DPF_ERROR("No voice can be assigned to more than %lu mix bins", DSMIXBIN_ASSIGNMENT_MAX);
        }

        if(pdsbd->lpwfxFormat)
        {
            if(pdsbd->lpMixBins->dwMixBinCount % pdsbd->lpwfxFormat->nChannels)
            {
                DPF_ERROR("The mixbin count must be a multiple of the channel count");
            }

            if(WAVE_FORMAT_EXTENSIBLE == pdsbd->lpwfxFormat->wFormatTag)
            {
                if(((LPCWAVEFORMATEXTENSIBLE)pdsbd->lpwfxFormat)->dwChannelMask)
                {
                    DPF_WARNING("Specifying mixbins will override the channel mask specified in the format");
                }
            }
        }

        for(i = 0; i < pdsbd->lpMixBins->dwMixBinCount; i++)
        {
            if(pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin > DSMIXBIN_LAST)
            {
                DPF_ERROR("Specified an invalid mixbin");
            }

            if(DSMIXBIN_SUBMIX == pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin)
            {
                DPF_ERROR("Don't assign a voice to DSMIXBIN_SUBMIX.  Instead, call SetOutputBuffer");
            }
        }

        if(pdsbd->dwFlags & DSBCAPS_CTRL3D)
        {
            if(pdsbd->lpMixBins->dwMixBinCount < DirectSoundRequiredMixBins_3D.dwMixBinCount)
            {
                DPF_ERROR("MixBin count doesn't include enough mixbins to hold all required for 3D");
            }
            
            for(i = 0; i < DirectSoundRequiredMixBins_3D.dwMixBinCount; i++)
            {
                if(pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin != DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[i].dwMixBin)
                {
                    DPF_ERROR("MixBin array does not include the required 3D bins");
                }
            }
        }
    }

    if(pdsbd->dwFlags & DSBCAPS_FXIN)
    {
        if((pdsbd->dwInputMixBin < DSMIXBIN_FXSEND_FIRST) || (pdsbd->dwInputMixBin > DSMIXBIN_FXSEND_LAST))
        {
            DPF_ERROR("The input mixbin for an FXIN buffer can only be one of the FX sends");
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Create the settings object
    //

    hr = HRFROMP(m_pSettings = NEW(CDirectSoundBufferSettings));

    if(SUCCEEDED(hr))
    {
        hr = m_pSettings->Initialize(pdsbd);
    }

    //
    // Create the implementation object
    //
    
    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pBuffer = NEW(CMcpxBuffer(m_pDirectSound->m_pDevice, m_pSettings)));
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->Initialize();
    }

    //
    // Initialize the base class
    //

    if(SUCCEEDED(hr))
    {
        CDirectSoundVoice::Initialize(m_pBuffer, m_pSettings);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetBufferData
 *
 *  Description:
 *      Sets buffer data pointers.
 *
 *  Arguments:
 *      LPVOID [in]: data buffer.
 *      LPVOID [in]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetBufferData"

HRESULT
CDirectSoundBuffer::SetBufferData
(
    LPVOID                  pvDataBuffer,
    DWORD                   dwBufferBytes
)
{
    const BOOL              fChanging   = pvDataBuffer || dwBufferBytes;
    HRESULT                 hr          = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(pvDataBuffer && dwBufferBytes)
    {
        if(dwBufferBytes && (dwBufferBytes % m_pSettings->m_fmt.nBlockAlign))
        {
            DPF_ERROR("Buffer size not block-aligned");
        }

        if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
        {
            DPF_ERROR("Can't call SetBufferData on MIXIN/FXIN buffers");
        }
    }
    else if(pvDataBuffer)
    {
        DPF_ERROR("0-sized buffer with non-NULL buffer pointer");
    }
    else if(dwBufferBytes)
    {
        DPF_ERROR("NULL buffer with non-zero buffer size");
    }

#endif // VALIDATE_PARAMETERS

    if((pvDataBuffer != m_pSettings->m_pvBufferData) || (dwBufferBytes != m_pSettings->m_dwBufferSize))
    {
        //
        // Give the implementation object a chance to clean up before we
        // stomp on the shared data members.
        //

        hr = m_pBuffer->ReleaseBufferData(fChanging);

        //
        // Hand off to the settings object
        //

        if(SUCCEEDED(hr))
        {
            hr = m_pSettings->SetBufferData(pvDataBuffer, dwBufferBytes);
        }

        //
        // Notify the implementation object of the change
        //

        if(SUCCEEDED(hr) && fChanging)
        {
            hr = m_pBuffer->SetBufferData();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::Play"

HRESULT
CDirectSoundBuffer::Play
(
    DWORD                   dwReserved1,
    DWORD                   dwReserved2,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwReserved1 || dwReserved2)
    {
        DPF_ERROR("Reserved parameters must be 0");
    }
    
    if(dwFlags & ~DSBPLAY_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DSBPLAY_VALID);
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call Play on a MIXIN/FXIN buffer");
    }
    
    if(!m_pSettings->m_pvBufferData || !m_pSettings->m_dwBufferSize)
    {
        DPF_ERROR("No data to play!");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->Play(dwFlags);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  PlayEx
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: time to start playing.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::PlayEx"

HRESULT
CDirectSoundBuffer::PlayEx
(
    REFERENCE_TIME          rtTimeStamp,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DSBPLAY_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DSBPLAY_VALID);
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call Play on a MIXIN/FXIN buffer");
    }
    
    if(!m_pSettings->m_pvBufferData || !m_pSettings->m_dwBufferSize)
    {
        DPF_ERROR("No data to play!");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->Play(rtTimeStamp, dwFlags);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops buffer playback.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::Stop"

HRESULT
CDirectSoundBuffer::Stop
(
    void
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call Stop on a MIXIN/FXIN buffer");
    }
    
#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->Stop();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  StopEx
 *
 *  Description:
 *      Stops buffer playback.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: timestamp.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::StopEx"

HRESULT
CDirectSoundBuffer::StopEx
(
    REFERENCE_TIME          rtTimeStamp,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DSBSTOPEX_VALID)
    {
        DPF_ERROR("Invalid flags");
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call Stop on a MIXIN/FXIN buffer");
    }
    
#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->Stop(rtTimeStamp, dwFlags);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets the current buffer status.
 *
 *  Arguments:
 *      LPDWORD [out]: buffer status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::GetStatus"

HRESULT
CDirectSoundBuffer::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwStatus)
    {
        DPF_ERROR("Failed to specify a status buffer");
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call GetStatus on a MIXIN/FXIN buffer");
    }
    
#endif // VALIDATE_PARAMETERS
    
    hr = m_pBuffer->GetStatus(pdwStatus);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetPlayRegion
 *
 *  Description:
 *      Sets buffer play region.
 *
 *  Arguments:
 *      DWORD [in]: starting position of the play region.
 *      DWORD [in]: length, in bytes, of the play region.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetPlayRegion"

HRESULT
CDirectSoundBuffer::SetPlayRegion
(
    DWORD                   dwPlayStart,
    DWORD                   dwPlayLength
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call SetPlayRegion on MIXIN/FXIN buffers");
    }

    if(dwPlayStart % 4)
    {
        DPF_ERROR("Play offset not block-aligned");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Munge the length so it's valid
    //

    if(dwPlayLength)
    {

#ifdef VALIDATE_PARAMETERS

        if(dwPlayLength % m_pSettings->m_fmt.nBlockAlign)
        {
            DPF_ERROR("Play length not block-aligned");
        }

#endif // VALIDATE_PARAMETERS

        if(dwPlayStart + dwPlayLength > m_pSettings->m_dwBufferSize)
        {
            DPF_ERROR("Play region extends past the end of the buffer");
            hr = DSERR_INVALIDCALL;
        }
    }
    else
    {
        dwPlayLength = m_pSettings->m_dwBufferSize - dwPlayStart;
    }

    //
    // Update the settings object
    //

    if(SUCCEEDED(hr))
    {
        m_pSettings->SetPlayRegion(dwPlayStart, dwPlayLength);
    }

    //
    // Update the buffer implementation
    //

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->SetPlayRegion();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetLoopRegion
 *
 *  Description:
 *      Sets buffer loop region.
 *
 *  Arguments:
 *      DWORD [in]: starting position of the loop region.
 *      DWORD [in]: length, in bytes, of the loop region.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetLoopRegion"

HRESULT
CDirectSoundBuffer::SetLoopRegion
(
    DWORD                   dwLoopStart,
    DWORD                   dwLoopLength
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call SetLoopRegion on MIXIN/FXIN buffers");
    }

    if(dwLoopStart % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Loop offset not block-aligned");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Munge the length so it's valid
    //

    if(dwLoopLength)
    {

#ifdef VALIDATE_PARAMETERS

        if(dwLoopLength % m_pSettings->m_fmt.nBlockAlign)
        {
            DPF_ERROR("Loop length not block-aligned");
        }

#endif // VALIDATE_PARAMETERS

        if(dwLoopStart + dwLoopLength > m_pSettings->m_dwPlayLength)
        {
            DPF_ERROR("Loop region extends past the end of the play region");
            hr = DSERR_INVALIDCALL;
        }
    }
    else
    {
        dwLoopLength = m_pSettings->m_dwPlayLength - dwLoopStart;
    }

    //
    // Update the settings object
    //

    if(SUCCEEDED(hr))
    {
        m_pSettings->SetLoopRegion(dwLoopStart, dwLoopLength);
    }

    //
    // Update the buffer implementation
    //

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->SetLoopRegion();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: play cursor position, in bytes.
 *      LPDWORD [out]: write cursor position, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::GetCurrentPosition"

HRESULT
CDirectSoundBuffer::GetCurrentPosition
(
    LPDWORD                 pdwPlayPosition,
    LPDWORD                 pdwWritePosition
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call GetCurrentPosition on MIXIN/FXIN buffers");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->GetCurrentPosition(pdwPlayPosition, pdwWritePosition);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer data for writing.
 *
 *  Arguments:
 *      DWORD [in]: lock position.
 *      DWORD [in]: lock size.
 *      LPVOID * [out]: lock pointer 1.
 *      LPDWORD [out]: lock size 1.
 *      LPVOID * [out]: lock pointer 2.
 *      LPDWORD [out]: lock size 2.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::Lock"

HRESULT
CDirectSoundBuffer::Lock
(
    DWORD                   dwLockPosition, 
    DWORD                   dwLockSize, 
    LPVOID *                ppvLock1, 
    LPDWORD                 pdwLockSize1, 
    LPVOID *                ppvLock2, 
    LPDWORD                 pdwLockSize2, 
    DWORD                   dwFlags
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!ppvLock1 || !pdwLockSize1)
    {
        DPF_ERROR("Missing first set of lock parameters");
    }

    if((ppvLock2 && !pdwLockSize2) || (!ppvLock2 && pdwLockSize2))
    {
        DPF_ERROR("Missing one of the second set of lock parameters");
    }

    if(dwFlags & ~DSBLOCK_VALID)
    {
        DPF_ERROR("Specified unsupported or invalid flags (%lx)", dwFlags & ~DSBLOCK_VALID);
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't lock MIXIN/FXIN buffers");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Validate the lock position
    //

    if(dwFlags & DSBLOCK_FROMWRITECURSOR)
    {
        hr = GetCurrentPosition(NULL, &dwLockPosition);
    }
    
#ifdef VALIDATE_PARAMETERS

    else if(dwLockPosition >= m_pSettings->m_dwBufferSize)
    {
        DPF_ERROR("Lock position out-of-bounds");
    }
    else if(dwLockPosition % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Lock position not block aligned");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Validate the lock region size
    //

    if(SUCCEEDED(hr))
    {
        if(dwFlags & DSBLOCK_ENTIREBUFFER)
        {
            dwLockSize = m_pSettings->m_dwBufferSize;
        }
            
#ifdef VALIDATE_PARAMETERS

        else if(!dwLockSize)
        {
            DPF_ERROR("Lock size can't be 0 without specifying DSBLOCK_ENTIREBUFFER");
        }
        else if(dwLockSize > m_pSettings->m_dwBufferSize)
        {
            DPF_ERROR("Lock size out-of-bounds");
        }
        else if(dwLockSize % m_pSettings->m_fmt.nBlockAlign)
        {
            DPF_ERROR("Lock size not block aligned");
        }

#endif // VALIDATE_PARAMETERS

    }

    //
    // We're not really locking anything.  Instead, we're just returning
    // pointers to the data buffer.
    //

    if(SUCCEEDED(hr))
    {
        *ppvLock1 = (LPBYTE)m_pSettings->m_pvBufferData + dwLockPosition;
        *pdwLockSize1 = min(dwLockSize, m_pSettings->m_dwBufferSize - dwLockPosition);

        if(ppvLock2 && pdwLockSize2)
        {
            if(*pdwLockSize1 < dwLockSize)
            {
                *ppvLock2 = m_pSettings->m_pvBufferData;
                *pdwLockSize2 = dwLockSize - *pdwLockSize1;
            }
            else
            {
                *ppvLock2 = NULL;
                *pdwLockSize2 = 0;
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Gets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play cursor position, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetCurrentPosition"

HRESULT
CDirectSoundBuffer::SetCurrentPosition
(
    DWORD                   dwPlayPosition
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwPlayPosition % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Position not sample-aligned");
    }
    
    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call SetCurrentPosition on MIXIN/FXIN buffers");
    }

    if(dwPlayPosition >= m_pSettings->m_dwPlayLength)
    {
        DPF_ERROR("Play cursor position out-of-bounds");
    }
    
#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->SetCurrentPosition(dwPlayPosition);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets notification positions.
 *
 *  Arguments:
 *      DWORD [in]: notification count.
 *      LPCDSBPOSITIONNOTIFY [in]: notification array.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetNotificationPositions"

HRESULT
CDirectSoundBuffer::SetNotificationPositions
(
    DWORD                   dwNotifyCount,
    LPCDSBPOSITIONNOTIFY    paNotifies
)
{
    HRESULT                 hr  = DS_OK;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY))
    {
        DPF_ERROR("Buffer does not have CTRLPOSITIONNOTIFY");
    }

    for(i = 0; i < dwNotifyCount; i++)
    {
        if(DSBPN_OFFSETSTOP == paNotifies[i].dwOffset)
        {
            continue;
        }
        
        if(paNotifies[i].dwOffset % m_pSettings->m_fmt.nBlockAlign)
        {
            DPF_ERROR("Offset at index %lu not block-aligned", i);
        }

        if(paNotifies[i].dwOffset >= m_pSettings->m_dwPlayLength)
        {
            DPF_ERROR("Offset at index %lu past the end of the play region", i);
        }
        
        if(!IS_VALID_HANDLE_VALUE(paNotifies[i].hEventNotify))
        {
            DPF_ERROR("Invalid event at index %lu", i);
        }
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call SetNotificationPositions on MIXIN/FXIN buffers");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the settings object
    //

    hr = m_pSettings->SetNotificationPositions(dwNotifyCount, paNotifies);

    //
    // Update the implementation object
    //

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->SetNotificationPositions();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifndef MCPX_BOOT_LIB

/****************************************************************************
 *
 *  CDirectSoundStreamSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStreamSettings::CDirectSoundStreamSettings"

CDirectSoundStreamSettings::CDirectSoundStreamSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundStreamSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStreamSettings::~CDirectSoundStreamSettings"

CDirectSoundStreamSettings::~CDirectSoundStreamSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: stream description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStreamSettings::Initialize"

HRESULT
CDirectSoundStreamSettings::Initialize
(
    LPCDSSTREAMDESC         pdssd
)
{
    HRESULT                 hr;

    DPF_ENTER();

    //
    // Hand off to the base class
    //

    hr = CDirectSoundVoiceSettings::Initialize(pdssd->dwFlags, pdssd->lpwfxFormat, pdssd->lpMixBins);

    //
    // Save stream-specific settings
    //

    if(SUCCEEDED(hr))
    {
        m_dwMaxAttachedPackets = pdssd->dwMaxAttachedPackets;
        m_pfnCallback = pdssd->lpfnCallback;
        m_pvContext = pdssd->lpvContext;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CDirectSoundStream
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: parent DirectSound object
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::CDirectSoundStream"

CDirectSoundStream::CDirectSoundStream
(
    CDirectSound *      pDirectSound
)
:   CDirectSoundVoice(pDirectSound)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundStream
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::~CDirectSoundStream"

CDirectSoundStream::~CDirectSoundStream
(
    void
)
{
    DPF_ENTER();

    //
    // Free the stream implementation
    //

    RELEASE(m_pStream);

    //
    // Free settings
    //

    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: stream description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Initialize"

HRESULT
CDirectSoundStream::Initialize
(
    LPCDSSTREAMDESC         pdssd
)
{                                   
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();
    
#ifdef VALIDATE_PARAMETERS

    if(!pdssd)
    {
        DPF_ERROR("DSSTREAMDESC not supplied");
    }

    if(pdssd->dwFlags & ~DSSTREAMCAPS_VALID)
    {
        DPF_ERROR("Specified invalid flags (%lx)", pdssd->dwFlags & ~DSSTREAMCAPS_VALID);
    }
        
    if(!pdssd->lpwfxFormat)
    {
        DPF_ERROR("Failed to specify a stream format");
    }

    if(!IsValidFormat(pdssd->lpwfxFormat))
    {
        DPF_ERROR("Invalid stream format");
    }

    if((pdssd->dwFlags & DSBCAPS_CTRL3D) && (1 != pdssd->lpwfxFormat->nChannels))
    {
        DPF_ERROR("3D streams must be mono");
    }

    if((pdssd->dwFlags & DSSTREAMCAPS_CTRL3D) && !CHrtfSource::IsValidAlgorithm())
    {
        DPF_ERROR("You must call one of the 3D algorithm initialization functions (DirectSoundUseLightHRTF, DirectSoundUseFullHRTF, DirectSoundUsePan3D) before creating a 3D stream");
    }

    if(pdssd->lpMixBins)
    {
        if(pdssd->lpMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
        {
            DPF_ERROR("No voice can be assigned to more than %lu mix bins", DSMIXBIN_ASSIGNMENT_MAX);
        }

        if(pdssd->lpwfxFormat)
        {
            if(pdssd->lpMixBins->dwMixBinCount % pdssd->lpwfxFormat->nChannels)
            {
                DPF_ERROR("The mixbin count must be a multiple of the channel count");
            }

            if(WAVE_FORMAT_EXTENSIBLE == pdssd->lpwfxFormat->wFormatTag)
            {
                if(((LPCWAVEFORMATEXTENSIBLE)pdssd->lpwfxFormat)->dwChannelMask)
                {
                    DPF_WARNING("Specifying mixbins will override the channel mask specified in the format");
                }
            }
        }

        for(i = 0; i < pdssd->lpMixBins->dwMixBinCount; i++)
        {
            if(pdssd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin > DSMIXBIN_LAST)
            {
                DPF_ERROR("Specified an invalid mixbin");
            }

            if(DSMIXBIN_SUBMIX == pdssd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin)
            {
                DPF_ERROR("Don't assign a voice to DSMIXBIN_SUBMIX.  Instead, call SetOutputBuffer");
            }
        }

        if(pdssd->dwFlags & DSBCAPS_CTRL3D)
        {
            if(pdssd->lpMixBins->dwMixBinCount < DirectSoundRequiredMixBins_3D.dwMixBinCount)
            {
                DPF_ERROR("MixBin count doesn't include enough mixbins to hold all required for 3D");
            }
            
            for(i = 0; i < DirectSoundRequiredMixBins_3D.dwMixBinCount; i++)
            {
                if(pdssd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin != DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[i].dwMixBin)
                {
                    DPF_ERROR("MixBin array does not include the required 3D bins");
                }
            }
        }
    }

    if(!pdssd->dwMaxAttachedPackets)
    {
        DPF_ERROR("dwMaxAttachedPackets must be at least 1");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Create the settings object
    //

    hr = HRFROMP(m_pSettings = NEW(CDirectSoundStreamSettings));

    if(SUCCEEDED(hr))
    {
        hr = m_pSettings->Initialize(pdssd);
    }

    //
    // Create the implementation object
    //
    
    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pStream = NEW(CMcpxStream(m_pDirectSound->m_pDevice, m_pSettings)));
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pStream->Initialize();
    }

    //
    // Initialize the base class
    //

    if(SUCCEEDED(hr))
    {
        CDirectSoundVoice::Initialize(m_pStream, m_pSettings);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the object supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [in/out]: info data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::GetInfo"

HRESULT
CDirectSoundStream::GetInfo
(
    LPXMEDIAINFO            pInfo
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pInfo)
    {
        DPF_ERROR("No XMEDIAINFO buffer supplied");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Flags are easy
    //
    
    pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC;

    //
    // The mixer will break up if you queue up less than the mix buffer size
    //

    pInfo->dwMaxLookahead = m_pStream->GetLowWatermark();

    //
    // Input size is just sample-aligment, since that's the smallest amount of
    // data we require to process.
    //

    pInfo->dwInputSize = m_pSettings->m_fmt.nBlockAlign;

    //
    // There is no output
    //

    pInfo->dwOutputSize = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Discontinuity
 *
 *  Description:
 *      Signals a discontinuity in the stream data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Discontinuity"

HRESULT
CDirectSoundStream::Discontinuity
(
    void
)                                       
{                                           
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
    hr = m_pStream->Discontinuity();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Resets the stream to it's default state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Flush"

HRESULT
CDirectSoundStream::Flush
(
    void
)                                       
{                                           
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
    hr = m_pStream->Flush();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets stream status.
 *
 *  Arguments:
 *      LPDWORD [out]: stream status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::GetStatus"

HRESULT
CDirectSoundStream::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwStatus)
    {
        DPF_ERROR("Status buffer not supplied");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pStream->GetStatus(pdwStatus);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Submits buffers to the stream.
 *
 *  Arguments:
 *      LPXMEDIAPACKET  [in]: input buffer.
 *      LPXMEDIAPACKET  [in]: output buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Process"

HRESULT
CDirectSoundStream::Process
(
    LPCXMEDIAPACKET         pxmbSource, 
    LPCXMEDIAPACKET         pxmbDest 
)
{
    DWORD                   dwStatus;
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pxmbSource)
    {
        DPF_ERROR("No input buffer supplied");
    }

    if(!pxmbSource->pvBuffer)
    {
        DPF_ERROR("No input data buffer supplied");
    }

    if(!pxmbSource->dwMaxSize)
    {
        DPF_ERROR("No input buffer size");
    }

    if(pxmbSource->dwMaxSize % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Input buffer size not block-aligned");
    }

    if(pxmbSource->prtTimestamp)
    {
        if(*pxmbSource->prtTimestamp)
        {
            DPF_ERROR("Timestamps are not supported on DirectSound streams");
        }
    }

    if(pxmbDest)
    {
        DPF_ERROR("DirectSound streams are input only.  No destination packet should be supplied.");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Make sure the stream is accepting data
    //

    hr = m_pStream->GetStatus(&dwStatus);

    if(SUCCEEDED(hr) && !(dwStatus & DSSTREAMSTATUS_READY))
    {
        DPF_ERROR("The stream is not ready to accept more data");
        hr = DSERR_INVALIDCALL;
    }
    
    //
    // Submit the packet to the stream
    //

    if(SUCCEEDED(hr))
    {
        hr = m_pStream->SubmitPacket(*pxmbSource);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Pause
 *
 *  Description:
 *      Pauses or resumes a stream.
 *
 *  Arguments:
 *      DWORD [in]: stream pause state.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Pause"

HRESULT
CDirectSoundStream::Pause
(
    DWORD                   dwPause
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((dwPause < DSSTREAMPAUSE_FIRST) || (dwPause > DSSTREAMPAUSE_LAST))
    {
        DPF_ERROR("Invalid stream pause state");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pStream->Pause(dwPause);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  PauseEx
 *
 *  Description:
 *      Pauses or resumes a stream.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: timestamp.
 *      DWORD [in]: stream pause state.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::PauseEx"

HRESULT
CDirectSoundStream::PauseEx
(
    REFERENCE_TIME          rtTimestamp,
    DWORD                   dwPause
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((dwPause < DSSTREAMPAUSE_FIRST) || (dwPause > DSSTREAMPAUSE_LAST))
    {
        DPF_ERROR("Invalid stream pause state");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pStream->Pause(rtTimestamp, dwPause);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  FlushEx
 *
 *  Description:
 *      Flushes the stream.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: timestamp.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::FlushEx"

HRESULT
CDirectSoundStream::FlushEx
(
    REFERENCE_TIME          rtTimeStamp, 
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DSSTREAMFLUSHEX_VALID)
    {
        DPF_ERROR("Invalid flags");
    }

    if((dwFlags & DSSTREAMFLUSHEX_ENVELOPE) && !(dwFlags & DSSTREAMFLUSHEX_ASYNC))
    {
        DPF_ERROR("ENVELOPE flag requires ASYNC flag");
    }

    if(rtTimeStamp && !(dwFlags & DSSTREAMFLUSHEX_ASYNC))
    {
        DPF_ERROR("Timestamped flush requires ASYNC flag");
    }

#endif // VALIDATE_PARAMETERS

    if(dwFlags)
    {
        hr = m_pStream->Stop(rtTimeStamp, dwFlags);
    }
    else
    {
        hr = m_pStream->Flush();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#endif // MCPX_BOOT_LIB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsapi.old.cpp ===
//depot/xbox/private/windows/directx/dsound/dsound/dsapi.cpp#72 - edit change 20916 (text)
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsapi.cpp
 *  Content:    DirectSound API objects and entry points.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/06/00    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

#pragma comment(linker, "/merge:DSOUND_RW=DSOUND")
#pragma comment(linker, "/merge:DSOUND_URW=DSOUND")
#pragma comment(linker, "/merge:DSOUND_RD=DSOUND")
#pragma comment(linker, "/section:DSOUND,ERW")

STDAPI IDirectSound_QueryInterfaceC(LPDIRECTSOUND pDirectSound, const IID *iid, LPVOID *ppvInterface)
{
    ASSERT(pDirectSound);
    ASSERT(ppvInterface);

    IDirectSound_AddRef(pDirectSound);
    *ppvInterface = pDirectSound;

    return DS_OK;
}

STDAPI IDirectSound_QueryInterface(LPDIRECTSOUND pDirectSound, REFIID iid, LPVOID *ppvInterface)
{
    ASSERT(pDirectSound);
    ASSERT(ppvInterface);

    IDirectSound_AddRef(pDirectSound);
    *ppvInterface = pDirectSound;

    return DS_OK;
}

STDAPI IDirectSound_SetCooperativeLevel(LPDIRECTSOUND pDirectSound, HWND hWnd, DWORD dwLevel)
{
    UNREFERENCED_PARAMETER(pDirectSound);
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(dwLevel);
    return DS_OK;
}

STDAPI IDirectSound_Compact(LPDIRECTSOUND pDirectSound)
{
    UNREFERENCED_PARAMETER(pDirectSound);
    return DS_OK;
}

STDAPI_(ULONG) IDirectSound_AddRef(LPDIRECTSOUND pDirectSound)
{
    return ((CDirectSound *)pDirectSound)->AddRef();
}

STDAPI_(ULONG) IDirectSound_Release(LPDIRECTSOUND pDirectSound)
{
    return ((CDirectSound *)pDirectSound)->Release();
}

STDAPI IDirectSound_GetCaps(LPDIRECTSOUND pDirectSound, LPDSCAPS pdsc)
{
    return ((CDirectSound *)pDirectSound)->GetCaps(pdsc);
}

STDAPI IDirectSound_CreateSoundBuffer(LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter)
{
    return ((CDirectSound *)pDirectSound)->CreateSoundBuffer(pdsbd, ppBuffer, pUnkOuter);
}

STDAPI IDirectSound_CreateSoundBuffer_v1(LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC1 pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter)
{
    return ((CDirectSound *)pDirectSound)->CreateSoundBuffer_v1(pdsbd, ppBuffer, pUnkOuter);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSound_CreateSoundStream(LPDIRECTSOUND pDirectSound, LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter)
{
    return ((CDirectSound *)pDirectSound)->CreateSoundStream(pdssd, ppStream, pUnkOuter);
}

STDAPI IDirectSound_CreateSoundStream_v1(LPDIRECTSOUND pDirectSound, LPCDSSTREAMDESC1 pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter)
{
    return ((CDirectSound *)pDirectSound)->CreateSoundStream_v1(pdssd, ppStream, pUnkOuter);
}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSound_GetSpeakerConfig(LPDIRECTSOUND pDirectSound, LPDWORD pdwSpeakerConfig)
{
    return ((CDirectSound *)pDirectSound)->GetSpeakerConfig(pdwSpeakerConfig);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSound_DownloadEffectsImage(LPDIRECTSOUND pDirectSound, LPCVOID pvImageBuffer, DWORD dwImageSize, LPCDSEFFECTIMAGELOC pImageLoc, LPDSEFFECTIMAGEDESC *ppImageDesc)
{
    return ((CDirectSound *)pDirectSound)->DownloadEffectsImage(pvImageBuffer, dwImageSize, pImageLoc, ppImageDesc);
}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSound_GetEffectData(LPDIRECTSOUND pDirectSound, DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize)
{
    return ((CDirectSound *)pDirectSound)->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);
}

STDAPI IDirectSound_SetEffectData(LPDIRECTSOUND pDirectSound, DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);
}

STDAPI IDirectSound_CommitEffectData(LPDIRECTSOUND pDirectSound)
{
    return ((CDirectSound *)pDirectSound)->CommitEffectData();
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSound_EnableHeadphones(LPDIRECTSOUND pDirectSound, BOOL fEnabled)
{
    return ((CDirectSound *)pDirectSound)->EnableHeadphones(fEnabled);
}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSound_SetMixBinHeadroom(LPDIRECTSOUND pDirectSound, DWORD dwMixBin, DWORD dwHeadroom)
{
    return ((CDirectSound *)pDirectSound)->SetMixBinHeadroom(dwMixBin, dwHeadroom);
}

STDAPI IDirectSound_SetMixBinHeadroom_v1(LPDIRECTSOUND pDirectSound, DWORD dwMixBinMask, DWORD dwHeadroom)
{
    return ((CDirectSound *)pDirectSound)->SetMixBinHeadroom_v1(dwMixBinMask, dwHeadroom);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSound_SetAllParameters(LPDIRECTSOUND pDirectSound, LPCDS3DLISTENER pds3dl, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetAllParameters(pds3dl, dwFlags);
}

STDAPI IDirectSound_SetDistanceFactor(LPDIRECTSOUND pDirectSound, FLOAT flDistanceFactor, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetDistanceFactor(flDistanceFactor, dwFlags);
}

STDAPI IDirectSound_SetDopplerFactor(LPDIRECTSOUND pDirectSound, FLOAT flDopplerFactor, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetDopplerFactor(flDopplerFactor, dwFlags);
}

STDAPI IDirectSound_SetOrientation(LPDIRECTSOUND pDirectSound, FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetOrientation(xFront, yFront, zFront, xTop, yTop, zTop, dwFlags);
}

STDAPI IDirectSound_SetPosition(LPDIRECTSOUND pDirectSound, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetPosition(x, y, z, dwFlags);
}

STDAPI IDirectSound_SetRolloffFactor(LPDIRECTSOUND pDirectSound, FLOAT flRolloffFactor, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetRolloffFactor(flRolloffFactor, dwFlags);
}

STDAPI IDirectSound_SetVelocity(LPDIRECTSOUND pDirectSound, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetVelocity(x, y, z, dwFlags);
}

STDAPI IDirectSound_CommitDeferredSettings(LPDIRECTSOUND pDirectSound)
{
    return ((CDirectSound *)pDirectSound)->CommitDeferredSettings();
}

STDAPI IDirectSound_SetI3DL2Listener(LPDIRECTSOUND pDirectSound, LPCDSI3DL2LISTENER pds3dl, DWORD dwFlags)
{
    return ((CDirectSound *)pDirectSound)->SetI3DL2Listener(pds3dl, dwFlags);
}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSound_GetTime(LPDIRECTSOUND pDirectSound, REFERENCE_TIME *prtCurrent)
{
    return ((CDirectSound *)pDirectSound)->GetTime(prtCurrent);
}

STDAPI IDirectSoundBuffer_QueryInterface(LPDIRECTSOUNDBUFFER pBuffer, REFIID iid, LPVOID *ppvInterface)
{
    ASSERT(pBuffer);
    ASSERT(ppvInterface);

    IDirectSoundBuffer_AddRef(pBuffer);
    *ppvInterface = pBuffer;

    return DS_OK;
}

STDAPI IDirectSoundBuffer_QueryInterfaceC(LPDIRECTSOUNDBUFFER pBuffer, const IID *iid, LPVOID *ppvInterface)
{
    ASSERT(pBuffer);
    ASSERT(ppvInterface);

    IDirectSoundBuffer_AddRef(pBuffer);
    *ppvInterface = pBuffer;

    return DS_OK;
}

STDAPI IDirectSoundBuffer_Unlock(LPDIRECTSOUNDBUFFER pBuffer, LPVOID pvLock1, DWORD dwLockSize1, LPVOID pvLock2, DWORD dwLockSize2)
{
    return DS_OK;
}

STDAPI IDirectSoundBuffer_Restore(LPDIRECTSOUNDBUFFER pBuffer)
{
    return DS_OK;
}

STDAPI_(ULONG) IDirectSoundBuffer_AddRef(LPDIRECTSOUNDBUFFER pBuffer)
{
    return ((CDirectSoundBuffer *)pBuffer)->AddRef();
}

STDAPI_(ULONG) IDirectSoundBuffer_Release(LPDIRECTSOUNDBUFFER pBuffer)
{
    return ((CDirectSoundBuffer *)pBuffer)->Release();
}

STDAPI IDirectSoundBuffer_SetFormat(LPDIRECTSOUNDBUFFER pBuffer, LPCWAVEFORMATEX pwfxFormat)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetFormat(pwfxFormat);
}

STDAPI IDirectSoundBuffer_SetFrequency(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwFrequency)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetFrequency(dwFrequency);
}

STDAPI IDirectSoundBuffer_SetVolume(LPDIRECTSOUNDBUFFER pBuffer, LONG lVolume)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetVolume(lVolume);
}

STDAPI IDirectSoundBuffer_SetPitch(LPDIRECTSOUNDBUFFER pBuffer, LONG lPitch)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetPitch(lPitch);
}

STDAPI IDirectSoundBuffer_SetLFO(LPDIRECTSOUNDBUFFER pBuffer, LPCDSLFODESC pLFODesc)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetLFO(pLFODesc);
}

STDAPI IDirectSoundBuffer_SetEG(LPDIRECTSOUNDBUFFER pBuffer, LPCDSENVELOPEDESC pEnvelopeDesc)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetEG(pEnvelopeDesc);
}

STDAPI IDirectSoundBuffer_SetFilter(LPDIRECTSOUNDBUFFER pBuffer, LPCDSFILTERDESC pFilter)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetFilter(pFilter);
}

STDAPI IDirectSoundBuffer_SetHeadroom(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwHeadroom)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetHeadroom(dwHeadroom);
}

STDAPI IDirectSoundBuffer_SetOutputBuffer(LPDIRECTSOUNDBUFFER pBuffer, LPDIRECTSOUNDBUFFER pOutputBuffer)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetOutputBuffer(pOutputBuffer);
}

STDAPI IDirectSoundBuffer_SetMixBins(LPDIRECTSOUNDBUFFER pBuffer, LPCDSMIXBINS pMixBins)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetMixBins(pMixBins);
}

STDAPI IDirectSoundBuffer_SetMixBinVolumes(LPDIRECTSOUNDBUFFER pBuffer, LPCDSMIXBINS pMixBins)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetMixBinVolumes(pMixBins);
}

STDAPI IDirectSoundBuffer_SetOutputBuffer_v1(LPDIRECTSOUNDBUFFER pBuffer, LPDIRECTSOUNDBUFFER pOutputBuffer)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetOutputBuffer_v1(pOutputBuffer);
}

STDAPI IDirectSoundBuffer_SetMixBins_v1(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwMixBinMask)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetMixBins_v1(dwMixBinMask);
}

STDAPI IDirectSoundBuffer_SetMixBinVolumes_v1(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwMixBinMask, const LONG *palVolumes)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetMixBinVolumes_v1(dwMixBinMask, palVolumes);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSoundBuffer_SetAllParameters(LPDIRECTSOUNDBUFFER pBuffer, LPCDS3DBUFFER pds3db, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetAllParameters(pds3db, dwFlags);
}

STDAPI IDirectSoundBuffer_SetConeAngles(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, dwFlags);
}

STDAPI IDirectSoundBuffer_SetConeOrientation(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetConeOrientation(x, y, z, dwFlags);
}

STDAPI IDirectSoundBuffer_SetConeOutsideVolume(LPDIRECTSOUNDBUFFER pBuffer, LONG lConeOutsideVolume, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetConeOutsideVolume(lConeOutsideVolume, dwFlags);
}

STDAPI IDirectSoundBuffer_SetMaxDistance(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flMaxDistance, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetMaxDistance(flMaxDistance, dwFlags);
}

STDAPI IDirectSoundBuffer_SetMinDistance(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flMinDistance, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetMinDistance(flMinDistance, dwFlags);
}

STDAPI IDirectSoundBuffer_SetMode(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwMode, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetMode(dwMode, dwFlags);
}

STDAPI IDirectSoundBuffer_SetPosition(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetPosition(x, y, z, dwFlags);
}

STDAPI IDirectSoundBuffer_SetVelocity(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetVelocity(x, y, z, dwFlags);
}

STDAPI IDirectSoundBuffer_SetI3DL2Source(LPDIRECTSOUNDBUFFER pBuffer, LPCDSI3DL2BUFFER pds3db, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetI3DL2Source(pds3db, dwFlags);
}

#endif // MCPX_BOOT_LIB

STDAPI IDirectSoundBuffer_Play(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->Play(dwReserved1, dwReserved2, dwFlags);
}

STDAPI IDirectSoundBuffer_PlayEx(LPDIRECTSOUNDBUFFER pBuffer, REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->PlayEx(rtTimeStamp, dwFlags);
}

STDAPI IDirectSoundBuffer_Stop(LPDIRECTSOUNDBUFFER pBuffer)
{
    return ((CDirectSoundBuffer *)pBuffer)->Stop();
}

STDAPI IDirectSoundBuffer_StopEx(LPDIRECTSOUNDBUFFER pBuffer, REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->StopEx(rtTimeStamp, dwFlags);
}

STDAPI IDirectSoundBuffer_SetBufferOffsets(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwPlayStart, DWORD dwPlayLength, DWORD dwLoopStart, DWORD dwLoopLength)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetBufferOffsets(dwPlayStart, dwPlayLength, dwLoopStart, dwLoopLength);
}

STDAPI IDirectSoundBuffer_SetLoopRegion_v1(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwLoopStart, DWORD dwLoopLength)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetLoopRegion_v1(dwLoopStart, dwLoopLength);
}

STDAPI IDirectSoundBuffer_GetStatus(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwStatus)
{
    return ((CDirectSoundBuffer *)pBuffer)->GetStatus(pdwStatus);
}

STDAPI IDirectSoundBuffer_GetCurrentPosition(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor)
{
    return ((CDirectSoundBuffer *)pBuffer)->GetCurrentPosition(pdwPlayCursor, pdwWriteCursor);
}

STDAPI IDirectSoundBuffer_SetCurrentPosition(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwPlayCursor)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetCurrentPosition(dwPlayCursor);
}

STDAPI IDirectSoundBuffer_SetBufferData(LPDIRECTSOUNDBUFFER pBuffer, LPVOID pvBufferData, DWORD dwBufferBytes)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetBufferData(pvBufferData, dwBufferBytes);
}

STDAPI IDirectSoundBuffer_Lock(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    return ((CDirectSoundBuffer *)pBuffer)->Lock(dwOffset, dwBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
}

STDAPI IDirectSoundBuffer_SetNotificationPositions(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies)
{
    return ((CDirectSoundBuffer *)pBuffer)->SetNotificationPositions(dwNotifyCount, paNotifies);
}

#ifndef MCPX_BOOT_LIB

STDAPI IDirectSoundStream_QueryInterface(LPDIRECTSOUNDSTREAM pStream, REFIID iid, LPVOID *ppvInterface)
{
    ASSERT(pStream);
    ASSERT(ppvInterface);

    IDirectSoundStream_AddRef(pStream);
    *ppvInterface = pStream;

    return DS_OK;
}

STDAPI IDirectSoundStream_QueryInterfaceC(LPDIRECTSOUNDSTREAM pStream, const IID *iid, LPVOID *ppvInterface)
{
    ASSERT(pStream);
    ASSERT(ppvInterface);

    IDirectSoundStream_AddRef(pStream);
    *ppvInterface = pStream;

    return DS_OK;
}

STDAPI IDirectSoundStream_SetFormat(LPDIRECTSOUNDSTREAM pStream, LPCWAVEFORMATEX pwfxFormat)
{
    return ((CDirectSoundStream *)pStream)->SetFormat(pwfxFormat);
}

STDAPI IDirectSoundStream_SetFrequency(LPDIRECTSOUNDSTREAM pStream, DWORD dwFrequency)
{
    return ((CDirectSoundStream *)pStream)->SetFrequency(dwFrequency);
}

STDAPI IDirectSoundStream_SetVolume(LPDIRECTSOUNDSTREAM pStream, LONG lVolume)
{
    return ((CDirectSoundStream *)pStream)->SetVolume(lVolume);
}

STDAPI IDirectSoundStream_SetPitch(LPDIRECTSOUNDSTREAM pStream, LONG lPitch)
{
    return ((CDirectSoundStream *)pStream)->SetPitch(lPitch);
}

STDAPI IDirectSoundStream_SetLFO(LPDIRECTSOUNDSTREAM pStream, LPCDSLFODESC pLFODesc)
{
    return ((CDirectSoundStream *)pStream)->SetLFO(pLFODesc);
}

STDAPI IDirectSoundStream_SetEG(LPDIRECTSOUNDSTREAM pStream, LPCDSENVELOPEDESC pEnvelopeDesc)
{
    return ((CDirectSoundStream *)pStream)->SetEG(pEnvelopeDesc);
}

STDAPI IDirectSoundStream_SetFilter(LPDIRECTSOUNDSTREAM pStream, LPCDSFILTERDESC pFilter)
{
    return ((CDirectSoundStream *)pStream)->SetFilter(pFilter);
}

STDAPI IDirectSoundStream_SetHeadroom(LPDIRECTSOUNDSTREAM pStream, DWORD dwHeadroom)
{
    return ((CDirectSoundStream *)pStream)->SetHeadroom(dwHeadroom);
}

STDAPI IDirectSoundStream_SetOutputBuffer(LPDIRECTSOUNDSTREAM pStream, LPDIRECTSOUNDBUFFER pOutputBuffer)
{
    return ((CDirectSoundStream *)pStream)->SetOutputBuffer(pOutputBuffer);
}

STDAPI IDirectSoundStream_SetMixBins(LPDIRECTSOUNDSTREAM pStream, LPCDSMIXBINS pMixBins)
{
    return ((CDirectSoundStream *)pStream)->SetMixBins(pMixBins);
}

STDAPI IDirectSoundStream_SetMixBinVolumes(LPDIRECTSOUNDSTREAM pStream, LPCDSMIXBINS pMixBins)
{
    return ((CDirectSoundStream *)pStream)->SetMixBinVolumes(pMixBins);
}

STDAPI IDirectSoundStream_SetOutputBuffer_v1(LPDIRECTSOUNDSTREAM pStream, LPDIRECTSOUNDBUFFER pOutputBuffer)
{
    return ((CDirectSoundStream *)pStream)->SetOutputBuffer_v1(pOutputBuffer);
}

STDAPI IDirectSoundStream_SetMixBins_v1(LPDIRECTSOUNDSTREAM pStream, DWORD dwMixBinMask)
{
    return ((CDirectSoundStream *)pStream)->SetMixBins_v1(dwMixBinMask);
}

STDAPI IDirectSoundStream_SetMixBinVolumes_v1(LPDIRECTSOUNDSTREAM pStream, DWORD dwMixBinMask, const LONG *palVolumes)
{
    return ((CDirectSoundStream *)pStream)->SetMixBinVolumes_v1(dwMixBinMask, palVolumes);
}

STDAPI IDirectSoundStream_SetAllParameters(LPDIRECTSOUNDSTREAM pStream, LPCDS3DBUFFER pds3db, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetAllParameters(pds3db, dwFlags);
}

STDAPI IDirectSoundStream_SetConeAngles(LPDIRECTSOUNDSTREAM pStream, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, dwFlags);
}

STDAPI IDirectSoundStream_SetConeOrientation(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetConeOrientation(x, y, z, dwFlags);
}

STDAPI IDirectSoundStream_SetConeOutsideVolume(LPDIRECTSOUNDSTREAM pStream, LONG lConeOutsideVolume, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetConeOutsideVolume(lConeOutsideVolume, dwFlags);
}

STDAPI IDirectSoundStream_SetMaxDistance(LPDIRECTSOUNDSTREAM pStream, FLOAT flMaxDistance, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetMaxDistance(flMaxDistance, dwFlags);
}

STDAPI IDirectSoundStream_SetMinDistance(LPDIRECTSOUNDSTREAM pStream, FLOAT flMinDistance, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetMinDistance(flMinDistance, dwFlags);
}

STDAPI IDirectSoundStream_SetMode(LPDIRECTSOUNDSTREAM pStream, DWORD dwMode, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetMode(dwMode, dwFlags);
}

STDAPI IDirectSoundStream_SetPosition(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetPosition(x, y, z, dwFlags);
}

STDAPI IDirectSoundStream_SetVelocity(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetVelocity(x, y, z, dwFlags);
}

STDAPI IDirectSoundStream_SetI3DL2Source(LPDIRECTSOUNDSTREAM pStream, LPCDSI3DL2BUFFER pds3db, DWORD dwFlags)
{
    return ((CDirectSoundStream *)pStream)->SetI3DL2Source(pds3db, dwFlags);
}

STDAPI IDirectSoundStream_Pause(LPDIRECTSOUNDSTREAM pStream, DWORD dwPause)
{
    return ((CDirectSoundStream *)pStream)->Pause(dwPause);
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  DirectSoundCreate
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      CDirectSound ** [out]: DirectSound object.  The caller is responbile
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateInternal"

HRESULT
DirectSoundCreateInternal
(
    CDirectSound **         ppDirectSound
)
{
    CDirectSound *          pDirectSound    = NULL;
    HRESULT                 hr              = DS_OK;
    
    DPF_ENTER();

    //
    // Check to see if the DirectSound object already exists
    //

    if(CDirectSound::m_pDirectSound)
    {
        *ppDirectSound = ADDREF(CDirectSound::m_pDirectSound);
    }
    else
    {
        hr = HRFROMP(pDirectSound = NEW(CDirectSound));

        if(SUCCEEDED(hr))
        {
            hr = pDirectSound->Initialize();
        }

        if(SUCCEEDED(hr))
        {
            *ppDirectSound = pDirectSound;
        }
        else
        {
            RELEASE(pDirectSound);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundCreate
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      LPGUID [in]: unused.  Must be NULL.
 *      LPDIRECTSOUND * [out]: DirectSound object.  The caller is responbile
 *                             for freeing this object with Release.
 *      LPUNKNOWN [in]: unused.  Must be NULL.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreate"

HRESULT
DirectSoundCreate
(
    LPGUID                  pguidDeviceId,
    LPDIRECTSOUND *         ppDirectSound,
    LPUNKNOWN               pControllingUnknown
)
{
    CDirectSound *          pDirectSound;
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifdef VALIDATE_PARAMETERS

    if(!IS_NULL_GUID(*pguidDeviceId))
    {
        DPF_ERROR("NULL or GUID_NULL is the only supported device identifier");
    }

    if(!ppDirectSound)
    {
        DPF_ERROR("Failed to supply an LPDIRECTSOUND *");
    }
    
    if(pControllingUnknown)
    {
        DPF_ERROR("Aggregation is not supported");
    }

#endif // VALIDATE_PARAMETERS

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        *ppDirectSound = pDirectSound;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundCreateBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *      LPDIRECTSOUNDBUFFER * [out]: DirectSound Buffer object.  The caller 
 *                                   is responbile for freeing this object 
 *                                   with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateBuffer"

HRESULT
DirectSoundCreateBuffer
(
    LPCDSBUFFERDESC         pdsbd,
    LPDIRECTSOUNDBUFFER *   ppBuffer
)
{
    CDirectSound *          pDirectSound    = NULL;
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->CreateSoundBuffer(pdsbd, ppBuffer, NULL);
    }

    RELEASE(pDirectSound);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundCreateBuffer_v1
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *      LPDIRECTSOUNDBUFFER * [out]: DirectSound Buffer object.  The caller 
 *                                   is responbile for freeing this object 
 *                                   with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateBuffer_v1"

HRESULT
DirectSoundCreateBuffer_v1
(
    LPCDSBUFFERDESC1        pdsbd,
    LPDIRECTSOUNDBUFFER *   ppBuffer
)
{
    CDirectSound *          pDirectSound    = NULL;
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->CreateSoundBuffer_v1(pdsbd, ppBuffer, NULL);
    }

    RELEASE(pDirectSound);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundCreateStream
 *
 *  Description:
 *      Creates and initializes a DirectSound Stream object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: stream description.
 *      LPDIRECTSOUNDSTREAM * [out]: DirectSound Stream object.  The caller 
 *                                   is responbile for freeing this object 
 *                                   with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateStream"

HRESULT
DirectSoundCreateStream
(
    LPCDSSTREAMDESC         pdssd,
    LPDIRECTSOUNDSTREAM *   ppStream
)
{
    CDirectSound *          pDirectSound    = NULL;
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->CreateSoundStream(pdssd, ppStream, NULL);
    }

    RELEASE(pDirectSound);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  DirectSoundCreateStream_v1
 *
 *  Description:
 *      Creates and initializes a DirectSound Stream object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: stream description.
 *      LPDIRECTSOUNDSTREAM * [out]: DirectSound Stream object.  The caller 
 *                                   is responbile for freeing this object 
 *                                   with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateStream_v1"

HRESULT
DirectSoundCreateStream_v1
(
    LPCDSSTREAMDESC1        pdssd,
    LPDIRECTSOUNDSTREAM *   ppStream
)
{
    CDirectSound *          pDirectSound    = NULL;
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->CreateSoundStream_v1(pdssd, ppStream, NULL);
    }

    RELEASE(pDirectSound);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  DirectSoundDoWork
 *
 *  Description:
 *      Does some work.  Leave me alone.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundDoWork"

void
DirectSoundDoWork
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

#ifdef DEBUG

    //
    // Check for a deferred breakpoint
    //

    if(INTERLOCKED_EXCHANGE(g_fDirectSoundDebugBreak, FALSE))
    {
        DPF_ABSOLUTE("A breakpoint occurred at raised IRQL.  If you're running the Visual C debugger, you probably missed it.");
        BREAK();
    }

#endif // DEBUG

    //
    // Workie, workie
    //

    if(CDirectSound::m_pDirectSound)
    {
        CDirectSound::m_pDirectSound->DoWork();
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  DirectSoundGetSampleTime
 *
 *  Description:
 *      Gets the current sample clock time.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: sample time.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundGetSampleTime"

DWORD
DirectSoundGetSampleTime
(
    void
)
{
    DWORD                   dwSampleTime;
    
    DPF_ENTER();    

    //
    // MASSIVE HACK
    //
    // In order to keep latency and overhead to an absolute minimum, we're 
    // going to read the MCPX sample clock register from here.  This will 
    // prevent us from having to take the critical section or raise IRQL.
    //

    MCPX_REG_READ(NV_PAPU_XGSCNT, &dwSampleTime);

    DPF_LEAVE(dwSampleTime);

    return dwSampleTime;
}


#ifndef MCPX_BOOT_LIB

/****************************************************************************
 *
 *  DirectSoundUseFullHRTF
 *
 *  Description:
 *      Sets up the HRTF 3D filter loader to use the full HRTF table.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundUseFullHRTF"

void
DirectSoundUseFullHRTF
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    CHrtfSource::SetFullHrtfQuality();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  DirectSoundUseLightHRTF
 *
 *  Description:
 *      Sets up the HRTF 3D filter loader to use the light HRTF table.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundUseLightHRTF"

void
DirectSoundUseLightHRTF
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    CHrtfSource::SetLightHrtfQuality();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  DirectSoundOverrideSpeakerConfig
 *
 *  Description:
 *      Allows a game to override the default speaker configuration.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundOverrideSpeakerConfig"

void
DirectSoundOverrideSpeakerConfig
(
    DWORD                   dwSpeakerConfig
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifdef VALIDATE_PARAMETERS

    if(!DSSPEAKER_IS_VALID(dwSpeakerConfig))
    {
        DPF_ERROR("Invalid speaker configuration");
    }

    if(!DSSPEAKER_IS_VALID_BASIC(dwSpeakerConfig))
    {
        DPF_ERROR("Can't set encoder bits in the speaker config");
    }

    if(CDirectSound::m_pDirectSound)
    {
        DPF_ERROR("Can't call " DPF_FNAME " after the DirectSound object has been created");
    }

#endif // VALIDATE_PARAMETERS

    g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_BASIC(dwSpeakerConfig);

    DPF_LEAVE_VOID();
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  XAudioCalculatePitch
 *
 *  Description:
 *      Converts frequency to an MCPX pitch value.
 *
 *  Arguments:
 *      DWORD [in]: frequency, in Hz.
 *
 *  Returns:  
 *      LONG: pitch.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "XAudioCalculatePitch"

LONG
XAudioCalculatePitch
(
    DWORD                   dwFrequency
)
{
    LONG                    lPitch;
   
    DPF_ENTER();
    AutoFpState();

#ifdef VALIDATE_PARAMETERS

    if((dwFrequency < DSBFREQUENCY_MIN) || (dwFrequency > DSBFREQUENCY_MAX))
    {
        DPF_ERROR("Invalid frequency value");
    }

#endif // VALIDATE_PARAMETERS

    if(MCPX_BASEFREQ == dwFrequency)
    {
        lPitch = 0;
    }
    else
    {
        lPitch = RatioToPitch((FLOAT)dwFrequency * MCPX_ONEOVERBASEFREQ);
    }

    DPF_LEAVE(lPitch);

    return lPitch;
}


/****************************************************************************
 *
 *  XAudioDownloadEffectsImage
 *
 *  Description:
 *      Downloads an effects image to the DSP.
 *
 *  Arguments:
 *      LPCSTR [in]: file or section name.
 *      LPCDSEFFECTIMAGELOC [in]: effect locations.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "XAudioDownloadEffectsImage"

STDAPI
XAudioDownloadEffectsImage
(
    LPCSTR                  pszImageName,
    LPCDSEFFECTIMAGELOC     pEffectLoc,
    DWORD                   dwFlags,
    LPDSEFFECTIMAGEDESC *   ppImageDesc
)
{
    HANDLE                  hImageFile      = NULL;
    LPVOID                  pvImageData     = NULL;
    HRESULT                 hr              = DS_OK;
    DWORD                   dwImageSize;

    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifdef VALIDATE_PARAMETERS

    if(!pszImageName)
    {
        DPF_ERROR("No image name supplied");
    }

    if(dwFlags & ~XAUDIO_DOWNLOADFX_VALID)
    {
        DPF_ERROR("Invalid flags");
    }

#endif // VALIDATE_PARAMETERS

    if(!CDirectSound::m_pDirectSound)
    {
        DPF_ERROR("The DirectSound object must have already been created before calling " DPF_FNAME);
        hr = DSERR_INVALIDCALL;
    }

    //
    // Open the image
    //

    if(SUCCEEDED(hr))
    {
        if(dwFlags & XAUDIO_DOWNLOADFX_XBESECTION)
        {
            if(INVALID_HANDLE_VALUE == (hImageFile = XGetSectionHandle(pszImageName)))
            {
                DPF_ERROR("Can't find image section");
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            if(SUCCEEDED(hr))
            {
                if(!(dwImageSize = XGetSectionSize(hImageFile)))
                {
                    DPF_ERROR("Can't get image size");
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            if(SUCCEEDED(hr))
            {
                if(!(pvImageData = XLoadSectionByHandle(hImageFile)))
                {
                    DPF_ERROR("Can't read image section");
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
        else
        {
            if(INVALID_HANDLE_VALUE == (hImageFile = CreateFile(pszImageName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)))
            {
                DPF_ERROR("Can't find image file");
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            if(SUCCEEDED(hr))
            {
                if(!(dwImageSize = GetFileSize(hImageFile, NULL)))
                {
                    DPF_ERROR("Can't get image size");
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            if(SUCCEEDED(hr))
            {
                hr = HRFROMP(pvImageData = MEMALLOC_NOINIT(BYTE, dwImageSize));
            }

            if(SUCCEEDED(hr))
            {
                if(!ReadFile(hImageFile, pvImageData, dwImageSize, &dwImageSize, NULL))
                {
                    DPF_ERROR("Can't read image file");
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }

    //
    // Download the image
    //
    
    if(SUCCEEDED(hr))
    {
        hr = CDirectSound::m_pDirectSound->DownloadEffectsImage(pvImageData, dwImageSize, pEffectLoc, ppImageDesc);
    }

    //
    // Clean up
    //

    if(dwFlags & XAUDIO_DOWNLOADFX_XBESECTION)
    {
        if(IS_VALID_HANDLE_VALUE(hImageFile))
        {
            XFreeSectionByHandle(hImageFile);
        }
    }
    else
    {
        MEMFREE(pvImageData);
        CLOSE_HANDLE(hImageFile);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB

/****************************************************************************
 *
 *  CDirectSoundSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSettings::CDirectSoundSettings"

CDirectSoundSettings::CDirectSoundSettings
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();

#ifndef MCPX_BOOT_LIB

    m_3dParams = DirectSoundDefault3DListener;
    m_I3dl2Params = DirectSoundI3DL2ListenerPreset_Default;

#endif // MCPX_BOOT_LIB

    //
    // Read the speaker configuration from the EEPROM
    //

#ifndef MCPX_BOOT_LIB

    if(DSSPEAKER_IS_VALID(g_dwDirectSoundOverrideSpeakerConfig))
    {
        m_dwSpeakerConfig = g_dwDirectSoundOverrideSpeakerConfig;
    }
    else
    {
        m_dwSpeakerConfig = XAudioGetSpeakerConfig();
    }

#else // MCPX_BOOT_LIB

    m_dwSpeakerConfig = DSSPEAKER_STEREO;

#endif // MCPX_BOOT_LIB

    //
    // Set default mixbin headroom
    //

    for(i = 0; i < DSMIXBIN_SUBMIX; i++)
    {
        m_adwMixBinHeadroom[i] = DSHEADROOM_DEFAULT;
    }

    m_adwMixBinHeadroom[DSMIXBIN_SUBMIX] = 0;

    //
    // Set default effect locations
    //

    SetEffectImageLocations(NULL);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSettings::~CDirectSoundSettings"

CDirectSoundSettings::~CDirectSoundSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetEffectImageLocations
 *
 *  Description:
 *      Sets effect indeces.
 *
 *  Arguments:
 *      LPCDSEFFECTIMAGELOC [in]: effect locations.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSettings::SetEffectImageLocations"

void
CDirectSoundSettings::SetEffectImageLocations
(
    LPCDSEFFECTIMAGELOC     pImageLoc
)
{
    DPF_ENTER();

    if(pImageLoc)
    {
        CopyMemory(&m_EffectLocations, pImageLoc, sizeof(*pImageLoc));
    }
    else
    {
        memset(&m_EffectLocations, 0xFF, sizeof(m_EffectLocations));
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CDirectSound
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CDirectSound"

CDirectSound *CDirectSound::m_pDirectSound;

CDirectSound::CDirectSound
(
    void
)

#ifdef USE_KEEPALIVE_BUFFERS

:   CRefCount(2)

#endif // USE_KEEPALIVE_BUFFER

{
    DPF_ENTER();

    //
    // Set the global DirectSound object pointer
    //

    m_pDirectSound = this;

    //
    // Initialize defaults
    //

    InitializeListHead(&m_lst3dVoices);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSound
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::~CDirectSound"

CDirectSound::~CDirectSound
(
    void
)
{
    DPF_ENTER();

    //
    // Release performance counters
    //

    CDirectSoundPerformanceMonitor::UnregisterCounters();

    //
    // Release the global DirectSound object pointer
    //

    m_pDirectSound = NULL;

    //
    // Free owned objects
    //

    RELEASE(m_pDevice);
    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: reference count.
 *
 ****************************************************************************/

#ifdef USE_KEEPALIVE_BUFFERS

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::Release"

DWORD
CDirectSound::Release
(
    void
)
{
    DWORD                   dwRefCount;
    DWORD                   i;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if((dwRefCount = CRefCount::Release()) == NUMELMS(m_apKeepAliveBuffers) + 1)
    {
        //
        // The only references we have left are the keepalive buffers and the
        // artificial one we added at creation.  Go ahead and shut down.
        //

        for(i = 0; i < NUMELMS(m_apKeepAliveBuffers); i++)
        {
            ASSERT(m_apKeepAliveBuffers[i]);
            RELEASE(m_apKeepAliveBuffers[i]);
        }

        dwRefCount = CRefCount::Release();
        ASSERT(!dwRefCount);
    }

    DPF_LEAVE(dwRefCount);

    return dwRefCount;
}

#endif // USE_KEEPALIVE_BUFFERS


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::Initialize"

HRESULT
CDirectSound::Initialize
(
    void
)
{

#ifdef USE_KEEPALIVE_BUFFERS

    static const WAVEFORMATEX   wfxSilence              = INIT_PCM_WAVEFORMAT(1, 48000, 16);
    static const SHORT          asSilence[32]           = { 0 };
    DSBUFFERDESC                dsbd;
    DSMIXBINVOLUMEPAIR          MixBinVolumePairs[8];
    DSMIXBINS                   MixBins;
    DWORD                       i, z;

#endif // USE_KEEPALIVE_BUFFERS

    HRESULT                     hr;

    DPF_ENTER();

    //
    // Create the shared settings object
    //

    hr = HRFROMP(m_pSettings = NEW(CDirectSoundSettings));

    //
    // Create the device object
    //

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pDevice = NEW(CMcpxAPU(m_pSettings)));
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDevice->Initialize();
    }

#ifdef USE_KEEPALIVE_BUFFERS

    //
    // Create dummy buffers.  The MCPX refuses to output any data at least 
    // one voice writes to the speaker mixbins.  We'll burn voices in order 
    // to write silence to all the mixbins all the time.
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));
        ZeroMemory(&MixBinVolumePairs, sizeof(MixBinVolumePairs));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = (LPWAVEFORMATEX)&wfxSilence;
        dsbd.lpMixBins = &MixBins;

        MixBins.dwMixBinCount = NUMELMS(MixBinVolumePairs);
        MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

        for(i = 0; SUCCEEDED(hr) && (i < NUMELMS(m_apKeepAliveBuffers)); i++)
        {
            for(z = 0; z < NUMELMS(MixBinVolumePairs); z++)
            {
                MixBinVolumePairs[z].dwMixBin = (i * NUMELMS(MixBinVolumePairs)) + z;
            }

            if(DSMIXBIN_SUBMIX == MixBinVolumePairs[NUMELMS(MixBinVolumePairs) - 1].dwMixBin)
            {
                MixBins.dwMixBinCount--;
            }

            hr = CreateSoundBuffer(&dsbd, &m_apKeepAliveBuffers[i], NULL);

            if(SUCCEEDED(hr))
            {
                hr = m_apKeepAliveBuffers[i]->SetBufferData((LPVOID)asSilence, sizeof(asSilence));
            }

            if(SUCCEEDED(hr))
            {
                hr = m_apKeepAliveBuffers[i]->Play(0, 0, DSBPLAY_LOOPING);
            }
        }
    }

#endif // USE_KEEPALIVE_BUFFERS

    //
    // Set up performance counters
    //

    if(SUCCEEDED(hr))
    {
        CDirectSoundPerformanceMonitor::RegisterCounters();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets the capabilities of the object.
 *
 *  Arguments:
 *      LPDSCAPS [in/out]: capabilities.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetCaps"

HRESULT
CDirectSound::GetCaps
(
    LPDSCAPS                pdsc
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdsc)
    {
        DPF_ERROR("DSCAPS not supplied");
    }

#endif // VALIDATE_PARAMETERS
    
    hr = m_pDevice->GetCaps(&pdsc->dwFree2DBuffers, &pdsc->dwFree3DBuffers, &pdsc->dwFreeBufferSGEs);

    if(SUCCEEDED(hr))
    {
        pdsc->dwMemoryAllocated = g_dwDirectSoundPoolMemoryUsage + g_dwDirectSoundPhysicalMemoryUsage;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CreateSoundBuffer
 *
 *  Description:
 *      Creates a sound buffer object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.  The caller is expected
 *                                   to free this object with Release.
 *      LPUNKNOWN [in]: controlling unknown.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundBuffer"

HRESULT
CDirectSound::CreateSoundBuffer
(
    LPCDSBUFFERDESC         pdsbd,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPUNKNOWN               pControllingUnknown
)
{
    CDirectSoundBuffer *    pBuffer;
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!ppBuffer)
    {
        DPF_ERROR("Failed to supply an LPDIRECTSOUNDBUFFER *");
    }
    
    if(pControllingUnknown)
    {
        DPF_ERROR("Aggregation is not supported");
    }

#endif // VALIDATE_PARAMETERS

    hr = HRFROMP(pBuffer = NEW(CDirectSoundBuffer(this)));

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pdsbd);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CreateSoundBuffer_v1
 *
 *  Description:
 *      Creates a sound buffer object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.  The caller is expected
 *                                   to free this object with Release.
 *      LPUNKNOWN [in]: controlling unknown.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundBuffer_v1"

HRESULT
CDirectSound::CreateSoundBuffer_v1
(
    LPCDSBUFFERDESC1        pdsbd,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPUNKNOWN               pControllingUnknown
)
{
    DSMIXBINS               MixBins;
    DSMIXBINVOLUMEPAIR      MixBinVolumePairs[DSMIXBIN_ASSIGNMENT_MAX];
    DSBUFFERDESC            dsbd;
    DWORD                   dwMixBinMask;
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = pdsbd->dwFlags;
    dsbd.dwBufferBytes = pdsbd->dwBufferBytes;
    dsbd.lpwfxFormat = pdsbd->lpwfxFormat;
    
    if(dwMixBinMask = pdsbd->dwMixBinMask)
    {
        dsbd.lpMixBins = &MixBins;
        
        MixBins.dwMixBinCount = 0;
        MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

        while(dwMixBinMask)
        {
            if(MixBins.dwMixBinCount >= NUMELMS(MixBinVolumePairs))
            {
                DPF_ERROR("Too many mixbins in the mask");
                break;
            }
            
            MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin = lsb(dwMixBinMask);
            MixBinVolumePairs[MixBins.dwMixBinCount].lVolume = 0;

            dwMixBinMask &= ~(1UL << MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin);

            MixBins.dwMixBinCount++;
        }
    }
    else
    {
        dsbd.lpMixBins = NULL;
    }

    if(pdsbd->dwInputMixBinMask)
    {
        dsbd.dwInputMixBin = lsb(pdsbd->dwInputMixBinMask);
    }
    else
    {
        dsbd.dwInputMixBin = 0;
    }

    hr = CreateSoundBuffer(&dsbd, ppBuffer, pControllingUnknown);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CreateSoundStream
 *
 *  Description:
 *      Creates a sound buffer object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: buffer description.
 *      LPDIRECTSOUNDSTREAM * [out]: buffer object.  The caller is expected
 *                                   to free this object with Release.
 *      LPUNKNOWN [in]: controlling unknown.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundStream"

HRESULT
CDirectSound::CreateSoundStream
(
    LPCDSSTREAMDESC         pdssd,
    LPDIRECTSOUNDSTREAM *   ppStream,
    LPUNKNOWN               pControllingUnknown
)
{
    CDirectSoundStream *    pStream;
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!ppStream)
    {
        DPF_ERROR("Failed to supply an LPDIRECTSOUNDSTREAM *");
    }
    
    if(pControllingUnknown)
    {
        DPF_ERROR("Aggregation is not supported");
    }

#endif // VALIDATE_PARAMETERS

    hr = HRFROMP(pStream = NEW(CDirectSoundStream(this)));

    if(SUCCEEDED(hr))
    {
        hr = pStream->Initialize(pdssd);
    }

    if(SUCCEEDED(hr))
    {
        *ppStream = pStream;
    }
    else
    {
        RELEASE(pStream);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  CreateSoundStream_v1
 *
 *  Description:
 *      Creates a sound buffer object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: buffer description.
 *      LPDIRECTSOUNDSTREAM * [out]: buffer object.  The caller is expected
 *                                   to free this object with Release.
 *      LPUNKNOWN [in]: controlling unknown.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundStream_v1"

HRESULT
CDirectSound::CreateSoundStream_v1
(
    LPCDSSTREAMDESC1        pdssd,
    LPDIRECTSOUNDSTREAM *   ppStream,
    LPUNKNOWN               pControllingUnknown
)
{
    DSMIXBINS               MixBins;
    DSMIXBINVOLUMEPAIR      MixBinVolumePairs[DSMIXBIN_ASSIGNMENT_MAX];
    DSSTREAMDESC            dssd;
    DWORD                   dwMixBinMask;
    HRESULT                 hr;
    DWORD                   i;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    dssd.dwFlags = pdssd->dwFlags;
    dssd.dwMaxAttachedPackets = pdssd->dwMaxAttachedPackets;
    dssd.lpwfxFormat = pdssd->lpwfxFormat;
    dssd.lpfnCallback = pdssd->lpfnCallback;
    dssd.lpvContext = pdssd->lpvContext;

    if(dwMixBinMask = pdssd->dwMixBinMask)
    {
        dssd.lpMixBins = &MixBins;
        
        MixBins.dwMixBinCount = 0;
        MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

        while(dwMixBinMask)
        {
            if(MixBins.dwMixBinCount >= NUMELMS(MixBinVolumePairs))
            {
                DPF_ERROR("Too many mixbins in the mask");
                break;
            }

            MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin = lsb(dwMixBinMask);
            MixBinVolumePairs[MixBins.dwMixBinCount].lVolume = 0;

            dwMixBinMask &= ~(1UL << MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin);

            MixBins.dwMixBinCount++;
        }
    }
    else
    {
        dssd.lpMixBins = NULL;
    }

    hr = CreateSoundStream(&dssd, ppStream, pControllingUnknown);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  GetSpeakerConfig
 *
 *  Description:
 *      Gets the current speaker config.
 *
 *  Arguments:
 *      LPDWORD [out]: speaker config.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetSpeakerConfig"

HRESULT
CDirectSound::GetSpeakerConfig
(
    LPDWORD                 pdwSpeakerConfig
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pdwSpeakerConfig)
    {
        DPF_ERROR("Failed to supply speaker config buffer");
    }

#endif // VALIDATE_PARAMETERS

    *pdwSpeakerConfig = m_pSettings->m_dwSpeakerConfig & ~DSSPEAKER_ENABLE_HEADPHONES;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  DownloadEffectsImage
 *
 *  Description:
 *      Downloads an effects image to the effects processor.
 *
 *  Arguments:
 *      LPCVOID [in]: image data.
 *      DWORD [in]: image data size, in bytes.
 *      LPCDSEFFECTIMAGELOC [in]: effect locations.
 *      LPVOID * [out]: image scratch data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::DownloadEffectsImage"

HRESULT
CDirectSound::DownloadEffectsImage
(
    LPCVOID                 pvImageBuffer, 
    DWORD                   dwImageSize,
    LPCDSEFFECTIMAGELOC     pImageLoc, 
    LPDSEFFECTIMAGEDESC *   ppImageDesc
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pvImageBuffer)
    {
        DPF_ERROR("Failed to supply an image buffer");
    }

    if(dwImageSize <= (DSP_COMMANDBLOCK_SCRATCHOFFSET + sizeof(HOST_TO_DSP_COMMANDBLOCK)))
    {
        DPF_ERROR("Invalid image size");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Save the effect locations
    //

    m_pSettings->SetEffectImageLocations(pImageLoc);

    //
    // Download the image
    //

    hr = m_pDevice->DownloadEffectsImage(pvImageBuffer, dwImageSize, ppImageDesc);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  SetEffectData
 *
 *  Description:
 *      Updates part or all of an effect's data.
 *
 *  Arguments:
 *      DWORD [in]: absolute effect index.
 *      DWORD [in]: offset, in bytes, of the start of the update region.
 *      LPCVOID [in]: data buffer.
 *      DWORD [in]: data buffer size, in bytes.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetEffectData"

HRESULT
CDirectSound::SetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPCVOID                 pvData, 
    DWORD                   dwDataSize,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwOffset & 3)
    {
        DPF_ERROR("Offset must be DWORD-aligned");
    }

    if(!pvData)
    {
        DPF_ERROR("Failed to supply a data buffer");
    }

    if(!dwDataSize)
    {
        DPF_ERROR("Invalid data size");
    }

    if(dwDataSize & 3)
    {
        DPF_ERROR("Data size must be DWORD-aligned");
    }

    if(dwFlags & ~DSFX_VALID)
    {
        DPF_ERROR("Invalid flags");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pDevice->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetEffectData
 *
 *  Description:
 *      Retrieves part or all of an effect's data.
 *
 *  Arguments:
 *      DWORD [in]: absolute effect index.
 *      DWORD [in]: offset, in bytes, of the start of the update region.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetEffectData"

HRESULT
CDirectSound::GetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwOffset & 3)
    {
        DPF_ERROR("Offset must be DWORD-aligned");
    }

    if(!pvData)
    {
        DPF_ERROR("Failed to supply a data buffer");
    }

    if(!dwDataSize)
    {
        DPF_ERROR("Invalid data size");
    }

    if(dwDataSize & 3)
    {
        DPF_ERROR("Data size must be DWORD-aligned");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pDevice->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitEffectData
 *
 *  Description:
 *      Commits deferred effects settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CommitEffectData"

HRESULT 
CDirectSound::CommitEffectData
(
    void
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    hr = m_pDevice->CommitEffectData();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBinHeadroom
 *
 *  Description:
 *      Sets the headroom for a mixbin.
 *
 *  Arguments:
 *      DWORD [in]: mixbin identifier.
 *      DWORD [in]: headroom amount.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetMixBinHeadroom"

HRESULT
CDirectSound::SetMixBinHeadroom
(
    DWORD                   dwMixBin,
    DWORD                   dwHeadroom
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwMixBin >= DSMIXBIN_COUNT)
    {
        DPF_ERROR("Invalid mixbin");
    }

    if((dwHeadroom < DSHEADROOM_MIN) || (dwHeadroom > DSHEADROOM_MAX))
    {
        DPF_ERROR("Invalid headroom value");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the settings object
    //

    m_pSettings->m_adwMixBinHeadroom[dwMixBin] = dwHeadroom;
    
    //
    // Update the implementation object
    //

    hr = m_pDevice->SetMixBinHeadroom(dwMixBin);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBinHeadroom_v1
 *
 *  Description:
 *      Sets the headroom for one or more mixbins.
 *
 *  Arguments:
 *      DWORD [in]: mixbin mask.
 *      DWORD [in]: headroom amount.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetMixBinHeadroom_v1"

HRESULT
CDirectSound::SetMixBinHeadroom_v1
(
    DWORD                   dwMixBinMask,
    DWORD                   dwHeadroom
)
{
    HRESULT                 hr          = DS_OK;
    DWORD                   dwMixBin;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    while(dwMixBinMask && SUCCEEDED(hr))
    {
        dwMixBin = lsb(dwMixBinMask);
        dwMixBinMask &= ~(1UL << dwMixBin);

        hr = SetMixBinHeadroom(dwMixBin, dwHeadroom);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [in]: properties.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetAllParameters"

HRESULT 
CDirectSound::SetAllParameters
(
    LPCDS3DLISTENER         pParams, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pParams)
    {
        DPF_ERROR("Buffer not supplied");
    }

    if(pParams->dwSize < sizeof(*pParams))
    {
        DPF_ERROR("Structure size too small");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if((pParams->flDistanceFactor < DS3D_MINDISTANCEFACTOR) || (pParams->flDistanceFactor > DS3D_MAXDISTANCEFACTOR))
    {
        DPF_ERROR("Distance factor out of bounds");
    }

    if((pParams->flDopplerFactor < DS3D_MINDOPPLERFACTOR) || (pParams->flDopplerFactor > DS3D_MAXDOPPLERFACTOR))
    {
        DPF_ERROR("Doppler factor out of bounds");
    }

    if((pParams->flRolloffFactor < DS3D_MINROLLOFFFACTOR) || (pParams->flRolloffFactor > DS3D_MAXROLLOFFFACTOR))
    {
        DPF_ERROR("Rolloff factor out of bounds");
    }

    if((!pParams->vOrientFront.x && !pParams->vOrientFront.y && !pParams->vOrientFront.z) || (!pParams->vOrientTop.x && !pParams->vOrientTop.y && !pParams->vOrientTop.z))
    {
        DPF_ERROR("Invalid orientation");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams = *pParams;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_LISTENER_MASK;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets the world's distance factor.
 *
 *  Arguments:
 *      FLOAT [in]: distance factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDistanceFactor"

HRESULT 
CDirectSound::SetDistanceFactor
(
    FLOAT                   flDistanceFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((flDistanceFactor < DS3D_MINDISTANCEFACTOR) || (flDistanceFactor > DS3D_MAXDISTANCEFACTOR))
    {
        DPF_ERROR("Distance factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.flDistanceFactor = flDistanceFactor;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_LISTENER_DISTANCEFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets the world's Doppler factor.
 *
 *  Arguments:
 *      FLOAT [in]: Doppler factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDopplerFactor"

HRESULT 
CDirectSound::SetDopplerFactor
(
    FLOAT                   flDopplerFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((flDopplerFactor < DS3D_MINDOPPLERFACTOR) || (flDopplerFactor > DS3D_MAXDOPPLERFACTOR))
    {
        DPF_ERROR("Doppler factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.flDopplerFactor = flDopplerFactor;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_LISTENER_DOPPLERFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets the world's rolloff factor.
 *
 *  Arguments:
 *      FLOAT [in]: rolloff factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetRolloffFactor"

HRESULT 
CDirectSound::SetRolloffFactor
(
    FLOAT                   flRolloffFactor, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((flRolloffFactor < DS3D_MINROLLOFFFACTOR) || (flRolloffFactor > DS3D_MAXROLLOFFFACTOR))
    {
        DPF_ERROR("Rolloff factor out of bounds");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.flRolloffFactor = flRolloffFactor;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_LISTENER_ROLLOFFFACTOR;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetOrientation
 *
 *  Description:
 *      Sets the listener's orientation.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: front orientation.
 *      REFD3DXVECTOR3 [in]: top orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetOrientation"

HRESULT 
CDirectSound::SetOrientation
(
    FLOAT                   flFrontX, 
    FLOAT                   flFrontY, 
    FLOAT                   flFrontZ, 
    FLOAT                   flTopX, 
    FLOAT                   flTopY, 
    FLOAT                   flTopZ, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if((!flFrontX && !flFrontY && !flFrontZ) || (!flTopX && !flTopY && !flTopZ))
    {
        DPF_ERROR("Invalid orientation");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.vOrientFront.x = flFrontX;
    m_pSettings->m_3dParams.vOrientFront.y = flFrontY;
    m_pSettings->m_3dParams.vOrientFront.z = flFrontZ;
    m_pSettings->m_3dParams.vOrientTop.x = flTopX;
    m_pSettings->m_3dParams.vOrientTop.y = flTopY;
    m_pSettings->m_3dParams.vOrientTop.z = flTopZ;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_LISTENER_ORIENTATION;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the listener's position.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetPosition"

HRESULT 
CDirectSound::SetPosition
(
    FLOAT                   flPositionX,
    FLOAT                   flPositionY,
    FLOAT                   flPositionZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.vPosition.x = flPositionX;
    m_pSettings->m_3dParams.vPosition.y = flPositionY;
    m_pSettings->m_3dParams.vPosition.z = flPositionZ;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_LISTENER_POSITION;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the listener's velocity.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetVelocity"

HRESULT 
CDirectSound::SetVelocity
(
    FLOAT                   flVelocityX,
    FLOAT                   flVelocityY,
    FLOAT                   flVelocityZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.vVelocity.x = flVelocityX;
    m_pSettings->m_3dParams.vVelocity.y = flVelocityY;
    m_pSettings->m_3dParams.vVelocity.z = flVelocityZ;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_LISTENER_VELOCITY;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetI3DL2Listener
 *
 *  Description:
 *      Sets I3DL2 listener properties.
 *
 *  Arguments:
 *      LPCDSI3DL2LISTENER [in]: listener properties.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetI3DL2Listener"

HRESULT
CDirectSound::SetI3DL2Listener
(
    LPCDSI3DL2LISTENER      pProperties,
    DWORD                   dwFlags
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();    
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pProperties)
    {
        DPF_ERROR("Failed to supply properties");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if((pProperties->lRoom < DSI3DL2LISTENER_MINROOM) || (pProperties->lRoom > DSI3DL2LISTENER_MAXROOM))
    {
        DPF_ERROR("Invalid lRoom value");
    }

    if((pProperties->lRoomHF < DSI3DL2LISTENER_MINROOMHF) || (pProperties->lRoomHF > DSI3DL2LISTENER_MAXROOMHF))
    {
        DPF_ERROR("Invalid lRoomHF value");
    }

    if((pProperties->flRoomRolloffFactor < DSI3DL2LISTENER_MINROOMROLLOFFFACTOR) || (pProperties->flRoomRolloffFactor > DSI3DL2LISTENER_MAXROOMROLLOFFFACTOR))
    {
        DPF_ERROR("Invalid flRoomRolloffFactor value");
    }

    if((pProperties->flDecayTime < DSI3DL2LISTENER_MINDECAYTIME) || (pProperties->flDecayTime > DSI3DL2LISTENER_MAXDECAYTIME))
    {
        DPF_ERROR("Invalid flDecayTime value");
    }

    if((pProperties->flDecayHFRatio < DSI3DL2LISTENER_MINDECAYHFRATIO) || (pProperties->flDecayHFRatio > DSI3DL2LISTENER_MAXDECAYHFRATIO))
    {
        DPF_ERROR("Invalid flDecayHFRatio value");
    }

    if((pProperties->lReflections < DSI3DL2LISTENER_MINREFLECTIONS) || (pProperties->lReflections > DSI3DL2LISTENER_MAXREFLECTIONS))
    {
        DPF_ERROR("Invalid lReflections value");
    }

    if((pProperties->flReflectionsDelay < DSI3DL2LISTENER_MINREFLECTIONSDELAY) || (pProperties->flReflectionsDelay > DSI3DL2LISTENER_MAXREFLECTIONSDELAY))
    {
        DPF_ERROR("Invalid flReflectionsDelay value");
    }

    if((pProperties->lReverb < DSI3DL2LISTENER_MINREVERB) || (pProperties->lReverb > DSI3DL2LISTENER_MAXREVERB))
    {
        DPF_ERROR("Invalid lReverb value");
    }

    if((pProperties->flReverbDelay < DSI3DL2LISTENER_MINREVERBDELAY) || (pProperties->flReverbDelay > DSI3DL2LISTENER_MAXREVERBDELAY))
    {
        DPF_ERROR("Invalid flReverbDelay value");
    }

    if((pProperties->flDiffusion < DSI3DL2LISTENER_MINDIFFUSION) || (pProperties->flDiffusion > DSI3DL2LISTENER_MAXDIFFUSION))
    {
        DPF_ERROR("Invalid flDiffusion value");
    }

    if((pProperties->flDensity < DSI3DL2LISTENER_MINDENSITY) || (pProperties->flDensity > DSI3DL2LISTENER_MAXDENSITY))
    {
        DPF_ERROR("Invalid flDensity value");
    }

    if((pProperties->flHFReference < DSI3DL2LISTENER_MINHFREFERENCE) || (pProperties->flHFReference > DSI3DL2LISTENER_MAXHFREFERENCE))
    {
        DPF_ERROR("Invalid flHFReference value");
    }

#endif // VALIDATE_PARAMETERS

    if(DSFX_IMAGELOC_UNUSED == m_pSettings->m_EffectLocations.dwI3DL2ReverbIndex)
    {
        DPF_ERROR("Can't set I3DL2 listener properties without loading the I3DL2 reverb effect");
        hr = DSERR_INVALIDCALL;
    }

    if(SUCCEEDED(hr))
    {
        m_pSettings->m_I3dl2Params = *pProperties;
        m_pSettings->m_dw3dParameterMask |= DS3DPARAM_LISTENER_I3DL2;

        if(!(dwFlags & DS3D_DEFERRED))
        {
            CommitDeferredSettings();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitDeferredSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CommitDeferredSettings"

HRESULT 
CDirectSound::CommitDeferredSettings
(
    void
)
{
    PLIST_ENTRY             pleEntry;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    //
    // Recalculate changed 3D listener parameters
    //

    m_pDevice->Commit3dSettings();

    //
    // Recalculate all 3D voices
    //

    for(pleEntry = m_lst3dVoices.Flink; pleEntry != &m_lst3dVoices; pleEntry = pleEntry->Flink)
    {
        CONTAINING_RECORD(pleEntry, CDirectSoundVoice, m_le3dVoice)->CommitDeferredSettings();
    }

    //
    // Reset the 3D listener parameter mask
    //

    m_pSettings->m_dw3dParameterMask = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  GetTime
 *
 *  Description:
 *      Gets the current time.
 *
 *  Arguments:
 *      REFERENCE_TIME * [out]: current time.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetTime"

HRESULT
CDirectSound::GetTime
(
    REFERENCE_TIME *        prtCurrent
)
{
    DPF_ENTER();    

#ifdef VALIDATE_PARAMETERS

    if(!prtCurrent)
    {
        DPF_ERROR("Failed to specify a time buffer");
    }

#endif // VALIDATE_PARAMETERS

    KeQuerySystemTime((PLARGE_INTEGER)prtCurrent);

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  DoWork
 *
 *  Description:
 *      Uh... does some work?
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::DoWork"

void
CDirectSound::DoWork
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD_VOID();

    m_pDevice->DoWork();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  EnableHeadphones
 *
 *  Description:
 *      Enables or disables headphone support.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::EnableHeadphones"

HRESULT
CDirectSound::EnableHeadphones
(
    BOOL                    fEnable
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if(MAKEBOOL(m_pSettings->m_dwSpeakerConfig & DSSPEAKER_ENABLE_HEADPHONES) != MAKEBOOL(fEnable))
    {
        //
        // Set the headphone bit in the speaker config
        //

        if(fEnable)
        {
            m_pSettings->m_dwSpeakerConfig |= DSSPEAKER_ENABLE_HEADPHONES;
        }
        else
        {
            m_pSettings->m_dwSpeakerConfig &= ~DSSPEAKER_ENABLE_HEADPHONES;
        }

        //
        // Update the APU
        //

        hr = m_pDevice->SetSpeakerConfig();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  CDirectSoundVoiceSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::CDirectSoundVoiceSettings"

CDirectSoundVoiceSettings::CDirectSoundVoiceSettings
(
    void
)
{
    DPF_ENTER();

#ifndef MCPX_BOOT_LIB

    m_3dParams = DirectSoundDefault3DBuffer;
    m_I3dl2Params = DirectSoundDefaultI3DL2Buffer;
    m_dw3dParameterMask = DS3DPARAM_BUFFER_MASK;

#endif // MCPX_BOOT_LIB

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundVoiceSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings"

CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings
(
    void
)
{
    DPF_ENTER();
    
    //
    // Release the output buffer
    //

    if(m_pMixinBuffer)
    {
        SetOutputBuffer(NULL);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: voice creation flags.
 *      LPCWAVEFORMATEX [in]: voice format.
 *      LPCDSMIXBINS [in]: mix bin assignments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::Initialize"

void
CDirectSoundVoiceSettings::Initialize
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    LPCDSMIXBINS            pMixBins
)
{
    BOOL                    fSetMixBins;

    DPF_ENTER();

    ASSERT(pwfxFormat);

    //
    // Save flags
    //
    
    m_dwFlags = dwFlags;

    //
    // Set default headroom
    //

    if(m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        m_dwHeadroom = DSBHEADROOM_DEFAULT_SUBMIX;
    }
    else if(m_dwFlags & DSBCAPS_CTRL3D)
    {
        m_dwHeadroom = DSBHEADROOM_DEFAULT_3D;
    }
    else
    {
        m_dwHeadroom = DSBHEADROOM_DEFAULT_2D;
    }

    //
    // Set format.  If mixbins were specified, we won't allow the format
    // to override them.
    //

    fSetMixBins = SetFormat(pwfxFormat, !pMixBins);

    //
    // If SetFormat didn't set the mixbins for us, we'll need to do it now
    //

    if(!fSetMixBins)
    {
        SetMixBins(pMixBins);
    }

    //
    // Set default volume
    //

    SetVolume(DSBVOLUME_MAX);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the voice format.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: voice format.
 *      BOOL [in]: TRUE to allow the format to define the mixbins.
 *
 *  Returns:  
 *      BOOL: TRUE if the voice format changed the mixbin assignments.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetFormat"

BOOL
CDirectSoundVoiceSettings::SetFormat
(
    LPCWAVEFORMATEX         pwfxFormat,
    BOOL                    fAllowMixBins
)
{
    BOOL                    fSetMixBins                                     = FALSE;
    DWORD                   dwChannelMask;
    DSMIXBINS               MixBins;
    DSMIXBINVOLUMEPAIR      MixBinVolumePairs[DSMIXBIN_ASSIGNMENT_MAX];
    
    DPF_ENTER();

    ASSERT(pwfxFormat);

    //
    // Save format.  If MixBins were specified by the format, we'll use those
    // assuming no mixbins were passed to us and the voice is 2D.
    //

    if(dwChannelMask = FmtCreateInternal(&m_fmt, pwfxFormat))
    {
        if(!(m_dwFlags & DSBCAPS_CTRL3D) && fAllowMixBins)
        {
            MixBins.dwMixBinCount = 0;
            MixBins.lpMixBinVolumePairs = MixBinVolumePairs;
            
            while(dwChannelMask && (MixBins.dwMixBinCount < NUMELMS(MixBinVolumePairs)))
            {
                MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin = lsb(dwChannelMask);
                MixBinVolumePairs[MixBins.dwMixBinCount].lVolume = 0;

                MixBins.dwMixBinCount++;

                dwChannelMask &= ~(1UL << MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin);
            }

            SetMixBins(&MixBins);

            fSetMixBins = TRUE;
        }
    }

    //
    // Set default pitch
    //

    m_lPitch = XAudioCalculatePitch(m_fmt.nSamplesPerSec);

    DPF_LEAVE(fSetMixBins);

    return fSetMixBins;
}


/****************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets voice volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetVolume"

void
CDirectSoundVoiceSettings::SetVolume
(
    LONG                    lVolume
)
{
    DPF_ENTER();

    //
    // Apply headroom
    //

    m_lVolume = lVolume - m_dwHeadroom;
    ASSERT(m_lVolume <= DSBVOLUME_MAX);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMixBinVolumes
 *
 *  Description:
 *      Sets the volume of some number of mixbins.
 *
 *  Arguments:
 *      LPCDSMIXBINS [in]: mixbin/volume pairs.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetMixBinVolumes"

void
CDirectSoundVoiceSettings::SetMixBinVolumes
(
    LPCDSMIXBINS            pMixBins
)
{
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(pMixBins);
    ASSERT(pMixBins->dwMixBinCount <= NUMELMS(m_alMixBinVolumes));

    for(i = 0; i < pMixBins->dwMixBinCount; i++)
    {
        ASSERT(pMixBins->lpMixBinVolumePairs[i].dwMixBin < NUMELMS(m_alMixBinVolumes));
        
        m_alMixBinVolumes[pMixBins->lpMixBinVolumePairs[i].dwMixBin] = pMixBins->lpMixBinVolumePairs[i].lVolume;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetHeadroom
 *
 *  Description:
 *      Sets voice headroom.
 *
 *  Arguments:
 *      DWORD [in]: headroom.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetHeadroom"

void
CDirectSoundVoiceSettings::SetHeadroom
(
    DWORD                   dwHeadroom
)
{
    LONG                    lDiff;
    
    DPF_ENTER();

    //
    // Calculate the difference between the old headroom and the new one
    //

    lDiff = m_dwHeadroom - dwHeadroom;

    //
    // Save the new headroom
    //

    m_dwHeadroom = dwHeadroom;
    
    //
    // Update volume
    //

    m_lVolume += lDiff;
    ASSERT(m_lVolume <= DSBVOLUME_MAX);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMixBins
 *
 *  Description:
 *      Sets the mixbins used by the voice.
 *
 *  Arguments:
 *      LPCDSMIXBINS [in]: mixbin assignments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetMixBins"

void
CDirectSoundVoiceSettings::SetMixBins
(
    LPCDSMIXBINS            pMixBins
)
{
    DPF_ENTER();

    //
    // If no mixbins were supplied, use defaults
    //

    if(!pMixBins)
    {
        if(m_dwFlags & DSBCAPS_CTRL3D)
        {
            pMixBins = &DirectSoundDefaultMixBins_3D;
        }
        else
        {
            switch(m_fmt.nChannels)
            {
                case 1:
                    pMixBins = &DirectSoundDefaultMixBins_Mono;
                    break;

                case 2:
                    pMixBins = &DirectSoundDefaultMixBins_Stereo;
                    break;

                case 4:
                    pMixBins = &DirectSoundDefaultMixBins_4Channel;
                    break;

                case 6:
                    pMixBins = &DirectSoundDefaultMixBins_6Channel;
                    break;

                default:
                    ASSERTMSG("Unexpected channel count");
                    break;
            }
        }
    }

    //
    // Set mixbins and volume
    //

    ASSERT(pMixBins);
    ASSERT(pMixBins->dwMixBinCount <= NUMELMS(m_adwMixBins));
    
    for(m_dwMixBinCount = 0; m_dwMixBinCount < pMixBins->dwMixBinCount; m_dwMixBinCount++)
    {
        ASSERT(pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].dwMixBin < NUMELMS(m_alMixBinVolumes));
        
        m_adwMixBins[m_dwMixBinCount] = pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].dwMixBin;
        m_alMixBinVolumes[m_adwMixBins[m_dwMixBinCount]] = pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].lVolume;
    }

    //
    // If we're submixing, the submix bin must be included
    //

    if(m_pMixinBuffer)
    {
        ASSERT(m_pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK);
        ASSERT(m_dwMixBinCount < NUMELMS(m_adwMixBins) - 1);

        m_adwMixBins[m_dwMixBinCount++] = m_pMixinBuffer->m_pSettings->m_dwInputMixBin;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetOutputBuffer
 *
 *  Description:
 *      Assignes the output of this voice to another voice instead of the
 *      standard mixbins.
 *
 *  Arguments:
 *      CDirectSoundBuffer * [in]: mixin buffer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoiceSettings::SetOutputBuffer"

void
CDirectSoundVoiceSettings::SetOutputBuffer
(
    CDirectSoundBuffer *    pOutputBuffer
)
{
    DWORD                   dwMixBin;
    
    DPF_ENTER();

    ASSERT(pOutputBuffer != m_pMixinBuffer);

    //
    // Release the old buffer and update the mixbins
    //

    if(m_pMixinBuffer)
    {
        dwMixBin = m_pMixinBuffer->m_pSettings->m_dwInputMixBin;

        ASSERT(m_dwMixBinCount);
        ASSERT(m_adwMixBins[m_dwMixBinCount - 1] == dwMixBin);

        m_dwMixBinCount--;

        RELEASE(m_pMixinBuffer);
    }

    //
    // Save a reference to the new buffer and update the mixbins
    //

    if(m_pMixinBuffer = ADDREF(pOutputBuffer))
    {
        dwMixBin = m_pMixinBuffer->m_pSettings->m_dwInputMixBin;

        ASSERT(m_pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK);
        ASSERT(m_dwMixBinCount < NUMELMS(m_adwMixBins) - 1);

        m_adwMixBins[m_dwMixBinCount++] = dwMixBin;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CDirectSoundVoice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: parent DirectSound object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::CDirectSoundVoice"

CDirectSoundVoice::CDirectSoundVoice
(
    CDirectSound *          pDirectSound
)
{
    DPF_ENTER();

    //
    // Initialize defaults
    //

    InitializeListHead(&m_le3dVoice);

    //
    // Save a reference to the DirectSound object
    //

    m_pDirectSound = ADDREF(pDirectSound);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundVoice
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::~CDirectSoundVoice"

CDirectSoundVoice::~CDirectSoundVoice
(
    void
)
{
    DPF_ENTER();

    //
    // Remove ourselves from the 3D list
    //

    RemoveEntryList(&m_le3dVoice);

    //
    // Release the reference to the DirectSound object
    //

    RELEASE(m_pDirectSound);

    //
    // Release the voice implementation object
    //

    RELEASE(m_pVoice);

    //
    // Release the shared settings object
    //

    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      CMcpxVoiceClient * [in]: voice implementation object.
 *      CDirectSoundVoiceSettings * [in]: shared settings object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::Initialize"

void
CDirectSoundVoice::Initialize
(
    CMcpxVoiceClient *          pVoice, 
    CDirectSoundVoiceSettings * pSettings
)
{
    DPF_ENTER();

    //
    // Just save a reference to each
    //

    m_pVoice = ADDREF(pVoice);
    m_pSettings = ADDREF(pSettings);

    //
    // If we're a 3D voice, add ourselves to the 3D voice list
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        InsertTailList(&m_pDirectSound->m_lst3dVoices, &m_le3dVoice);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the voice format.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: new format.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetFormat"

HRESULT 
CDirectSoundVoice::SetFormat
(
    LPCWAVEFORMATEX         pwfxFormat
)
{
    BOOL                    fSetMixBins;
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pwfxFormat)
    {
        DPF_ERROR("Failed to specify a buffer format");
    }

    if(!FmtIsValid(pwfxFormat))
    {
        DPF_ERROR("Invalid voice format");
    }

    if((m_pSettings->m_dwFlags & DSBCAPS_CTRL3D) && (1 != pwfxFormat->nChannels))
    {
        DPF_ERROR("3D voices must be mono");
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't SetFormat on MIXIN or FXIN buffers");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the settings object
    //

    fSetMixBins = m_pSettings->SetFormat(pwfxFormat, TRUE);

    //
    // Update the implementation object
    //

    hr = m_pVoice->SetFormat();

    //
    // In some cases, the mixbins are defined by the format structure
    //
    
    if(SUCCEEDED(hr) && fSetMixBins)
    {
        hr = m_pVoice->SetMixBins();
    }

    //
    // Make sure the pitch is updated as well
    //

    if(SUCCEEDED(hr))
    {
        m_pVoice->SetPitch();
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the buffer playback frequency.
 *
 *  Arguments:
 *      DWORD [in]: frequency in Hz.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetFrequency"

HRESULT 
CDirectSoundVoice::SetFrequency
(
    DWORD                   dwFrequency
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(dwFrequency)
    {
        if((dwFrequency < DSBFREQUENCY_MIN) || (dwFrequency > DSBFREQUENCY_MAX))
        {
            DPF_ERROR("Invalid frequency value");
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Convert frequency to pitch.  0 frequency means use the default.
    //

    if(!dwFrequency)
    {
        dwFrequency = m_pSettings->m_fmt.nSamplesPerSec;
    }

    hr = SetPitch(XAudioCalculatePitch(dwFrequency));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetPitch
 *
 *  Description:
 *      Sets the buffer pitch.
 *
 *  Arguments:
 *      LONG [in]: pitch, in octaves (s3.12).
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetPitch"

HRESULT 
CDirectSoundVoice::SetPitch
(
    LONG                    lPitch
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((lPitch < DSBPITCH_MIN) || (lPitch > DSBPITCH_MAX))
    {
        DPF_ERROR("Invalid pitch value");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the settings object
    //

    m_pSettings->m_lPitch = lPitch;

    //
    // Notify the implementation object of the change
    //

    hr = m_pVoice->SetPitch();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the buffer playback volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetVolume"

HRESULT
CDirectSoundVoice::SetVolume
(
    LONG                    lVolume
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((lVolume < DSBVOLUME_MIN) || (lVolume > DSBVOLUME_MAX))
    {
        DPF_ERROR("Volume value out-of-bounds");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Save the volume to the settings
    //

    m_pSettings->SetVolume(lVolume);
    
    //
    // Notify the implementation object
    //

    hr = m_pVoice->SetVolume();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetLFO
 *
 *  Description:
 *      Sets parameters for one of the low-frequency occilator.
 *
 *  Arguments:
 *      LPCDSLFODESC [in]: common LFO settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetLFO"

HRESULT
CDirectSoundVoice::SetLFO
(
    LPCDSLFODESC            pLfo
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pLfo)
    {
        DPF_ERROR("LFO description not provided");
    }

    if((pLfo->dwLFO < DSLFO_FIRST) && (pLfo->dwLFO > DSLFO_LAST))
    {
        DPF_ERROR("Invalid LFO identifier");
    }

    if(pLfo->dwDelay > 0x7FFF)
    {
        DPF_ERROR("Invalid LFO delay value");
    }

    if(pLfo->dwDelta > 0x3FF)
    {
        DPF_ERROR("Invalid LFO delta value");
    }

    if((pLfo->lPitchModulation < -128) || (pLfo->lPitchModulation > 127))
    {
        DPF_ERROR("Invalid LFO pitch modulation value");
    }

    if((pLfo->lFilterCutOffRange < -128) || (pLfo->lFilterCutOffRange > 127))
    {
        DPF_ERROR("Invalid LFO filter cutoff value");
    }

    if((pLfo->lAmplitudeModulation < -128) || (pLfo->lAmplitudeModulation > 127))
    {
        DPF_ERROR("Invalid LFO amplitude modulation value");
    }

    if(pLfo->dwLFO != DSLFO_MULTI)
    {
        if(pLfo->lFilterCutOffRange || pLfo->lAmplitudeModulation)
        {
            DPF_WARNING("The pitch LFO doesn not support filter cut-off range or amplitude modulation");
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetLFO(pLfo);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetEG
 *
 *  Description:
 *      Sets parameters for one of the envelope generators.
 *
 *  Arguments:
 *      LPCDSENVELOPEDESC [in]: common envelope settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetEG"

HRESULT
CDirectSoundVoice::SetEG
(
    LPCDSENVELOPEDESC       pEnv
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pEnv)
    {
        DPF_ERROR("Envelope description not provided");
    }

    if((pEnv->dwEG < DSEG_FIRST) || (pEnv->dwEG > DSEG_LAST))
    {
        DPF_ERROR("Invalid envelope generator identifier");
    }

    if((pEnv->dwMode < DSEG_MODE_FIRST) || (pEnv->dwMode > DSEG_MODE_LAST))
    {
        DPF_ERROR("Invalid envelope generator mode");
    }

    if(pEnv->dwDelay > 0x7FFF)
    {
        DPF_ERROR("Invalid envelope delay value");
    }

    if(pEnv->dwAttack > 0x7FFF)
    {
        DPF_ERROR("Invalid envelope attack value");
    }

    if(pEnv->dwHold > 0x7FFF)
    {
        DPF_ERROR("Invalid envelope hold value");
    }

    if(pEnv->dwDecay > 0x7FFF)
    {
        DPF_ERROR("Invalid envelope decay value");
    }

    if(pEnv->dwRelease > 0x7FFF)
    {
        DPF_ERROR("Invalid envelope release value");
    }

    if(pEnv->dwSustain > 0xFF)
    {
        DPF_ERROR("Invalid envelope sustain value");
    }

    if((pEnv->lPitchScale < -128) || (pEnv->lPitchScale > 127))
    {
        DPF_ERROR("Invalid envelope pitch scale value");
    }

    if((pEnv->lFilterCutOff < -128) || (pEnv->lFilterCutOff > 127))
    {
        DPF_ERROR("Invalid envelope filter cutoff value");
    }

    if(pEnv->dwEG != DSEG_MULTI)
    {
        if(pEnv->lPitchScale || pEnv->lFilterCutOff)
        {
            DPF_WARNING("The amplitude envelope doesn not support pitch scale or filter cutoff");
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetEG(pEnv);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetFilter
 *
 *  Description:
 *      Sets parameters for the filter.
 *
 *  Arguments:
 *      LPCDSFILTERDESC [in]: filter settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetFilter"

HRESULT
CDirectSoundVoice::SetFilter
(
    LPCDSFILTERDESC         pFilter
)
{
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pFilter)
    {
        DPF_ERROR("Filter description not provided");
    }

    if((pFilter->dwMode < DSFILTER_MODE_FIRST) || (pFilter->dwMode > DSFILTER_MODE_LAST))
    {
        DPF_ERROR("Invalid filter mode");
    }

    if(pFilter->dwQCoefficient > 7)
    {
        DPF_ERROR("Invalid Q-coefficient value");
    }

    for(i = 0; i < NUMELMS(pFilter->adwCoefficients); i++)
    {
        if(pFilter->adwCoefficients[i] > 0xFFFF)
        {
            DPF_ERROR("Invalid coefficient value (index %lu)", i);
        }
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        if(DSFILTER_MODE_BYPASS == pFilter->dwMode)
        {
            DPF_ERROR("The filter can't be bypassed on a 3D voice");
        }

        for(i = 2; i < NUMELMS(pFilter->adwCoefficients); i++)
        {
            if(pFilter->adwCoefficients[i])
            {
                DPF_ERROR("Only the first 2 coefficients are valid on a 3D voice");
            }
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetFilter(pFilter);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetHeadroom
 *
 *  Description:
 *      Sets voice headroom.
 *
 *  Arguments:
 *      DWORD [in]: headroom, in Millibels.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetHeadroom"

HRESULT
CDirectSoundVoice::SetHeadroom
(
    DWORD                   dwHeadroom
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((dwHeadroom < DSBHEADROOM_MIN) || (dwHeadroom > DSBHEADROOM_MAX))
    {
        DPF_ERROR("Headroom value out-of-bounds");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Save the headroom to the settings
    //

    m_pSettings->SetHeadroom(dwHeadroom);
    
    //
    // Headroom affects voice volume, so notify the implementation object
    //

    hr = m_pVoice->SetVolume();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}    


/****************************************************************************
 *
 *  SetOutputBuffer
 *
 *  Description:
 *      Assignes the output of this voice to another voice instead of the
 *      standard mixbins.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: mixin buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetOutputBuffer"

HRESULT
CDirectSoundVoice::SetOutputBuffer
(
    LPDIRECTSOUNDBUFFER     pOutputBuffer
)
{
    CDirectSoundBuffer *    pMixinBuffer    = (CDirectSoundBuffer *)pOutputBuffer;
    HRESULT                 hr              = DS_OK;

#ifdef VALIDATE_PARAMETERS
    
    static BOOL             fSubMixHeadroom = FALSE;
    static BOOL             fExtraMixBins   = FALSE;
    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(pMixinBuffer)
    {
        //
        // Make sure the output buffer is really MIXIN
        //

        if(!(pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK))
        {
            DPF_ERROR("Output buffer specified is not a MIXIN/FXIN buffer");
        }

        //
        // Only supporting a single submix
        //

        if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
        {
            DPF_ERROR("Can't set the output buffer on MIXIN/FXIN buffers");
        }

        //
        // Can't submix 3D voices
        //

        if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
        {
            DPF_ERROR("Can't submix a 3D buffer.  Create a 2D source buffer and a 3D destination buffer.");
        }

        //
        // Can't submix anything but mono
        //

        if(1 != m_pSettings->m_fmt.nChannels)
        {
            DPF_ERROR("Can only submix mono source voices");
        }

        //
        // Must have one mixbin slot free for the submix bin
        //

        if(m_pSettings->m_dwMixBinCount >= NUMELMS(m_pSettings->m_adwMixBins))
        {
            DPF_ERROR("Submixed voices must leave one mixbin slot free");
        }

        //
        // Reduce API ignorance
        //

        if(!fExtraMixBins)
        {
            if(m_pSettings->m_dwMixBinCount)
            {
                DPF_WARNING("The voice you're adding to the submix chain is assigned to mixbins.  You will hear the voice both through the submix output and the mixbins it's assigned to.  In order to prevent this, set the mixbin count to 0 before calling SetOutputBuffer.  You will only see this warning once.");
                fExtraMixBins = TRUE;
            }
        }

        //
        // Make sure we're not double-assigned to the submix bin
        //

        for(i = 0; i < m_pSettings->m_dwMixBinCount; i++)
        {
            if(m_pSettings->m_adwMixBins[i] == pMixinBuffer->m_pSettings->m_dwInputMixBin)
            {
                DPF_WARNING("The mixbin your submix destination is reading from is already in your mixbin list");
                break;
            }
        }

        //
        // Check the headroom for the destination voice
        //

        if(!fSubMixHeadroom)
        {
            if(m_pDirectSound->m_pSettings->m_adwMixBinHeadroom[pMixinBuffer->m_pSettings->m_dwInputMixBin])
            {
                DPF_WARNING("The headroom for the mixbin your submix destination is reading from is non-zero.  This will be additive with the headroom that your submix destination is reading to, possibly giving you more headroom that you want.  You will only see this warning once.");
                fSubMixHeadroom = TRUE;
            }
        }
    }

#endif // VALIDATE_PARAMETERS

    if(pMixinBuffer != m_pSettings->m_pMixinBuffer)
    {
        //
        // Disconnect from the current buffer
        //

        if(m_pSettings->m_pMixinBuffer)
        {
            hr = m_pVoice->DisconnectVoice();
        }
        
        //
        // Update the settings object
        //

        if(SUCCEEDED(hr))
        {
            m_pSettings->SetOutputBuffer(pMixinBuffer);
        }

        //
        // Hand off to the implementation object.  ConnectVoice handles
        // resetting the mixbins and mixbin volumes as well as voice list
        // management.
        //

        if(SUCCEEDED(hr) && pMixinBuffer)
        {
            hr = m_pVoice->ConnectVoice();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetOutputBuffer_v1
 *
 *  Description:
 *      Assignes the output of this voice to another voice instead of the
 *      standard mixbins.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: mixin buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetOutputBuffer_v1"

HRESULT
CDirectSoundVoice::SetOutputBuffer_v1
(
    LPDIRECTSOUNDBUFFER     pOutputBuffer
)
{
    DSMIXBINS               MixBins;
    HRESULT                 hr;

    DPF_ENTER();

    //
    // Assign the voice to 0 mixbins
    //

    MixBins.dwMixBinCount = 0;
    
    hr = SetMixBins(&MixBins);

    //
    // Set the output buffer
    //

    if(SUCCEEDED(hr))
    {
        hr = SetOutputBuffer(pOutputBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBins
 *
 *  Description:
 *      Assigns the output of this voice to specific mixbins.
 *
 *  Arguments:
 *      LPCDSMIXBINS [in]: mixbin assignments.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMixBins"

HRESULT
CDirectSoundVoice::SetMixBins
(
    LPCDSMIXBINS            pMixBins
)
{
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS  

    DWORD                   i;
   
#endif // VALIDATE_PARAMETERS    

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(pMixBins->dwMixBinCount)
    {
        if(pMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
        {
            DPF_ERROR("No voice can be assigned to more than %lu mix bins", DSMIXBIN_ASSIGNMENT_MAX);
        }
        
        if(pMixBins->dwMixBinCount % m_pSettings->m_fmt.nChannels)
        {
            DPF_ERROR("The mixbin count must be a multiple of the channel count");
        }

        for(i = 0; i < pMixBins->dwMixBinCount; i++)
        {
            if(pMixBins->lpMixBinVolumePairs[i].dwMixBin > DSMIXBIN_LAST)
            {
                DPF_ERROR("Specified an invalid mixbin");
            }

            if(DSMIXBIN_SUBMIX == pMixBins->lpMixBinVolumePairs[i].dwMixBin)
            {
                DPF_ERROR("Don't SetMixBins to DSMIXBIN_SUBMIX.  Instead, call SetOutputBuffer");
            }

            if(m_pSettings->m_pMixinBuffer)
            {
                if(pMixBins->lpMixBinVolumePairs[i].dwMixBin == m_pSettings->m_pMixinBuffer->m_pSettings->m_dwInputMixBin)
                {
                    DPF_WARNING("Don't use SetMixBins to redirect output to an FXIN buffer.  Instead, call SetOutputBuffer");
                }
            }
        }

        if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
        {
            if(pMixBins->dwMixBinCount < DirectSoundRequiredMixBins_3D.dwMixBinCount)
            {
                DPF_ERROR("MixBin count doesn't include enough mixbins to hold all required for 3D");
            }
            
            for(i = 0; i < DirectSoundRequiredMixBins_3D.dwMixBinCount; i++)
            {
                if(pMixBins->lpMixBinVolumePairs[i].dwMixBin != DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[i].dwMixBin)
                {
                    DPF_ERROR("MixBin array does not include the required 3D bins");
                }
            }
        }

        if(m_pSettings->m_pMixinBuffer)
        {
            if(pMixBins->dwMixBinCount >= DSMIXBIN_ASSIGNMENT_MAX)
            {
                DPF_ERROR("Submixed voices need to keep one mixbin slot free");
            }
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Save settings
    //

    m_pSettings->SetMixBins(pMixBins);

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetMixBins();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBins_v1
 *
 *  Description:
 *      Assigns the output of this voice to specific mixbins.
 *
 *  Arguments:
 *      DWORD [in]: mixbin assignment mask.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMixBins_v1"

HRESULT
CDirectSoundVoice::SetMixBins_v1
(
    DWORD                   dwMixBinMask
)
{
    DSMIXBINS               MixBins;
    DSMIXBINVOLUMEPAIR      MixBinVolumePairs[DSMIXBIN_ASSIGNMENT_MAX];
    DWORD                   dwMixBin;
    HRESULT                 hr;

    DPF_ENTER();

    MixBins.dwMixBinCount = 0;
    MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

    while(dwMixBinMask)
    {
        if(MixBins.dwMixBinCount >= NUMELMS(MixBinVolumePairs))
        {
            DPF_ERROR("Too many mixbins in the mask");
            break;
        }

        MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin = lsb(dwMixBinMask);
        MixBinVolumePairs[MixBins.dwMixBinCount].lVolume = 0;

        dwMixBinMask &= ~(1UL << MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin);

        MixBins.dwMixBinCount++;
    }

    hr = SetMixBins(&MixBins);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBinVolumes
 *
 *  Description:
 *      Sets the volume of each channel of the voice as it applies to it's
 *      assigned mixbins.
 *
 *  Arguments:
 *      LPCDSMIXBINS [in]: mixbin volume data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMixBinVolumes"

HRESULT
CDirectSoundVoice::SetMixBinVolumes
(
    LPCDSMIXBINS            pMixBins
)
{
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i, z;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pMixBins)
    {
        DPF_ERROR("Failed to supply any volume data");
    }

    if(pMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
    {
        DPF_ERROR("Invalid mixbin count");
    }
    
    for(i = 0; i < pMixBins->dwMixBinCount; i++)
    {
        for(z = 0; z < m_pSettings->m_dwMixBinCount; z++)
        {
            if(pMixBins->lpMixBinVolumePairs[i].dwMixBin == m_pSettings->m_adwMixBins[z])
            {
                break;
            }
        }

        if(z >= m_pSettings->m_dwMixBinCount)
        {
            DPF_ERROR("Specified a mixbin the voice is not assigned to at index %lu (mixbin %lu)", i, pMixBins->lpMixBinVolumePairs[i].dwMixBin);
        }
        
        if((pMixBins->lpMixBinVolumePairs[i].lVolume < DSBVOLUME_MIN) || (pMixBins->lpMixBinVolumePairs[i].lVolume > DSBVOLUME_MAX))
        {
            DPF_ERROR("Invalid volume at index %lu", i);
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the volume
    //

    m_pSettings->SetMixBinVolumes(pMixBins);

    //
    // Hand off to the implementation object
    //

    hr = m_pVoice->SetVolume();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetMixBinVolumes_v1
 *
 *  Description:
 *      Sets the volume of each channel of the voice as it applies to it's
 *      assigned mixbins.
 *
 *  Arguments:
 *      DWORD [in]: mask of mixbins to set volume on.
 *      const LONG * [in]: volume array.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMixBinVolumes_v1"

HRESULT
CDirectSoundVoice::SetMixBinVolumes_v1
(
    DWORD                   dwMixBinMask,
    const LONG *            palVolumes
)
{
    DSMIXBINS               MixBins;
    DSMIXBINVOLUMEPAIR      MixBinVolumePairs[DSMIXBIN_ASSIGNMENT_MAX];
    HRESULT                 hr;
    DWORD                   i;

    DPF_ENTER();

    MixBins.dwMixBinCount = 0;
    MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

    while(dwMixBinMask)
    {
        if(MixBins.dwMixBinCount >= NUMELMS(MixBinVolumePairs))
        {
            DPF_ERROR("Too many mixbins in the mask");
            break;
        }

        MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin = lsb(dwMixBinMask);
        MixBinVolumePairs[MixBins.dwMixBinCount].lVolume = palVolumes[MixBins.dwMixBinCount];

        dwMixBinMask &= ~(1UL << MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin);

        MixBins.dwMixBinCount++;
    }

    hr = SetMixBinVolumes(&MixBins);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifndef MCPX_BOOT_LIB

/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object properties.
 *
 *  Arguments:
 *      LPDS3DBUFFER [in]: object parameters.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetAllParameters"

HRESULT 
CDirectSoundVoice::SetAllParameters
(
    LPCDS3DBUFFER           pParams, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pParams)
    {
        DPF_ERROR("Parameters not supplied");
    }

    if(pParams->dwSize < sizeof(*pParams))
    {
        DPF_ERROR("Invalid structure size");
    }

    if((pParams->dwInsideConeAngle < DS3D_MINCONEANGLE) || (pParams->dwInsideConeAngle > DS3D_MAXCONEANGLE) || (pParams->dwOutsideConeAngle < DS3D_MINCONEANGLE) || (pParams->dwOutsideConeAngle > DS3D_MAXCONEANGLE))
    {
        DPF_ERROR("Invalid cone angle value");
    }

    if(pParams->dwInsideConeAngle > pParams->dwOutsideConeAngle)
    {
        DPF_ERROR("Inside cone angle can't be greater than outside");
    }

    if(!pParams->vConeOrientation.x && !pParams->vConeOrientation.y && !pParams->vConeOrientation.z)
    {
        DPF_ERROR("Invalid cone orientation");
    }
    
    if((pParams->lConeOutsideVolume < DSBVOLUME_MIN) || (pParams->lConeOutsideVolume > DSBVOLUME_MAX))
    {
        DPF_ERROR("Invalid volume level");
    }

    if(!pParams->flMinDistance || !pParams->flMaxDistance)
    {
        DPF_ERROR("Minimum and maximum distance must be non-zero");
    }

    if((pParams->dwMode < DS3DMODE_FIRST) || (pParams->dwMode > DS3DMODE_LAST))
    {
        DPF_ERROR("Invalid mode");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams = *pParams;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_MASK;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets the sound cone's angles.
 *
 *  Arguments:
 *      DWORD [in]: inside angle.
 *      DWORD [in]: outside angle.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetConeAngles"

HRESULT 
CDirectSoundVoice::SetConeAngles
(
    DWORD                   dwInside, 
    DWORD                   dwOutside, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((dwInside < DS3D_MINCONEANGLE) || (dwInside > DS3D_MAXCONEANGLE) || (dwOutside < DS3D_MINCONEANGLE) || (dwOutside > DS3D_MAXCONEANGLE))
    {
        DPF_ERROR("Invalid cone angle value");
    }

    if(dwInside > dwOutside)
    {
        DPF_ERROR("Inside cone angle can't be greater than outside");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.dwInsideConeAngle = dwInside;
    m_pSettings->m_3dParams.dwOutsideConeAngle = dwOutside;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_CONEANGLES;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets the sound cone's orientation.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetConeOrientation"

HRESULT 
CDirectSoundVoice::SetConeOrientation
(
    FLOAT                   flOrientationX,
    FLOAT                   flOrientationY,
    FLOAT                   flOrientationZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!flOrientationX && !flOrientationY && !flOrientationZ)
    {
        DPF_ERROR("Invalid cone orientation");
    }
    
    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.vConeOrientation.x = flOrientationX;
    m_pSettings->m_3dParams.vConeOrientation.y = flOrientationY;
    m_pSettings->m_3dParams.vConeOrientation.z = flOrientationZ;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_CONEORIENTATION;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets the sound cone's outside volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetConeOutsideVolume"

HRESULT 
CDirectSoundVoice::SetConeOutsideVolume
(
    LONG                    lVolume, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((lVolume < DSBVOLUME_MIN) || (lVolume > DSBVOLUME_MAX))
    {
        DPF_ERROR("Invalid volume level");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.lConeOutsideVolume = lVolume;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_CONEOUTSIDEVOLUME;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the objects maximum distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: maximum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMaxDistance"

HRESULT 
CDirectSoundVoice::SetMaxDistance
(
    FLOAT                   flMaxDistance, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((flMaxDistance < DS3D_MINMAXDISTANCE) || (flMaxDistance > DS3D_MAXMAXDISTANCE))
    {
        DPF_ERROR("Invalid max distance value");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

    if(flMaxDistance < m_pSettings->m_3dParams.flMinDistance)
    {
        DPF_ERROR("flMaxDistance must be >= flMinDistance");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.flMaxDistance = flMaxDistance;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_MAXDISTANCE;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the objects minimum distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: minimum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMinDistance"

HRESULT 
CDirectSoundVoice::SetMinDistance
(
    FLOAT                   flMinDistance, 
    DWORD                   dwFlags
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((flMinDistance < DS3D_MINMINDISTANCE) || (flMinDistance > DS3D_MAXMINDISTANCE))
    {
        DPF_ERROR("Invalid min distance value");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

    if(flMinDistance > m_pSettings->m_3dParams.flMaxDistance)
    {
        DPF_ERROR("MinDistance must be <= MaxDistance");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.flMinDistance = flMinDistance;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_MINDISTANCE;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the objects mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetMode"

HRESULT 
CDirectSoundVoice::SetMode
(
    DWORD                   dwMode, 
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if((dwMode < DS3DMODE_FIRST) || (dwMode > DS3DMODE_LAST))
    {
        DPF_ERROR("Invalid mode");
    }
    
    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    //
    // There is no parameter bit for mode since what's recalculated is based
    // on the mode change
    //
    
    m_pSettings->m_3dParams.dwMode = dwMode;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the objects position.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetPosition"

HRESULT 
CDirectSoundVoice::SetPosition
(
    FLOAT                   flPositionX,
    FLOAT                   flPositionY,
    FLOAT                   flPositionZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.vPosition.x = flPositionX;
    m_pSettings->m_3dParams.vPosition.y = flPositionY;
    m_pSettings->m_3dParams.vPosition.z = flPositionZ;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_POSITION;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the objects velocity.
 *
 *  Arguments:
 *      REFD3DXVECTOR3 [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetVelocity"

HRESULT 
CDirectSoundVoice::SetVelocity
(
    FLOAT                   flVelocityX,
    FLOAT                   flVelocityY,
    FLOAT                   flVelocityZ,
    DWORD                   dwFlags
)
{
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_3dParams.vVelocity.x = flVelocityX;
    m_pSettings->m_3dParams.vVelocity.y = flVelocityY;
    m_pSettings->m_3dParams.vVelocity.z = flVelocityZ;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_VELOCITY;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetI3DL2Source
 *
 *  Description:
 *      Sets I3DL2 source parameters.
 *
 *  Arguments:
 *      LPCDSI3DL2BUFFER [in]: source parameters.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::SetI3DL2Source"

HRESULT
CDirectSoundVoice::SetI3DL2Source
(
    LPCDSI3DL2BUFFER        pProperties,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!pProperties)
    {
        DPF_ERROR("Failed to supply parameters");
    }

    if(dwFlags & ~DS3D_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DS3D_VALID);
    }

    if((pProperties->lDirect < DSI3DL2BUFFER_MINDIRECT) || (pProperties->lDirect > DSI3DL2BUFFER_MAXDIRECT))
    {
        DPF_ERROR("Invalid lDirect value");
    }

    if((pProperties->lDirectHF < DSI3DL2BUFFER_MINDIRECTHF) || (pProperties->lDirectHF > DSI3DL2BUFFER_MAXDIRECTHF))
    {
        DPF_ERROR("Invalid lDirectHF value");
    }

    if((pProperties->lRoom < DSI3DL2BUFFER_MINROOM) || (pProperties->lRoom > DSI3DL2BUFFER_MAXROOM))
    {
        DPF_ERROR("Invalid lRoom value");
    }

    if((pProperties->lRoomHF < DSI3DL2BUFFER_MINROOMHF) || (pProperties->lRoomHF > DSI3DL2BUFFER_MAXROOMHF))
    {
        DPF_ERROR("Invalid lRoomHF value");
    }

    if((pProperties->flRoomRolloffFactor < DSI3DL2BUFFER_MINROOMROLLOFFFACTOR) || (pProperties->flRoomRolloffFactor > DSI3DL2BUFFER_MAXROOMROLLOFFFACTOR))
    {
        DPF_ERROR("Invalid flRoomRolloffFactor value");
    }

    if((pProperties->Obstruction.lHFLevel < DSI3DL2BUFFER_MINOBSTRUCTION) || (pProperties->Obstruction.lHFLevel > DSI3DL2BUFFER_MAXOBSTRUCTION))
    {
        DPF_ERROR("Invalid Obstruction.lHFLevel value");
    }

    if((pProperties->Obstruction.flLFRatio < DSI3DL2BUFFER_MINOBSTRUCTIONLFRATIO) || (pProperties->Obstruction.flLFRatio > DSI3DL2BUFFER_MAXOBSTRUCTIONLFRATIO))
    {
        DPF_ERROR("Invalid Obstruction.flLFRatio value");
    }

    if((pProperties->Occlusion.lHFLevel < DSI3DL2BUFFER_MINOCCLUSION) || (pProperties->Occlusion.lHFLevel > DSI3DL2BUFFER_MAXOCCLUSION))
    {
        DPF_ERROR("Invalid Occlusion.lHFLevel value");
    }

    if((pProperties->Occlusion.flLFRatio < DSI3DL2BUFFER_MINOCCLUSIONLFRATIO) || (pProperties->Occlusion.flLFRatio > DSI3DL2BUFFER_MAXOCCLUSIONLFRATIO))
    {
        DPF_ERROR("Invalid Occlusion.flLFRatio value");
    }

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        DPF_ERROR("3D not enabled");
    }

#endif // VALIDATE_PARAMETERS

    m_pSettings->m_I3dl2Params = *pProperties;
    m_pSettings->m_dw3dParameterMask |= DS3DPARAM_BUFFER_I3DL2;

    if(!(dwFlags & DS3D_DEFERRED))
    {
        CommitDeferredSettings();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CommitDeferredSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundVoice::CommitDeferredSettings"

HRESULT 
CDirectSoundVoice::CommitDeferredSettings
(
    void
)
{
    DPF_ENTER();

    //
    // Include the changed listener parameters in the 3D parameter mask
    //
    
    m_pSettings->m_dw3dParameterMask |= m_pDirectSound->m_pSettings->m_dw3dParameterMask;

    //
    // Apply changes to the voice.  The voice implementation object will 
    // properly reset m_pSettings->m_dw3dParameterMask for us.
    //
    
    m_pVoice->Commit3dSettings();

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  CDirectSoundBufferSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::CDirectSoundBufferSettings"

const WAVEFORMATEX CDirectSoundBufferSettings::m_wfxMixDest = INIT_PCM_WAVEFORMAT_EX(1, 48000, 24, 32);

CDirectSoundBufferSettings::CDirectSoundBufferSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundBufferSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::~CDirectSoundBufferSettings"

CDirectSoundBufferSettings::~CDirectSoundBufferSettings
(
    void
)
{
    DPF_ENTER();
    
    //
    // Free the data buffer
    //
    
    SetBufferData(NULL, 0);

    //
    // Free notifications
    //

    SetNotificationPositions(0, NULL);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::Initialize"

HRESULT
CDirectSoundBufferSettings::Initialize
(
    LPCDSBUFFERDESC         pdsbd
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    //
    // Hand off to the base class
    //

    CDirectSoundVoiceSettings::Initialize(pdsbd->dwFlags, (pdsbd->dwFlags & DSBCAPS_SUBMIXMASK) ? &m_wfxMixDest : pdsbd->lpwfxFormat, pdsbd->lpMixBins);

    //
    // Save the input mixbin
    //

    if(pdsbd->dwFlags & DSBCAPS_FXIN)
    {
        m_dwInputMixBin = pdsbd->dwInputMixBin;
    }
    else if(pdsbd->dwFlags & DSBCAPS_MIXIN)
    {
        m_dwInputMixBin = DSMIXBIN_SUBMIX;
    }
    
    //
    // Initialize buffer data
    //

    if(pdsbd->dwBufferBytes)
    {
        hr = SetBufferData(NULL, pdsbd->dwBufferBytes);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetBufferData
 *
 *  Description:
 *      Sets buffer data pointers.
 *
 *  Arguments:
 *      LPVOID [in]: data buffer.
 *      LPVOID [in]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::SetBufferData"

HRESULT
CDirectSoundBufferSettings::SetBufferData
(
    LPVOID                  pvDataBuffer,
    DWORD                   dwBufferBytes
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    
    //
    // Free the existing buffer
    //

    if(m_dwFlags & DSBCAPS_APPALLOCBUFFER)
    {
        m_pvBufferData = NULL;
    }
    else
    {
        MEMFREE(m_pvBufferData);
    }

    //
    // Allocate the new buffer (or just save the pointer)
    //

    if(m_dwBufferSize = dwBufferBytes)
    {
        if(pvDataBuffer)
        {
            m_dwFlags |= DSBCAPS_APPALLOCBUFFER;

            m_pvBufferData = pvDataBuffer;
        }
        else
        {
            m_dwFlags &= ~DSBCAPS_APPALLOCBUFFER;
        
            hr = HRFROMP(m_pvBufferData = MEMALLOC_NOINIT(BYTE, m_dwBufferSize));
        }
    }

    //
    // Reset the buffer offsets
    //

    SetBufferOffsets(0, m_dwBufferSize, 0, m_dwBufferSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetBufferOffsets
 *
 *  Description:
 *      Sets buffer play and loop regions.
 *
 *  Arguments:
 *      DWORD [in]: starting position of the play region.
 *      DWORD [in]: length, in bytes, of the play region.
 *      DWORD [in]: starting position of the loop region.
 *      DWORD [in]: length, in bytes, of the loop region.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::SetBufferOffsets"

void
CDirectSoundBufferSettings::SetBufferOffsets
(
    DWORD                   dwPlayStart,
    DWORD                   dwPlayLength,
    DWORD                   dwLoopStart,
    DWORD                   dwLoopLength
)
{
    DPF_ENTER();

    ASSERT(dwPlayStart + dwPlayLength <= m_dwBufferSize);
    ASSERT(dwLoopStart + dwLoopLength <= m_dwBufferSize);
    ASSERT(dwLoopStart + dwLoopLength <= dwPlayLength);
    
    m_dwPlayStart = dwPlayStart;
    m_dwPlayLength = dwPlayLength;
    m_dwLoopStart = dwLoopStart;
    m_dwLoopLength = dwLoopLength;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets notification positions.
 *
 *  Arguments:
 *      DWORD [in]: notification count.
 *      LPCDSBPOSITIONNOTIFY [in]: notification array.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferSettings::SetNotificationPositions"

HRESULT
CDirectSoundBufferSettings::SetNotificationPositions
(
    DWORD                   dwNotifyCount,
    LPCDSBPOSITIONNOTIFY    paNotifies
)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   i       = 0;
    DSBPOSITIONNOTIFY       NotifyT;

    DPF_ENTER();

    //
    // Free any existing notifications
    //

    MEMFREE(m_paNotifies);

    //
    // Save the new notification count
    //

    m_dwNotifyCount = dwNotifyCount;

    //
    // Make a copy of the notification array and put it into ascending order
    //

    if(dwNotifyCount)
    {
        hr = HRFROMP(m_paNotifies = MEMALLOC_NOINIT(DSBPOSITIONNOTIFY, dwNotifyCount));

        if(SUCCEEDED(hr))
        {
            CopyMemory(m_paNotifies, paNotifies, sizeof(*paNotifies) * dwNotifyCount);
        }

        if(SUCCEEDED(hr))
        {
            while(i < m_dwNotifyCount - 1)
            {
                if(m_paNotifies[i].dwOffset > m_paNotifies[i + 1].dwOffset)
                {
                    NotifyT = m_paNotifies[i];
                    m_paNotifies[i] = m_paNotifies[i + 1];
                    m_paNotifies[i + 1] = NotifyT;

                    i = 0;
                }
                else
                {
                    i++;
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CDirectSoundBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: parent DirectSound object
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::CDirectSoundBuffer"

CDirectSoundBuffer::CDirectSoundBuffer
(
    CDirectSound *      pDirectSound
)
:   CDirectSoundVoice(pDirectSound)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::~CDirectSoundBuffer"

CDirectSoundBuffer::~CDirectSoundBuffer
(
    void
)
{
    DPF_ENTER();

    //
    // Free the buffer implementation
    //

    RELEASE(m_pBuffer);

    //
    // Free settings
    //

    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: buffer description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::Initialize"

HRESULT
CDirectSoundBuffer::Initialize
(
    LPCDSBUFFERDESC         pdsbd
)
{                                   
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(!pdsbd)
    {
        DPF_ERROR("DSBUFFERDESC not supplied");
    }

    if(sizeof(*pdsbd) < pdsbd->dwSize)
    {
        DPF_ERROR("DSBUFFERDESC size not valid");
    }

    if(pdsbd->dwFlags & ~DSBCAPS_VALID)
    {
        DPF_ERROR("Specified invalid flags (%lx)", pdsbd->dwFlags & ~DSBCAPS_VALID);
    }

    if(pdsbd->dwFlags & DSBCAPS_SUBMIXMASK)
    {
        if(pdsbd->dwFlags & DSBCAPS_LOCDEFER)
        {
            DPF_ERROR("MIXIN/FXIN buffers can't be LOCDEFER");
        }

        if(pdsbd->dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
        {
            DPF_ERROR("MIXIN/FXIN buffers can't have CTRLPOSITIONNOTIFY");
        }

        if(pdsbd->lpwfxFormat)
        {
            DPF_ERROR("lpwfxFormat for MIXIN/FXIN buffers must be NULL");
        }

        if(pdsbd->dwBufferBytes)
        {
            DPF_ERROR("dwBufferBytes for MIXIN/FXIN buffers must be 0");
        }
    }
    else
    {
        if(!pdsbd->lpwfxFormat)
        {
            DPF_ERROR("Failed to specify a buffer format");
        }

        if(!FmtIsValid(pdsbd->lpwfxFormat))
        {
            DPF_ERROR("Invalid buffer format");
        }

        if(pdsbd->dwBufferBytes && ((pdsbd->dwBufferBytes < DSBSIZE_MIN) || (pdsbd->dwBufferBytes > DSBSIZE_MAX)))
        {
            DPF_ERROR("Buffer size out-of-bounds");
        }
    
        if(pdsbd->dwBufferBytes && (pdsbd->dwBufferBytes % pdsbd->lpwfxFormat->nBlockAlign))
        {
            DPF_ERROR("Buffer size not a multiple of the sample size");
        }

        if((pdsbd->dwFlags & DSBCAPS_CTRL3D) && (1 != pdsbd->lpwfxFormat->nChannels))
        {
            DPF_ERROR("3D voices must be mono");
        }
    }

    if((pdsbd->dwFlags & DSBCAPS_CTRL3D) && !CHrtfSource::IsValidHrtfQuality())
    {
        DPF_ERROR("You must call DirectSoundUseLight/FullHRTF before creating a 3D buffer");
    }

    if(pdsbd->lpMixBins)
    {
        if(pdsbd->lpMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
        {
            DPF_ERROR("No voice can be assigned to more than %lu mix bins", DSMIXBIN_ASSIGNMENT_MAX);
        }

        if(pdsbd->lpwfxFormat)
        {
            if(pdsbd->lpMixBins->dwMixBinCount % pdsbd->lpwfxFormat->nChannels)
            {
                DPF_ERROR("The mixbin count must be a multiple of the channel count");
            }

            if(WAVE_FORMAT_EXTENSIBLE == pdsbd->lpwfxFormat->wFormatTag)
            {
                if(((LPCWAVEFORMATEXTENSIBLE)pdsbd->lpwfxFormat)->dwChannelMask)
                {
                    DPF_WARNING("Specifying mixbins will override the channel mask specified in the format");
                }
            }
        }

        for(i = 0; i < pdsbd->lpMixBins->dwMixBinCount; i++)
        {
            if(pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin > DSMIXBIN_LAST)
            {
                DPF_ERROR("Specified an invalid mixbin");
            }

            if(DSMIXBIN_SUBMIX == pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin)
            {
                DPF_ERROR("Don't assign a voice to DSMIXBIN_SUBMIX.  Instead, call SetOutputBuffer");
            }
        }

        if(pdsbd->dwFlags & DSBCAPS_CTRL3D)
        {
            if(pdsbd->lpMixBins->dwMixBinCount < DirectSoundRequiredMixBins_3D.dwMixBinCount)
            {
                DPF_ERROR("MixBin count doesn't include enough mixbins to hold all required for 3D");
            }
            
            for(i = 0; i < DirectSoundRequiredMixBins_3D.dwMixBinCount; i++)
            {
                if(pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin != DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[i].dwMixBin)
                {
                    DPF_ERROR("MixBin array does not include the required 3D bins");
                }
            }
        }
    }

    if(pdsbd->dwFlags & DSBCAPS_FXIN)
    {
        if((pdsbd->dwInputMixBin < DSMIXBIN_FXSEND_FIRST) || (pdsbd->dwInputMixBin > DSMIXBIN_FXSEND_LAST))
        {
            DPF_ERROR("The input mixbin for an FXIN buffer can only be one of the FX sends");
        }
    }

#endif // VALIDATE_PARAMETERS

    //
    // Create the settings object
    //

    hr = HRFROMP(m_pSettings = NEW(CDirectSoundBufferSettings));

    if(SUCCEEDED(hr))
    {
        hr = m_pSettings->Initialize(pdsbd);
    }

    //
    // Create the implementation object
    //
    
    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pBuffer = NEW(CMcpxBuffer(m_pDirectSound->m_pDevice, m_pSettings)));
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->Initialize();
    }

    //
    // Initialize the base class
    //

    if(SUCCEEDED(hr))
    {
        CDirectSoundVoice::Initialize(m_pBuffer, m_pSettings);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetBufferData
 *
 *  Description:
 *      Sets buffer data pointers.
 *
 *  Arguments:
 *      LPVOID [in]: data buffer.
 *      LPVOID [in]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetBufferData"

HRESULT
CDirectSoundBuffer::SetBufferData
(
    LPVOID                  pvDataBuffer,
    DWORD                   dwBufferBytes
)
{
    const BOOL              fChanging   = pvDataBuffer || dwBufferBytes;
    HRESULT                 hr          = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(pvDataBuffer && dwBufferBytes)
    {
        if(dwBufferBytes && (dwBufferBytes % m_pSettings->m_fmt.nBlockAlign))
        {
            DPF_ERROR("Buffer size not block-aligned");
        }

        if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
        {
            DPF_ERROR("Can't SetBufferData on MIXIN/FXIN buffers");
        }
    }
    else if(pvDataBuffer)
    {
        DPF_ERROR("0-sized buffer with non-NULL buffer pointer");
    }
    else if(dwBufferBytes)
    {
        DPF_ERROR("NULL buffer with non-zero buffer size");
    }

#endif // VALIDATE_PARAMETERS

    if((pvDataBuffer != m_pSettings->m_pvBufferData) || (dwBufferBytes != m_pSettings->m_dwBufferSize))
    {
        //
        // Give the implementation object a chance to clean up before we
        // stomp on the shared data members.
        //

        hr = m_pBuffer->ReleaseBufferData(fChanging);

        //
        // Hand off to the settings object
        //

        if(SUCCEEDED(hr))
        {
            hr = m_pSettings->SetBufferData(pvDataBuffer, dwBufferBytes);
        }

        //
        // Notify the implementation object of the change
        //

        if(SUCCEEDED(hr) && fChanging)
        {
            hr = m_pBuffer->SetBufferData();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::Play"

HRESULT
CDirectSoundBuffer::Play
(
    DWORD                   dwReserved1,
    DWORD                   dwReserved2,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwReserved1 || dwReserved2)
    {
        DPF_ERROR("Reserved parameters must be 0");
    }
    
    if(dwFlags & ~DSBPLAY_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DSBPLAY_VALID);
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call Play on a MIXIN/FXIN buffer");
    }
    
    if(!m_pSettings->m_pvBufferData || !m_pSettings->m_dwBufferSize)
    {
        DPF_ERROR("No data to play!");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->Play(MAKEBOOL(dwFlags & DSBPLAY_LOOPING));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  PlayEx
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: time to start playing.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::PlayEx"

HRESULT
CDirectSoundBuffer::PlayEx
(
    REFERENCE_TIME          rtTimeStamp,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DSBPLAY_VALID)
    {
        DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DSBPLAY_VALID);
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call Play on a MIXIN/FXIN buffer");
    }
    
    if(!m_pSettings->m_pvBufferData || !m_pSettings->m_dwBufferSize)
    {
        DPF_ERROR("No data to play!");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->Play(rtTimeStamp, MAKEBOOL(dwFlags & DSBPLAY_LOOPING));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops buffer playback.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::Stop"

HRESULT
CDirectSoundBuffer::Stop
(
    void
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call Stop on a MIXIN/FXIN buffer");
    }
    
#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->Stop();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  StopEx
 *
 *  Description:
 *      Stops buffer playback.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: timestamp.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::StopEx"

HRESULT
CDirectSoundBuffer::StopEx
(
    REFERENCE_TIME          rtTimeStamp,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwFlags & ~DSBSTOPEX_VALID)
    {
        DPF_ERROR("Invalid flags");
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call Stop on a MIXIN/FXIN buffer");
    }
    
#endif // VALIDATE_PARAMETERS

    if(dwFlags & DSBSTOPEX_VALID)
    {
        hr = m_pBuffer->NoteOff(rtTimeStamp, MAKEBOOL(dwFlags & DSBSTOPEX_RELEASEWAVEFORM));
    }
    else
    {
        hr = m_pBuffer->Stop(rtTimeStamp);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets the current buffer status.
 *
 *  Arguments:
 *      LPDWORD [out]: buffer status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::GetStatus"

HRESULT
CDirectSoundBuffer::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwStatus)
    {
        DPF_ERROR("Failed to specify a status buffer");
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't call GetStatus on a MIXIN/FXIN buffer");
    }
    
#endif // VALIDATE_PARAMETERS
    
    hr = m_pBuffer->GetStatus(pdwStatus);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetBufferOffsets
 *
 *  Description:
 *      Sets buffer play and loop regions.
 *
 *  Arguments:
 *      DWORD [in]: starting position of the play region.
 *      DWORD [in]: length, in bytes, of the play region.
 *      DWORD [in]: starting position of the loop region.
 *      DWORD [in]: length, in bytes, of the loop region.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetBufferOffsets"

HRESULT
CDirectSoundBuffer::SetBufferOffsets
(
    DWORD                   dwPlayStart,
    DWORD                   dwPlayLength,
    DWORD                   dwLoopStart,
    DWORD                   dwLoopLength
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't SetBufferOffsets on MIXIN/FXIN buffers");
    }

    if(dwPlayStart % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Play offset not block-aligned");
    }

    if(dwLoopStart % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Loop offset not block-aligned");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Munge the lengths so that they're all valid
    //

    if(dwPlayLength)
    {

#ifdef VALIDATE_PARAMETERS

        if(dwPlayStart + dwPlayLength > m_pSettings->m_dwBufferSize)
        {
            DPF_ERROR("Play region extends past the end of the buffer");
        }
    
        if(dwPlayLength % m_pSettings->m_fmt.nBlockAlign)
        {
            DPF_ERROR("Play length not block-aligned");
        }

#endif // VALIDATE_PARAMETERS

    }
    else
    {
        dwPlayLength = m_pSettings->m_dwBufferSize - dwPlayStart;
    }

    if(dwLoopLength)
    {

#ifdef VALIDATE_PARAMETERS

        if(dwLoopStart + dwLoopLength > dwPlayLength)
        {
            DPF_ERROR("Loop region extends past the end of the play region");
        }
    
        if(dwLoopLength % m_pSettings->m_fmt.nBlockAlign)
        {
            DPF_ERROR("Loop length not block-aligned");
        }

#endif // VALIDATE_PARAMETERS

    }
    else
    {
        dwLoopLength = dwPlayLength - dwLoopStart;
    }

    //
    // Update the settings object
    //

    m_pSettings->SetBufferOffsets(dwPlayStart, dwPlayLength, dwLoopStart, dwLoopLength);

    //
    // Update the buffer implementation
    //

    hr = m_pBuffer->SetBufferOffsets();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: play cursor position, in bytes.
 *      LPDWORD [out]: write cursor position, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::GetCurrentPosition"

HRESULT
CDirectSoundBuffer::GetCurrentPosition
(
    LPDWORD                 pdwPlayPosition,
    LPDWORD                 pdwWritePosition
)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't GetCurrentPosition on MIXIN/FXIN buffers");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->GetCurrentPosition(pdwPlayPosition, pdwWritePosition);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer data for writing.
 *
 *  Arguments:
 *      DWORD [in]: lock position.
 *      DWORD [in]: lock size.
 *      LPVOID * [out]: lock pointer 1.
 *      LPDWORD [out]: lock size 1.
 *      LPVOID * [out]: lock pointer 2.
 *      LPDWORD [out]: lock size 2.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::Lock"

HRESULT
CDirectSoundBuffer::Lock
(
    DWORD                   dwLockPosition, 
    DWORD                   dwLockSize, 
    LPVOID *                ppvLock1, 
    LPDWORD                 pdwLockSize1, 
    LPVOID *                ppvLock2, 
    LPDWORD                 pdwLockSize2, 
    DWORD                   dwFlags
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!ppvLock1 || !pdwLockSize1)
    {
        DPF_ERROR("Missing first set of lock parameters");
    }

    if((ppvLock2 && !pdwLockSize2) || (!ppvLock2 && pdwLockSize2))
    {
        DPF_ERROR("Missing one of the second set of lock parameters");
    }

    if(dwFlags & ~DSBLOCK_VALID)
    {
        DPF_ERROR("Specified unsupported or invalid flags (%lx)", dwFlags & ~DSBLOCK_VALID);
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't Lock MIXIN/FXIN buffers");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Validate the lock position
    //

    if(dwFlags & DSBLOCK_FROMWRITECURSOR)
    {
        hr = GetCurrentPosition(NULL, &dwLockPosition);
    }
    
#ifdef VALIDATE_PARAMETERS

    else if(dwLockPosition >= m_pSettings->m_dwBufferSize)
    {
        DPF_ERROR("Lock position out-of-bounds");
    }
    else if(dwLockPosition % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Lock position not block aligned");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Validate the lock region size
    //

    if(SUCCEEDED(hr))
    {
        if(dwFlags & DSBLOCK_ENTIREBUFFER)
        {
            dwLockSize = m_pSettings->m_dwBufferSize;
        }
            
#ifdef VALIDATE_PARAMETERS

        else if(!dwLockSize)
        {
            DPF_ERROR("Lock size can't be 0 without specifying DSBLOCK_ENTIREBUFFER");
        }
        else if(dwLockSize > m_pSettings->m_dwBufferSize)
        {
            DPF_ERROR("Lock size out-of-bounds");
        }
        else if(dwLockSize % m_pSettings->m_fmt.nBlockAlign)
        {
            DPF_ERROR("Lock size not block aligned");
        }

#endif // VALIDATE_PARAMETERS

    }

    //
    // We're not really locking anything.  Instead, we're just returning
    // pointers to the data buffer.
    //

    if(SUCCEEDED(hr))
    {
        *ppvLock1 = (LPBYTE)m_pSettings->m_pvBufferData + dwLockPosition;
        *pdwLockSize1 = min(dwLockSize, m_pSettings->m_dwBufferSize - dwLockPosition);

        if(ppvLock2 && pdwLockSize2)
        {
            if(*pdwLockSize1 < dwLockSize)
            {
                *ppvLock2 = m_pSettings->m_pvBufferData;
                *pdwLockSize2 = dwLockSize - *pdwLockSize1;
            }
            else
            {
                *ppvLock2 = NULL;
                *pdwLockSize2 = 0;
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Gets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play cursor position, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetCurrentPosition"

HRESULT
CDirectSoundBuffer::SetCurrentPosition
(
    DWORD                   dwPlayPosition
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
#ifdef VALIDATE_PARAMETERS

    if(dwPlayPosition % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Position not sample-aligned");
    }
    
    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't SetCurrentPosition on MIXIN/FXIN buffers");
    }

    if(dwPlayPosition >= m_pSettings->m_dwPlayLength)
    {
        DPF_ERROR("Play cursor position out-of-bounds");
    }
    
#endif // VALIDATE_PARAMETERS

    hr = m_pBuffer->SetCurrentPosition(dwPlayPosition);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets notification positions.
 *
 *  Arguments:
 *      DWORD [in]: notification count.
 *      LPCDSBPOSITIONNOTIFY [in]: notification array.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::SetNotificationPositions"

HRESULT
CDirectSoundBuffer::SetNotificationPositions
(
    DWORD                   dwNotifyCount,
    LPCDSBPOSITIONNOTIFY    paNotifies
)
{
    HRESULT                 hr  = DS_OK;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();

#ifdef VALIDATE_PARAMETERS

    if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY))
    {
        DPF_ERROR("Buffer does not have CTRLPOSITIONNOTIFY");
    }

    for(i = 0; i < dwNotifyCount; i++)
    {
        if(DSBPN_OFFSETSTOP == paNotifies[i].dwOffset)
        {
            continue;
        }
        
        if(paNotifies[i].dwOffset % m_pSettings->m_fmt.nBlockAlign)
        {
            DPF_ERROR("Offset at index %lu not block-aligned", i);
        }

        if(paNotifies[i].dwOffset >= m_pSettings->m_dwPlayLength)
        {
            DPF_ERROR("Offset at index %lu past the end of the play region", i);
        }
        
        if(!IS_VALID_HANDLE_VALUE(paNotifies[i].hEventNotify))
        {
            DPF_ERROR("Invalid event at index %lu", i);
        }
    }

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        DPF_ERROR("Can't SetNotificationPositions on MIXIN/FXIN buffers");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Update the settings object
    //

    hr = m_pSettings->SetNotificationPositions(dwNotifyCount, paNotifies);

    //
    // Update the implementation object
    //

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->SetNotificationPositions();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifndef MCPX_BOOT_LIB

/****************************************************************************
 *
 *  CDirectSoundStreamSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStreamSettings::CDirectSoundStreamSettings"

CDirectSoundStreamSettings::CDirectSoundStreamSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundStreamSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStreamSettings::~CDirectSoundStreamSettings"

CDirectSoundStreamSettings::~CDirectSoundStreamSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: stream description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStreamSettings::Initialize"

HRESULT
CDirectSoundStreamSettings::Initialize
(
    LPCDSSTREAMDESC         pdssd
)
{
    DPF_ENTER();

    //
    // Hand off to the base class
    //

    CDirectSoundVoiceSettings::Initialize(pdssd->dwFlags, pdssd->lpwfxFormat, pdssd->lpMixBins);

    //
    // Save stream-specific settings
    //

    m_dwMaxAttachedPackets = pdssd->dwMaxAttachedPackets;
    m_pfnCallback = pdssd->lpfnCallback;
    m_pvContext = pdssd->lpvContext;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  CDirectSoundStream
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: parent DirectSound object
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::CDirectSoundStream"

CDirectSoundStream::CDirectSoundStream
(
    CDirectSound *      pDirectSound
)
:   CDirectSoundVoice(pDirectSound)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundStream
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::~CDirectSoundStream"

CDirectSoundStream::~CDirectSoundStream
(
    void
)
{
    DPF_ENTER();

    //
    // Free the stream implementation
    //

    RELEASE(m_pStream);

    //
    // Free settings
    //

    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSSTREAMDESC [in]: stream description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Initialize"

HRESULT
CDirectSoundStream::Initialize
(
    LPCDSSTREAMDESC         pdssd
)
{                                   
    HRESULT                 hr;

#ifdef VALIDATE_PARAMETERS

    DWORD                   i;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();
    
#ifdef VALIDATE_PARAMETERS

    if(!pdssd)
    {
        DPF_ERROR("DSSTREAMDESC not supplied");
    }

    if(pdssd->dwFlags & ~DSSTREAMCAPS_VALID)
    {
        DPF_ERROR("Specified invalid flags (%lx)", pdssd->dwFlags & ~DSSTREAMCAPS_VALID);
    }
        
    if(!pdssd->lpwfxFormat)
    {
        DPF_ERROR("Failed to specify a stream format");
    }

    if(!FmtIsValid(pdssd->lpwfxFormat))
    {
        DPF_ERROR("Invalid stream format");
    }

    if((pdssd->dwFlags & DSBCAPS_CTRL3D) && (1 != pdssd->lpwfxFormat->nChannels))
    {
        DPF_ERROR("3D streams must be mono");
    }

    if((pdssd->dwFlags & DSSTREAMCAPS_CTRL3D) && !CHrtfSource::IsValidHrtfQuality())
    {
        DPF_ERROR("You must call DirectSoundUseLight/FullHrtf before creating a 3D stream");
    }

    if(pdssd->lpMixBins)
    {
        if(pdssd->lpMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
        {
            DPF_ERROR("No voice can be assigned to more than %lu mix bins", DSMIXBIN_ASSIGNMENT_MAX);
        }

        if(pdssd->lpwfxFormat)
        {
            if(pdssd->lpMixBins->dwMixBinCount % pdssd->lpwfxFormat->nChannels)
            {
                DPF_ERROR("The mixbin count must be a multiple of the channel count");
            }

            if(WAVE_FORMAT_EXTENSIBLE == pdssd->lpwfxFormat->wFormatTag)
            {
                if(((LPCWAVEFORMATEXTENSIBLE)pdssd->lpwfxFormat)->dwChannelMask)
                {
                    DPF_WARNING("Specifying mixbins will override the channel mask specified in the format");
                }
            }
        }

        for(i = 0; i < pdssd->lpMixBins->dwMixBinCount; i++)
        {
            if(pdssd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin > DSMIXBIN_LAST)
            {
                DPF_ERROR("Specified an invalid mixbin");
            }

            if(DSMIXBIN_SUBMIX == pdssd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin)
            {
                DPF_ERROR("Don't assign a voice to DSMIXBIN_SUBMIX.  Instead, call SetOutputBuffer");
            }
        }

        if(pdssd->dwFlags & DSBCAPS_CTRL3D)
        {
            if(pdssd->lpMixBins->dwMixBinCount < DirectSoundRequiredMixBins_3D.dwMixBinCount)
            {
                DPF_ERROR("MixBin count doesn't include enough mixbins to hold all required for 3D");
            }
            
            for(i = 0; i < DirectSoundRequiredMixBins_3D.dwMixBinCount; i++)
            {
                if(pdssd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin != DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[i].dwMixBin)
                {
                    DPF_ERROR("MixBin array does not include the required 3D bins");
                }
            }
        }
    }

    if(!pdssd->dwMaxAttachedPackets)
    {
        DPF_ERROR("dwMaxAttachedPackets must be at least 1");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Create the settings object
    //

    hr = HRFROMP(m_pSettings = NEW(CDirectSoundStreamSettings));

    if(SUCCEEDED(hr))
    {
        hr = m_pSettings->Initialize(pdssd);
    }

    //
    // Create the implementation object
    //
    
    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pStream = NEW(CMcpxStream(m_pDirectSound->m_pDevice, m_pSettings)));
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pStream->Initialize();
    }

    //
    // Initialize the base class
    //

    if(SUCCEEDED(hr))
    {
        CDirectSoundVoice::Initialize(m_pStream, m_pSettings);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the object supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [in/out]: info data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::GetInfo"

HRESULT
CDirectSoundStream::GetInfo
(
    LPXMEDIAINFO            pInfo
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pInfo)
    {
        DPF_ERROR("No XMEDIAINFO buffer supplied");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Flags are easy
    //
    
    pInfo->dwFlags = XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC;

    //
    // The mixer will break up if you queue up less than the mix buffer size
    //

    pInfo->dwMaxLookahead = m_pStream->GetLowWatermark();

    //
    // Input size is just sample-aligment, since that's the smallest amount of
    // data we require to process.
    //

    pInfo->dwInputSize = m_pSettings->m_fmt.nBlockAlign;

    //
    // There is no output
    //

    pInfo->dwOutputSize = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Discontinuity
 *
 *  Description:
 *      Signals a discontinuity in the stream data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Discontinuity"

HRESULT
CDirectSoundStream::Discontinuity
(
    void
)                                       
{                                           
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
    hr = m_pStream->Discontinuity();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Resets the stream to it's default state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Flush"

HRESULT
CDirectSoundStream::Flush
(
    void
)                                       
{                                           
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
    hr = m_pStream->Flush();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets stream status.
 *
 *  Arguments:
 *      LPDWORD [out]: stream status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::GetStatus"

HRESULT
CDirectSoundStream::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwStatus)
    {
        DPF_ERROR("Status buffer not supplied");
    }

#endif // VALIDATE_PARAMETERS

    if(m_pStream->IsReady())
    {
        *pdwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA;
    }
    else
    {
        *pdwStatus = 0;
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Submits buffers to the stream.
 *
 *  Arguments:
 *      LPXMEDIAPACKET  [in]: input buffer.
 *      LPXMEDIAPACKET  [in]: output buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Process"

HRESULT
CDirectSoundStream::Process
(
    LPCXMEDIAPACKET         pxmbSource, 
    LPCXMEDIAPACKET         pxmbDest 
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pxmbSource)
    {
        DPF_ERROR("No input buffer supplied");
    }

    if(!pxmbSource->pvBuffer)
    {
        DPF_ERROR("No input data buffer supplied");
    }

    if(!pxmbSource->dwMaxSize)
    {
        DPF_ERROR("No input buffer size");
    }

    if(pxmbSource->dwMaxSize % m_pSettings->m_fmt.nBlockAlign)
    {
        DPF_ERROR("Input buffer size not block-aligned");
    }

    if(pxmbDest)
    {
        DPF_ERROR("DirectSound streams are input only.  No destination packet should be supplied.");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Make sure the stream is accepting data
    //

    if(!m_pStream->IsReady())
    {
        DPF_ERROR("The stream is not ready to accept more data");
        hr = DSERR_INVALIDCALL;
    }
    
    //
    // Submit the packet to the stream
    //

    if(SUCCEEDED(hr))
    {
        hr = m_pStream->SubmitPacket(*pxmbSource);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Pause
 *
 *  Description:
 *      Pauses or resumes a stream.
 *
 *  Arguments:
 *      DWORD [in]: stream pause state.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundStream::Pause"

HRESULT
CDirectSoundStream::Pause
(
    DWORD                   dwPause
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((dwPause < DSSTREAMPAUSE_FIRST) || (dwPause > DSSTREAMPAUSE_LAST))
    {
        DPF_ERROR("Invalid stream pause state");
    }

#endif // VALIDATE_PARAMETERS

    hr = m_pStream->Pause(dwPause);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#endif // MCPX_BOOT_LIB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsmath.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsmath.cpp
 *  Content:    Math helpers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/24/01    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"


double 
Math::NormalizeDouble
(
    double                  f
)
{
    int                     nClass  = _fpclass(f);
    
    if(nClass & (_FPCLASS_SNAN | _FPCLASS_QNAN))
    {
        DPF_ERROR("floating point error: NAN");
        f = 0.0f;
    }
    else if(nClass & _FPCLASS_NINF)
    {
        DPF_ERROR("floating point error: NINF");
        f = -DBL_MAX;
    }
    else if(nClass & _FPCLASS_PINF)
    {
        DPF_ERROR("floating point error: PINF");
        f = DBL_MAX;
    }

    return f;
}


float 
Math::NormalizeFloat
(
    float                   f
)
{
    int                     nClass  = _fpclass(f);
    
    if(nClass & (_FPCLASS_SNAN | _FPCLASS_QNAN))
    {
        DPF_ERROR("floating point error: NAN");
        f = 0.0f;
    }
    else if(nClass & _FPCLASS_NINF)
    {
        DPF_ERROR("floating point error: NINF");
        f = -FLT_MAX;
    }
    else if(nClass & _FPCLASS_PINF)
    {
        DPF_ERROR("floating point error: PINF");
        f = FLT_MAX;
    }

    return f;
}


double 
Math::NormalizeVector3
(
    D3DVECTOR *             pdst, 
    double                  x, 
    double                  y, 
    double                  z
)
{
    double                  magnitude;

    if(!x && !y && !z)
    {
        pdst->x = 0.0f;
        pdst->y = 0.0f;
        pdst->z = 0.0f;

        return 0.0f;
    }
    else if((FLT_MAX == x) || (FLT_MAX == y) || (FLT_MAX == z))
    {
        pdst->x = (float)x;
        pdst->y = (float)y;
        pdst->z = (float)z;

        return FLT_MAX;
    }

    magnitude = MagnitudeVector3(x, y, z);
    ASSERT(magnitude > 0.0f);

    pdst->x = (float)(x / magnitude);
    pdst->y = (float)(y / magnitude);
    pdst->z = (float)(z / magnitude);

    return magnitude;
}


float 
Math::NormalizeVector3
(
    D3DVECTOR *             pdst, 
    const D3DVECTOR *       psrc
)
{
    float                   magnitude;

    if(!psrc->x && !psrc->y && !psrc->z)
    {
        pdst->x = 0.0f;
        pdst->y = 0.0f;
        pdst->z = 0.0f;

        return 0.0f;
    }
    else if((FLT_MAX == psrc->x) || (FLT_MAX == psrc->y) || (FLT_MAX == psrc->z))
    {
        pdst->x = psrc->x;
        pdst->y = psrc->y;
        pdst->z = psrc->z;

        return FLT_MAX;
    }

    magnitude = MagnitudeVector3(psrc);
    ASSERT(magnitude > 0.0f);

    pdst->x = psrc->x / magnitude;
    pdst->y = psrc->y / magnitude;
    pdst->z = psrc->z / magnitude;

    return magnitude;
}


float 
Math::NormalizeVector3
(
    D3DVECTOR *             pdst
)
{
    float                   magnitude;

    if(!pdst->x && !pdst->y && !pdst->z)
    {
        return 0.0f;
    }
    else if((FLT_MAX == pdst->x) || (FLT_MAX == pdst->y) || (FLT_MAX == pdst->z))
    {
        return FLT_MAX;
    }

    magnitude = MagnitudeVector3(pdst);
    ASSERT(magnitude > 0.0f);

    pdst->x = pdst->x / magnitude;
    pdst->y = pdst->y / magnitude;
    pdst->z = pdst->z / magnitude;

    return magnitude;
}


double 
Math::NormalizeVector2
(
    D3DVECTOR *             pdst, 
    double                  x, 
    double                  z
)
{
    double                  magnitude;

    pdst->y = 0.0f;

    if(!x && !z)
    {
        pdst->x = 0.0f;
        pdst->z = 0.0f;

        return 0.0f;
    }
    else if((FLT_MAX == x) || (FLT_MAX == z))
    {
        pdst->x = (float)x;
        pdst->z = (float)z;

        return FLT_MAX;
    }

    magnitude = MagnitudeVector2(x, z);
    ASSERT(magnitude > 0.0f);

    pdst->x = (float)(x / magnitude);
    pdst->z = (float)(z / magnitude);

    return magnitude;
}


float 
Math::NormalizeVector2
(
    D3DVECTOR *             pdst, 
    const D3DVECTOR *       psrc
)
{
    float                   magnitude;

    pdst->y = 0.0f;
    
    if(!psrc->x && !psrc->z)
    {
        pdst->x = 0.0f;
        pdst->z = 0.0f;

        return 0.0f;
    }
    else if((FLT_MAX == psrc->x) || (FLT_MAX == psrc->z))
    {
        pdst->x = psrc->x;
        pdst->z = psrc->z;

        return FLT_MAX;
    }

    magnitude = MagnitudeVector2(psrc);
    ASSERT(magnitude > 0.0f);

    pdst->x = psrc->x / magnitude;
    pdst->z = psrc->z / magnitude;

    return magnitude;
}


float 
Math::NormalizeVector2
(
    D3DVECTOR *             pdst
)
{
    float                   magnitude;

    pdst->y = 0.0f;
    
    if(!pdst->x && !pdst->z)
    {
        return 0.0f;
    }
    else if((FLT_MAX == pdst->x) || (FLT_MAX == pdst->z))
    {
        return FLT_MAX;
    }

    magnitude = MagnitudeVector2(pdst);
    ASSERT(magnitude > 0.0f);

    pdst->x = pdst->x / magnitude;
    pdst->z = pdst->z / magnitude;

    return magnitude;
}


long 
Math::RatioToPitch
(
    float                   flRatio
)
{
    const float             fl4096  = 4096.0f;
    long                    lPitch;

    ASSERT(flRatio);

    __asm 
    {
        fld     fl4096
        fld     flRatio
        fyl2x
        fistp   lPitch
    }

    return lPitch;
}


//
// sincosf - Compute the sin and cos of an angle at the same time
//

static inline void
sincosf(float angle, float *psin, float *pcos)
{
#ifdef _X86_
#define fsincos __asm _emit 0xd9 __asm _emit 0xfb
    __asm {
        mov eax, psin
        mov edx, pcos
        fld angle
        fsincos
        fstp DWORD ptr [edx]
        fstp DWORD ptr [eax]
    }
#undef fsincos
#else //!_X86_
    *psin = sinf(angle);
    *pcos = cosf(angle);
#endif //!_X86_
}

D3DMATRIX* 
Math::MatrixRotationAxis
( 
    D3DMATRIX *             pOut, 
    const D3DVECTOR *       pV, 
    float                   angle 
)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);
    float c1 = 1 - c;

    D3DVECTOR v = *pV;
    NormalizeVector3(&v, &v);

    float xyc1 = v.x * v.y * c1;
    float yzc1 = v.y * v.z * c1;
    float zxc1 = v.z * v.x * c1;

    pOut->_11 = v.x * v.x * c1 + c;
    pOut->_12 = xyc1 + v.z * s;
    pOut->_13 = zxc1 - v.y * s;
    pOut->_14 = 0.0f;

    pOut->_21 = xyc1 - v.z * s;
    pOut->_22 = v.y * v.y * c1 + c;
    pOut->_23 = yzc1 + v.x * s;
    pOut->_24 = 0.0f;

    pOut->_31 = zxc1 + v.y * s;
    pOut->_32 = yzc1 - v.x * s;
    pOut->_33 = v.z * v.z * c1 + c;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

VECTOR4* 
Math::Vec3Transform
( 
    VECTOR4 *               pOut, 
    const D3DVECTOR *       pV, 
    const D3DMATRIX *       pM 
)
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
    if ((ULONG_PTR)pM & 0xF)
    {
        DPF_ERROR("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif

#ifdef _X86_
    __asm {
        mov     eax, pV
        mov     ecx, pM
        movss   xmm2, [eax]             // pV->x
        shufps  xmm2, xmm2, 0           // Fill xmm2 with x
        mulps   xmm2, [ecx]             // x*pM->_11, x*pM->_12, x*pM->_13, x*pM->_14

        movss   xmm1, [eax+4]           // pV->y
        shufps  xmm1, xmm1, 0           // Fill xmm1 with y
        mulps   xmm1, [ecx+16]          // y*pM->_21, y*pM->_22, y*pM->_23, y*pM->_24

        movss   xmm3, [eax+8]
        shufps  xmm3, xmm3, 0           // Fill xmm3 with z
        mulps   xmm3, [ecx+32]          // z*pM->_31, z*pM->_32, z*pM->_33, z*pM->_34

        addps   xmm2, [ecx + 48]        // Add the last row of the matrix
        mov     eax,  pOut
        addps   xmm2, xmm1
        addps   xmm2, xmm3
        movups  [eax], xmm2             // Output result
    }
#else // !_X86_
    XGVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsndver.h ===
#include <xboxverp.h>

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(push)
#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_DSoundBuildNumberD")
__declspec(selectany) unsigned short DSoundBuildNumberD[8] = { 'D' | ('S' << 8), 'O' | ('U' << 8), 'N' | ('D' << 8), 'D',
                                        VER_PRODUCTVERSION | 0x8000 };
#elif LTCG
#pragma comment(linker, "/include:_DSoundBuildNumberL")
__declspec(selectany) unsigned short DSoundBuildNumberL[8] = { 'D' | ('S' << 8), 'O' | ('U' << 8), 'N' | ('D' << 8),  'L' | ('T' << 8),
                                        VER_PRODUCTVERSION | 0x4000 };
#else
#pragma comment(linker, "/include:_DSoundBuildNumber")
__declspec(selectany) unsigned short DSoundBuildNumber[8] = { 'D' | ('S' << 8), 'O' | ('U' << 8), 'N' | ('D' << 8), 0,
                                        VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg(pop)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsoundi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsoundi.h
 *  Content:    DirectSound master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/00    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSOUNDI_H__
#define __DSOUNDI_H__

//
// Enable recovery of unused physical memory
//

#define ENABLE_SLOP_MEMORY_RECOVERY

//
// Put all code and data into a DSOUND section
//

#pragma code_seg("DSOUND")
#pragma data_seg("DSOUND_RW")
#pragma const_seg("DSOUND_RD")
#pragma bss_seg("DSOUND_URW")

//
// Common includes
//

#include "dscommon.h"

//
// Missing types
//

DEFINEREFTYPE(DS3DLISTENER);
DEFINEREFTYPE(DS3DBUFFER);
DEFINEREFTYPE(DSI3DL2LISTENER);
DEFINEREFTYPE(DSI3DL2BUFFER);
DEFINEREFTYPE(XMEDIAPACKET);
DEFINELPCTYPE(LONG);
DEFINELPCTYPE(DWORD);

//
// Private includes
//

#include "dsmath.h"
#include "heap.h"
#include "hrtf.h"
#include "i3dl2.h"
#include "ac97.h"
#include "dsp.h"
#include "cipher.h"
#include "dsapi.h"
#include "dsperf.h"
#include "mcpxcore.h"
#include "wavexmo.h"
#include "ac97xmo.h"

#endif // __DSOUNDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dspbootsndcode.h ===
0x0BF080, 
0x0000AC, 
0x300000, 
0x44F400, 
0x004000, 
0x445800, 
0x44F400, 
0x080403, 
0x445800, 
0x44F400, 
0x000201, 
0x445800, 
0x44F400, 
0x000C00, 
0x445800, 
0x2E0000, 
0x0BF080, 
0x000029, 
0x0BF080, 
0x000020, 

0x08F484, 
0x000001, 

0x0BF080, 
0x0000B7, 
0x0BF080, 
0x000021, 
0x0BF080, 
0x000022, 
0x2E0000, 
0x0BF080, 
0x00007D, 
0x050FD5, 
0x00000C, 
0x00000C, 
0x65F400, 
0x000004, 
0x66F400, 
0x000204, 
0x0BF080, 
0x0000C8, 
0x00000C, 

0x0D1080, 
0x000038, 

0x08F497, 
0x000000, 

0x0140C6, 
0x003FFF, 
0x08CE15, 
0x08CE14, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x0059E0, 
0x0200CE, 
0x0A7093, 
0x000002, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x0059E2, 
0x0200CE, 
0x0A7093, 
0x000002, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 

0x08F496, 
0x000001, 
0x0CD604, 
0x000000, 
0x00000C, 
0x08F496, 
0x000002, 
0x0CD624, 
0x000000, 
0x00000C, 
0x08F496, 
0x000003, 
0x0CD603, 
0x000000, 
0x00000C, 
0x08F496, 
0x000002, 
0x0CD624, 
0x000000, 
0x08F496, 
0x000003, 
0x0CD603, 
0x000000, 
0x00000C, 
0x08F496, 
0x000004, 
0x0CD623, 
0x000000, 
0x00000C, 
0x08F496, 
0x000004, 
0x0CD623, 
0x000000, 
0x08F496, 
0x000001, 
0x0CD604, 
0x000000, 
0x00000C, 
0x0CC507, 
0x000000, 
0x08F485, 
0x000080, 
0x00000C, 
0x050BC4, 
0x0140C6, 
0xFFDFFF, 
0x08CE14, 
0x050BCE, 
0x050BD6, 
0x00000C, 
0x050B9D, 
0x0140C6, 
0xFFDFFF, 
0x08CE14, 
0x050BC7, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x005BE2, 
0x0200CE, 
0x56F400, 
0x000020, 
0x02088E, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x005BE0, 
0x0200CE, 
0x56F400, 
0x000020, 
0x02088E, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 

0x08F485, 
0x000FFF, 

0x60F400, 
0x000000, 
0x44F400, 
0x001000, 
0x0BF080, 
0x0000BC, 
0x0BF080, 
0x0000C0, 
0x00000C, 
0x0A8581, 
0x0000B7, 
0x08F485, 
0x000002, 
0x00000C, 
0x200013, 
0x06C420, 
0x565800, 
0x00000C, 
0x60F400, 
0x000000, 
0x44F400, 
0x000800, 
0x200013, 
0x06C420, 
0x5E5800, 
0x00000C, 

0x021594, 
0x0CC4A0, 
0x000025, 
0x0AC460, 
0x021584, 

0x0D1080, 
0x0003DC, 
0x44F400, 
0x00C000, 
0x020584, 
0x44F400, 
0x001560, 
0x46F400, 
0x001560, 
0x0215C4, 
0x021D86, 
0x44F400, 
0x000C00, 
0x45F400, 
0x000C20, 
0x46F400, 
0x000C80, 
0x47F400, 
0x000CA0, 
0x021DC4, 
0x022585, 
0x0225C6, 
0x022D87, 
0x22CE00, 
0x0405B0, 
0x061F90, 
0x000003, 
0x565800, 
0x016080, 
0x0D1080, 
0x000419, 
0x0D1080, 
0x000139, 
0x021594, 
0x0CC482, 
0x000006, 
0x0AC442, 
0x021584, 
0x0D1080, 
0x00013B, 
0x0D1080, 
0x00014D, 

0x00000C, 

0x062090, 
0x000003, 
0x44D800, 
0x445900, 
0x00000C, 
0x062090, 
0x000004, 
0x45E000, 
0x2000A0, 
0x565800, 
0x00000C, 
0x062090, 
0x000005, 
0x45D800, 
0x56E100, 
0x2000A3, 
0x565900, 
0x00000C, 
0x062090, 
0x000005, 
0x44D800, 
0x56E100, 
0x200040, 
0x565900, 
0x00000C, 
0x062090, 
0x000005, 
0x44D800, 
0x56D900, 
0x200040, 
0x565A00, 
0x00000C, 
0x062090, 
0x000004, 
0x56E000, 
0x0C1E48, 
0x565800, 
0x00000C, 
0x062090, 
0x000006, 
0x47D800, 
0x56E100, 
0x2000C3, 
0x0C1E4C, 
0x565900, 
0x00000C, 

0x0D1080, 
0x00000D, 
0x00000C, 
0x2E0000, 
0x0A758E, 
0x0001F0, 
0x0A758E, 
0x0001E1, 
0x56F400, 
0x000001, 
0x0A758E, 
0x0001E0, 
0x00000C, 
0x56F400, 
0xFFFFFF, 
0x0A758E, 
0x0001F0, 
0x2E0000, 
0x0A758E, 
0x0001E1, 
0x0A758E, 
0x0001E0, 
0x00000C, 
0x0D1080, 
0x0000C1, 
0x0D1080, 
0x000003, 
0x00000C, 
0x0A75CE, 
0x0001E0, 
0x014085, 
0x0D104A, 
0x000025, 
0x0A75CE, 
0x0001E1, 
0x014085, 
0x0D104A, 
0x000021, 
0x0140C5, 
0x000100, 
0x0D104A, 
0x000092, 
0x0140C5, 
0x000200, 
0x0D104A, 
0x0000A3, 
0x0A75D0, 
0x0001E4, 
0x0A70D0, 
0x000003, 
0x0A75CF, 
0x0001E3, 
0x0A75C6, 
0x0001E2, 
0x062090, 
0x000006, 
0x21E500, 
0x44E000, 
0x2000A0, 
0x565800, 
0x200058, 
0x0A758F, 
0x0001E3, 
0x0A75CE, 
0x0001E1, 
0x016080, 
0x0A758E, 
0x0001E1, 
0x00000C, 
0x0A75C4, 
0x0001E0, 
0x0CC4A0, 
0x000018, 
0x0CC4A5, 
0x000025, 
0x0CC4AD, 
0x000052, 
0x0CC4B1, 
0x00003B, 
0x0CC4B3, 
0x00007F, 
0x0A75CE, 
0x0001E4, 
0x014780, 
0x0A758E, 
0x0001E4, 
0x0A75CE, 
0x0001E5, 
0x0A75C4, 
0x0001E6, 
0x200040, 
0x0A758E, 
0x0001E5, 
0x0D10C0, 
0x000054, 
0x22AE00, 
0x0140C0, 
0x000046, 
0x0A758E, 
0x0001E7, 
0x0140C0, 
0x000059, 
0x0A758E, 
0x0001E5, 
0x0140C0, 
0x000062, 
0x0A758E, 
0x0001E4, 
0x0D10C0, 
0x000042, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x0A758E, 
0x0001E5, 
0x0140C0, 
0x000085, 
0x0A758E, 
0x0001E4, 
0x0140C0, 
0xFFFF6F, 
0x21D000, 
0x0A75C4, 
0x00004B, 
0x0140C0, 
0x000155, 
0x21D100, 
0x0A758E, 
0x0001E7, 
0x060890, 
0x000004, 
0x56D800, 
0x200040, 
0x565900, 
0x0D10C0, 
0x000028, 
0x22AE00, 
0x0140C0, 
0x0000F3, 
0x0A758E, 
0x0001E5, 
0x0140C0, 
0x0000D9, 
0x0A758E, 
0x0001E4, 
0x015C80, 
0x21D000, 
0x0A758E, 
0x0001E7, 
0x0A75CE, 
0x000058, 
0x565800, 
0x566000, 
0x56F400, 
0x000007, 
0x0D10C0, 
0x000014, 
0x22AE00, 
0x0140C0, 
0x000054, 
0x0A758E, 
0x0001E7, 
0x0140C0, 
0x000067, 
0x0A758E, 
0x0001E5, 
0x0140C0, 
0x0000D9, 
0x0A758E, 
0x0001E4, 
0x56F400, 
0x000007, 
0x0D10C0, 
0x000003, 
0x200013, 
0x0A758E, 
0x0001E6, 
0x56F400, 
0xFF8000, 
0x0A758E, 
0x0001E2, 
0x56F400, 
0x7F8000, 
0x0A758E, 
0x0001E3, 
0x050ED5, 
0x0A75D0, 
0x0001E7, 
0x56D800, 
0x0A7590, 
0x0001E7, 
0x016084, 
0x014085, 
0x202913, 
0x21C500, 
0x0A75D0, 
0x0001E5, 
0x0A75D1, 
0x0001E4, 
0x0D1080, 
0x0002B0, 
0x56F400, 
0x008000, 
0x0A758E, 
0x0001E2, 
0x050EC1, 
0x050A5F, 
0x2E0000, 
0x0A758E, 
0x0001E1, 
0x0A75CE, 
0x0001E0, 
0x200032, 
0x0A758E, 
0x0001E0, 
0x050ECD, 
0x0A75CE, 
0x0001F0, 
0x014085, 
0x0D1049, 
0x00001A, 
0x22AF00, 
0x0140C8, 
0x000063, 
0x21F000, 
0x0140C8, 
0x000177, 
0x21F100, 
0x0140C5, 
0x000150, 
0x0D104A, 
0x000010, 
0x014180, 
0x0A758E, 
0x0001F0, 
0x060690, 
0x000009, 
0x56E100, 
0x57D800, 
0x200014, 
0x21C600, 
0x0141D0, 
0x7C49BA, 
0x200018, 
0x575900, 
0x00000C, 
0x060690, 
0x000003, 
0x44D800, 
0x445900, 
0x56F400, 
0xFFFFFF, 
0x0A758E, 
0x0001F0, 
0x050FD7, 

0x0D1080, 
0x00001C, 
0x0D1080, 
0x00000E, 
0x0D1080, 
0xFFFEFD, 
0x0D1080, 
0x000182, 
0x00000C, 
0x0D1080, 
0x000013, 
0x0D1080, 
0xFFFEF9, 
0x0D1080, 
0x000239, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x0001DA, 
0x21D000, 
0x0140C0, 
0xFFFE89, 
0x21D100, 
0x060690, 
0x000003, 
0x44D900, 
0x445800, 
0x00000C, 
0x00000C, 
0x0D1080, 
0x000154, 
0x05F420, 
0xFFFFFF, 
0x0461A0, 
0x0462A0, 
0x0463A0, 
0x0464A0, 
0x0465A0, 
0x244000, 
0x0A75D0, 
0x000005, 
0x0D1080, 
0xFFFEAF, 
0x0A75D0, 
0x000005, 
0x22AE00, 
0x0140C0, 
0x00006A, 
0x21D100, 
0x0D1080, 
0x00014C, 
0x0D1080, 
0xFFFE20, 
0x0D1080, 
0xFFFEE3, 
0x0A75D1, 
0x00000C, 
0x060490, 
0x000006, 
0x0A75D0, 
0x00000B, 
0x0D1080, 
0xFFFEA8, 
0x22AE00, 
0x0A75D0, 
0x000020, 
0x0A75D1, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x00008F, 
0x21D200, 
0x060490, 
0x000005, 
0x44DA00, 
0x0D1080, 
0xFFFE93, 
0x22AE00, 
0x0140C0, 
0x000059, 
0x21D300, 
0x0A75D0, 
0x000010, 
0x0A75D2, 
0x000024, 
0x3A2000, 
0x060490, 
0x000009, 
0x060290, 
0x000006, 
0x225100, 
0x44DB00, 
0x0D1080, 
0xFFFE82, 
0x000000, 
0x44CA00, 
0x0A75D0, 
0x000019, 
0x0A75D1, 
0x00001A, 
0x0A75D2, 
0x000014, 
0x0D1080, 
0xFFFE86, 
0x0A75D0, 
0x000018, 
0x0D1080, 
0xFFFE82, 
0x0A75D0, 
0x00001C, 
0x0A75D1, 
0x000014, 
0x0D1080, 
0xFFFE75, 
0x0D1080, 
0xFFFE73, 
0x0A75D0, 
0x00001F, 
0x0A75D1, 
0x000014, 
0x0D1080, 
0xFFFE6D, 
0x0A75D0, 
0x00001E, 
0x0D1080, 
0xFFFE69, 
0x0A75D0, 
0x000014, 
0x0A75D1, 
0x000015, 
0x0A75D2, 
0x000016, 
0x0D1080, 
0xFFFE68, 
0x0A75D0, 
0x000016, 
0x0A75C4, 
0x000062, 
0x0D1080, 
0xFFFE4E, 
0x0A75D0, 
0x000014, 
0x0A75C4, 
0x000061, 
0x0D1080, 
0xFFFE48, 
0x0D1080, 
0xFFFE46, 
0x0A75D0, 
0x000028, 
0x0A75D1, 
0x000014, 
0x0D1080, 
0xFFFE4D, 
0x0D1080, 
0xFFFE4B, 
0x0A75D0, 
0x000014, 
0x0A75D1, 
0x000028, 
0x0D1080, 
0xFFFE33, 
0x0D1080, 
0xFFFE31, 
0x0A75D0, 
0x000014, 
0x22AE00, 
0x0140C0, 
0x000082, 
0x21D100, 
0x0D1080, 
0x0000D3, 
0x22AE00, 
0x0140C0, 
0x000085, 
0x21D100, 
0x0D1080, 
0x0000CD, 
0x0A75D0, 
0x000019, 
0x22AE00, 
0x0140C0, 
0x00006D, 
0x21D100, 
0x382000, 
0x390300, 
0x060390, 
0x000005, 
0x0D1080, 
0x0000C1, 
0x44C800, 
0x44C900, 
0x0A75D4, 
0x000010, 
0x22AE00, 
0x0140C0, 
0x00008B, 
0x21D300, 
0x382000, 
0x060490, 
0x000010, 
0x0A75D1, 
0x000024, 
0x062090, 
0x00000B, 
0x223000, 
0x227200, 
0x200013, 
0x060490, 
0x000004, 
0x44C800, 
0x45DA00, 
0x2000A3, 
0x565C00, 
0x44D900, 
0x44D300, 
0x0A75D1, 
0x000010, 
0x060490, 
0x000006, 
0x0A75D0, 
0x000016, 
0x0D1080, 
0xFFFE07, 
0x22AE00, 
0x3B0300, 
0x0A75D0, 
0x000010, 
0x0140C0, 
0x000076, 
0x21D300, 
0x060490, 
0x000005, 
0x227100, 
0x0D1080, 
0x000093, 
0x44CB00, 
0x0A75D0, 
0x000005, 
0x0A75D1, 
0x00000B, 
0x0D1080, 
0xFFFDE2, 
0x0A75D1, 
0x00000C, 
0x0A75D2, 
0x000024, 
0x0A75D3, 
0x000028, 
0x0A75D4, 
0x000020, 
0x22AE00, 
0x0140C0, 
0x0001DA, 
0x21D000, 
0x0A75C6, 
0x0001DE, 
0x0A75C7, 
0x0001DF, 
0x0A75CE, 
0x000069, 
0x014485, 
0x0D104A, 
0x000006, 
0x0D1080, 
0x00003A, 
0x0D10C0, 
0x000006, 
0x0D1080, 
0x00004A, 
0x0A75D4, 
0x000022, 
0x0A75D1, 
0x00000E, 
0x0A75D2, 
0x000026, 
0x22AE00, 
0x0140C0, 
0x0001DC, 
0x21D000, 
0x0A75C6, 
0x0001DE, 
0x0A75C7, 
0x0001DF, 
0x0A75CE, 
0x000069, 
0x014485, 
0x0D104A, 
0x000006, 
0x0D1080, 
0x000021, 
0x0D10C0, 
0x000010, 
0x0D1080, 
0x000031, 
0x0A75D0, 
0x000022, 
0x0A75D1, 
0x000009, 
0x0D1080, 
0xFFFDBA, 
0x0A75D0, 
0x000023, 
0x0A75D1, 
0x00000A, 
0x0D1080, 
0xFFFDB4, 
0x0A75D0, 
0x000020, 
0x0A75D1, 
0x000007, 
0x0D1080, 
0xFFFDAE, 
0x0A75D0, 
0x000021, 
0x0A75D1, 
0x000008, 
0x0D1080, 
0xFFFDA8, 
0x0D1080, 
0x000038, 
0x00000C, 
0x392000, 
0x3A2000, 
0x44D800, 
0x062090, 
0x00000F, 
0x45E900, 
0x44D000, 
0x2000A0, 
0x45D900, 
0x44D800, 
0x2000A3, 
0x45EA00, 
0x2000E3, 
0x45DA00, 
0x2000E3, 
0x45DB00, 
0x2000F3, 
0x0C1D0E, 
0x565C00, 
0x00000C, 
0x3C2000, 
0x3A2000, 
0x392000, 
0x44D800, 
0x20CE00, 
0x200022, 
0x21C600, 
0x062090, 
0x000012, 
0x45E900, 
0x44D000, 
0x2000A8, 
0x45D900, 
0x44D800, 
0x2000A0, 
0x45EA00, 
0x2000EB, 
0x45DA00, 
0x2000E3, 
0x45DB00, 
0x2000FB, 
0x2000F3, 
0x0C1D8F, 
0x0C1D0E, 
0x576C00, 
0x565C00, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x000101, 
0x0D1080, 
0xFFFCEB, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x0D1080, 
0xFFFCDE, 
0x00000C, 
0x0201D6, 
0x020997, 
0x062090, 
0x000007, 
0x020194, 
0x2000D0, 
0x45E000, 
0x2000F2, 
0x02018E, 
0x565800, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x21D000, 
0x380700, 
0x280000, 
0x2C2000, 
0x44F400, 
0x004BD2, 
0x46F400, 
0x00000E, 
0x0D1080, 
0x00005B, 
0x44F400, 
0x004BD0, 
0x46F400, 
0x00001F, 
0x0D1080, 
0x000055, 
0x05F420, 
0xFFFFFF, 
0x380700, 
0x22AE00, 
0x0140C0, 
0x0000A2, 
0x21D000, 
0x022DDE, 
0x564800, 
0x0265DE, 
0x060390, 
0x000004, 
0x564800, 
0x0140C0, 
0x000040, 
0x02359E, 
0x060890, 
0x000003, 
0x564800, 
0x016080, 
0x02559E, 
0x060290, 
0x000003, 
0x564800, 
0x016080, 
0x22AE00, 
0x0140C0, 
0x000104, 
0x21D000, 
0x380700, 
0x022DDE, 
0x061F90, 
0x000003, 
0x564800, 
0x016080, 
0x22AE00, 
0x0140C0, 
0x000101, 
0x21D000, 
0x22AE00, 
0x016A80, 
0x21D100, 
0x44E100, 
0x0201D5, 
0x060D90, 
0x000004, 
0x0210C4, 
0x021885, 
0x54C800, 
0x060490, 
0x000009, 
0x44D900, 
0x45D900, 
0x060290, 
0x000004, 
0x0210C4, 
0x021885, 
0x54C800, 
0x000000, 
0x060A90, 
0x000006, 
0x44D900, 
0x0210C4, 
0x45D900, 
0x021885, 
0x54C800, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x21D000, 
0x22AE00, 
0x016A80, 
0x21D100, 
0x060E90, 
0x000006, 
0x44D900, 
0x0210C4, 
0x45D900, 
0x021885, 
0x54C800, 
0x0D1080, 
0x000011, 
0x00000C, 
0x221100, 
0x06C610, 
0x000008, 
0x0A7190, 
0x000000, 
0x0200C4, 
0x02088C, 
0x021088, 
0x221100, 
0x45C800, 
0x44F400, 
0x004000, 
0x446100, 
0x00000C, 
0x0D1080, 
0x000005, 
0x0D1080, 
0x000048, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x000046, 
0x21D200, 
0x0140C0, 
0x000059, 
0x21D000, 
0x0140C0, 
0x000062, 
0x21D100, 
0x260000, 
0x47F400, 
0x000005, 
0x0D1080, 
0x000060, 
0x22AE00, 
0x0140C0, 
0x000093, 
0x21D200, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x21D000, 
0x0140C0, 
0x000085, 
0x21D100, 
0x0A75C6, 
0x00004B, 
0x47F400, 
0x000008, 
0x0D1080, 
0x00004F, 
0x22AE00, 
0x0140C0, 
0x000054, 
0x21D200, 
0x0140C0, 
0x000067, 
0x21D000, 
0x0140C0, 
0x0000D9, 
0x21D100, 
0x380700, 
0x390700, 
0x060490, 
0x000006, 
0x45DA00, 
0x0D1080, 
0x000048, 
0x44C800, 
0x44C900, 
0x22AE00, 
0x0140C0, 
0x0000F3, 
0x21D000, 
0x0140C0, 
0x0000D9, 
0x21D100, 
0x380700, 
0x390700, 
0x060290, 
0x000007, 
0x0A75C5, 
0x000058, 
0x0D1080, 
0x000037, 
0x44C800, 
0x44C900, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x00004C, 
0x21D200, 
0x0140C0, 
0x000053, 
0x21D000, 
0x0140C0, 
0x0000BD, 
0x21D100, 
0x380700, 
0x060490, 
0x000007, 
0x260000, 
0x47F400, 
0x000002, 
0x0D1080, 
0x000018, 
0x44C800, 
0x22AE00, 
0x0140C0, 
0x0000D7, 
0x21D000, 
0x0140C0, 
0x0000D9, 
0x21D100, 
0x22AE00, 
0x0140C0, 
0x00009B, 
0x21D200, 
0x380700, 
0x390700, 
0x060490, 
0x000006, 
0x45DA00, 
0x0D1080, 
0x00000F, 
0x44C800, 
0x44C900, 
0x00000C, 
0x390700, 
0x06C710, 
0x000007, 
0x56DA00, 
0x200050, 
0x21C500, 
0x0D1080, 
0x000004, 
0x44C900, 
0x00000C, 
0x02109F, 
0x20006C, 
0x0140CE, 
0xFFFFFC, 
0x01408D, 
0x0D1041, 
0x000005, 
0x021894, 
0x200048, 
0x014188, 
0x02118F, 
0x00000C, 

0x44F400, 
0x000088, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0x400000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0x00008F, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0xCCCCCD, 
0x445800, 
0x44F400, 
0x333333, 
0x445800, 
0x44F400, 
0xCCCCCD, 
0x445800, 
0x44F400, 
0xCCCCCD, 
0x445800, 
0x44F400, 
0x000093, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x0001D0, 
0x445800, 
0x44F400, 
0x000430, 
0x445800, 
0x44F400, 
0x000740, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x0001D0, 
0x445800, 
0x44F400, 
0x000430, 
0x445800, 
0x44F400, 
0x000740, 
0x445800, 
0x44F400, 
0x00009B, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0x00AE00, 
0x445800, 
0x44F400, 
0x00FF80, 
0x445800, 
0x44F400, 
0x00D2C0, 
0x445800, 
0x44F400, 
0x0135C0, 
0x445800, 
0x00000C, 
0x200013, 
0x44F400, 
0x00002A, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0x00C000, 
0x445800, 
0x44F400, 
0x00BB7F, 
0x445800, 
0x44F400, 
0x017B80, 
0x445800, 
0x44F400, 
0x00BB7F, 
0x445800, 
0x44F400, 
0x023700, 
0x445800, 
0x44F400, 
0x00BB7F, 
0x445800, 
0x44F400, 
0x02F280, 
0x445800, 
0x44F400, 
0x00BB7F, 
0x445800, 
0x44F400, 
0x03AE00, 
0x445800, 
0x44F400, 
0x00153F, 
0x445800, 
0x44F400, 
0x03C340, 
0x445800, 
0x44F400, 
0x00132F, 
0x445800, 
0x44F400, 
0x03D670, 
0x445800, 
0x44F400, 
0x00140F, 
0x445800, 
0x44F400, 
0x03EA80, 
0x445800, 
0x44F400, 
0x00167F, 
0x445800, 
0x44F400, 
0x040100, 
0x445800, 
0x44F400, 
0x002B7F, 
0x445800, 
0x44F400, 
0x042C80, 
0x445800, 
0x44F400, 
0x0034AF, 
0x445800, 
0x44F400, 
0x046130, 
0x445800, 
0x44F400, 
0x003FDF, 
0x445800, 
0x44F400, 
0x04A110, 
0x445800, 
0x44F400, 
0x004D6F, 
0x445800, 
0x44F400, 
0x04EE80, 
0x445800, 
0x44F400, 
0x01E8BF, 
0x445800, 
0x44F400, 
0x06D740, 
0x445800, 
0x44F400, 
0x01E8BF, 
0x445800, 
0x44F400, 
0x000540, 
0x445800, 
0x44F400, 
0x000620, 
0x445800, 
0x44F400, 
0x0005D0, 
0x445800, 
0x44F400, 
0x0006B0, 
0x445800, 
0x44F400, 
0x000730, 
0x445800, 
0x44F400, 
0x000830, 
0x445800, 
0x44F400, 
0x001E00, 
0x445800, 
0x44F400, 
0x000FE0, 
0x445800, 
0x44F400, 
0x008D50, 
0x445800, 
0x44F400, 
0x00BB80, 
0x445800, 
0x44F400, 
0x00AB40, 
0x445800, 
0x44F400, 
0x00BA10, 
0x445800, 
0x44F400, 
0x00AB40, 
0x445800, 
0x44F400, 
0x0065C0, 
0x445800, 
0x44F400, 
0x0004C0, 
0x445800, 
0x44F400, 
0x000470, 
0x445800, 
0x44F400, 
0x0004A0, 
0x445800, 
0x44F400, 
0x000520, 
0x445800, 
0x44F400, 
0x01E8C0, 
0x445800, 
0x44F400, 
0x7FFFFF, 
0x445800, 
0x44F400, 
0x800001, 
0x445800, 
0x44F400, 
0x800001, 
0x445800, 
0x44F400, 
0x7FFFFF, 
0x445800, 
0x44F400, 
0x7FFFFF, 
0x445800, 
0x44F400, 
0x7FFFFF, 
0x445800, 
0x44F400, 
0x800001, 
0x445800, 
0x44F400, 
0x800001, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x199999, 
0x445800, 
0x44F400, 
0x001E23, 
0x445800, 
0x44F400, 
0x001B7E, 
0x445800, 
0x44F400, 
0x001C8D, 
0x445800, 
0x44F400, 
0x001FB9, 
0x445800, 
0x44F400, 
0x0108FF, 
0x445800, 
0x44F400, 
0x0108FF, 
0x445800, 
0x44F400, 
0x000002, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x6C5A41, 
0x445800, 
0x44F400, 
0x13A5BF, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x62F77D, 
0x445800, 
0x44F400, 
0x091E2F, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x62F77D, 
0x445800, 
0x44F400, 
0x091E2F, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x62F77D, 
0x445800, 
0x44F400, 
0x091E2F, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x385F2C, 
0x445800, 
0x44F400, 
0x36C675, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x3DADA9, 
0x445800, 
0x44F400, 
0x2FEF6E, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x433C8E, 
0x445800, 
0x44F400, 
0x28FC95, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x48BA8F, 
0x445800, 
0x44F400, 
0x2246D7, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x7E6CD8, 
0x445800, 
0x44F400, 
0x0003E9, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x7E6CD8, 
0x445800, 
0x44F400, 
0x0003E9, 
0x445800, 
0x00000C, 

0x000000,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dspdma.cpp ===
/************************Object to do DSP memory management*****************\
*                                                                           *
* History:                                                                  *
* 12/21/2000 georgioc(MSFT) - redid page table management, integrated with 
* xbox apu driver
*                                                                           *
\***************************************************************************/

#include "dsoundi.h"
#include "dspdma.h"

#define INVALID_INDEX_VALUE         (~0)


CMcpxDspScratchDma::CMcpxDspScratchDma(BOOL fGpScratch)
{
    m_dwMaxPages = 0;
    m_fGpScratch = fGpScratch;
    memset(&m_ctxFxScratch,0,sizeof(m_ctxFxScratch));

}

CMcpxDspScratchDma::~CMcpxDspScratchDma()
{
    if (m_ctxFxScratch.VirtualAddress && m_ctxFxScratch.Size) {

        MmLockUnlockBufferPages(m_ctxFxScratch.VirtualAddress,m_ctxFxScratch.Size,TRUE);
        POOLFREE(m_ctxFxScratch.VirtualAddress);

    }
}

VOID
CMcpxDspScratchDma::Initialize(DWORD dwReservedPages)
{

    ULONG index = (m_fGpScratch == TRUE) ? (index = MCPX_MEM_GPSCRATCH) : (MCPX_MEM_EPSCRATCH);

    //
    // keep a pointer to the proper alloc contexts
    //

    m_pDmaBufferContext = &CMcpxCore::m_ctxMemory[index];
    m_pSgeTableContext = &CMcpxCore::m_ctxMemory[index+1];

    //
    // the caller passes us an array of ALLOC_CONTEXTs
    // first one is the allocation for the scratch memory itself
    // the second is the allocation for the SGE table describing the scratch space
    //

	m_dwMaxPages = (USHORT) (m_pSgeTableContext->Size / NV_PSGE_SIZE);
    m_dwReservedPages = dwReservedPages;

    //
    // initialize the hw SGE table and our internal page table to point to 
    // DMA allocated memory
    //

    MCP1_PRD *pPrd = (MCP1_PRD *)m_pSgeTableContext->VirtualAddress;

    ULONG bytesRemaining = m_pDmaBufferContext->Size;
    ULONG bytesMapped = 0;
    PVOID currentVa = m_pDmaBufferContext->VirtualAddress;

    //
    // note that all pages are 4k aligned and since the dma buffer is 4k length
    // aligned, all sizes are 4k as well..
    //

    for (ULONG i = 0; i < m_dwMaxPages-dwReservedPages; i++)
    {
        pPrd[i].uAddr = CMcpxCore::MapTransfer(&currentVa,
                                               &bytesRemaining,
                                               &bytesMapped);

        pPrd[i].Control.uValue = 0;
        pPrd[i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

    }

    //
    // Set base address for GP/EP scratch
    //

    //
    // tell the hw that all pages are valid , except the reserved ones
    //
    
    if (m_fGpScratch) {

        MCPX_REG_WRITE(NV_PAPU_GPSADDR, m_pSgeTableContext->PhysicalAddress);    
        MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages);

    } else {

        MCPX_REG_WRITE(NV_PAPU_EPSADDR, m_pSgeTableContext->PhysicalAddress);    
        MCPX_REG_WRITE(NV_PAPU_EPSMAXSGE, m_dwMaxPages);
    }

    return;
}

VOID
CMcpxDspScratchDma::AddPages(
    PMCPX_ALLOC_CONTEXT pContextArray,
    DWORD dwCount,
    PULONG pOffset
    )
{
    DWORD dwPageIndex = m_dwMaxPages - m_dwReservedPages;
    ULONG i;

    ASSERT(dwCount <= m_dwReservedPages);

    m_dwReservedPages -= dwCount;

    MCP1_PRD *pPrd = (MCP1_PRD *)CMcpxCore::m_ctxMemory[MCPX_MEM_GPSCRATCHSGE].VirtualAddress;

    for (i=0;i<dwCount;i++) {

        //
        // update the hw SGE table
        //

        pPrd[dwPageIndex+i].uAddr = pContextArray[i].PhysicalAddress;

        pPrd[dwPageIndex+i].Control.uValue = 0;
        pPrd[dwPageIndex+i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

    }

    //
    // tell the hw that all pages are valid , including the reserved ones
    //
    
    MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages);

    //
    // give them the linear offset into our DMA buffer window
    //

    *pOffset = dwPageIndex*PAGE_SIZE;
    return;

}


VOID
CMcpxDspScratchDma::Copy(ULONG uLinOffset, VOID *pSource, ULONG uSize)
{
    //
    // scratch mem is contigious
    //

    PUCHAR pDest = (PUCHAR)m_pDmaBufferContext->VirtualAddress+uLinOffset;
    memcpy(pDest, pSource, uSize);
}

HRESULT
CMcpxDspScratchDma::AdjustFxScratch(DWORD dwSize)
{

    MCPX_ALLOC_CONTEXT ctx;
    ULONG offset,i;
    DWORD dwPageIndex = m_dwMaxPages-m_dwReservedPages;
    MCP1_PRD *pPrd = (MCP1_PRD *)CMcpxCore::m_ctxMemory[MCPX_MEM_GPSCRATCHSGE].VirtualAddress;
    DWORD dwCount = dwSize/PAGE_SIZE;

    if (dwCount > m_dwReservedPages) {

        DPF_ERROR("Effects Image scratch space usage exceed max (%d) pages",
                  MCPX_HW_MAX_FX_SCRATCH_PAGES);

        return DSERR_OUTOFMEMORY;
    }

    ctx.Size = 0;

    if (m_ctxFxScratch.Size < dwSize) {

        //
        // there is already scratch allocated for FX delay lines
        // If its larger than what we need dont do anything.
        // if its less, free whats there and replace it with a new allocation
        //
    
        memcpy(&ctx,&m_ctxFxScratch,sizeof(m_ctxFxScratch));        

        //
        // allocate a new one
        //

        m_ctxFxScratch.Size = dwSize;
        m_ctxFxScratch.VirtualAddress = POOLALLOC(BYTE, m_ctxFxScratch.Size);
        if (m_ctxFxScratch.VirtualAddress == NULL) {

            return E_OUTOFMEMORY;

        }

        MmLockUnlockBufferPages(m_ctxFxScratch.VirtualAddress,dwSize,FALSE);

    } else {

        return DS_OK;
    }


    for (i=0;i<dwCount;i++) {

        //
        // update the hw SGE table
        //

        pPrd[dwPageIndex+i].uAddr = MmGetPhysicalAddress(i*PAGE_SIZE+(PUCHAR)m_ctxFxScratch.VirtualAddress);
        pPrd[dwPageIndex+i].Control.uValue = 0;
        pPrd[dwPageIndex+i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

    }

    //
    // tell the hw, more pages are now valid...
    //

    MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages+dwCount);

    //
    // free old allocation
    //

    if (ctx.Size) {

        MmLockUnlockBufferPages(ctx.VirtualAddress,ctx.Size,TRUE);
        POOLFREE(ctx.VirtualAddress);

    }

    return DS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsmath.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsmath.h
 *  Content:    Math helpers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/24/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __DSMATH_H__
#define __DSMATH_H__

#include <float.h>
#include <math.h>

typedef struct _VECTOR4 {
    float x;
    float y;
    float z;
    float w;
} VECTOR4;

#ifndef FLT_MAX
#define FLT_MAX         3.402823466e+38F        /* max value */
#endif // FLT_MAX

#ifndef FLT_MIN
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#endif // FLT_MIN

#ifdef __cplusplus

#define ftoi(x) \
    DirectSound::Math::FloatToLong(x)

#define FTOI(x) \
    DirectSound::Math::FloatToLong(x)

#define ftol(x) \
    DirectSound::Math::FloatToLong(x)

#define FTOL(x) \
    DirectSound::Math::FloatToLong(x)

namespace DirectSound
{
    namespace Math
    {
        double NormalizeDouble(double f);
        float NormalizeFloat(float f);
        long RatioToPitch(float flRatio);

        VECTOR4* Vec3Transform( VECTOR4 *pOut, const D3DVECTOR *pV, const D3DMATRIX *pM );
        D3DMATRIX* MatrixRotationAxis( D3DMATRIX *pOut, const D3DVECTOR *pV, float angle );

        double NormalizeVector3(D3DVECTOR *pdst, double x, double y, double z);
        float NormalizeVector3(D3DVECTOR *pdst, const D3DVECTOR *psrc);
        float NormalizeVector3(D3DVECTOR *pdst);

        double NormalizeVector2(D3DVECTOR *pdst, double x, double z);
        float NormalizeVector2(D3DVECTOR *pdst, const D3DVECTOR *psrc);
        float NormalizeVector2(D3DVECTOR *pdst);

        static _declspec(naked) long FloatToLong(float x)
        {
            __asm
            {
                cvttss2si eax, [esp+4]
                ret 4
            }
        }

        __inline double MagnitudeVector3(double x, double y, double z)
        {
            return sqrt((x * x) + (y * y) + (z * z));
        }

        __inline float MagnitudeVector3(float x, float y, float z)
        {
            return (float)sqrt((double)((x * x) + (y * y) + (z * z)));
        }

        __inline float MagnitudeVector3(const D3DVECTOR *p)
        {
            return (float)sqrt((double)((p->x * p->x) + (p->y * p->y) + (p->z * p->z)));
        }

        __inline double MagnitudeVector2(double x, double z)
        {
            return sqrt((x * x) + (z * z));
        }

        __inline float MagnitudeVector2(float x, float z)
        {
            return (float)sqrt((float)((x * x) + (z * z)));
        }

        __inline float MagnitudeVector2(const D3DVECTOR *p)
        {
            return (float)sqrt((p->x * p->x) + (p->z * p->z));
        }

        __inline long MetersToVolume(float x)
        {
            if(x >= 0.0f)
            {
                return ftoi(-2000.0f * log10f(x + 1.0f));
            }
            else
            {
                return DSBVOLUME_MAX;
            }
        }

        __inline long PowerToVolume(float x)
        {
            if(x <= 0.0f)
            {
                return DSBVOLUME_MIN;
            }
            else if(x >= 1.0f)
            {
                return DSBVOLUME_MAX;
            }
            else
            {
                return ftoi(1000.0f * log10f(x));
            }
        }

        __inline long AmplitudeToVolume(float x)
        {
            if(x <= 0.0f)
            {
                return DSBVOLUME_MIN;
            }
            else if(x >= 1.0f)
            {
                return DSBVOLUME_MAX;
            }
            else
            {
                return ftoi(2000.0f * log10f(x));
            }
        }

#ifdef DEBUG

        static unsigned int __fastcall lsb(unsigned int x)
        {
            ASSERT(x);
    
            __asm
            {
                mov     ecx, x
                bsf     eax, ecx
            }
        }

#else // DEBUG

        static unsigned int __fastcall lsb(unsigned int x)
        {
            __asm
            {
                bsf     eax, ecx
            }
        }

#endif // DEBUG

        __inline unsigned int log2(unsigned int x)
        {
            ASSERT(!(x & (x - 1)));
            return lsb(x);
        }
    }
}

using namespace DirectSound::Math;

#endif // __cplusplus

#endif // __DSMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsperf.h ===
/***************************************************************************
 *
 *  Copyright (C) 8/29/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsperf.h
 *  Content:    Performance tools.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/29/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __DSPERF_H__
#define __DSPERF_H__

#if defined(DEBUG) && !defined(IMPLEMENT_PERF_COUNTERS)
#define IMPLEMENT_PERF_COUNTERS
#endif // IMPLEMENT_PERF_COUNTERS

BEGIN_DEFINE_STRUCT()
    LPCSTR      pszName;
    DWORD       dwFlags;
    LPVOID      pvData;
END_DEFINE_STRUCT(DSPERFCOUNTER);

#ifdef __cplusplus

//
// Performance monitor object
//

namespace DirectSound
{
    class CPerfMon
    {

#ifdef IMPLEMENT_PERF_COUNTERS

    private:
        static const DSPERFCOUNTER  m_aCounters[];

#endif // IMPLEMENT_PERF_COUNTERS

    public:
        static void RegisterCounters(void);
        static void UnregisterCounters(void);

#ifdef IMPLEMENT_PERF_COUNTERS

    protected:
        static HRESULT STDAPICALLTYPE GetFreeGPCycles(PLARGE_INTEGER pliData, PLARGE_INTEGER pliUnused);
        static HRESULT STDAPICALLTYPE GetFreeEPCycles(PLARGE_INTEGER pliData, PLARGE_INTEGER pliUnused);

    private:
        static DWORD GetFreeDSPCycles(DWORD dwAddress, DWORD dwSamplesPerClock);

#endif // IMPLEMENT_PERF_COUNTERS

    };

#ifndef IMPLEMENT_PERF_COUNTERS

    __inline void CPerfMon::RegisterCounters(void)
    {
    }

    __inline void CPerfMon::UnregisterCounters(void)
    {
    }

#endif // IMPLEMENT_PERF_COUNTERS

}

#endif // __cplusplus

#endif // __DSPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsperf.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 8/29/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsperf.cpp
 *  Content:    Performance tools.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/29/2001   dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

#ifdef IMPLEMENT_PERF_COUNTERS

#include <dm.h>
#include <xbdm.h>

const DSPERFCOUNTER CPerfMon::m_aCounters[] =
{
    { "DirectSound free 2D voices", DMCOUNT_VALUE | DMCOUNT_ASYNC32, &g_dwDirectSoundFree2dVoices },
    { "DirectSound free 3D voices", DMCOUNT_VALUE | DMCOUNT_ASYNC32, &g_dwDirectSoundFree3dVoices },
    { "DirectSound free buffer SGEs", DMCOUNT_VALUE | DMCOUNT_ASYNC32, &g_dwDirectSoundFreeBufferSGEs },
    { "DirectSound pool memory used", DMCOUNT_VALUE | DMCOUNT_ASYNC32, &g_dwDirectSoundPoolMemoryUsage },
    { "DirectSound physical memory used", DMCOUNT_VALUE | DMCOUNT_ASYNC32, &g_dwDirectSoundPhysicalMemoryUsage },
    { "DirectSound percent free GP cycles", DMCOUNT_VALUE | DMCOUNT_SYNC, GetFreeGPCycles },
    { "DirectSound percent free EP cycles", DMCOUNT_VALUE | DMCOUNT_SYNC, GetFreeEPCycles },
};


/****************************************************************************
 *
 *  RegisterCounters
 *
 *  Description:
 *      Registers DirectSound performance counters.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPerfMon::RegisterCounters"

void
CPerfMon::RegisterCounters
(
    void
)
{
    DWORD                   i;
    
    DPF_ENTER();

    for(i = 0; i < NUMELMS(m_aCounters); i++)
    {
        DmTell_RegisterPerformanceCounter(m_aCounters[i].pszName, m_aCounters[i].dwFlags, m_aCounters[i].pvData);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  UnregisterCounters
 *
 *  Description:
 *      Unregisters DirectSound performance counters.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPerfMon::UnregisterCounters"

void
CPerfMon::UnregisterCounters
(
    void
)
{
    DWORD                   i;
    
    DPF_ENTER();

    for(i = 0; i < NUMELMS(m_aCounters); i++)
    {
        DmTell_UnregisterPerformanceCounter(m_aCounters[i].pszName);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  PerfGetFreeGPCycles
 *
 *  Description:
 *      Gets the count of available GP DSP cycles.
 *
 *  Arguments:
 *      PLARGE_INTEGER [out]: count.
 *      PLARGE_INTEGER [out]: reserved.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPerfMon::GetFreeGPCycles"

STDAPI
CPerfMon::GetFreeGPCycles
(
    PLARGE_INTEGER          pliData, 
    PLARGE_INTEGER          pliUnused
)
{
    DPF_ENTER();

    pliData->QuadPart = GetFreeDSPCycles(0xFE8301F0, 32);

    DPF_LEAVE_HRESULT(XBDM_NOERR);

    return XBDM_NOERR;
}


/****************************************************************************
 *
 *  PerfGetFreeEPCycles
 *
 *  Description:
 *      Gets the count of available EP DSP cycles.
 *
 *  Arguments:
 *      PLARGE_INTEGER [out]: count.
 *      PLARGE_INTEGER [out]: reserved.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPerfMon::GetFreeEPCycles"

STDAPI
CPerfMon::GetFreeEPCycles
(
    PLARGE_INTEGER          pliData, 
    PLARGE_INTEGER          pliUnused
)
{
    DPF_ENTER();

    pliData->QuadPart = GetFreeDSPCycles(0xFE85A010, 256);

    DPF_LEAVE_HRESULT(XBDM_NOERR);

    return XBDM_NOERR;
}


/****************************************************************************
 *
 *  PerfGetFreeDSPCycles
 *
 *  Description:
 *      Gets the count of available DSP cycles.
 *
 *  Arguments:
 *      DWORD [in]: performance register address.
 *      DWORD [in]: samples per clock.
 *
 *  Returns:  
 *      DWORD: count of idle cycles.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPerfMon::GetFreeDSPCycles"

DWORD
CPerfMon::GetFreeDSPCycles
(
    DWORD                   dwAddress,
    DWORD                   dwSamplesPerClock
)
{
    static DWORD            dwClockSpeed;
    PCI_SLOT_NUMBER         Slot;
    DWORD                   dwMaxIdle;
    DWORD                   dwUsage;
    
    DPF_ENTER();

    //
    // Get the DSP clock speed
    //
    
    if(!dwClockSpeed)
    {
        Slot.u.AsULONG = 0;
        Slot.u.bits.DeviceNumber = 1;
        Slot.u.bits.FunctionNumber = 0;

        HalReadPCISpace(0, Slot.u.AsULONG, 0x8C, &dwClockSpeed, sizeof(dwClockSpeed));

        switch((dwClockSpeed >> 26) & 3)
        {
            case 1:
                dwClockSpeed = 133;
                break;

            case 2:
                dwClockSpeed = 200;
                break;

            default:
                dwClockSpeed = 160;
                break;
        }
    }

    //
    // Calculate max idle cycles
    //

    dwMaxIdle = ((dwSamplesPerClock * 1000) / 48) * dwClockSpeed;

    //
    // Get the count of cycles currently being used
    //

    dwUsage = *(LPDWORD)dwAddress;

    //
    // Convert to idle cycles
    //

    if(dwUsage >= dwMaxIdle)
    {
        dwUsage = dwMaxIdle;
    }
    else
    {
        dwUsage = dwMaxIdle - dwUsage;
    }

    //
    // Convert to percentage
    //

    dwUsage *= 100;
    dwUsage /= dwMaxIdle;

    DPF_LEAVE(dwUsage);

    return dwUsage;
}

#endif // IMPLEMENT_PERF_COUNTERS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dspdma.h ===
/************************Object to do DSP memory management*****************\
*                                                                           *
* Module: CScratchDma.h		                                                *
*   Object to handle pages/offsets etc for the scratch memory		        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#ifndef _CSCRATCHDMA_
#define _CSCRATCHDMA_

namespace DirectSound
{
    class CMcpxDspScratchDma
    {
    public:
        CMcpxDspScratchDma(BOOL fGpScratch);
        CMcpxDspScratchDma::~CMcpxDspScratchDma();


    public:
        VOID Initialize(DWORD dwReservedPages);
        VOID Copy(ULONG uLinOffset, VOID *pSource, ULONG uSize);
        VOID Put(ULONG uLinOffset, ULONG dwValue)
        {
            *((PULONG)m_pDmaBufferContext->VirtualAddress+uLinOffset/sizeof(DWORD)) = dwValue;
        }
    
        VOID
        AddPages(
            PMCPX_ALLOC_CONTEXT pContextArray,
            DWORD dwCount,
            PULONG pOffset
            );

        VOID *GetScratchTableLinAddr() { return m_pSgeTableContext->VirtualAddress; }
        VOID *GetScratchSpaceLinAddr() { return m_pDmaBufferContext->VirtualAddress; }
        VOID *GetFxScratchSpaceLinAddr() { return m_ctxFxScratch.VirtualAddress; }

        ULONG GetScratchSpacePhysAddr() { return m_pDmaBufferContext->PhysicalAddress; }
        ULONG GetScratchSpaceSize() { return m_pDmaBufferContext->Size; }
        HRESULT AdjustFxScratch(DWORD dwSize);


    private:
    
        DWORD       m_dwMaxPages;
        DWORD       m_dwReservedPages;
        BOOL        m_fGpScratch;

        MCPX_ALLOC_CONTEXT *m_pSgeTableContext;
        MCPX_ALLOC_CONTEXT *m_pDmaBufferContext;
        MCPX_ALLOC_CONTEXT m_ctxFxScratch;

        ULONG        m_uRegOffsetValidPages;
    };
}

//
// scratch queue
//

typedef union _MCPX_DSP_MBOX
{
    struct
    {
        UCHAR    write;
        UCHAR    read;
    } Ptr;

    USHORT uVal;
} MCPX_DSP_MBOX, *PMCPX_DSP_MBOX;

namespace DirectSound
{
    class CMcpxDspScratchQ
    {
    public:

        CMcpxDspScratchQ(ULONG uBaseOffset, 
                         UCHAR uMaxEntries, 
                         CMcpxCore *pApu, 
                         CMcpxDspScratchDma *pDma);

        UCHAR Start();
        VOID Stop();

        BOOL Read(ULONG *puMethod, ULONG *puData);
        BOOL Write(ULONG uMethod, ULONG uData1, ULONG uData2);

        ULONG GetSize()  { return (3*m_uWrapIndex); }
        ULONG GetOffset() { return m_uBaseOffset; }
    
    private:
        UCHAR       GetAvailableSlots();
        VOID        Incr(UCHAR *puIndex);
    
        ULONG           m_uBaseOffset;
        ULONG           m_uRegOffset;
    
        MCPX_DSP_MBOX   m_MailBox;
        CMcpxCore        *m_pApu;
        CMcpxDspScratchDma     *m_pScratchDma;
        ULONG            m_uStartFlag;

        UCHAR           m_uWrapIndex;
    };
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dspexeccode.h ===
0x0BF080, 
0x000155, 
0x300600, 
0x310000, 
0x62F400, 
0x000800, 
0x330600, 
0x0BF080, 
0x0000DB, 
0x301800, 
0x310000, 
0x62F400, 
0x000800, 
0x330600, 
0x0BF080, 
0x0000EB, 
0x0BF080, 
0x00009E, 
0x301E00, 
0x61F400, 
0x001560, 
0x62F400, 
0x00B000, 
0x63F400, 
0x000280, 
0x0BF080, 
0x0000EB, 
0x44F400, 
0x0049E2, 
0x0200C4, 
0x240000, 
0x447000, 
0x00007F, 
0x447000, 
0x00007E, 
0x07F432, 
0xFFFFFF, 
0x07F430, 
0x000001, 
0x07F431, 
0x000001, 

0x08F484, 
0x000001, 

0x0BF080, 
0x000160, 
0x44F000, 
0xFFFFB3, 
0x447000, 
0x00007F, 
0x0BF080, 
0x00005C, 
0x44F000, 
0xFFFFB3, 
0x447000, 
0x00007D, 
0x0BF080, 
0x000171, 
0x200013, 
0x54F000, 
0xFFFFB3, 
0x44F000, 
0x00007D, 
0x0C1FF8, 
0x059405, 
0x218E00, 
0x200044, 
0x547000, 
0x00007C, 
0x56F400, 
0x000025, 
0x0BF080, 
0x000126, 
0x56F400, 
0x00001E, 
0x0BF080, 
0x000126, 
0x200013, 
0x54F000, 
0xFFFFB3, 
0x44F000, 
0x00007F, 
0x0C1FF8, 
0x059797, 
0x218E00, 
0x200044, 
0x547000, 
0x00007E, 
0x44F400, 
0x019E10, 
0x0C1FF8, 
0x05978F, 
0x050F8E, 
0x56F400, 
0x000006, 
0x0BF080, 
0x000126, 
0x448400, 
0x56F400, 
0x000000, 
0x200045, 
0x0D104A, 
0x000039, 
0x0A0480, 
0x000084, 
0x60F400, 
0x000080, 
0x44F400, 
0x000F80, 
0x0BF080, 
0x000165, 
0x0BF080, 
0x000169, 
0x05F420, 
0xFFFFFF, 
0x0461A0, 
0x0462A0, 
0x0463A0, 
0x0464A0, 
0x0465A0, 
0x60F400, 
0x000012, 
0x61F400, 
0x002971, 
0x62F400, 
0x000818, 
0x638100, 
0x0BF080, 
0x0000DB, 
0x56F400, 
0x000012, 
0x0BF080, 
0x000126, 
0x0A0481, 
0x00009D, 
0x60F400, 
0x00000C, 
0x56F400, 
0x000080, 
0x448000, 
0x200040, 
0x21D100, 
0x448200, 
0x209200, 
0x638300, 
0x0BF080, 
0x0000DB, 
0x56F400, 
0x00000C, 
0x0BF080, 
0x000126, 
0x44F400, 
0x000000, 
0x440400, 
0x56F400, 
0x000018, 
0x0BF080, 
0x000126, 
0x00000C, 
0x64F400, 
0x000025, 
0x44F400, 
0x008000, 
0x61F400, 
0x000024, 
0x446100, 
0x56F400, 
0x00002C, 
0x62F400, 
0x0000CC, 
0x060690, 
0x000017, 
0x565C00, 
0x0140C0, 
0x000007, 
0x44F400, 
0x0059D2, 
0x445C00, 
0x44F400, 
0x000020, 
0x445C00, 
0x07DA84, 
0x445C00, 
0x44F400, 
0x000000, 
0x445C00, 
0x57E100, 
0x575C00, 
0x0140C8, 
0x000800, 
0x576100, 
0x44F400, 
0x0007FF, 
0x445C00, 
0x56F400, 
0x000025, 
0x0BF080, 
0x0000D2, 
0x0140C0, 
0x000023, 
0x21D400, 
0x44F400, 
0x004000, 
0x445C00, 
0x00000C, 
0x001400, 
0x001440, 
0x001420, 
0x001480, 
0x0014A0, 
0x001460, 

0x0D1080, 
0x000038, 

0x08F497, 
0x000000, 

0x0140C6, 
0x003FFF, 
0x08CE15, 
0x08CE14, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x0059E0, 
0x0200CE, 
0x0A7093, 
0x000002, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x0059E2, 
0x0200CE, 
0x0A7093, 
0x000002, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 

0x08F496, 
0x000001, 
0x0CD604, 
0x000000, 
0x00000C, 
0x08F496, 
0x000002, 
0x0CD624, 
0x000000, 
0x00000C, 
0x08F496, 
0x000003, 
0x0CD603, 
0x000000, 
0x00000C, 
0x08F496, 
0x000002, 
0x0CD624, 
0x000000, 
0x08F496, 
0x000003, 
0x0CD603, 
0x000000, 
0x00000C, 
0x08F496, 
0x000004, 
0x0CD623, 
0x000000, 
0x00000C, 
0x08F496, 
0x000004, 
0x0CD623, 
0x000000, 
0x08F496, 
0x000001, 
0x0CD604, 
0x000000, 
0x00000C, 
0x0CC507, 
0x000000, 
0x08F485, 
0x000080, 
0x00000C, 
0x050BC4, 
0x0140C6, 
0xFFDFFF, 
0x08CE14, 
0x050BCE, 
0x050BD6, 
0x00000C, 
0x050B9D, 
0x0140C6, 
0xFFDFFF, 
0x08CE14, 
0x050BC7, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x005BE2, 
0x0200CE, 
0x56F400, 
0x000020, 
0x02088E, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x005BE0, 
0x0200CE, 
0x56F400, 
0x000020, 
0x02088E, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 

0x08F485, 
0x000FFF, 

0x60F400, 
0x000000, 
0x44F400, 
0x001000, 
0x0BF080, 
0x000165, 
0x0BF080, 
0x000169, 
0x00000C, 
0x0A8581, 
0x000160, 
0x08F485, 
0x000002, 
0x00000C, 
0x200013, 
0x06C420, 
0x565800, 
0x00000C, 
0x60F400, 
0x000000, 
0x44F400, 
0x000800, 
0x200013, 
0x06C420, 
0x5E5800, 
0x00000C, 

0x000000, 
0x00000C,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\epdsp.cpp ===
#include "dsoundi.h"
#include "dspdma.h"
#include "GPDsp.h"
#include "EPDsp.h"

#pragma const_seg("DOLBY")

const ULONG AC3SuperExec[] = 
{
#include <AC3SuperExec.h>
};

const ULONG AC3Loader[] =
{
#include <AC3Loader.h>
};

const ULONG AC3Dolby1[] =
{
#include <AC3Dolby1.h>
};

const ULONG AC3Dolby2[] =
{
#include <AC3Dolby2.h>
};

const ULONG AC3Dolby3[] =
{
#include <AC3Dolby3.h>
};

const ULONG AC3Dolby4[] =
{
#include <AC3Dolby4.h>
};

const ULONG AC3Dolby5[] =
{
#include <AC3Dolby5.h>
};

const ULONG AC3Dolby6[] =
{
#include <AC3Dolby6.h>
};

const DOLBY_CONFIG_TABLE AC3ConfigTable =
{
    24,         // table size
    1,          // perform dolby surround encode flag
    1,          // perform dolby game encode flag
    0,          // perform downmix
    0,          // ac3 pcm sampling rate code
    7,          // ac3 dolby input channel config code (acmod)
    1,          // lfe channel present flag
    31,         // ac3 dialnorm value
    9,          // ac3 channel bandwidth code
    0,          // channel lpf enabled flag
    1,          // lfe channel lpf enabled flag
    1,          // dc hpf enabled flag
    0,          // dynrng exists flag
    0,          // ac3 dynrng code
    1,          // compr exists flag
    0xEF,       // ac3 compr code
    0,          // dolby surround gain enabled flag
    0x65AC8C,   // dolby surround encoder gain value
    2,          // dolby surround mode. Only used for 2/0 Mode
    0,          // reserved 1
    0,          // reserved 2
    0,          // reserved 3
    0,          // reserved 4
    0           // reserved 5
};


#pragma const_seg("DSOUND_RD")


ULONG
CMcpxEPDspManager::AC3GetTotalScratchSize()
{
    // in bytes
    return (AC3_DOLBYBASE * sizeof(ULONG) + 
            sizeof(AC3Dolby1) + 
            sizeof(AC3Dolby2) + 
            sizeof(AC3Dolby3) + 
            sizeof(AC3Dolby4) +
            sizeof(AC3Dolby5) +
            sizeof(AC3Dolby6) +
            sizeof(DOLBY_CONFIG_TABLE) + 
            AC3_HEAPLENGTH * sizeof(ULONG));

}

VOID
CMcpxEPDspManager::AC3GetSuperExec(PVOID *ppData, ULONG *pSize, ULONG *pBase)
{
    *ppData = (PVOID)AC3SuperExec;
    *pSize = sizeof(AC3SuperExec)/sizeof(DWORD);
    *pBase = AC3_SUPREXECBASE;
}

VOID
CMcpxEPDspManager::AC3GetLoader(PVOID *ppData, ULONG *pSize, ULONG *pBase)
{
    *ppData = (PVOID)AC3Loader;
    *pSize = sizeof(AC3Loader)/sizeof(DWORD);
    *pBase = AC3_LOADERBASE;
}

PVOID 
CMcpxEPDspManager::AC3GetInitialConfigTable()
{
    return (PVOID)&AC3ConfigTable;
}

VOID
CMcpxEPDspManager::AC3GetProgram(ULONG uIndex, PVOID *ppData, ULONG *pSize)
{
    switch(uIndex)
    {
    case 0:
        *ppData = (PVOID)AC3Dolby1;
        *pSize = sizeof(AC3Dolby1)/sizeof(DWORD);
        break;
    case 1:
        *ppData = (PVOID)AC3Dolby2;
        *pSize = sizeof(AC3Dolby2)/sizeof(DWORD);
        break;
    case 2:
        *ppData = (PVOID)AC3Dolby3;
        *pSize = sizeof(AC3Dolby3)/sizeof(DWORD);
        break;
    case 3:
        *ppData = (PVOID)AC3Dolby4;
        *pSize = sizeof(AC3Dolby4)/sizeof(DWORD);
        break;

    case 4:
        *ppData = (PVOID)AC3Dolby5;
        *pSize = sizeof(AC3Dolby5)/sizeof(DWORD);
        break;

    case 5:
        *ppData = (PVOID)AC3Dolby6;
        *pSize = sizeof(AC3Dolby6)/sizeof(DWORD);
        break;

    default:
        *ppData = NULL;
        *pSize = 0;
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// dma manager code
//
///////////////////////////////////////////////////////////////////////////////


CMcpxEPDspManager::CMcpxEPDspManager()
{
    m_pGlobalProc = NULL;
    m_pScratchDma = NULL;
    m_pConfigTable = NULL;
}

CMcpxEPDspManager::~CMcpxEPDspManager()
{
    DELETE(m_pScratchDma);
}

VOID   
CMcpxEPDspManager::Initialize(CMcpxGPDspManager *pGlobalProc)
{
    ASSERT(CMcpxCore::m_ctxMemory[MCPX_MEM_EPSCRATCH].VirtualAddress);
    ASSERT(CMcpxCore::m_ctxMemory[MCPX_MEM_EPSCRATCH].PhysicalAddress);
    ASSERT(CMcpxCore::m_ctxMemory[MCPX_MEM_EPSCRATCH].Size);

    ASSERT(CMcpxCore::m_ctxMemory[MCPX_MEM_EPSCRATCHSGE].VirtualAddress);
    ASSERT(CMcpxCore::m_ctxMemory[MCPX_MEM_EPSCRATCHSGE].PhysicalAddress);
    ASSERT(CMcpxCore::m_ctxMemory[MCPX_MEM_EPSCRATCHSGE].Size);

    m_pGlobalProc = pGlobalProc;

    //
    // allocate the scratch Dma. This must be done AFTER allocating the contexts above
    //

    m_pScratchDma = NEW(CMcpxDspScratchDma(FALSE));
    ASSERT(m_pScratchDma);
    
    //
    // initialize the scratch dma object. We dont need do reserve any pages
    //

    m_pScratchDma->Initialize(0);
    
#ifdef DEBUG
    //
    // check if somebody called DirectSoundLoadEncoder
    // if they did, use their code+data instead of re-creating it here..
    //

    if ((CDirectSound::m_pvEncoderImageData != NULL) &&
        (CDirectSound::m_dwEncoderImageSize != 0)) {

        m_pScratchDma->Copy(0, CDirectSound::m_pvEncoderImageData, CDirectSound::m_dwEncoderImageSize);
           
    } else 
#endif 
    {
        //
        // copy the dolby DSP code to the DMA memory pages
        //

        PVOID pCode;
        ULONG uSize;
        ULONG uBase;
    
        //
        // superexec dsp code
        //

        AC3GetSuperExec(&pCode, &uSize, &uBase);
        m_pScratchDma->Copy(uBase*sizeof(ULONG), (VOID *)pCode, uSize*sizeof(ULONG));

        //
        // loader code, copy to dma scratch space
        //

        AC3GetLoader(&pCode, &uSize, &uBase);
        m_pScratchDma->Copy(uBase*sizeof(ULONG), (VOID *)pCode, uSize*sizeof(ULONG));

        //
        // loader table
        //

        DOLBY_LOADER_TABLE LoaderTable;
    
        LoaderTable.tableSize = sizeof(DOLBY_LOADER_TABLE) / sizeof(ULONG);
        LoaderTable.maxProgs = AC3GetMaxPrograms();

        //
        // now copy the four Dolby encoder programs into system memory so the DSP can
        // DMA them when it needs them.  Keep track of the current offset into the
        // buffer, and update the loader table with the addresses as we go along.
        // NOTE: offset and Sizes are in DWORDS!!!!!
        //

        ULONG uCurrentOffset = AC3GetProgramBase();
    
        ULONG uCnt;
        for (uCnt = 0; uCnt < AC3GetMaxPrograms(); uCnt++)
        {
            AC3GetProgram(uCnt, &pCode, &uSize);
            m_pScratchDma->Copy(uCurrentOffset*sizeof(ULONG), (VOID *)pCode, uSize*sizeof(ULONG));

            //
            // update the loader table
            //

            LoaderTable.prog[uCnt].ptr = uCurrentOffset;
            LoaderTable.prog[uCnt].size = uSize ;
            uCurrentOffset += uSize;
        }

        //
        // now the config table
        //

        ULONG *pConfig = (ULONG *)AC3GetInitialConfigTable();

        //
        // Note: the AC3 config table is actually a DOLBY_CONFIG_TABLE,
        // not a ULONG...  The size is contained in the first word of the
        // table, so we will treat it here as a ULONG array.
        //

        uSize = pConfig[0];

        LoaderTable.config_ptr = uCurrentOffset;
        LoaderTable.config_size = uSize;

        m_pScratchDma->Copy(uCurrentOffset*sizeof(ULONG), (VOID *)pConfig, uSize * sizeof(ULONG));

        //
        // save the config table offset into the scratch space.
        //

        m_pConfigTable = uCurrentOffset*sizeof(ULONG) +  (PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr();

        uCurrentOffset += uSize;

        //Init pingpong buffer offset
        LoaderTable.pingpong_offset = 0;
        LoaderTable.reserved1 = 0;
        LoaderTable.reserved2 = 0;
        LoaderTable.reserved3 = 0;
    
        //
        // now for the heap
        //

        LoaderTable.heap_ptr = uCurrentOffset;
        LoaderTable.heap_size = AC3GetHeapSize();
    
        //
        // copy the table to the offset
        //

        m_pScratchDma->Copy(AC3GetLoaderTableBase()*sizeof(ULONG), (VOID *)&LoaderTable, sizeof(DOLBY_LOADER_TABLE));
    }

    //
    // map the same number of pages into the GP scratch.
    // The GP outputs dolby data to SCRATCH space, not to the normal FIFO output buffers
    // THe EP then reads from the GP scratch buffer...
    //

    AC3StartGpInput(CMcpxCore::m_ctxMemory[MCPX_MEM_EPSCRATCH].Size - (MCPX_HW_AC3_NUM_INPUT_PAGES * PAGE_SIZE));

    return;
}


DOLBY_CONFIG_TABLE*
CMcpxEPDspManager::GetDolbyConfigTable()
{
    return (DOLBY_CONFIG_TABLE*) m_pConfigTable;
}

VOID
CMcpxEPDspManager::AC3StartGpInput(ULONG uLinOffset)
{
    //
    // use the last n pages for ac-3 input from the GP
    //

    MCPX_ALLOC_CONTEXT mem[MCPX_HW_AC3_NUM_INPUT_PAGES];
    ULONG uNumOfPagesForInput = MCPX_HW_AC3_NUM_INPUT_PAGES;
    
    ASSERT(m_pGlobalProc);

    ULONG uOffset = AC3GetLoaderTableBase()*sizeof(ULONG);

#ifdef DEBUG
    //
    // check if somebody called DirectSoundLoadEncoder
    // if they did, use their code+data instead of re-creating it here..
    //

    if ((CDirectSound::m_pvEncoderImageData == NULL) &&
        (CDirectSound::m_dwEncoderImageSize == 0)) 
#endif
    {
        //
        // because we ping pong, here we tell the DSP code to address half the total buffer
        //

        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(pcm_ptr), uLinOffset/sizeof(ULONG));
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(pcm_size), AC3_FRAME_SIZE * AC3_NUM_CHANNELS);
    }

    // program the same pages in the GP
    for (ULONG uCnt = 0; uCnt < uNumOfPagesForInput; uCnt++)
    {
        mem[uCnt].VirtualAddress = (PUCHAR) m_pScratchDma->GetScratchSpaceLinAddr() + uLinOffset;
        mem[uCnt].PhysicalAddress = m_pScratchDma->GetScratchSpacePhysAddr() +uLinOffset ;
        mem[uCnt].Size = PAGE_SIZE;
        uLinOffset += mem[uCnt].Size;
    }
    
    m_pGlobalProc->AC3SetOutputBuffer(mem, uNumOfPagesForInput);
    return;
}


VOID
CMcpxEPDspManager::AC3SetAnalogOutput(ULONG uAnalogFifoIndex, ULONG uSize)
{

    ULONG uOffset = AC3GetLoaderTableBase()*sizeof(ULONG);

    ASSERT(m_pGlobalProc);

#ifdef DEBUG
    //
    // check if somebody called DirectSoundLoadEncoder
    // if they did, use their code+data instead of re-creating it here..
    //

    if ((CDirectSound::m_pvEncoderImageData == NULL) &&
        (CDirectSound::m_dwEncoderImageSize == 0)) 
#endif
    {
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ltrt_ptr), uAnalogFifoIndex);
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ltrt_size), uSize/sizeof(ULONG));
    }

    return;
}

VOID
CMcpxEPDspManager::AC3SetDigitalOutput(ULONG uDigitalFifoIndex, ULONG uSize)
{

    ULONG uOffset = AC3GetLoaderTableBase() * sizeof(ULONG);
    ASSERT(m_pGlobalProc);

#ifdef DEBUG
    //
    // check if somebody called DirectSoundLoadEncoder
    // if they did, use their code+data instead of re-creating it here..
    //

    if ((CDirectSound::m_pvEncoderImageData == NULL) &&
        (CDirectSound::m_dwEncoderImageSize == 0)) 
#endif
    {
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_ptr), uDigitalFifoIndex);
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_zero_fill), 1);
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_preamble), 1);
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_size), uSize/sizeof(ULONG));
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\globals.c ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       globals.c
 *  Content:    Externally exposed DirectSound global variables.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/22/01    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

#ifdef MCPX_BOOT_LIB
#define DSGLOBAL const
#else // MCPX_BOOT_LIB
#define DSGLOBAL const __declspec(selectany)
#endif // MCPX_BOOT_LIB

DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_Mono[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_MONO };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_Stereo[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_STEREO };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_4Channel[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_4CHANNEL };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_6Channel[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_6CHANNEL };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundRequiredMixBinVolumePairs_3D[] = { DSMIXBINVOLUMEPAIRS_REQUIRED_3D };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_3D[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_3D };

DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_Mono = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_Mono),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_Mono
};
        
DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_Stereo = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_Stereo),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_Stereo
};
        
DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_4Channel = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_4Channel),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_4Channel
};
        
DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_6Channel = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_6Channel),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_6Channel
};
        
DSGLOBAL DSMIXBINS DirectSoundRequiredMixBins_3D = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundRequiredMixBinVolumePairs_3D),
    /* lpMixBinVolumePairs  */ DirectSoundRequiredMixBinVolumePairs_3D
};
        
DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_3D = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_3D),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_3D
};

#ifndef MCPX_BOOT_LIB
        
DSGLOBAL DS3DBUFFER DirectSoundDefault3DBuffer =
{
    /* dwSize               */ sizeof(DS3DBUFFER),
    /* vPosition            */ { DS3D_DEFAULTPOSITION_X, DS3D_DEFAULTPOSITION_Y, DS3D_DEFAULTPOSITION_Z },
    /* vVelocity            */ { DS3D_DEFAULTVELOCITY_X, DS3D_DEFAULTVELOCITY_Y, DS3D_DEFAULTVELOCITY_Z },
    /* dwInsideConeAngle    */ DS3D_DEFAULTCONEANGLE,
    /* dwOutsideConeAngle   */ DS3D_DEFAULTCONEANGLE,
    /* vConeOrientation     */ { DS3D_DEFAULTCONEORIENT_X, DS3D_DEFAULTCONEORIENT_Y, DS3D_DEFAULTCONEORIENT_Z },
    /* lConeOutsideVolume   */ DS3D_DEFAULTCONEOUTSIDEVOLUME,
    /* flMinDistance        */ DS3D_DEFAULTMINDISTANCE,
    /* flMaxDistance        */ DS3D_DEFAULTMAXDISTANCE,
    /* dwMode               */ DS3DMODE_NORMAL,
    /* flDistanceFactor     */ DS3D_DEFAULTDISTANCEFACTOR,                                                         
    /* flRolloffFactor      */ DS3D_DEFAULTROLLOFFFACTOR,                                                          
    /* flDopplerFactor      */ DS3D_DEFAULTDOPPLERFACTOR                                                           
};

DSGLOBAL DSI3DL2BUFFER DirectSoundDefaultI3DL2Buffer =
{
    /* lDirect              */ DSI3DL2BUFFER_DEFAULTDIRECT,
    /* lDirectHF            */ DSI3DL2BUFFER_DEFAULTDIRECTHF,
    /* lRoom                */ DSI3DL2BUFFER_DEFAULTROOM,
    /* lRoomHF              */ DSI3DL2BUFFER_DEFAULTROOMHF,
    /* flRoomRolloffFactor  */ DSI3DL2BUFFER_DEFAULTROOMROLLOFFFACTOR,
    /* Obstruction          */ { DSI3DL2BUFFER_DEFAULTOBSTRUCTION, DSI3DL2BUFFER_DEFAULTOBSTRUCTIONLFRATIO },
    /* Occlusion            */ { DSI3DL2BUFFER_DEFAULTOCCLUSION, DSI3DL2BUFFER_DEFAULTOCCLUSIONLFRATIO}
};

DSGLOBAL DS3DLISTENER DirectSoundDefault3DListener =
{
    /* dwSize               */ sizeof(DS3DLISTENER),                                                               
    /* vPosition            */ { DS3D_DEFAULTPOSITION_X, DS3D_DEFAULTPOSITION_Y, DS3D_DEFAULTPOSITION_Z },         
    /* vVelocity            */ { DS3D_DEFAULTVELOCITY_X, DS3D_DEFAULTVELOCITY_Y, DS3D_DEFAULTVELOCITY_Z },         
    /* vOrientFront         */ { DS3D_DEFAULTORIENTFRONT_X, DS3D_DEFAULTORIENTFRONT_Y, DS3D_DEFAULTORIENTFRONT_Z },
    /* vOrientTop           */ { DS3D_DEFAULTORIENTTOP_X, DS3D_DEFAULTORIENTTOP_Y, DS3D_DEFAULTORIENTTOP_Z },      
    /* flDistanceFactor     */ DS3D_DEFAULTDISTANCEFACTOR,                                                         
    /* flRolloffFactor      */ DS3D_DEFAULTROLLOFFFACTOR,                                                          
    /* flDopplerFactor      */ DS3D_DEFAULTDOPPLERFACTOR                                                           
};

DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Default = { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Generic = { DSI3DL2_ENVIRONMENT_PRESET_GENERIC };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_PaddedCell = { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Room = { DSI3DL2_ENVIRONMENT_PRESET_ROOM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Bathroom = { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_LivingRoom = { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_StoneRoom = { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Auditorium = { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_ConcertHall = { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Cave = { DSI3DL2_ENVIRONMENT_PRESET_CAVE };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Arena = { DSI3DL2_ENVIRONMENT_PRESET_ARENA };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Hangar = { DSI3DL2_ENVIRONMENT_PRESET_HANGAR };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_CarpetedHallway = { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Hallway = { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_StoneCorridor = { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Alley = { DSI3DL2_ENVIRONMENT_PRESET_ALLEY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Forest = { DSI3DL2_ENVIRONMENT_PRESET_FOREST };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_City = { DSI3DL2_ENVIRONMENT_PRESET_CITY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Mountains = { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Quarry = { DSI3DL2_ENVIRONMENT_PRESET_QUARRY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Plain = { DSI3DL2_ENVIRONMENT_PRESET_PLAIN };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_ParkingLot = { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_SewerPipe = { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Underwater = { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_NoReverb = { DSI3DL2_ENVIRONMENT_PRESET_NOREVERB };

DSGLOBAL GUID KSDATAFORMAT_SUBTYPE_PCM = { WAVE_FORMAT_PCM, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } };
DSGLOBAL GUID KSDATAFORMAT_SUBTYPE_XBOX_ADPCM = { WAVE_FORMAT_XBOX_ADPCM, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } };

DWORD g_dwDirectSoundDebugLevel = DPFLVL_DEFAULT;
DWORD g_dwDirectSoundDebugBreakLevel = DPFLVL_DEFAULT_BREAK;
BOOL g_fDirectSoundDebugBreak = FALSE;

DWORD g_dwDirectSoundPoolMemoryUsage = 0;
DWORD g_dwDirectSoundPhysicalMemoryUsage = 0;

DWORD g_dwDirectSoundPhysicalMemorySlop = 0;
DWORD g_dwDirectSoundPhysicalMemoryRecovered = 0;

DWORD g_dwDirectSoundFree2dVoices = 0;
DWORD g_dwDirectSoundFree3dVoices = 0;
DWORD g_dwDirectSoundFreeBufferSGEs = 0;

DWORD g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_USE_DEFAULT;

BOOL g_fDirectSoundInFinalRelease = FALSE;
BOOL g_fDirectSoundDisableBusyWaitWarning = FALSE;
BOOL g_fDirectSoundI3DL2Overdelay = FALSE;

INITIALIZED_CRITICAL_SECTION(g_DirectSoundCriticalSection);

#endif // MCPX_BOOT_LIB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\epdsp.h ===
#if !defined _EPDSP_H_
#define _EPDSP_H_

//
// make sure all these stays in sync with whatver dolby does
//

//
// the following are EP P ram values of the offsets for the cached values
// of peak and rms levels. These values get updated twice every 5.33ms
// To avoid dma overhead, we read these values directly from DSP memory
//

#define EP_OFFSET_OUTPUT_LEVELS_ANALOG_PEAK     0x1AB
#define EP_OFFSET_OUTPUT_LEVELS_ANALOG_RMS      0x1AD
#define EP_OFFSET_OUTPUT_LEVELS_DIGITAL_PEAK    0x1AF
#define EP_OFFSET_OUTPUT_LEVELS_DIGITAL_RMS     0x1B5

//
// below are P memory offsets for the loader
//

#define AC3_SUPREXECBASE        0x000
#define AC3_LOADERBASE          0x180
#define AC3_LOADERTABLEBASE     0x100  
#define AC3_DOLBYBASE           0x300

#define AC3_MAX_PROGRAMS        6

#define AC3_HEAPLENGTH          8192  // length in words

typedef struct
{
    // the entries in this table are actually all 24-bit DSP words, but when
    // we store DSP code in system memory, we extend each word to fill 32 bits,
    // so we can store them in U032S.  
    ULONG tableSize;         // table size                  
    ULONG maxProgs;          // number of programs

    struct
    {
        ULONG ptr;
        ULONG size;
    } prog[AC3_MAX_PROGRAMS];

    ULONG pcm_ptr;              // pointer to input PCM buffer
    ULONG pcm_size;             // size of input PCM buffer
    ULONG ltrt_ptr;             // pointer to output Lt/Rt buffer  (Note: actually a FIFO index!!)
    ULONG ltrt_size;            // size of output Lt/Rt buffer
    ULONG ac3_ptr;              // pointer to output AC-3 buffer   (Note: actually a FIFO index!!)
    ULONG ac3_size;             // size of output AC-3 buffer
    ULONG config_ptr;           // pointer to config table
    ULONG config_size;          // size of config table
    ULONG pingpong_offset;      // current pingpong buffer offset
    ULONG reserved1;
    ULONG ac3_zero_fill;        // AC3 zero fill (Note: actually a FIFO index!!)
    ULONG reserved2;
    ULONG ac3_preamble;         // AC3 preamble (Note: actually a FIFO index!!)
    ULONG reserved3;

    ULONG levels_ac3_ptr;		// Digital Levels returned from EP
	ULONG levels_ac3_size;
	ULONG levels_analog_ptr;	// Analog Levels returned from EP
	ULONG levels_analog_size;
	ULONG unused_lid_2_ptr;		// Currently unused
	ULONG unused_lid_2_size;

    ULONG heap_ptr;             // pointer to heap data buffer
    ULONG heap_size;            // size of heap data buffer
} DOLBY_LOADER_TABLE;

typedef struct
{
    ULONG table_size;
    ULONG do_surround_encode;
    ULONG do_game_encode;
	ULONG do_downmix_encode;
    ULONG pcm_sample_rate_code;
    ULONG input_ch_config;
    ULONG lfe_present;
    ULONG ac3_dialnorm;
    ULONG ac3_bandwidth;
    ULONG channel_lpf_enabled;
    ULONG lfe_lpf_enabled;
    ULONG dc_hpf_enabled;
    ULONG dynrng_exists;
    ULONG ac3_dynrng_code;
    ULONG compr_exists;
    ULONG ac3_compr_code;
    ULONG surround_gain_enabled;
    ULONG surround_gain;
    ULONG surround_mode;
	ULONG reserved_1;
	ULONG reserved_2;
	ULONG reserved_3;
	ULONG reserved_4;
	ULONG reserved_5;
} DOLBY_CONFIG_TABLE;

#define DOLBY_LOADER_TABLE_OFFSET(x)    (ULONG)&(((DOLBY_LOADER_TABLE *)0)->x)

namespace DirectSound
{
    class CMcpxEPDspManager 
    {
    public:
        CMcpxEPDspManager();
        ~CMcpxEPDspManager();

    public:
	    VOID	Initialize(CMcpxGPDspManager *pGlobalProc);
    
        VOID   AC3SetAnalogOutput(ULONG uOffset, ULONG uSize);   // actually a FIFO index
        VOID   AC3SetDigitalOutput(ULONG uOffset, ULONG uSize);  // actually a FIFO index

        VOID *GetScratchSpaceAddr() { return m_pScratchDma->GetScratchSpaceLinAddr(); }

        DOLBY_CONFIG_TABLE* GetDolbyConfigTable();

        // AC3 functions
        static ULONG AC3GetTotalScratchSize();
        static VOID AC3GetSuperExec(PVOID *ppData, ULONG *pSize, ULONG *pBase);
        static VOID AC3GetLoader(PVOID *ppData, ULONG *pSize, ULONG *pBase);
        static VOID AC3GetProgram(ULONG uIndex, PVOID *ppData, ULONG *pSize);
    
        static PVOID AC3GetInitialConfigTable();
    
        static ULONG AC3GetLoaderTableBase() { return AC3_LOADERTABLEBASE; }
        static ULONG AC3GetProgramBase() { return AC3_DOLBYBASE; }
        static ULONG AC3GetMaxPrograms() { return AC3_MAX_PROGRAMS; }
        static ULONG AC3GetHeapSize() { return AC3_HEAPLENGTH; }

    private:
    
        VOID   AC3StartGpInput(ULONG uLinOffset);

        CMcpxDspScratchDma  *m_pScratchDma;
        CMcpxGPDspManager   *m_pGlobalProc;
        PUCHAR               m_pConfigTable;

    };
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\gpdsp.h ===
#if !defined _GPDSPMANAGER_
#define _GPDSPMANAGER_

typedef struct
{
    union
    {
        struct
        {
            ULONG oper : 1;
            ULONG res  : 15;
            ULONG size : 16;
        } fields;

        ULONG uVal;
    } data1;

    ULONG offset;

} AC3_SET_BUFFER;



///////////////////////////////////////////////////////////////////////////////
//
// Dsp program base class
//
///////////////////////////////////////////////////////////////////////////////

namespace DirectSound
{
    class CMcpxDspImage
    {
    public:
        CMcpxDspImage()
        {
            m_pLoader = NULL;
            m_uLoaderSize = 0;
        }
    
        VOID Initialize();

        PVOID       GetLoader() { return m_pLoader; }
        ULONG       GetLoaderSize() { return m_uLoaderSize; }    

    protected:
    
        PVOID        m_pLoader;
        ULONG        m_uLoaderSize;

    };
}

namespace DirectSound
{
    class CMcpxGPDspManager
    {
    public:

        CMcpxGPDspManager();
        ~CMcpxGPDspManager();

    public:
        VOID Initialize();

        // debug only
        VOID *GetScratchPage(ULONG uPageNumber);
        VOID AC3SetOutputBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages);
        VOID SetMultipassBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages);

        HRESULT DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPDSEFFECTIMAGEDESC *ppImageDesc);
        HRESULT SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags);
        HRESULT GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize);
        HRESULT GetEffectMap(DWORD dwEffectIndex, LPCDSEFFECTMAP *ppEffectMap);
        VOID CommitChanges(DWORD dwScratchOffset, DWORD dwDataSize);

        VOID RestoreCommandBlock();

    protected:

        CMcpxDspScratchDma *GetScratchDma() { return m_pScratchDma; }
        HRESULT     ParseEffectImageInfo(LPCVOID pScratchImage);

    private:

        ULONG        m_uAC3BufferOffset;
        ULONG        m_uMultipassBufferOffset;

        CMcpxDspScratchDma     *m_pScratchDma;
        CMcpxDspImage          *m_pDspImage; 

        ULONG        m_uPMemOffset;
        ULONG        m_uPMemMaxSize;

        DWORD m_dwCurrentLowestScratchOffset;
        DWORD m_dwStateSizeToCommit;
        LPDSEFFECTIMAGEDESC m_pFxDescriptor;
        HOST_TO_DSP_COMMANDBLOCK m_InitialCmdBlock;

    };
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\heap.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       heap.h
 *  Content:    Generic heap object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/24/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __HEAP_H__
#define __HEAP_H__

// 
// Buffer SGE heap run marker
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY  leListEntry;            // Linked list entry
    WORD        nElement;               // Run element index
    WORD        nLength;                // Run length, in elements
    union
    {
        DWORD   dwRefCount;             // Run reference count
        BOOL    fAllocated;             // Is the run allocated?
    };
    LPVOID      pvBaseAddress;          // Base address of mapped buffer
END_DEFINE_STRUCT(SGEHEAPRUNMARKER);

//
// Slop heap owned memory entry
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY  leListEntry;            // List entry
    LPVOID      pvBaseAddress;          // Base address of allocation
END_DEFINE_STRUCT(SLOPMEMENTRY);

// 
// Unused memory heap run marker
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY  leListEntry;            // Linked list entry
    DWORD       nLength;                // Run length, in bytes (includes marker)
    union
    {
        DWORD   dwSignature;            // Allocation validation signature
        BOOL    fAllocated;             // Is the run allocated?
    };
END_DEFINE_STRUCT(SLOPRUNMARKER);

#ifdef __cplusplus

//
// MCP-X buffer SGE heap
//

namespace DirectSound
{
    class CMcpxBufferSgeHeap
    {
    protected:
        LIST_ENTRY              m_lstRuns;                  // Heap element run list
        LIST_ENTRY              m_lstMarkers;               // Unused markers
        LPSGEHEAPRUNMARKER      m_paMarkers;                // Markers
        LPSGEHEAPRUNMARKER      m_pLargestFreeRunMarker;    // Largest available run
        DWORD &                 m_nFreeElementCount;        // Free element count

    public:
        CMcpxBufferSgeHeap(void);
        virtual ~CMcpxBufferSgeHeap(void);

    public:
        // Initialization
        HRESULT Initialize(WORD nElementCount);

        // Allocation
        LPSGEHEAPRUNMARKER Alloc(LPVOID pvBuffer, DWORD dwBufferSize);
        void Free(LPSGEHEAPRUNMARKER pMarker);

        // Free element count
        DWORD GetFreeElementCount(void);

    protected:
        // Allocation
        LPSGEHEAPRUNMARKER AllocRun(LPVOID pvBaseAddress, WORD nElementCount);
        void FreeRun(LPSGEHEAPRUNMARKER pMarker);
    
        // Garbage collection
        LPSGEHEAPRUNMARKER CoalesceRuns(LPSGEHEAPRUNMARKER pMarker, LPSGEHEAPRUNMARKER pNextMarker);

        // Markers
        LPSGEHEAPRUNMARKER CreateMarker(LPSGEHEAPRUNMARKER pMarker, WORD nElement, WORD nLength, PLIST_ENTRY plePrevEntry);

        // MCPX SGE stuff
        static void MapBuffer(DWORD dwSgeIndex, LPVOID pvBaseAddress, DWORD dwLength);
        static void UnmapBuffer(LPVOID pvBaseAddress, DWORD dwLength);
    };

    __inline DWORD CMcpxBufferSgeHeap::GetFreeElementCount(void)
    {
        return m_nFreeElementCount;
    }

    __inline LPSGEHEAPRUNMARKER CMcpxBufferSgeHeap::CreateMarker(LPSGEHEAPRUNMARKER pMarker, WORD nElement, WORD nLength, PLIST_ENTRY plePrevEntry)
    {
        InsertHeadListUninit(plePrevEntry, &pMarker->leListEntry);

        pMarker->nElement = nElement;
        pMarker->nLength = nLength;
        pMarker->dwRefCount = 0;
        pMarker->pvBaseAddress = NULL;

        return pMarker;
    }
}

//
// MCP-X slop memory heap
//

namespace DirectSound
{
    class CMcpxSlopMemoryHeap
        : public CRefCount
    {
    public:
        static const DWORD              m_dwUsageThreshold;         // Minimum amount of memory the heap will track
        static CMcpxSlopMemoryHeap *    m_pSlopMemoryHeap;          // The one and only slop memory heap
        static DWORD &                  m_dwAvailable;              // Total amount of memory in the heap
        static DWORD &                  m_dwUsed;                   // Amount of memory used

    protected:
        LIST_ENTRY                      m_lstEntries;               // Allocations
        LIST_ENTRY                      m_lstRuns;                  // Heap element run list
        LPSLOPRUNMARKER                 m_pLargestFreeRunMarker;    // Largest available run

    public:
        CMcpxSlopMemoryHeap(void);
        virtual ~CMcpxSlopMemoryHeap(void);

    public:
        // Slop memory
        BOOL AddRun(LPVOID pvBaseAddress, DWORD dwLength, DWORD dwUsed);

        // Allocation
        LPVOID Alloc(DWORD dwLength);
        void Free(LPVOID pvBuffer);

    protected:
        // Garbage collection
        LPSLOPRUNMARKER CoalesceRuns(LPSLOPRUNMARKER pMarker, LPSLOPRUNMARKER pNextMarker);

        // Markers
        LPSLOPRUNMARKER CreateMarker(LPVOID pvBaseAddress, DWORD nLength, PLIST_ENTRY plePrevEntry);
    };

    __inline LPSLOPRUNMARKER CMcpxSlopMemoryHeap::CreateMarker(LPVOID pvBaseAddress, DWORD nLength, PLIST_ENTRY plePrevEntry)
    {
        LPSLOPRUNMARKER         pRunMarker  = (LPSLOPRUNMARKER)pvBaseAddress;
    
        ASSERT(nLength > sizeof(*pRunMarker));

        InsertHeadListUninit(plePrevEntry, &pRunMarker->leListEntry);

        pRunMarker->nLength = nLength;
        pRunMarker->dwSignature = 0;

        return pRunMarker;
    }
}

#endif // __cplusplus

#endif // __HEAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\heap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       heap.cpp
 *  Content:    Heap implementation objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/24/01    dereks  Created.
 *
 ****************************************************************************/

// #define MCPX_NO_SGE_SHARING

#include "dsoundi.h"

#define DPF_SGE_HEAP DPF_BLAB
#define DPF_MEM_HEAP DPF_BLAB

const DWORD CMcpxSlopMemoryHeap::m_dwUsageThreshold = 64;

CMcpxSlopMemoryHeap *CMcpxSlopMemoryHeap::m_pSlopMemoryHeap = NULL;

DWORD &CMcpxSlopMemoryHeap::m_dwAvailable = g_dwDirectSoundPhysicalMemorySlop;
DWORD &CMcpxSlopMemoryHeap::m_dwUsed = g_dwDirectSoundPhysicalMemoryRecovered;


/****************************************************************************
 *
 *  CMcpxBufferSgeHeap
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::CMcpxBufferSgeHeap"

CMcpxBufferSgeHeap::CMcpxBufferSgeHeap
(
    void
)
:   m_nFreeElementCount(g_dwDirectSoundFreeBufferSGEs)
{
    DPF_ENTER();

    InitializeListHead(&m_lstRuns);
    InitializeListHead(&m_lstMarkers);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxBufferSgeHeap
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::~CMcpxBufferSgeHeap"

CMcpxBufferSgeHeap::~CMcpxBufferSgeHeap
(
    void
)
{
    DPF_ENTER();

    MEMFREE(m_paMarkers);

    m_nFreeElementCount = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      WORD [in]: count of elements managed by the heap.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::Initialize"

HRESULT
CMcpxBufferSgeHeap::Initialize
(
    WORD                    nLength
)
{
    HRESULT                 hr;
    DWORD                   i;

    m_nFreeElementCount = nLength;

    //
    // Allocate markers, include one extra marker for slop
    //

    hr = HRFROMP(m_paMarkers = MEMALLOC(SGEHEAPRUNMARKER, nLength + 1));

    //
    // All elements are initially free, so add 1 run marker to the run list
    //

    if(SUCCEEDED(hr))
    {
        m_pLargestFreeRunMarker = CreateMarker(&m_paMarkers[0], 0, nLength, &m_lstRuns);
    }

    //
    // The remaining markers are unused
    //

    if(SUCCEEDED(hr))
    {
        for(i = 1; i < (DWORD)nLength + 1; i++)
        {
            InsertTailListUninit(&m_lstMarkers, &m_paMarkers[i].leListEntry);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Alloc
 *
 *  Description:
 *      Allocates a run of elements.
 *
 *  Arguments:
 *      LPVOID [in]: buffer.
 *      DWORD [in]: buffer size, in bytes.
 *
 *  Returns:  
 *      LPSGEHEAPRUNMARKER: run marker or NULL if the request could not be
 *                          completed.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::Alloc"

LPSGEHEAPRUNMARKER
CMcpxBufferSgeHeap::Alloc
(
    LPVOID                  pvBaseAddress,
    DWORD                   dwBufferSize
)
{
    LPSGEHEAPRUNMARKER      pRunMarker      = NULL;
    PLIST_ENTRY             pleEntry;
    LPSGEHEAPRUNMARKER      pMarkerNode;
    WORD                    nLength;
    CIrql                   irql;
    
    DPF_ENTER();

    //
    // Page-align the buffer address and size
    //

    nLength = (WORD)COMPUTE_PAGES_SPANNED(pvBaseAddress, dwBufferSize);
    pvBaseAddress = (LPVOID)((DWORD)pvBaseAddress & ~(PAGE_SIZE - 1));

    //
    // Check the list for a buffer whose SGEs we can share
    //

    irql.Raise();

#ifndef MCPX_NO_SGE_SHARING

    for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
    {
        AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

        pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

        if(pMarkerNode->dwRefCount)
        {
            if((DWORD)pvBaseAddress == (DWORD)pMarkerNode->pvBaseAddress)
            {
                if(nLength == pMarkerNode->nLength)
                {
                    pRunMarker = pMarkerNode;
                    break;
                }
            }
        }
    }

    if(pRunMarker)
    {
        //
        // We found one, so just AddRef it
        //

        ASSERT(pRunMarker->dwRefCount < MCPX_HW_MAX_VOICES);

        pRunMarker->dwRefCount++;

        DPF_SGE_HEAP("Sharing SGE run %x (ref count %lu)", pRunMarker->nElement, pRunMarker->dwRefCount);
    }
    else

#endif // MCPX_NO_SGE_SHARING

    {
        //
        // Allocate a new run and map it into SGEs.  Note that we're not 
        // setting the run marker's base address until after it's been
        // mapped.  This will prevent us from ever trying to use an unmapped
        // run if a higher IRQL call comes in.
        //
        
        if(pRunMarker = AllocRun(pvBaseAddress, nLength))
        {
            irql.Lower();

            MapBuffer(pRunMarker->nElement, pvBaseAddress, nLength);
        }
    }

    irql.Lower();

    DPF_LEAVE(pRunMarker);

    return pRunMarker;
}


/****************************************************************************
 *
 *  Free
 *
 *  Description:
 *      Frees a previously allocated run.
 *
 *  Arguments:
 *      LPSGEHEAPRUNMARKER [in]: run marker.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::Free"

void
CMcpxBufferSgeHeap::Free
(
    LPSGEHEAPRUNMARKER      pRunMarker
)
{
    LPVOID                  pvBaseAddress;
    DWORD                   dnLength;
    CIrql                   irql;
    
    DPF_ENTER();

    irql.Raise();
    
    if(!--pRunMarker->dwRefCount)
    {
        pvBaseAddress = pRunMarker->pvBaseAddress;
        dnLength = pRunMarker->nLength;
        
        FreeRun(pRunMarker);

        irql.Lower();

        UnmapBuffer(pvBaseAddress, dnLength);
    }
    
    irql.Lower();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Alloc
 *
 *  Description:
 *      Allocates a run of elements.
 *
 *  Arguments:
 *      LPVOID [in]: buffer.
 *      WORD [in]: element count.
 *
 *  Returns:  
 *      LPSGEHEAPRUNMARKER: run marker or NULL if the request could not be 
 *                          completed.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::AllocRun"

LPSGEHEAPRUNMARKER
CMcpxBufferSgeHeap::AllocRun
(
    LPVOID                  pvBaseAddress,
    WORD                    nLength
)
{
    LPSGEHEAPRUNMARKER      pRunMarker  = NULL;
    LPSGEHEAPRUNMARKER      pMarkerNode;
    PLIST_ENTRY             pleEntry;

    DPF_ENTER();

    //
    // Check the largest available run length to see if we can service
    // the request
    //

    if(m_pLargestFreeRunMarker)
    {
        if(m_pLargestFreeRunMarker->nLength >= nLength)
        {
            //
            // Find a free run that is as close as possible to the requested element
            // count.  This will help to reduce fragmentation.
            //

            for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
            {
                AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

                pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);
            
                if(!pMarkerNode->fAllocated)
                {
                    if(pMarkerNode->nLength >= nLength)
                    {
                        if(!pRunMarker)
                        {
                            pRunMarker = pMarkerNode;
                        }
                        else if(pMarkerNode->nLength < pRunMarker->nLength)
                        {
                            pRunMarker = pMarkerNode;
                        }
                    }
                }
            }

            //
            // If we're using the whole run, just flag it as allocated.  If not,
            // get a free marker from the pool and add it to the list.  We're only
            // using a single list so that runs can be broken and coalesced without
            // having to walk the list.
            //

            if(pRunMarker)
            {
                if(nLength < pRunMarker->nLength)
                {
                    ASSERT(!IsListEmpty(&m_lstMarkers));
            
                    pleEntry = RemoveHeadList(&m_lstMarkers);
                    pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

                    CreateMarker(pMarkerNode, pRunMarker->nElement + nLength, pRunMarker->nLength - nLength, &pRunMarker->leListEntry);

                    pRunMarker->nLength = nLength;

                    DPF_SGE_HEAP("Split SGE run into %x (%lu) and %x (%lu)", pRunMarker->nElement, pRunMarker->nLength, pMarkerNode->nElement, pMarkerNode->nLength);
                }
                else
                {
                    DPF_SGE_HEAP("Allocating SGE run %x (%lu)", pRunMarker->nElement, pRunMarker->nLength);
                }

                pRunMarker->fAllocated = TRUE;
                pRunMarker->pvBaseAddress = pvBaseAddress;
            }

            //
            // Update the free element count and largest run members
            //

            if(pRunMarker)
            {
                ASSERT(m_nFreeElementCount >= pRunMarker->nLength);
                m_nFreeElementCount -= pRunMarker->nLength;

                if(pRunMarker == m_pLargestFreeRunMarker)
                {
                    m_pLargestFreeRunMarker = NULL;
                    
                    for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
                    {
                        AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

                        pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);
            
                        if(!pMarkerNode->fAllocated)
                        {
                            if(!m_pLargestFreeRunMarker)
                            {
                                m_pLargestFreeRunMarker = pMarkerNode;
                            }
                            else if(pMarkerNode->nLength > m_pLargestFreeRunMarker->nLength)
                            {
                                m_pLargestFreeRunMarker = pMarkerNode;
                            }
                        }
                    }
                }                    
            }
        }
    }

    DPF_LEAVE(pRunMarker);

    return pRunMarker;
}


/****************************************************************************
 *
 *  Free
 *
 *  Description:
 *      Frees a previously allocated run.
 *
 *  Arguments:
 *      LPSGEHEAPRUNMARKER [in]: run marker.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::FreeRun"

void
CMcpxBufferSgeHeap::FreeRun
(
    LPSGEHEAPRUNMARKER      pRunMarker
)
{
    PLIST_ENTRY             pleEntry;
    LPSGEHEAPRUNMARKER      pMarkerNode;
    
    DPF_ENTER();

    ASSERT(!pRunMarker->fAllocated);

    DPF_SGE_HEAP("Freeing SGE run %x (%lu)", pRunMarker->nElement, pRunMarker->nLength);

    //
    // Update the free element count
    //

    m_nFreeElementCount += pRunMarker->nLength;

    //
    // Coalesce the run with those around it and add it back to the free 
    // marker pool.
    //

    while(TRUE)
    {
        if((pleEntry = pRunMarker->leListEntry.Flink) == &m_lstRuns)
        {
            break;
        }

        pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

        if(pMarkerNode->fAllocated)
        {
            break;
        }

        pRunMarker = CoalesceRuns(pRunMarker, pMarkerNode);
    }

    while(TRUE)
    {
        if((pleEntry = pRunMarker->leListEntry.Blink) == &m_lstRuns)
        {
            break;
        }

        pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

        if(pMarkerNode->fAllocated)
        {
            break;
        }

        pRunMarker = CoalesceRuns(pMarkerNode, pRunMarker);
    }

    //
    // Update the largest run pointer
    //

    if(m_pLargestFreeRunMarker)
    {
        if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)
        {
            m_pLargestFreeRunMarker = pRunMarker;
        }
    }
    else
    {
        m_pLargestFreeRunMarker = pRunMarker;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CoalesceRuns
 *
 *  Description:
 *      Coalesces two adjacent runs.
 *
 *  Arguments:
 *      LPSGEHEAPRUNMARKER [in]: run marker.
 *      LPSGEHEAPRUNMARKER [in]: next run marker in the list (this one will
 *                               be removed).
 *
 *  Returns:  
 *      LPSGEHEAPRUNMARKER: run marker.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::CoalesceRuns"

LPSGEHEAPRUNMARKER
CMcpxBufferSgeHeap::CoalesceRuns
(
    LPSGEHEAPRUNMARKER      pRunMarker,
    LPSGEHEAPRUNMARKER      pNextRunMarker
)
{
    DPF_ENTER();

    ASSERT(pRunMarker->nElement + pRunMarker->nLength == pNextRunMarker->nElement);

    AssertValidEntryList(&pRunMarker->leListEntry, ASSERT_IN_LIST);
    AssertValidEntryList(&pNextRunMarker->leListEntry, ASSERT_IN_LIST);

    DPF_SGE_HEAP("Coalescing SGE run %x (%lu) and %x (%lu)", pRunMarker->nElement, pRunMarker->nLength, pNextRunMarker->nElement, pNextRunMarker->nLength);

    pRunMarker->nLength += pNextRunMarker->nLength;

    MoveEntryTailList(&m_lstMarkers, &pNextRunMarker->leListEntry);

    DPF_LEAVE(pRunMarker);

    return pRunMarker;
}


/****************************************************************************
 *
 *  MapBuffer
 *
 *  Description:
 *      Maps a data buffer into SGEs.
 *
 *  Arguments:
 *      DWORD [in]: base SGE index.
 *      LPVOID [in]: data buffer.  This address must be page-aligned.
 *      DWORD [in]: data buffer size, in pages.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::MapBuffer"

void
CMcpxBufferSgeHeap::MapBuffer
(
    DWORD                   dwSgeIndex,
    LPVOID                  pvBaseAddress,
    DWORD                   dnLength
)
{
    DWORD                   dwAddress;
    CIrql                   irql;
    
    DPF_ENTER();

    ASSERT(dwSgeIndex < MCPX_HW_MAX_BUFFER_PRDS);
    ASSERT(pvBaseAddress);
    ASSERT(!((DWORD)pvBaseAddress & (PAGE_SIZE - 1)));
    ASSERT(dnLength);

    //
    // Lock the buffer data
    //

    MmLockUnlockBufferPages(pvBaseAddress, dnLength << PAGE_SHIFT, FALSE);

    //
    // Start mapping pages into SGEs
    //

    while(dnLength--)
    {
        dwAddress = MmGetPhysicalAddress(pvBaseAddress);
        ASSERT(!(dwAddress & (PAGE_SIZE - 1)));

        irql.Raise();
        
        MCPX_CHECK_VOICE_FIFO(2);

        MCPX_VOICE_WRITE(SetCurrentInBufSGE, dwSgeIndex);
        MCPX_VOICE_WRITE(SetCurrentInBufSGEOffset, dwAddress);

        irql.Lower();

        pvBaseAddress = (LPBYTE)pvBaseAddress + PAGE_SIZE;
        
        dwSgeIndex++;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  UnmapBuffer
 *
 *  Description:
 *      Unmaps a buffer mapped by MapBuffer.
 *
 *  Arguments:
 *      DWORD [in]: data buffer.  This address must be page-aligned.
 *      DWORD [in]: data buffer size, in pages.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeap::UnmapBuffer"

void
CMcpxBufferSgeHeap::UnmapBuffer
(
    LPVOID                  pvBaseAddress,
    DWORD                   dnLength
)
{
    DPF_ENTER();

    ASSERT(pvBaseAddress);
    ASSERT(!((DWORD)pvBaseAddress & (PAGE_SIZE - 1)));
    ASSERT(dnLength);

    //
    // Unlock the buffer data
    //

    MmLockUnlockBufferPages(pvBaseAddress, dnLength << PAGE_SHIFT, TRUE);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CMcpxSlopMemoryHeap
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeap::CMcpxSlopMemoryHeap"

CMcpxSlopMemoryHeap::CMcpxSlopMemoryHeap
(
    void
)
{
    DPF_ENTER();

    ASSERT(!m_dwAvailable);
    ASSERT(!m_dwUsed);

    ASSERT(!m_pSlopMemoryHeap);
    m_pSlopMemoryHeap = this;

    InitializeListHead(&m_lstEntries);
    InitializeListHead(&m_lstRuns);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxSlopMemoryHeap
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeap::~CMcpxSlopMemoryHeap"

CMcpxSlopMemoryHeap::~CMcpxSlopMemoryHeap
(
    void
)
{

#ifdef DEBUG

    LPSLOPRUNMARKER         pMarkerNode;

#endif // DEBUG

    PLIST_ENTRY             pleEntry;
    LPSLOPMEMENTRY          pEntryNode;
    LPVOID                  pvBaseAddress;

    DPF_ENTER();
    AutoIrql();

#ifdef DEBUG

    // 
    // Make sure no memory is still being used
    //
    
    for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
    {
        pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

        ASSERT(!pMarkerNode->fAllocated);
    }

#endif // DEBUG

    //
    // Free the global pointer
    //
    
    ASSERT(this == m_pSlopMemoryHeap);
    m_pSlopMemoryHeap = NULL;

    //
    // Free memory owned by the heap
    //

    while((pleEntry = RemoveHeadList(&m_lstEntries)) != &m_lstEntries)
    {
        pEntryNode = CONTAINING_RECORD(pleEntry, SLOPMEMENTRY, leListEntry);
        pvBaseAddress = pEntryNode->pvBaseAddress;
        
        PHYSFREE(pvBaseAddress);
    }

    //
    // Reset tracking values
    //

    ASSERT(!m_dwUsed);

    m_dwAvailable = 0;
    m_dwUsed = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AddRun
 *
 *  Description:
 *      Adds a run of slop memory to the heap.
 *
 *  Arguments:
 *      LPVOID [in]: base address.
 *      DWORD [in]: length, in bytes, of the allocation.
 *      DWORD [in]: length, in bytes, of the allocation that's actually being
 *                  used.
 *
 *  Returns:  
 *      BOOL: TRUE if the run was added to the heap.  If the run was added,
 *            the heap now owns the memory, so it should not be freed by the
 *            caller.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeap::AddRun"

BOOL
CMcpxSlopMemoryHeap::AddRun
(
    LPVOID                  pvBaseAddress,
    DWORD                   nLength,
    DWORD                   nUsed
)
{
    DWORD                   nSlopLength;
    LPSLOPRUNMARKER         pRunMarker;
    LPSLOPMEMENTRY          pEntry;
    BOOL                    fOwned;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Make sure the run is large enough to hold the tracking entry, at least
    // one run marker and still have some space left over for data.
    //

    ASSERT(nLength >= nUsed);
    nSlopLength = nLength - nUsed;

    if(fOwned = (nSlopLength > sizeof(*pEntry) + sizeof(*pRunMarker) + m_dwUsageThreshold))
    {
        //
        // Add the allocation to the entry list so we can free it later.  
        // We'll use the first part of the unused memory as the entry marker
        //

        pEntry = (LPSLOPMEMENTRY)((LPBYTE)pvBaseAddress + nUsed);

        pEntry->pvBaseAddress = pvBaseAddress;

        InsertTailListUninit(&m_lstEntries, &pEntry->leListEntry);

        //
        // Initialize a run marker immediately after the tracking entry and
        // add it to the run list.
        //

        pRunMarker = CreateMarker(pEntry + 1, nSlopLength - sizeof(*pEntry), &m_lstRuns);

        if(m_pLargestFreeRunMarker)
        {
            if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)
            {
                m_pLargestFreeRunMarker = pRunMarker;
            }
        }
        else
        {
            m_pLargestFreeRunMarker = pRunMarker;
        }

        m_dwAvailable += nLength;

        DPF_MEM_HEAP("Added %x to the slop heap (entry %x, run marker %x, length %lu, %lu bytes used for tracking, %lu bytes used for run marker)", pvBaseAddress, pEntry, pRunMarker, nSlopLength, sizeof(*pEntry), sizeof(*pRunMarker));
    }

    DPF_LEAVE(fOwned);

    return fOwned;
}


/****************************************************************************
 *
 *  Alloc
 *
 *  Description:
 *      Allocates memory from the heap.
 *
 *  Arguments:
 *      DWORD [in]: length, in bytes
 *
 *  Returns:  
 *      LPVOID: buffer base address or NULL.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeap::Alloc"

LPVOID
CMcpxSlopMemoryHeap::Alloc
(
    DWORD                   nLength
)
{
    LPSLOPRUNMARKER         pRunMarker      = NULL;
    LPSLOPRUNMARKER         pMarkerNode;
    PLIST_ENTRY             pleEntry;

    DPF_ENTER();
    AutoIrql();

    //
    // The length must include the space to hold the run marker
    //

    nLength += sizeof(SLOPRUNMARKER);

    //
    // Check the largest available run length to see if we can service
    // the request
    //

    if(m_pLargestFreeRunMarker)
    {
        if(m_pLargestFreeRunMarker->nLength >= nLength)
        {
            //
            // Find a free run that is as close as possible to the requested element
            // count.  This will help to reduce fragmentation.
            //

            for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
            {
                AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

                pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);
            
                if(!pMarkerNode->fAllocated)
                {
                    if(pMarkerNode->nLength >= nLength)
                    {
                        if(!pRunMarker)
                        {
                            pRunMarker = pMarkerNode;
                        }
                        else if(pMarkerNode->nLength < pRunMarker->nLength)
                        {
                            pRunMarker = pMarkerNode;
                        }
                    }
                }
            }

            //
            // If we're using the whole run, just flag it as allocated.  If not,
            // create a new marker from the remaining buffer and add it to the 
            // list.  We're only using a single list so that runs can be broken 
            // and coalesced without having to walk the list.
            //

            if(pRunMarker)
            {
                if(nLength + sizeof(*pRunMarker) + m_dwUsageThreshold < pRunMarker->nLength)
                {
                    pMarkerNode = CreateMarker((LPBYTE)pRunMarker + nLength, pRunMarker->nLength - nLength, &pRunMarker->leListEntry);

                    pRunMarker->nLength = nLength;

                    DPF_MEM_HEAP("Split memory run into %x (%lu) and %x (%lu)", pRunMarker, pRunMarker->nLength, pMarkerNode, pMarkerNode->nLength);
                }
                else
                {
                    DPF_MEM_HEAP("Allocating memory run %x (%lu)", pRunMarker, pRunMarker->nLength);
                }

                pRunMarker->dwSignature = DSOUND_ALLOCATOR_SLOP;
            }

            //
            // Update the largest run member
            //

            if(pRunMarker)
            {
                if(pRunMarker == m_pLargestFreeRunMarker)
                {
                    m_pLargestFreeRunMarker = NULL;
                    
                    for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
                    {
                        AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

                        pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);
            
                        if(!pMarkerNode->fAllocated)
                        {
                            if(!m_pLargestFreeRunMarker)
                            {
                                m_pLargestFreeRunMarker = pMarkerNode;
                            }
                            else if(pMarkerNode->nLength > m_pLargestFreeRunMarker->nLength)
                            {
                                m_pLargestFreeRunMarker = pMarkerNode;
                            }
                        }
                    }
                }                    
            }

            //
            // Update the amount of memory recovered
            //

            if(pRunMarker)
            {
                m_dwUsed += pRunMarker->nLength;
            }

            //
            // AddRef ourselves so we're always around as long as allocated
            // memory is.
            //

            if(pRunMarker)
            {
                AddRef();
            }
        }
    }

    DPF_LEAVE(pRunMarker ? pRunMarker + 1 : NULL);

    return pRunMarker ? pRunMarker + 1 : NULL;
}


/****************************************************************************
 *
 *  Free
 *
 *  Description:
 *      Frees a previously allocated run.
 *
 *  Arguments:
 *      LPVOID [in]: buffer base address.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeap::Free"

void
CMcpxSlopMemoryHeap::Free
(
    LPVOID                  pvBaseAddress
)
{
    LPSLOPRUNMARKER         pRunMarker  = (LPSLOPRUNMARKER)pvBaseAddress - 1;
    PLIST_ENTRY             pleEntry;
    LPSLOPRUNMARKER         pMarkerNode;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(DSOUND_ALLOCATOR_SLOP == pRunMarker->dwSignature);

    DPF_MEM_HEAP("Freeing memory run %x (%lu)", pRunMarker, pRunMarker->nLength);

    //
    // Update the amount of memory recovered
    //

    ASSERT(m_dwUsed >= pRunMarker->nLength);
    m_dwUsed -= pRunMarker->nLength;

    //
    // Reset the run signature so it's flagged as free
    //

    pRunMarker->dwSignature = 0;

    //
    // Coalesce the run with those around it
    //

    while(TRUE)
    {
        if((pleEntry = pRunMarker->leListEntry.Flink) == &m_lstRuns)
        {
            break;
        }

        pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

        if(pMarkerNode->fAllocated)
        {
            break;
        }

        if((LPBYTE)pRunMarker + pRunMarker->nLength != (LPBYTE)pMarkerNode)
        {
            break;
        }

        pRunMarker = CoalesceRuns(pRunMarker, pMarkerNode);
    }

    while(TRUE)
    {
        if((pleEntry = pRunMarker->leListEntry.Blink) == &m_lstRuns)
        {
            break;
        }

        pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

        if(pMarkerNode->fAllocated)
        {
            break;
        }

        if((LPBYTE)pMarkerNode + pMarkerNode->nLength != (LPBYTE)pRunMarker)
        {
            break;
        }

        pRunMarker = CoalesceRuns(pMarkerNode, pRunMarker);
    }

    //
    // Update the largest run pointer
    //

    if(m_pLargestFreeRunMarker)
    {
        if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)
        {
            m_pLargestFreeRunMarker = pRunMarker;
        }
    }
    else
    {
        m_pLargestFreeRunMarker = pRunMarker;
    }

    //
    // Release the reference added in Alloc
    //

    Release();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CoalesceRuns
 *
 *  Description:
 *      Coalesces two adjacent runs.
 *
 *  Arguments:
 *      LPSLOPRUNMARKER [in]: run marker.
 *      LPSLOPRUNMARKER [in]: next run marker in the list (this one will be 
 *                           removed).
 *
 *  Returns:  
 *      LPSLOPRUNMARKER: run marker.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeap::CoalesceRuns"

LPSLOPRUNMARKER
CMcpxSlopMemoryHeap::CoalesceRuns
(
    LPSLOPRUNMARKER         pRunMarker,
    LPSLOPRUNMARKER         pNextRunMarker
)
{
    DPF_ENTER();

    ASSERT((LPBYTE)pRunMarker + pRunMarker->nLength == (LPBYTE)pNextRunMarker);
    ASSERT(!pRunMarker->fAllocated);
    ASSERT(!pNextRunMarker->fAllocated);

    AssertValidEntryList(&pRunMarker->leListEntry, ASSERT_IN_LIST);
    AssertValidEntryList(&pNextRunMarker->leListEntry, ASSERT_IN_LIST);

    DPF_MEM_HEAP("Coalescing memory run %x (%lu) and %x (%lu)", pRunMarker, pRunMarker->nLength, pNextRunMarker, pNextRunMarker->nLength);

    pRunMarker->nLength += pNextRunMarker->nLength;
    
    RemoveEntryList(&pNextRunMarker->leListEntry);

    DPF_LEAVE(pRunMarker);

    return pRunMarker;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\gpdsp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       gpdsp.cpp
 *  Content:    GP dsp manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/2001    georgioc created
 *
 ****************************************************************************/


#include "dsoundi.h"
#include "dspdma.h"
#include "GPDsp.h"

//
// include dsp code words for default execution engine loaded into GP after reset
//

#ifdef MCPX_BOOT_LIB

static ULONG DefaultExec[] = 
{
    #include "dspbootsndcode.h"
};

#else // MCPX_BOOT_LIB
    
static ULONG DefaultExec[] = 
{
    #include "dspexeccode.h"
};

#endif // MCPX_BOOT_LIB


VOID
CMcpxDspImage::Initialize()
{
    //
    // initialize all the effects here
    //

    m_pLoader = (PVOID)DefaultExec;
    m_uLoaderSize = sizeof(DefaultExec);
   
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// DSP DMA Manager for the GP
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


CMcpxGPDspManager::CMcpxGPDspManager()
{
    m_pScratchDma = NULL;
    m_pDspImage = NULL;
    m_uPMemMaxSize = NV_PAPU_GPPMEM__SIZE_1;
    m_uPMemOffset = 0;

    m_dwCurrentLowestScratchOffset = MCPX_GLOBAL_PROC_SCRATCH_SIZE;
    m_dwStateSizeToCommit = 0;

}

CMcpxGPDspManager::~CMcpxGPDspManager()
{
    DELETE(m_pScratchDma);
    DELETE(m_pDspImage);
#ifndef MCPX_BOOT_LIB
    DELETE(m_pFxDescriptor);
#endif
}

VOID   
CMcpxGPDspManager::Initialize()
{
    //
    // create the dsp table class that holds the code for all effects + loader
    //

    m_pDspImage = NEW(CMcpxDspImage());
    ASSERT(m_pDspImage);

    m_pDspImage->Initialize();

    //
    // allocate the scratch Dma, telling it we are the GP
    //

    m_pScratchDma = NEW(CMcpxDspScratchDma(TRUE));
    ASSERT(m_pScratchDma);

    //
    // initialize scratch space handler
    //

    m_pScratchDma->Initialize(MCPX_HW_AC3_NUM_INPUT_PAGES+MCPX_HW_MULTIPASS_NUM_PAGES+MCPX_HW_MAX_FX_SCRATCH_PAGES);
    
    if (!m_pScratchDma)
    {
        ASSERT(FALSE && "CMcpxDspManager::Initialize - one of the objects could not be constructed\n");
        return;
    }
    
    ULONG uOffset = 0;

    ASSERT(m_pDspImage->GetLoaderSize() < DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // load a default exec program to get the GP pumping data to system memory
    //
    
    m_pScratchDma->Copy(uOffset,
                        (VOID *)m_pDspImage->GetLoader(),
                        m_pDspImage->GetLoaderSize());

    return ;

}

HRESULT CMcpxGPDspManager::DownloadEffectsImage
(
    LPCVOID                 pvImageBuffer, 
    DWORD                   dwImageSize,
    LPDSEFFECTIMAGEDESC *   ppImageDesc
)
{

    HRESULT hr = DS_OK;
#ifndef MCPX_BOOT_LIB

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;

    //
    // do some basic validation of the image
    // this should be the image generated by our XPS2 tool..
    //

    ASSERT(dwImageSize > (DSP_COMMANDBLOCK_SCRATCHOFFSET + sizeof(HOST_TO_DSP_COMMANDBLOCK)));

    //
    // verify that command block is preset for instructing the DSP to download new
    // code and state
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)pvImageBuffer + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    ASSERT(pCmdBlock->dwCommandFlags & BIT_H2DCB_COMMAND_LOAD_CODE);
    ASSERT(pCmdBlock->dwCommandFlags & BIT_H2DCB_COMMAND_LOAD_XRAM_STATE);

    ASSERT(dwImageSize <= MCPX_GLOBAL_PROC_SCRATCH_SIZE);

    //
    // proceed to copy the buffer they passed us into offset 0 of scratch memory
    // first zero out the flags in the command block so the dsp does not attempt
    // to download yet
    //

    PHOST_TO_DSP_COMMANDBLOCK pPrivateCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);
    memset(pPrivateCmdBlock,0,sizeof(HOST_TO_DSP_COMMANDBLOCK));

    //
    // copy their image into two parts: 1st part is the command block, second is the rest
    // we dont copy the flags since we want them 0 in the scratch image
    //

    pPrivateCmdBlock->dwOffset = pCmdBlock->dwOffset;
    pPrivateCmdBlock->dwCodeLength = pCmdBlock->dwCodeLength;
    pPrivateCmdBlock->dwStateOffset = pCmdBlock->dwStateOffset;
    pPrivateCmdBlock->dwStateLength = pCmdBlock->dwStateLength;
    pPrivateCmdBlock->dwDspStatus = pCmdBlock->dwDspStatus;

    m_pScratchDma->Copy(DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK),
                        (PUCHAR)pCmdBlock+sizeof(HOST_TO_DSP_COMMANDBLOCK),
                        dwImageSize - DSP_COMMANDBLOCK_SCRATCHOFFSET - sizeof(HOST_TO_DSP_COMMANDBLOCK));

    //
    // parse FX description array, to be used by the SetEffectData api
    //

    hr = ParseEffectImageInfo(pvImageBuffer);
    if (FAILED(hr)){
        return hr;
    }

    if(ppImageDesc) {
        *ppImageDesc = m_pFxDescriptor;
    }

    //
    // we need to keep a cached version of the command block associated with this image
    // We do this so if the user calls SetEffectData and then a delta panic occurs,
    // we can restore the command block and re-download the original code from the
    // correct offset
    //

    memcpy(&m_InitialCmdBlock,pPrivateCmdBlock,sizeof(m_InitialCmdBlock));

#endif //MCPX_BOOT_LIB

    return hr;


}

VOID CMcpxGPDspManager::RestoreCommandBlock() 
{

    PHOST_TO_DSP_COMMANDBLOCK pPrivateCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    pPrivateCmdBlock->dwCommandFlags = 0;
    memcpy(pPrivateCmdBlock,&m_InitialCmdBlock,sizeof(m_InitialCmdBlock));

}

HRESULT CMcpxGPDspManager::ParseEffectImageInfo(LPCVOID pScratchImage)
{
    DWORD dwValue;
    HRESULT hr = S_OK;

#ifndef MCPX_BOOT_LIB

    //
    // retrieve and cache the FX description array
    // We will use it later when the game calls the UpdateEffectParameters API
    //

    LPDSEFFECTIMAGEDESC pDescriptor;
    UCHAR szKey[8];
    int err;
    DWORD dwFxScratchSize = 0;

    PUCHAR pCodeBlock;
    PUCHAR pKeyBlock;

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    pDescriptor = (LPDSEFFECTIMAGEDESC) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() +
        DSP_COMMANDBLOCK_SCRATCHOFFSET +\
        sizeof(HOST_TO_DSP_COMMANDBLOCK) +\
        (pCmdBlock->dwCodeLength*sizeof(DWORD)) +\
        (pCmdBlock->dwStateLength*sizeof(DWORD)) );


	//
	// initialize descriptor
	//

	DWORD dwDescriptorSize = sizeof(DSEFFECTIMAGEDESC) + 
		sizeof(DSEFFECTMAP)*(pDescriptor->dwEffectCount-1);


    if (m_pFxDescriptor != NULL) {

        DELETE(m_pFxDescriptor);
        
    }

    m_pFxDescriptor = (LPDSEFFECTIMAGEDESC) NEW(BYTE[dwDescriptorSize]);

    if (m_pFxDescriptor == NULL) {
        return E_OUTOFMEMORY;
    }

    //
    // check the scratch space usage for the FX chain
    // adjust our ram allocation if required
    //

    if (FAILED(hr = m_pScratchDma->AdjustFxScratch(pDescriptor->dwTotalScratchSize))){
        return hr;
    }

    //
    // we will have to decode the dsp code words since each one
    // is encrypted, using a different dsp dev supplied key.
    // we do in-place decryption
    //

    pCodeBlock = (PUCHAR)pCmdBlock + sizeof(HOST_TO_DSP_COMMANDBLOCK);
    pKeyBlock = (PUCHAR)pDescriptor + dwDescriptorSize;

    //
    // decode keys used to encrypt block
    //

	XAudiopUtility_GenerateKey(szKey);

	err = XAudiopUtility_Decode(szKey,
		pKeyBlock,
		KEY_SIZE*pDescriptor->dwEffectCount,
		pKeyBlock,
		FALSE);
	
    hr = HRESULT_FROM_WIN32(err);
    if (FAILED(hr)) {
        DPF_ERROR("Keyblock decode failed with hr = %x",hr);
        return hr;
    }

    //
    // we need to convert all offsets in FX description elements
    // from relative (the tool creates relative offsets) to absolute
    // This way the caller can treat the LPVOIDs into State, Ymem, Code
    // as normal virtual memory pointers. 
    //

    for (ULONG i=0;i<pDescriptor->dwEffectCount;i++) {

        //
        // decode key block in place using appropriate key
        //

        err = XAudiopUtility_Decode((pKeyBlock+i*KEY_SIZE),
            pCodeBlock,
            pDescriptor->aEffectMaps[i].dwCodeSize,
            pCodeBlock,
            FALSE);
        
        hr = HRESULT_FROM_WIN32(err);
        if (FAILED(hr)) {
            DPF_ERROR("code block decode failed with hr = %x",hr);
            return hr;
        }

        pCodeBlock += pDescriptor->aEffectMaps[i].dwCodeSize;

        //
        // convert code first
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvCodeSegment;

        //
        // create a P-memory absolute address in bytes
        //

        dwValue -= (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));

        //
        // the fx start after the default engine P-words
        //

        dwValue += m_pDspImage->GetLoaderSize();

        //
        // convert P-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPPMEM_REG_OFFSET;

        pDescriptor->aEffectMaps[i].lpvCodeSegment = (LPVOID)dwValue;

        //
        // do the same for Y memory. The tool creates absolute Ymem addresses
        // so all we need to do is add the register space offset
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvYMemorySegment;

        //
        // convert Y-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPYMEM_REG_OFFSET;
        pDescriptor->aEffectMaps[i].lpvYMemorySegment = (LPVOID)dwValue;

        //
        // now convert X-memory relative address
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvStateSegment;

        //
        // create a X-memory absolute address in bytes
        //

        dwValue -= (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));
        dwValue -= pCmdBlock->dwCodeLength*sizeof(DWORD);
        dwValue += DSP_FX_STATE_XMEMORY_BASE_OFFSET;

        //
        // convert X-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPXMEM_REG_OFFSET;
        pDescriptor->aEffectMaps[i].lpvStateSegment = (LPVOID)dwValue;

        //
        // finally fixup scratch space offset to point to a real VA, not
        // just a relative scratch offset
        //

        dwValue = (DWORD)pDescriptor->aEffectMaps[i].lpvScratchSegment;
        dwValue += (DWORD) m_pScratchDma->GetFxScratchSpaceLinAddr();

        //
        // subtract the fx delay line base offset
        //

        dwValue -= DSP_FX_DELAY_DATA_SCRATCHOFFSET;

        pDescriptor->aEffectMaps[i].lpvScratchSegment = (LPVOID) dwValue;
        
    }

    memcpy(m_pFxDescriptor,pDescriptor,dwDescriptorSize);

    //
    // the dsp will automagically DMA in the new FX dsp code and state when its done with the
    // current 32 sample block processing...
    //

    pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_CODE | BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;

    volatile DWORD *pdwflags = &pCmdBlock->dwCommandFlags;
    while(*pdwflags != 0);

#endif // MCPX_BOOT_LIB

    return S_OK;

}


HRESULT
CMcpxGPDspManager::SetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPCVOID                 pvData, 
    DWORD                   dwDataSize,
    DWORD                   dwFlags
)
{
    LPCDSEFFECTMAP pFxDesc;
    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
    DWORD dwScratchOffset;
    LPVOID pvXramBuffer;
    HRESULT hr;

    ASSERT(dwDataSize >= sizeof(DWORD));

    //
    // FX offset and size must be dword aligned
    //

    ASSERT(!(dwDataSize & 0x00000003));
    ASSERT(!(dwOffset & 0x00000003));

    //
    // get effect map
    //

    hr = GetEffectMap(dwEffectIndex, &pFxDesc);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // validate fx specific parameters
    //

    ASSERT(pFxDesc->dwStateSize >= (dwOffset+dwDataSize));

    //
    // copy in the data they want to update
    // figure a scratch offset, from the mcpx base register space offset
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // we reverse-engineer the scratch offset we stomped on in SetFxDescriptor..
    // needless to say this is magic so if you plan to change make sure you change
    // xgpimage AND SetFxDescriptor correctly as well
    //

    dwScratchOffset = (DWORD)pFxDesc->lpvStateSegment;
    dwScratchOffset -= MCPX_HW_GPXMEM_REG_OFFSET;
    dwScratchOffset -= DSP_FX_STATE_XMEMORY_BASE_OFFSET;
    dwScratchOffset += (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));
    dwScratchOffset += pCmdBlock->dwCodeLength*sizeof(DWORD);

    dwScratchOffset += dwOffset;
       
    //
    // copy in the data they want to update
    //

    m_pScratchDma->Copy(dwScratchOffset,
                        (PVOID)pvData,
                        dwDataSize);

    if (dwFlags & DSFX_DEFERRED) {        

        //
        // based on where the offset they are updating is, we might have to update
        // our scratch image to deal with sparse memory pokes. If somebody calls
        // SetEffectData(FALSE) twice but the two memory blocks they are updating are
        // non-contigious, we need to fill in the in between memory with latest state
        // from the dsp. Then at commit time, we can commit one big block all at once
        //

        if (m_dwCurrentLowestScratchOffset != MCPX_GLOBAL_PROC_SCRATCH_SIZE) {

            //
            // this is not the first deferred SetEffectData command
            // so we can go ahead and do the sparse checks
            //

            if ((m_dwCurrentLowestScratchOffset+m_dwStateSizeToCommit) < dwScratchOffset) {
    
                //
                // sparse update, on the high end...
                //
    
                dwDataSize += dwScratchOffset - (m_dwCurrentLowestScratchOffset+m_dwStateSizeToCommit);
    
            } else if (m_dwCurrentLowestScratchOffset > (dwScratchOffset+dwDataSize)){
    
                //
                // sparse update below the last block updated
                //
    
                dwDataSize += m_dwCurrentLowestScratchOffset-(dwScratchOffset+dwDataSize);
    
            }

        }

        m_dwCurrentLowestScratchOffset = min(m_dwCurrentLowestScratchOffset,dwScratchOffset);
        m_dwStateSizeToCommit += dwDataSize;

    } else {

        //
        // if they want to commit now, poke directly the XRAM offset
        //

        pvXramBuffer = (LPVOID) ((DWORD)pFxDesc->lpvStateSegment + dwOffset);
        memcpy(pvXramBuffer,pvData,dwDataSize);
    }

    return DS_OK;

}


HRESULT
CMcpxGPDspManager::GetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    LPCDSEFFECTMAP pFxDesc;
    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
    DWORD dwScratchOffset;
    LPVOID pvXramBuffer;
    HRESULT hr;

    ASSERT(dwDataSize >= sizeof(DWORD));

    //
    // FX offset and size must be dword aligned
    //

    ASSERT(!(dwDataSize & 0x00000003));
    ASSERT(!(dwOffset & 0x00000003));

    //
    // get effect map
    //

    hr = GetEffectMap(dwEffectIndex, &pFxDesc);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // validate fx specific parameters
    //

    ASSERT(pFxDesc->dwStateSize >= (dwOffset+dwDataSize));

    //
    // copy fx data
    //

    pvXramBuffer = (LPVOID) ((DWORD)pFxDesc->lpvStateSegment + dwOffset);
    memcpy(pvData,pvXramBuffer,dwDataSize);

    return DS_OK;

}


HRESULT
CMcpxGPDspManager::GetEffectMap
(
    DWORD                   dwEffectIndex, 
    LPCDSEFFECTMAP *        ppEffectMap
)
{
    DSEFFECTIMAGEDESC* pDescriptor = m_pFxDescriptor;

    ASSERT(pDescriptor);
    ASSERT(ppEffectMap);

    //
    // validate params
    //

    if (dwEffectIndex > pDescriptor->dwEffectCount-1) {

        DPF_ERROR("Zero-based Effect Index (%d) is larger than number of Effects (%d) currently loaded in DSP",
                  dwEffectIndex,
                  pDescriptor->dwEffectCount-1);

        return DSERR_INVALIDCALL;

    }

    //
    // retrieve the effect they want to modify
    //

    *ppEffectMap = &pDescriptor->aEffectMaps[dwEffectIndex];

    return DS_OK;
}


VOID
CMcpxGPDspManager::CommitChanges(DWORD dwScratchOffset,DWORD dwDataSize)
{

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;

    if (dwDataSize == 0) {

        //
        // use internal members for deferred state update
        //

        dwDataSize = m_dwStateSizeToCommit;
        dwScratchOffset = m_dwCurrentLowestScratchOffset;

        if ((dwScratchOffset == MCPX_GLOBAL_PROC_SCRATCH_SIZE) ||
            (dwDataSize == 0)) {

            //
            // no changes to commit
            //

            DPF_WARNING("CommitEffectData was called but there were no deferred changes!!");
            return;

        }
    }


    //
    // the caller wants to update internal DSP state with this call
    // set up the command block, to signal the DSP to DMA in the new state
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // before we go stomping on the existing command block
    // make sure there is no other pending command
    //

    volatile DWORD *pdwflags = &pCmdBlock->dwCommandFlags;
    while(*pdwflags != 0);

    //
    // create xram offset
    // the original base offset can be calculated from the code size
    // the DSP default engine will add this offset to the base offset where the concatenated state blocks live
    //

    
    pCmdBlock->dwOffset = dwScratchOffset/sizeof(DWORD) - 
        (pCmdBlock->dwCodeLength+sizeof(HOST_TO_DSP_COMMANDBLOCK)/sizeof(DWORD)) -
        (DSP_COMMANDBLOCK_SCRATCHOFFSET/sizeof(DWORD));

    pCmdBlock->dwStateOffset = dwScratchOffset;
    pCmdBlock->dwStateLength = dwDataSize/sizeof(DWORD);

    pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;

    //
    // set internal member to signal deferred state updates have been flushed
    //

    m_dwCurrentLowestScratchOffset = MCPX_GLOBAL_PROC_SCRATCH_SIZE;
    m_dwStateSizeToCommit = 0;

}

VOID
CMcpxGPDspManager::AC3SetOutputBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages)
{
    //
    // we need to add these pages to the GP dma table
    //

    m_pScratchDma->AddPages(pMem, uNumOfPages, &m_uAC3BufferOffset);

    return;
}

VOID
CMcpxGPDspManager::SetMultipassBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages)
{
    //
    // we need to add these pages to the GP dma table
    //

    m_pScratchDma->AddPages(pMem, uNumOfPages, &m_uMultipassBufferOffset);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\hrtf.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HRTF.h
 *  Content:    HRTF 3D objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/13/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __HRTF_H__
#define __HRTF_H__

//
// 3D calculation flags
//

#define MCPX_3DCALC_NORMPOS                 0x00000001
#define MCPX_3DCALC_LEFTRIGHT               0x00000002
#define MCPX_3DCALC_DISTANCE                0x00000004
#define MCPX_3DCALC_DIRECTION               0x00000008
#define MCPX_3DCALC_CONEVOLUME              0x00000010
#define MCPX_3DCALC_FRONTREAR               0x00000020
#define MCPX_3DCALC_DOPPLER                 0x00000040
#define MCPX_3DCALC_I3DL2SOURCE             0x00000080
#define MCPX_3DCALC_I3DL2LISTENER           0x00000100
#define MCPX_3DCALC_LISTENER_ORIENTATION    0x00000200

#define DS3DPARAM_LISTENER_DISTANCEFACTOR   (MCPX_3DCALC_FRONTREAR | MCPX_3DCALC_DOPPLER)
#define DS3DPARAM_LISTENER_DOPPLERFACTOR    (MCPX_3DCALC_DOPPLER)
#define DS3DPARAM_LISTENER_ROLLOFFFACTOR    (MCPX_3DCALC_DISTANCE)
#define DS3DPARAM_LISTENER_ORIENTATION      (MCPX_3DCALC_LEFTRIGHT | MCPX_3DCALC_DISTANCE | MCPX_3DCALC_FRONTREAR | MCPX_3DCALC_LISTENER_ORIENTATION)
#define DS3DPARAM_LISTENER_POSITION         (MCPX_3DCALC_NORMPOS | MCPX_3DCALC_LEFTRIGHT | MCPX_3DCALC_DISTANCE | MCPX_3DCALC_DIRECTION | MCPX_3DCALC_CONEVOLUME | MCPX_3DCALC_FRONTREAR | MCPX_3DCALC_DOPPLER | MCPX_3DCALC_I3DL2SOURCE)
#define DS3DPARAM_LISTENER_VELOCITY         (MCPX_3DCALC_DOPPLER)
#define DS3DPARAM_LISTENER_I3DL2            (MCPX_3DCALC_I3DL2SOURCE | MCPX_3DCALC_I3DL2LISTENER)
#define DS3DPARAM_LISTENER_MASK             (MCPX_3DCALC_NORMPOS | MCPX_3DCALC_LEFTRIGHT | MCPX_3DCALC_DISTANCE | MCPX_3DCALC_DIRECTION | MCPX_3DCALC_CONEVOLUME | MCPX_3DCALC_FRONTREAR | MCPX_3DCALC_DOPPLER | MCPX_3DCALC_I3DL2SOURCE | MCPX_3DCALC_LISTENER_ORIENTATION)

#define DS3DPARAM_BUFFER_CONEANGLES         (MCPX_3DCALC_CONEVOLUME)
#define DS3DPARAM_BUFFER_CONEORIENTATION    (MCPX_3DCALC_DIRECTION | MCPX_3DCALC_CONEVOLUME)
#define DS3DPARAM_BUFFER_CONEOUTSIDEVOLUME  (MCPX_3DCALC_CONEVOLUME)
#define DS3DPARAM_BUFFER_MAXDISTANCE        (MCPX_3DCALC_DISTANCE)
#define DS3DPARAM_BUFFER_MINDISTANCE        (MCPX_3DCALC_DISTANCE)
#define DS3DPARAM_BUFFER_POSITION           (MCPX_3DCALC_NORMPOS | MCPX_3DCALC_LEFTRIGHT | MCPX_3DCALC_DISTANCE | MCPX_3DCALC_DIRECTION | MCPX_3DCALC_CONEVOLUME | MCPX_3DCALC_FRONTREAR | MCPX_3DCALC_DOPPLER | MCPX_3DCALC_I3DL2SOURCE)
#define DS3DPARAM_BUFFER_VELOCITY           (MCPX_3DCALC_DOPPLER)
#define DS3DPARAM_BUFFER_FREQUENCY          (MCPX_3DCALC_DOPPLER)
#define DS3DPARAM_BUFFER_DISTANCEFACTOR     (MCPX_3DCALC_FRONTREAR | MCPX_3DCALC_DOPPLER)
#define DS3DPARAM_BUFFER_DOPPLERFACTOR      (MCPX_3DCALC_DOPPLER)
#define DS3DPARAM_BUFFER_ROLLOFFFACTOR      (MCPX_3DCALC_DISTANCE)
#define DS3DPARAM_BUFFER_I3DL2              (MCPX_3DCALC_I3DL2SOURCE)
#define DS3DPARAM_BUFFER_MASK               (MCPX_3DCALC_NORMPOS | MCPX_3DCALC_LEFTRIGHT | MCPX_3DCALC_DISTANCE | MCPX_3DCALC_DIRECTION | MCPX_3DCALC_CONEVOLUME | MCPX_3DCALC_FRONTREAR | MCPX_3DCALC_DOPPLER | MCPX_3DCALC_I3DL2SOURCE)

//
// Pan3d algorithm speaker locations
//

BEGIN_DEFINE_STRUCT()
    union 
    {
        D3DVECTOR   vSpeakerPos;    // Speaker position in 3D space
        VECTOR4     v4SpeakerPos;   // Speaker position in 4D space
    }; 

    DWORD       dwMixBin;           // Speaker mixbin identifier
END_DEFINE_STRUCT(PAN3DSPEAKER);

#define PAN3D_DEFAULT_SPEAKER_DATA \
    { { -0.7f, 0.0f,  0.7f }, DSMIXBIN_3D_FRONT_LEFT }, \
    { {  0.7f, 0.0f,  0.7f }, DSMIXBIN_3D_FRONT_RIGHT }, \
    { { -0.7f, 0.0f, -0.7f }, DSMIXBIN_3D_BACK_LEFT }, \
    { {  0.7f, 0.0f, -0.7f }, DSMIXBIN_3D_BACK_RIGHT },\
    { {  0.0f, 0.0f,  1.0f }, DSMIXBIN_FRONT_CENTER },

#define PAN3D_SPEAKER_COUNT 5

//
// 31-tap, 8-bit FIR filter coefficient data
//

BEGIN_DEFINE_STRUCT()
    BYTE    Coeff[31];
    BYTE    Delay;
END_DEFINE_STRUCT(FIRFILTER8);

//
// 3D filter pair
//

BEGIN_DEFINE_STRUCT()
    LPCFIRFILTER8   pLeftFilter;
    LPCFIRFILTER8   pRightFilter;
END_DEFINE_STRUCT(HRTFFILTERPAIR);

//
// 3D calculator types
//

BEGIN_DEFINE_ENUM()
    DS3DALG_FULL_HRTF = 0,
    DS3DALG_LIGHT_HRTF,
    DS3DALG_PAN,
    DS3DALG_COUNT,
END_DEFINE_ENUM_();

#define DS3DALG_FIRST DS3DALG_FULL_HRTF
#define DS3DALG_LAST DS3DALG_PAN
#define DS3DALG_INVALID DS3DALG_COUNT

//
// 3D listener parameters
//

BEGIN_DEFINE_STRUCT()
    D3DVECTOR       vNormOrient;                        // Full & light HRTF only
    PAN3DSPEAKER    aSpeakers[PAN3D_SPEAKER_COUNT];     // Pan3D only
END_DEFINE_STRUCT(HRTFLISTENER);

//
// 3D source parameters
//

BEGIN_DEFINE_STRUCT()
    D3DVECTOR       vNormPos;
    FLOAT           flMagPos;
    FLOAT           flAzimuth;
    FLOAT           flElevation;
    FLOAT           flThetaS;
END_DEFINE_STRUCT(HRTFSOURCE);

//
// 3D voice parameters
//

#define MCPX_3DAPPLY_DISTANCEVOLUME     0x00000001
#define MCPX_3DAPPLY_CONEVOLUME         0x00000002
#define MCPX_3DAPPLY_FRONTVOLUME        0x00000004
#define MCPX_3DAPPLY_REARVOLUME         0x00000008
#define MCPX_3DAPPLY_DOPPLERPITCH       0x00000010
#define MCPX_3DAPPLY_FILTERPAIR         0x00000020
#define MCPX_3DAPPLY_MASK               0x0000003F

BEGIN_DEFINE_STRUCT()
    DWORD               dwChangeMask;
    DWORD               dwMixBinValidMask;
    DWORD               dwMixBinChangeMask;
    LONG                lDistanceVolume;
    LONG                lConeVolume;
    LONG                lFrontVolume;
    LONG                lRearVolume;
    LONG                lDopplerPitch;
    HRTFFILTERPAIR      FilterPair;
    LONG                alMixBinVolumes[DSMIXBIN_COUNT];
END_DEFINE_STRUCT(HRTFVOICE);

//
// 3D API parameters
//

BEGIN_DEFINE_STRUCT()
    DS3DLISTENER    HrtfParams;             // 3D listener parameters
    DSI3DL2LISTENER I3dl2Params;            // I3DL2 listener parameters
    DWORD           dwParameterMask;        // 3D source properties that have changed
END_DEFINE_STRUCT(DS3DLISTENERPARAMS);

BEGIN_DEFINE_STRUCT()
    DS3DBUFFER      HrtfParams;             // 3D source parameters
    DSI3DL2BUFFER   I3dl2Params;            // I3DL2 source parameters
    const FLOAT *   paflRolloffPoints;      // Rolloff curve points
    DWORD           dwRolloffPointCount;    // Number of points in the rolloff curve
    DWORD           dwParameterMask;        // 3D source properties that have changed
END_DEFINE_STRUCT(DS3DSOURCEPARAMS);

#ifdef __cplusplus

//
// Forward declarations
//

namespace DirectSound
{
    class CHrtfSource;
}

//
// HRTF data calculation function
//

namespace DirectSound
{
    typedef void (*LPFNHRTFCALC)(DWORD dwOperation, CHrtfSource *pSource);
    typedef void (*LPFNGETHRTFFILTERPAIR)(CHrtfSource *pSource);
}

//
// 3D listener
//

namespace DirectSound
{
    class CHrtfListener
    {
        friend class CHrtfSource;
        friend class CFullHrtfSource;
        friend class CLightHrtfSource;
        friend class CPan3dSource;

    protected:
        static const D3DVECTOR      m_vDefaultNormOrient;                       // Default normalized orientation
        static const D3DVECTOR      m_vDefaultNormFrontOrient;                  // Default normalized front orientation

        static const PAN3DSPEAKER   m_aDefaultSpeakers[PAN3D_SPEAKER_COUNT];    // Default Pan3d speaker data

        D3DMATRIX *                 m_pTransformMatrix;

        REFDS3DLISTENER             m_3dParams;                                 // 3D parameters
        HRTFLISTENER                m_3dData;                                   // 3D calculation data
        BOOLEAN                     m_fSurround;                                // Surround or stereo?

    public:
        CHrtfListener(REFDS3DLISTENER ds3dl);
        ~CHrtfListener();

    public:
        void Calculate3d(DWORD dwOperation);
    };    
}

//
// Full 3D source
//

namespace DirectSound
{
    class CFullHrtfSource
    {
        friend class CLightHrtfSource;
        friend class CPan3dSource;

    public:
        enum
        {
            DS3DALG = DS3DALG_FULL_HRTF
        };

    public:
        // Calculation functions
        static void Calculate3d(DWORD dwOperation, CHrtfSource *pSource);
    
        // HRTF filter coefficients
        static void GetHrtfFilterPair(CHrtfSource *pSource);

    protected:
        // Calculation functions
        static void CalcNormPos(CHrtfSource *pSource);
        static void CalcLeftRightGains(CHrtfSource *pSource);
        static void CalcDistanceVolume(CHrtfSource *pSource);
        static void CalcDirection(CHrtfSource *pSource);
        static void CalcConeVolume(CHrtfSource *pSource);
        static void CalcFrontRearGains(CHrtfSource *pSource);
        static void CalcDoppler(CHrtfSource *pSource);
    };
}

//
// Light 3D source
//

namespace DirectSound
{
    class CLightHrtfSource
    {
        friend class CPan3dSource;

    public:
        enum
        {
            DS3DALG = DS3DALG_LIGHT_HRTF
        };

    public:
        // Calculation functions
        static void Calculate3d(DWORD dwOperation, CHrtfSource *pSource);
    
        // HRTF filter coefficients
        static void GetHrtfFilterPair(CHrtfSource *pSource);

    protected:
        // Calculation functions
        static void CalcNormPos(CHrtfSource *pSource);
        static void CalcLeftRightGains(CHrtfSource *pSource);
        static void CalcFrontRearGains(CHrtfSource *pSource);
    };
}

//
// MixBin pan 3D source
//

namespace DirectSound
{
    class CPan3dSource
    {
    public:
        enum
        {
            DS3DALG = DS3DALG_PAN
        };

    public:
        // Calculation functions
        static void Calculate3d(DWORD dwOperation, CHrtfSource *pSource);
    
        // HRTF filter coefficients
        static void GetHrtfFilterPair(CHrtfSource *pSource);

    protected:
        // Calculation functions
        static void CalcPan(CHrtfSource *pSource);
    };
}

//
// 3D source
//

namespace DirectSound
{
    class CHrtfSource
    {
        friend class CFullHrtfSource;
        friend class CLightHrtfSource;
        friend class CPan3dSource;

    public:
        HRTFSOURCE                      m_3dData;               // 3D calculation data
        HRTFVOICE                       m_3dVoiceData;          // 3D voice data
                                                            
    protected:                                                  
        const CHrtfListener &           m_Listener;             // 3D listener
        REFDS3DSOURCEPARAMS             m_3dParams;             // 3D parameters
        static UINT                     m_nAlgorithm;           // Algorithm identifier

    private:
        static const HRTFSOURCE         m_Default3dData;        // Default 3D calculation data
        static const HRTFVOICE          m_Default3dVoiceData;   // Default 3D voice data
        static LPFNHRTFCALC             m_pfnCalculate;         // 3D calculation function
        static LPFNGETHRTFFILTERPAIR    m_pfnGetFilterPair;     // Filter pair lookup function

    public:
        CHrtfSource(const CHrtfListener &Listener, REFDS3DSOURCEPARAMS Params);

    public:
        // HRTF quality
        static void SetAlgorithm_FullHrtf(void);
        static void SetAlgorithm_LightHrtf(void);
        static void SetAlgorithm_Pan(void);
        static BOOL IsValidAlgorithm(void);
        static UINT GetAlgorithm(void);

        // 3D parameters
        void Calculate3d(DWORD dwOperation);
        void GetHrtfFilterPair(void);
    };

    __inline void CHrtfSource::SetAlgorithm_FullHrtf(void)
    {
        m_nAlgorithm = CFullHrtfSource::DS3DALG;
        m_pfnCalculate = CFullHrtfSource::Calculate3d;
        m_pfnGetFilterPair = CFullHrtfSource::GetHrtfFilterPair;
    }

    __inline void CHrtfSource::SetAlgorithm_LightHrtf(void)
    {
        m_nAlgorithm = CLightHrtfSource::DS3DALG;
        m_pfnCalculate = CLightHrtfSource::Calculate3d;
        m_pfnGetFilterPair = CLightHrtfSource::GetHrtfFilterPair;
    }

    __inline void CHrtfSource::SetAlgorithm_Pan(void)
    {
        m_nAlgorithm = CPan3dSource::DS3DALG;
        m_pfnCalculate = CPan3dSource::Calculate3d;
        m_pfnGetFilterPair = CPan3dSource::GetHrtfFilterPair;
    }

    __inline BOOL CHrtfSource::IsValidAlgorithm(void)
    {
        return (m_nAlgorithm >= DS3DALG_FIRST) && (m_nAlgorithm <= DS3DALG_LAST);
    }

    __inline UINT CHrtfSource::GetAlgorithm(void)
    {
        return m_nAlgorithm;
    }

    __inline void CHrtfSource::GetHrtfFilterPair(void)
    {
        ASSERT(IsValidAlgorithm());
        ASSERT(m_pfnGetFilterPair);
        m_pfnGetFilterPair(this);
    }
}

#endif // __cplusplus

#endif // __HRTF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\i3dl2.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       I3DL2.cpp
 *  Content:    I3DL2 reverb and filter calculations.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/30/01    dereks  Created based on Sensaura tables.
 *
 ****************************************************************************/

#include "dsoundi.h"

#define ALIGN_COUNT(a, b) \
    (((a) / (b)) * (b))

#define DWORD_ALIGN(a) \
    (((a) + 3) & ~3)

typedef struct							// Coefficients for a 1 pole IIR filter
{
	int	iA;
	int	iB;
} RVB_IIR_1P;

#define MB_SCALE		2000.0f
#define DS_LEVEL_SILENT	(-10000)		// Attenuation which produces silence
#define DS_GAIN_SILENT	0.00001f		// Linear gain below which is silent

static __inline float ds_alog(const float x)
{
	float y;
	float scale = 3.321928f;			// 1/log10(2)
	float one = 1;
	float dummy;
	float n;

	__asm {
	fld scale;
	fmul x;								// x/log10(2)
	frndint;							// assumes standard rounding mode - should we set it?
	fst n;								// n=int part of x/log10(2)
	fwait;								// wait for n
	fld1;								// 1.0
	fscale;								// generate 2^n
	fxch;								// move n to top of stack
	fstp dummy;							// get rid of it
										// stack now has 2^n
	fld scale;
	fmul x;								// x/log10(2) again
	fsub n;								// remove int part, so in range -1...+1 required by f2xm1
	f2xm1;								// 2^(x/log10(2)-n)-1
	fadd one;							// 2^(x/log10(2)-n) = 2^(x/log10(2)) * 2^(-n)
#ifdef	_MSC_VER
	fmulp st(1),st;						// 2^(x/log10(2))
#else
	fmulp;								// 2^(x/log10(2))
#endif
	fstp y;								// log10(y) = (x/log10(2)) * log10(2) = x
										// y = 10^x QED!
	fwait;								// synchronise
	}
	return y;
}

static inline float mBToLinear(long x) 
	{ return /*x <= DS_LEVEL_SILENT ? 0.f :*/ds_alog((float)x/MB_SCALE); }

static inline long LinearTomB(float x) 
	{ return x <= DS_GAIN_SILENT ? DS_LEVEL_SILENT : (long)FTOI((float)log10(x)*MB_SCALE); }


/****************************************************************************
 *
 *  CI3dl2Listener
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::CI3dl2Listener"

const float CI3dl2Listener::m_flScale23 = 8388608.f;   // 2^23
const float CI3dl2Listener::m_flScale16 = 65536.f;     // 2^16

const float CI3dl2Listener::m_aflReflectionData[RVB_HW_REFLECTIONS][5] =
{
	{ 0.57f, -0.40f, 0.1052f, 0.003651f, 0.2469f },
	{ 0.52f,  0.40f, 0.0673f, 0.003515f, 0.2209f },
	{ 0.54f, -0.40f, 0.1737f, 0.003673f, 0.2311f },
	{ 0.60f, -0.40f, 0.2404f, 0.003946f, 0.2608f }		
};

const float CI3dl2Listener::m_aflShortReverbInputFactor[RVB_HW_SHORTREVERBS][2] =
{
	{ 1.0f, -1.0f },
	{ -1.0f, 1.0f },
	{ 1.0f,  1.0f },
	{ -1.0f,  -1.0f },
};

const float CI3dl2Listener::m_aflShortReverbFeedbackDelay[RVB_HW_SHORTREVERBS] =
{
	0.058005f, 0.070295f, 0.085238f, 0.103288f
};

const float CI3dl2Listener::m_aflLongReverbInputDelay[RVB_HW_LONGREVERBS][4] = 
{
	{ 0.040023f, 0.288186f, 0.603764f, 0.851905f },
	{ 0.021224f, 0.375420f, 0.623583f, 0.759229f },
};

const DWORD CI3dl2Listener::m_dwSamplesPerSec = 24000;

CI3dl2Listener::CI3dl2Listener
(
    REFDSI3DL2LISTENER      ds3dl
)
:   m_I3dl2Params(ds3dl)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetSize
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetSize"

void
CI3dl2Listener::SetSize
(
    FLOAT                   fSize
)
{
	float	fSizeFactor;
	int		i;
	int		j;
	float	f;
	DWORD	dw;

	if(fSize < RVB_MAXSMALLSIZE)		// Small room?
		fSizeFactor = (fSize-RVB_BASESIZE)/(RVB_MAXSMALLSIZE-RVB_BASESIZE);
	else
		fSizeFactor = 1.0f;

	for(i = 0; i < 4; i++)
		for(j = 0; j < 2; j++)
		{
			f = m_aflLongReverbInputDelay[j][i]*fSizeFactor*m_dwSamplesPerSec;
			dw = ftoi(f);
			ALIGN_COUNT(dw, 4);
				
			DPF_BLAB("Reverb input delay (D4%lx):%d", 2*i+j, dw);
			m_I3dl2Data.dwLongReverbInputDelay[2*i+j]=dw;
		}

	m_I3dl2Data.dwLongReverbFeedbackDelay = ftoi(fSizeFactor*m_dwSamplesPerSec);
	ALIGN_COUNT(m_I3dl2Data.dwLongReverbFeedbackDelay, 4);

	DPF_BLAB("Long reverb feedback delays (D50-D51):%d", m_I3dl2Data.dwLongReverbFeedbackDelay);
}


/****************************************************************************
 *
 *  SetInputFilter
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetInputFilter"

void 
CI3dl2Listener::SetInputFilter
(
    LONG                    lGainHF, 
    FLOAT                   fHFReference
)
{
	float	fA, fB;

    //
    // always pass 48k to this function even if dsp reverb is running at 24k
    //

	Get1PoleLoPass(0, lGainHF, fHFReference, (float)max(m_dwSamplesPerSec, MCPX_BASEFREQ), &fA, &fB);
	
	m_I3dl2Data.IIR[InputIIR].dwCoefficients[0]=ftoi(fA*m_flScale23);
	m_I3dl2Data.IIR[InputIIR].dwCoefficients[1]=ftoi(fB*m_flScale23);

	DPF_BLAB("Input IIR(F00):dwCoefficients[0]:%d  dwCoefficients[1]:%d", m_I3dl2Data.IIR[InputIIR].dwCoefficients[0], m_I3dl2Data.IIR[InputIIR].dwCoefficients[1]);
}


/****************************************************************************
 *
 *  SetReflectionsGain
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetReflectionsGain"

void 
CI3dl2Listener::SetReflectionsGain
(
    FLOAT                   fGain
)
{
	for(int i = 0; i < RVB_HW_REFLECTIONS; i++)		// G60 to G63
	{
		m_I3dl2Data.dwReflectionsOutputGain[i] = ftoi(m_aflReflectionData[i][0]*fGain*m_flScale16);
		DPF_BLAB("Reflection[%d] output gain(G6%lx):%d", i, i, m_I3dl2Data.dwReflectionsOutputGain[i]);
	}
}


/****************************************************************************
 *
 *  SetReflectionsDelay
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetReflectionsDelay"

void 
CI3dl2Listener::SetReflectionsDelay
(
    FLOAT                   fDelay
)
{
	m_I3dl2Data.dwReflectionsInputDelay[0] = ftoi(fDelay*m_dwSamplesPerSec);
	ALIGN_COUNT(m_I3dl2Data.dwReflectionsInputDelay[0], 4);

	DPF_BLAB("Reflections delay(D00):%d", m_I3dl2Data.dwReflectionsInputDelay[0]);
}


/****************************************************************************
 *
 *  SetReverbGain
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetReverbGain"

void 
CI3dl2Listener::SetReverbGain
(
    FLOAT                   fGain
)
{
	DPF_BLAB("Reverb output gain(G70-75):%d", ftoi(fGain*m_flScale16));
	m_I3dl2Data.dwShortReverbOutputGain=ftoi(fGain*m_flScale16);
	m_I3dl2Data.dwLongReverbOutputGain=ftoi(fGain*m_flScale16);
}


/****************************************************************************
 *
 *  SetReverbDelay
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetReverbDelay"

void 
CI3dl2Listener::SetReverbDelay
(
    FLOAT                   fDelay
)
{
	float f;

	m_I3dl2Data.dwShortReverbInputDelay = ftoi(fDelay*m_dwSamplesPerSec);
	ALIGN_COUNT(m_I3dl2Data.dwShortReverbInputDelay, 4);

	for(int i = 0; i < 4; i++)				// D01 to D04
	{
		f = m_aflReflectionData[i][2]*(float)m_I3dl2Data.dwShortReverbInputDelay ;
		m_I3dl2Data.dwReflectionsInputDelay[1+i] = ftoi(f);
		DPF_BLAB("Reflection[%d] input delay(D0%lx):%d", i, i+1, m_I3dl2Data.dwReflectionsInputDelay[1+i]);
		
	}
	for(i = 0; i < 4; i++)					// D05 to D08
	{
		f = (m_aflReflectionData[i][3]+m_aflReflectionData[i][4]*fDelay)*m_dwSamplesPerSec;
		m_I3dl2Data.dwReflectionsFeedbackDelay[i] = ftoi(f);
		DPF_BLAB("Reflection[%d] feedback delay(D0%lx):%d", i, i+5, m_I3dl2Data.dwReflectionsFeedbackDelay[i]);
	}

	DPF_BLAB("Reverb delay:%d", m_I3dl2Data.dwShortReverbInputDelay);
}


/****************************************************************************
 *
 *  SetDecayTimes
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetDecayTimes"

void 
CI3dl2Listener::SetDecayTimes
(
    FLOAT                   fDecayTime, 
    FLOAT                   fDecayHFRatio, 
    FLOAT                   fHFReference
)
{
	int		i;

	DSFX_I3DL2REVERB_IIR ReverbIir; 
	DSFX_I3DL2REVERB_IIR LongReverbFeedbackIir;


	SetDecayFilter(&ReverbIir, m_I3dl2Data.dwLongReverbFeedbackDelay/4, fDecayTime, fDecayHFRatio, fHFReference);
	DPF_BLAB("Reverb IIR(F40-F42):dwCoefficients[0]:%d  dwCoefficients[1]:%d", ReverbIir.dwCoefficients[0], ReverbIir.dwCoefficients[1]);
	for(i=0;i<3;i++)
	{
		m_I3dl2Data.IIR[MainDelayLineLongReverbIIR+i].dwCoefficients[0]=ReverbIir.dwCoefficients[0];
		m_I3dl2Data.IIR[MainDelayLineLongReverbIIR+i].dwCoefficients[1]=ReverbIir.dwCoefficients[1];
	}
	SetDecayFilter(&LongReverbFeedbackIir, m_I3dl2Data.dwLongReverbFeedbackDelay,
					   fDecayTime, fDecayHFRatio, fHFReference);
	DPF_BLAB("Long reverb feedback IIR(F50-F51):dwCoefficients[0]:%d  dwCoefficients[1]:%d", 
		   LongReverbFeedbackIir.dwCoefficients[0], LongReverbFeedbackIir.dwCoefficients[1]);
	for(i=0;i<2;i++)
	{
		m_I3dl2Data.IIR[LongReverbIIR+i].dwCoefficients[0]=LongReverbFeedbackIir.dwCoefficients[0];
		m_I3dl2Data.IIR[LongReverbIIR+i].dwCoefficients[1]=LongReverbFeedbackIir.dwCoefficients[1];
	}

	for(i =0; i < RVB_HW_SHORTREVERBS; i++)
	{
		SetDecayFilter(&m_I3dl2Data.IIR[ShortReverbIIR+i], m_I3dl2Data.DelayLines[i+ShortReverbDelayLineID].dwLength, fDecayTime, fDecayHFRatio, fHFReference);
		DPF_BLAB("Short reverb[%d] feedback IIR(F3%lx):dwCoefficients[0]:%d  dwCoefficients[1]:%d", i, i,
			   m_I3dl2Data.IIR[ShortReverbIIR+i].dwCoefficients[0], m_I3dl2Data.IIR[ShortReverbIIR+i].dwCoefficients[1]);
		
	}
}


/****************************************************************************
 *
 *  SetDiffusion
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetDiffusion"

void 
CI3dl2Listener::SetDiffusion
(
    FLOAT                   fDiffusion
)
{
	for(int i = 0; i < RVB_HW_SHORTREVERBS; i++)
	{
		for(int j = 0; j < 2; j++)
		{
			m_I3dl2Data.dwShortReverbInputGain[i*2+j] = ftoi(m_aflShortReverbInputFactor[i][j]*fDiffusion*m_flScale23);

			DPF_BLAB("Short reverb[%d] input gain[%d](G1%lx):%d",
			i, j, i*2+j, m_I3dl2Data.dwShortReverbInputGain[i*2+j]);

		}
	}


	m_I3dl2Data.dwLongReverbCrossfeedGain=ftoi(m_flScale23*fDiffusion/(RVB_HW_LONGREVERBS+RVB_HW_SHORTREVERBS-1));
	m_I3dl2Data.dwLongReverbInputGain=ftoi(m_flScale23*(1.0f-fDiffusion));

	DPF_BLAB("Long reverb crossfeed gains(G50-51):%d", m_I3dl2Data.dwLongReverbCrossfeedGain);
	DPF_BLAB("Long reverb input gains(G52-53):%d", m_I3dl2Data.dwLongReverbInputGain);
}


/****************************************************************************
 *
 *  SetDecayFilter
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      TYPE [in/out]: insert argument description here.
 *
 *  Returns:  
 *      RETURNTYPE: insert return description here.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::SetDecayFilter"

void
CI3dl2Listener::SetDecayFilter
(
    DSFX_I3DL2REVERB_IIR *  pIir,
    DWORD                   dwDelay,
    FLOAT                   fDecayTime,
    FLOAT                   fDecayHFRatio,
    FLOAT                   fHFReference
)
{
	float	f;
	long	lGain;
	long	lGainHF;
	float	fA, fB;

	ASSERT(pIir != NULL);

	f = (float)dwDelay/(float)m_dwSamplesPerSec;
	f = -6000.0f*(f/fDecayTime);
	lGain = (long)ftoi(f);
	if(fDecayHFRatio < 1.0f)
		f /= fDecayHFRatio;
	lGainHF = (long)ftoi(f);
	lGainHF -= lGain;
	Get1PoleLoPass(lGain, lGainHF, fHFReference, (float)m_dwSamplesPerSec, &fA, &fB);

	pIir->dwCoefficients[0] = ftoi(fA*m_flScale23);
	pIir->dwCoefficients[1] = ftoi(fB*m_flScale23);
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Sets up constant reverb parameters.
 *
 *  Arguments:
 *      LPDSFX_I3dl2REVERB_PARAMS [out]: reverb parameter block.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::Initialize"

void
CI3dl2Listener::Initialize
(
    void
)
{
	int		i;

#ifdef I3DL2_DSP_INIT

    //
    // The DSP program has already initialized part of the structure.  We need
    // to fill in the rest.
    //
    // The DSP specifies the delay line lengths in bytes, but the C code 
    // assumes they're in samples.
    //

    for(i = 0; i < NUMELMS(m_I3dl2Data.DelayLines); i++)
    {
        m_I3dl2Data.DelayLines[i].dwLength--;
        m_I3dl2Data.DelayLines[i].dwLength /= sizeof(DWORD);
        m_I3dl2Data.DelayLines[i].dwLength++;
    }

#else // I3DL2_DSP_INIT

	float	f;
	DWORD	dw;

	for(i = 0; i < 4; i++)
	{
		f = (m_aflReflectionData[i][3]+m_aflReflectionData[i][4]*0.1f)*m_dwSamplesPerSec;
		dw = ftoi(f);
		ALIGN_COUNT(dw , 4)
		m_I3dl2Data.DelayLines[i+ReflectionDelayLineID].dwLength=dw;
	}
	
	for(i = 0; i < RVB_HW_SHORTREVERBS; i++)		
	{									// Calculate reverb delay line parameters
		f = m_aflShortReverbFeedbackDelay[i]*m_dwSamplesPerSec;
		m_I3dl2Data.DelayLines[i+ShortReverbDelayLineID].dwLength = ftoi(f);
		ALIGN_COUNT(m_I3dl2Data.DelayLines[i+ShortReverbDelayLineID].dwLength, 4)
	}
										// Allocate memory for reverb source delay buffer
	for(i=0;i<4;i++)
	{
		m_I3dl2Data.DelayLines[MainDelayLineID+i].dwLength=m_dwSamplesPerSec/4;
	}
	for(i=0;i<2;i++)
	{
		m_I3dl2Data.DelayLines[LongReverbDelayLineID+i].dwLength=m_dwSamplesPerSec;
	}

#endif // I3DL2_DSP_INIT

    //
    // Set the channel count
    //

    m_I3dl2Data.dwChannelCount = 4;

    //
    // Initialize the IIR delay values
    //

    for(i = 0; i < NUMELMS(m_I3dl2Data.IIR); i++)
    {
        m_I3dl2Data.IIR[i].dwDelay = 0;
    }
}


/****************************************************************************
 *
 *  CalculateI3dl2
 *
 *  Description:
 *      Sets all I3DL2 listener properties.
 *
 *  Arguments:
 *      LPDSFX_I3dl2REVERB_PARAMS [out]: reverb parameter block.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::CalculateI3dl2"

void
CI3dl2Listener::CalculateI3dl2
(
    void
)
{
	float fDiffusion;
	float fDensity;
	float fSize;

	fDiffusion = m_I3dl2Params.flDiffusion/100.0f;
	fDensity = m_I3dl2Params.flDensity/100.0f;

	fSize = (m_I3dl2Params.flDecayTime-1.0f)*5.0f;
	fSize *= 2.0f-fDensity;

	if (fSize <1.0f)
		fSize = 1.0f;
	if (fSize > 60.0f)
		fSize = 60.0f;

	int i,j;

	Initialize();
    SetInputFilter(m_I3dl2Params.lRoomHF, m_I3dl2Params.flHFReference);
	SetReflectionsGain(mBToLinear(m_I3dl2Params.lRoom + m_I3dl2Params.lReflections));
	SetReflectionsDelay(m_I3dl2Params.flReflectionsDelay);
	SetReverbGain(mBToLinear(m_I3dl2Params.lRoom+ m_I3dl2Params.lReverb));
	SetReverbDelay(m_I3dl2Params.flReverbDelay);
	SetSize(fSize);
	SetDecayTimes(m_I3dl2Params.flDecayTime, m_I3dl2Params.flDecayHFRatio, m_I3dl2Params.flHFReference);
	SetDiffusion(fDiffusion);




	// Ensure that the lengths of the delay buffers are delays are multiples of 4
	for(i=0;i<NUMELMS(m_I3dl2Data.DelayLines);i++)
	{
		m_I3dl2Data.DelayLines[i].dwLength=(m_I3dl2Data.DelayLines[i].dwLength+1) & (~3);
	}
	
	// Ensure that the positions of the reflection input delay taps are delays are multiples of 4
	for(i=0;i<5;i++)
	{
		m_I3dl2Data.dwReflectionsInputDelay[i]=(m_I3dl2Data.dwReflectionsInputDelay[i]+1) & ~3;
	}
	// Ensure that the positions of the Long Reverb Input Delay taps are delays are multiples of 4
	for(i=0;i<8;i++)
	{
		m_I3dl2Data.dwLongReverbInputDelay[i]=(m_I3dl2Data.dwLongReverbInputDelay[i]+1) & ~3;
	}
	m_I3dl2Data.dwShortReverbInputDelay=(m_I3dl2Data.dwShortReverbInputDelay+1) & ~3;

	// Ensure that the positions of the reflection taps are delays are multiples of 4
	for(i=0;i<4;i++)
	{
		m_I3dl2Data.dwReflectionsFeedbackDelay[i]=(m_I3dl2Data.dwReflectionsFeedbackDelay[i]+1) & ~3;
	}
	m_I3dl2Data.dwLongReverbFeedbackDelay=(m_I3dl2Data.dwLongReverbFeedbackDelay+1) & ~3;


	// There isn't enough memory on the EVM board to implement all the
	// delay buffers. Therefore calculate the length of the long reverb
	// buffers based on the length of the other buffers. (This
	// actually makes the long reverb buffers about 0.6 seconds rather than
	// 1.0 seconds.
	/*DWORD SumMemory=0;								// Add up the lengths of all
	for(i=0;i<NUMELMS(m_I3dl2Data.DelayLines)-2;i++)			// the buffers excluding the
	{												// two long reverb buffers
		SumMemory+=m_I3dl2Data.DelayLines[i].dwLength;
	}
													// Calculate the length of
													// the long reverb buffers
	DWORD MaxLongReverbBufferLength=(128*1024-SumMemory)/2;
													// Clip the length of the
													// reverb buffer
	for(i=0;i<2;i++)
	{
		if(m_I3dl2Data.DelayLines[LongReverbDelayLineID+i].dwLength>MaxLongReverbBufferLength)
		{
			m_I3dl2Data.DelayLines[LongReverbDelayLineID+i].dwLength=MaxLongReverbBufferLength;
		}
	}*/



	
	
	
	
	///////////////////////////////////////////////////////////
	// Write a block representing the host memory delay lines
	///////////////////////////////////////////////////////////
	//int Memory=DSP_StartOfMemory;
	for(i=0;i<NUMELMS(m_I3dl2Data.DelayLines);i++)
	{
		//fprintf( fp , "%d %d",Memory,DelayLines[i].dwLength-1);
		m_I3dl2Data.DelayLines[i].dwLength--;
        //Memory+=m_I3dl2Data.DelayLines[i].dwLength;
	}
	//fprintf( fp , "" );


	///////////////////////////////////////////////////////////
	// Reflections input delay
	///////////////////////////////////////////////////////////
	//fprintf( fp , "%d" , dwReflectionsInputDelay[0]);
	for(i=1;i<5;i++)
	{
		//fprintf( fp , " %d" , dwReflectionsInputDelay[0]+dwReflectionsInputDelay[i]);
        m_I3dl2Data.dwReflectionsInputDelay[i] += m_I3dl2Data.dwReflectionsInputDelay[0];
	}
	//fprintf( fp , "" );

	
	///////////////////////////////////////////////////////////
	// Short reverb input delay
	///////////////////////////////////////////////////////////
	//		Note that the short reverb is additative reflections input delay
	//fprintf( fp , "%d" , dwShortReverbInputDelay+dwReflectionsInputDelay[0]);	
    m_I3dl2Data.dwShortReverbInputDelay += m_I3dl2Data.dwReflectionsInputDelay[0];

	
	///////////////////////////////////////////////////////////
	// Long reverb input delays
	///////////////////////////////////////////////////////////
	// On entry the dwLongReverbInputDelay[] values are measured with
	// respect to the start of the main delay buffer.
	// The long reverb input delays should be relative to the start of 
	// their respective delay buffers.  
	DWORD EndOfLastReverbBuffer=0;
	DWORD EndOfThisReverbBuffer=0;
	for(i=0;i<4;i++)
	{
		EndOfThisReverbBuffer=m_I3dl2Data.dwLongReverbInputDelay[2*i+1];

		int LongestDelayOnThisBuffer=max(m_I3dl2Data.dwLongReverbInputDelay[2*i],m_I3dl2Data.dwLongReverbInputDelay[2*i+1]);

		if(LongestDelayOnThisBuffer-EndOfLastReverbBuffer>m_I3dl2Data.DelayLines[MainDelayLineID+i].dwLength)
		{
			// The second reverb needs to be clipped
			// Scale the reverb delay times so that the long 
			// reverb fits within the buffer
			float fTimeScale=(float)m_I3dl2Data.DelayLines[MainDelayLineID+i].dwLength/(LongestDelayOnThisBuffer-EndOfLastReverbBuffer);
			
			DPF_BLAB("Before clipping  %i - %i %i",i*2,m_I3dl2Data.dwLongReverbInputDelay[2*i],m_I3dl2Data.dwLongReverbInputDelay[2*i+1]);
			m_I3dl2Data.dwLongReverbInputDelay[2*i]=ftoi((m_I3dl2Data.dwLongReverbInputDelay[2*i]-EndOfLastReverbBuffer)*fTimeScale);
			m_I3dl2Data.dwLongReverbInputDelay[2*i+1]=ftoi((m_I3dl2Data.dwLongReverbInputDelay[2*i+1]-EndOfLastReverbBuffer)*fTimeScale);

			// Qudword align the delays
			for(j=0;j<2;j++)
			{
				m_I3dl2Data.dwLongReverbInputDelay[2*i+j]=(m_I3dl2Data.dwLongReverbInputDelay[2*i+j]+1) & ~3;
			}

			DPF_BLAB("Clipped long reverb input delay %i - %i %i",i*2,m_I3dl2Data.dwLongReverbInputDelay[2*i],m_I3dl2Data.dwLongReverbInputDelay[2*i+1]);
		}
		else
		{
			m_I3dl2Data.dwLongReverbInputDelay[2*i]-=EndOfLastReverbBuffer;
			m_I3dl2Data.dwLongReverbInputDelay[2*i+1]-=EndOfLastReverbBuffer;
		}

		EndOfLastReverbBuffer=EndOfThisReverbBuffer;
	}

	for(i=0;i<8;i++)
	{
		//fprintf( fp , "%d" , dwLongReverbInputDelay[i] );
		//if(i!=7) //fprintf( fp , " " );
	}
	//fprintf( fp , "" );


	///////////////////////////////////////////////////////////
	// Reflections feedback delays
	///////////////////////////////////////////////////////////
	for(i=0;i<4;i++)
	{
														// Limit the positions of the
														// reflections delay taps
		if(m_I3dl2Data.dwReflectionsFeedbackDelay[i]>m_I3dl2Data.DelayLines[ReflectionDelayLineID+i].dwLength)
		{
			m_I3dl2Data.dwReflectionsFeedbackDelay[i]=m_I3dl2Data.DelayLines[ReflectionDelayLineID+i].dwLength;
			DPF_BLAB("Clipped reflections feedback delay %i",i);
		}

		//fprintf( fp , "%d" , dwReflectionsFeedbackDelay[i]);
		//if(i!=3) //fprintf( fp , " " );
	}
	//fprintf( fp , "" );



	///////////////////////////////////////////////////////////
	// Long Reverb feedback delay
	///////////////////////////////////////////////////////////
														// Limit the position of the
														// long reverb feedback tap
	if(m_I3dl2Data.dwLongReverbFeedbackDelay>m_I3dl2Data.DelayLines[LongReverbDelayLineID].dwLength)	
	{
		m_I3dl2Data.dwLongReverbFeedbackDelay=m_I3dl2Data.DelayLines[LongReverbDelayLineID].dwLength;
	}
	//fprintf( fp , "%d" , dwLongReverbFeedbackDelay);

	
	///////////////////////////////////////////////////////////
	// Short reverb input gain
	///////////////////////////////////////////////////////////
	for(i=0;i<8;i++)
	{
		if((LONG)m_I3dl2Data.dwShortReverbInputGain[i] > 8388607)
        {
            m_I3dl2Data.dwShortReverbInputGain[i] = 8388607;
        }
        else if((LONG)m_I3dl2Data.dwShortReverbInputGain[i] < -8388607)
        {
            m_I3dl2Data.dwShortReverbInputGain[i] = -8388607;
        }
        /*if(fabs((LONG)m_I3dl2Data.dwShortReverbInputGain[i])>=8388608)
		{
			m_I3dl2Data.dwShortReverbInputGain[i]=ftoi((8388608-1)*(((LONG)m_I3dl2Data.dwShortReverbInputGain[i])>0?1:-1));
		}*/
		//fprintf( fp , "%d" , dwShortReverbInputGain[i]);
		//if(i!=7) //fprintf( fp , " " );
	}
	//fprintf( fp , "" );

	
	///////////////////////////////////////////////////////////
	// Long reverb input gain
	///////////////////////////////////////////////////////////
	//fprintf( fp , "%d" , dwLongReverbInputGain);


	///////////////////////////////////////////////////////////
	// Long Reverb Crossfeed gain
	///////////////////////////////////////////////////////////
	//fprintf( fp , "%d" , dwLongReverbCrossfeedGain);

	
	///////////////////////////////////////////////////////////
	// Reflections output gain
	///////////////////////////////////////////////////////////
	for(i=0;i<4;i++)
	{
		//fprintf( fp , "%d" , ReflectionsOutputGain[i]);
		//if(i!=3) //fprintf( fp , " " );
	}
	//fprintf( fp , "" );


	///////////////////////////////////////////////////////////
	// Short reverb output gain
	///////////////////////////////////////////////////////////
	//fprintf( fp , "%d" , ShortReverbOutputGain);


	///////////////////////////////////////////////////////////
	// Long reverb output gain
	///////////////////////////////////////////////////////////
	//fprintf( fp , "%d" , LongReverbOutputGain);


	///////////////////////////////////////////////////////////
	// Number output channels
	///////////////////////////////////////////////////////////
	//fprintf( fp , "%d" , dwChannelCount);

	///////////////////////////////////////////////////////////
	// IIR outputs
	///////////////////////////////////////////////////////////
	for(i=0;i<10;i++)
	{
		//fprintf( fp , "%d %d" , IIR[i].dwCoefficients[0] , IIR[i].dwCoefficients[1] );
	}
	//fprintf( fp , "" );

	//fclose(fp);}


    //
    // Convert DWORDs to BYTEs
    //

    for(i = 0; i < NUMELMS(m_I3dl2Data.dwReflectionsInputDelay); i++)
    {
        m_I3dl2Data.dwReflectionsInputDelay[i] *= sizeof(DWORD);
    }

    m_I3dl2Data.dwShortReverbInputDelay *= sizeof(DWORD);

    for(i = 0; i < NUMELMS(m_I3dl2Data.dwLongReverbInputDelay); i++)
    {
        m_I3dl2Data.dwLongReverbInputDelay[i] *= sizeof(DWORD);
    }

    for(i = 0; i < NUMELMS(m_I3dl2Data.dwReflectionsFeedbackDelay); i++)
    {
        m_I3dl2Data.dwReflectionsFeedbackDelay[i] *= sizeof(DWORD);
    }

    m_I3dl2Data.dwLongReverbFeedbackDelay *= sizeof(DWORD);
}


/****************************************************************************
 *
 *  Get1PoleLoPass
 *
 *  Description:
 *      Calculates low-pass filter values
 *
 *  Arguments:
 *      long [in]: gain.
 *      long [in]: high-frequency gain.
 *      float [in]: high-frequency reference.
 *      float [in]: sampling rate.
 *      float * [out]: coefficient A.
 *      float * [out]: coefficient B.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::Get1PoleLoPass"

void 
CI3dl2Listener::Get1PoleLoPass
(
    long                    lGain, 
    long                    lGainHF, 
    float                   fHFReference, 
    float                   fSamplesPerSec, 
    float *                 pfA, 
    float *                 pfB
)
{
	static const float      pi          = 3.14159265f;
    double	                fW, fK, fG;
	double	                fCosW, fA;

    DPF_ENTER();

	ASSERT(pfA != NULL);
	ASSERT(pfB != NULL);
	ASSERT(lGainHF <= 0);

	fW = 2.f*pi*fHFReference/fSamplesPerSec;
	ASSERT(fW <= 2*pi);

	if(lGain <= DSBVOLUME_MIN)		// Output will be silent
	{
	    *pfA = 0.f;
	    *pfB = 0.f;
	}
	else if(lGain == 0 && lGainHF == 0)	// Audio is not changed by the filter
	{
	
	    *pfA = 0.f;
		*pfB = 1.f;
	}
	else if(lGainHF == 0)				// The filter is a pure gain
	{
	
	    *pfA = 0.f;
		*pfB = mBToLinear(lGain);
	}
	else
	{
	    // 
        // Filter has the transfer function:
        // 
		//     H(z) = k*	1-a
		// 		       ------
		// 		       1-az(-1)
        // 
	    // If Fh is the reference frequency, x is the attenuation in dB at Fh 
        // and y is the attenuation ratio at 0Hz then:
        // 
	    // k = 10^(x*y/20)
        // 
	    // a = 1 - g*cos(W) - sqrt(2g(1 - cos(W))-g*g*(1-cos^2(W)))
		//     -----------------------------------------------------
		// 					    1 - g
        // 
	    // g = 10^(x(1-y)/10)
        // 

		fK = mBToLinear(lGain);
		fG = mBToLinear(2 * lGainHF);
		fCosW = cos(fW);

		fA = (1.f - fG * fCosW - sqrt(2.f * fG * (1.f - fCosW) - fG * fG * (1.f - fCosW * fCosW))) / (1.f - fG);

		*pfA = (float)fA;
		*pfB = (float)(fK * (1.f - fA));
	}

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Get1PoleLoPass
 *
 *  Description:
 *      Calculates low-pass filter values
 *
 *  Arguments:
 *      long [in]: gain.
 *      long [in]: high-frequency gain.
 *      float [in]: high-frequency reference.
 *      float [in]: sampling rate.
 *      int * [out]: coefficient A.
 *      int * [out]: coefficient B.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Listener::Get1PoleLoPass"

void 
CI3dl2Listener::Get1PoleLoPass
(
    long                    lGain, 
    long                    lGainHF, 
    float                   fHFReference, 
    float                   fSamplesPerSec, 
    int *                   piA,
    int *                   piB
)
{
    FLOAT                   flA, flB;

    DPF_ENTER();

    Get1PoleLoPass(lGain, lGainHF, fHFReference, fSamplesPerSec, &flA, &flB);

    *piA = ftoi(flA * m_flScale23);
    *piB = ftoi(flB * m_flScale23);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CI3dl2Source
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Source::CI3dl2Source"

const I3DL2SOURCE CI3dl2Source::m_DefaultI3dl2Data =
{
    0,                      // dwChangeMask
    0,                      // lDirect;
    0,                      // lSource;
    0,                      // nDirectIir;
    0                       // nReverbIir;
};

CI3dl2Source::CI3dl2Source
(
    const CI3dl2Listener &  Listener,
    REFDSI3DL2BUFFER        ds3db
)
:   m_Listener(Listener),
    m_I3dl2Params(ds3db)
{
    DPF_ENTER();

    m_I3dl2Data = m_DefaultI3dl2Data;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CalculateI3dl2
 *
 *  Description:
 *      Sets all I3DL2 source parameters.
 *
 *  Arguments:
 *      LPCDSI3DL2LISTENER [in]: listener properties.
 *      LPCDSI3DL2BUFFER [in]: source properties.
 *      FLOAT [in]: distance between source and m_Listener.m_I3dl2Params.
 *      LPDSFX_I3dl2SOURCE_PARAMS [out]: effect data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Source::CalculateI3dl2"

void
CI3dl2Source::CalculateI3dl2
(
    FLOAT                   flDistance
)
{
    FLOAT                   flDirectObstructionLevel;
    FLOAT                   flDirectOcclusionLevel;
    FLOAT                   flDirectHFObstructionLevel;
    FLOAT                   flDirectHFOcclusionLevel;
    FLOAT                   flReverbFeed;
    LONG                    lDirect;
    LONG                    lDirectHF;
    LONG                    lSource;
    LONG                    lSourceHF;
    INT                     nDirectIir;
    INT                     nReverbIir;

    DPF_ENTER();

    ASSERT(flDistance >= 0.0f);

    m_I3dl2Data.dwChangeMask = 0;

    flDistance *= m_Listener.m_I3dl2Params.flRoomRolloffFactor;
    flDistance *= m_I3dl2Params.flRoomRolloffFactor;

    //
    // Direct path level (may go above 0 volume)
    //

    flDirectObstructionLevel = (FLOAT)m_I3dl2Params.Obstruction.lHFLevel * m_I3dl2Params.Obstruction.flLFRatio;
    flDirectOcclusionLevel = (FLOAT)m_I3dl2Params.Occlusion.lHFLevel * m_I3dl2Params.Occlusion.flLFRatio;
    
    lDirect = m_I3dl2Params.lDirect + ftoi(flDirectObstructionLevel + flDirectOcclusionLevel);

    if(lDirect != m_I3dl2Data.lDirect)
    {
        m_I3dl2Data.lDirect = lDirect;
        m_I3dl2Data.dwChangeMask |= MCPX_I3DL2APPLY_DIRECT;
    }

    //
    // Direct path HF
    //

    flDirectHFObstructionLevel = (FLOAT)m_I3dl2Params.Obstruction.lHFLevel * (1.f - m_I3dl2Params.Obstruction.flLFRatio);
    flDirectHFOcclusionLevel = (FLOAT)m_I3dl2Params.Occlusion.lHFLevel * (1.f - m_I3dl2Params.Occlusion.flLFRatio);

    lDirectHF = m_I3dl2Params.lDirectHF + ftoi(flDirectHFObstructionLevel + flDirectHFOcclusionLevel);

    CHECKRANGE(lDirectHF, DSBVOLUME_MIN, DSBVOLUME_MAX);

    //
    // Reverb feed level (may go above 0 volume)
    //

    flReverbFeed = flDirectOcclusionLevel;

    if(flDistance > 1.0f)
    {
        flReverbFeed += LinearTomB(flDistance);
    }

    lSource = m_I3dl2Params.lRoom + ftoi(flReverbFeed);

    if(lSource != m_I3dl2Data.lSource)
    {
        m_I3dl2Data.lSource = lSource;
        m_I3dl2Data.dwChangeMask |= MCPX_I3DL2APPLY_SOURCE;
    }

    //
    // Reverb feed HF
    //

    lSourceHF = m_I3dl2Params.lRoom + ftoi(flDirectHFOcclusionLevel);

    CHECKRANGE(lSourceHF, DSBVOLUME_MIN, DSBVOLUME_MAX);

    //
    // Low-pass filters
    //

    nDirectIir = Get1PoleLoPass(0, lDirectHF, m_Listener.m_I3dl2Params.flHFReference, MCPX_BASEFREQ);

    if(nDirectIir != m_I3dl2Data.nDirectIir)
    {
        m_I3dl2Data.nDirectIir = nDirectIir;
        m_I3dl2Data.dwChangeMask |= MCPX_I3DL2APPLY_DIRECTIIR;
    }

    nReverbIir = Get1PoleLoPass(0, lSourceHF, m_Listener.m_I3dl2Params.flHFReference, MCPX_BASEFREQ);

    if(nReverbIir != m_I3dl2Data.nReverbIir)
    {
        m_I3dl2Data.nReverbIir = nReverbIir;
        m_I3dl2Data.dwChangeMask |= MCPX_I3DL2APPLY_REVERBIIR;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Get1PoleLoPass
 *
 *  Description:
 *      Calculates low-pass filter values
 *
 *  Arguments:
 *      long [in]: gain.
 *      long [in]: high-frequency gain.
 *      float [in]: high-frequency reference.
 *      float [in]: sampling rate.
 *
 *  Returns:  
 *      int: coefficient A.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CI3dl2Source::Get1PoleLoPass"

int
CI3dl2Source::Get1PoleLoPass
(
    long                    lGain, 
    long                    lGainHF, 
    float                   fHFReference, 
    float                   fSamplesPerSec
)
{
	static const float      pi              = 3.14159265f;
    double                  fG, fW, fCosW;
    float                   fA;
    int                     nA;

    ASSERT(lGainHF <= 0);

    if(lGain <= DSBVOLUME_MIN)
    {
        //
        // Output will be silent.
        //

        nA = 0;
    }
    else if(lGain == 0 && lGainHF == 0)
    {
        //
        // Audio is not changed by the filter.
        //
        
        nA = 0;
    }
    else if(lGainHF == 0)
    {
        //
        // The filter is a pure gain.
        //
        
        nA = 0;
    }
    else
    {
        //
        // If Fh is the reference frequency, x is the attenuation in dB at Fh 
        // and y is the attenuation ratio at 0Hz then:
        //
        // g = 10^(x(1-y)/10)
        //
        // a = 1 - g*cos(W) - sqrt(2g(1 - cos(W))-g*g*(1-cos^2(W)))
        //     -----------------------------------------------------
        //                            1 - g
        //
    
        fW = 2.f * pi * fHFReference / fSamplesPerSec;
        ASSERT(fW <= 2 * pi);

        fCosW = cos(fW);

        fG = mBToLinear(2 * lGainHF);

        fA = (float)((1.f - fG * fCosW - sqrt(2.f * fG * (1.f - fCosW) - fG * fG * (1.f - fCosW * fCosW))) / (1.f - fG));

        if(fA >= 1.f)
        {
            nA = 65535;
        }
        else
        {
            nA = ftoi(fA * 65536.f);
        }
    }

    DPF_LEAVE(nA);

    return nA;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\i3dl2.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       i3dl2.h
 *  Content:    I3dl2 reverb and filter calculations.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/30/01    dereks  Created based on Sensaura tables.
 *
 ****************************************************************************/

#ifndef __I3DL2_H__
#define __I3DL2_H__

#define I3DL2_DSP_INIT

#define RVB_HW_REFLECTIONS	    4
#define RVB_HW_SHORTREVERBS	    4
#define RVB_HW_LONGREVERBS	    2

#define RVB_HW_DEFSIZE			1.0f	// Default size parameter = minimum supported size
#define RVB_MAXSMALLSIZE		2.5f	// Largest size that causes feedback delays to be shortened
#define RVB_BASESIZE			0.8f	// Minimum size for reverb feedback delay calculations 

//
// I3dl2 listener properties
//

DEFINETYPE(I3DL2LISTENER, DSFX_I3DL2REVERB_PARAMS);

//
// I3dl2 source properties
//

#define MCPX_I3DL2APPLY_DIRECT      0x00000001
#define MCPX_I3DL2APPLY_SOURCE      0x00000002
#define MCPX_I3DL2APPLY_DIRECTIIR   0x00000004
#define MCPX_I3DL2APPLY_REVERBIIR   0x00000008
#define MCPX_I3DL2APPLY_MASK        0x0000000F

BEGIN_DEFINE_STRUCT()
    DWORD       dwChangeMask;
    LONG        lDirect;
    LONG        lSource;
    INT         nDirectIir;
    INT         nReverbIir;
END_DEFINE_STRUCT(I3DL2SOURCE);

#ifdef __cplusplus

//
// I3DL2 listener object
//

namespace DirectSound
{
    class CI3dl2Listener
    {
        friend class CI3dl2Source;

    protected:
        REFDSI3DL2LISTENER      m_I3dl2Params;      // I3dl2 parameters
        I3DL2LISTENER           m_I3dl2Data;        // Calculated I3dl2 data

    private:
        static const float      m_flScale23;
        static const float      m_flScale16;
        static const DWORD      m_dwSamplesPerSec;
        static const float      m_aflReflectionData[RVB_HW_REFLECTIONS][5];
        static const float      m_aflShortReverbInputFactor[RVB_HW_SHORTREVERBS][2];
        static const float      m_aflLongReverbInputDelay[RVB_HW_LONGREVERBS][4];
        static const float      m_aflShortReverbFeedbackDelay[RVB_HW_SHORTREVERBS];

        enum 
        { 
            MainDelayLineID = 0, 
            ReflectionDelayLineID = 4, 
            ShortReverbDelayLineID = 8, 
            LongReverbDelayLineID = 12 
        };

        enum 
        { 
            InputIIR = 0, 
            MainDelayLineLongReverbIIR = 1, 
            ShortReverbIIR = 4, 
            LongReverbIIR = 8 
        };

    public:
        CI3dl2Listener(REFDSI3DL2LISTENER ds3dl);

    public:
        void Initialize(void);
        void CalculateI3dl2(void);

    private:
        void SetSize(float fSize);
        void SetInputFilter(long lGainHF, float fHFReference);
        void SetReflectionsGain(float fGain);
        void SetReflectionsDelay(float fDelay);
        void SetReverbGain(float fGain);
        void SetReverbDelay(float fDelay);
        void SetDecayTimes(float fDecayTime, float fDecayHFRatio, float fHFReference);
        void SetDiffusion(float fDiffusion);
        void SetDecayFilter(DSFX_I3DL2REVERB_IIR *pIir, DWORD dwDelay, float fDecayTime, float fDecayHFRatio, float fHFReference);
        void Get1PoleLoPass(long lGain, long lGainHF, float fHFReference, float fSamplesPerSec, int *pia, int *pib);
        void Get1PoleLoPass(long lGain, long lGainHF, float fHFReference, float fSamplesPerSec, float *pfa, float *pfb);
    };
}

//
// I3dl2 source object
//

namespace DirectSound
{
    class CI3dl2Source
    {
    public:
        I3DL2SOURCE                 m_I3dl2Data;

    private:
        static const I3DL2SOURCE    m_DefaultI3dl2Data;

    protected:
        const CI3dl2Listener &      m_Listener;
        REFDSI3DL2BUFFER            m_I3dl2Params;

    public:
        CI3dl2Source(const CI3dl2Listener &Listener, REFDSI3DL2BUFFER ds3db);

    public:
        void CalculateI3dl2(FLOAT flDistance);

    private:
        int Get1PoleLoPass(long lGain, long lGainHF, float fHFReference, float fSamplesPerSec);
    };
}

#endif // __cplusplus

#endif // __I3DL2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\makefile.inc ===
DSP: dsstdfx.bin defaultscratchimg.bin

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

dsstdfx.bin defaultscratchimg.bin: dsp\ini\$*.ini
    set _XGPIMAGE_DSP_CODE_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\bin
    set _XGPIMAGE_INI_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\ini
    xgpimage $** $(_NT386TREE)\$*.bin $(SDK_INC_PATH)\$*.h
    copy $(SDK_INC_PATH)\$*.h $(XDK_INC_PATH)\$*.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\hrtf.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HRTF.cpp
 *  Content:    HRTF 3D objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/13/01    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"
#include "xgmath.h"

const D3DVECTOR CHrtfListener::m_vDefaultNormOrient =
{
    1.0f, 0.0f, 0.0f
};

const D3DVECTOR CHrtfListener::m_vDefaultNormFrontOrient =
{
    0.0f, 0.0f, 1.0f
};

const PAN3DSPEAKER CHrtfListener::m_aDefaultSpeakers[PAN3D_SPEAKER_COUNT] = 
{ 
    PAN3D_DEFAULT_SPEAKER_DATA 
};

const HRTFSOURCE CHrtfSource::m_Default3dData =
{
    { 0.0f, 0.0f, 0.0f },   // vNormPos
    0.0f,                   // flMagPos
    0.0f,                   // flAzimuth
    0.0f,                   // flElevation
    0.0f                    // flThetaS
};

const HRTFVOICE CHrtfSource::m_Default3dVoiceData =
{
    0,                      // dwChangeMask
    0,                      // dwMixBinValidMask
    0,                      // dwMixBinChangeMask
    0,                      // lDistanceVolume
    0,                      // lConeVolume
    0,                      // lFrontVolume
    0,                      // lRearVolume
    0,                      // fDoppler
    { NULL, NULL },         // FilterPair
    { 0 }                   // alMixBinVolumes
};

LPFNHRTFCALC CHrtfSource::m_pfnCalculate = NULL;
LPFNGETHRTFFILTERPAIR CHrtfSource::m_pfnGetFilterPair = NULL;
UINT CHrtfSource::m_nAlgorithm = DS3DALG_INVALID;


/****************************************************************************
 *
 *  CHrtfListener
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      LPCDWORD [in]: pointer to the speaker configuration.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHrtfListener::CHrtfListener"

CHrtfListener::CHrtfListener
(
    REFDS3DLISTENER         ds3dl
)
:   m_3dParams(ds3dl)
{
    DPF_ENTER();

    CopyMemory(&m_3dData.vNormOrient, &m_vDefaultNormOrient, sizeof(m_vDefaultNormOrient));
    CopyMemory(&m_3dData.aSpeakers, &m_aDefaultSpeakers, sizeof(m_aDefaultSpeakers));

    m_pTransformMatrix = PHYSALLOC(D3DMATRIX, 1, 16, PAGE_READWRITE);

    DPF_LEAVE_VOID();
}

/****************************************************************************
 *
 *  CHrtfListener
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "~CHrtfListener::CHrtfListener"

CHrtfListener::~CHrtfListener
(
)
{
    DPF_ENTER();

    PHYSFREE(m_pTransformMatrix);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Calculate3d
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      DWORD [in]: parameter mask.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHrtfListener::Calculate3d"

void
CHrtfListener::Calculate3d
(
    DWORD                   dwOperation
)
{
    const LPPAN3DSPEAKER    aSpeakers           = m_3dData.aSpeakers;
    const LPCPAN3DSPEAKER   aDefaultSpeakers    = m_aDefaultSpeakers;
    const UINT              nAlgorithm          = CHrtfSource::GetAlgorithm();
    D3DVECTOR               vNormOrientFront;
    FLOAT                   flTheta;
    XGVECTOR4               v4SpeakerPos;
    DWORD                   i;
    
    DPF_ENTER();

    if(dwOperation & MCPX_3DCALC_LISTENER_ORIENTATION)
    {
        //
        // Recalculate the normalized listener orientation
        //

        if((DS3DALG_FULL_HRTF == nAlgorithm) || (DS3DALG_LIGHT_HRTF == nAlgorithm) || (nAlgorithm >= DS3DALG_COUNT))
        {
            m_3dData.vNormOrient.x = (m_3dParams.vOrientTop.y * m_3dParams.vOrientFront.z) - (m_3dParams.vOrientFront.y * m_3dParams.vOrientTop.z);
            m_3dData.vNormOrient.y = (m_3dParams.vOrientTop.z * m_3dParams.vOrientFront.x) - (m_3dParams.vOrientFront.z * m_3dParams.vOrientTop.x);
            m_3dData.vNormOrient.z = (m_3dParams.vOrientTop.x * m_3dParams.vOrientFront.y) - (m_3dParams.vOrientFront.x * m_3dParams.vOrientTop.y);
        }
        
        //
        // Recalculate the speaker locations
        //

        if((DS3DALG_PAN == nAlgorithm) || (nAlgorithm >= DS3DALG_COUNT))
        {            
            //
            // Normalize front orientation vector
            //

            NormalizeVector3(&vNormOrientFront, &m_3dParams.vOrientFront);

            //
            // Calculate dot product between a default front orientation 
            // vector and new orientation vector. The dot product is the same 
            // as the angle between the default orientation vector and the 
            // new orientation vector because both vectors are normalized.
            //

            flTheta = (FLOAT)acos((vNormOrientFront.x * m_vDefaultNormFrontOrient.x) + (vNormOrientFront.y * m_vDefaultNormFrontOrient.y) + (vNormOrientFront.z * m_vDefaultNormFrontOrient.z));

            //
            // Now use the top orientation vector and the angle to calculate 
            // a transform matrix we need to multiply our speaker matrix by
            //

            ASSERT(m_pTransformMatrix);
            MatrixRotationAxis(m_pTransformMatrix, &m_3dParams.vOrientTop, flTheta);

            //
            // Now transform the speaker positions
            //

            for(i = 0; i < PAN3D_SPEAKER_COUNT; i++) 
            {
                Vec3Transform(&aSpeakers[i].v4SpeakerPos, &aDefaultSpeakers[i].vSpeakerPos, m_pTransformMatrix);
            }            
        }
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CHrtfSource
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHrtfSource::CHrtfSource"

CHrtfSource::CHrtfSource
(
    const CHrtfListener &   Listener,
    REFDS3DSOURCEPARAMS     Params
)
:   m_Listener(Listener),
    m_3dParams(Params)
{
    DPF_ENTER();

    m_3dData = m_Default3dData;
    m_3dVoiceData = m_Default3dVoiceData;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Calculate3d
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      DWORD [in]: parameter mask.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHrtfSource::Calculate3d"

void
CHrtfSource::Calculate3d
(   
    DWORD                   dwOperation
)
{
    DPF_ENTER();

    ASSERT((DS3DMODE_NORMAL == m_3dParams.HrtfParams.dwMode) || (DS3DMODE_HEADRELATIVE == m_3dParams.HrtfParams.dwMode));
    ASSERT(IsValidAlgorithm());

    //
    // Reset the changed voice data masks
    //

    m_3dVoiceData.dwChangeMask = 0;
    m_3dVoiceData.dwMixBinChangeMask = 0;

    //
    // Recalculate
    //

    ASSERT(m_pfnCalculate);
    m_pfnCalculate(dwOperation, this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Calculate3d
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      DWORD [in]: parameter mask.
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::Calculate3d"

void
CFullHrtfSource::Calculate3d
(   
    DWORD                   dwOperation,
    CHrtfSource *           pSource
)
{
    DPF_ENTER();

    if(dwOperation & MCPX_3DCALC_NORMPOS)
    {
        CalcNormPos(pSource);
    }

    if(dwOperation & MCPX_3DCALC_LEFTRIGHT)
    {
        CalcLeftRightGains(pSource);
    }

    if(dwOperation & MCPX_3DCALC_DISTANCE)
    {
        CalcDistanceVolume(pSource);
    }

    if(dwOperation & MCPX_3DCALC_DIRECTION)
    {
        CalcDirection(pSource);
    }

    if(dwOperation & MCPX_3DCALC_CONEVOLUME)
    {
        CalcConeVolume(pSource);
    }

    if(dwOperation & MCPX_3DCALC_FRONTREAR)
    {
        CalcFrontRearGains(pSource);
    }

    if(dwOperation & MCPX_3DCALC_DOPPLER)
    {
        CalcDoppler(pSource);
    }

#ifdef DS3D_ALLOW_ALGORITHM_SWAP

    pSource->m_3dVoiceData.dwMixBinChangeMask = pSource->m_3dVoiceData.dwMixBinValidMask;
    pSource->m_3dVoiceData.dwMixBinValidMask = 0;

#else // DS3D_ALLOW_ALGORITHM_SWAP

    ASSERT(!pSource->m_3dVoiceData.dwMixBinChangeMask);
    ASSERT(!pSource->m_3dVoiceData.dwMixBinValidMask);

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcNormPos
 *
 *  Description:
 *      Calculates the normalized source position.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::CalcNormPos"

void
CFullHrtfSource::CalcNormPos
(   
    CHrtfSource *           pSource
)
{
    const D3DVECTOR &       vListenerPos    = pSource->m_Listener.m_3dParams.vPosition;
    const D3DVECTOR &       vSourcePos      = pSource->m_3dParams.HrtfParams.vPosition;
    D3DVECTOR &             vNormPos        = pSource->m_3dData.vNormPos;
    float &                 flMagPos        = pSource->m_3dData.flMagPos;

    DPF_ENTER();

    vNormPos.x = vSourcePos.x;
    vNormPos.y = vSourcePos.y;
    vNormPos.z = vSourcePos.z;

    if(DS3DMODE_HEADRELATIVE != pSource->m_3dParams.HrtfParams.dwMode)
    {
        vNormPos.x -= vListenerPos.x;
        vNormPos.y -= vListenerPos.y;
        vNormPos.z -= vListenerPos.z;
    }
    
    flMagPos = (float)NormalizeVector3(&vNormPos);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcLeftRightGains
 *
 *  Description:
 *      Calculates left/right pan.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::CalcLeftRightGains"

void
CFullHrtfSource::CalcLeftRightGains
(   
    CHrtfSource *           pSource
)
{
    const DWORD &           dwMode                  = pSource->m_3dParams.HrtfParams.dwMode;
    const DS3DLISTENER &    ListenerParams          = (DS3DMODE_HEADRELATIVE == dwMode) ? DirectSoundDefault3DListener : pSource->m_Listener.m_3dParams;
    const D3DVECTOR &       vListenerNormOrient     = (DS3DMODE_HEADRELATIVE == dwMode) ? CHrtfListener::m_vDefaultNormOrient : pSource->m_Listener.m_3dData.vNormOrient;
    const D3DVECTOR &       vListenerOrientFront    = ListenerParams.vOrientFront;
    const D3DVECTOR &       vListenerOrientTop      = ListenerParams.vOrientTop;
    const float &           flMagPos                = pSource->m_3dData.flMagPos;
    D3DVECTOR &             vNormPos                = pSource->m_3dData.vNormPos;
    float &                 flAzimuth               = pSource->m_3dData.flAzimuth;
    float &                 flElevation             = pSource->m_3dData.flElevation;
    D3DVECTOR               vPDot;
    float                   PdotT;
    float                   absPdotT;
    float                   magnitude;
    float                   absPdotF;
    float                   absPdotR;

    DPF_ENTER();

    //
    // Step 3a:  vPDot.x = PdotR, vPDot.y = 0, vPDot.z = PDotF
    //

    vPDot.z = (vNormPos.x * vListenerOrientFront.x) + (vNormPos.y * vListenerOrientFront.y) + (vNormPos.z * vListenerOrientFront.z);
    vPDot.x = (vNormPos.x * vListenerNormOrient.x) + (vNormPos.y * vListenerNormOrient.y) + (vNormPos.z * vListenerNormOrient.z);

    //
    // Step 3b:  calculate elevation
    //

    if(flMagPos)
    {
        PdotT = (vNormPos.x * vListenerOrientTop.x) + (vNormPos.y * vListenerOrientTop.y) + (vNormPos.z * vListenerOrientTop.z);
        absPdotT = fabsf(PdotT);

        magnitude = MagnitudeVector2(vPDot.x, vPDot.z);

        if(absPdotT < magnitude)
        {
            ASSERT( magnitude != 0.0f );
            flElevation = absPdotT / magnitude * 45.0f;
        }
        else
        {
            ASSERT( absPdotT != 0.0f );
            flElevation = 90.0f - (magnitude / absPdotT * 45.0f);
        }

        if(PdotT < 0.0f)
        {
            flElevation = -flElevation;
        }
    }
    else
    {
        flElevation = 0.0f;
    }

    //
    // Step 3c:  calculate azimuth
    //

    if(flMagPos)
    {
        absPdotF = fabsf(vPDot.z);
        absPdotR = fabsf(vPDot.x);

        if(absPdotF > absPdotR)
        {
            ASSERT( absPdotF != 0.0f );
            flAzimuth = absPdotR / absPdotF * 45.0f;
        }
        else if(absPdotR == 0.0f)
        {
            flAzimuth = 0.0f;
        }
        else
        {
            ASSERT(absPdotR != 0.0f);
            flAzimuth = 90.0f - (absPdotF / absPdotR * 45.0f);
        }
    }
    else
    {
        flAzimuth = 0.0f;
    }
        
    if(vPDot.z < 0.0f)
    {
        flAzimuth = 180.0f - flAzimuth;
    }

    if(vPDot.x < 0.0f)
    {
        flAzimuth = - flAzimuth;
    }

    //
    // Reload coefficients
    //

    GetHrtfFilterPair(pSource);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcDistanceVolume
 *
 *  Description:
 *      Calculates distance attenuation.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::CalcDistanceVolume"

void
CFullHrtfSource::CalcDistanceVolume
(   
    CHrtfSource *           pSource
)
{
    const float &           flSourceRolloffFactor   = pSource->m_3dParams.HrtfParams.flRolloffFactor;
    const float &           flListenerRolloffFactor = pSource->m_Listener.m_3dParams.flRolloffFactor;
    const float &           flMinDistance           = pSource->m_3dParams.HrtfParams.flMinDistance;
    const float &           flMaxDistance           = pSource->m_3dParams.HrtfParams.flMaxDistance;
    const float *           aflRolloffPoints        = pSource->m_3dParams.paflRolloffPoints;
    const DWORD             dwRolloffPointCount     = pSource->m_3dParams.dwRolloffPointCount;
    float                   flMagPos                = pSource->m_3dData.flMagPos;
    float                   flRolloffFactor;
    long                    lDistanceVolume;
    float                   flPointWidth;
    DWORD                   dwNextPoint;
    float                   aflLocalPoints[2];
    float                   flDistanceFromPoint;
    
    DPF_ENTER();

    //
    // If the position is less-than-or-equal-to MinDistance, there is no
    // distance attenuation.  
    //
    // If the position is greater-than-or-equal-to MaxDistance, the distance 
    // is floored.
    //
    // If a rolloff curve has been specified, we'll use that rather than
    // the standard rolloff factor.
    //

    if(flMagPos > flMinDistance)
    {
        if(flMagPos > flMaxDistance)
        {
            flMagPos = flMaxDistance;
        }

        if(aflRolloffPoints && dwRolloffPointCount)
        {
            //
            // How far (in meters) is the space between each point in the 
            // curve?
            //
            
            flPointWidth = (flMaxDistance - flMinDistance) / (float)dwRolloffPointCount;

            //
            // Store the two points the source is between locally.  We do this
            // because f[0] of the curve really specifies the first point after
            // MinDistance and f[n-1] is at MaxDistance.  This allows us to have 
            // a linear rolloff with only one point specified.
            //

            if((dwNextPoint = (DWORD)((flMagPos - flMinDistance) / flPointWidth)) >= dwRolloffPointCount)
            {
                ASSERT(dwRolloffPointCount == dwNextPoint);
                dwNextPoint = dwRolloffPointCount - 1;
            }

            if(!dwNextPoint)
            {
                aflLocalPoints[0] = 1.0f;
                aflLocalPoints[1] = aflRolloffPoints[0];

                flDistanceFromPoint = flMagPos;
            }
            else
            {
                aflLocalPoints[0] = aflRolloffPoints[dwNextPoint - 1];
                aflLocalPoints[1] = aflRolloffPoints[dwNextPoint];

                flDistanceFromPoint = flMagPos - ((float)dwNextPoint * flPointWidth);
            }

            flRolloffFactor = aflLocalPoints[0] + ((flDistanceFromPoint / flPointWidth) * (aflLocalPoints[1] - aflLocalPoints[0]));

            lDistanceVolume = AmplitudeToVolume(flRolloffFactor);
        }
        else
        {
            flRolloffFactor = flSourceRolloffFactor * flListenerRolloffFactor;

            lDistanceVolume = MetersToVolume(flRolloffFactor * (flMagPos / flMinDistance - 1.0f));
        }
    }
    else
    {
        lDistanceVolume = DSBVOLUME_MAX;
    }

    if(lDistanceVolume != pSource->m_3dVoiceData.lDistanceVolume)
    {
        pSource->m_3dVoiceData.lDistanceVolume = lDistanceVolume;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_DISTANCEVOLUME;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcDirection
 *
 *  Description:
 *      Calculates sound direction based on cone orientation.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::CalcDirection"

void
CFullHrtfSource::CalcDirection
(   
    CHrtfSource *           pSource
)
{
    const D3DVECTOR &       vConeOrientation    = pSource->m_3dParams.HrtfParams.vConeOrientation;
    const D3DVECTOR &       vNormPos            = pSource->m_3dData.vNormPos;
    float &                 flThetaS            = pSource->m_3dData.flThetaS;
    float                   absCplusP;
    float                   absCminusP;
    D3DXVECTOR3             CplusP;
    D3DXVECTOR3             CminusP;

    DPF_ENTER();

    ASSERT(vConeOrientation.x || vConeOrientation.y || vConeOrientation.z);

    CminusP.x = vConeOrientation.x - vNormPos.x;
    CminusP.y = vConeOrientation.y - vNormPos.y;
    CminusP.z = vConeOrientation.z - vNormPos.z;
    
    absCminusP = MagnitudeVector3(&CminusP);

    CplusP.x = vConeOrientation.x + vNormPos.x;
    CplusP.y = vConeOrientation.y + vNormPos.y;
    CplusP.z = vConeOrientation.z + vNormPos.z;
    
    absCplusP = MagnitudeVector3(&CplusP);

    if(absCplusP < absCminusP)
    {
        ASSERT(absCminusP);
        flThetaS = 4.0f * (absCplusP / absCminusP * 45.0f);
    }

    else
    {
        ASSERT(absCplusP);
        flThetaS = 4.0f * (90.0f - (absCminusP / absCplusP * 45.0f));
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcConeVolume
 *
 *  Description:
 *      Calculates cone volume.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::CalcConeVolume"

void
CFullHrtfSource::CalcConeVolume
(   
    CHrtfSource *           pSource
)
{
    const DWORD &           dwInsideConeAngle   = pSource->m_3dParams.HrtfParams.dwInsideConeAngle;
    const DWORD &           dwOutsideConeAngle  = pSource->m_3dParams.HrtfParams.dwOutsideConeAngle;
    const long &            lConeOutsideVolume  = pSource->m_3dParams.HrtfParams.lConeOutsideVolume;
    const float &           flThetaS            = pSource->m_3dData.flThetaS;
    long                    lConeVolume;
    
    DPF_ENTER();

    ASSERT(dwInsideConeAngle <= dwOutsideConeAngle);

    if(flThetaS <= (float)dwInsideConeAngle)
    {
        lConeVolume = 0;
    }
    else if((dwInsideConeAngle < dwOutsideConeAngle) && (flThetaS >= (float)dwOutsideConeAngle))
    {
        lConeVolume = lConeOutsideVolume;
    }
    else
    {
        lConeVolume = (long)ftoi((float)lConeOutsideVolume * (flThetaS - (float)dwInsideConeAngle ) / (float)(max(1, dwOutsideConeAngle - dwInsideConeAngle)));
    }

    if(lConeVolume != pSource->m_3dVoiceData.lConeVolume)
    {
        pSource->m_3dVoiceData.lConeVolume = lConeVolume;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_CONEVOLUME;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcFrontRearGains
 *
 *  Description:
 *      Calculates front/rear gains.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::CalcFrontRearGains"

void
CFullHrtfSource::CalcFrontRearGains
(   
    CHrtfSource *           pSource
)
{
    const float &           flMagPos                    = pSource->m_3dData.flMagPos;
    const float &           flSourceDistanceFactor      = pSource->m_3dParams.HrtfParams.flDistanceFactor;
    const float &           flListenerDistanceFactor    = pSource->m_Listener.m_3dParams.flDistanceFactor;
    const float &           flAzimuth                   = pSource->m_3dData.flAzimuth;
    const float &           flElevation                 = pSource->m_3dData.flElevation;
    float                   flDistance;
    float                   flFactor;
    LONG                    lFrontVolume;
    LONG                    lRearVolume;    

    DPF_ENTER();

    //
    // In surround mode, we'll calculate the proper front and rear gains.
    // In mono/stereo mode, front gains are always full and rear gains
    // are always silent.
    //

    if(pSource->m_Listener.m_fSurround)
    {
        //
        // Calculate front and rear gains based on position and distance factor.
        // Scaling factor is 0 for full front, 1 for full rear.
        //

        flDistance = flMagPos * flSourceDistanceFactor * flListenerDistanceFactor;

        flFactor = 0.5f * (1.0f + (fabsf(flAzimuth) / 90.0f - 1.0f) * (1.0f - fabsf(flElevation) / 90.0f));

        //
        // Convert to a range of -0.5 to 1.5 so that no attenuation happens until
        // the sound passes 45 degrees.
        //
    
        flFactor *= 2.0f;
        flFactor -= 0.5f;

        if(flFactor > 1.0f)
        {
            flFactor = 1.0f;
        }
        else if(flFactor < 0.0f)
        {
            flFactor = 0.0f;
        }

        //
        // Inside 0.5 meters, we crossfade to the 0, 0, 0 point at which we have 
        // equal front and rear gains.
        //

        if(flDistance < 0.5f)
        {
            flFactor = 0.5f + (flFactor - 0.5f) * flDistance / 2.0f;
        }

        //
        // Convert to millibels
        //

        lFrontVolume = PowerToVolume(1.0f - flFactor);
        lRearVolume = PowerToVolume(flFactor);
    }
    else
    {
        lFrontVolume = DSBVOLUME_MAX;
        lRearVolume = DSBVOLUME_MIN;
    }        

    if(lFrontVolume != pSource->m_3dVoiceData.lFrontVolume)
    {
        pSource->m_3dVoiceData.lFrontVolume = lFrontVolume;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_FRONTVOLUME;
    }

    if(lRearVolume != pSource->m_3dVoiceData.lRearVolume)
    {
        pSource->m_3dVoiceData.lRearVolume = lRearVolume;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_REARVOLUME;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcDoppler
 *
 *  Description:
 *      Calculates Doppler shift.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::CalcDoppler"

void
CFullHrtfSource::CalcDoppler
(   
    CHrtfSource *           pSource
)
{
    static const float      flSpeedOfSound              = 342.0f;
    const D3DVECTOR &       vSourceVelocity             = pSource->m_3dParams.HrtfParams.vVelocity;
    const D3DVECTOR &       vListenerVelocity           = pSource->m_Listener.m_3dParams.vVelocity;
    const D3DVECTOR &       vNormPos                    = pSource->m_3dData.vNormPos;
    const float &           flSourceDistanceFactor      = pSource->m_3dParams.HrtfParams.flDistanceFactor;
    const float &           flListenerDistanceFactor    = pSource->m_Listener.m_3dParams.flDistanceFactor;
    const float &           flSourceDopplerFactor       = pSource->m_3dParams.HrtfParams.flDopplerFactor;
    const float &           flListenerDopplerFactor     = pSource->m_Listener.m_3dParams.flDopplerFactor;
    float                   flVelocity;
    LONG                    lDopplerPitch;
    
    DPF_ENTER();

    if(DS3DMODE_HEADRELATIVE == pSource->m_3dParams.HrtfParams.dwMode)
    {
        flVelocity = vSourceVelocity.x * vNormPos.x +
                     vSourceVelocity.y * vNormPos.y +
                     vSourceVelocity.z * vNormPos.z;
    }
    else
    {
        flVelocity = (vSourceVelocity.x - vListenerVelocity.x) * vNormPos.x +
                     (vSourceVelocity.y - vListenerVelocity.y) * vNormPos.y +
                     (vSourceVelocity.z - vListenerVelocity.z) * vNormPos.z;
    }

    flVelocity *= flSourceDistanceFactor * flListenerDistanceFactor;
    flVelocity *= flSourceDopplerFactor * flListenerDopplerFactor;

    if(!flVelocity)
    {
        lDopplerPitch = 0;
    }
    else if(flVelocity >= flSpeedOfSound)
    {
        lDopplerPitch = DSBPITCH_MIN;
    }
    else if(flVelocity <= -flSpeedOfSound)
    {
        lDopplerPitch = 4096;
    }
    else
    {
        lDopplerPitch = RatioToPitch(1.0f - flVelocity / flSpeedOfSound);
    }

    if(lDopplerPitch != pSource->m_3dVoiceData.lDopplerPitch)
    {
        pSource->m_3dVoiceData.lDopplerPitch = lDopplerPitch;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_DOPPLERPITCH;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetHrtfFilterPair
 *
 *  Description:
 *      Loads HRTF coefficients.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFullHrtfSource::GetHrtfFilterPair"

void
CFullHrtfSource::GetHrtfFilterPair
(
    CHrtfSource *           pSource
)
{
    static const WORD awFilterIndex[180 / 3 + 1][180 / 6 + 1] = 
    { 
        #include "hrtffull.idx" 
    };

    static const FIRFILTER8 aFilters[] = 
    { 
        #include "hrtffull.flt" 
    };

    static const int        nElevationInnerLimit    = 30;
    static const int        nElevationOuterLimit    = 60;
    const float &           flAzimuth               = pSource->m_3dData.flAzimuth;
    const float &           flElevation             = pSource->m_3dData.flElevation;
    int                     nElevation;
    int                     nAbsElevation;
    float                   flAbsAzimuth;
    int                     nAzimuth;
    int                     nIndex;
    HRTFFILTERPAIR          FilterPair;

    DPF_ENTER();

    ASSERT((flAzimuth >= -180.f) && (flAzimuth <= 180.f));
    ASSERT((flElevation >= -90.f) && (flElevation <= 90.f));

    //
    // Convert elevation to a table index.  The full HRTF table has 6 degrees
    // of elevation granularity.
    //

    if(flElevation >= 0.f)
    {
        nElevation = ftoi(flElevation + 3.f) / 6 * 6;
    }
    else
    {
        nElevation = ftoi(flElevation - 3.f) / 6 * 6;
    }

    nAbsElevation = abs(nElevation);

    //
    // Convert azimuth to a table index.  The full HRTF table has 3 degrees of
    // azimuth granularity.
    //

    flAbsAzimuth = fabsf(flAzimuth);

    if(90 == nAbsElevation)
    {
        nAzimuth = 0;
    }
    else if(nAbsElevation > nElevationOuterLimit)
    {
        nAzimuth = ftoi(flAbsAzimuth + 6.f) / 12 * 12;
    }
    else if(nAbsElevation > nElevationInnerLimit)
    {
        nAzimuth = ftoi(flAbsAzimuth + 3.f) / 6 * 6;
    }
    else
    {
        nAzimuth = ftoi(flAbsAzimuth + 1.5f) / 3 * 3;
    }

    //
    // If we're in quad mode, we don't want to use any of the coefficients 
    // with virtual rear low-pass filter
    //

    if(pSource->m_Listener.m_fSurround)
    {
        if(nAzimuth > 90)
        {
            nAzimuth = 180 - nAzimuth;
        }
    }

    //
    // Look up the filter index
    //

    nAzimuth /= 3;
    
    nElevation += 90;
    nElevation /= 6;

    if(nAzimuth >= NUMELMS(awFilterIndex))
    {
        ASSERTMSG("Azimuth out of range");
        nAzimuth = 0;
    }

    if(nElevation >= NUMELMS(awFilterIndex[0]))
    {
        ASSERTMSG("Elevation out of range");
        nElevation = 0;
    }

    nIndex = awFilterIndex[nAzimuth][nElevation];

    //
    // Load filters
    //

    ASSERT(nIndex < NUMELMS(aFilters) - 1);

    if(flAzimuth >= 0)
    {
        FilterPair.pLeftFilter = &aFilters[nIndex];
        FilterPair.pRightFilter = &aFilters[nIndex + 1];
    }
    else
    {
        FilterPair.pRightFilter = &aFilters[nIndex];
        FilterPair.pLeftFilter = &aFilters[nIndex + 1];
    }

    if((FilterPair.pLeftFilter != pSource->m_3dVoiceData.FilterPair.pLeftFilter) || (FilterPair.pRightFilter != pSource->m_3dVoiceData.FilterPair.pRightFilter))
    {
        pSource->m_3dVoiceData.FilterPair = FilterPair;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_FILTERPAIR;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Calculate3d
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      DWORD [in]: parameter mask.
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CLightHrtfSource::Calculate3d"

void
CLightHrtfSource::Calculate3d
(   
    DWORD                   dwOperation,
    CHrtfSource *           pSource
)
{
    DPF_ENTER();

    if(dwOperation & MCPX_3DCALC_NORMPOS)
    {
        CalcNormPos(pSource);
    }

    if(dwOperation & MCPX_3DCALC_LEFTRIGHT)
    {
        CalcLeftRightGains(pSource);
    }

    if(dwOperation & MCPX_3DCALC_DISTANCE)
    {
        CFullHrtfSource::CalcDistanceVolume(pSource);
    }

    if(dwOperation & MCPX_3DCALC_FRONTREAR)
    {
        CalcFrontRearGains(pSource);
    }

    if(dwOperation & MCPX_3DCALC_DOPPLER)
    {
        CFullHrtfSource::CalcDoppler(pSource);
    }

#ifdef DS3D_ALLOW_ALGORITHM_SWAP

    if(pSource->m_3dVoiceData.lConeVolume)
    {
        pSource->m_3dVoiceData.lConeVolume = 0;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_CONEVOLUME;
    }

    pSource->m_3dVoiceData.dwMixBinChangeMask = pSource->m_3dVoiceData.dwMixBinValidMask;
    pSource->m_3dVoiceData.dwMixBinValidMask = 0;

#else // DS3D_ALLOW_ALGORITHM_SWAP

    ASSERT(!pSource->m_3dVoiceData.lConeVolume);
    ASSERT(!pSource->m_3dVoiceData.dwMixBinValidMask);
    ASSERT(!pSource->m_3dVoiceData.dwMixBinChangeMask);

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcNormPos
 *
 *  Description:
 *      Calculates the normalized source position.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CLightHrtfSource::CalcNormPos"

void
CLightHrtfSource::CalcNormPos
(   
    CHrtfSource *           pSource
)
{
    const D3DVECTOR &       vSourcePos      = pSource->m_3dParams.HrtfParams.vPosition;
    const D3DVECTOR &       vListenerPos    = pSource->m_Listener.m_3dParams.vPosition;
    D3DVECTOR &             vNormPos        = pSource->m_3dData.vNormPos;
    float &                 flMagPos        = pSource->m_3dData.flMagPos;

    DPF_ENTER();

    vNormPos.x = vSourcePos.x;
    vNormPos.z = vSourcePos.z;

    if(DS3DMODE_HEADRELATIVE != pSource->m_3dParams.HrtfParams.dwMode)
    {
        vNormPos.x -= vListenerPos.x;
        vNormPos.z -= vListenerPos.z;
    }
    
    flMagPos = (float)NormalizeVector2(&vNormPos);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcLeftRightGains
 *
 *  Description:
 *      Calculates left/right pan.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CLightHrtfSource::CalcLeftRightGains"

void
CLightHrtfSource::CalcLeftRightGains
(   
    CHrtfSource *           pSource
)
{
    const DWORD &           dwMode                  = pSource->m_3dParams.HrtfParams.dwMode;
    const DS3DLISTENER &    ListenerParams          = (DS3DMODE_HEADRELATIVE == dwMode) ? DirectSoundDefault3DListener : pSource->m_Listener.m_3dParams;
    const D3DVECTOR &       vListenerNormOrient     = (DS3DMODE_HEADRELATIVE == dwMode) ? CHrtfListener::m_vDefaultNormOrient : pSource->m_Listener.m_3dData.vNormOrient;
    const D3DVECTOR &       vListenerOrientFront    = ListenerParams.vOrientFront;
    const D3DVECTOR &       vListenerOrientTop      = ListenerParams.vOrientTop;
    const float &           flMagPos                = pSource->m_3dData.flMagPos;
    D3DVECTOR &             vNormPos                = pSource->m_3dData.vNormPos;
    float &                 flAzimuth               = pSource->m_3dData.flAzimuth;
    float &                 flElevation             = pSource->m_3dData.flElevation;
    D3DVECTOR               vPDot;
    float                   PdotT;
    float                   absPdotT;
    float                   magnitude;
    float                   absPdotF;
    float                   absPdotR;

    DPF_ENTER();

    //
    // Step 3a:  vPDot.x = PdotR, vPDot.y = 0, vPDot.z = PDotF
    //

    vPDot.z = (vNormPos.x * vListenerOrientFront.x) + (vNormPos.y * vListenerOrientFront.y) + (vNormPos.z * vListenerOrientFront.z);
    vPDot.x = (vNormPos.x * vListenerNormOrient.x) + (vNormPos.y * vListenerNormOrient.y) + (vNormPos.z * vListenerNormOrient.z);

    //
    // Step 3c:  calculate azimuth
    //

    if(flMagPos)
    {
        absPdotF = fabsf(vPDot.z);
        absPdotR = fabsf(vPDot.x);

        if(absPdotF > absPdotR)
        {
            ASSERT( absPdotF != 0.0f );
            flAzimuth = absPdotR / absPdotF * 45.0f;
        }
        else if(absPdotR == 0.0f)
        {
            flAzimuth = 0.0f;
        }
        else
        {
            ASSERT(absPdotR != 0.0f);
            flAzimuth = 90.0f - (absPdotF / absPdotR * 45.0f);
        }
    }
    else
    {
        flAzimuth = 0.0f;
    }
        
    if(vPDot.z < 0.0f)
    {
        flAzimuth = 180.0f - flAzimuth;
    }

    if(vPDot.x < 0.0f)
    {
        flAzimuth = - flAzimuth;
    }

    //
    // Reload coefficients
    //

    GetHrtfFilterPair(pSource);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcFrontRearGains
 *
 *  Description:
 *      Calculates front/rear gains.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CLightHrtfSource::CalcFrontRearGains"

void
CLightHrtfSource::CalcFrontRearGains
(   
    CHrtfSource *           pSource
)
{
    const float &           flMagPos                    = pSource->m_3dData.flMagPos;
    const float &           flSourceDistanceFactor      = pSource->m_3dParams.HrtfParams.flDistanceFactor;
    const float &           flListenerDistanceFactor    = pSource->m_Listener.m_3dParams.flDistanceFactor;
    const float &           flAzimuth                   = pSource->m_3dData.flAzimuth;
    const float &           flElevation                 = pSource->m_3dData.flElevation;
    float                   flDistance;
    float                   flFactor;
    LONG                    lFrontVolume;
    LONG                    lRearVolume;    

    DPF_ENTER();

    //
    // In surround mode, we'll calculate the proper front and rear gains.
    // In mono/stereo mode, front gains are always full and rear gains
    // are always silent.
    //

    if(pSource->m_Listener.m_fSurround)
    {
        //
        // Calculate front and rear gains based on position and distance factor.
        // Scaling factor is 0 for full front, 1 for full rear.
        //

        flDistance = flMagPos * flSourceDistanceFactor * flListenerDistanceFactor;

        flFactor = 0.5f * (1.0f + (fabsf(flAzimuth) / 90.0f - 1.0f));

        //
        // Convert to a range of -0.5 to 1.5 so that no attenuation happens until
        // the sound passes 45 degrees.
        //
    
        flFactor *= 2.0f;
        flFactor -= 0.5f;

        if(flFactor > 1.0f)
        {
            flFactor = 1.0f;
        }
        else if(flFactor < 0.0f)
        {
            flFactor = 0.0f;
        }

        //
        // Inside 0.5 meters, we crossfade to the 0, 0, 0 point at which we have 
        // equal front and rear gains.
        //

        if(flDistance < 0.5f)
        {
            flFactor = 0.5f + (flFactor - 0.5f) * flDistance / 2.0f;
        }

        //
        // Convert to millibels
        //

        lFrontVolume = PowerToVolume(1.0f - flFactor);
        lRearVolume = PowerToVolume(flFactor);
    }
    else
    {
        lFrontVolume = DSBVOLUME_MAX;
        lRearVolume = DSBVOLUME_MIN;
    }        

    if(lFrontVolume != pSource->m_3dVoiceData.lFrontVolume)
    {
        pSource->m_3dVoiceData.lFrontVolume = lFrontVolume;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_FRONTVOLUME;
    }

    if(lRearVolume != pSource->m_3dVoiceData.lRearVolume)
    {
        pSource->m_3dVoiceData.lRearVolume = lRearVolume;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_REARVOLUME;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetHrtfFilterPair
 *
 *  Description:
 *      Loads HRTF coefficients.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CLightHrtfSource::GetHrtfFilterPair"

void
CLightHrtfSource::GetHrtfFilterPair
(
    CHrtfSource *           pSource
)
{
    static const FIRFILTER8 aFilters[] = 
    { 
        #include "hrtflite.flt" 
    };

    const float &           flAzimuth       = pSource->m_3dData.flAzimuth;
    const float &           flElevation     = pSource->m_3dData.flElevation;
    float                   flAbsAzimuth;
    int                     nAzimuth;
    int                     nIndex;
    HRTFFILTERPAIR          FilterPair;

    DPF_ENTER();

    ASSERT((flAzimuth >= -180.f) && (flAzimuth <= 180.f));
    ASSERT(!flElevation);

    //
    // Convert azimuth to a table index.  The azimuth HRTF table has 3 degrees 
    // of granularity.
    //

    flAbsAzimuth = fabsf(flAzimuth);

    nAzimuth = ftoi(flAbsAzimuth + 1.5f) / 3 * 3;

    //
    // If we're in quad mode, we don't want to use any of the coefficients 
    // with virtual rear low-pass filter
    //

    if(pSource->m_Listener.m_fSurround)
    {
        if(nAzimuth > 90)
        {
            nAzimuth = 180 - nAzimuth;
        }
    }

    //
    // Calculate the filter index
    //

    if(nAzimuth > 180)
    {
        ASSERTMSG("Azimuth out of range");
        nAzimuth = 0;
    }
    
    nIndex = ((180 - nAzimuth) / 3) * 2;

    //
    // Load filters
    //

    ASSERT(nIndex >= 0);
    ASSERT(nIndex < NUMELMS(aFilters) - 1);

    if(flAzimuth >= 0)
    {
        FilterPair.pLeftFilter = &aFilters[nIndex];
        FilterPair.pRightFilter = &aFilters[nIndex + 1];
    }
    else
    {
        FilterPair.pRightFilter = &aFilters[nIndex];
        FilterPair.pLeftFilter = &aFilters[nIndex + 1];
    }

    if((FilterPair.pLeftFilter != pSource->m_3dVoiceData.FilterPair.pLeftFilter) || (FilterPair.pRightFilter != pSource->m_3dVoiceData.FilterPair.pRightFilter))
    {
        pSource->m_3dVoiceData.FilterPair = FilterPair;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_FILTERPAIR;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Calculate3d
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      DWORD [in]: parameter mask.
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dSource::Calculate3d"

void
CPan3dSource::Calculate3d
(   
    DWORD                   dwOperation,
    CHrtfSource *           pSource
)
{
    DPF_ENTER();

    if(dwOperation & MCPX_3DCALC_NORMPOS)
    {
        CLightHrtfSource::CalcNormPos(pSource);
    }

    if(dwOperation & (MCPX_3DCALC_LEFTRIGHT | MCPX_3DCALC_FRONTREAR))
    {
        CalcPan(pSource);
    }

    if(dwOperation & MCPX_3DCALC_DISTANCE)
    {
        CFullHrtfSource::CalcDistanceVolume(pSource);
    }

    if(dwOperation & MCPX_3DCALC_DOPPLER)
    {
        CFullHrtfSource::CalcDoppler(pSource);
    }

#ifdef DS3D_ALLOW_ALGORITHM_SWAP

    if(pSource->m_3dVoiceData.lConeVolume)
    {
        pSource->m_3dVoiceData.lConeVolume = 0;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_CONEVOLUME;
    }

    if(pSource->m_3dVoiceData.lFrontVolume)
    {
        pSource->m_3dVoiceData.lFrontVolume = 0;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_FRONTVOLUME;
    }

    if(pSource->m_3dVoiceData.lRearVolume)
    {
        pSource->m_3dVoiceData.lRearVolume = 0;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_REARVOLUME;
    }

    if(pSource->m_3dVoiceData.FilterPair.pLeftFilter || pSource->m_3dVoiceData.FilterPair.pRightFilter)
    {
        pSource->m_3dVoiceData.FilterPair.pLeftFilter = NULL;
        pSource->m_3dVoiceData.FilterPair.pRightFilter = NULL;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_FILTERPAIR;
    }

#else // DS3D_ALLOW_ALGORITHM_SWAP

    ASSERT(!pSource->m_3dVoiceData.lConeVolume);
    ASSERT(!pSource->m_3dVoiceData.lFrontVolume);
    ASSERT(!pSource->m_3dVoiceData.lRearVolume);
    ASSERT(!pSource->m_3dVoiceData.FilterPair.pLeftFilter);
    ASSERT(!pSource->m_3dVoiceData.FilterPair.pRightFilter);

#endif // DS3D_ALLOW_ALGORITHM_SWAP

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CalcPan
 *
 *  Description:
 *      Calculates left/right pan.
 *
 *  Arguments:
 *      CHrtfSource * [in]: source object.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dSource::CalcPan"

void
CPan3dSource::CalcPan
(   
    CHrtfSource *           pSource
)
{
    static const float      flAlpha             = 0.25f;
    static const float      flVolumeRange       = 6400.0f;
    static const float      flDCOffset          = 2400.0f;
    const DWORD &           dwMode              = pSource->m_3dParams.HrtfParams.dwMode;
    const LPCPAN3DSPEAKER   aSpeakers           = (DS3DMODE_HEADRELATIVE == dwMode) ? CHrtfListener::m_aDefaultSpeakers : pSource->m_Listener.m_3dData.aSpeakers;
    const float &           flMagPos            = pSource->m_3dData.flMagPos;
    const D3DVECTOR &       vNormPos            = pSource->m_3dData.vNormPos;
    DWORD &                 dwMixBinChangeMask  = pSource->m_3dVoiceData.dwMixBinChangeMask;
    DWORD &                 dwMixBinValidMask   = pSource->m_3dVoiceData.dwMixBinValidMask;
    LPLONG                  alMixBinVolumes     = pSource->m_3dVoiceData.alMixBinVolumes;
    D3DVECTOR               vSpeakerNorm;
    FLOAT                   flSpeakerMag;
    FLOAT                   flSpeakerFactor;
    LONG                    lVolume;
    DWORD                   dwSpeakerCount;
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(!dwMixBinChangeMask);
    dwMixBinValidMask = 0;

    //
    // If we're not running in surround mode, only calculate the front
    // speakers
    //

    if(!flMagPos)
    {
        dwSpeakerCount = 0;
    }
    else if(!pSource->m_Listener.m_fSurround)
    {
        ASSERT(PAN3D_SPEAKER_COUNT >= 2);
        
        ASSERT((DSMIXBIN_3D_FRONT_LEFT == aSpeakers[0].dwMixBin) || (DSMIXBIN_3D_FRONT_RIGHT == aSpeakers[0].dwMixBin));
        ASSERT((DSMIXBIN_3D_FRONT_LEFT == aSpeakers[1].dwMixBin) || (DSMIXBIN_3D_FRONT_RIGHT == aSpeakers[1].dwMixBin));

        dwSpeakerCount = 2;
    }
    else
    {
        dwSpeakerCount = PAN3D_SPEAKER_COUNT;
    }

    //
    // Calculate volume for each speaker.  We're calculating volume for 
    // each speaker, regardless of speaker config so that processing takes
    // the same amount of time.
    //
    // Distance and rolloff attenuation are taken care of in a different
    // function using different data members, so this is strictly pan.
    //

    for(i = 0; i < dwSpeakerCount; i++)
    {

        // alternate algorithm but more cpu intensive
#if 0
        vSpeakerNorm.x = (vNormPos.x - aSpeakers[i].vSpeakerPos.x);
        vSpeakerNorm.y = (vNormPos.y - aSpeakers[i].vSpeakerPos.y);
        vSpeakerNorm.z = (vNormPos.z - aSpeakers[i].vSpeakerPos.z);

        flSpeakerMag = NormalizeVector3(&vSpeakerNorm);
        flSpeakerFactor = 1.0f - (float)exp(-pow(2.0f, flSpeakerMag) * flAlpha);

        ASSERT((flSpeakerFactor >= 0.0f) && (flSpeakerFactor <= 1.0f));
        
        lVolume = (long)(flSpeakerFactor * -flVolumeRange + flDCOffset);

#else
        vSpeakerNorm.x = (vNormPos.x - aSpeakers[i].vSpeakerPos.x)/2;
        vSpeakerNorm.y = (vNormPos.y - aSpeakers[i].vSpeakerPos.y)/2;
        vSpeakerNorm.z = (vNormPos.z - aSpeakers[i].vSpeakerPos.z)/2;

        flSpeakerMag =(FLOAT)(vSpeakerNorm.x*vSpeakerNorm.x +\
            vSpeakerNorm.y*vSpeakerNorm.y +\
            vSpeakerNorm.z*vSpeakerNorm.z);
        
        flSpeakerFactor = flSpeakerMag;

        ASSERT((flSpeakerFactor >= 0.0f) && (flSpeakerFactor <= 1.0f));            
        lVolume = (long)(flSpeakerFactor * -flVolumeRange);

#endif

        
        CHECKRANGE(lVolume, DSBVOLUME_MIN, DSBVOLUME_MAX);
        
        if(lVolume != alMixBinVolumes[aSpeakers[i].dwMixBin])
        {
            alMixBinVolumes[aSpeakers[i].dwMixBin] = lVolume;
            dwMixBinChangeMask |= 1UL << aSpeakers[i].dwMixBin;
        }
        
        dwMixBinValidMask |= 1UL << aSpeakers[i].dwMixBin;
    }

    //
    // Fill in the remaining speakers we would ever recalc, but might not
    // have this time (for example, when position is <= 0, or the speaker
    // config changes).
    //
    
    for(; i < PAN3D_SPEAKER_COUNT; i++)
    {
        if(alMixBinVolumes[aSpeakers[i].dwMixBin])
        {
            alMixBinVolumes[aSpeakers[i].dwMixBin] = 0;
            dwMixBinChangeMask |= 1UL << aSpeakers[i].dwMixBin;
        }

        dwMixBinValidMask |= 1UL << aSpeakers[i].dwMixBin;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetHrtfFilterPair
 *
 *  Description:
 *      Loads HRTF coefficients.
 *
 *  Arguments:
 *      FLOAT [in]: azimuth.
 *      FLOAT [in]: elevation.
 *      BOOL [in]: TRUE if the speaker configuration is a quad setup.
 *      LPHRTFFILTERPAIR [out]: filter pair.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dSource::GetHrtfFilterPair"

void
CPan3dSource::GetHrtfFilterPair
(
    CHrtfSource *           pSource
)
{
    DPF_ENTER();

#ifdef DS3D_ALLOW_ALGORITHM_SWAP

    if(pSource->m_3dVoiceData.FilterPair.pLeftFilter || pSource->m_3dVoiceData.FilterPair.pRightFilter)
    {
        pSource->m_3dVoiceData.FilterPair.pLeftFilter = NULL;
        pSource->m_3dVoiceData.FilterPair.pRightFilter = NULL;
        pSource->m_3dVoiceData.dwChangeMask |= MCPX_3DAPPLY_FILTERPAIR;
    }

#else // DS3D_ALLOW_ALGORITHM_SWAP
    
    ASSERT(!pSource->m_3dVoiceData.FilterPair.pLeftFilter);
    ASSERT(!pSource->m_3dVoiceData.FilterPair.pRightFilter);

#endif // DS3D_ALLOW_ALGORITHM_SWAP
    
    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpapu.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpapu.h
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#ifndef __MCPAPU_H__
#define __MCPAPU_H__

//
// Voice indeces
//

#define MCPX_IS_3D_VOICE(hVoice) \
    ((DWORD)hVoice < MCPX_HW_MAX_3D_VOICES)

#ifdef __cplusplus

//
// Forward declarations
//

namespace DirectSound
{
    class CMcpxVoiceClient;
    class CMcpxBuffer;
    class CMcpxStream;
}

//
// Deferred commands
//

#define MCPX_DEFERREDCMDF_LOWPRIORITY   0x00000001
#define MCPX_DEFERREDCMDF_SCHEDULED     0x00000002
#define MCPX_DEFERREDCMDF_PERSIST       0x00000004

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY                      leListEntry;
    DWORD                           dwFlags;
    DirectSound::CMcpxVoiceClient * pVoice;
    DWORD                           dwCommand;
    DWORD                           dwContext;
    REFERENCE_TIME                  rtTimestamp;
END_DEFINE_STRUCT(MCPX_DEFERRED_COMMAND);

//
// Miscelaneous APU state flags
//

#define MCPX_APUSTATE_GPIMAGE           0x00000001

//
// Audio device implementation
//

namespace DirectSound
{
    class CMcpxAPU
        : public CRefCount, public CMcpxCore

#ifndef MCPX_BOOT_LIB

        , protected CHrtfListener, protected CI3dl2Listener

#endif // MCPX_BOOT_LIB

    {
        friend class CMcpxVoiceClient;

    public:
        DWORD &                     m_dwFree2dVoiceCount;                       // Count of free 2D voices
        DWORD &                     m_dwFree3dVoiceCount;                       // Count of free 3D voices
        LIST_ENTRY                  m_lst3dVoices;                              // List of 3D voices
        CMcpxBufferSgeHeap          m_SgeHeap;                                  // Buffer scatter-gather heap object
        DWORD                       m_dwState;                                  // APU state flags
                                                                            
    protected:                                                                  
        volatile DWORD              m_dwVoiceMapLock;                           // Voice map/list lock count
        CMcpxVoiceClient *          m_apVoiceMap[MCPX_HW_MAX_VOICES];           // Voice usage map
        LIST_ENTRY                  m_alstActiveVoices[MCPX_VOICELIST_COUNT];   // Active voice list
        LIST_ENTRY                  m_lstPendingInactiveVoices;                 // Pending inactive voice list
        LIST_ENTRY                  m_lstDeferredCommandsHigh;                  // Voice deferred command list (high-priority)
        LIST_ENTRY                  m_lstDeferredCommandsLow;                   // Voice deferred command list (low-priority)
        R_INTR                      m_arInterruptStatus[2];                     // Status bits from last interrupt received
        KDPC                        m_dpcInterrupt;                             // Interrupt handler DPC object
        static KINTERRUPT           m_Interrupt;                                // Interrupt object
        KTIMER                      m_tmrDeferredCommandsHigh;                  // Voice deferred command timer
        KDPC                        m_dpcDeferredCommandsHigh;                  // Voice deferred command DPC
        HAL_SHUTDOWN_REGISTRATION   m_HalShutdownData;                          // HAL shutdown registration data

    private:
        static DWORD                m_dwDeltaPanicCount;                        // Delta panic counter
        static DWORD                m_dwDeltaWarningCount;                      // Delta warning counter

#ifdef DEBUG

        static BOOL                 m_fSimulateDeltaPanic;                      // Delta panic simulator
        static BOOL                 m_fSimulateDeltaWarning;                    // Delta warning simulator

#endif // DEBUG

    public:
        CMcpxAPU(CDirectSoundSettings *pSettings);
        virtual ~CMcpxAPU(void);

    public:
        // Initialization
        HRESULT Initialize(void);

        // 3D listener properties
        DWORD Commit3dSettings(void);

        // GP DSP
        HRESULT DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPDSEFFECTIMAGEDESC *ppImageDesc);
        HRESULT SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags);
        HRESULT GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize);
        HRESULT CommitEffectData(void);

        // Device properties
        HRESULT SetHrtfHeadroom(DWORD dwHeadroom);
        HRESULT SetMixBinHeadroom(DWORD dwMixBin);
        HRESULT SetSpeakerConfig(void);

        // Voice allocation
        HRESULT AllocateVoices(CMcpxVoiceClient *pVoice);
        void FreeVoices(CMcpxVoiceClient *pVoice);

        // Synchronization
        void BlockIdleHandler(void);
        void UnblockIdleHandler(void);

        // Deferred voice commands
        BOOL ScheduleDeferredCommand(LPMCPX_DEFERRED_COMMAND pCmd);
        void RemoveDeferredCommand(LPMCPX_DEFERRED_COMMAND pCmd);

        // Work, work, work
        void DoWork(void);

    protected:
        // Voice allocation
        static DWORD AllocateVoice(LPDWORD adwVoiceMap, DWORD dwElementCount);
        static void FreeVoice(DWORD dwVoice, LPDWORD adwVoiceMap, DWORD dwElementCount);

        // Shutdown
        void Terminate(void);
    
        // Interrupt handlers
        BOOL ServiceApuInterrupt(void);
        void ServiceApuInterruptDpc(void);
        void ServiceVoiceInterrupt(void);
        void WaitForMagicWrite(void);
        void HandleFETrap(void);

#ifndef MCPX_BOOT_LIB

        void HandleDeltaWarning(void);
        void HandleDeltaPanic(void);

#endif // MCPX_BOOT_LIB

        void HandleSoftwareMethod(DWORD dwMethod, DWORD dwParam);
        void HandleIdleVoice(DWORD dwIdleVoice);

        // Deferred voice commands
        BOOL ScheduleDeferredCommandHigh(LPMCPX_DEFERRED_COMMAND pCmd);
        BOOL ScheduleDeferredCommandLow(LPMCPX_DEFERRED_COMMAND pCmd);
        void ServiceDeferredCommandsHigh(void);
        void ServiceDeferredCommandsLow(void);
        void RemoveDeferredCommandHigh(LPMCPX_DEFERRED_COMMAND pCmd);
        void RemoveDeferredCommandLow(LPMCPX_DEFERRED_COMMAND pCmd);

        // Interrupt service
        void ScheduleApuInterruptDpc(void);
        void GetInterruptStatus(void);

    private:
        static BOOLEAN ApuInterruptServiceRoutine(PKINTERRUPT pInterrupt, LPVOID pvContext);
        static void ApuInterruptDpcRoutine(PKDPC pDpc, LPVOID pvDeferredContext, LPVOID pvSystemContext1, LPVOID pvSystemContext2);
        static BOOLEAN GetInterruptStatusCallback(LPVOID pvContext);
        static void DeferredCommandDpcRoutine(PKDPC pdpc, LPVOID pvDeferredContext, LPVOID pvSystemContext1, LPVOID pvSystemContext2);
        static void ApuShutdownNotifier(PHAL_SHUTDOWN_REGISTRATION pHalShutdownData);
    };

    __inline HRESULT CMcpxAPU::DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPDSEFFECTIMAGEDESC *ppImageDesc)
    {
        HRESULT                 hr;
    
        ASSERT(m_pGpDspManager);

        if(SUCCEEDED(hr = m_pGpDspManager->DownloadEffectsImage(pvImageBuffer, dwImageSize, ppImageDesc)))
        {
            m_dwState |= MCPX_APUSTATE_GPIMAGE;
        }
        else
        {
            m_dwState &= ~MCPX_APUSTATE_GPIMAGE;
        }

        return hr;
    }

    __inline HRESULT CMcpxAPU::SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags)
    {
        ASSERT(m_pGpDspManager);
        ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);

        return m_pGpDspManager->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);
    }
    
    __inline HRESULT CMcpxAPU::GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize)
    {
        ASSERT(m_pGpDspManager);
        ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);

        return m_pGpDspManager->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);
    }
    
    __inline HRESULT CMcpxAPU::CommitEffectData(void)
    {
        ASSERT(m_pGpDspManager);
        ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);

        m_pGpDspManager->CommitChanges(0, 0);

        return DS_OK;
    }
    
    __inline BOOLEAN CMcpxAPU::ApuInterruptServiceRoutine(PKINTERRUPT pInterrupt, LPVOID pvContext)
    {
        return (BOOLEAN)((CMcpxAPU *)pvContext)->ServiceApuInterrupt();
    }

    __inline void CMcpxAPU::ApuInterruptDpcRoutine(PKDPC pDpc, LPVOID pvDeferredContext, LPVOID pvSystemContext1, LPVOID pvSystemContext2)
    {
        ((CMcpxAPU *)pvDeferredContext)->ServiceApuInterruptDpc();
    }

    __inline void CMcpxAPU::DeferredCommandDpcRoutine(PKDPC pdpc, LPVOID pvDeferredContext, LPVOID pvSystemContext1, LPVOID pvSystemContext2)
    {
        ((CMcpxAPU *)pvDeferredContext)->ServiceDeferredCommandsHigh();
    }

    __inline void CMcpxAPU::ApuShutdownNotifier(PHAL_SHUTDOWN_REGISTRATION pHalShutdownData)
    {
        g_fDirectSoundInFinalRelease = TRUE;
    
        CONTAINING_RECORD(pHalShutdownData, CMcpxAPU, m_HalShutdownData)->Terminate();
    }

    __inline void CMcpxAPU::DoWork(void)
    {
        ServiceDeferredCommandsLow();
    }

    __inline void CMcpxAPU::BlockIdleHandler(void)
    {
        ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
        ASSERT(m_dwVoiceMapLock < ~0UL);
        m_dwVoiceMapLock++;
    }

    __inline void CMcpxAPU::UnblockIdleHandler(void)
    {
        ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
        ASSERT(m_dwVoiceMapLock >= 1);
        m_dwVoiceMapLock--;
    }

    __inline void CMcpxAPU::ScheduleApuInterruptDpc(void)
    {
        KeInsertQueueDpc(&m_dpcInterrupt, NULL, NULL);
    }
}

#endif // __cplusplus

#endif // __MCPAPU_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpapu.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpapu.cpp
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#include "dsoundi.h"


/****************************************************************************
 *
 *  CMcpxAPU
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::CMcpxAPU"

KINTERRUPT CMcpxAPU::m_Interrupt;

DWORD CMcpxAPU::m_dwDeltaWarningCount = 0;
DWORD CMcpxAPU::m_dwDeltaPanicCount = 0;

#ifdef DEBUG

BOOL CMcpxAPU::m_fSimulateDeltaPanic = FALSE;
BOOL CMcpxAPU::m_fSimulateDeltaWarning = FALSE;

#endif // DEBUG

CMcpxAPU::CMcpxAPU
(
    CDirectSoundSettings *  pSettings
)
:   CMcpxCore(pSettings),

#ifndef MCPX_BOOT_LIB

    CHrtfListener(pSettings->m_3dParams.HrtfParams),
    CI3dl2Listener(pSettings->m_3dParams.I3dl2Params),

#endif // MCPX_BOOT_LIB

    m_dwFree2dVoiceCount(g_dwDirectSoundFree2dVoices),
    m_dwFree3dVoiceCount(g_dwDirectSoundFree3dVoices)
{
    DWORD                   i;
    
    DPF_ENTER();
    
    //
    // Initialize defaults
    //
    
    for(i = 0; i < NUMELMS(m_alstActiveVoices); i++)
    {
        InitializeListHead(&m_alstActiveVoices[i]);
    }

    InitializeListHead(&m_lstPendingInactiveVoices);
    InitializeListHead(&m_lstDeferredCommandsHigh);
    InitializeListHead(&m_lstDeferredCommandsLow);

    m_dwFree2dVoiceCount = MCPX_HW_MAX_2D_VOICES;
    m_dwFree3dVoiceCount = MCPX_HW_MAX_3D_VOICES;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxAPU
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::~CMcpxAPU"

CMcpxAPU::~CMcpxAPU
(
    void
)
{
    DPF_ENTER();

    DPF_INFO("APU going away...");

    //
    // Shut down the APU
    //

    Terminate();

    //
    // Disconnect the interrupt handler
    //

    if(m_Interrupt.ServiceRoutine)
    {
        KeDisconnectInterrupt(&m_Interrupt);
        m_Interrupt.ServiceRoutine = NULL;
    }

    //
    // Cancel timers
    //

    KeCancelTimer(&m_tmrDeferredCommandsHigh);

    //
    // Clear any pending DPCs
    //

    if(DpcObject == m_dpcInterrupt.Type)
    {
        KeRemoveQueueDpc(&m_dpcInterrupt);
        m_dpcInterrupt.Type = ~m_dpcInterrupt.Type;
    }

    if(DpcObject == m_dpcDeferredCommandsHigh.Type)
    {
        KeRemoveQueueDpc(&m_dpcDeferredCommandsHigh);
        m_dpcDeferredCommandsHigh.Type = ~m_dpcInterrupt.Type;
    }

    //
    // Unregister the shutdown handler
    //

    if(m_HalShutdownData.NotificationRoutine)
    {
        HalRegisterShutdownNotification(&m_HalShutdownData, FALSE);
        m_HalShutdownData.NotificationRoutine = NULL;
    }

    m_dwFree2dVoiceCount = 0;
    m_dwFree3dVoiceCount = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Intializes the object.
 *
 *  Arguments:
 *      CDirectSoundSettings * [in]: shared settings object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::Initialize"

HRESULT 
CMcpxAPU::Initialize
(
    void
)
{
    ULONG                   ulInterruptVector;
    KIRQL                   irql;
    HRESULT                 hr;
    DWORD                   i;

    //
    // Initialize the APU core
    //

    hr = CMcpxCore::Initialize();

    //
    // Create the buffer SGE heap.  We're only managing 2047 markers because
    // the 2048th is reserved for FXIN buffers.
    //

    if(SUCCEEDED(hr))
    {
        hr = m_SgeHeap.Initialize(MCPX_HW_MAX_BUFFER_PRDS - 1);
    }

    //
    // Set up timers and DPCs
    //
    
	if(SUCCEEDED(hr))
    {
        KeInitializeDpc(&m_dpcInterrupt, ApuInterruptDpcRoutine, this);
        KeInitializeTimer(&m_tmrDeferredCommandsHigh);
        KeInitializeDpc(&m_dpcDeferredCommandsHigh, DeferredCommandDpcRoutine, this);
    }

	//
    // Hook and enable interrupts
    //

    if(SUCCEEDED(hr))
    {
        ulInterruptVector = HalGetInterruptVector(XPCICFG_APU_IRQ, &irql);

        KeInitializeInterrupt(&m_Interrupt, ApuInterruptServiceRoutine, this, ulInterruptVector, irql, LevelSensitive, TRUE);

        if(!KeConnectInterrupt(&m_Interrupt))
        {
            DPF_ERROR("KeConnectInterrupt failed");
            hr = DSERR_GENERIC;
        }
    }

    if(SUCCEEDED(hr))
    {
        MCPX_REG_WRITE(NV_PAPU_ISTS, ~0UL);
    }

    if(SUCCEEDED(hr))
    {
        SetInterruptState(TRUE);
    }

    //
    // Register for HAL shutdown notification
    //

    if(SUCCEEDED(hr))
    {
        m_HalShutdownData.NotificationRoutine = ApuShutdownNotifier;

        HalRegisterShutdownNotification(&m_HalShutdownData, TRUE);
    }

    //
    // Set default headroom values
    //

    if(SUCCEEDED(hr))
    {
        hr = SetHrtfHeadroom(0);
    }

    for(i = 0; (i < NUMELMS(m_pSettings->m_abMixBinHeadroom)) && SUCCEEDED(hr); i++)
    {
        hr = SetMixBinHeadroom(i);
    }

#ifndef MCPX_BOOT_LIB

    //
    // Set up the HRTF listener
    //

    if(SUCCEEDED(hr))
    {
        if(DSSPEAKER_IS_HEADPHONES(m_pSettings->m_dwSpeakerConfig))
        {
            m_fSurround = FALSE;
        }
        else
        {
            m_fSurround = DSSPEAKER_IS_SURROUND(m_pSettings->m_dwSpeakerConfig);
        }
    }

#endif // MCPX_BOOT_LIB

    DPF_LEAVE_HRESULT(hr);

	return hr;
}


/****************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Shuts down the APU.  This function assumes that the system is 
 *      rebooting.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::Terminate"

void
CMcpxAPU::Terminate
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    CMcpxVoiceClient *      pVoice;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Block the idle handler
    //

    BlockIdleHandler();

    //
    // Deactivate all voices
    //

    for(i = 0; i < NUMELMS(m_alstActiveVoices); i++)
    {
        for(pleEntry = m_alstActiveVoices[i].Flink; pleEntry != &m_alstActiveVoices[i]; pleEntry = pleEntry->Flink)
        {
            pVoice = CONTAINING_RECORD(pleEntry, CMcpxVoiceClient, m_leActiveVoice);

            pVoice->DeactivateVoice();
        }
    }

    //
    // Unblock the idle handler
    //

    UnblockIdleHandler();

    //
    // Shut down the APU core
    //

    Reset();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AllocateVoices
 *
 *  Description:
 *      Allocates hardware voices for a client.
 *
 *  Arguments:
 *      CMcpxVoiceClient * [in]: voice client.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::AllocateVoices"

HRESULT
CMcpxAPU::AllocateVoices
(
    CMcpxVoiceClient *      pVoice
)
{
    LPDWORD                 pdwFreeVoiceCount;
    MCPX_VOICE_HANDLE       nFirstVoice;
    MCPX_VOICE_HANDLE       nLastVoice;
    MCPX_VOICE_HANDLE       nVoice;
    BYTE                    bVoiceIndex;
    HRESULT                 hr;

    DPF_ENTER();
    AutoIrql();

#ifdef DEBUG

    ASSERT(pVoice->m_bVoiceCount);
    ASSERT(pVoice->m_bVoiceCount <= NUMELMS(pVoice->m_ahVoices));

    for(bVoiceIndex = 0; bVoiceIndex < NUMELMS(pVoice->m_ahVoices); bVoiceIndex++)
    {
        ASSERT(MCPX_VOICE_HANDLE_INVALID == pVoice->m_ahVoices[bVoiceIndex]);
    }

#endif // DEBUG

    //
    // Block the idle handler in order to lock the voice map
    //

    BlockIdleHandler();

    //
    // Allocate voices
    //
    
    if(pVoice->m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        pdwFreeVoiceCount = &m_dwFree3dVoiceCount;
        nFirstVoice = MCPX_HW_FIRST_3D_VOICE;
        nLastVoice = MCPX_HW_FIRST_3D_VOICE + MCPX_HW_MAX_3D_VOICES - 1;
    }
    else
    {
        pdwFreeVoiceCount = &m_dwFree2dVoiceCount;
        nFirstVoice = MCPX_HW_FIRST_2D_VOICE;
        nLastVoice = MCPX_HW_FIRST_2D_VOICE + MCPX_HW_MAX_2D_VOICES - 1;
    }

    if(pVoice->m_bVoiceCount <= *pdwFreeVoiceCount)
    {
        *pdwFreeVoiceCount -= pVoice->m_bVoiceCount;
        
        bVoiceIndex = 0;
        nVoice = nFirstVoice;

        while(bVoiceIndex < pVoice->m_bVoiceCount)
        {
            ASSERT(nVoice <= nLastVoice);

            if(!m_apVoiceMap[nVoice])
            {
                DPF_INFO("Voice client %x allocated hardware voice %x", pVoice, nVoice);

                pVoice->m_ahVoices[bVoiceIndex] = nVoice;
                m_apVoiceMap[nVoice] = pVoice;

                bVoiceIndex++;
            }

            nVoice++;
        }

        hr = DS_OK;
    }
    else
    {
        DPF_ERROR("Not enough free hardware voices");
        hr = DSERR_INVALIDCALL;
    }

    //
    // Unlock the voice map
    //

    UnblockIdleHandler();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  FreeVoices
 *
 *  Description:
 *      Allocates hardware voices for a client.
 *
 *  Arguments:
 *      CMcpxVoiceClient * [in]: voice client.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::FreeVoices"

void
CMcpxAPU::FreeVoices
(
    CMcpxVoiceClient *      pVoice
)
{
    DWORD                   dwVoiceIndex;
    WORD                    i;

    DPF_ENTER();
    AutoIrql();

    //
    // Block the idle handler in order to lock the voice map
    //

    BlockIdleHandler();

    //
    // Remove each voice from the map and the voice client's array
    //

    for(i = 0; i < pVoice->m_bVoiceCount; i++)
    {
        dwVoiceIndex = (DWORD)pVoice->m_ahVoices[i];
        pVoice->m_ahVoices[i] = MCPX_VOICE_HANDLE_INVALID;
        
        ASSERT(dwVoiceIndex < MCPX_HW_MAX_VOICES);
        ASSERT(m_apVoiceMap[dwVoiceIndex] == pVoice);

        m_apVoiceMap[dwVoiceIndex] = NULL;

        if(MCPX_IS_3D_VOICE(dwVoiceIndex))
        {
            m_dwFree3dVoiceCount++;
        }
        else
        {
            m_dwFree2dVoiceCount++;
        }
    }

#ifdef DEBUG

    for(i = 0; i < NUMELMS(pVoice->m_ahVoices); i++)
    {
        ASSERT(MCPX_VOICE_HANDLE_INVALID == pVoice->m_ahVoices[i]);
    }

#endif // DEBUG

    //
    // Unlock the voice map
    //

    UnblockIdleHandler();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceApuInterrupt
 *
 *  Description:
 *      Handles APU interrupts.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the interrupt was handled.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::ServiceApuInterrupt"

BOOL
CMcpxAPU::ServiceApuInterrupt
(
    void
)
{
    R_INTR                  rInterruptStatus;
    BOOL                    fServiced;

    //
    // Get the pending interrupt
    //
    
    MCPX_REG_READ(NV_PAPU_ISTS, &rInterruptStatus.uValue);

    if(fServiced = MAKEBOOL(rInterruptStatus.General))
    {
        //
        // Clear the interrupt(s)
        //

        MCPX_REG_WRITE(NV_PAPU_ISTS, rInterruptStatus.uValue);

        //
        // Save the interrupt bits
        //

#ifdef DEBUG

        rInterruptStatus.DeltaPanic |= INTERLOCKED_EXCHANGE(m_fSimulateDeltaPanic, 0);
        rInterruptStatus.DeltaWarning |= INTERLOCKED_EXCHANGE(m_fSimulateDeltaWarning, 0);

#endif // DEBUG

        m_arInterruptStatus[0].uValue |= rInterruptStatus.uValue;

        //
        // Check for a trap caused by an error or an overridden hardware 
        // method
        //
    
        if(rInterruptStatus.FETrap)
        {
            HandleFETrap();
        }

#ifdef MCPX_HANDLE_DELTA_PANICS_FROM_ISR

#ifndef MCPX_BOOT_LIB

        //
        // If we got a delta panic, handle it here
        //

        if(rInterruptStatus.DeltaPanic)
        {
            HandleDeltaPanic();
        }

#ifdef MCPX_ENABLE_DELTA_WARNINGS

        else if(rInterruptStatus.DeltaWarning)
        {
            HandleDeltaWarning();
        }

#endif // MCPX_ENABLE_DELTA_WARNINGS

#endif // MCPX_BOOT_LIB

        //
        // If we got a voice interrupt, schedule a DPC to handle it
        //

        if(rInterruptStatus.FEVoice)
        {
            ScheduleApuInterruptDpc();
        }

#else // MCPX_HANDLE_DELTA_PANICS_FROM_ISR

        //
        // If we got a voice interrupt or a delta panic, schedule a DPC to 
        // handle it
        //

        if(rInterruptStatus.DeltaPanic || rInterruptStatus.DeltaWarning || rInterruptStatus.FEVoice)
        {
            ScheduleApuInterruptDpc();
        }

#endif // MCPX_HANDLE_DELTA_PANICS_FROM_ISR

        //
        // Read the interrupt status again to make sure everything's flushed
        //

        MCPX_REG_READ(NV_PAPU_ISTS, &rInterruptStatus.uValue);
    }
    
    return fServiced;
}


/****************************************************************************
 *
 *  WaitForMagicWrite
 *
 *  Description:
 *      Waits for the "magic write" to complete.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::WaitForMagicWrite"

void
CMcpxAPU::WaitForMagicWrite
(
    void
)
{
    static DWORD            dwMagicWriteValue   = 0;
    DWORD                   dwTimeout           = 100;
    volatile DWORD *        pdwMagicWrite;
    DWORD                   i;

    dwMagicWriteValue++;

    pdwMagicWrite = (volatile DWORD *)m_ctxMemory[MCPX_MEM_MAGICWRITE].VirtualAddress;
    *pdwMagicWrite = ~dwMagicWriteValue;

    SetPrivLockState(TRUE);

    MCPX_REG_WRITE(NV_PAPU_FEMEMADDR, m_ctxMemory[MCPX_MEM_MAGICWRITE].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_FEMEMDATA, dwMagicWriteValue);

    SetPrivLockState(FALSE);

    while(*pdwMagicWrite != dwMagicWriteValue)
    {
        if(!dwTimeout--)
        {
            DPF_ERROR("Magic write not completing!");
            break;
        }

        KeStallExecutionProcessor(1);
    }
}


/****************************************************************************
 *
 *  ServiceApuInterruptDpc
 *
 *  Description:
 *      Handles APU interrupts from a deferred procedure callback.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::ServiceApuInterruptDpc"

void
CMcpxAPU::ServiceApuInterruptDpc
(
    void
)
{
    //
    // The DPC will parse the interrupt mask and do processing based on what
    // event was signaled. In ISR-safe fashion, it will read the current 
    // pending interrupt mask twice in the loop. This makes sure the dpc 
    // leaves only when no more ISRs are pending.
    //

    while(TRUE)
    {
        KeSynchronizeExecution(&m_Interrupt, GetInterruptStatusCallback, this);

        if(!m_arInterruptStatus[1].General)
        {
            break;
        }

#ifndef MCPX_BOOT_LIB

#ifndef MCPX_HANDLE_DELTA_PANICS_FROM_ISR

        if(m_arInterruptStatus[1].DeltaPanic)
        {
            HandleDeltaPanic();
        }

#ifdef MCPX_ENABLE_DELTA_WARNINGS

        else if(m_arInterruptStatus[1].DeltaWarning)
        {
            HandleDeltaWarning();
        }

#endif // MCPX_ENABLE_DELTA_WARNINGS

#endif // MCPX_HANDLE_DELTA_PANICS_FROM_ISR

#endif // MCPX_BOOT_LIB

        if(m_arInterruptStatus[1].FEVoice)
        {
            ServiceVoiceInterrupt();
        }

        m_arInterruptStatus[1].uValue = 0;
    } 
}


/****************************************************************************
 *
 *  ServiceVoiceInterrupt
 *
 *  Description:
 *      Handles APU interrupts from a deferred procedure callback.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::ServiceVoiceInterrupt"

void
CMcpxAPU::ServiceVoiceInterrupt
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    CMcpxVoiceClient *      pClient;
    DWORD                   dwVoiceList;

#ifdef MCPX_ENABLE_ISR_DEBUGGING

    DWORD                   i;

#endif // MCPX_ENABLE_ISR_DEBUGGING

    //
    // Wait for the magic write to complete so that all notifiers are 
    // written
    //

    WaitForMagicWrite();

    //
    // Process all active voices.  Because the idle handler is allowed to run
    // while we're in this function, we need to protect ourselves against the
    // active voice list potentially being modified while we're walking it.
    // The best way to do this seems to be restarting at the head of the list
    // every time the list changes.  We can't guarantee that any node in the 
    // list will ever be valid, so we can't keep a back or next pointer.
    //

    for(dwVoiceList = 0; dwVoiceList < NUMELMS(m_alstActiveVoices); dwVoiceList++)
    {
        pleEntry = m_alstActiveVoices[dwVoiceList].Flink;

        while(pleEntry != &m_alstActiveVoices[dwVoiceList])
        {
            pClient = CONTAINING_RECORD(pleEntry, CMcpxVoiceClient, m_leActiveVoice);

#ifdef MCPX_ENABLE_ISR_DEBUGGING

            for(i = 0; i < MCPX_NOTIFIER_COUNT; i++)
            {
                if(pClient->m_Notifier.GetStatus(i))
                {
                    DPF_BLAB("Voice %x (%x) notifier %lu signaled", pClient, pClient->m_ahVoices[0], i);
                }
            }

#endif // MCPX_ENABLE_ISR_DEBUGGING

            pClient->ServiceVoiceInterrupt();

            BlockIdleHandler();
            
            if(IsEntryInList(pleEntry))
            {
                pleEntry = pleEntry->Flink;
            }
            else
            {
                pleEntry = m_alstActiveVoices[dwVoiceList].Flink;
            }

            UnblockIdleHandler();
        }
    }

    //
    // Process the pending inactive voice list, but this time just remove
    // every node from the list as we go.
    //

    while(TRUE)
    {
        BlockIdleHandler();
        
        pleEntry = RemoveHeadList(&m_lstPendingInactiveVoices);

        UnblockIdleHandler();

        if(&m_lstPendingInactiveVoices == pleEntry)
        {
            break;
        }
    
        pClient = CONTAINING_RECORD(pleEntry, CMcpxVoiceClient, m_lePendingInactiveVoice);

#ifdef MCPX_ENABLE_ISR_DEBUGGING

        if(!pClient->m_Notifier.GetStatus(MCPX_NOTIFIER_SSLA_DONE))
        {
            if(!pClient->m_Notifier.GetStatus(MCPX_NOTIFIER_SSLB_DONE))
            {
                if(!pClient->m_Notifier.GetStatus(MCPX_NOTIFIER_VOICE_OFF))
                {
                    ASSERTMSG("Voice has no signaled notifiers");
                }
            }
        }

#endif // MCPX_ENABLE_ISR_DEBUGGING

        pClient->ServiceVoiceInterrupt();
    }
}


/****************************************************************************
 *
 *  GetInterruptStatusCallback
 *
 *  Description:
 *      Interrupt synchonization function.
 *
 *  Arguments:
 *      LPVOID [in]: context.
 *
 *  Returns:  
 *      BOOLEAN: TRUE.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::GetInterruptStatusCallback"

BOOLEAN 
CMcpxAPU::GetInterruptStatusCallback
(
    LPVOID                  pvContext
)
{
    CMcpxAPU *              pThis   = (CMcpxAPU *)pvContext;

    pThis->m_arInterruptStatus[1].uValue |= INTERLOCKED_EXCHANGE(pThis->m_arInterruptStatus[0].uValue, 0);

    return TRUE;
}


/****************************************************************************
 *
 *  HandleFETrap
 *
 *  Description:
 *      Handles front-end method traps.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::HandleFETrap"

VOID
CMcpxAPU::HandleFETrap
(
    void
)
{
    R_FE_CONTROL            rFeControl;
    DWORD                   dwParam;
    DWORD                   dwMethod;

    //
    // Whahoppen?
    //
    
    MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);

#ifdef MCPX_ENABLE_ISR_DEBUGGING

    ASSERT(NV_PAPU_FECTL_FEMETHMODE_TRAPPED == rFeControl.Mode);

#endif // MCPX_ENABLE_ISR_DEBUGGING

    MCPX_REG_READ(NV_PAPU_FEDECMETH, &dwMethod);
    MCPX_REG_READ(NV_PAPU_FEDECPARAM, &dwParam);

    dwMethod = MCPX_GET_REG_VALUE(dwMethod, NV_PAPU_FEDECMETH_METH);
    dwParam = MCPX_GET_REG_VALUE(dwParam, NV_PAPU_FEDECPARAM_VALUE);

    switch(rFeControl.TrapReason)
    {
        case NV_PAPU_FECTL_FETRAPREASON_NONE:
            DPF_ERROR("NONE: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED:
            DPF_ERROR("NOT_IMPLEMENTED: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN:
            DPF_ERROR("METHOD_UNKNOWN: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT:
            DPF_ERROR("BAD_ARGUMENT: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET:
            DPF_ERROR("CURRENT_NOT_SET: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET:
            DPF_ERROR("ANTECEDENT_NOT_SET: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE:
            DPF_ERROR("BAD_DATA_TYPE: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER:
            DPF_ERROR("BAD_LIST_POINTER: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D:
            DPF_ERROR("CURRENT_VOICE_NOT_3d: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID:
            DPF_ERROR("CTXPA_INVALID: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_REQUESTED:
            HandleSoftwareMethod(dwMethod, dwParam);
            break;
        
        default:
            DPF_ERROR("(unknown) %x: method %x, param %x", (DWORD)rFeControl.TrapReason, dwMethod, dwParam);
            break;
    }

    //
    // Snap the FE out of trap mode
    //

    SetFrontEndState(MCPX_FE_STATE_HALTED);
    SetFrontEndState(MCPX_FE_STATE_FREE_RUNNING);
}


/****************************************************************************
 *
 *  HandleDeltaWarning
 *
 *  Description:
 *      Handles a delta warning (when the APU output read cursor gets too 
 *      close to the write cursor).
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::HandleDeltaWarning"

void
CMcpxAPU::HandleDeltaWarning
(
    void
)
{
    DWORD                   XGSCNT;
    DWORD                   DGSCNT;
    
    DPF_ENTER();

#if !defined(MCPX_HANDLE_DELTA_PANICS_FROM_ISR) || defined(MCPX_ENABLE_ISR_DEBUGGING)

    DPF_WARNING("Delta warning");

#endif // !defined(MCPX_HANDLE_DELTA_PANICS_FROM_ISR) || defined(MCPX_ENABLE_ISR_DEBUGGING)

    m_dwDeltaWarningCount++;

    MCPX_REG_READ(NV_PAPU_XGSCNT, &XGSCNT);
    MCPX_REG_READ(NV_PAPU_DGSCNT, &DGSCNT);
    
    MCPX_REG_WRITE(NV_PAPU_IGSCNT, XGSCNT + DGSCNT);
    
    DPF_LEAVE_VOID();
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  HandleDeltaPanic
 *
 *  Description:
 *      Handles a delta panic (when the APU output read cursor passes the
 *      write cursor).
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::HandleDeltaPanic"

void
CMcpxAPU::HandleDeltaPanic
(
    void
)
{
    BOOL                    fIdle;
    
    DPF_ENTER();

#if !defined(MCPX_HANDLE_DELTA_PANICS_FROM_ISR) || defined(MCPX_ENABLE_ISR_DEBUGGING)

    DPF_WARNING("Delta panic.  You'll hear a glitch while the APU is reset...");

#endif // !defined(MCPX_HANDLE_DELTA_PANICS_FROM_ISR) || defined(MCPX_ENABLE_ISR_DEBUGGING)
    
    m_dwDeltaPanicCount++;

#ifdef MCPX_HANDLE_DELTA_PANICS_FROM_ISR

    //
    // Shut down the setup engine
    //

    SetSetupEngineState(MCPX_SE_STATE_OFF);

#else // MCPX_HANDLE_DELTA_PANICS_FROM_ISR

    //
    // Idle the voice processor
    //

    fIdle = IdleVoiceProcessor(TRUE);

#endif // MCPX_HANDLE_DELTA_PANICS_FROM_ISR

    //
    // Reset the ACI DMA
    //

    m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Reset();
    m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Reset();

    //
    // Reset the sample counters
    //

    ResetGlobalCounters();

    //
    // Reset the EP
    //

    MCPX_REG_WRITE(NV_PAPU_EPRST, 1);

    SetupEncodeProcessor();

    //
    // Start the ACI running again
    //

    m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Run();
    m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Run();

#ifdef MCPX_HANDLE_DELTA_PANICS_FROM_ISR

    //
    // Restart the setup engine
    //

    SetSetupEngineState(MCPX_SE_STATE_DEFAULT);

#else // MCPX_HANDLE_DELTA_PANICS_FROM_ISR

    //
    // Restore the VP state
    //

    if(fIdle)
    {
        IdleVoiceProcessor(FALSE);
    }

#endif // MCPX_HANDLE_DELTA_PANICS_FROM_ISR

    DPF_LEAVE_VOID();
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  HandleSoftwareMethod
 *
 *  Description:
 *      Dispatches a software-overridden hardware method.
 *
 *  Arguments:
 *      DWORD [in]: method identifier.
 *      DWORD [in]: method parameter.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::HandleSoftwareMethod"

void
CMcpxAPU::HandleSoftwareMethod
(
    DWORD                   dwMethod,
    DWORD                   dwParam
)
{
    switch(dwMethod)
    {
        case 0x8000:
            
            //
            // SE2FE_IDLE_VOICE is undocumented since it's an internal method
            //

            HandleIdleVoice(dwParam);

            break;

        default:
            
            //
            // Huh?
            //

            DPF_ERROR("Unexpected software method:  %x %x", dwMethod, dwParam);

            break;
    }
}


/****************************************************************************
 *
 *  HandleIdleVoice
 *
 *  Description:
 *      Handles the SE2FE_IDLE_VOICE hardware method by removing the voice
 *      from it's processing list.
 *
 *  Arguments:
 *      DWORD [in]: voice index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::HandleIdleVoice"

void
CMcpxAPU::HandleIdleVoice
(
    DWORD                   dwIdleVoice
)
{
    CMcpxVoiceClient *      pClient;
    DWORD                   dwVoiceFormat;
    
#ifdef MCPX_ENABLE_ISR_DEBUGGING

    DWORD                   dwVoiceState;

#endif // MCPX_ENABLE_ISR_DEBUGGING

    DEBUGLOG("HandleIdleVoice %x", dwIdleVoice);

    //
    // Check the voice index for validity.  The hardware sometimes likes
    // to have some fun with us.
    //

    if(dwIdleVoice < MCPX_HW_MAX_VOICES)
    {
        //
        // Make sure no-one's accessing the voice map.  If they are, we can
        // just ignore the idle message and it will get posted again on the
        // next frame.
        //

        if(!m_dwVoiceMapLock)
        {
            //
            // Don't remove PERSIST voices from the list.  When those voices
            // need to go away, they'll remove the PERSIST bit from their
            // format.
            //

#ifdef MCPX_ENABLE_ISR_DEBUGGING

            MCPX_VOICE_STRUCT_READ(dwIdleVoice, NV_PAVS_VOICE_PAR_STATE, &dwVoiceState);

#endif // MCPX_ENABLE_ISR_DEBUGGING

            MCPX_VOICE_STRUCT_READ(dwIdleVoice, NV_PAVS_VOICE_CFG_FMT, &dwVoiceFormat);

            if(!MCPX_GET_REG_VALUE(dwVoiceFormat, NV_PAVS_VOICE_CFG_FMT_PERSIST))
            {

#ifdef MCPX_ENABLE_ISR_DEBUGGING

                DPF_BLAB("Hardware reports voice %x is idle", dwIdleVoice);

                ASSERT(!MCPX_GET_REG_VALUE(dwVoiceState, NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE));

#endif // MCPX_ENABLE_ISR_DEBUGGING
        
                //
                // Get the voice client for the hardware voice
                //

                pClient = m_apVoiceMap[dwIdleVoice];

#ifdef MCPX_ENABLE_ISR_DEBUGGING

                ASSERT(pClient);

#endif // MCPX_ENABLE_ISR_DEBUGGING

#ifdef MCPX_DEBUG_STUCK_VOICES

                pClient->m_dwIgnoredTraps = 0;

#endif // MCPX_DEBUG_STUCK_VOICES
        
                //
                // We don't want to remove the voice from the processing list until the
                // last hardware voice is done processing.  Because the voices are always
                // placed into the processing list in order, the last voice in the array
                // should be the last one to finish.
                //

                if(dwIdleVoice == (DWORD)pClient->m_ahVoices[pClient->m_bVoiceCount - 1])
                {
                    if(IsEntryInList(&pClient->m_leActiveVoice))
                    {
                        pClient->RemoveIdleVoice();
                    }            
                    else
                    {
                        ASSERTMSG("Voice not in software active list");
                    }
                }
                else
                {

#ifdef MCPX_ENABLE_ISR_DEBUGGING

                    DPF_BLAB("Waiting for voice %x to idle...", pClient->m_ahVoices[pClient->m_bVoiceCount - 1]);

#endif // MCPX_ENABLE_ISR_DEBUGGING
        
                }
            }
            else
            {

#ifdef MCPX_ENABLE_ISR_DEBUGGING

                ASSERT(!MCPX_GET_REG_VALUE(dwVoiceState, NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE));

#endif // MCPX_ENABLE_ISR_DEBUGGING

            }
        }

#ifdef MCPX_DEBUG_STUCK_VOICES

        else
        {
            pClient = m_apVoiceMap[dwIdleVoice];
            ASSERT(pClient);

            pClient->m_dwIgnoredTraps++;
        }

#endif // MCPX_DEBUG_STUCK_VOICES
        
    }

#if defined(MCPX_ENABLE_ISR_DEBUGGING) || defined(MCPX_DEBUG_STUCK_VOICES)

    else
    {
        DPF_ERROR("Internal hardware error -- invalid voice index in idle message (%x)", dwIdleVoice);
    }

#endif // defined(MCPX_ENABLE_ISR_DEBUGGING) || defined(MCPX_DEBUG_STUCK_VOICES)

}


/***************************************************************************
 *
 *  Commit3dSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      DWORD [in]: parameter mask.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::Commit3dSettings"

DWORD
CMcpxAPU::Commit3dSettings
(
    void
)
{
    static const DWORD      dwStateOffset   = offsetof(DSFX_I3DL2REVERB_PARAMS, State.dwFlags);
    static const DWORD      dwParamOffset   = offsetof(DSFX_I3DL2REVERB_PARAMS, dwReflectionsInputDelay[0]);
    DWORD                   dwParameterMask;

    DPF_ENTER();

    //
    // Cache the parameter mask.  We're relying on the calling function to
    // clear it after all 3D voices have been recalculated.
    //
    
    dwParameterMask = m_pSettings->m_3dParams.dwParameterMask;

    //
    // Recalculate 3D
    //

    Calculate3d(dwParameterMask);

    //
    // Recalculate I3DL2
    //

    if((dwParameterMask & MCPX_3DCALC_I3DL2LISTENER) && (DSFX_IMAGELOC_UNUSED != m_pSettings->m_EffectLocations.dwI3DL2ReverbIndex))
    {
        //
        // Reverb effect data is made up of the following sections:
        //  - state block
        //  - delay line offsets/sizes
        //  - reverb parameters
        //
        // We're using this internal knowlege to tell us where to poke the
        // I3DL2 data.  If the reverb state block size ever changes, update
        // DSFX_I3DL2REVERB_PARAMS.
        //
        // Neither the state block nor the delay line data change between
        // calls to SetI3dl2Listener, so we'll start the changes after both
        // of those.
        //

        if(SUCCEEDED(GetEffectData(m_pSettings->m_EffectLocations.dwI3DL2ReverbIndex, 0, &m_I3dl2Data, dwParamOffset)))
        {
            //
            // In the Nov01 release, I accidentally broke I3DL2 by adding this
            // call to Initialize and failing to remove the Initialize call in
            // CI3dl2Listener::CalculateI3dl2.  If any games tweaked their
            // I3DL2 parameters based on this bug, we want them to be able to
            // get back to the broken behavior.
            //
            
            if(g_fDirectSoundI3DL2Overdelay)
            {
                CI3dl2Listener::Initialize();
            }

            CI3dl2Listener::CalculateI3dl2();

            m_I3dl2Data.State.dwFlags |= DSFX_STATE_UPDATE;

            SetEffectData(m_pSettings->m_EffectLocations.dwI3DL2ReverbIndex, dwStateOffset, &m_I3dl2Data.State.dwFlags, sizeof(m_I3dl2Data.State.dwFlags), DSFX_DEFERRED);
            SetEffectData(m_pSettings->m_EffectLocations.dwI3DL2ReverbIndex, dwParamOffset, (LPBYTE)&m_I3dl2Data + dwParamOffset, sizeof(DSFX_I3DL2REVERB_PARAMS) - dwParamOffset, DSFX_DEFERRED);
            
            CommitEffectData();
        }
    }

    DPF_LEAVE(dwParameterMask);

    return dwParameterMask;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  ScheduleDeferredCommand
 *
 *  Description:
 *      Adds a deferred voice command to the queue.
 *
 *  Arguments:
 *      LPMCPX_DEFERRED_COMMAND [in/out]: command data.
 *
 *  Returns:  
 *      BOOL: TRUE if the command was scheduled.  If the timestamp for the
 *            command has already elapsed, it won't be scheduled and should
 *            be processed immediately.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::ScheduleDeferredCommand"

BOOL
CMcpxAPU::ScheduleDeferredCommand
(
    LPMCPX_DEFERRED_COMMAND pCmd
)
{
    BOOL                    fScheduled;
 
    DPF_ENTER();
    AutoIrql();

    if(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY)
    {
        fScheduled = ScheduleDeferredCommandLow(pCmd);
    }
    else
    {
        fScheduled = ScheduleDeferredCommandHigh(pCmd);
    }

    if(fScheduled)
    {
        pCmd->dwFlags |= MCPX_DEFERREDCMDF_SCHEDULED;
    }

    DPF_LEAVE(fScheduled);

    return fScheduled;
}


/****************************************************************************
 *
 *  ScheduleDeferredCommandHigh
 *
 *  Description:
 *      Adds a high-priority deferred voice command to the queue.
 *
 *  Arguments:
 *      LPMCPX_DEFERRED_COMMAND [in/out]: command data.
 *
 *  Returns:  
 *      BOOL: TRUE if the command was scheduled.  If the timestamp for the
 *            command has already elapsed, it won't be scheduled and should
 *            be processed immediately.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::ScheduleDeferredCommandHigh"

BOOL
CMcpxAPU::ScheduleDeferredCommandHigh
(
    LPMCPX_DEFERRED_COMMAND pCmd
)
{
    REFERENCE_TIME          rtCurrentTime;
    PLIST_ENTRY             pleNextEntry;
    BOOL                    fScheduled;

    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY));
    ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_PERSIST));

    //
    // Check the current time.  If the timestamp has already elapsed,
    // we aren't going to schedule the command.
    //

    if(pCmd->rtTimestamp)
    {
        KeQuerySystemTime((PLARGE_INTEGER)&rtCurrentTime);

        if(pCmd->rtTimestamp <= 0)
        {
            pCmd->rtTimestamp = rtCurrentTime - pCmd->rtTimestamp;
        }

        if(fScheduled = (pCmd->rtTimestamp > rtCurrentTime))
        {
            //
            // If the command is already scheduled, remove it from the queue
            //

            if(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED)
            {
                RemoveDeferredCommand(pCmd);
            }

            //
            // Insert the command into the list in the order commands should be
            // processed.
            //

            for(pleNextEntry = m_lstDeferredCommandsHigh.Flink; pleNextEntry != &m_lstDeferredCommandsHigh; pleNextEntry = pleNextEntry->Flink)
            {
                AssertValidEntryList(pleNextEntry, ASSERT_IN_LIST);

                if(CONTAINING_RECORD(pleNextEntry, MCPX_DEFERRED_COMMAND, leListEntry)->rtTimestamp > pCmd->rtTimestamp)
                {
                    break;
                }
            }

            InsertTailList(pleNextEntry, &pCmd->leListEntry);

            //
            // If we just added the new item at the head of the list, set the timer
            //

            if(&pCmd->leListEntry == m_lstDeferredCommandsHigh.Flink)
            {
                KeSetTimer(&m_tmrDeferredCommandsHigh, *(PLARGE_INTEGER)&pCmd->rtTimestamp, &m_dpcDeferredCommandsHigh);
            }
        }
    }
    else
    {
        fScheduled = FALSE;
    }

    DPF_LEAVE(fScheduled);

    return fScheduled;
}


/****************************************************************************
 *
 *  ScheduleDeferredCommandLow
 *
 *  Description:
 *      Adds a low-priority deferred voice command to the queue.
 *
 *  Arguments:
 *      LPMCPX_DEFERRED_COMMAND [in/out]: command data.
 *
 *  Returns:  
 *      BOOL: TRUE if the command was scheduled.  If the timestamp for the
 *            command has already elapsed, it won't be scheduled and should
 *            be processed immediately.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::ScheduleDeferredCommandLow"

BOOL
CMcpxAPU::ScheduleDeferredCommandLow
(
    LPMCPX_DEFERRED_COMMAND pCmd
)
{
    DWORD                   dwIndex;

    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY);
    ASSERT(!pCmd->rtTimestamp);

    //
    // If the command is already in the queue, we don't need to do 
    // anything.  Low-priority commands don't use a timestamp, so the
    // list order is meaningless and there are no timers to reset.
    //

    if(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED))
    {
        InsertTailList(&m_lstDeferredCommandsLow, &pCmd->leListEntry);
    }

    DPF_LEAVE(TRUE);

    return TRUE;
}


/****************************************************************************
 *
 *  RemoveDeferredCommand
 *
 *  Description:
 *      Removes a deferred voice command from the queue.
 *
 *  Arguments:
 *      LPMCPX_DEFERRED_COMMAND [in/out]: command data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::RemoveDeferredCommand"

void
CMcpxAPU::RemoveDeferredCommand
(
    LPMCPX_DEFERRED_COMMAND pCmd
)
{
    DPF_ENTER();
    AutoIrql();

    if(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED)
    {
        if(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY)
        {
            RemoveDeferredCommandLow(pCmd);
        }
        else
        {
            RemoveDeferredCommandHigh(pCmd);
        }
    }

    pCmd->dwFlags &= ~MCPX_DEFERREDCMDF_SCHEDULED;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  RemoveDeferredCommandHigh
 *
 *  Description:
 *      Removes a deferred voice command from the queue.
 *
 *  Arguments:
 *      LPMCPX_DEFERRED_COMMAND [in/out]: command data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::RemoveDeferredCommandHigh"

void
CMcpxAPU::RemoveDeferredCommandHigh
(
    LPMCPX_DEFERRED_COMMAND pCmd
)
{
    BOOL                    fListHead;

    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY));
    ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED);

    //
    // If this is the first command in the queue, we'll have some extra
    // processing to do.
    //

    fListHead = (&pCmd->leListEntry == m_lstDeferredCommandsHigh.Flink);

    //
    // Remove the command from the queue.  If we're in the middle of
    // processing the list, defer that to later.
    //

    RemoveEntryList(&pCmd->leListEntry);

    //
    // If that was the only item in the list, cancel the timer and remove
    // any pending DPCs.  If there's still items in the list, but we
    // removed the head, reset the timer.
    // 

    if(IsListEmpty(&m_lstDeferredCommandsHigh))
    {
        KeCancelTimer(&m_tmrDeferredCommandsHigh);
        KeRemoveQueueDpc(&m_dpcDeferredCommandsHigh);
    }
    else if(fListHead)
    {
        KeSetTimer(&m_tmrDeferredCommandsHigh, *(PLARGE_INTEGER)&CONTAINING_RECORD(m_lstDeferredCommandsHigh.Flink, MCPX_DEFERRED_COMMAND, leListEntry)->rtTimestamp, &m_dpcDeferredCommandsHigh);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  RemoveDeferredCommandLow
 *
 *  Description:
 *      Removes a deferred voice command from the queue.
 *
 *  Arguments:
 *      LPMCPX_DEFERRED_COMMAND [in/out]: command data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::RemoveDeferredCommandLow"

void
CMcpxAPU::RemoveDeferredCommandLow
(
    LPMCPX_DEFERRED_COMMAND pCmd
)
{
    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY);
    ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED);

    //
    // Remove the command from the queue
    //

    RemoveEntryList(&pCmd->leListEntry);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceDeferredCommandsHigh
 *
 *  Description:
 *      Services high-priority deferred commands in the queue.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::ServiceDeferredCommandsHigh"

void
CMcpxAPU::ServiceDeferredCommandsHigh
(
    void
)
{
    LPMCPX_DEFERRED_COMMAND     pCmd;
    REFERENCE_TIME              rtCurrentTime;
    
    DPF_ENTER();
    AutoIrql();

    while(!IsListEmpty(&m_lstDeferredCommandsHigh))
    {
        pCmd = CONTAINING_RECORD(m_lstDeferredCommandsHigh.Flink, MCPX_DEFERRED_COMMAND, leListEntry);

        ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY));
        ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED);
        ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_PERSIST));

        //
        // Get the current system time
        //

        KeQuerySystemTime((PLARGE_INTEGER)&rtCurrentTime);

        //
        // If the first command in the list's timestamp has expired, go ahead 
        // and trigger it and remove it from the queue.  If not, reset the
        // timer and bail out.
        //

        if(pCmd->rtTimestamp <= rtCurrentTime)
        {
            pCmd->dwFlags &= ~MCPX_DEFERREDCMDF_SCHEDULED;

            RemoveEntryList(&pCmd->leListEntry);

            pCmd->pVoice->ServiceDeferredCommand(pCmd->dwCommand, pCmd->dwContext);
        }
        else
        {
            KeSetTimer(&m_tmrDeferredCommandsHigh, *(PLARGE_INTEGER)&pCmd->rtTimestamp, &m_dpcDeferredCommandsHigh);
            break;
        }
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceDeferredCommandsLow
 *
 *  Description:
 *      Services low-priority deferred commands in the queue.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::ServiceDeferredCommandsLow"

void
CMcpxAPU::ServiceDeferredCommandsLow
(
    void
)
{
    LIST_ENTRY              lstCommands;
    PLIST_ENTRY             pleEntry;
    LPMCPX_DEFERRED_COMMAND pCmd;
    CIrql                   irql;
    
    DPF_ENTER();

    //
    // Create a local copy of the command list.  We're doing this so we
    // can safely walk the list without worrying about nodes being added
    // or removed.
    //

    InitializeListHead(&lstCommands);

    irql.Raise();
    
    while(!IsListEmpty(&m_lstDeferredCommandsLow))
    {
        MoveEntryTailList(&lstCommands, m_lstDeferredCommandsLow.Flink);
    }

    //
    // Service all commands, removing them from the local list and adding
    // them back to the main list.
    //

    while((pleEntry = RemoveHeadList(&lstCommands)) != &lstCommands)
    {
        pCmd = CONTAINING_RECORD(pleEntry, MCPX_DEFERRED_COMMAND, leListEntry);

        ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY);
        ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED);

        if(pCmd->dwFlags & MCPX_DEFERREDCMDF_PERSIST)
        {
            InsertTailList(&m_lstDeferredCommandsLow, pleEntry);
        }
        else
        {
            pCmd->dwFlags &= ~MCPX_DEFERREDCMDF_SCHEDULED;
        }

        irql.Lower();

        pCmd->pVoice->ServiceDeferredCommand(pCmd->dwCommand, pCmd->dwContext);

        irql.Raise();
    }

    ASSERT(IsListEmpty(&lstCommands));

    irql.Lower();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetHrtfHeadroom
 *
 *  Description:
 *      Sets the HRTF headroom.
 *
 *  Arguments:
 *      DWORD [in]: headroom amount.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::SetHrtfHeadroom"

HRESULT
CMcpxAPU::SetHrtfHeadroom
(
    DWORD                   dwHeadroom
)
{
    DPF_ENTER();
    AutoIrql();

    MCPX_CHECK_VOICE_FIFO(1);
    MCPX_VOICE_WRITE(SetHRTFHeadroom, MCPX_MAKE_REG_VALUE(dwHeadroom, NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT));

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetMixBinHeadroom
 *
 *  Description:
 *      Sets the headroom for one or more mixbins.
 *
 *  Arguments:
 *      DWORD [in]: mixbin.
 *      DWORD [in]: headroom amount.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::SetMixBinHeadroom"

HRESULT
CMcpxAPU::SetMixBinHeadroom
(
    DWORD                   dwMixBin
)
{
    DPF_ENTER();
    AutoIrql();

    MCPX_CHECK_VOICE_FIFO(1);
    MCPX_VOICE_WRITE(SetSubMixHeadroom[dwMixBin], MCPX_MAKE_REG_VALUE(m_pSettings->m_abMixBinHeadroom[dwMixBin], NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT));

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Handles speaker configuration changes.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPU::SetSpeakerConfig"

HRESULT
CMcpxAPU::SetSpeakerConfig
(
    void
)
{
    HRESULT                 hr          = DS_OK;
    DSFX_CROSSTALK_STATE    Crosstalk;
    
    DPF_ENTER();

    //
    // If the headphone bit is set, disable the crosstalk effect
    //

    if(DSFX_IMAGELOC_UNUSED != m_pSettings->m_EffectLocations.dwCrosstalkIndex)
    {
        hr = GetEffectData(m_pSettings->m_EffectLocations.dwCrosstalkIndex, 0, &Crosstalk, sizeof(Crosstalk));

        if(SUCCEEDED(hr))
        {
            if(m_pSettings->m_dwSpeakerConfig & DSSPEAKER_ENABLE_HEADPHONES)
            {
                Crosstalk.dwFlags &= ~DSFX_STATE_GLOBAL;
            }
            else
            {
                Crosstalk.dwFlags |= DSFX_STATE_GLOBAL;
            }

            hr = SetEffectData(m_pSettings->m_EffectLocations.dwCrosstalkIndex, 0, &Crosstalk, sizeof(Crosstalk), DSFX_IMMEDIATE);
        }
    }

    //
    // Update the 3D listener's surround flag.  We're relying on te caller
    // to trigger the recalc of the listener and all 3D sources.
    //

    if(SUCCEEDED(hr))
    {
        if(DSSPEAKER_IS_HEADPHONES(m_pSettings->m_dwSpeakerConfig))
        {
            m_fSurround = FALSE;
        }
        else
        {
            m_fSurround = DSSPEAKER_IS_SURROUND(m_pSettings->m_dwSpeakerConfig);
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}

#endif // MCPX_BOOT_LIB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpstrm.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpxstrm.cpp
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#include "dsoundi.h"


/****************************************************************************
 *
 *  CMcpxStream
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CMcpxAPU * [in]: pointer back to the APU object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::CMcpxStream"

CMcpxStream::CMcpxStream
(
    CMcpxAPU *                      pMcpxApu,
    CDirectSoundStreamSettings *    pSettings
)
:   CMcpxVoiceClient(pMcpxApu, pSettings)
{
    DWORD                   i;
    
    DPF_ENTER();

    m_pSettings = ADDREF(pSettings);

    InitializeListHead(&m_lstAvailable);
    InitializeListHead(&m_lstPending);
    InitializeListHead(&m_lstCompleted);

    for(i = 0; i < NUMELMS(m_aSslDesc); i++)
    {
        InitializeListHead(&m_aSslDesc[i].lstPackets);
    }

    //
    // Initialize deferred command structures
    //

    for(i = 0; i < NUMELMS(m_aDeferredCommands); i++)
    {
        InitializeListHead(&m_aDeferredCommands[i].leListEntry);
        
        m_aDeferredCommands[i].pVoice = this;
        m_aDeferredCommands[i].dwCommand = i;
    }

    m_aDeferredCommands[MCPX_DEFERREDCMD_STREAM_CHECKSTUCK].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;
    m_aDeferredCommands[MCPX_DEFERREDCMD_STREAM_RELEASERESOURCES].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY;
    m_aDeferredCommands[MCPX_DEFERREDCMD_STREAM_COMPLETEPACKETS].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;
    m_aDeferredCommands[MCPX_DEFERREDCMD_STREAM_FLUSH].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;

    //
    // Set the PERSIST bit in the voice status so we'll only be removed from
    // the voice list when we explicitly stop.  This helps us recover from
    // starvation.
    //

    or(&m_dwStatus, MCPX_VOICESTATUS_PERSIST);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxStream
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::~CMcpxStream"

CMcpxStream::~CMcpxStream
(
    void
)
{
    DWORD                   i;
    
    DPF_ENTER();

    //
    // Make sure all deferred commands are dequeued
    //

    for(i = 0; i < NUMELMS(m_aDeferredCommands); i++)
    {
        RemoveDeferredCommand(i);
    }

    //
    // Flush the stream
    //

    Flush();

    //
    // Release hardware resources
    //

    ReleaseStreamResources();

    //
    // Release the settings object
    //
    
    RELEASE(m_pSettings);

    //
    // Free memory
    //

    MEMFREE(m_paPacketContexts);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      CDirectSoundStreamSettings * [in]: shared stream settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::Initialize"

HRESULT
CMcpxStream::Initialize
(
    void
)
{
    HRESULT                         hr;
    DWORD                           i;
    
    DPF_ENTER();

    //
    // Call the base class
    //

    hr = CMcpxVoiceClient::Initialize(TRUE);

    //
    // Allocate a fixed amount of context packets
    //

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_paPacketContexts = MEMALLOC(MCPX_PACKET_CONTEXT, m_pSettings->m_dwMaxAttachedPackets));
    }

    //
    // Initialize context lists used to track submitted XMEDIABUFFERS
    //

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < m_pSettings->m_dwMaxAttachedPackets; i++) 
        {
            InsertTailListUninit(&m_lstAvailable, &m_paPacketContexts[i].leListEntry);
        }
    }

    //
    // If the stream was created without LOCDEFER, allocate voice resources now
    //

    if(SUCCEEDED(hr) && !(m_pSettings->m_dwFlags & DSSTREAMCAPS_LOCDEFER))
    {
        hr = AllocateStreamResources();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the voice format.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::SetFormat"

HRESULT 
CMcpxStream::SetFormat
(
    void
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Hand off to the base class
    //

    hr = CMcpxVoiceClient::SetFormat();

    //
    // Setup PRD control
    //

    if(SUCCEEDED(hr))
    {
        switch(m_pSettings->m_fmt.wFormatTag)
        {
            case WAVE_FORMAT_PCM:
                switch(m_pSettings->m_fmt.wBitsPerSample)
                {
                    case 8:
                        m_dwPrdControl = MCPX_SET_REG_VALUE(m_dwPrdControl, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B8, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE);
                        break;

                    case 16:
                        m_dwPrdControl = MCPX_SET_REG_VALUE(m_dwPrdControl, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B16, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE);
                        break;

                    case 32: 
                        m_dwPrdControl = MCPX_SET_REG_VALUE(m_dwPrdControl, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B32, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE);
                        break;

                    default:
                        ASSERTMSG("Unexpected sample container size");
                        break;
                }

                break;

            case WAVE_FORMAT_XBOX_ADPCM:
                m_dwPrdControl = MCPX_SET_REG_VALUE(m_dwPrdControl, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE);
                break;

            default:
                ASSERTMSG("Unexpected format tag");
                break;
        }

        m_dwPrdControl = MCPX_SET_REG_VALUE(m_dwPrdControl, m_pSettings->m_fmt.nChannels - 1, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_SAMPLES_PER_BLOCK);

        if(m_pSettings->m_fmt.nChannels > 1)
        {
            m_dwPrdControl = MCPX_SET_REG_VALUE(m_dwPrdControl, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO_OK, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO);
        }
        else
        {
            m_dwPrdControl = MCPX_SET_REG_VALUE(m_dwPrdControl, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO_NOTOK, NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SubmitPacket
 *
 *  Description:
 *      Submits a packet to the stream.
 *
 *  Arguments:
 *      REFXMEDIAPACKET [in]: packet description.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::SubmitPacket"

HRESULT
CMcpxStream::SubmitPacket
(
    REFXMEDIAPACKET         Packet
)
{

#ifdef DEBUG

    DWORD                   dwContiguousLength;

#endif // DEBUG

    PMCPX_PACKET_CONTEXT    pPacketContext;
    PLIST_ENTRY             pleEntry;
    CIrql                   irql;
    HRESULT                 hr;

    DPF_ENTER();

    //
    // Set the packet's initial state
    //
    
    XMOAcceptPacket(&Packet);

    //
    // If a discontinuity was signaled, but another packet was attached
    // before resources were freed, undo the discontinuity
    //

    and(&m_dwStatus, ~MCPX_VOICESTATUS_DISCONTINUITY);

    RemoveDeferredCommand(MCPX_DEFERREDCMD_STREAM_FLUSH);
    RemoveDeferredCommand(MCPX_DEFERREDCMD_STREAM_RELEASERESOURCES);

    //
    // Make sure resources are allocated
    //
    
    hr = AllocateStreamResources();

    //
    // Get a packet context to track this stream packet
    //

    if(SUCCEEDED(hr))
    {
        irql.Raise();
        
        ASSERT(!IsListEmpty(&m_lstAvailable));
        
        pleEntry = RemoveHeadList(&m_lstAvailable);
        pPacketContext = CONTAINING_RECORD(pleEntry, MCPX_PACKET_CONTEXT, leListEntry);

        irql.Lower();

        pPacketContext->xmpPacket = Packet;
        pPacketContext->dwCompletedSize = 0;
        pPacketContext->dwStatus = XMEDIAPACKET_STATUS_PENDING;
        
        DPF_BLAB("Received packet %x, buffer %x, size %lu", pPacketContext, pPacketContext->xmpPacket.pvBuffer, pPacketContext->xmpPacket.dwMaxSize);
    }

    //
    // Lock the packet memory
    //

    if(SUCCEEDED(hr))
    {
        MmLockUnlockBufferPages(pPacketContext->xmpPacket.pvBuffer, pPacketContext->xmpPacket.dwMaxSize, FALSE);
    }

#ifdef DEBUG

    //
    // ADPCM streams require phsycally contiguous memory
    //

    if(SUCCEEDED(hr) && (WAVE_FORMAT_XBOX_ADPCM == m_pSettings->m_fmt.wFormatTag))
    {
        m_pMcpxApu->GetPhysicalMemoryProperties(pPacketContext->xmpPacket.pvBuffer, pPacketContext->xmpPacket.dwMaxSize, NULL, &dwContiguousLength);

        if(dwContiguousLength != pPacketContext->xmpPacket.dwMaxSize)
        {
            ASSERT(dwContiguousLength < pPacketContext->xmpPacket.dwMaxSize);
            DPF_ERROR("ADPCM stream packet data must be allocated using XPhysicalAlloc.  Using any other allocator will cause unexpected results.");
        }
    }

#endif // DEBUG

    //
    // Add the packet to the pending queue
    //

    if(SUCCEEDED(hr))
    {
        irql.Raise();

        InsertTailList(&m_lstPending, &pPacketContext->leListEntry);

        irql.Lower();
    }

    //
    // Queue up as many packets as we can
    //

    if(SUCCEEDED(hr))
    {
        Process();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Discontinuity
 *
 *  Description:
 *      Signals that no more audio data is available.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::Discontinuity"

HRESULT 
CMcpxStream::Discontinuity
(
    void
)
{
    DPF_ENTER();

    //
    // The caller has no more data to supply
    //

    if(HasPendingData())
    {
        or(&m_dwStatus, MCPX_VOICESTATUS_DISCONTINUITY);
    }
    else
    {
        Flush();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Pause
 *
 *  Description:
 *      Pauses or resumes a stream.
 *
 *  Arguments:
 *      DWORD [in]: pause state.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::Pause"

HRESULT
CMcpxStream::Pause
(
    DWORD                   dwPause
)
{
    DPF_ENTER();
    AutoIrql();

    if(DSSTREAMPAUSE_PAUSE == dwPause)
    {
        PauseVoice(m_dwStatus | MCPX_VOICESTATUS_PAUSED);
    }
    else if(DSSTREAMPAUSE_RESUME == dwPause)
    {
        PauseVoice(m_dwStatus & ~MCPX_VOICESTATUS_PAUSED);
    }
    else
    {
        ASSERTMSG("Invalid pause state");
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Pause
 *
 *  Description:
 *      Pauses or resumes a stream.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: timestamp.
 *      DWORD [in]: pause state.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::Pause"

HRESULT
CMcpxStream::Pause
(
    REFERENCE_TIME          rtTimeStamp,
    DWORD                   dwPause
)
{
    BOOL                    fDeferred   = FALSE;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    if(rtTimeStamp)
    {
        fDeferred = ScheduleDeferredCommand(MCPX_DEFERREDCMD_STREAM_PAUSE, rtTimeStamp, dwPause);
    }

    if(!fDeferred)
    {
        hr = Pause(dwPause);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Pauses a playing buffer.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: time to stop.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::Stop"

HRESULT
CMcpxStream::Stop
(
    REFERENCE_TIME          rtTimeStamp,
    DWORD                   dwFlags
)
{
    BOOL                    fDeferred   = FALSE;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    if(rtTimeStamp)
    {
        fDeferred = ScheduleDeferredCommand(MCPX_DEFERREDCMD_STREAM_STOP, rtTimeStamp, dwFlags);
    }

    if(!fDeferred)
    {
        hr = Stop(dwFlags);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops the stream and readies it to be flushed.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::Stop"

HRESULT 
CMcpxStream::Stop
(
    DWORD                   dwFlags
)
{
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(dwFlags & DSSTREAMFLUSHEX_ASYNC);

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        //
        // Cancel all outstanding deferred commands
        //

        for(i = 0; i < MCPX_DEFERREDCMD_STREAM_COUNT; i++)
        {
            RemoveDeferredCommand(i);
        }

        //
        // Deactivate or release the voice
        //

        if(dwFlags & DSSTREAMFLUSHEX_ENVELOPE)
        {
            ReleaseVoice();
        }
        else
        {
            DeactivateVoice();
        }

        //
        // Schedule a deferred flush for when the voice is actually stopped
        //

        ScheduleDeferredCommand(MCPX_DEFERREDCMD_STREAM_FLUSH, 0, 0);
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Revokes all submitted packets.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::Flush"

HRESULT 
CMcpxStream::Flush
(
    void
)
{
    const KIRQL             CurrentIrql = KeGetCurrentIrql();
    CIrql                   irql;
    DWORD                   i;
    
    DPF_ENTER();

    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        //
        // Raise IRQL for synchronization with the voice interrupt handler
        //
    
        irql.Raise();
    
        //
        // Cancel any outstanding deferred commands
        //

        for(i = 0; i < MCPX_DEFERREDCMD_STREAM_COUNT; i++)
        {
            RemoveDeferredCommand(i);
        }

        //
        // Deactivate the voice
        //

        DeactivateVoice();

        //
        // Lower IRQL to allow the interrupt handler to run
        //

        irql.Lower();

        //
        // Busy-wait until the voice is really idle
        //

        WaitForVoiceOff();

        //
        // Clear the SSLs
        //

        for(i = 0; i < NUMELMS(m_aSslDesc); i++)
        {
            CompleteSsl(i, XMEDIAPACKET_STATUS_FLUSHED);
        }

        ASSERT(!m_dwMappedSslCount);
        m_dwFirstMappedSslIndex = 0;

        //
        // Complete any pending packets
        //

        CompletePackets(&m_lstPending, XMEDIAPACKET_STATUS_FLUSHED);

        //
        // If we're LOCDEFER, free stream resources
        //

        if(m_pSettings->m_dwFlags & DSSTREAMCAPS_LOCDEFER)
        {
            if(PASSIVE_LEVEL == CurrentIrql)
            {
                ReleaseStreamResources();
            }
            else
            {
                ScheduleDeferredCommand(MCPX_DEFERREDCMD_STREAM_RELEASERESOURCES, 0, 0);
            }
        }

        //
        // Clear the deferred completion list
        //
        
        if(PASSIVE_LEVEL == CurrentIrql)
        {
            CompleteDeferredPackets();
        }
        else
        {
            ScheduleDeferredCommand(MCPX_DEFERREDCMD_STREAM_COMPLETEPACKETS, 0, 0);
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets the status of the stream.
 *
 *  Arguments:
 *      LPDWORD [out]: stream status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::GetStatus"

HRESULT
CMcpxStream::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    DPF_ENTER();
    AutoIrql();

    *pdwStatus = 0;

    if(!IsListEmpty(&m_lstAvailable))
    {
        *pdwStatus |= DSSTREAMSTATUS_READY;
    }

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        if(m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK)
        {
            *pdwStatus |= DSSTREAMSTATUS_PAUSED;

            if(m_dwStatus & MCPX_VOICESTATUS_STARVED)
            {
                *pdwStatus |= DSSTREAMSTATUS_STARVED;
            }
        }
        else
        {
            *pdwStatus |= DSSTREAMSTATUS_PLAYING;
        }
    }
    else if((m_dwStatus & MCPX_VOICESTATUS_VOICEOFFMASK) == MCPX_VOICESTATUS_VOICEOFFMASK)
    {
        *pdwStatus |= DSSTREAMSTATUS_PLAYING;
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  OnEndOfStream
 *
 *  Description:
 *      Handles the voice deactivation notifier.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::OnEndOfStream"

void
CMcpxStream::OnEndOfStream
(
    void
)
{

#ifdef DEBUG

    DWORD                   i;

#endif // DEBUG

    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK);

    //
    // Stop the voice
    //

    DeactivateVoice();

#ifdef DEBUG

    //
    // Assert that all packets have been completed
    //

    for(i = 0; i < NUMELMS(m_aSslDesc); i++)
    {
        ASSERT(IsListEmpty(&m_aSslDesc[i].lstPackets));
    }

    ASSERT(IsListEmpty(&m_lstPending));

#endif // DEBUG

    //
    // Reset the SSL indeces
    //

    ASSERT(!m_dwMappedSslCount);
    m_dwFirstMappedSslIndex = 0;

    //
    // If we're LOCDEFER, schedule a deferred command to release voice
    // resources
    //

    if(m_pSettings->m_dwFlags & DSSTREAMCAPS_LOCDEFER)
    {
        ScheduleDeferredCommand(MCPX_DEFERREDCMD_STREAM_RELEASERESOURCES, 0, 0);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  OnDeferredFlush
 *
 *  Description:
 *      Handles the deferred flush command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::OnDeferredFlush"

void
CMcpxStream::OnDeferredFlush
(
    void
)
{
    DPF_ENTER();

    ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);

    //
    // Check the voice status.  If we're still waiting for the VoiceOff, don't
    // do the flush yet.
    //

    if(m_dwStatus & MCPX_VOICESTATUS_ACTIVEORVOICEOFF)
    {
        DPF_BLAB("Voice %x (%x) not stopped yet", this, m_ahVoices[0]);
    }
    else
    {
        Flush();
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Updates the stream by completing and remapping SSLs.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: MCPX_STREAM_PROCESS code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::Process"

DWORD
CMcpxStream::Process
(
    void
)
{
    DWORD                   dwStatus        = 0;
    BOOL                    fContinue       = TRUE;
    DWORD                   dwSslIndex;
    DWORD                   dwSslCount;

    DPF_ENTER();
    AutoIrql();

    while(fContinue)
    {
        //
        // Check for completed SSLs, starting with the oldest one first
        //

        dwSslIndex = m_dwFirstMappedSslIndex;
    
        for(dwSslCount = 0; dwSslCount < NUMELMS(m_aSslDesc); dwSslCount++)
        {
            if(m_Notifier.GetStatus(dwSslIndex))
            {
                CompleteSsl(dwSslIndex, XMEDIAPACKET_STATUS_SUCCESS);

                dwStatus |= MCPX_STREAM_PROCESS_COMPLETEDSSL;
            }
            else
            {
                break;
            }

            dwSslIndex = (dwSslIndex + 1) % NUMELMS(m_aSslDesc);
        }

        //
        // Fill SSLs, starting with the first empty one
        //

        dwSslIndex = (m_dwFirstMappedSslIndex + m_dwMappedSslCount) % NUMELMS(m_aSslDesc);
    
        for(dwSslCount = 0; dwSslCount < NUMELMS(m_aSslDesc); dwSslCount++)
        {
            if(MapPackets(dwSslIndex))
            {
                dwStatus |= MCPX_STREAM_PROCESS_MAPPEDDATA;
            }
            else
            {
                fContinue = FALSE;
                break;
            }

            dwSslIndex = (dwSslIndex + 1) % NUMELMS(m_aSslDesc);
        }
    }

    //
    // If we're providing accurate callbacks, flush the deferred completion 
    // list
    //

    if(m_pSettings->m_dwFlags & DSSTREAMCAPS_ACCURATENOTIFY)
    {
        CompleteDeferredPackets();
    }

    DPF_LEAVE(dwStatus);

    return dwStatus;
}


/****************************************************************************
 *
 *  MapPackets
 *
 *  Description:
 *      Maps packets into the given SSL.
 *
 *  Arguments:
 *      DWORD [in]: SSL index.
 *
 *  Returns:  
 *      BOOL: TRUE if any packets were mapped.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::MapPackets"

BOOL
CMcpxStream::MapPackets
(
    DWORD                   dwSslIndex
)
{
    BOOL                    fMapped         = FALSE;
    PMCPX_PACKET_CONTEXT    pPacketContext;
    DWORD                   dwBytesMapped;
    
    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Map as many packets as we can into this SSL.  If the user asked
    // for accurate packet completions, we'll only map one packet per
    // SSL.  Mapping any more would cause multiple packets to complete
    // at the same time.
    //

    if(!m_aSslDesc[dwSslIndex].dwPrdCount)
    {
        while(m_aSslDesc[dwSslIndex].dwPrdCount < MCPX_HW_MAX_PRD_ENTRIES_PER_SSL)
        {
            if(IsListEmpty(&m_lstPending))
            {
                break;
            }

            //
            // Get the next packet from the list
            //

            pPacketContext = CONTAINING_RECORD(m_lstPending.Flink, MCPX_PACKET_CONTEXT, leListEntry);

            //
            // Map the packet into the SSL
            //

            if(dwBytesMapped = MapPacket(dwSslIndex, pPacketContext))
            {
                DPF_BLAB("Mapped %lu bytes into SSL%c (%lu total)", dwBytesMapped, 'A' + dwSslIndex, m_aSslDesc[dwSslIndex].dwBytesMapped);
                fMapped = TRUE;
            }
            else
            {
                break;
            }

            //
            // Are we allowed to map more packets?
            //

            if(m_pSettings->m_dwFlags & DSSTREAMCAPS_ACCURATENOTIFY)
            {
                break;
            }
        }

        //
        // Commit the SSL to the hardware.  If we didn't map any packets into 
        // this SSL, we can stop processing.
        //

        if(fMapped)
        {
            CommitSsl(dwSslIndex);
        }
    }

    DPF_LEAVE(fMapped);

    return fMapped;
}


/****************************************************************************
 *
 *  MapPacket
 *
 *  Description:
 *      Maps a packet into an SSL.
 *
 *  Arguments:
 *      DWORD [in]: SSL index.
 *      PMCPX_PACKET_CONTEXT [in]: packet data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::MapPacket"

DWORD
CMcpxStream::MapPacket
(
    DWORD                   dwSslIndex,
    PMCPX_PACKET_CONTEXT    pPacketContext
)
{
    DWORD                   dwBytesMapped       = 0;
    LPBYTE                  pbPacketData;
    DWORD                   dwPacketSize;
    PMCPX_SSL_DESC          pSsl;
    DWORD                   dwMaxPrdSize;
    DWORD                   dwContiguousLength;
    DWORD                   dwSampleCount;
    DWORD                   dwAddress;
    DWORD                   dwBase;
    DWORD                   dwBasePage;
    DWORD                   dwIndex;
    DWORD                   dwLengthAndControl;
    DWORD                   dwIncrement;
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(dwSslIndex < NUMELMS(m_aSslDesc));

    pSsl = &m_aSslDesc[dwSslIndex];

    //
    // Save a local pointer to the packet data.  If we've already mapped part
    // of this packet into another SSL, the dwCompletedSize member will be 
    // non-zero.
    //
    
    pbPacketData = (LPBYTE)pPacketContext->xmpPacket.pvBuffer;
    dwPacketSize = pPacketContext->xmpPacket.dwMaxSize;

    if(pPacketContext->dwCompletedSize)
    {
        ASSERT(pPacketContext->dwCompletedSize < dwPacketSize);

        pbPacketData += pPacketContext->dwCompletedSize;
        dwPacketSize -= pPacketContext->dwCompletedSize;

        DPF_BLAB("Working packet offset %lu", pPacketContext->dwCompletedSize);
    }
    else
    {
        DPF_BLAB("Mapping new packet");
    }

    //
    // PRDs can only contain 16-bit addresses
    //

    dwMaxPrdSize = SamplesToBytes(0xFFFF);

    //
    // Map as much of the packet as we can into the SSL
    //

    while((dwBytesMapped < dwPacketSize) && (pSsl->dwPrdCount < MCPX_HW_MAX_PRD_ENTRIES_PER_SSL))
    {
        //
        // Get physical memory properties of the packet data
        //
        
        dwAddress = m_pMcpxApu->GetPhysicalMemoryProperties(pbPacketData + dwBytesMapped, min(dwPacketSize - dwBytesMapped, dwMaxPrdSize), NULL, &dwContiguousLength);

        //
        // Convert packet length to samples
        //

        dwSampleCount = BytesToSamples(dwContiguousLength);
        ASSERT(!(dwSampleCount & ~0xFFFF));

        //
        // ... and back to bytes
        //

        dwContiguousLength = SamplesToBytes(dwSampleCount);

        //
        // If there's not at least one full block to write, we can't do
        // any more.
        //

        if(!dwSampleCount)
        {
            DPF_ERROR("Unable to map the next packet because it doesn't contain a full block of contiguous data");
            break;
        }

        //
        // If we ever support multiple mono voices (i.e. an n-channel voice uses
        // n mono hardware voices instead of n/2 stereo), the increment value 
        // should be halved.
        //

        dwIncrement = m_pSettings->m_fmt.wBitsPerSample * 2 / 8;

        //
        // Fill in PRD values
        //

        MCPX_CHECK_VOICE_FIFO(3 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            dwBase = GetSslBase(i, dwSslIndex) + pSsl->dwPrdCount;
            dwBasePage = dwBase / NUMELMS(((LPMCPXVPREGSET)NULL)->SetSSLSegment);
            dwIndex = dwBase % NUMELMS(((LPMCPXVPREGSET)NULL)->SetSSLSegment);
            dwLengthAndControl = (m_dwPrdControl & 0xFFFF0000) | dwSampleCount;

            MCPX_VOICE_WRITE(SetCurrentSSL, MCPX_MAKE_REG_VALUE(dwBasePage, NV1BA0_PIO_SET_CURRENT_SSL_BASE_PAGE));
            MCPX_VOICE_WRITE(SetSSLSegment[dwIndex].Offset, dwAddress);
            MCPX_VOICE_WRITE(SetSSLSegment[dwIndex].Length, dwLengthAndControl);

            dwAddress += dwIncrement;
        }

        //
        // Increment the count of bytes we've mapped
        //
        
        dwBytesMapped += dwContiguousLength;

        pSsl->dwBytesMapped += dwContiguousLength;

        //
        // Increment the count of PRDs used in this SSL
        //
        
        pSsl->dwPrdCount++;
    }

    //
    // If we managed to map the whole packet into the SSL, remove it from
    // the pending list and add it to the SSL's list.  If not, leave it
    // in the pending list, but set the completed size so we'll know where
    // to start working next time.
    //

    if(dwBytesMapped >= dwPacketSize)
    {
        MoveEntryTailList(&pSsl->lstPackets, &pPacketContext->leListEntry);
    }
    else
    {
        pPacketContext->dwCompletedSize += dwBytesMapped;
    }

    DPF_LEAVE(dwBytesMapped);

    return dwBytesMapped;
}


/****************************************************************************
 *
 *  CommitSsl
 *
 *  Description:
 *      Commits an SSL to the hardware.
 *
 *  Arguments:
 *      DWORD [in]: SSL index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::CommitSsl"

void
CMcpxStream::CommitSsl
(
    DWORD                   dwSslIndex
)
{
    DWORD                   dwSslBase;
    DWORD                   dwSslBaseAndCount;
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(dwSslIndex < NUMELMS(m_aSslDesc));

    DPF_BLAB("Commiting SSL%c", 'A' + dwSslIndex);

    //
    // Assign the SSL to the voice
    //

    MCPX_CHECK_VOICE_FIFO(2 * m_bVoiceCount);
    
    for(i = 0; i < m_bVoiceCount; i++)
    {
        dwSslBase = GetSslBase(i, dwSslIndex);
        
        dwSslBaseAndCount = MCPX_MAKE_REG_VALUE(dwSslBase, NV1BA0_PIO_SET_VOICE_SSL_A_BASE);
        dwSslBaseAndCount |= MCPX_MAKE_REG_VALUE(m_aSslDesc[dwSslIndex].dwPrdCount, NV1BA0_PIO_SET_VOICE_SSL_A_COUNT);
        
        MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
        
        if(!dwSslIndex)
        {
            MCPX_VOICE_WRITE(SetVoiceSSLA, dwSslBaseAndCount);
        }
        else
        {
            MCPX_VOICE_WRITE(SetVoiceSSLB, dwSslBaseAndCount);
        }
    }

    //
    // Reset the notifier
    //

    m_Notifier.SetStatus(dwSslIndex, FALSE);

    //
    // Increment the count of mapped SSLs
    //

    ASSERT(m_dwMappedSslCount < NUMELMS(m_aSslDesc));

    if(!m_dwMappedSslCount++)
    {
        m_dwFirstMappedSslIndex = dwSslIndex;
    }

    //
    // If we're not providing high-accuracy packet completions, register for
    // deferred completion callbacks.
    //

    if(!(m_pSettings->m_dwFlags & DSSTREAMCAPS_ACCURATENOTIFY))
    {
        ScheduleDeferredCommand(MCPX_DEFERREDCMD_STREAM_COMPLETEPACKETS, 0, 0);
    }

    //
    // Activate the voice
    //

    ActivateVoice();

    //
    // If the voice is starved, unstarve it
    //

    PauseVoice(m_dwStatus & ~MCPX_VOICESTATUS_STARVED);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceVoiceInterrupt
 *
 *  Description:
 *      DPC callback function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::ServiceVoiceInterrupt"

BOOL
CMcpxStream::ServiceVoiceInterrupt
(
    void
)
{
    DWORD                   dwStatus;
    DWORD                   dwSslIndex;
    DWORD                   dwSslCount;
    DWORD                   i;

    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
    
    //
    // The first thing to check is whether the voice is still active or 
    // not.  If we reached the end of the release envelope, the voice will
    // automatically be removed from the voice list.  This should only
    // happen when NoteOff has been called, but may occur either because
    // the envelope ended or because the stream was starved after the 
    // NoteOff was received.  Because we remove the PERSIST bit from the
    // voice format when NoteOff is called, the hardware is free to idle
    // the voice whenever it wants to.  We have no way of knowing why the
    // voice idled, so we just don't worry about it.
    //

    if(m_Notifier.GetStatus(MCPX_NOTIFIER_VOICE_OFF))
    {
        ASSERT(MCPX_VOICELIST_INVALID == m_bVoiceList);
        
        DPF_INFO("Stream completed naturally");

        //
        // Reset the notifier
        //

        m_Notifier.SetStatus(MCPX_NOTIFIER_VOICE_OFF, FALSE);

        //
        // Flush the stream
        //

        Flush();
    }
    else if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        ASSERT(m_bVoiceList < MCPX_VOICELIST_COUNT);

        //
        // An interrupt triggered for voice end or notifier written.  If either
        // of our SSL completion notifiers are set, map some more packets into
        // them.  Note that we're not resetting the notifier status in this
        // function.  We're doing it in Process instead.
        //

        dwStatus = Process();

        //
        // If we handled the interrupt, but no more packets were available
        // to be mapped into an SSL, the stream has been starved by the 
        // user.  If DISCONTINUITY is set in the status, we can flush the
        // stream now.  If not, the voice should be stopped until more 
        // packets arrive.  If we allow the voice to remain active, the 
        // hardware generates an SSL completion interrupt every frame.
        //

        if(((dwStatus & MCPX_STREAM_PROCESS_MASK) == MCPX_STREAM_PROCESS_COMPLETEDSSL) && !m_dwMappedSslCount)
        {
            if(m_dwStatus & MCPX_VOICESTATUS_DISCONTINUITY)
            {
                DPF_INFO("End-of-stream reached");
                OnEndOfStream();
            }
            else if(!(m_dwStatus & MCPX_VOICESTATUS_STARVED))
            {
                DPF_WARNING("The stream is starving");
                PauseVoice(MCPX_VOICESTATUS_STARVED);
            }
        }
    }

    DPF_LEAVE(TRUE);

    return TRUE;
}


/****************************************************************************
 *
 *  CompleteSsl
 *
 *  Description:
 *      Called to handle an SSL completion.
 *
 *  Arguments:
 *      DWORD [in]: SSL index.
 *      DWORD [in]: packet status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::CompleteSsl"

void
CMcpxStream::CompleteSsl
(
    DWORD                   dwSslIndex,
    DWORD                   dwStatus
)
{
    DWORD                   dwSslBase;
    DWORD                   dwSslBaseAndCount;
    DWORD                   i;

    DPF_ENTER();
    AutoIrql();

    ASSERT(dwSslIndex < NUMELMS(m_aSslDesc));

    if(m_aSslDesc[dwSslIndex].dwPrdCount)
    {
        DPF_BLAB("Completing SSL%c", 'A' + dwSslIndex);

        //
        // Reset hardware SSL
        //

        MCPX_CHECK_VOICE_FIFO(2 * m_bVoiceCount);
    
        for(i = 0; i < m_bVoiceCount; i++)
        {
            dwSslBase = GetSslBase(i, dwSslIndex);
        
            dwSslBaseAndCount = MCPX_MAKE_REG_VALUE(dwSslBase, NV1BA0_PIO_SET_VOICE_SSL_A_BASE);
        
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

            if(!dwSslIndex)
            {
                MCPX_VOICE_WRITE(SetVoiceSSLA, dwSslBaseAndCount);
            }
            else
            {
                MCPX_VOICE_WRITE(SetVoiceSSLB, dwSslBaseAndCount);
            }
        }

        //
        // Complete all the packets mapped into the SSL
        //

        CompletePackets(&m_aSslDesc[dwSslIndex].lstPackets, dwStatus);

        //
        // Reset the SSL data
        //

        m_aSslDesc[dwSslIndex].dwPrdCount = 0;
        m_aSslDesc[dwSslIndex].dwBytesMapped = 0;

        //
        // Decrement the count of mapped SSLs
        //

        ASSERT(m_dwMappedSslCount);
        m_dwMappedSslCount--;

        m_dwFirstMappedSslIndex = (m_dwFirstMappedSslIndex + 1) % NUMELMS(m_aSslDesc);
    }
    else
    {
        ASSERT(IsListEmpty(&m_aSslDesc[dwSslIndex].lstPackets));
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CompletePackets
 *
 *  Description:
 *      Releases packets.
 *
 *  Arguments:
 *      PLIST_ENTRY [in]: packet list entry.
 *      DWORD [in]: packet completion status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::CompletePackets"

void
CMcpxStream::CompletePackets
(
    PLIST_ENTRY             pListHead,
    DWORD                   dwStatus
)
{
    PLIST_ENTRY             pleEntry;
    CIrql                   irql;

    DPF_ENTER();

    //
    // Only complete the packets if it's the deferred list.  For everything
    // else, add the packets to the deferred completion list.
    //

    if(&m_lstCompleted == pListHead)
    {
        irql.Raise();
        
        while((pleEntry = MoveHeadTailList(&m_lstAvailable, pListHead)) != pListHead)
        {
            irql.Lower();

            CompletePacket(CONTAINING_RECORD(pleEntry, MCPX_PACKET_CONTEXT, leListEntry), dwStatus);

            irql.Raise();
        }

        irql.Lower();
    }
    else
    {
        irql.Raise();
        
        while((pleEntry = MoveHeadTailList(&m_lstCompleted, pListHead)) != pListHead)
        {
            CONTAINING_RECORD(pleEntry, MCPX_PACKET_CONTEXT, leListEntry)->dwStatus = dwStatus;

            DPF_BLAB("Packet %x scheduled for deferred completion with status %lu", pleEntry, dwStatus);
        }

        irql.Lower();
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CompletePacket
 *
 *  Description:
 *      Releases a packet.
 *
 *  Arguments:
 *      PMCPX_PACKET_CONTEXT [in]: packet context.
 *      DWORD [in]: packet completion status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::CompletePacket"

void
CMcpxStream::CompletePacket
(
    PMCPX_PACKET_CONTEXT    pPacketContext,
    DWORD                   dwStatus
)
{
    DPF_ENTER();

    //
    // If the packet has a status value other than PENDING stored in it's
    // context, we'll use that instead of the status value passed in.
    //

    if(XMEDIAPACKET_STATUS_PENDING != pPacketContext->dwStatus)
    {
        dwStatus = pPacketContext->dwStatus;
    }

    ASSERT(XMEDIAPACKET_STATUS_PENDING != dwStatus);

    DPF_BLAB("Completing packet %x with status %lu", pPacketContext, dwStatus);

    //
    // Unlock buffer pages
    //

    MmLockUnlockBufferPages(pPacketContext->xmpPacket.pvBuffer, pPacketContext->xmpPacket.dwMaxSize, TRUE);

    //
    // Now call them back so there is at least one available context
    // if they turn around and call process in their callback
    //

    XMOCompletePacket(&pPacketContext->xmpPacket, pPacketContext->xmpPacket.dwMaxSize, m_pSettings->m_pfnCallback, m_pSettings->m_pvContext, dwStatus);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CompleteDeferredPackets
 *
 *  Description:
 *      Releases packets in the deferred completion list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::CompleteDeferredPackets"

void
CMcpxStream::CompleteDeferredPackets
(
    void
)
{
    DPF_ENTER();

    //
    // If we're not running any more, we can unregister for completion 
    // callbacks
    //

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) != MCPX_VOICESTATUS_ACTIVEMASK)
    {
        RemoveDeferredCommand(MCPX_DEFERREDCMD_STREAM_COMPLETEPACKETS);
    }        

    //
    // Complete all the packets in the deferred completion list
    //
    
    CompletePackets(&m_lstCompleted, XMEDIAPACKET_STATUS_PENDING);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ReleaseStreamResources
 *
 *  Description:
 *      Releases hardware resources for the voice.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::ReleaseStreamResources"

void
CMcpxStream::ReleaseStreamResources
(
    void
)
{
    DWORD                   i;
    
    DPF_ENTER();

    //
    // Make sure the voice is stopped
    //

    DeactivateVoice(TRUE);

    //
    // Unschedule any pending low-priority tasks (including RELEASERESOURCES)
    //

    for(i = 0; i < MCPX_DEFERREDCMD_STREAM_COUNT; i++)
    {
        if(m_aDeferredCommands[i].dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY)
        {
            RemoveDeferredCommand(i);
        }
    }

    //
    // Clear any left-over status bits
    //

    and(&m_dwStatus, MCPX_VOICESTATUS_DEACTIVATEMASK);

    //
    // Release voice resources
    //

    ReleaseVoiceResources();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ScheduleDeferredCommand
 *
 *  Description:
 *      Adds a deferred voice command to the queue.
 *
 *  Arguments:
 *      DWORD [in]: command index.
 *      REFERENCE_TIME [in]: timestamp.
 *      DWORD [in]: context.
 *
 *  Returns:  
 *      BOOL: TRUE if the command was scheduled.  If the timestamp for the
 *            command has already elapsed, it won't be scheduled and should
 *            be processed immediately.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::ScheduleDeferredCommand"

BOOL 
CMcpxStream::ScheduleDeferredCommand
(
    DWORD                   dwCommand, 
    REFERENCE_TIME          rtTimeStamp, 
    DWORD                   dwContext
)
{
    LPMCPX_DEFERRED_COMMAND pCmd        = &m_aDeferredCommands[dwCommand];
    BOOL                    fScheduled;

    DPF_ENTER();
    
    ASSERT(dwCommand < NUMELMS(m_aDeferredCommands));

    pCmd->rtTimestamp = rtTimeStamp;
    pCmd->dwContext = dwContext;

    if(fScheduled = m_pMcpxApu->ScheduleDeferredCommand(pCmd))
    {
        DPF_BLAB("Voice %x (%x) scheduled command %lu", this, m_ahVoices[0], dwCommand);
    }

    DPF_LEAVE(fScheduled);

    return fScheduled;
}


/****************************************************************************
 *
 *  RemoveDeferredCommand
 *
 *  Description:
 *      Removes a deferred voice command from the queue.
 *
 *  Arguments:
 *      DWORD [in]: command index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::RemoveDeferredCommand"

void 
CMcpxStream::RemoveDeferredCommand
(
    DWORD                   dwCommand
)
{
    DPF_ENTER();

    ASSERT(dwCommand < NUMELMS(m_aDeferredCommands));

    if(m_aDeferredCommands[dwCommand].dwFlags & MCPX_DEFERREDCMDF_SCHEDULED)
    {
        DPF_BLAB("Voice %x (%x) unscheduling command %lu", this, m_ahVoices[0], dwCommand);
    }
    
    m_pMcpxApu->RemoveDeferredCommand(&m_aDeferredCommands[dwCommand]);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceDeferredCommand
 *
 *  Description:
 *      Deferred command dispatcher.
 *
 *  Arguments:
 *      DWORD [in]: command identifier.
 *      DWORD [in]: command context.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxStream::ServiceDeferredCommand"

void 
CMcpxStream::ServiceDeferredCommand
(
    DWORD                   dwCommand, 
    DWORD                   dwContext
)
{
    DPF_ENTER();
    
    switch(dwCommand)
    {
        case MCPX_DEFERREDCMD_STREAM_COMPLETEPACKETS:
            CompleteDeferredPackets();
            break;

        case MCPX_DEFERREDCMD_STREAM_RELEASERESOURCES:
            ReleaseStreamResources();
            break;

        case MCPX_DEFERREDCMD_STREAM_FLUSH:
            OnDeferredFlush();
            break;

        case MCPX_DEFERREDCMD_STREAM_STOP:
            Stop(dwContext);
            break;

        case MCPX_DEFERREDCMD_STREAM_PAUSE:
            Pause(dwContext);
            break;

        case MCPX_DEFERREDCMD_STREAM_CHECKSTUCK:
            CheckStuckVoice();
            break;

        default:
            ASSERTMSG("Unexpected deferred command identifier");
            break;
    }

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpbuf.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpbuf.h
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/16/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __MCPBUF_H__
#define __MCPBUF_H__

//
// Deferred buffer commands
//

#define MCPX_DEFERREDCMD_BUFFER_CHECKSTUCK MCPX_DEFERREDCMD_VOICE_CHECKSTUCK

BEGIN_DEFINE_ENUM()
    MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES = MCPX_DEFERREDCMD_VOICE_COUNT,
    MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA,
    MCPX_DEFERREDCMD_BUFFER_PLAY,
    MCPX_DEFERREDCMD_BUFFER_STOP,
    MCPX_DEFERREDCMD_BUFFER_COUNT
END_DEFINE_ENUM_();

#ifdef __cplusplus

//
// Audio buffer implementation
//

namespace DirectSound
{
    class CMcpxBuffer
        : public CMcpxVoiceClient
    {
        friend class CMcpxAPU;
        friend class CMcpxVoiceClient;

    protected:
        CDirectSoundBufferSettings *    m_pSettings;                                        // Shared buffer settings
        LPSGEHEAPRUNMARKER              m_pSgeHeapEntry;                                    // SGE heap allocation
        MCPX_DEFERRED_COMMAND           m_aDeferredCommands[MCPX_DEFERREDCMD_BUFFER_COUNT]; // Deferred command data    
        DWORD                           m_dwCachedPlayCursor;                               // Cached for LOCDEFER
        DWORD                           m_dwLastNotifyPosition;                             // Last signaled notification position
        DWORD                           m_dwNextNotifyIndex;                                // Next notification index to signal
        DWORD                           m_dwBufferBase;                                     // Buffer base address register

    public:
        CMcpxBuffer(CMcpxAPU *pAPU, CDirectSoundBufferSettings *pSettings);
        virtual ~CMcpxBuffer(void);

    public:
        // Initialization
        HRESULT Initialize(void);

        // Buffer state
        HRESULT Play(DWORD dwFlags);
        HRESULT Play(REFERENCE_TIME rtTimeStamp, DWORD dwFlags);
        HRESULT Stop(DWORD dwFlags = 0);
        HRESULT Stop(REFERENCE_TIME rtTimeStamp, DWORD dwFlags = 0);
        HRESULT GetStatus(LPDWORD pdwStatus);

        // Buffer data
        HRESULT SetBufferData(void);
        HRESULT ReleaseBufferData(BOOL fChanging = FALSE);

        // Buffer play and loop regions
        HRESULT SetPlayRegion(void);
        HRESULT SetLoopRegion(void);

        // Buffer position
        HRESULT GetCurrentPosition(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor);
        HRESULT SetCurrentPosition(DWORD dwPlayCursor);

        // Notifications
        HRESULT SetNotificationPositions(void);

    protected:
        // Hardware voice resources
        HRESULT AllocateBufferResources(void);
        void ReleaseBufferResources(void);

        // Buffer state
        void PlayFromCurrent(DWORD dwFlags);
        void PlayFromPosition(DWORD dwPosition, DWORD dwFlags);
    
        // Buffer data
        HRESULT MapInputBuffer(void);
        void MapEffectsBuffer(void);
        void MapBuffer(void);
        void MapBuffer(DWORD dwOffset);
        void UnmapBuffer(void);

        // Deferred commands
        BOOL ScheduleDeferredCommand(DWORD dwCommand, REFERENCE_TIME rtTimeStamp, DWORD dwContext);
        void RemoveDeferredCommand(DWORD dwCommand);
        void ServiceDeferredCommand(DWORD dwCommand, DWORD dwContext);

        // Buffer events
        void OnPositionDelta(void);
        void NotifyToPosition(DWORD dwPlayCursor, BOOL fSignal = TRUE);
        void NotifyStop(void);

        // Interrupt handler
        BOOL ServiceVoiceInterrupt(void);
        void OnDeferredTerminate(void);
    };

    __inline void CMcpxBuffer::MapBuffer(void)
    {
        MapBuffer(m_pSettings->m_dwPlayStart);
    }
}

#endif // __cplusplus

#endif // __MCPBUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpstrm.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpxstrm.h
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#ifndef __MCPSTRM_H__
#define __MCPSTRM_H__

//
// Stream data
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY          leListEntry;        // List entry
    XMEDIAPACKET        xmpPacket;          // Packet data
    DWORD               dwCompletedSize;    // Amount of the packet that's been mapped into an SSL
    DWORD               dwStatus;           // Packet status (used by the deferred completion list)
    LONGLONG            rtTimestamp;        // Packet timestamp
END_DEFINE_STRUCT(MCPX_PACKET_CONTEXT);

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY          lstPackets;         // List of packets mapped into the SSL
    DWORD               dwPrdCount;         // Count of PRDs filled
    DWORD               dwBytesMapped;      // Count of bytes mapped into the SSL
END_DEFINE_STRUCT(MCPX_SSL_DESC);

//
// Return codes from CMcpxStream::Process
//

#define MCPX_STREAM_PROCESS_COMPLETEDSSL    0x00000001
#define MCPX_STREAM_PROCESS_MAPPEDDATA      0x00000002
#define MCPX_STREAM_PROCESS_MASK            0x00000003

//
// Deferred stream commands
//

#define MCPX_DEFERREDCMD_STREAM_CHECKSTUCK MCPX_DEFERREDCMD_VOICE_CHECKSTUCK

BEGIN_DEFINE_ENUM()
    MCPX_DEFERREDCMD_STREAM_RELEASERESOURCES = MCPX_DEFERREDCMD_VOICE_COUNT,
    MCPX_DEFERREDCMD_STREAM_COMPLETEPACKETS,
    MCPX_DEFERREDCMD_STREAM_FLUSH,
    MCPX_DEFERREDCMD_STREAM_STOP,
    MCPX_DEFERREDCMD_STREAM_PAUSE,
    MCPX_DEFERREDCMD_STREAM_COUNT
END_DEFINE_ENUM_();

#ifdef __cplusplus

//
// Audio stream implementation
//

namespace DirectSound
{
    class CMcpxStream
        : public CMcpxVoiceClient
    {
    protected:
        CDirectSoundStreamSettings *    m_pSettings;                                        // Shared stream settings
        DWORD                           m_dwPrdControl;                                     // PRD control value
        MCPX_SSL_DESC                   m_aSslDesc[MCPX_HW_SSLS_PER_VOICE];                 // SSL descriptors
        LIST_ENTRY                      m_lstPending;                                       // Pending packet list
        LIST_ENTRY                      m_lstAvailable;                                     // Available packet list
        LIST_ENTRY                      m_lstCompleted;                                     // Completed packet list
        PMCPX_PACKET_CONTEXT            m_paPacketContexts;                                 // Packet contexts
        PMCPX_PACKET_CONTEXT            m_pWorkingPacket;                                   // Current packet (only used when packet size is too large for SSL)
        DWORD                           m_dwWorkingPacketOffset;                            // Current read offset of working packet
        MCPX_DEFERRED_COMMAND           m_aDeferredCommands[MCPX_DEFERREDCMD_STREAM_COUNT]; // Deferred command data    
        DWORD                           m_dwFirstMappedSslIndex;                            // Index of the first mapped SSL
        DWORD                           m_dwMappedSslCount;                                 // Count of Ssls currently mapped

    public:
        CMcpxStream(CMcpxAPU *pAPU, CDirectSoundStreamSettings *pSettings);
        virtual ~CMcpxStream(void);

    public:
        // Initialization
        HRESULT Initialize(void);

        // Stream state
        HRESULT Pause(DWORD dwPause);
        HRESULT Pause(REFERENCE_TIME rtTimeStamp, DWORD dwPause);
        HRESULT Stop(DWORD dwFlags = 0);
        HRESULT Stop(REFERENCE_TIME rtTimeStamp, DWORD dwFlags = 0);
    
        // Stream status
        HRESULT GetStatus(LPDWORD pdwStatus);
        BOOL HasPendingData(void);

        // Stream properties
        HRESULT SetFormat(void);
        DWORD GetLowWatermark(void);

        // Stream data
        HRESULT SubmitPacket(REFXMEDIAPACKET Packet);
        HRESULT Discontinuity(void);
        HRESULT Flush(void);

    protected:
        // Hardware voice resources
        HRESULT AllocateStreamResources(void);
        void ReleaseStreamResources(void);

        // SSL management
        DWORD Process(void);
        BOOL MapPackets(DWORD dwSslIndex);
        DWORD MapPacket(DWORD dwSslIndex, PMCPX_PACKET_CONTEXT pPacketContext);
        void CommitSsl(DWORD dwSslIndex);
        void CompleteSsl(DWORD dwSslIndex, DWORD dwStatus);
        DWORD GetSslBase(DWORD dwVoiceIndex, DWORD dwSslIndex);

        // Packet list
        void CompletePackets(PLIST_ENTRY pListHead, DWORD dwStatus);
        void CompleteDeferredPackets(void);
        void CompletePacket(PMCPX_PACKET_CONTEXT pPacketContext, DWORD dwStatus);
        void OnDeferredFlush(void);

        // Interrupt handler
        BOOL ServiceVoiceInterrupt(void);

        // Deferred commands
        BOOL ScheduleDeferredCommand(DWORD dwCommand, REFERENCE_TIME rtTimeStamp, DWORD dwContext);
        void RemoveDeferredCommand(DWORD dwCommand);
        void ServiceDeferredCommand(DWORD dwCommand, DWORD dwContext);

        // Voice state
        void OnEndOfStream(void);
    };

    __inline DWORD CMcpxStream::GetLowWatermark(void)
    {
        return max((m_pSettings->m_fmt.nChannels * (DWORD)m_pSettings->m_fmt.wBitsPerSample / 8) * 32, m_pSettings->m_fmt.nBlockAlign) * 2;
    }

    __inline DWORD CMcpxStream::GetSslBase(DWORD dwVoiceIndex, DWORD dwSslIndex)
    {
        return ((DWORD)m_ahVoices[dwVoiceIndex] * MCPX_HW_MAX_PRD_ENTRIES_PER_VOICE) + (dwSslIndex * MCPX_HW_MAX_PRD_ENTRIES_PER_SSL);
    }

    __inline HRESULT CMcpxStream::AllocateStreamResources(void)
    {
        return CMcpxVoiceClient::AllocateVoiceResources();
    }

    __inline BOOL CMcpxStream::HasPendingData(void)
    {
        return !(IsListEmpty(&m_lstPending) && !m_dwMappedSslCount);
    }
}

#endif // __cplusplus

#endif // __MCPSTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpbuf.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpbuf.cpp
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#include "dsoundi.h"


/****************************************************************************
 *
 *  CMcpxBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CMcpxAPU * [in]: MCP-X APU object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::CMcpxBuffer"

CMcpxBuffer::CMcpxBuffer
(
    CMcpxAPU *                      pMcpxApu,
    CDirectSoundBufferSettings *    pSettings
)
:   CMcpxVoiceClient(pMcpxApu, pSettings)
{
    DWORD                   i;
    
    DPF_ENTER();

    m_pSettings = ADDREF(pSettings);

    //
    // Initialize deferred command structures
    //

    for(i = 0; i < NUMELMS(m_aDeferredCommands); i++)
    {
        InitializeListHead(&m_aDeferredCommands[i].leListEntry);
        
        m_aDeferredCommands[i].pVoice = this;
        m_aDeferredCommands[i].dwCommand = i;
    }

    m_aDeferredCommands[MCPX_DEFERREDCMD_BUFFER_CHECKSTUCK].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;
    m_aDeferredCommands[MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;
    m_aDeferredCommands[MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::~CMcpxBuffer"

CMcpxBuffer::~CMcpxBuffer
(
    void
)
{
    DWORD                   i;
    
    DPF_ENTER();

    //
    // Free buffer resources
    //

    ReleaseBufferResources();

    //
    // Make sure all deferred commands are dequeued
    //

    for(i = 0; i < NUMELMS(m_aDeferredCommands); i++)
    {
        RemoveDeferredCommand(i);
    }

    //
    // Release the settings object
    //
    
    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::Initialize"

HRESULT
CMcpxBuffer::Initialize
(
    void
)
{
    HRESULT                         hr;

    DPF_ENTER();

    //
    // Initialize the base class
    //

    hr = CMcpxVoiceClient::Initialize(FALSE);

    //
    // If the buffer was created without LOCDEFER and we have valid buffer 
    // data, allocate resources now.
    //

    if(SUCCEEDED(hr) && !(m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER))
    {
        hr = AllocateBufferResources();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetBufferData
 *
 *  Description:
 *      Sets the data buffer address and size.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::SetBufferData"

HRESULT 
CMcpxBuffer::SetBufferData
(
    void
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    ASSERT(!(m_dwStatus & ~MCPX_VOICESTATUS_ALLOCATED));
    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
    ASSERT(m_pSettings->m_pvBufferData);
    ASSERT(m_pSettings->m_dwBufferSize);

    //
    // Reset the cached play cursor position
    //

    m_dwCachedPlayCursor = 0;

    //
    // If we're LOCDEFER, don't do anything.  If we're not, make sure
    // resources are allocated.
    //

    if(!(m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER))
    {
        hr = AllocateBufferResources();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ReleaseBufferData
 *
 *  Description:
 *      Called before SetBufferData, giving the object a chance to clean
 *      up before the data pointer/size pair changes.
 *
 *  Arguments:
 *      BOOL [in]: TRUE if more data is on the way; FALSE if the data is
 *                 being released.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::ReleaseBufferData"

HRESULT 
CMcpxBuffer::ReleaseBufferData
(
    BOOL                    fChanging
)
{
    DPF_ENTER();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));

    //
    // If we're LOCDEFER, go ahead and free voice resources.  If not, just
    // deactivate the voice and unmap the data buffer.
    //

    if(!fChanging && (m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER))
    {
        ReleaseBufferResources();
    }
    else
    {
        UnmapBuffer();
    }

    //
    // We're not allowing the current position to persist after changing
    // the buffer data.
    //

    m_dwCachedPlayCursor = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  AllocateBufferResources
 *
 *  Description:
 *      Allocates hardware resources for the voice.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::AllocateBufferResources"

HRESULT 
CMcpxBuffer::AllocateBufferResources
(
    void
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    //
    // Allocate voice resources
    //
    
    hr = AllocateVoiceResources();

    //
    // Map the data buffer
    //

    if(SUCCEEDED(hr) && !(m_pSettings->m_dwFlags & DSBCAPS_MIXIN))
    {
        if(m_pSettings->m_dwFlags & DSBCAPS_FXIN)
        {
            MapEffectsBuffer();
        }
        else if(m_pSettings->m_pvBufferData && m_pSettings->m_dwBufferSize)
        {
            hr = MapInputBuffer();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ReleaseBufferResources
 *
 *  Description:
 *      Releases hardware resources for the voice.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::ReleaseBufferResources"

void
CMcpxBuffer::ReleaseBufferResources
(
    void
)
{
    DWORD                   i;
    
    DPF_ENTER();

    //
    // Make sure the voice is stopped
    //

    Stop();
    WaitForVoiceOff();

    //
    // Unschedule any pending low-priority tasks (including RELEASERESOURCES)
    //

    for(i = 0; i < MCPX_DEFERREDCMD_BUFFER_COUNT; i++)
    {
        if(m_aDeferredCommands[i].dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY)
        {
            RemoveDeferredCommand(i);
        }
    }

    //
    // Unmap the buffer.
    //

    UnmapBuffer();

    //
    // Clear any left-over status bits
    //

    and(&m_dwStatus, MCPX_VOICESTATUS_DEACTIVATEMASK);

    //
    // Release voice resources
    //

    ReleaseVoiceResources();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  MapInputBuffer
 *
 *  Description:
 *      Maps the data buffer into SGEs used by the voice.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::MapInputBuffer"

HRESULT
CMcpxBuffer::MapInputBuffer
(
    void
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
    ASSERT(m_pSettings->m_pvBufferData);
    ASSERT(m_pSettings->m_dwBufferSize);

    if(!(m_dwStatus & MCPX_VOICESTATUS_BUFFERMAPPED))
    {
        ASSERT(m_dwStatus == MCPX_VOICESTATUS_ALLOCATED);
        ASSERT(!m_pSgeHeapEntry);

        //
        // Set the status bit that shows that the buffer was mapped
        //

        or(&m_dwStatus, MCPX_VOICESTATUS_BUFFERMAPPED);

        //
        // Allocate a run of SGEs and map the buffer into the global SGE table
        //

        if(!(m_pSgeHeapEntry = m_pMcpxApu->m_SgeHeap.Alloc(m_pSettings->m_pvBufferData, m_pSettings->m_dwBufferSize)))
        {
            DPF_RESOURCE("Out of scatter/gather entries.  Either your buffer is too big, or too many buffers have been mapped at one time.");
            hr = DSERR_OUTOFMEMORY;
        }

        //
        // Complete the mapping operation
        //

        if(SUCCEEDED(hr))
        {
            MapBuffer();
        }

        //
        // If anything went wrong, unmap the buffer
        //

        if(FAILED(hr))
        {
            UnmapBuffer();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  MapEffectsBuffer
 *
 *  Description:
 *      Maps the data buffer into SGEs used by the voice.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::MapEffectsBuffer"

void
CMcpxBuffer::MapEffectsBuffer
(
    void
)
{
    DWORD                   dwVoiceIndex;
    LPVOID                  pvBufferData;
    DWORD                   dwBufferSize;
    
    DPF_ENTER();

    ASSERT((m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK) == DSBCAPS_FXIN);
    ASSERT(!m_pSgeHeapEntry);

    if(!(m_dwStatus & MCPX_VOICESTATUS_BUFFERMAPPED))
    {
        ASSERT(m_dwStatus == MCPX_VOICESTATUS_ALLOCATED);
        ASSERT(!m_pSettings->m_pvBufferData);
        ASSERT(!m_pSettings->m_dwBufferSize);

        //
        // Set the status bit that shows that the buffer was mapped
        //

        or(&m_dwStatus, MCPX_VOICESTATUS_BUFFERMAPPED);

        //
        // The 2047th SGE is reserved for global multipass (i.e. FXIN) buffers.
        // It was already set up for us, so all we have to do here is point the
        // voice at it.
        //

        dwVoiceIndex = m_pSettings->m_dwInputMixBin - DSMIXBIN_FXSEND_FIRST;

        dwBufferSize = SamplesToBytes(MCPX_HW_FRAME_SIZE_SAMPLES);
        pvBufferData = (LPBYTE)m_pMcpxApu->m_ctxMemory[MCPX_MEM_GPMULTIPASS].VirtualAddress + (dwVoiceIndex * dwBufferSize);

        m_pSettings->SetBufferData(pvBufferData, dwBufferSize);

        DPF_INFO("Voice %x (%x) using mixbin %lu (address %x) as it's input", this, m_ahVoices[0], m_pSettings->m_dwInputMixBin, pvBufferData);

        //
        // Complete the mapping operation
        //

        MapBuffer();
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  MapBuffer
 *
 *  Description:
 *      Maps the data buffer into SGEs used by the voice.
 *
 *  Arguments:
 *      DWORD [in]: byte offset from the base buffer address to map.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::MapBuffer"

void
CMcpxBuffer::MapBuffer
(
    DWORD                   dwOffset
)
{

#ifdef DEBUG

    DWORD                   dwAlignment;

#endif // DEBUG

    DWORD                   dwSgeIndex;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_MIXIN));
    ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);

#ifdef DEBUG

    //
    // Validate that the buffer base address and offset are properly aligned
    //
    
    if(WAVE_FORMAT_XBOX_ADPCM == m_pSettings->m_fmt.wFormatTag)
    {
        dwAlignment = 4;
    }
    else if(8 == m_pSettings->m_fmt.wBitsPerSample)
    {
        dwAlignment = 1;
    }
    else if(16 == m_pSettings->m_fmt.wBitsPerSample)
    {
        dwAlignment = 2;
    }
    else if((24 == m_pSettings->m_fmt.wBitsPerSample) || (32 == m_pSettings->m_fmt.wBitsPerSample))
    {
        dwAlignment = 4;
    }

    ASSERT(!(((DWORD)m_pSettings->m_pvBufferData + dwOffset) % dwAlignment));

#endif // DEBUG

    //
    // Calculate the proper base SGE index.  For FXIN buffers, it's the 
    // reserved 2047th one that's already set up for us.  For standard
    // buffers, calculate the proper index based on the offset from the
    // start of the base page.
    //
    
    ASSERT(m_pSettings->m_pvBufferData);
    
    if(m_pSettings->m_dwFlags & DSBCAPS_FXIN)
    {
        ASSERT(!m_pSgeHeapEntry);
        ASSERT(!dwOffset);
        
        dwOffset = BYTE_OFFSET(m_pSettings->m_pvBufferData);
        dwSgeIndex = MCPX_HW_MAX_BUFFER_PRDS - 1;
    }
    else
    {
        ASSERT(m_pSgeHeapEntry);

        dwSgeIndex = m_pSgeHeapEntry->nElement;
        
        dwOffset += BYTE_OFFSET(m_pSettings->m_pvBufferData);
        dwSgeIndex += dwOffset >> PAGE_SHIFT;

        ASSERT(dwSgeIndex < (DWORD)m_pSgeHeapEntry->nElement + (DWORD)m_pSgeHeapEntry->nLength);
        
        dwOffset &= PAGE_SIZE - 1;
    }

    //
    // Calculate the buffer address register value.  The low word represents
    // the page offset, while the high word represents the entry into the 
    // SGE table.
    //

    ASSERT(dwSgeIndex < MCPX_HW_MAX_BUFFER_PRDS);
    ASSERT(dwOffset < PAGE_SIZE);
    
    m_dwBufferBase = (dwSgeIndex << PAGE_SHIFT) | dwOffset;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  UnmapBuffer
 *
 *  Description:
 *      Releases the data buffer mapped into this voice.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::UnmapBuffer"

void
CMcpxBuffer::UnmapBuffer
(
    void
)
{
    DPF_ENTER();

    //
    // Make sure the voice is stopped
    //

    Stop();
    WaitForVoiceOff();

    //
    // Unmap the buffer
    //

    if(m_dwStatus & MCPX_VOICESTATUS_BUFFERMAPPED)
    {
        //
        // Clear the status bit
        //

        and(&m_dwStatus, ~MCPX_VOICESTATUS_BUFFERMAPPED);
        
        //
        // Release the SGE
        //

        if(m_pSgeHeapEntry)
        {
            m_pMcpxApu->m_SgeHeap.Free(m_pSgeHeapEntry);
            m_pSgeHeapEntry = NULL;
        }
    }
    else
    {
        ASSERT(!(m_dwStatus & ~MCPX_VOICESTATUS_ALLOCATED));
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: time to start playing.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::Play"

HRESULT
CMcpxBuffer::Play
(
    REFERENCE_TIME          rtTimeStamp,
    DWORD                   dwFlags
)
{
    BOOL                    fDeferred   = FALSE;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    if(rtTimeStamp)
    {
        fDeferred = ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_PLAY, rtTimeStamp, dwFlags);
    }

    if(!fDeferred)
    {
        hr = Play(dwFlags);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::Play"

HRESULT
CMcpxBuffer::Play
(
    DWORD                   dwFlags
)
{
    DWORD                   dwCurrentBufferOffset;
    HRESULT                 hr;
    
    DPF_ENTER();

    //
    // Make sure resources are allocated
    //

    hr = AllocateBufferResources();

    //
    // Handle the different modes of playing the buffer:  normal, 
    // extra-crispy... no, wait; normal, non-zero position, mixin.
    //

    if(SUCCEEDED(hr))
    {
        if(m_pSettings->m_dwFlags & DSBCAPS_MIXIN)
        {
            //
            // Just activate the voice.  The hardware takes care of the rest
            //
            
            ActivateVoice();
        }
        else 
        {
            //
            // Determine where to start playback from
            //
            
            if(!(dwFlags & DSBPLAY_FROMSTART) && !(m_dwStatus & MCPX_VOICESTATUS_ACTIVE))
            {
                dwCurrentBufferOffset = m_dwCachedPlayCursor;
            }
            else
            {
                dwCurrentBufferOffset = 0;
            }

            m_dwCachedPlayCursor = 0;

            //
            // Hand off to the proper play handler
            //
            
            if(dwCurrentBufferOffset)
            {
                PlayFromPosition(dwCurrentBufferOffset, dwFlags);
            }
            else
            {
                PlayFromCurrent(dwFlags);
            }

            //
            // Register for position notification callbacks
            //

            if(m_pSettings->m_dwNotifyCount)
            {
                ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA, 0, 0);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  PlayFromCurrent
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to loop the buffer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::PlayFromCurrent"

void
CMcpxBuffer::PlayFromCurrent
(
    DWORD                   dwFlags
)
{
    DWORD                   dwLoopBackOffset;
    DWORD                   dwEndBufferOffset;
    DWORD                   dwIncrement;
    CIrql                   irql;
    HRESULT                 hr;
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_MIXIN));

    //
    // Raise IRQL for synchronization
    //

    irql.Raise();

    //
    // Calculate the proper starting and ending buffer offsets as well
    // as the proper loop region
    //

    if(dwFlags & DSBPLAY_LOOPING)
    {
        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP);

        dwLoopBackOffset = BytesToSamples(m_pSettings->m_dwLoopStart);
        dwEndBufferOffset = BytesToSamples(m_pSettings->m_dwLoopStart + m_pSettings->m_dwLoopLength);

        or(&m_dwStatus, MCPX_VOICESTATUS_LOOPING);
    }
    else
    {
        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP);

        dwLoopBackOffset = 0;
        dwEndBufferOffset = BytesToSamples(m_pSettings->m_dwPlayLength);

        and(&m_dwStatus, ~MCPX_VOICESTATUS_LOOPING);
    }

    ASSERT(dwEndBufferOffset > 1);
    dwEndBufferOffset--;

    dwIncrement = m_pSettings->m_fmt.wBitsPerSample * 2 / 8;

    MCPX_CHECK_VOICE_FIFO(8 * m_bVoiceCount);

    for(i = 0; i < m_bVoiceCount; i++)
    {
        MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
        MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
        MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
        MCPX_VOICE_WRITE(SetVoiceCfgBufBase, m_dwBufferBase + (dwIncrement * i));
        MCPX_VOICE_WRITE(SetVoiceCfgBufEBO, dwEndBufferOffset);
        MCPX_VOICE_WRITE(SetVoiceCfgBufLBO, dwLoopBackOffset);

        if(dwFlags & DSBPLAY_FROMSTART)
        {
            MCPX_VOICE_WRITE(SetVoiceBufCBO, 0);
        }

        MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
    }

    // 
    // Lower IRQL
    //

    irql.Lower();

    //
    // Activate the voice
    //

    ActivateVoice();

    //
    // By the time we get to this point, any pending SSL or VoiceOff interrupts
    // should have happened.  Unschedule any pending RELEASERESOURCES tasks 
    // that may have been scheduled.
    //
    // BUGBUG: unless we're at raised IRQL through this whole function, such
    // as when the dmusic sequencer calls us or a deferred Play command happens.
    //

#pragma TODO("What impact does this have?")

    RemoveDeferredCommand(MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  PlayFromPosition
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: starting offset, in bytes.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::PlayFromPosition"

void
CMcpxBuffer::PlayFromPosition
(
    DWORD                   dwPosition,
    DWORD                   dwFlags
)
{
    MCPX_VOICE_VOLUME       Volume;
    DWORD                   dwState;
    CIrql                   irql;
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ALLOCATED);
    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_MIXIN));
    ASSERT(!(dwFlags & DSBPLAY_FROMSTART));
    ASSERT(dwPosition);

    //
    // The hardware won't let us set the CBO until it's processed the first
    // frame.  Set the buffer up so it plays the first 32 samples in a loop
    // until the NEW_VOICE bit is cleared.
    //

    memset(&Volume, 0xFF, sizeof(Volume));

    irql.Raise();

    m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP);

    MCPX_CHECK_VOICE_FIFO(10 * m_bVoiceCount);

    for(i = 0; i < m_bVoiceCount; i++)
    {
        MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
        MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
        MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
        MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);
        MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);
        MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);
        MCPX_VOICE_WRITE(SetVoiceCfgBufBase, m_dwBufferBase);
        MCPX_VOICE_WRITE(SetVoiceCfgBufEBO, MCPX_HW_FRAME_SIZE_SAMPLES);
        MCPX_VOICE_WRITE(SetVoiceCfgBufLBO, 0);
        MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
    }

    irql.Lower();

    ActivateVoice();

    //
    // Wait for the NEW_VOICE bit to clear so we know the first frame of audio
    // has been processed
    //

    do
    {
        MCPX_VOICE_STRUCT_READ(m_ahVoices[m_bVoiceCount - 1], NV_PAVS_VOICE_PAR_STATE, &dwState);
    }
    while(MCPX_GET_REG_VALUE(dwState, NV_PAVS_VOICE_PAR_STATE_NEW_VOICE));

    //
    // Play the buffer properly
    //

    PlayFromCurrent(dwFlags);

    //
    // Set the cursor position and restore the volume
    //

    irql.Raise();

    ConvertVolumeValues(&Volume);

    dwPosition = BytesToSamples(dwPosition);

    MCPX_CHECK_VOICE_FIFO(7 * m_bVoiceCount);
    
    for(i = 0; i < m_bVoiceCount; i++)
    {
        MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
        MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
        MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);
        MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);
        MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);
        MCPX_VOICE_WRITE(SetVoiceBufCBO, dwPosition);
        MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
    }

    irql.Lower();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetPlayRegion
 *
 *  Description:
 *      Sets the buffer's play region.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::SetPlayRegion"

HRESULT
CMcpxBuffer::SetPlayRegion
(
    void
)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwFlags;
 
    DPF_ENTER();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));

    //
    // Reset the cached play cursor
    //

    m_dwCachedPlayCursor = 0;

    //
    // Recalculate the buffer base address
    //

    if(m_dwStatus & MCPX_VOICESTATUS_BUFFERMAPPED)
    {
        MapBuffer();
    }

    //
    // If we're playing, call Play again.  That will reset the regions
    // based on what was just set.
    //

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        dwFlags = DSBPLAY_FROMSTART;

        if(m_dwStatus & MCPX_VOICESTATUS_LOOPING)
        {
            dwFlags |= DSBPLAY_LOOPING;
        }
        
        hr = Play(dwFlags);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetLoopRegion
 *
 *  Description:
 *      Sets the buffer's loop region.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::SetLoopRegion"

HRESULT
CMcpxBuffer::SetLoopRegion
(
    void
)
{
    HRESULT                 hr  = DS_OK;
 
    DPF_ENTER();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));

    //
    // If we're playing, call Play again.  That will reset the regions
    // based on what was just set.
    //

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        hr = Play((m_dwStatus & MCPX_VOICESTATUS_LOOPING) ? DSBPLAY_LOOPING : 0);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Pauses a playing buffer.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: time to stop.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::Stop"

HRESULT
CMcpxBuffer::Stop
(
    REFERENCE_TIME          rtTimeStamp,
    DWORD                   dwFlags
)
{
    BOOL                    fDeferred   = FALSE;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    if(rtTimeStamp)
    {
        fDeferred = ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_STOP, rtTimeStamp, dwFlags);
    }

    if(!fDeferred)
    {
        hr = Stop(dwFlags);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Pauses a playing buffer.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::Stop"

HRESULT
CMcpxBuffer::Stop
(
    DWORD                   dwFlags
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    //
    // Make sure resources are allocated and we're actually running
    //

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        if(dwFlags & DSBSTOPEX_ENVELOPE)
        {
            //
            // If we're supposed to break out of the loop, just call Play again
            // without the loop flag.
            //

            if(dwFlags & DSBSTOPEX_RELEASEWAVEFORM)
            {
                if((m_dwStatus & MCPX_VOICESTATUS_LOOPINGMASK) == MCPX_VOICESTATUS_LOOPINGMASK)
                {
                    hr = Play(0);
                }
            }

            //
            // Enter the release segment
            //

            if(SUCCEEDED(hr))
            {
                ReleaseVoice();
            }
        }
        else
        {
            //
            // Cache the current play cursor position
            //

            if(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK))
            {
                GetCurrentPosition(&m_dwCachedPlayCursor, NULL);
            }

            //
            // Stop the voice
            //

            DeactivateVoice();

            //
            // Signal positions up to this point
            //

            OnPositionDelta();

            //
            // If we're LOCDEFER, schedule a deferred command to release voice
            // resources
            //

            if(m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER)
            {
                ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES, 0, 0);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets the current play state of the buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::GetStatus"

HRESULT
CMcpxBuffer::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    DPF_ENTER();
    AutoIrql();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));

    //
    // Convert the voice state to buffer status.  We're going to look at
    // the VOICEOFF bit so IDirectSoundBuffer::GetStatus is as accurate as
    // possible.  This will allow a client to spin on GetStatus until the
    // voice is really inactive, preventing us from busy-waiting later.
    //

    *pdwStatus = 0;
    
    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        if(m_dwStatus & MCPX_VOICESTATUS_ACTIVEORVOICEOFF)
        {
            *pdwStatus |= DSBSTATUS_PLAYING;

            if(m_dwStatus & MCPX_VOICESTATUS_LOOPING)
            {
                *pdwStatus |= DSBSTATUS_LOOPING;
            }
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: play cursor position, in bytes.
 *      LPDWORD [out]: write cursor position, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::GetCurrentPosition"

HRESULT
CMcpxBuffer::GetCurrentPosition
(
    LPDWORD                 pdwPlayCursor,
    LPDWORD                 pdwWriteCursor
)
{
    DWORD                   dwPlayCursor;
    DWORD                   dwFrameSize;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));

    //
    // Get the current SSL position if we're playing or used the cached one
    // if we're not.
    //
    // When we're playing, the write cursor is 32 samples ahead of the play 
    // cursor.
    //

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        dwPlayCursor = GetSslPosition();

        if(pdwPlayCursor)
        {
            *pdwPlayCursor = dwPlayCursor;
        }

        if(pdwWriteCursor)
        {
            dwFrameSize = SamplesToBytes(MCPX_HW_FRAME_SIZE_SAMPLES);

            if(dwFrameSize < m_pSettings->m_fmt.nBlockAlign)
            {
                dwFrameSize = m_pSettings->m_fmt.nBlockAlign;
            }
            
            *pdwWriteCursor = dwPlayCursor + dwFrameSize;
    
            if((m_dwStatus & MCPX_VOICESTATUS_LOOPING) && (dwPlayCursor >= m_pSettings->m_dwLoopStart) && (dwPlayCursor < m_pSettings->m_dwLoopStart + m_pSettings->m_dwLoopLength))
            {
                *pdwWriteCursor %= m_pSettings->m_dwLoopLength;
                *pdwWriteCursor += m_pSettings->m_dwLoopStart;
            }
            else
            {
                *pdwWriteCursor %= m_pSettings->m_dwBufferSize;
            }
        }
    }
    else
    {
        if(pdwPlayCursor)
        {
            *pdwPlayCursor = m_dwCachedPlayCursor;
        }

        if(pdwWriteCursor)
        {
            *pdwWriteCursor = m_dwCachedPlayCursor;
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Sets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play cursor position, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::SetCurrentPosition"

HRESULT
CMcpxBuffer::SetCurrentPosition
(
    DWORD                   dwPlayCursor
)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwState;
    CIrql                   irql;
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
    ASSERT(dwPlayCursor <= m_pSettings->m_dwPlayLength);

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        //
        // Wait for the NEW_VOICE bit to clear so we can set the CBO.  The
        // hardware will ignore the CBO until it's processed at least one
        // frame.
        //

        do
        {
            MCPX_VOICE_STRUCT_READ(m_ahVoices[m_bVoiceCount - 1], NV_PAVS_VOICE_PAR_STATE, &dwState);
        }
        while(MCPX_GET_REG_VALUE(dwState, NV_PAVS_VOICE_PAR_STATE_NEW_VOICE));

        //
        // If the cursor position is outside the loop region, toggle
        // the loop flag.
        //

        if((m_dwStatus & MCPX_VOICESTATUS_LOOPINGMASK) == MCPX_VOICESTATUS_LOOPINGMASK)
        {
            if(dwPlayCursor >= m_pSettings->m_dwLoopStart + m_pSettings->m_dwLoopLength)
            {
                hr = Play(0);
            }
        }

        //
        // Set voice position
        //
        
        if(SUCCEEDED(hr))
        {
            dwPlayCursor = BytesToSamples(dwPlayCursor);

            DPF_INFO("Voice %x (%x) setting current buffer offset to %lu", this, m_ahVoices[0], dwPlayCursor);

            irql.Raise();
        
            MCPX_CHECK_VOICE_FIFO(2 * m_bVoiceCount);
            
            for(i = 0; i < m_bVoiceCount; i++)
            {
                MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
                MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
                MCPX_VOICE_WRITE(SetVoiceBufCBO, dwPlayCursor);
                MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
            }

            irql.Lower();
        }
    }
    else
    {
        //
        // Cache the play cursor for the next time we call Play
        //
        
        m_dwCachedPlayCursor = dwPlayCursor;
    }

    //
    // Signal position events
    //

    OnPositionDelta();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ServiceVoiceInterrupt
 *
 *  Description:
 *      DPC callback function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::ServiceVoiceInterrupt"

BOOL
CMcpxBuffer::ServiceVoiceInterrupt
(
    void
)
{
    BOOL                    fHandled;

    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
    
    if(fHandled = m_Notifier.GetStatus(MCPX_NOTIFIER_VOICE_OFF))
    {
        //
        // Reset the notifier
        //
        
        m_Notifier.SetStatus(MCPX_NOTIFIER_VOICE_OFF, FALSE);

        //
        // Handle the stop
        //

        DeactivateVoice();

        //
        // If we're LOCDEFER, free voice resources
        //

        if(m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER)
        {
            ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES, 0, 0);
        }
    }

    DPF_LEAVE(fHandled);

    return fHandled;
}


/****************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets notification positions.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::SetNotificationPositions"

HRESULT
CMcpxBuffer::SetNotificationPositions
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    //
    // If we're playing, make sure the position delta event is set up
    //

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        if(m_pSettings->m_dwNotifyCount)
        {
            ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA, 0, 0);
        }
    }

    //
    // Reset the notification index
    //

    m_dwLastNotifyPosition = -1;
    m_dwNextNotifyIndex = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  OnPositionDelta
 *
 *  Description:
 *      Signals position notifications.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::OnPositionDelta"

void
CMcpxBuffer::OnPositionDelta
(
    void
)
{
    DWORD                   dwPlayCursor;
    DWORD                   dwStartPosition;
    DWORD                   dwEndPosition;
    HRESULT                 hr;
    
    DPF_ENTER();

    if(m_pSettings->m_dwNotifyCount)
    {
        ASSERT(m_pSettings->m_paNotifies);

        //
        // Compare the current position to the last and signal the events in
        // between
        //

        if(NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_ON == MCPX_GET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP))
        {
            dwStartPosition = m_pSettings->m_dwLoopStart;
            dwEndPosition = m_pSettings->m_dwLoopStart + m_pSettings->m_dwLoopLength;
        }
        else
        {
            dwStartPosition = 0;
            dwEndPosition = m_pSettings->m_dwPlayLength;
        }

        hr = GetCurrentPosition(&dwPlayCursor, NULL);
        ASSERT(SUCCEEDED(hr));

        if((dwPlayCursor > m_dwLastNotifyPosition) || (m_dwLastNotifyPosition > dwEndPosition))
        {
            //
            // The play cursor has moved forward.  Signal the events in
            // between where we were and where we are.
            //

            NotifyToPosition(dwPlayCursor);
        }
        else if(dwPlayCursor < m_dwLastNotifyPosition)
        {
            //
            // The play cursor has moved backwards.  We'll assume it's because 
            // we looped.  Signal to the end of the buffer, reset the 
            // notification index to the beginning of the play region, then 
            // signal up to the current position.
            //

            NotifyToPosition(dwEndPosition);

            m_dwNextNotifyIndex = 0;

            NotifyToPosition(dwStartPosition, FALSE);
            NotifyToPosition(dwPlayCursor);
        }

        //
        // If the buffer isn't playing anymore, signal the stop event and
        // unregister for position delta callbacks.
        //

        if(!(m_dwStatus & MCPX_VOICESTATUS_ACTIVEORVOICEOFF))
        {
            RemoveDeferredCommand(MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA);
            NotifyStop();
        }
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  NotifyToPosition
 *
 *  Description:
 *      Signals position notifications.
 *
 *  Arguments:
 *      DWORD [in]: play cursor position.
 *      BOOL [in]: TRUE to signal notifications; FALSE to just move the
 *                 indices.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::NotifyToPosition"

void
CMcpxBuffer::NotifyToPosition
(
    DWORD                   dwPlayCursor,
    BOOL                    fSignal
)
{
    DPF_ENTER();

    ASSERT(m_pSettings->m_dwNotifyCount);
    ASSERT(m_pSettings->m_paNotifies);

    while(TRUE)
    {
        if(m_dwNextNotifyIndex >= m_pSettings->m_dwNotifyCount)
        {
            break;
        }
        else if(DSBPN_OFFSETSTOP == m_pSettings->m_paNotifies[m_dwNextNotifyIndex].dwOffset)
        {
            break;
        }
        else if(m_pSettings->m_paNotifies[m_dwNextNotifyIndex].dwOffset >= dwPlayCursor)
        {
            break;
        }

        if(fSignal)
        {
            NtSetEvent(m_pSettings->m_paNotifies[m_dwNextNotifyIndex].hEventNotify, NULL);
        }

        m_dwNextNotifyIndex++;
    }

    m_dwLastNotifyPosition = dwPlayCursor;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  NotifyStop
 *
 *  Description:
 *      Signals position notifications.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::NotifyStop"

void
CMcpxBuffer::NotifyStop
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();

    ASSERT(m_pSettings->m_dwNotifyCount);
    ASSERT(m_pSettings->m_paNotifies);

    for(i = m_pSettings->m_dwNotifyCount; i > 0; i--)
    {
        if(DSBPN_OFFSETSTOP != m_pSettings->m_paNotifies[i - 1].dwOffset)
        {
            break;
        }

        NtSetEvent(m_pSettings->m_paNotifies[i - 1].hEventNotify, NULL);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ScheduleDeferredCommand
 *
 *  Description:
 *      Adds a deferred voice command to the queue.
 *
 *  Arguments:
 *      DWORD [in]: command index.
 *      REFERENCE_TIME [in]: timestamp.
 *      DWORD [in]: context.
 *
 *  Returns:  
 *      BOOL: TRUE if the command was scheduled.  If the timestamp for the
 *            command has already elapsed, it won't be scheduled and should
 *            be processed immediately.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::ScheduleDeferredCommand"

BOOL 
CMcpxBuffer::ScheduleDeferredCommand
(
    DWORD                   dwCommand, 
    REFERENCE_TIME          rtTimeStamp, 
    DWORD                   dwContext
)
{
    LPMCPX_DEFERRED_COMMAND pCmd        = &m_aDeferredCommands[dwCommand];
    BOOL                    fScheduled;

    DPF_ENTER();
    
    ASSERT(dwCommand < NUMELMS(m_aDeferredCommands));

    pCmd->rtTimestamp = rtTimeStamp;
    pCmd->dwContext = dwContext;

    if(fScheduled = m_pMcpxApu->ScheduleDeferredCommand(pCmd))
    {
        DPF_BLAB("Voice %x (%x) scheduled command %lu", this, m_ahVoices[0], dwCommand);
    }

    DPF_LEAVE(fScheduled);

    return fScheduled;
}


/****************************************************************************
 *
 *  RemoveDeferredCommand
 *
 *  Description:
 *      Removes a deferred voice command from the queue.
 *
 *  Arguments:
 *      DWORD [in]: command index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::RemoveDeferredCommand"

void 
CMcpxBuffer::RemoveDeferredCommand
(
    DWORD                   dwCommand
)
{
    DPF_ENTER();

    ASSERT(dwCommand < NUMELMS(m_aDeferredCommands));

    if(m_aDeferredCommands[dwCommand].dwFlags & MCPX_DEFERREDCMDF_SCHEDULED)
    {
        DPF_BLAB("Voice %x (%x) unscheduling command %lu", this, m_ahVoices[0], dwCommand);
    }
    
    m_pMcpxApu->RemoveDeferredCommand(&m_aDeferredCommands[dwCommand]);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceDeferredCommand
 *
 *  Description:
 *      Deferred command dispatcher.
 *
 *  Arguments:
 *      DWORD [in]: command identifier.
 *      DWORD [in]: command context.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::ServiceDeferredCommand"

void 
CMcpxBuffer::ServiceDeferredCommand
(
    DWORD                   dwCommand, 
    DWORD                   dwContext
)
{
    DPF_ENTER();
    
    switch(dwCommand)
    {
        case MCPX_DEFERREDCMD_BUFFER_PLAY:
            Play(dwContext);
            break;

        case MCPX_DEFERREDCMD_BUFFER_STOP:
            Stop(dwContext);
            break;

        case MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA:
            OnPositionDelta();
            break;

        case MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES:
            OnDeferredTerminate();
            break;

        case MCPX_DEFERREDCMD_BUFFER_CHECKSTUCK:
            CheckStuckVoice();
            break;

        default:
            ASSERTMSG("Unexpected deferred command identifier");
            break;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  OnDeferredTerminate
 *
 *  Description:
 *      Checks for a stopped voice and frees voice resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxBuffer::OnDeferredTerminate"

void 
CMcpxBuffer::OnDeferredTerminate
(
    void
)
{
    DPF_ENTER();

    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        if(!(m_dwStatus & MCPX_VOICESTATUS_ACTIVEORVOICEOFF))
        {
            ReleaseBufferResources();
        }
    }
    else
    {
        RemoveDeferredCommand(MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES);
    }

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpvoice.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpvoice.h
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#ifndef __MCPVOICE_H__
#define __MCPVOICE_H__

//
// Voice status
//

#define MCPX_VOICESTATUS_ALLOCATED          0x0001
#define MCPX_VOICESTATUS_ACTIVE             0x0002
#define MCPX_VOICESTATUS_PAUSED             0x0004
#define MCPX_VOICESTATUS_NOTEOFF            0x0008
#define MCPX_VOICESTATUS_PERSIST            0x0010
#define MCPX_VOICESTATUS_VOICEOFF           0x8000

//
// Buffer status
//

#define MCPX_VOICESTATUS_BUFFERMAPPED       0x0100
#define MCPX_VOICESTATUS_LOOPING            0x0200

//
// Stream status
//

#define MCPX_VOICESTATUS_STARVED            0x0400
#define MCPX_VOICESTATUS_DISCONTINUITY      0x0800

//
// Status masks
//
                                            
#define MCPX_VOICESTATUS_ACTIVEMASK         (MCPX_VOICESTATUS_ALLOCATED | MCPX_VOICESTATUS_ACTIVE)
#define MCPX_VOICESTATUS_PAUSEDMASK         (MCPX_VOICESTATUS_ACTIVEMASK | MCPX_VOICESTATUS_PAUSED)
#define MCPX_VOICESTATUS_NOTEOFFMASK        (MCPX_VOICESTATUS_ACTIVEMASK | MCPX_VOICESTATUS_NOTEOFF)
#define MCPX_VOICESTATUS_VOICEOFFMASK       (MCPX_VOICESTATUS_ALLOCATED | MCPX_VOICESTATUS_VOICEOFF)
#define MCPX_VOICESTATUS_ACTIVEORVOICEOFF   (MCPX_VOICESTATUS_ACTIVE | MCPX_VOICESTATUS_VOICEOFF)

#define MCPX_VOICESTATUS_BUFFERMAPPEDMASK   (MCPX_VOICESTATUS_ALLOCATED | MCPX_VOICESTATUS_BUFFERMAPPED)
#define MCPX_VOICESTATUS_LOOPINGMASK        (MCPX_VOICESTATUS_ACTIVEMASK | MCPX_VOICESTATUS_LOOPING)

#define MCPX_VOICESTATUS_DISCONTINUITYMASK  (MCPX_VOICESTATUS_ACTIVEMASK | MCPX_VOICESTATUS_DISCONTINUITY)

#define MCPX_VOICESTATUS_ALLPAUSEDMASK      (MCPX_VOICESTATUS_PAUSED | MCPX_VOICESTATUS_STARVED)
#define MCPX_VOICESTATUS_DEACTIVATEMASK     (MCPX_VOICESTATUS_ALLOCATED | MCPX_VOICESTATUS_BUFFERMAPPED | MCPX_VOICESTATUS_PERSIST)
#define MCPX_VOICESTATUS_RELEASEMASK        MCPX_VOICESTATUS_PERSIST

//
// Cached voice registers
//

BEGIN_DEFINE_STRUCT()
    DWORD   CfgFMT;
    DWORD   CfgMISC;
    DWORD   CfgENV0;
    DWORD   CfgENVA;
    DWORD   CfgENV1;
    DWORD   CfgENVF;
    DWORD   CfgLFODLY;
    DWORD   LFOENV;
    DWORD   LFOMOD;
    DWORD   TarFCA;
    DWORD   TarFCB;
    DWORD   VoiceOn;
END_DEFINE_STRUCT(MCPX_VOICE_REGCACHE);

//
// Volume data
//

BEGIN_DEFINE_STRUCT()
    DWORD   TarVOLA[MCPX_MAX_VOICE_CHANNELS];
    DWORD   TarVOLB[MCPX_MAX_VOICE_CHANNELS];
    DWORD   TarVOLC[MCPX_MAX_VOICE_CHANNELS];
END_DEFINE_STRUCT(MCPX_VOICE_VOLUME);

//
// Deferred voice commands
//

BEGIN_DEFINE_ENUM()
    MCPX_DEFERREDCMD_VOICE_CHECKSTUCK = 0,
    MCPX_DEFERREDCMD_VOICE_COUNT,
END_DEFINE_ENUM_();

#ifdef __cplusplus

//
// MCPX voice notifier wrapper class
//

namespace DirectSound
{
    class CMcpxVoiceNotifier
        : public CMcpxNotifier
    {
    public:
        // Initialization
        void Initialize(MCPX_VOICE_HANDLE hVoice);
    };

    __inline void CMcpxVoiceNotifier::Initialize(MCPX_VOICE_HANDLE hVoice)
    {
        CMcpxNotifier::Initialize(MCPX_NOTIFIER_BASE_OFFSET + ((DWORD)hVoice * MCPX_NOTIFIER_COUNT), MCPX_NOTIFIER_COUNT);
    }
}

//
// Base class for buffers and streams
//

namespace DirectSound
{
    class CMcpxVoiceClient
        : public CRefCount
    {
        friend class CMcpxAPU;

    public:
        static DWORD                m_dwStuckVoiceCount;                    // Number of times a voice has had to be un-stuck

    protected:
        CMcpxAPU *                  m_pMcpxApu;                             // Pointer back to the core MCPX object
        MCPX_VOICE_HANDLE           m_ahVoices[MCPX_MAX_VOICE_CHANNELS];    // Hardware voice array
        volatile WORD               m_dwStatus;                             // Voice status (WORD for alignment)
        MCPX_VOICE_REGCACHE         m_RegCache;                             // Cached voice registers
        LIST_ENTRY                  m_lstSourceVoices;                      // Source voice list for mix-in voices
        LIST_ENTRY                  m_leActiveVoice;                        // Active voice list entry
        LIST_ENTRY                  m_lePendingInactiveVoice;               // Pending inactive voice list entry
        LIST_ENTRY                  m_leSourceVoice;                        // Source voice list entry
        BYTE                        m_bVoiceCount;                          // Hardware voice count
        BYTE                        m_bVoiceList;                           // Which voice list is the voice in?
        BYTE                        m_bAvailable3dFilter;                   // Available 3D filter index
        BYTE                        m_bAlign0;                              // 32-bit alignment
        CMcpxVoiceNotifier          m_Notifier;                             // Voice notifier wrapper
        CHrtfSource *               m_pHrtfSource;                          // HRTF source object
        CI3dl2Source *              m_pI3dl2Source;                         // I3DL2 source object
                                                                                    
    private:                                                                            
        CDirectSoundVoiceSettings * m_pSettings;                            // Shared voice settings
        DWORD                       m_dw3dMode;                             // Cached 3D mode
        REFERENCE_TIME              m_rtVoiceOff;                           // Time VoiceOff method was called

#ifdef MCPX_DEBUG_STUCK_VOICES

        DWORD                       m_dwIgnoredTraps;                       // Number of times we've had to ignore SE2FE_IDLE_VOICE

#endif // MCPX_DEBUG_STUCK_VOICES

    public:
        CMcpxVoiceClient(CMcpxAPU *pAPU, CDirectSoundVoiceSettings *pSettings);
        virtual ~CMcpxVoiceClient(void);

    public:
        // Initialization
        virtual HRESULT Initialize(BOOL fStream);
        virtual HRESULT SetFormat(void);
    
        // Voice properties
        HRESULT SetMixBins(void);
        HRESULT SetVolume(void);
        HRESULT SetPitch(void);
        HRESULT SetLFO(LPCDSLFODESC pLfo);
        HRESULT SetEG(LPCDSENVELOPEDESC pEnv);
        HRESULT SetFilter(LPCDSFILTERDESC pFilterDesc);
        HRESULT ConnectVoice(void);
        HRESULT DisconnectVoice(void);

#ifndef MCPX_BOOT_LIB

        // 3D object properties
        DWORD Commit3dSettings(void);

#endif // MCPX_BOOT_LIB

    protected:
        // Voice state
        void ActivateVoice(void);
        void DeactivateVoice(BOOL fBlock = FALSE);
        void ReleaseVoice(void);
        void PauseVoice(DWORD dwStatus);
        void WaitForVoiceOff(void);
        void CheckStuckVoice(void);
    
        // Register formatting
        void ConvertMixBinValues(LPDWORD pdwVBin, LPDWORD pdwVoiceFormat);
        void ConvertVolumeValues(LPMCPX_VOICE_VOLUME pVolume);
        void ConvertPitchValue(LPDWORD pdwPitch);
        DWORD GetVoiceCfgFMT(DWORD dwVoiceIndex);

        // Hardware voice resources
        HRESULT AllocateVoiceResources(void);
        void ReleaseVoiceResources(void);
    
#ifndef MCPX_BOOT_LIB
    
        // 3D
        void Apply3dSettings(DWORD dw3dChangeMask, DWORD dwMixBinChangeMask, DWORD dwI3dl2ChangeMask);
        void LoadHrtfFilter(void);

#endif // MCPX_BOOT_LIB

	    // Voice Format
	    DWORD BytesToSamples(DWORD dwBytes);
        DWORD SamplesToBytes(DWORD dwSamples);

        // Voice SSL position
        DWORD GetSslPosition(void);

        // Submixing
        CMcpxBuffer *GetSubMixDestination(void);

        // Interrupt handler
        virtual BOOL ServiceVoiceInterrupt(void) = 0;

        // Deferred commands
        virtual BOOL ScheduleDeferredCommand(DWORD dwCommand, REFERENCE_TIME rtTimeStamp, DWORD dwContext) = 0;
        virtual void RemoveDeferredCommand(DWORD dwCommand) = 0;
        virtual void ServiceDeferredCommand(DWORD dwCommand, DWORD dwContext) = 0;

    private:
        // Voice state
        void GetAntecedentVoice(LPBYTE pbVoiceList, CMcpxVoiceClient **ppAntecedentVoice);
        void RemoveIdleVoice(BOOL fScheduleDpc = TRUE);
        void RemoveStuckVoice(void);
    };

    __inline DWORD CMcpxVoiceClient::BytesToSamples(DWORD dwBytes)
    {
        if(WAVE_FORMAT_XBOX_ADPCM == m_pSettings->m_fmt.wFormatTag)
        {
            return (dwBytes / m_pSettings->m_fmt.nBlockAlign) << 6;
        }
        else
        {
            ASSERT(WAVE_FORMAT_PCM == m_pSettings->m_fmt.wFormatTag);
        
            return dwBytes / m_pSettings->m_fmt.nBlockAlign;
        }
    }

    __inline DWORD CMcpxVoiceClient::SamplesToBytes(DWORD dwSamples)
    {
	    if(WAVE_FORMAT_XBOX_ADPCM == m_pSettings->m_fmt.wFormatTag)
        {
            return (dwSamples >> 6) * m_pSettings->m_fmt.nBlockAlign;
        }
        else
        {
            ASSERT(WAVE_FORMAT_PCM == m_pSettings->m_fmt.wFormatTag);
        
            return dwSamples * m_pSettings->m_fmt.nBlockAlign;
        }
    }

    __inline DWORD CMcpxVoiceClient::GetVoiceCfgFMT(DWORD dwVoiceIndex)
    {
        DWORD                   dwCfgFMT    = m_RegCache.CfgFMT;

        if(dwVoiceIndex)
        {
            dwCfgFMT |= MCPX_MAKE_REG_VALUE(NV_PAVS_VOICE_CFG_FMT_LINKED_VOICE_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_LINKED_VOICE);
        }

        return dwCfgFMT;
    }

    __inline CMcpxBuffer *CMcpxVoiceClient::GetSubMixDestination(void)
    {
        if(!m_pSettings->m_pMixinBuffer)
        {
            return NULL;
        }

        ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
        ASSERT(m_pSettings->m_pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK);

        return m_pSettings->m_pMixinBuffer->m_pBuffer;
    }
}

#endif // __cplusplus

#endif // __MCPVOICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpvoice.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpvoice.cpp
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#include "dsoundi.h"


/****************************************************************************
 *
 *  CMcpxVoiceClient
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CMcpxAPU * [in]: pointer back to the core APU object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::CMcpxVoiceClient"

DWORD CMcpxVoiceClient::m_dwStuckVoiceCount = 0;

CMcpxVoiceClient::CMcpxVoiceClient
(
    CMcpxAPU *                  pMcpxApu,
    CDirectSoundVoiceSettings * pSettings
)
{
    DWORD                   i;
    
    DPF_ENTER();
    
    m_pMcpxApu = ADDREF(pMcpxApu);
    m_pSettings = ADDREF(pSettings);

    //
    // Initialize defaults
    //

    m_dw3dMode = DS3DMODE_NORMAL;

    InitializeListHead(&m_leActiveVoice);
    InitializeListHead(&m_lePendingInactiveVoice);
    InitializeListHead(&m_leSourceVoice);
    InitializeListHead(&m_lstSourceVoices);

    m_bVoiceList = MCPX_VOICELIST_INVALID;

    for(i = 0; i < NUMELMS(m_ahVoices); i++)
    {
        m_ahVoices[i] = MCPX_VOICE_HANDLE_INVALID;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxVoiceClient
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::~CMcpxVoiceClient"

CMcpxVoiceClient::~CMcpxVoiceClient
(
    void
)
{
    DPF_ENTER();

    ASSERT(!(m_dwStatus & ~MCPX_VOICESTATUS_RELEASEMASK));

    //
    // Make sure we're not still in the active voice list
    //

    AssertValidEntryList(&m_leActiveVoice, ASSERT_NOT_IN_LIST);
    AssertValidEntryList(&m_lePendingInactiveVoice, ASSERT_NOT_IN_LIST);
    
    //
    // Make sure we're disconnected from any submixes
    //

    DisconnectVoice();

    AssertValidEntryList(&m_leSourceVoice, ASSERT_NOT_IN_LIST);
    AssertValidEntryList(&m_lstSourceVoices, ASSERT_NOT_IN_LIST);

    //
    // Release object references
    //
    
    DELETE(m_pHrtfSource);
    DELETE(m_pI3dl2Source);

    RELEASE(m_pSettings);
    RELEASE(m_pMcpxApu);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      CMcpxVoiceClientSettings * [in]: shared voice settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::Initialize"

HRESULT 
CMcpxVoiceClient::Initialize
(
    BOOL                    fStream
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    ASSERT(!m_RegCache.CfgFMT);
    ASSERT(!m_RegCache.CfgMISC);
    
    //
    // Setup voice for buffer or stream mode
    //

    if(fStream)
    {
        m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE_STREAM, NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE);
    }
    else
    {
        m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE_BUFFER, NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE);
    }

    //
    // Set MIXIN-only values
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_MIXIN)
    {
        m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(DSMIXBIN_SUBMIX, NV_PAVS_VOICE_CFG_FMT_MULTIPASS_BIN__ALIAS__);
        m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS);
        m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX_TRUE, NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX);
    }

    //
    // Turn interrupts on for streams.  Buffers will get them from the idle
    // voice handler, not the hardware.
    //

    if(fStream)
    {
        m_RegCache.CfgMISC |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT_ENABLE, NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT);
    }

    //
    // Set up filter and SRC headroom
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC0_FLT0, NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM);
    }
    else
    {
        m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT3, NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM);
    }

    //
    // Set the voice format.  If we're a MIXIN voice, we just need to set the
    // voice count to 1.
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_MIXIN)
    {
        ASSERT(1 == m_pSettings->m_fmt.nChannels);
        m_bVoiceCount = 1;
    }
    else
    {
        hr = SetFormat();
    }

#ifndef MCPX_BOOT_LIB

    //
    // Allocate 3D helper objects
    //

    if(SUCCEEDED(hr) && (m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
    {
        ASSERT(m_pSettings->m_p3dParams);
        
        hr = HRFROMP(m_pHrtfSource = NEW(CHrtfSource(*m_pMcpxApu, *m_pSettings->m_p3dParams)));

        if(SUCCEEDED(hr))
        {
            hr = HRFROMP(m_pI3dl2Source = NEW(CI3dl2Source(*m_pMcpxApu, m_pSettings->m_p3dParams->I3dl2Params)));
        }
    }

#endif // MCPX_BOOT_LIB

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the voice format.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::SetFormat"

HRESULT 
CMcpxVoiceClient::SetFormat
(
    void
)
{
    HRESULT                 hr              = DS_OK;
    BYTE                    bVoiceCount;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_MIXIN));

    //
    // Update the number of hardware voices used by the object
    // 

    bVoiceCount = ((m_pSettings->m_fmt.nChannels - 1) >> 1) + 1;

    if(bVoiceCount != m_bVoiceCount)
    {
        if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
        {
            DPF_ERROR("Can't change the number of hardware voices used by an allocated voice");
            hr = DSERR_INVALIDCALL;
        }
        else
        {
            m_bVoiceCount = bVoiceCount;
        }
    }

    //
    // Create the format mask
    //

    if(SUCCEEDED(hr))
    {
        switch(m_pSettings->m_fmt.wFormatTag)
        {
            case WAVE_FORMAT_PCM:
                switch(m_pSettings->m_fmt.wBitsPerSample)
                {
                    case 8:  
                        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_U8, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);
                        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B8, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);
                        break;

                    case 16: 
                        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S16, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);
                        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B16, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);
                        break;

                    case 24:
                        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S24, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);
                        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B32, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);
                        break;

                    case 32: 
                        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S32, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);
                        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B32, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);
                        break;

                    default:
                        ASSERTMSG("Unexpected sample size");
                        break;
                }

                break;

            case WAVE_FORMAT_XBOX_ADPCM:
                m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);
                m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);
                break;

            default:
                ASSERTMSG("Unexpected format type");
                break;
        }
    }

    //
    // Set samples per block.  This register overlaps with the multipass bin 
    // alias for mixin buffers, so we can't set both.
    //

    if(SUCCEEDED(hr))
    {
        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, m_pSettings->m_fmt.nChannels - 1, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLES_PER_BLOCK);
    }

    //
    // If the voice uses more than 1 channel, enable stereo.  We can do
    // this when we're using multiple hardware voices per software voice
    // because we're restricted to 1, 2, 4 or 6-channels per voice, so 
    // there's only one odd-numbered voice.
    //

    if(SUCCEEDED(hr))
    {
        if(1 == m_pSettings->m_fmt.nChannels)
        {
            m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO_DISABLE, NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO);
        }
        else
        {
            ASSERT(!(m_pSettings->m_fmt.nChannels % 2));

            m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO_ENABLE, NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO);
        }
    }

    //
    // Update voice registers
    //
    
    if(SUCCEEDED(hr) && (m_dwStatus & MCPX_VOICESTATUS_ALLOCATED))
    {
        MCPX_CHECK_VOICE_FIFO(2 * m_bVoiceCount);

        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  AllocateVoiceResources
 *
 *  Description:
 *      Allocates hardware resources for the voice.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::AllocateVoiceResources"

HRESULT 
CMcpxVoiceClient::AllocateVoiceResources
(
    void
)
{
    HRESULT                 hr              = DS_OK;
    DWORD                   dwVoiceBins;
    DWORD                   dwPitch;
    MCPX_VOICE_VOLUME       Volume;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    if(!(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED))
    {
        ASSERT(!(m_dwStatus & ~MCPX_VOICESTATUS_DEACTIVATEMASK));
        
        //
        // Allocate voices
        //

        hr = m_pMcpxApu->AllocateVoices(this);

        //
        // Initialize the notifier wrapper
        //

        if(SUCCEEDED(hr))
        {
            m_Notifier.Initialize(m_ahVoices[0]);
        }

        //
        // Flag the voice as having resources allocated
        //

        if(SUCCEEDED(hr))
        {
            or(&m_dwStatus, MCPX_VOICESTATUS_ALLOCATED);
        }

        //
        // Build mixbin register values
        //

        if(SUCCEEDED(hr))
        {
            ConvertMixBinValues(&dwVoiceBins, &m_RegCache.CfgFMT);
        }

        //
        // Build volume register values
        //

        if(SUCCEEDED(hr))
        {
            ConvertVolumeValues(&Volume);
        }

        //
        // Calculate pitch shift
        //

        if(SUCCEEDED(hr))
        {
            ConvertPitchValue(&dwPitch);
        }

        //
        // Set voice registers
        //

        if(SUCCEEDED(hr))
        {
            for(i = 0; i < m_bVoiceCount; i++)
            {
                MCPX_CHECK_VOICE_FIFO(18);

                MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
                MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
                MCPX_VOICE_WRITE(SetVoiceCfgMISC, m_RegCache.CfgMISC);
                MCPX_VOICE_WRITE(SetVoiceCfgENV0, m_RegCache.CfgENV0);
                MCPX_VOICE_WRITE(SetVoiceCfgENVA, m_RegCache.CfgENVA);
                MCPX_VOICE_WRITE(SetVoiceCfgENV1, m_RegCache.CfgENV1);
                MCPX_VOICE_WRITE(SetVoiceCfgENVF, m_RegCache.CfgENVF);
                MCPX_VOICE_WRITE(SetVoiceCfgLFODLY, m_RegCache.CfgLFODLY);
                MCPX_VOICE_WRITE(SetVoiceLFOENV, m_RegCache.LFOENV);
                MCPX_VOICE_WRITE(SetVoiceLFOMOD, m_RegCache.LFOMOD);
                MCPX_VOICE_WRITE(SetVoiceTarFCA, m_RegCache.TarFCA);
                MCPX_VOICE_WRITE(SetVoiceTarFCB, m_RegCache.TarFCB);
                MCPX_VOICE_WRITE(SetVoiceCfgVBIN, dwVoiceBins);
                MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);
                MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);
                MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);
                MCPX_VOICE_WRITE(SetVoiceTarPitch, dwPitch);
                MCPX_VOICE_WRITE(SetVoiceTarHRTF, 0xFFFF);
            }
        }

#ifndef MCPX_BOOT_LIB

        //
        // If we're 3D, force a reload of the HRTF filter coefficients
        //

        if(SUCCEEDED(hr) && (m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
        {
            ASSERT(m_pHrtfSource);

            m_pHrtfSource->GetHrtfFilterPair();

            LoadHrtfFilter();
        }

#endif // MCPX_BOOT_LIB

    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ReleaseVoiceResources
 *
 *  Description:
 *      Releases hardware resources for the voice.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::ReleaseVoiceResources"

void
CMcpxVoiceClient::ReleaseVoiceResources
(
    void
)
{
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(!(m_dwStatus & ~(MCPX_VOICESTATUS_ALLOCATED | MCPX_VOICESTATUS_RELEASEMASK)));
    
    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        //
        // Clear the voice structure
        //

        for(i = 0; i < m_bVoiceCount; i++)
        {
            ZeroMemory((LPVOID)MCPX_VOICE_STRUCT_BASE(m_ahVoices[i]), NV_PAVS_SIZE);

            MCPX_VOICE_STRUCT_WRITE(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, m_ahVoices[i]);
        }
        
        //
        // Free the notifier wrapper
        //

        m_Notifier.Free();
        
        //
        // Free the hardware voices
        //

        DPF_INFO("Voice %x (%x) freeing resources", this, m_ahVoices[0]);

        m_pMcpxApu->FreeVoices(this);

        //
        // Reset the status
        //

        and(&m_dwStatus, MCPX_VOICESTATUS_RELEASEMASK);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMixBins
 *
 *  Description:
 *      Sets the voice mix bin assignments.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::SetMixBins"

HRESULT
CMcpxVoiceClient::SetMixBins
(
    void
)
{
    DWORD                   dwVoiceBins;
    MCPX_VOICE_VOLUME       Volume;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        ConvertMixBinValues(&dwVoiceBins, &m_RegCache.CfgFMT);
        ConvertVolumeValues(&Volume);

        MCPX_CHECK_VOICE_FIFO(8 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
            MCPX_VOICE_WRITE(SetVoiceCfgVBIN, dwVoiceBins);
            MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
            MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);
            MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);
            MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
        }
    }
    
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  ConvertMixBinValues
 *
 *  Description:
 *      Converts a mixbin mask to register values.
 *
 *  Arguments:
 *      LPDWORD [out]: VoiceBin register value.
 *      LPDWORD [out]: VoiceFormat register value.  Only the low 8 bits of
 *                     this value will be modified.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::ConvertMixBinValues"

void
CMcpxVoiceClient::ConvertMixBinValues
(
    LPDWORD                 pdwVoiceBins,
    LPDWORD                 pdwVoiceFormat
)
{
    DWORD                   adwMixBins[8];
    DWORD                   i, a, b;
    
    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // The MCP-X registers are stored in a wacky format.  Instead of using a
    // 32-bit register that uses 1 bit per mixbin, they use 5-bit mixbin 
    // indeces that are stored in 30 bits of one register and 10 of another.
    //
    // The hardware gets surly if a voice is assigned to less than 8 mixbins, 
    // so we'll assign it to 8, but set the extra bins' volumes to 0.
    //
    // You'll notice that when we invent mixbins to assign the voice to,
    // they're unique.  This is to prevent a theoretical stall in the VP.
    //

    for(i = 0; i < m_pSettings->m_dwMixBinCount; i++)
    {
        adwMixBins[i] = m_pSettings->m_abMixBins[i];
    }

    a = DSMIXBIN_FIRST;

    while(i < NUMELMS(adwMixBins))
    {
        ASSERT(a <= DSMIXBIN_LAST);
        
        for(b = 0; b < i; b++)
        {
            if(a == adwMixBins[b])
            {
                break;
            }
        }

        if(b >= i)
        {
            adwMixBins[i++] = a;
        }
    
        a++;
    }            

#ifdef DEBUG

    for(i = 0; i < m_pSettings->m_dwMixBinCount; i++)
    {
        DPF_BLAB("Voice %x (%x) assigned to mixbin %lu", this, m_ahVoices[0], adwMixBins[i]);
    }

    for(; i < NUMELMS(adwMixBins); i++)
    {
        DPF_BLAB("Voice %x (%x) assigned to mixbin %lu (unused)", this, m_ahVoices[0], adwMixBins[i]);
    }

#endif // DEBUG

    *pdwVoiceBins = 0;
    
    for(i = 0; i < 3; i++)
    {
        *pdwVoiceBins |= adwMixBins[i] << (i * 5);
    }

    for(; i < 6; i++)
    {
        *pdwVoiceBins |= adwMixBins[i] << ((i * 5) + 1);
    }        

    *pdwVoiceFormat &= ~0x3FF;

    for(; i < 8; i++)
    {
        *pdwVoiceFormat |= adwMixBins[i] << ((i - 6) * 5);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the voice volume.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::SetVolume"

HRESULT
CMcpxVoiceClient::SetVolume
(
    void
)
{
    MCPX_VOICE_VOLUME       Volume;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        ConvertVolumeValues(&Volume);

        MCPX_CHECK_VOICE_FIFO(6 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
            MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);
            MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);
            MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
        }
    }
    
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  ConvertVolumeValues
 *
 *  Description:
 *      Converts volume values to register format.
 *
 *  Arguments:
 *      LPMCPX_VOICE_VOLUME [out]: volume register data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::ConvertVolumeValues"

void
CMcpxVoiceClient::ConvertVolumeValues
(
    LPMCPX_VOICE_VOLUME     pVolumeRegisters
)
{
    static const DWORD      dwMcpxMaxAttenuation                    = MCPX_GET_REG_VALUE(~0UL, NV_PAVS_VOICE_TAR_VOLA_VOLUME0);
    DWORD                   adwVolumes[MCPX_HW_MAX_VOICE_MIXBINS];

#ifndef MCPX_BOOT_LIB

    BOOL                    f3dVolume                               = FALSE;
    LONG                    l3dVolume;
    LONG                    l3dFrontDirect;
    LONG                    l3dRearDirect;
    LONG                    l3dReverbSend;

#endif // MCPX_BOOT_LIB

    DWORD                   dwPerVoiceBins;
    DWORD                   dwVoiceIndex;
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

#ifndef MCPX_BOOT_LIB

    //
    // Calculate generic 3D volume, front direct-path, rear direct-path 
    // and reverb send levels separately.  3D volume will be applied
    // to all mixbins, front to the fronts, rear to the rears and reverb
    // to the I3DL2 mixbin.
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        ASSERT(m_pSettings->m_p3dParams);

        if(DS3DMODE_DISABLE != m_pSettings->m_p3dParams->HrtfParams.dwMode)
        {
            ASSERT(m_pHrtfSource);
        
            ASSERT(m_pHrtfSource->m_3dVoiceData.lDistanceVolume <= 0);
            ASSERT(m_pHrtfSource->m_3dVoiceData.lConeVolume <= 0);
            ASSERT(m_pHrtfSource->m_3dVoiceData.lFrontVolume <= 0);
            ASSERT(m_pHrtfSource->m_3dVoiceData.lRearVolume <= 0);

            l3dVolume = m_pHrtfSource->m_3dVoiceData.lDistanceVolume + m_pHrtfSource->m_3dVoiceData.lConeVolume;
        
            l3dFrontDirect = l3dVolume + m_pHrtfSource->m_3dVoiceData.lFrontVolume + m_pI3dl2Source->m_I3dl2Data.lDirect;
            l3dFrontDirect = min(l3dFrontDirect, 0);

            l3dRearDirect = l3dVolume + m_pHrtfSource->m_3dVoiceData.lRearVolume + m_pI3dl2Source->m_I3dl2Data.lDirect;
            l3dRearDirect = min(l3dRearDirect, 0);

            l3dReverbSend = l3dVolume + m_pI3dl2Source->m_I3dl2Data.lSource;
            l3dReverbSend = min(l3dReverbSend, 0);

            f3dVolume = TRUE;
        }
    }

#endif // MCPX_BOOT_LIB

    //
    // If we're multichannel, determine which mixbins need to be muted.
    // We need to be sure that since all of our hardware voices point to
    // the same mixbins, we mute some on a per-voice basis so we don't
    // end up with multiple voices feeding the same mixbin.
    //

    ASSERT(!(m_pSettings->m_dwMixBinCount % m_bVoiceCount));
    dwPerVoiceBins = m_pSettings->m_dwMixBinCount / m_bVoiceCount;

    //
    // Enter the per-voice loop
    //

    for(dwVoiceIndex = 0; dwVoiceIndex < m_bVoiceCount; dwVoiceIndex++)
    {
        //
        // For each mixbin we're assigned to, set a volume in the array
        //

        for(i = 0; i < NUMELMS(adwVolumes); i++)
        {
            //
            // Are we using this mixbin?
            //

            if((i < (dwPerVoiceBins * dwVoiceIndex)) || (i >= (dwPerVoiceBins * (dwVoiceIndex + 1))))
            {
                adwVolumes[i] = dwMcpxMaxAttenuation;
                continue;
            }

            //
            // Start with global voice volume
            //

            ASSERT(m_pSettings->m_lVolume <= 0);
            adwVolumes[i] = -m_pSettings->m_lVolume;

            //
            // Combine mixbin-specific volume with global voice volume
            //

            ASSERT(m_pSettings->m_alMixBinVolumes[m_pSettings->m_abMixBins[i]] <= 0);
            adwVolumes[i] -= m_pSettings->m_alMixBinVolumes[m_pSettings->m_abMixBins[i]];

#ifndef MCPX_BOOT_LIB

            //
            // Add 3D attenuation
            //

            if(f3dVolume)
            {
                switch(m_pSettings->m_abMixBins[i])
                {
                    case DSMIXBIN_3D_FRONT_LEFT:
                    case DSMIXBIN_3D_FRONT_RIGHT:
                        ASSERT(l3dFrontDirect <= 0);
                        adwVolumes[i] -= l3dFrontDirect;
                        break;

                    case DSMIXBIN_3D_BACK_LEFT:
                    case DSMIXBIN_3D_BACK_RIGHT:
                        ASSERT(l3dRearDirect <= 0);
                        adwVolumes[i] -= l3dRearDirect;
                        break;

                    case DSMIXBIN_I3DL2:
                        ASSERT(l3dReverbSend <= 0);
                        adwVolumes[i] -= l3dReverbSend;
                        break;

                    default:
                        ASSERT(l3dVolume <= 0);
                        adwVolumes[i] -= l3dVolume;
                        break;
                }

                if(m_pHrtfSource->m_3dVoiceData.dwMixBinValidMask & (1UL << m_pSettings->m_abMixBins[i]))
                {
                    ASSERT(m_pHrtfSource->m_3dVoiceData.alMixBinVolumes[m_pSettings->m_abMixBins[i]] <= 0);
                    adwVolumes[i] -= m_pHrtfSource->m_3dVoiceData.alMixBinVolumes[m_pSettings->m_abMixBins[i]];
                }
            }

#endif // MCPX_BOOT_LIB

            //
            // Convert to register format
            //

            DPF_BLAB("Voice %x (%x) mixbin %lu (%lu) volume -%ld", this, m_ahVoices[dwVoiceIndex], i, m_pSettings->m_abMixBins[i], adwVolumes[i]);
            
            adwVolumes[i] <<= 6;
            adwVolumes[i] /= 100;

            CHECKRANGE(adwVolumes[i], 0, dwMcpxMaxAttenuation);
        }

        //
        // Set register values
        //

        pVolumeRegisters->TarVOLA[dwVoiceIndex] = MCPX_MAKE_REG_VALUE(adwVolumes[0], NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME0);
        pVolumeRegisters->TarVOLA[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[1], NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME1);
        pVolumeRegisters->TarVOLA[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[6], NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME6_B3_0);
        pVolumeRegisters->TarVOLA[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[7], NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME7_B3_0);

        pVolumeRegisters->TarVOLB[dwVoiceIndex] = MCPX_MAKE_REG_VALUE(adwVolumes[2], NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME2);
        pVolumeRegisters->TarVOLB[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[3], NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME3);
        pVolumeRegisters->TarVOLB[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[6] >> 4, NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME6_B7_4);
        pVolumeRegisters->TarVOLB[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[7] >> 4, NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME7_B7_4);

        pVolumeRegisters->TarVOLC[dwVoiceIndex] = MCPX_MAKE_REG_VALUE(adwVolumes[4], NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME4);
        pVolumeRegisters->TarVOLC[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[5], NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME5);
        pVolumeRegisters->TarVOLC[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[6] >> 8, NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME6_B11_8);
        pVolumeRegisters->TarVOLC[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[7] >> 8, NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME7_B11_8);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetPitch
 *
 *  Description:
 *      Sets the voice pitch.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::SetPitch"

HRESULT
CMcpxVoiceClient::SetPitch
(
    void
)
{
    PLIST_ENTRY             pleSourceVoice;
    CMcpxVoiceClient *      pSourceVoice;
    DWORD                   dwPitch;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    //
    // If we're a submix destination, we can't change our pitch.  It has to
    // stay locked at 0.  Instead, we'll update all the source voices' pitch
    // values.
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        for(pleSourceVoice = m_lstSourceVoices.Flink; pleSourceVoice != &m_lstSourceVoices; pleSourceVoice = pleSourceVoice->Flink)
        {
            AssertValidEntryList(pleSourceVoice, ASSERT_IN_LIST);

            pSourceVoice = CONTAINING_RECORD(pleSourceVoice, CMcpxVoiceClient, m_leSourceVoice);

            pSourceVoice->SetPitch();
        }
    }
    else if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        ConvertPitchValue(&dwPitch);

        MCPX_CHECK_VOICE_FIFO(2 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(SetVoiceTarPitch, dwPitch);
        }
    }
    
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  ConvertPitchValue
 *
 *  Description:
 *      Converts volume values to register format.
 *
 *  Arguments:
 *      LPDWORD [out]: pitch register.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::ConvertPitchValue"

void
CMcpxVoiceClient::ConvertPitchValue
(
    LPDWORD                 pdwPitch
)
{
    CMcpxBuffer *           pSubMixDestination;
    LONG                    lPitch;
    
    DPF_ENTER();

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If we're a submix destination, our pitch must be locked at 0.  In order 
    // to allow callers to set the pitch on submix destination voices, all
    // source voices will know to read from our pitch.
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        lPitch = 0;
    }
    else
    {
        lPitch = m_pSettings->m_lPitch;

#ifndef MCPX_BOOT_LIB

        if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
        {
            ASSERT(m_pSettings->m_p3dParams);
            ASSERT(m_pHrtfSource);
            
            if(DS3DMODE_DISABLE != m_pSettings->m_p3dParams->HrtfParams.dwMode)
            {
                lPitch += m_pHrtfSource->m_3dVoiceData.lDopplerPitch;
            }
        }

#endif // MCPX_BOOT_LIB

        if(pSubMixDestination = GetSubMixDestination())
        {
            lPitch += pSubMixDestination->m_pSettings->m_lPitch;

#ifndef MCPX_BOOT_LIB

            if(pSubMixDestination->m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
            {
                ASSERT(pSubMixDestination->m_pSettings->m_p3dParams);
                ASSERT(pSubMixDestination->m_pHrtfSource);

                if(DS3DMODE_DISABLE != pSubMixDestination->m_pSettings->m_p3dParams->HrtfParams.dwMode)
                {
                    lPitch += pSubMixDestination->m_pHrtfSource->m_3dVoiceData.lDopplerPitch;
                }
            }

#endif // MCPX_BOOT_LIB

        }

        CHECKRANGE(lPitch, DSBPITCH_MIN, DSBPITCH_MAX);
    }

    *pdwPitch = MCPX_MAKE_REG_VALUE(lPitch, NV1BA0_PIO_SET_VOICE_TAR_PITCH_STEP);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetAntecedentVoice
 *
 *  Description:
 *      Determines which voice processing list the voice should be inserted
 *      into, and at which position.
 *
 *  Arguments:
 *      LPDWORD [out]: voice list identifier.
 *      CMcpxVoiceClient ** [out]: antecedent voice.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::GetAntecedentVoice"

void
CMcpxVoiceClient::GetAntecedentVoice
(
    LPBYTE                  pbVoiceList,
    CMcpxVoiceClient **     ppAntecedentVoice
)
{
    CMcpxVoiceClient *      pSubMixDestination;
    PLIST_ENTRY             pleAntecedentVoice;
    CMcpxVoiceClient *      pAntecedentVoice;
    
    DPF_ENTER();

    if(pSubMixDestination = GetSubMixDestination())
    {
        *pbVoiceList = MCPX_VOICELIST_MP;

        AssertValidEntryList(&pSubMixDestination->m_leActiveVoice, ASSERT_IN_LIST);

        pleAntecedentVoice = pSubMixDestination->m_leActiveVoice.Blink;

        if(&m_pMcpxApu->m_alstActiveVoices[MCPX_VOICELIST_MP] == pleAntecedentVoice)
        {
            *ppAntecedentVoice = NULL;
        }
        else
        {
            *ppAntecedentVoice = CONTAINING_RECORD(pleAntecedentVoice, CMcpxVoiceClient, m_leActiveVoice);
        }
    }
    else if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
    {
        *pbVoiceList = MCPX_VOICELIST_MP;
        *ppAntecedentVoice = NULL;
    }
    else if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        *pbVoiceList = MCPX_VOICELIST_3D;
        *ppAntecedentVoice = NULL;
    }
    else
    {
        *pbVoiceList = MCPX_VOICELIST_2D;
        *ppAntecedentVoice = NULL;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ActivateVoice
 *
 *  Description:
 *      Starts the voice running.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::ActivateVoice"

void
CMcpxVoiceClient::ActivateVoice
(
    void
)
{
    BYTE                    bVoiceList;
    CMcpxBuffer *           pSubMixDestination;
    CMcpxVoiceClient *      pAntecedentVoice;
    MCPX_VOICE_HANDLE       hAntecedentVoice;
    DWORD                   dwAntecedentVoice;
    DWORD                   dwVoiceOn;
    DWORD                   dwVoicePause;
    CIrql                   irql;
    int                     i;
    
    DPF_ENTER();

    ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);

    if(!(m_dwStatus & MCPX_VOICESTATUS_ACTIVE))
    {

#ifndef MCPX_BOOT_LIB

        if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
        {
            if(!(m_pMcpxApu->m_dwState & MCPX_APUSTATE_GPIMAGE))
            {
                DPF_ERROR("No effects image has been downloaded and 3D sounds are feeding the XTLK mixbins.  Your 3D sounds will be silent");
            }
            else if(DSFX_IMAGELOC_UNUSED == m_pMcpxApu->m_pSettings->m_EffectLocations.dwCrosstalkIndex)
            {
                DPF_ERROR("Crosstalk is not in the current effects image and 3D sounds are feeding the XTLK mixbins.  Your 3D sounds will be silent");
            }
        }

#endif // MCPX_BOOT_LIB

        if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
        {
            ASSERT(!IsListEmpty(&m_lstSourceVoices));
        }
        else
        {
            ASSERT(IsListEmpty(&m_lstSourceVoices));
        }

        //
        // Just because the voice status doesn't include ACTIVE doesn't mean
        // the hardware voice is done.  Block until the voice is really 
        // finished.
        //

        WaitForVoiceOff();

        AssertValidEntryList(&m_leActiveVoice, ASSERT_NOT_IN_LIST);
        AssertValidEntryList(&m_lePendingInactiveVoice, ASSERT_NOT_IN_LIST);

        //
        // Update the status
        //
        
        or(&m_dwStatus, MCPX_VOICESTATUS_ACTIVE);

#ifndef MCPX_BOOT_LIB

        //
        // If we're 3D, make sure all 3D data is up-to-date
        //

        if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
        {
            Commit3dSettings();
        }

#endif // MCPX_BOOT_LIB

        //
        // If we're submixing, go ahead and start the destination playing 
        // now so it's in the list before we try to determine where to insert 
        // ourselves.
        //

        if(pSubMixDestination = GetSubMixDestination())
        {
            ASSERT(pSubMixDestination->m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
            
            pSubMixDestination->Play(TRUE);
        }

        //
        // Raise IRQL for synchronization
        //

        irql.Raise();
        
        //
        // Wait for the method queue to clear so we know we have enough space
        // in the FIFO for the VoiceOn method.
        //

        MCPX_CHECK_VOICE_FIFO(PIO_METHOD_QUEUE_CLEAR);

        //
        // Block the idle handler in order to prevent the voice list from
        // being modified.
        //

        m_pMcpxApu->BlockIdleHandler();

        //
        // Reset the voice notifiers
        //

        m_Notifier.Reset();

        //
        // Turn on the PERSIST bit so voices are left in the processing list 
        // until we take them out.
        //

        if(m_dwStatus & MCPX_VOICESTATUS_PERSIST)
        {
            m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST);
        }
        else
        {
            m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST);
        }

        //
        // Figure out where to insert the voice in the hardware processing 
        // list
        //

        GetAntecedentVoice(&bVoiceList, &pAntecedentVoice);

        if(pAntecedentVoice)
        {
            hAntecedentVoice = pAntecedentVoice->m_ahVoices[pAntecedentVoice->m_bVoiceCount - 1];
            ASSERT(hAntecedentVoice < MCPX_HW_MAX_VOICES);

            dwAntecedentVoice = MCPX_MAKE_REG_VALUE(hAntecedentVoice, NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE);
            dwAntecedentVoice |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_INHERIT, NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST);
        }
        else
        {
            dwAntecedentVoice = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE_NULL, NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE);
            dwAntecedentVoice |= MCPX_MAKE_REG_VALUE(bVoiceList + 1, NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST);
        }

        //
        // Turn the voice on.  If we're supposed to be paused, do that now
        // as well.  Note that we're turning the voices on in reverse order
        // so they're in the hardware processing list correctly.
        //

        MCPX_CHECK_VOICE_FIFO(7 * m_bVoiceCount);

        for(i = m_bVoiceCount - 1; i >= 0; i--)
        {
            if(pAntecedentVoice)
            {
                DPF_BLAB("Voice %x (%x) inheriting voice list position from voice %x (%x)", this, m_ahVoices[i], pAntecedentVoice, hAntecedentVoice);
            }

            dwVoiceOn = MCPX_SET_REG_VALUE(m_RegCache.VoiceOn, m_ahVoices[i], NV1BA0_PIO_VOICE_ON_HANDLE);
        
            if(m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK)
            {
                dwVoicePause = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_VOICE_PAUSE_ACTION_STOP, NV1BA0_PIO_VOICE_PAUSE_ACTION);
            }
            else
            {
                dwVoicePause = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_VOICE_PAUSE_ACTION_RESUME, NV1BA0_PIO_VOICE_PAUSE_ACTION);
            }

            dwVoicePause |= MCPX_MAKE_REG_VALUE(m_ahVoices[i], NV1BA0_PIO_VOICE_PAUSE_HANDLE);
        
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
            MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
            MCPX_VOICE_WRITE(SetAntecedentVoice, dwAntecedentVoice);
            MCPX_VOICE_WRITE(VoiceOn, dwVoiceOn);
            MCPX_VOICE_WRITE(VoicePause, dwVoicePause);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
        }

        //
        // Add the voice client object to the active voice list
        //

        if(pAntecedentVoice)
        {
            AssertValidEntryList(&pAntecedentVoice->m_leActiveVoice, ASSERT_IN_LIST);
            InsertHeadList(&pAntecedentVoice->m_leActiveVoice, &m_leActiveVoice);
        }
        else
        {
            ASSERT(bVoiceList < NUMELMS(m_pMcpxApu->m_alstActiveVoices));
            InsertHeadList(&m_pMcpxApu->m_alstActiveVoices[bVoiceList], &m_leActiveVoice);
        }

        //
        // Save the voice list index for later retrieval
        //

        ASSERT(MCPX_VOICELIST_INVALID == m_bVoiceList);
        m_bVoiceList = bVoiceList;

        //
        // Wait for the method queue to clear so we know the VoiceOn method
        // has been processed.
        //

        MCPX_CHECK_VOICE_FIFO(PIO_METHOD_QUEUE_CLEAR);

        //
        // Unblock the idle handler
        //

        m_pMcpxApu->UnblockIdleHandler();

        //
        // Lower IRQL
        //

        irql.Lower();

        //
        // All done
        //

        if(m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK)
        {
            DPF_INFO("Voice %x (%x) now active in list %x, but paused", this, m_ahVoices[0], (DWORD)bVoiceList);
        }
        else
        {
            DPF_INFO("Voice %x (%x) now active in list %x", this, m_ahVoices[0], (DWORD)bVoiceList);
        }
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  DeactivateVoice
 *
 *  Description:
 *      Stops the voice.
 *
 *  Arguments:
 *      BOOL [in]: TRUE if the voice stopped naturally.  FALSE if we're
 *                 forcibly stopping it.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::DeactivateVoice"

void
CMcpxVoiceClient::DeactivateVoice
(
    BOOL                    fBlock
)
{
    CMcpxBuffer *           pSubMixDestination;
    CMcpxVoiceClient *      pSourceVoice;
    PLIST_ENTRY             pleListEntry;
    BOOL                    fSourceValid;
    CIrql                   irql;
    DWORD                   i;
    
    DPF_ENTER();

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        DPF_INFO("Deactivating voice %x (%x)", this, m_ahVoices[0]);

        //
        // Raise IRQL for synchronization
        //

        irql.Raise();

        //
        // Block the idle handler until we're done setting the voice status
        //

        m_pMcpxApu->BlockIdleHandler();
        
        //
        // Remove pretty much everything from the status mask, since
        // most of the bits are only valid when we're active.
        //

        and(&m_dwStatus, MCPX_VOICESTATUS_DEACTIVATEMASK);

        //
        // Turn off the PERSIST bit so we're guaranteed the voice will be
        // stopped.
        //

        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST);

        //
        // There also seems to be a bug where a looping voice won't always
        // turn off, so we'll disable the looping bit while we're at it.
        //

        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP);

        //
        // Check the voice list identifier.  If it's -1, the voice has
        // already been removed from the voice list.  We'll set a bit in 
        // the status that tells us that we're still waiting for the voice 
        // to turn off.  When this happens, the ISR will clear the status 
        // bit for us.
        //

        if(m_bVoiceList < MCPX_VOICELIST_COUNT)
        {
            //
            // Turn off the voice.  It won't turn off instantly, but the VoiceOff
            // command will be in the command FIFO, so for all intents, the voice
            // really is off.  The one caveat to this is that you want to watch
            // for the VoiceOff notifier before freeing any memory associated
            // with this voice.  It's possible that the VP could access memory
            // between when the VoiceOff notifier goes into the queue and when
            // the voice is processed.
            //

            DEBUGLOG("VoiceOff %x (%x)", this, m_ahVoices[0]);

            or(&m_dwStatus, MCPX_VOICESTATUS_VOICEOFF);
            ASSERT(m_bVoiceList < MCPX_VOICELIST_COUNT);

#ifndef MCPX_SIMULATE_STUCK_VOICE

#ifdef MCPX_NO_VOICE_OFF

            DWORD LFOENV = MCPX_SET_REG_VALUE(m_RegCache.LFOENV, 1, NV1BA0_PIO_SET_VOICE_LFO_ENV_EA_RELEASERATE);
            
            MCPX_CHECK_VOICE_FIFO(4 * m_bVoiceCount);
        
            for(i = 0; i < m_bVoiceCount; i++)
            {
                MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
                MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
                MCPX_VOICE_WRITE(SetVoiceLFOENV, LFOENV);
                MCPX_VOICE_WRITE(VoiceRelease, m_ahVoices[i]);
            }

#else // MCPX_NO_VOICE_OFF

            MCPX_CHECK_VOICE_FIFO(3 * m_bVoiceCount);
        
            for(i = 0; i < m_bVoiceCount; i++)
            {
                MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
                MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
                MCPX_VOICE_WRITE(VoiceOff, m_ahVoices[i]);
            }

#endif // MCPX_NO_VOICE_OFF

#endif // MCPX_SIMULATE_STUCK_VOICE

        }
        else
        {
            ASSERT(MCPX_VOICELIST_INVALID == m_bVoiceList);
        }

        //
        // Unblock the idle handler
        //

        m_pMcpxApu->UnblockIdleHandler();

        //
        // Save the time we posted the VoiceOff request so we can make
        // the hardware handles it later.
        //
        
        KeQuerySystemTime((PLARGE_INTEGER)&m_rtVoiceOff);

        //
        // Schedule a deferred command to check for a stuck voice
        //

        if(!fBlock)
        {
            ScheduleDeferredCommand(MCPX_DEFERREDCMD_VOICE_CHECKSTUCK, 0, 0);
        }

        //
        // If we're submixing, and we're the last source voice to stop,
        // deactivate the destination voice.
        //

        if(pSubMixDestination = GetSubMixDestination())
        {
            fSourceValid = FALSE;

            for(pleListEntry = pSubMixDestination->m_lstSourceVoices.Flink; pleListEntry != &pSubMixDestination->m_lstSourceVoices; pleListEntry = pleListEntry->Flink)
            {
                AssertValidEntryList(pleListEntry, ASSERT_IN_LIST);

                pSourceVoice = CONTAINING_RECORD(pleListEntry, CMcpxVoiceClient, m_leSourceVoice);

                if((pSourceVoice->m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
                {
                    fSourceValid = TRUE;
                    break;
                }
            }

            if(!fSourceValid)
            {
                pSubMixDestination->Stop();
            }
        }

        //
        // Lower IRQL
        //

        irql.Lower();
    }
    else if(!(m_dwStatus & MCPX_VOICESTATUS_VOICEOFF))
    {
        //
        // Remove the CHECKSTUCK deferred command from the queue
        //

        RemoveDeferredCommand(MCPX_DEFERREDCMD_VOICE_CHECKSTUCK);
    }

    //
    // Block until the voice actually stops
    //

    if(fBlock)
    {
        WaitForVoiceOff();
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  RemoveIdleVoice
 *
 *  Description:
 *      Removes an idle voice from the processing list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::RemoveIdleVoice"

void
CMcpxVoiceClient::RemoveIdleVoice
(
    BOOL                    fScheduleDpc
)
{
    static const struct
    {
        DWORD               TVL;
        DWORD               CVL;
        DWORD               NVL;
    } ListRegisters[] =
    {
        { NV_PAPU_TVL2D, NV_PAPU_CVL2D, NV_PAPU_NVL2D },    // MCPX_VOICELIST_2D
        { NV_PAPU_TVL3D, NV_PAPU_CVL3D, NV_PAPU_NVL3D },    // MCPX_VOICELIST_3D
        { NV_PAPU_TVLMP, NV_PAPU_CVLMP, NV_PAPU_NVLMP },    // MCPX_VOICELIST_MP
    };

    CMcpxVoiceClient *      pPrev;
    CMcpxVoiceClient *      pNext;
    DWORD                   dwPrevVoice;
    DWORD                   dwNextVoice;
    DWORD                   dwRegister;
    DWORD                   dwTVL;
    DWORD                   dwCVL;
    DWORD                   dwNVL;
    BOOL                    fFixCVL;
    BOOL                    fFixNVL;
    DWORD                   i;

#ifdef MCPX_ENABLE_ISR_DEBUGGING

    ASSERT((KeGetCurrentIrql() > DISPATCH_LEVEL) || m_pMcpxApu->m_dwVoiceMapLock);

    AssertValidEntryList(&m_leActiveVoice, ASSERT_IN_LIST);
    ASSERT(m_bVoiceList < NUMELMS(ListRegisters));

#endif // MCPX_ENABLE_ISR_DEBUGGING

    //
    // Save the current list register values
    //

    MCPX_REG_READ(ListRegisters[m_bVoiceList].TVL, &dwTVL);
    MCPX_REG_READ(ListRegisters[m_bVoiceList].CVL, &dwCVL);
    MCPX_REG_READ(ListRegisters[m_bVoiceList].NVL, &dwNVL);

#ifdef MCPX_ENABLE_ISR_DEBUGGING

    ASSERT(!(dwTVL & 0xFFFF0000));
    ASSERT(!(dwCVL & 0xFFFF0000));
    ASSERT(!(dwNVL & 0xFFFF0000));

#endif // MCPX_ENABLE_ISR_DEBUGGING

    //
    // Determine the voice's position within the list
    //

    if(&m_pMcpxApu->m_alstActiveVoices[m_bVoiceList] == m_leActiveVoice.Blink)
    {
        pPrev = NULL;
        dwPrevVoice = NV_PAPU_FECV_VALUE_NULL;
    }
    else
    {
        pPrev = CONTAINING_RECORD(m_leActiveVoice.Blink, CMcpxVoiceClient, m_leActiveVoice);
        dwPrevVoice = (DWORD)pPrev->m_ahVoices[pPrev->m_bVoiceCount - 1];
    }

    if(&m_pMcpxApu->m_alstActiveVoices[m_bVoiceList] == m_leActiveVoice.Flink)
    {
        pNext = NULL;
        dwNextVoice = NV_PAPU_FECV_VALUE_NULL;
    }
    else
    {
        pNext = CONTAINING_RECORD(m_leActiveVoice.Flink, CMcpxVoiceClient, m_leActiveVoice);
        dwNextVoice = (DWORD)pNext->m_ahVoices[0];
    }

#ifdef MCPX_ENABLE_ISR_DEBUGGING

    //
    // Validate the list surrounding the voice to be removed
    //
    
    if(pPrev)
    {
        MCPX_VOICE_STRUCT_READ(dwPrevVoice, NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);
        ASSERT((dwRegister & 0xFFFF) == (DWORD)m_ahVoices[0]);
    }
    else
    {
        ASSERT(dwTVL == (DWORD)m_ahVoices[0]);
    }

    for(i = 0; i < (DWORD)m_bVoiceCount - 1; i++)
    {
        MCPX_VOICE_STRUCT_READ(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);
        ASSERT((dwRegister & 0xFFFF) == (DWORD)m_ahVoices[i + 1]);
    }

    MCPX_VOICE_STRUCT_READ(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);
    ASSERT((dwRegister & 0xFFFF) == dwNextVoice);

#endif // MCPX_ENABLE_ISR_DEBUGGING

    //
    // If we're at the head of the list, fix the TVL register.  If not, 
    // fix up the next voice pointer for the previous voice.
    //

    if(pPrev)
    {
        MCPX_VOICE_STRUCT_READ(dwPrevVoice, NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);

        dwRegister &= 0xFFFF0000;
        dwRegister |= dwNextVoice;

        MCPX_VOICE_STRUCT_WRITE(dwPrevVoice, NV_PAVS_VOICE_TAR_PITCH_LINK, dwRegister);
    }
    else
    {
        dwTVL = dwNextVoice;
        
        MCPX_REG_WRITE(ListRegisters[m_bVoiceList].TVL, dwTVL);
    }

    //
    // Enter the hardware voice loop
    //

    for(i = 0, fFixCVL = FALSE, fFixNVL = FALSE; i < m_bVoiceCount; i++)
    {
        //
        // Check the CVL register
        //

        if(dwCVL == (DWORD)m_ahVoices[i])
        {
            fFixCVL = TRUE;
        }

        //
        // Check the NVL register
        //

        if(dwNVL == (DWORD)m_ahVoices[i])
        {
            fFixNVL = TRUE;
        }

        //
        // Remove the voice from the hardware list by making it point to itself
        //

        MCPX_VOICE_STRUCT_READ(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);

        dwRegister &= 0xFFFF0000;
        dwRegister |= (WORD)m_ahVoices[i];
        
        MCPX_VOICE_STRUCT_WRITE(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, dwRegister);
    }

    //
    // Fix up the CVL and NVL registers
    //

    if(fFixCVL)
    {
        if(pNext)
        {
            dwCVL = dwNextVoice;

            MCPX_VOICE_STRUCT_READ(dwNextVoice, NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);
            
            dwRegister &= 0xFFFF;

            if(NV_PAPU_FECV_VALUE_NULL == dwRegister)
            {
                dwRegister = dwTVL;
            }

            dwNVL = dwRegister;
        }
        else
        {
            dwCVL = NV_PAPU_FECV_VALUE_NULL;
            dwNVL = dwTVL;
        }

        MCPX_REG_WRITE(ListRegisters[m_bVoiceList].CVL, dwCVL);
        MCPX_REG_WRITE(ListRegisters[m_bVoiceList].NVL, dwNVL);
    }
    else if(fFixNVL)
    {
        if(pNext)
        {
            dwNVL = dwNextVoice;
        }
        else
        {
            dwNVL = dwTVL;
        }

        MCPX_REG_WRITE(ListRegisters[m_bVoiceList].NVL, dwNVL);
    }

    //
    // Remove the voice client object from the active voice list
    //

    RemoveEntryList(&m_leActiveVoice);

    //
    // Reset the voice list index
    //

    m_bVoiceList = MCPX_VOICELIST_INVALID;

    //
    // If the voice realizes it's stopped before we do, either because it
    // stopped itself or because the SSL interrupt was completed before
    // the idle voice interrupt, the voice will set the VOICEOFF bit in
    // it's status, meaning that it's waiting for notification from us that
    // it's free to release it's resources.  If this bit is set, just clear
    // it.  If it's not, add the voice to the "pending inactive" list.  During
    // the ISR DPC, we'll walk both the active voice lists and the pending
    // inactive list.  This makes it safe for us to remove the voice from the
    // active voice list before the SSL interrupt is handled.
    // 

    if(m_dwStatus & MCPX_VOICESTATUS_VOICEOFF)
    {
        and(&m_dwStatus, ~MCPX_VOICESTATUS_VOICEOFF);

#ifdef MCPX_ENABLE_ISR_DEBUGGING

        DPF_INFO("Voice %x (%x) is now idle", this, m_ahVoices[0]);

#endif // MCPX_ENABLE_ISR_DEBUGGING

    }
    else
    {
        m_Notifier.SetStatus(MCPX_NOTIFIER_VOICE_OFF, TRUE);
        
        if(fScheduleDpc)
        {
            InsertTailList(&m_pMcpxApu->m_lstPendingInactiveVoices, &m_lePendingInactiveVoice);

            m_pMcpxApu->m_arInterruptStatus[0].FEVoice = TRUE;
        
            m_pMcpxApu->ScheduleApuInterruptDpc();
        }

#ifdef MCPX_ENABLE_ISR_DEBUGGING

        DPF_INFO("Voice %x (%x) is now idle, but pending SSL completion", this, m_ahVoices[0]);

#endif // MCPX_ENABLE_ISR_DEBUGGING

    }
}


/****************************************************************************
 *
 *  RemoveStuckVoice
 *
 *  Description:
 *      Removes an idle voice from the processing list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::RemoveStuckVoice"

void
CMcpxVoiceClient::RemoveStuckVoice
(
    void
)
{
    BOOL                    fIdle;
    
    DPF_ENTER();
    AutoIrql();

#ifdef MCPX_DEBUG_STUCK_VOICES

    BREAK();

#endif // MCPX_DEBUG_STUCK_VOICES

    m_dwStuckVoiceCount++;
    
    //
    // Idle the voice processor
    //

    fIdle = m_pMcpxApu->IdleVoiceProcessor(TRUE);

    //
    // Remove the stuck voice
    //

    RemoveIdleVoice(FALSE);

    //
    // Turn the VP back on
    //

    if(fIdle)
    {
        m_pMcpxApu->IdleVoiceProcessor(FALSE);
    }

    //
    // Service the voice interrupt that didn't happen
    //

    ServiceVoiceInterrupt();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ReleaseVoice
 *
 *  Description:
 *      Puts the voice into it's release phase.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::ReleaseVoice"

void
CMcpxVoiceClient::ReleaseVoice
(
    void
)
{
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        //
        // Release the voice.  We'll get an interrupt later when the voice
        // actually turns off.  Be sure the PERSIST bit is cleared so the voice
        // turns off at the end of the envelope.
        //
        
        DPF_INFO("Releasing voice %x (%x)", this, m_ahVoices[0]);

        or(&m_dwStatus, MCPX_VOICESTATUS_NOTEOFF);
        
        m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST);

        MCPX_CHECK_VOICE_FIFO(3 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
            MCPX_VOICE_WRITE(VoiceRelease, m_ahVoices[i]);
        }
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  WaitForVoiceOff
 *
 *  Description:
 *      Busy-waits for a voice that's in the process of being turned off to
 *      actually become inactive.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::WaitForVoiceOff"

void
CMcpxVoiceClient::WaitForVoiceOff
(
    void
)
{
    static BOOL             fExplained  = FALSE;
    
    DPF_ENTER();

    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        ASSERT(!(m_dwStatus & MCPX_VOICESTATUS_ACTIVE));

#ifdef DEBUG

        if(m_dwStatus & MCPX_VOICESTATUS_VOICEOFF)
        {
            if(!g_fDirectSoundDisableBusyWaitWarning)
            {
                DPF_WARNING("Busy-waiting for the voice to turn off");

                if(!fExplained)
                {
                    DPF_WARNING("This warning is being generated because you've called a method that requires");
                    DPF_WARNING("a hardware voice to be stopped.  Stopping a voice is an asynchronous");
                    DPF_WARNING("operation, so any function that requires the voice to be stopped must block");
                    DPF_WARNING("until it is.  To see an example of this, call IDirectSoundBuffer::Stop and");
                    DPF_WARNING("immediately follow it with a call to IDirectSoundBuffer::GetStatus.  Chances");
                    DPF_WARNING("are, you'll see that DSBSTATUS_PLAYING is still set.  For a list of methods");
                    DPF_WARNING("that can potentially block in this method, consult the documentation.  To");
                    DPF_WARNING("query the playing status of a buffer or stream, call the GetStatus method on");
                    DPF_WARNING("the object you wish to check.  To disable this warning, set the global");
                    DPF_WARNING("variable \"g_fDirectSoundDisableBusyWaitWarning\" to TRUE.");

                    fExplained = TRUE;
                }
            }

#endif // DEBUG
        
            while(m_dwStatus & MCPX_VOICESTATUS_VOICEOFF)
            {
                CheckStuckVoice();
            }

#ifdef DEBUG

        }

#endif // DEBUG

    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CheckStuckVoice
 *
 *  Description:
 *      Checks the amount of time that has elapsed since since a stop request
 *      was sent to the hardware.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::CheckStuckVoice"

void
CMcpxVoiceClient::CheckStuckVoice
(
    void
)
{

#ifdef MCPX_DEBUG_STUCK_VOICES

    static const REFERENCE_TIME rtTimeout   = 5000i64 * 10000i64;  // 5000ms

#else // MCPX_DEBUG_STUCK_VOICES

    static const REFERENCE_TIME rtTimeout   = 500i64 * 10000i64;   // 500ms

#endif // MCPX_DEBUG_STUCK_VOICES

    REFERENCE_TIME              rtCurrent;
    
    DPF_ENTER();

    if((m_dwStatus & MCPX_VOICESTATUS_VOICEOFFMASK) == MCPX_VOICESTATUS_VOICEOFFMASK)
    {
        //
        // We're still waiting for the voice to turn off.  Check to see how
        // long it's been since we called VoiceOff.
        //
        
        ASSERT(m_rtVoiceOff > 0);
        ASSERT(!m_pMcpxApu->m_dwVoiceMapLock);
        
        KeQuerySystemTime((PLARGE_INTEGER)&rtCurrent);

        if(rtCurrent >= m_rtVoiceOff + rtTimeout)
        {
            DPF_WARNING("Voice %x (%x) appears to be stuck.  Forcing it to turn off...", this, m_ahVoices[0]);

            RemoveStuckVoice();
        }
    }
    else
    {
        //
        // The voice is turned off.  Make sure the CHECKSTUCK deferred
        // command is removed from the queue.
        //
        
        RemoveDeferredCommand(MCPX_DEFERREDCMD_VOICE_CHECKSTUCK);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  PauseVoice
 *
 *  Description:
 *      Pauses or resumes a running voice.
 *
 *  Arguments:
 *      DWORD [in]: paused/starving status bitmask.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::PauseVoice"

void
CMcpxVoiceClient::PauseVoice
(
    DWORD                   dwStatus
)
{
    DWORD                   dwRegisterValue;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    dwStatus &= MCPX_VOICESTATUS_ALLPAUSEDMASK;

    //
    // Pause or resume the voice
    //

    if(MAKEBOOL(dwStatus) != MAKEBOOL(m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK))
    {
        if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
        {
            if(dwStatus)
            {
                dwRegisterValue = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_VOICE_PAUSE_ACTION_STOP, NV1BA0_PIO_VOICE_PAUSE_ACTION);
            }
            else
            {
                dwRegisterValue = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_VOICE_PAUSE_ACTION_RESUME, NV1BA0_PIO_VOICE_PAUSE_ACTION);
            }

            MCPX_CHECK_VOICE_FIFO(1 * m_bVoiceCount);
            
            for(i = 0; i < m_bVoiceCount; i++)
            {
                MCPX_VOICE_WRITE(VoicePause, MCPX_SET_REG_VALUE(dwRegisterValue, m_ahVoices[i], NV1BA0_PIO_VOICE_PAUSE_HANDLE));
            }
        }

        DPF_INFO("Voice %x (%x) pause state going from %x to %x", this, m_ahVoices[0], m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK, dwStatus);
    }

    //
    // Update the status
    //

    and(&m_dwStatus, ~MCPX_VOICESTATUS_ALLPAUSEDMASK);
    or(&m_dwStatus, (WORD)dwStatus);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Commit3dSettings
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: parameter mask.
 *
 ***************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::Commit3dSettings"

DWORD
CMcpxVoiceClient::Commit3dSettings
(   
    void
)
{
    DWORD                   dwParameterMask     = 0;
    DWORD                   dw3dChangeMask;
    DWORD                   dwMixBinChangeMask;
    DWORD                   dwI3dl2ChangeMask;

    DPF_ENTER();
    AutoFpState();

    ASSERT(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D);
    ASSERT(m_pSettings->m_p3dParams);
    ASSERT(m_pHrtfSource);
    ASSERT(m_pI3dl2Source);

    //
    // If the voice isn't active, don't bother doing the recalc yet.  We'll
    // do it when the voice is activated.
    //
    
    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        //
        // If the mode changed at all, a position recalculation is required.
        // This is because any change from NORMAL to HEADRELATIVE requires
        // the position recalc, but since you could go from NORMAL to 
        // DISABLED to HEADRELATIVE, we'll just take the hit.
        //
        // If we went from ENABLED to DISABLED, we don't actually want to
        // recalculate anything yet, but we do have to reset everything 3D
        // affects.
        //
        // If not, we'll go ahead and recalculate and reset the parameter
        // mask.  Because changing the mode to DISABLED doesn't clear the
        // parameter mask, any remaining changes will be recalculated and
        // applied now.
        //

        dw3dChangeMask = 0;
        dwMixBinChangeMask = 0;
        dwI3dl2ChangeMask = 0;
        
        if(m_dw3dMode != m_pSettings->m_p3dParams->HrtfParams.dwMode)
        {
            if((DS3DMODE_DISABLE == m_pSettings->m_p3dParams->HrtfParams.dwMode) != (DS3DMODE_DISABLE == m_dw3dMode))
            {
                dw3dChangeMask |= MCPX_3DAPPLY_MASK;
                dwI3dl2ChangeMask |= MCPX_I3DL2APPLY_MASK;
                dwMixBinChangeMask |= ~0UL;
            }

            m_dw3dMode = m_pSettings->m_p3dParams->HrtfParams.dwMode;
            m_pSettings->m_p3dParams->dwParameterMask |= DS3DPARAM_BUFFER_POSITION;
        }
        
        //
        // Save a local copy of the parameter mask
        //
        
        dwParameterMask |= m_pSettings->m_p3dParams->dwParameterMask;

        //
        // Recalculate and check for changes that need to be applied
        //

        if(DS3DMODE_DISABLE != m_pSettings->m_p3dParams->HrtfParams.dwMode)
        {
            m_pHrtfSource->Calculate3d(dwParameterMask);

            dw3dChangeMask |= m_pHrtfSource->m_3dVoiceData.dwChangeMask;
            dwMixBinChangeMask |= m_pHrtfSource->m_3dVoiceData.dwMixBinChangeMask;

            if(dwParameterMask & DS3DPARAM_BUFFER_I3DL2)
            {
                m_pI3dl2Source->CalculateI3dl2(m_pHrtfSource->m_3dData.flMagPos);

                dwI3dl2ChangeMask |= m_pI3dl2Source->m_I3dl2Data.dwChangeMask;
            }
        }

        Apply3dSettings(dw3dChangeMask, dwMixBinChangeMask, dwI3dl2ChangeMask);
    }
    
    DPF_LEAVE(dwParameterMask);

    return dwParameterMask;
}

#endif // MCPX_BOOT_LIB


/***************************************************************************
 *
 *  Apply3dSettings
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      DWORD [in]: parameter mask.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::Apply3dSettings"

void
CMcpxVoiceClient::Apply3dSettings
(
    DWORD                   dw3dChangeMask, 
    DWORD                   dwMixBinChangeMask, 
    DWORD                   dwI3dl2ChangeMask
)
{
    static const DWORD      dw3dVolumeMask      = MCPX_3DAPPLY_DISTANCEVOLUME | MCPX_3DAPPLY_CONEVOLUME | MCPX_3DAPPLY_FRONTVOLUME | MCPX_3DAPPLY_REARVOLUME;
    static const DWORD      dwI3dl2VolumeMask   = MCPX_I3DL2APPLY_DIRECT | MCPX_I3DL2APPLY_SOURCE;
    static const DWORD      dwPitchMask         = MCPX_3DAPPLY_DOPPLERPITCH;
    static const DWORD      dwHrtfMask          = MCPX_3DAPPLY_FILTERPAIR;
    static const DWORD      dwFilterMask        = MCPX_I3DL2APPLY_DIRECTIIR | MCPX_I3DL2APPLY_REVERBIIR;
    
    DPF_ENTER();

    if((dw3dChangeMask & dw3dVolumeMask) || (dwMixBinChangeMask) || (dwI3dl2ChangeMask & dwI3dl2VolumeMask))
    {
        SetVolume();
    }

    if(dw3dChangeMask & dwPitchMask)
    {
        SetPitch();
    }
    
    if(dw3dChangeMask & dwHrtfMask)
    {
        LoadHrtfFilter();
    }

    if(dwI3dl2ChangeMask & dwFilterMask)
    {
        SetFilter(NULL);
    }

    DPF_LEAVE_VOID();
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  LoadHrtfFilter
 *
 *  Description:
 *      Loads the HRTF filter for the voice to use.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::LoadHrtfFilter"

void
CMcpxVoiceClient::LoadHrtfFilter
(
    void
)
{
    static const FIRFILTER8     DisabledFilterData  =
    {
        { 0x00, 0x55, 0x55, 0x9F, 0x22, 0x41, 0x06, 0xA4, 0x11, 0x27, 0xAA, 0xB2, 0x2d, 0x2d, 0x09, 0x0D, 0x92, 0x96, 0x13, 0x0B, 0x9B, 0x81, 0x0D, 0x91, 0x07, 0x16, 0x05, 0x05, 0x06, 0x06, 0x02 },  0    /*  left, #1170 */
    };

    static const HRTFFILTERPAIR DisabledFilterPair  =
    {
        &DisabledFilterData,
        &DisabledFilterData
    };

    LPCHRTFFILTERPAIR           pFilterPair;
    DWORD                       dwFilterIndex;
    DWORD                       hrir;
    DWORD                       hrirx;
    LONG                        itd;
    DWORD                       i;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
    ASSERT(m_pSettings->m_p3dParams);
    ASSERT(m_pHrtfSource);

    //
    // Get pointers to the HRTF coefficients
    //
    // If we're not 3D or the 3D mode is DISABLED, we'll disable HRTF by
    // loading the coefficients for 0,0 azimuth/elevation.
    //
    // If the HRTF coefficients ever change, the filter pair used here will
    // need to be updated.
    //

    if(DS3DMODE_DISABLE == m_pSettings->m_p3dParams->HrtfParams.dwMode)
    {
        pFilterPair = &DisabledFilterPair;
    }
    else if(!m_pHrtfSource->m_3dVoiceData.FilterPair.pLeftFilter)
    {
        pFilterPair = &DisabledFilterPair;
    }
    else if(!m_pHrtfSource->m_3dVoiceData.FilterPair.pRightFilter)
    {
        pFilterPair = &DisabledFilterPair;
    }
    else
    {
        pFilterPair = &m_pHrtfSource->m_3dVoiceData.FilterPair;
    }

    //
    // Alternate between the 3D filters.  Each 3D voice actually gets 
    // allocated 2 hardware 3D filters.  This way, we can update one of
    // them while the other one is still being processed.  This prevents
    // us from stomping on the filter coefficients while the hardware is
    // in the middle of processing a frame.
    //

    ASSERT(m_bAvailable3dFilter < MCPX_HW_3DFILTERS_PER_VOICE);

    dwFilterIndex = ((DWORD)m_ahVoices[0] * MCPX_HW_3DFILTERS_PER_VOICE) + m_bAvailable3dFilter;
    m_bAvailable3dFilter = !m_bAvailable3dFilter;

    //
    // Load the coefficients
    //

    MCPX_CHECK_VOICE_FIFO(1 + (NUMELMS(pFilterPair->pLeftFilter->Coeff) - 1) / 2 + 1 + 2);

    MCPX_VOICE_WRITE(SetCurrentHRTFEntry, MCPX_MAKE_REG_VALUE(dwFilterIndex, NV1BA0_PIO_SET_CURRENT_HRTF_ENTRY_HANDLE));

    for(i = 0; i < (NUMELMS(pFilterPair->pLeftFilter->Coeff) - 1) / 2; i++)
    {
        hrir = MCPX_MAKE_REG_VALUE(pFilterPair->pLeftFilter->Coeff[i * 2], NV1BA0_PIO_SET_HRIR_LEFT0);
        hrir |= MCPX_MAKE_REG_VALUE(pFilterPair->pRightFilter->Coeff[i * 2], NV1BA0_PIO_SET_HRIR_RIGHT0);
        hrir |= MCPX_MAKE_REG_VALUE(pFilterPair->pLeftFilter->Coeff[(i * 2) + 1], NV1BA0_PIO_SET_HRIR_LEFT1);
        hrir |= MCPX_MAKE_REG_VALUE(pFilterPair->pRightFilter->Coeff[(i * 2) + 1], NV1BA0_PIO_SET_HRIR_RIGHT1);

        MCPX_VOICE_WRITE(SetHRIR[i], hrir);
    }

    hrirx = MCPX_MAKE_REG_VALUE(pFilterPair->pLeftFilter->Coeff[i * 2], NV1BA0_PIO_SET_HRIR_X_LEFT30);
    hrirx |= MCPX_MAKE_REG_VALUE(pFilterPair->pRightFilter->Coeff[i * 2], NV1BA0_PIO_SET_HRIR_X_RIGHT30);

    //
    // Set filter delay
    //

    ASSERT(m_pHrtfSource);
    
    if(m_pHrtfSource->m_3dData.flAzimuth >= 0.0f)
    {
        itd = (LONG)pFilterPair->pLeftFilter->Delay;
    }
    else
    {
        itd = -(LONG)pFilterPair->pRightFilter->Delay;
    }

    ASSERT((itd >= -42) && (itd <= 42));

    itd <<= 9;

    itd = MCPX_MAKE_REG_VALUE(itd, NV1BA0_PIO_SET_HRIR_X_ITD);

    MCPX_VOICE_WRITE(SetHRIRX, hrirx | itd);

    //
    // Tell the voice to use the coefficient we just loaded
    //

    MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[0]);
    MCPX_VOICE_WRITE(SetVoiceTarHRTF, MCPX_MAKE_REG_VALUE(dwFilterIndex, NV1BA0_PIO_SET_VOICE_TAR_HRTF_HANDLE));

    DPF_LEAVE_VOID();
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  SetLFO
 *
 *  Description:
 *      Sets parameters for one of the low-frequency occilator.
 *
 *  Arguments:
 *      LPCDSLFODESC [in]: common LFO settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::SetLFO"

HRESULT
CMcpxVoiceClient::SetLFO
(
    LPCDSLFODESC            pLfo
)
{
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Recalculate register values
    //
    
    if(DSLFO_MULTI == pLfo->dwLFO)
    {
        m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, MAKEBOOL(pLfo->dwDelay), NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOA_DELAYMODE);
        
        m_RegCache.CfgLFODLY = MCPX_SET_REG_VALUE(m_RegCache.CfgLFODLY, pLfo->dwDelay, NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOADLY);
        
        m_RegCache.LFOENV = MCPX_SET_REG_VALUE(m_RegCache.LFOENV, pLfo->dwDelta, NV1BA0_PIO_SET_VOICE_LFO_ENV_LFOADLT);
        
        m_RegCache.LFOMOD = MCPX_SET_REG_VALUE(m_RegCache.LFOMOD, pLfo->lAmplitudeModulation, NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAAM);
        m_RegCache.LFOMOD = MCPX_SET_REG_VALUE(m_RegCache.LFOMOD, pLfo->lPitchModulation, NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAFM);
        m_RegCache.LFOMOD = MCPX_SET_REG_VALUE(m_RegCache.LFOMOD, pLfo->lFilterCutOffRange, NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAFC);
    }
    else if(DSLFO_PITCH == pLfo->dwLFO)
    {
        m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, MAKEBOOL(pLfo->dwDelay), NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOF_DELAYMODE);
        
        m_RegCache.CfgLFODLY = MCPX_SET_REG_VALUE(m_RegCache.CfgLFODLY, pLfo->dwDelay, NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOFDLY);
        
        m_RegCache.LFOENV = MCPX_SET_REG_VALUE(m_RegCache.LFOENV, pLfo->dwDelta, NV1BA0_PIO_SET_VOICE_LFO_ENV_LFOFDLT);
        
        m_RegCache.LFOMOD = MCPX_SET_REG_VALUE(m_RegCache.LFOMOD, pLfo->lPitchModulation, NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOFFM);
    }
    else
    {
        ASSERTMSG("Invalid LFO identifier");
    }

    //
    // Apply changes
    //
    
    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        MCPX_CHECK_VOICE_FIFO(7 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
            MCPX_VOICE_WRITE(SetVoiceCfgMISC, m_RegCache.CfgMISC);
            MCPX_VOICE_WRITE(SetVoiceCfgLFODLY, m_RegCache.CfgLFODLY);
            MCPX_VOICE_WRITE(SetVoiceLFOENV, m_RegCache.LFOENV);
            MCPX_VOICE_WRITE(SetVoiceLFOMOD, m_RegCache.LFOMOD);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetEG
 *
 *  Description:
 *      Sets parameters for one of the envelope generators.
 *
 *  Arguments:
 *      LPCDSENVELOPEDESC [in]: common envelope settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::SetEG"

HRESULT
CMcpxVoiceClient::SetEG
(
    LPCDSENVELOPEDESC       pEnv
)
{
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Recalculate register values
    //
    
    if(DSEG_MULTI == pEnv->dwEG)
    {
        m_RegCache.VoiceOn = MCPX_SET_REG_VALUE(m_RegCache.VoiceOn, pEnv->dwMode, NV1BA0_PIO_VOICE_ON_ENVF);
        
        m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, pEnv->dwRelease, NV1BA0_PIO_SET_VOICE_CFG_MISC_EF_RELEASERATE);
        
        m_RegCache.CfgENV0 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV0, pEnv->lPitchScale, NV1BA0_PIO_SET_VOICE_CFG_ENV0_EF_PITCHSCALE);
        
        m_RegCache.CfgENV1 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV1, pEnv->dwAttack, NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_ATTACKRATE);
        m_RegCache.CfgENV1 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV1, pEnv->dwDelay, NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_DELAYTIME);
        m_RegCache.CfgENV1 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV1, pEnv->lFilterCutOff, NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_FCSCALE);
        
        m_RegCache.CfgENVF = MCPX_SET_REG_VALUE(m_RegCache.CfgENVF, pEnv->dwDecay, NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_DECAYRATE);
        m_RegCache.CfgENVF = MCPX_SET_REG_VALUE(m_RegCache.CfgENVF, pEnv->dwHold, NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_HOLDTIME);
        m_RegCache.CfgENVF = MCPX_SET_REG_VALUE(m_RegCache.CfgENVF, pEnv->dwSustain, NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_SUSTAINLEVEL);
    }
    else if(DSEG_AMPLITUDE == pEnv->dwEG)
    {
        m_RegCache.VoiceOn = MCPX_SET_REG_VALUE(m_RegCache.VoiceOn, pEnv->dwMode, NV1BA0_PIO_VOICE_ON_ENVA);

        m_RegCache.LFOENV = MCPX_SET_REG_VALUE(m_RegCache.LFOENV, pEnv->dwRelease, NV1BA0_PIO_SET_VOICE_LFO_ENV_EA_RELEASERATE);

        m_RegCache.CfgENV0 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV0, pEnv->dwAttack, NV1BA0_PIO_SET_VOICE_CFG_ENV0_EA_ATTACKRATE);
        m_RegCache.CfgENV0 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV0, pEnv->dwDelay, NV1BA0_PIO_SET_VOICE_CFG_ENV0_EA_DELAYTIME);

        m_RegCache.CfgENVA = MCPX_SET_REG_VALUE(m_RegCache.CfgENVA, pEnv->dwDecay, NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_DECAYRATE);
        m_RegCache.CfgENVA = MCPX_SET_REG_VALUE(m_RegCache.CfgENVA, pEnv->dwHold, NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_HOLDTIME);
        m_RegCache.CfgENVA = MCPX_SET_REG_VALUE(m_RegCache.CfgENVA, pEnv->dwSustain, NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_SUSTAINLEVEL);
    }
    else
    {
        ASSERTMSG("Invalid EG identifier");
    }

    //
    // Apply changes
    //
    
    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        MCPX_CHECK_VOICE_FIFO(9 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
            MCPX_VOICE_WRITE(SetVoiceCfgMISC, m_RegCache.CfgMISC);
            MCPX_VOICE_WRITE(SetVoiceCfgENV0, m_RegCache.CfgENV0);
            MCPX_VOICE_WRITE(SetVoiceCfgENVA, m_RegCache.CfgENVA);
            MCPX_VOICE_WRITE(SetVoiceCfgENV1, m_RegCache.CfgENV1);
            MCPX_VOICE_WRITE(SetVoiceCfgENVF, m_RegCache.CfgENVF);
            MCPX_VOICE_WRITE(SetVoiceLFOENV, m_RegCache.LFOENV);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  SetFilter
 *
 *  Description:
 *      Sets parameters for the filter.
 *
 *  Arguments:
 *      LPCDSFILTERDESC [in]: filter settings.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::SetFilter"

HRESULT
CMcpxVoiceClient::SetFilter
(
    LPCDSFILTERDESC         pFilter
)
{
    DSFILTERDESC            Filter;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Make a local copy of the filter data or create one based on current
    // register values.
    //

    if(pFilter)
    {
        CopyMemory(&Filter, pFilter, sizeof(*pFilter));
    }
    else
    {
        Filter.dwMode = MCPX_GET_REG_VALUE(m_RegCache.CfgMISC, NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE);
        Filter.dwQCoefficient = MCPX_GET_REG_VALUE(m_RegCache.CfgMISC, NV1BA0_PIO_SET_VOICE_CFG_MISC_BPQ);

        Filter.adwCoefficients[0] = MCPX_GET_REG_VALUE(m_RegCache.TarFCA, NV1BA0_PIO_SET_VOICE_TAR_FCA_FC0);
        Filter.adwCoefficients[1] = MCPX_GET_REG_VALUE(m_RegCache.TarFCA, NV1BA0_PIO_SET_VOICE_TAR_FCA_FC1);

        Filter.adwCoefficients[2] = MCPX_GET_REG_VALUE(m_RegCache.TarFCB, NV1BA0_PIO_SET_VOICE_TAR_FCB_FC2);
        Filter.adwCoefficients[3] = MCPX_GET_REG_VALUE(m_RegCache.TarFCB, NV1BA0_PIO_SET_VOICE_TAR_FCB_FC3);
    }

#ifndef MCPX_BOOT_LIB

    //
    // If we're 3D, hack the filter mode so I3DL2 is always turned on
    //

    if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        if(DSFILTER_MODE_BYPASS == Filter.dwMode)
        {
            Filter.dwMode = DSFILTER_MODE_MULTI;
        }
    }

#endif // MCPX_BOOT_LIB

    //
    // Recalculate register values
    //
    
    m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, Filter.dwMode, NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE);
    m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, Filter.dwQCoefficient, NV1BA0_PIO_SET_VOICE_CFG_MISC_BPQ);

    m_RegCache.TarFCA = MCPX_MAKE_REG_VALUE(Filter.adwCoefficients[0], NV1BA0_PIO_SET_VOICE_TAR_FCA_FC0);
    m_RegCache.TarFCA |= MCPX_MAKE_REG_VALUE(Filter.adwCoefficients[1], NV1BA0_PIO_SET_VOICE_TAR_FCA_FC1);

#ifndef MCPX_BOOT_LIB

    if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
    {
        ASSERT(m_pSettings->m_p3dParams);
        ASSERT(m_pI3dl2Source);
        
        if(DS3DMODE_DISABLE == m_pSettings->m_p3dParams->HrtfParams.dwMode)
        {
            m_RegCache.TarFCB = 0;
        }
        else            
        {
            m_RegCache.TarFCB = MCPX_MAKE_REG_VALUE(m_pI3dl2Source->m_I3dl2Data.nDirectIir, NV_PAVS_VOICE_CUR_FCB_FC2);
            m_RegCache.TarFCB |= MCPX_MAKE_REG_VALUE(m_pI3dl2Source->m_I3dl2Data.nReverbIir, NV_PAVS_VOICE_CUR_FCB_FC3);
        }
    }
    else

#endif // MCPX_BOOT_LIB

    {
        m_RegCache.TarFCB = MCPX_MAKE_REG_VALUE(Filter.adwCoefficients[2], NV_PAVS_VOICE_CUR_FCB_FC2);
        m_RegCache.TarFCB |= MCPX_MAKE_REG_VALUE(Filter.adwCoefficients[3], NV_PAVS_VOICE_CUR_FCB_FC3);
    }

    //
    // Apply changes
    //
    
    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        MCPX_CHECK_VOICE_FIFO(6 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
            MCPX_VOICE_WRITE(SetVoiceCfgMISC, m_RegCache.CfgMISC);
            MCPX_VOICE_WRITE(SetVoiceTarFCA, m_RegCache.TarFCA);
            MCPX_VOICE_WRITE(SetVoiceTarFCB, m_RegCache.TarFCB);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  ConnectVoice
 *
 *  Description:
 *      Sets the submix destination for this voice.
 *
 *  Arguments:
 *      CMcpxVoiceClient * [in]: destination voice.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::ConnectVoice"

HRESULT
CMcpxVoiceClient::ConnectVoice
(
    void
)
{
    CMcpxBuffer *           pSubMixDestination;
    DWORD                   dwVoiceBins;
    MCPX_VOICE_VOLUME       Volume;
    DWORD                   dwPitch;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    pSubMixDestination = GetSubMixDestination();
    ASSERT(pSubMixDestination);

    DPF_INFO("Voice %x (%x) using %x (%x) as it's submix destination", this, m_ahVoices[0], pSubMixDestination, pSubMixDestination->m_ahVoices[0]);

    //
    // Make sure we're not active.  The voice has to be turned off in order
    // to change it's position in the voice list.
    //
    
    if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)
    {
        DPF_WARNING("Voice %x (%x) is still active.  Shutting it down...", this, m_ahVoices[0]);
        DeactivateVoice();
    }

    //
    // Add us to the destination voice's list
    //

    InsertTailList(&pSubMixDestination->m_lstSourceVoices, &m_leSourceVoice);

    //
    // Update our mixbin assignments, volume and pitch
    //

    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        ConvertMixBinValues(&dwVoiceBins, &m_RegCache.CfgFMT);
        ConvertVolumeValues(&Volume);
        ConvertPitchValue(&dwPitch);

        MCPX_CHECK_VOICE_FIFO(9 * m_bVoiceCount);
        
        for(i = 0; i < m_bVoiceCount; i++)
        {
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
            MCPX_VOICE_WRITE(SetVoiceCfgVBIN, dwVoiceBins);
            MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
            MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);
            MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);
            MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);
            MCPX_VOICE_WRITE(SetVoiceTarPitch, dwPitch);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  DisconnectVoice
 *
 *  Description:
 *      Disconnects this voice from a submix chain.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::DisconnectVoice"

HRESULT
CMcpxVoiceClient::DisconnectVoice
(
    void
)
{
    CMcpxBuffer *           pSubMixDestination;
    DWORD                   dwVoiceBins;
    MCPX_VOICE_VOLUME       Volume;
    DWORD                   dwPitch;
    HRESULT                 hr;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    if(pSubMixDestination = GetSubMixDestination())
    {
        //
        // Remove ourselves from the destination voices's list
        //

        RemoveEntryList(&m_leSourceVoice);

        DPF_INFO("Voice %x (%x) disconnected submix from %x (%x)", this, m_ahVoices[0], pSubMixDestination, pSubMixDestination->m_ahVoices[0]);

        //
        // Update our mixbin assignments, volume and pitch
        //

        if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
        {
            ConvertMixBinValues(&dwVoiceBins, &m_RegCache.CfgFMT);
            ConvertVolumeValues(&Volume);
            ConvertPitchValue(&dwPitch);

            MCPX_CHECK_VOICE_FIFO(9 * m_bVoiceCount);
            
            for(i = 0; i < m_bVoiceCount; i++)
            {
                MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
                MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
                MCPX_VOICE_WRITE(SetVoiceCfgVBIN, dwVoiceBins);
                MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
                MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);
                MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);
                MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);
                MCPX_VOICE_WRITE(SetVoiceTarPitch, dwPitch);
                MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);
            }
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  GetSslPosition
 *
 *  Description:
 *      Gets the current SSL play cursor position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: cursor position, in bytes.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxVoiceClient::GetSslPosition"

DWORD
CMcpxVoiceClient::GetSslPosition
(
    void
)
{
    DWORD                   dwPlayCursor    = 0;
    DWORD                   dwState;
    
    DPF_ENTER();
    AutoIrql();

    //
    // There's two ways to query the hardware for current position.  We could 
    // use the "recommended" way and poke a position request register, wait for 
    // an interrupt, then get the current position out of a notifier.  Or, we
    // could go the simple route and just look at the voice structure.  NVidia
    // doesn't like this solution because they want to be able to change the
    // voice structure without modifying any driver code.  Our part won't change,
    // and the driver could be modified either way.  Hm... let's see... I think
    // I prefer the lesser amount of code and no interrupts.
    //
    // We're locking the voice so we don't query the voice structure while the
    // APU is writing to it.  It's possible we could read partially written
    // data.
    // 

    if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)
    {
        //
        // Check for the NEW_VOICE bit in the voice state.  The hardware 
        // doesn't update the position register until the first frame has 
        // been processed.
        //

        MCPX_VOICE_STRUCT_READ(m_ahVoices[m_bVoiceCount - 1], NV_PAVS_VOICE_PAR_STATE, &dwState);

        if(!MCPX_GET_REG_VALUE(dwState, NV_PAVS_VOICE_PAR_STATE_NEW_VOICE))
        {
            MCPX_CHECK_VOICE_FIFO(3);
        
            MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[0]);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);
            MCPX_VOICE_STRUCT_READ(m_ahVoices[0], NV_PAVS_VOICE_PAR_OFFSET, &dwPlayCursor);
            MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

            dwPlayCursor = MCPX_GET_REG_VALUE(dwPlayCursor, NV_PAVS_VOICE_PAR_OFFSET_CBO);
            dwPlayCursor = SamplesToBytes(dwPlayCursor);
        }
    }

    DPF_LEAVE(dwPlayCursor);

    return dwPlayCursor;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpxhw.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpxhw.h
 *  Content:    MCP-X hardware definitions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __MCPXHW_H__
#define __MCPXHW_H__

#include "nv_papu.h"
#include "nv_uap.h"

#define MCPX_HW_PCI_VENDOR_ID 0x10DE
#define MCPX_HW_PCI_DEVICE_ID 0x01B0

//
// DONT CHANGE SCRATCH SIZES WITHOUT CHANGING XGPIMAGE\DSP.h and DSP\INCLUDE\IO.H!!!!!
// dsp code depends on the value for the EP input dma
//

#define MCPX_GLOBAL_PROC_SCRATCH_SIZE              DSP_AUDIO_DATA_SCRATCHOFFSET  

//
// FX can potentially use up to a megabyte of scratch space
//

#define MCPX_HW_MAX_FX_SCRATCH_PAGES               512

//
// DSP memory spaces are addressable from within the mcpx register space
// the offsets fo GP p, x and y mem are below
//

#define MCPX_HW_GPXMEM_REG_OFFSET (XPCICFG_APU_MEMORY_REGISTER_BASE_0+0x30000)
#define MCPX_HW_GPYMEM_REG_OFFSET (XPCICFG_APU_MEMORY_REGISTER_BASE_0+0x36000)
#define MCPX_HW_GPPMEM_REG_OFFSET (XPCICFG_APU_MEMORY_REGISTER_BASE_0+0x3A000)

//
// internal DSP offsets, in words
//
#define MCPX_HW_GPMEMOFSET_MIXBIN00                 0x1400      // VP mixbins are mapped to offset 0x1400 of GP X mem.

#define MCPX_HW_MAX_NOTIFIERS (MCPX_HW_MAX_VOICES * 4 + 2)
#define MCPX_HW_NOTIFIERS_PER_VOICE 4

#define MCPX_SW_DEFAULT_HRTF_HEADROOM 4
#define MCPX_HW_DEFAULT_TRACKING 0xFFF

//
// encode proc output buffer defines
//

#define MCPX_HW_EP_STEP_SIZE    256
#define AC3_BUFFER_COUNT        2      // so we can ping-pong
#define AC3_FRAME_SIZE          MCPX_HW_EP_STEP_SIZE
#define AC3_CONTAINER_SIZE      4
#define AC3_NUM_CHANNELS        6
#define MCPX_HW_AC3_NUM_INPUT_PAGES     (((AC3_BUFFER_COUNT * AC3_FRAME_SIZE * AC3_CONTAINER_SIZE * AC3_NUM_CHANNELS) + PAGE_SIZE-1)  / PAGE_SIZE)

//
// multipass buffer pages
//

#define MCPX_HW_MULTIPASS_NUM_PAGES ((((DSMIXBIN_FXSEND_LAST-DSMIXBIN_FXSEND_FIRST+1)*128)+PAGE_SIZE-1)/PAGE_SIZE)

//
// Misc MCP-X values
//

#define MCPX_MAX_VOICE_CHANNELS             3
                                                
#define MCPX_ALIGN_16K                      0x4000
                                            
#define MCPX_MAX_VALID_ADDRESS              0x8000000
                                            
#define MCPX_BASEFREQ                       48000
#define MCPX_BASEFREQF                      48000.0f
#define MCPX_ONEOVERBASEFREQ                2.0833333333333E-5f
                                            
#define MCPX_HW_MAX_VOICES                  256
#define MCPX_HW_MAX_3D_VOICES               64
#define MCPX_HW_MAX_2D_VOICES               (MCPX_HW_MAX_VOICES - MCPX_HW_MAX_3D_VOICES)

#define MCPX_HW_FIRST_3D_VOICE              0
#define MCPX_HW_FIRST_2D_VOICE              MCPX_HW_MAX_3D_VOICES
                                            
#define MCPX_HW_MAX_PRD_ENTRIES_PER_SSL     16
#define MCPX_HW_SSLS_PER_VOICE              2
#define MCPX_HW_MAX_PRD_ENTRIES_PER_VOICE   (MCPX_HW_MAX_PRD_ENTRIES_PER_SSL * MCPX_HW_SSLS_PER_VOICE)
#define MCPX_HW_MAX_SSL_PRDS                (MCPX_HW_MAX_VOICES * MCPX_HW_MAX_PRD_ENTRIES_PER_VOICE)

#define MCPX_HW_3DFILTERS_PER_VOICE         2

#define MCPX_HW_MAX_SUBMIX_BINS             32

#define MCPX_HW_MAX_BUFFER_PRDS             2048

#define MCPX_HW_FRAME_SIZE_SAMPLES          32
#define MCPX_HW_FRAME_LENGTH_US             667

#define MCPX_HW_MAX_VOICE_MIXBINS           8

///////////////////////////////////////////////////////////////////////////////
//
// list of methods that the RM will write to the
// output Q in the scratch memory, for communication
// with the GP
//
///////////////////////////////////////////////////////////////////////////////

/*
NV_OGP_SET_EFFECT - Method to set an effect in the GP

NV_OGP_SET_EFFECT_INDEX - Index of the effect that has changed.  The GP
whould use this index to access the Effect_Control in the scratch memory
NV_OGP_SET_EFFECT_OPERATION_RESET - A new effect has been requested by the
client.  The GP should pull this effect into the p-mem.  All information
reguired by the GP will be present in the Effect_Control[Index].
NV_OGP_SET_EFFECT_OPERATION_ENABLE - An already loaded effect has been
enabled
NV_OGP_SET_EFFECT_OPERATION_DISABLE - An already loaded effect has been
disabled
NV_OGP_SET_EFFECT_OFFSET - Offset in scratch memory, of the effect control.
This offset need only be accessed on NV_OGP_SET_EFFECT_OPERATION_RESET.
*/

#define NV_OGP_SET_EFFECT                           0x00000001
#define NV_OGP_SET_EFFECT_INDEX                     15:0
#define NV_OGP_SET_EFFECT_OPERATION                 31:16
#define NV_OGP_SET_EFFECT_OPERATION_RESET           0x0
#define NV_OGP_SET_EFFECT_OPERATION_ENABLE          0x1
#define NV_OGP_SET_EFFECT_OPERATION_DISABLE         0x2
#define NV_OGP_SET_EFFECT_OFFSET                    63:32

/*
NV_OGP_SET_AC3_OUTPUT_BUFFER - method to set the AC3 output buffer offset

NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_ENABLE - the buffer described by the size
and offset is valid.  The GP should start putting de-interleaved data in it
NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_DISABLE - a previously configured AC3 output
buffer is not valid, the GP should stop putting data in it
NV_OGP_SET_AC3_OUTPUT_BUFFER_SIZE - buffer size in bytes
NV_OGP_SET_AC3_OUTPUT_BUFFER_OFFSET - offset of the buffer in GP scratch
*/

#define NV_OGP_SET_AC3_OUTPUT_BUFFER                0x00000002
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER           0:0
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_ENABLE    0x1
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_DISABLE   0x0
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_SIZE           31:16
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_OFFSET         63:32

///////////////////////////////////////////////////////////////////////////////
//
// data structures
//
///////////////////////////////////////////////////////////////////////////////

#pragma pack (push, _store_)
#pragma pack (1)

// interrupt registers
typedef union
{
	struct
	{	
		ULONG General		: 1;
		ULONG DeltaWarning : 1;
		ULONG RetriggerEvent : 1;		/* not in INTERRUPT_ENABLE  */
		ULONG DeltaPanic	: 1;
		ULONG FETrap		: 1;
		ULONG FENotify		: 1;
		ULONG FEVoice		: 1;
		ULONG FEMethodOverFlow : 1;
		ULONG GPMailbox	: 1;
		ULONG GPNotify		: 1;
		ULONG EPMailbox	: 1;
		ULONG EPNotify		: 1;
		ULONG				: 21;
	};
	
	ULONG uValue;
} R_INTR;

// front end
typedef union
{
	struct
	{	
		ULONG NotifyISO	: 1;
		ULONG ReadISO		: 1;
		ULONG WriteISO		: 1;
		ULONG TrapOnNotifier : 1;
		ULONG Lock			: 1;
		ULONG Mode			: 3;
		ULONG TrapReason	: 4;
        ULONG PIOClass     : 1;
        ULONG EnableLock   : 1;
		ULONG MethodOrigin : 1;
		ULONG ValidSESSL   : 1;
		ULONG ValidSESGE   : 1;
		ULONG ValidGPSGE   : 1;
		ULONG				: 14;
	};
	
	ULONG uValue;
} R_FE_CONTROL;

// setup engine
typedef union
{
	struct
	{	
		ULONG ReadISO		: 1;
		ULONG WriteISO		: 1;
		ULONG SampleReadISO : 1;
		ULONG GSCUpdate	: 2;
		ULONG DeltaWarn	: 1;
		ULONG Retriggered	: 1;
		ULONG DeltaPanic	: 1;
		ULONG				: 24;
	};
	
	ULONG uValue;
} R_SE_CONTROL;

typedef union
{
	struct
	{	
		ULONG Global   : 1;
		ULONG DSP      : 1;
		ULONG NMI      : 1;
		ULONG Abort   	: 1;
		ULONG          : 28;
	};
	
	ULONG uValue;
} R_GP_RESET;

typedef union
{
	struct
	{	
		ULONG Start		: 1;
		ULONG Ready		: 1;
		ULONG ReqIOC       : 1;
		ULONG ReqEOL   	: 1;
		ULONG ReqErr	    : 1;
		ULONG				: 27;
	};
	
	ULONG uValue;
} R_GPDMA_CONFIG;

typedef union
{
	struct
	{	
		ULONG Idle         : 1;
		ULONG Stopped      : 1;
		ULONG EnableStop   : 1;
		ULONG IntrNotify   : 1;
		ULONG				: 28;
	};
	
	ULONG uValue;
} R_GP_CONTROL;

typedef struct
{
    ULONG  uAddr;

    union
    {
        struct
        {
            ULONG Length   : 16;
            ULONG ContSize : 2;
            ULONG Samples  : 5;
            ULONG Stereo   : 1;
            ULONG Owner    : 1;
            ULONG          : 6;
            ULONG Intr     : 1;
        };

        ULONG uValue;
    }Control;

} MCP1_PRD;

// word format for DSP commands

typedef union
{
    struct
    {
        ULONG nextCommand    : 14;
        ULONG EOL            : 1;
        ULONG                : 17;
    } field;

    ULONG uValue;
} WORD0;

typedef union
{
    struct
    {
        ULONG interleave     : 1;
        ULONG dspToSys       : 1;
        ULONG IOC            : 2;
        ULONG smOffWrBack    : 1;
        ULONG smBufId        : 4;
        ULONG iso            : 1;
        ULONG smDataFormat   : 3;
        ULONG                : 1;
        ULONG increment      : 11;
        ULONG                : 7;
    } field;

    ULONG uValue;
} WORD1;

typedef union
{
    struct
    {
        ULONG count0     : 4;
        ULONG count1     : 10;
        ULONG            : 18;
    } field;

    ULONG uValue;
} WORD2;

typedef union
{
    struct
    {
        ULONG dspStart   : 14;
        ULONG nul        : 1;
        ULONG            : 17;
    } field;

    ULONG uValue;
} WORD3;

typedef union
{
    struct
    {
        ULONG smOffset   : 24;
        ULONG            : 8;
    } field;

    ULONG uValue;
} WORD4;

typedef union
{
    struct
    {
        ULONG smBaseAddr : 24;
        ULONG            : 8;
    } field;

    ULONG uValue;
} WORD5;

typedef union
{
    struct
    {
        ULONG smSizeMinus1   : 24;
        ULONG                : 8;
    } field;

    ULONG uValue;
} WORD6;

typedef struct
{
    WORD0 w0;
    WORD1 w1;
    WORD2 w2;
    WORD3 w3;
} DSP_CONTROL;

#define INCR(x,limit)		(((x) < ((limit)-1))?((x)++):0)
#define DECR(x,limit)		((x)?((x)--):((limit)-1))

#define APU_INVALID_METHOD		0xFFFF

typedef volatile struct _MCPX_HW_NOTIFICATION
{
	ULONG	GSCNT;
	ULONG	CurrentOffset;
	ULONG	Zero;
	UCHAR	Res0;
	UCHAR	SamplesAvailable;       // not in sync
	UCHAR	EnvelopeActive;         // not in sync
	UCHAR	Status;
} MCPX_HW_NOTIFICATION, *PMCPX_HW_NOTIFICATION;

#define NV1BA0_NOTIFICATION_STATUS_DONE_SUCCESS       0x01
#define NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS        0x80

#define LOW16(x)								(USHORT)(0x0000ffff & (ULONG)(x))
#define LOW08(x)								(UCHAR)(0x000000ff & (ULONG)(x))

#define MIN(x,y)								(((x)<(y))?(x):(y))
#define MAX(x,y)								(((x)>(y))?(x):(y))

// codec defines
#define ACI_OFFSET                              0x100
#define MIXER_OFFSET                            0x000

// revision IDs of the hardware
#define REV_MCP1								0xA1

// sizes of various HW structures (in bytes)
// #define SIZEOF_PRD                              8
// #define SIZEOF_VOICE                            128
#define SIZEOF_TARGET_HRTF                      64
#define SIZEOF_CURRENT_HRTF                     96

// all EP methods are in NV_PAPU_NV1BA0 + PIO_EP_OFFSET
#define PIO_EP_OFFSET                           0x8000

// all debug methods are in NV_PAPU_NV1BA0 + PIO_DEBUG_OFFSET
#define PIO_DEBUG_OFFSET                        0x4000

// maximum PIOFree value (formatted for method count -- real max value is 0x80)
#define PIO_METHOD_QUEUE_CLEAR                  0x20

#pragma pack (pop, _store_)

//
// voice processor register defines
//

#define VPPIOFREE DWORD volatile
#define VPPIOINFO DWORD volatile
#define VPDMAPUT DWORD volatile
#define VPDMAGET DWORD volatile
#define VPNOOPERATION DWORD volatile
#define VPSYNCHRONIZE DWORD volatile
#define VPSETTIME DWORD volatile
#define VPSETPROCESSORMODE DWORD volatile
#define VPSETANTECEDENTVOICE DWORD volatile
#define VPVOICEON DWORD volatile
#define VPVOICEOFF DWORD volatile
#define VPVOICERELEASE DWORD volatile
#define VPVOICEPAUSE DWORD volatile
#define VPSETCONTEXTDMANOTIFY DWORD volatile
#define VPGETVOICEPOSITION DWORD volatile
#define VPSETSUBMIXHEADROOM DWORD volatile
#define VPSETHRTFHEADROOM DWORD volatile
#define VPSETHRTFSUBMIX DWORD volatile
#define VPSETHRTFSUBMIXES DWORD volatile
#define VPSETVOLUMETRACKING DWORD volatile
#define VPSETPITCHTRACKING DWORD volatile
#define VPSETHRTFTRACKING DWORD volatile
#define VPSETITDTRACKING DWORD volatile
#define VPSETFILTERTRACKING DWORD volatile
#define VPSETCURRENTVOICE DWORD volatile
#define VPVOICELOCK DWORD volatile
#define VPSETVOICECFGVBIN DWORD volatile
#define VPSETVOICECFGFMT DWORD volatile
#define VPSETVOICECFGENV0 DWORD volatile
#define VPSETVOICECFGENVA DWORD volatile
#define VPSETVOICECFGENV1 DWORD volatile
#define VPSETVOICECFGENVF DWORD volatile
#define VPSETVOICECFGMISC DWORD volatile
#define VPSETVOICETARHRTF DWORD volatile
#define VPSETVOICECFGLFODLY DWORD volatile
#define VPSETVOICESSLA DWORD volatile
#define VPSETVOICESSLB DWORD volatile
#define VPSETVOICECFGBUFBASE DWORD volatile
#define VPSETVOICECFGBUFLBO DWORD volatile
#define VPSETVOICEBUFCBOFRAC DWORD volatile
#define VPSETVOICEBUFCBO DWORD volatile
#define VPSETVOICECFGBUFEBO DWORD volatile
#define VPSETVOICETARVOLA DWORD volatile
#define VPSETVOICETARVOLB DWORD volatile
#define VPSETVOICETARVOLC DWORD volatile
#define VPSETVOICELFOENV DWORD volatile
#define VPSETVOICELFOMOD DWORD volatile
#define VPSETVOICETARFCA DWORD volatile
#define VPSETVOICETARFCB DWORD volatile
#define VPSETVOICETARPITCH DWORD volatile
#define VPSETCURRENTHRTFENTRY DWORD volatile
#define VPSETHRIR DWORD volatile
#define VPSETHRIRX DWORD volatile
#define VPSETCURRENTSSLCONTEXTDMA DWORD volatile
#define VPSETCURRENTSSL DWORD volatile
#define VPSETSSLSEGMENTOFFSET DWORD volatile
#define VPSETSSKSEGMENTLENGTH DWORD volatile
#define VPSETCURRENTINBUFSGECONTEXTDMA DWORD volatile
#define VPSETCURRENTINBUFSGE DWORD volatile
#define VPSETCURRENTINBUFSGEOFFSET DWORD volatile
#define VPSETOUTBUFLEN DWORD volatile
#define VPSETOUTBUFBA DWORD volatile
#define VPSETCURRENTOUTBUFSGE DWORD volatile
#define VPSETCURRENTOUTBUFSGECONTEXTDMA DWORD volatile
#define VPSETOUTBUFSGEOFFSET DWORD volatile

#define VPSETSGEVOICENUMHACK DWORD volatile
#define VPSETSGEFULLLENHACK DWORD volatile
#define VPSETSGEADDRHACK DWORD volatile

#define VPSTARTRMDMA DWORD volatile

BEGIN_DEFINE_STRUCT()

    DWORD Reserved0000[4];                     // 0x0000 - 0x000C
    VPPIOFREE PIOFree;                         // 0x0010
    VPPIOINFO PIOInfo;                         // 0x0014
    DWORD Reserved2[10];                       // 0x0018 - 0x003C
    VPDMAPUT DMAPut;                           // 0x0040
    VPDMAGET DMAGet;                           // 0x0044
    DWORD Reserved0048[46];                    // 0x0048 - 0x00FC
    VPNOOPERATION NoOperation;                 // 0x0100
    VPSYNCHRONIZE Synchronize;                 // 0x0104
    VPSETTIME SetTime;                         // 0x0108
    VPSETPROCESSORMODE SetProcessorMode;       // 0x010C
    DWORD Reserved0110[4];                     // 0x0110 - 0x011C
    VPSETANTECEDENTVOICE SetAntecedentVoice;   // 0x0120
    VPVOICEON VoiceOn;                         // 0x0124
    VPVOICEOFF VoiceOff;                       // 0x0128
    VPVOICERELEASE VoiceRelease;               // 0x012C
    VPGETVOICEPOSITION GetVoicePosition;       // 0x0130
    DWORD Reserved0134[3];                     // 0x0134 - 0x13f
    VPVOICEPAUSE VoicePause;                   // 0x0140
    DWORD Reserved0144[7];                     // 0x0144 - 0x15c
    VPSETCURRENTHRTFENTRY SetCurrentHRTFEntry; // 0x0160
    DWORD Reserved0164[7];                     // 0x0164 - 0x017f
    VPSETCONTEXTDMANOTIFY SetContextDMANotify; // 0x0180
    DWORD Reserved0184[2];                     // 0x0184 - 0x018B
    VPSETCURRENTSSLCONTEXTDMA SetCurrentSSLContextDMA; // 0x018C
    VPSETCURRENTSSL SetCurrentSSL;             // 0x0190
    DWORD Reserved0194[27];                    // 0x0194 - 0x01fc
    VPSETSUBMIXHEADROOM SetSubMixHeadroom[32]; // 0x0200 - 0x027C
    VPSETHRTFHEADROOM SetHRTFHeadroom;         // 0x0280
    DWORD Reserved0284[3];                     // 0x0284 - 0x028C
    VPSETHRTFSUBMIX SetHRTFSubmix[4];          // 0x0290 - 0x029C
    VPSETVOLUMETRACKING SetVolumeTracking;     // 0x02A0
    VPSETPITCHTRACKING SetPitchTracking;       // 0x02A4
    VPSETHRTFTRACKING SetHRTFTracking;         // 0x02A8
    VPSETITDTRACKING SetITDTracking;           // 0x02AC
    VPSETFILTERTRACKING SetFilterTracking;     // 0x02B0
    DWORD Reserved02B4[3];                     // 0x02B4 - 0x02BC
    VPSETHRTFSUBMIXES SetHRTFSubmixes;         // 0x02C0
    DWORD Reserved02C4[13];                    // 0x02C4 - 0x02F4
    VPSETCURRENTVOICE SetCurrentVoice;         // 0x02F8
    VPVOICELOCK VoiceLock;                     // 0x02FC
    VPSETVOICECFGVBIN SetVoiceCfgVBIN;         // 0x0300
    VPSETVOICECFGFMT SetVoiceCfgFMT;           // 0x0304
    VPSETVOICECFGENV0 SetVoiceCfgENV0;         // 0x0308
    VPSETVOICECFGENVA SetVoiceCfgENVA;         // 0x030C
    VPSETVOICECFGENV1 SetVoiceCfgENV1;         // 0x0310
    VPSETVOICECFGENVF SetVoiceCfgENVF;         // 0x0314
    VPSETVOICECFGMISC SetVoiceCfgMISC;         // 0x0318
    VPSETVOICETARHRTF SetVoiceTarHRTF;         // 0x031C
    VPSETVOICESSLA SetVoiceSSLA;               // 0x0320
    DWORD Reserved0324[11];                    // 0x0324 - 0x034C
    VPSETVOICECFGLFODLY SetVoiceCfgLFODLY;     // 0x0350
    DWORD Reserved0354[2];                     // 0x0354 - 0x0358
    VPSETVOICESSLB SetVoiceSSLB;               // 0x035C
    VPSETVOICETARVOLA SetVoiceTarVOLA;         // 0x0360
    VPSETVOICETARVOLB SetVoiceTarVOLB;         // 0x0364
    VPSETVOICETARVOLC SetVoiceTarVOLC;         // 0x0368
    VPSETVOICELFOENV SetVoiceLFOENV;           // 0x036C
    VPSETVOICELFOMOD SetVoiceLFOMOD;           // 0x0370
    VPSETVOICETARFCA SetVoiceTarFCA;           // 0x0374
    VPSETVOICETARFCB SetVoiceTarFCB;           // 0x0378
    VPSETVOICETARPITCH SetVoiceTarPitch;       // 0x037C
    DWORD Reserved0360[8];                     // 0x0380 - 0x039C
    VPSETVOICECFGBUFBASE SetVoiceCfgBufBase;   // 0x03A0
    VPSETVOICECFGBUFLBO SetVoiceCfgBufLBO;     // 0x03A4
    DWORD Reserved03A8[11];                    // 0x03A8 - 0x03D0
    VPSETVOICEBUFCBOFRAC SetVoiceBufCBOFrac;   // 0x03D4
    VPSETVOICEBUFCBO SetVoiceBufCBO;           // 0x03D8
    VPSETVOICECFGBUFEBO SetVoiceCfgBufEBO;     // 0x03DC
    DWORD Reserved03E0[8];                     // 0x03E0 - 0x03FC
    VPSETHRIR SetHRIR[15];                     // 0x0400 - 0x0438
    VPSETHRIRX SetHRIRX;                       // 0x043C
    DWORD Reserved0440[112];                   // 0x0440 - 0x05FC
    struct {
        VPSETSSLSEGMENTOFFSET Offset;          // 0x0600 - 0x07F8
        VPSETSSKSEGMENTLENGTH Length;          // 0x0604 - 0x07FC
    } SetSSLSegment[64];                       // 0x0600 - 0x07FC
    VPSETCURRENTINBUFSGECONTEXTDMA SetCurrentInBufSGEContextDMA; // 0x0800
    VPSETCURRENTINBUFSGE SetCurrentInBufSGE;   // 0x0804
    VPSETCURRENTINBUFSGEOFFSET SetCurrentInBufSGEOffset; // 0x0808
    DWORD Reserved080C[509];                   // 0x080C - 0x0FFC
    struct {
        VPSETOUTBUFBA  BA;                     // 0x1000 - 0x1018
        VPSETOUTBUFLEN Len;                    // 0x1004 - 0x101C
    } SetOutBuf[4];                            // 0x1000 - 0x101C
    DWORD Reserved1020[504];                   // 0x1020 - 0x17FC
    VPSETCURRENTOUTBUFSGE SetCurrentOutBufSGE; // 0x1800
    VPSETCURRENTOUTBUFSGECONTEXTDMA SetCurrentOutBufSGEContextDMA; // 0x1804
    VPSETOUTBUFSGEOFFSET SetOutBufSGEOffset;   // 0x1808

    VPSETSGEVOICENUMHACK  SetSGEVoiceNumHack;  // 0x180c  --- Not a real function (trace use only)
    VPSETSGEFULLLENHACK  SetSGEFullLenHack;    // 0x1810  --- Not a real function (trace use only)
    VPSETSGEADDRHACK  SetSGEAddrHack;          // 0x1814  --- Not a real function (trace use only)

    DWORD Reserved1818[2554];                  // 0x1818 - 0x3fff

END_DEFINE_STRUCT(MCPXVPREGSET);

#endif // __MCPXHW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\nv_papu.h ===
/*  FILE: nv_papu.h
 *  CREATED: Mon Nov 20 07:59:00 2000
 *
 *  Copyright (c) 2000, by NVIDIA CORP
 *  All Rights Reserved.
 */

 /*** DO NOT EDIT, THIS FILE GENERATED FROM ../../../manuals/dev_apu.ref ***/


#ifndef __NV_PAPU_H__
#define __NV_PAPU_H__


/***********************************************/
/* Macros and constants                        */
/***********************************************/

#ifndef REF_VAL
#define DRF_SHIFT(drf)    ((0?drf) % 32)
#define DRF_MASK(drf)     (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define REF_VAL(drf,v)    (((v)>>DRF_SHIFT(drf))&DRF_MASK(drf))
#define REF_NUM(drf,n)    (((n)&DRF_MASK(drf))<<DRF_SHIFT(drf))
#endif /* !REF_VAL */

/***********************************************/
/*    #defines from the manuals                */
/***********************************************/

#define NV_PAVS                                            0x0000007F:0x00000000 /* RW--D */
#define NV_PAVS_SIZE                                       0x00000080 /* RW--V */
#define NV_PAVS_SIZE_LG2                                   0x7 /* RW--V */
#define NV_PAVS_VOICE_CFG_00                               0x00000000 /* */ 
#define NV_PAVS_VOICE_CFG_VBIN                             0x00000000 /* -W-4R */
#define NV_PAVS_VOICE_CFG_VBIN_V0BIN                       4:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V1BIN                       9:5 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V2BIN                       14:10 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V3BIN                       20:16 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V4BIN                       25:21 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V5BIN                       30:26 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT                              0x00000004 /* -W-4R */
#define NV_PAVS_VOICE_CFG_FMT_V6BIN                        4:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT_V7BIN                        9:5 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT_V6PHASE                      10:10 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_V6PHASE_POSITIVE             0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_V6PHASE_NEGATIVE             0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_V7PHASE                      11:11 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_V7PHASE_POSITIVE             0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_V7PHASE_NEGATIVE             0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_GAIN                         12:12 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_GAIN_X1                      0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_GAIN_X2                      0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM                     15:13 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC0_FLT0           0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT0           0x04 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT1           0x05 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT2           0x06 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT3           0x07 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLES_PER_BLOCK            20:16 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT_MULTIPASS_BIN__ALIAS__       20:16 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT_MULTIPASS                    21:21 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_MULTIPASS_OFF                0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_MULTIPASS_ON                 0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_LINKED_VOICE                 22:22 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_LINKED_VOICE_OFF             0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_LINKED_VOICE_ON              0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_PERSIST                      23:23 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_PERSIST_OFF                  0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_PERSIST_ON                   0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_DATA_TYPE                    24:24 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_DATA_TYPE_BUFFER             0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_DATA_TYPE_STREAM             0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_LOOP                         25:25 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_LOOP_OFF                     0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_LOOP_ON                      0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX                    26:26 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX_FALSE              0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX_TRUE               0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_STEREO                       27:27 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_STEREO_DISABLE               0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_STEREO_ENABLE                0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE                  29:28 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE_U8               0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE_S16              0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE_S24              0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE_S32              0x03 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE               31:30 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE_B8            0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE_B16           0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM         0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE_B32           0x03 /* -W--V */
#define NV_PAVS_VOICE_CFG_ENV0                             0x00000008 /* -W-4R */
#define NV_PAVS_VOICE_CFG_ENV0_EA_ATTACKRATE               11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV0_EA_DELAYTIME                23:12 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV0_EF_PITCHSCALE               31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVA                             0x0000000C /* -W-4R */
#define NV_PAVS_VOICE_CFG_ENVA_EA_DECAYRATE                11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVA_EA_HOLDTIME                 23:12 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVA_EA_SUSTAINLEVEL             31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV1                             0x00000010 /* -W-4R */
#define NV_PAVS_VOICE_CFG_ENV1_EF_ATTACKRATE               11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV1_EF_DELAYTIME                23:12 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV1_EF_FCSCALE                  31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVF                             0x00000014 /* -W-4R */
#define NV_PAVS_VOICE_CFG_ENVF_EF_DECAYRATE                11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVF_EF_HOLDTIME                 23:12 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVF_EF_SUSTAINLEVEL             31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_MISC                             0x00000018 /* -W-4R */
#define NV_PAVS_VOICE_CFG_MISC_EF_RELEASERATE              11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_MISC_LFOA_DELAYMODE              14:14 /* -W-VF */
#define NV_PAVS_VOICE_CFG_MISC_LFOA_DELAYMODE_NORMAL       0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_LFOA_DELAYMODE_DELAY        0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_LFOF_DELAYMODE              15:15 /* -W-VF */
#define NV_PAVS_VOICE_CFG_MISC_LFOF_DELAYMODE_NORMAL       0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_LFOF_DELAYMODE_DELAY        0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE                       17:16 /* -W-VF */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_BYPASS                0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_STEREO_DLS2           0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_STEREO_P_EQ           0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_MONO_DLS2             0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_MONO_P_EQ             0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_MONO_DLS2_P_EQ        0x03 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_THREED_DLS2_I3DL2     0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_THREED_P_EQ_I3DL2     0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_THREED_I3DL2          0x03 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_BPQ                         20:18 /* -W-UF */
#define NV_PAVS_VOICE_CFG_MISC_NOTIFY_INTERRUPT            23:23 /* -W-VF */
#define NV_PAVS_VOICE_CFG_MISC_NOTIFY_INTERRUPT_DISABLE    0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_NOTIFY_INTERRUPT_ENABLE     0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_V_GSCNT                     31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_HRTF_TARGET                      0x0000001C /* -W-4R */
#define NV_PAVS_VOICE_CFG_HRTF_TARGET_HANDLE               15:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSL_START                        0x00000020 /* -W-4R */
#define NV_PAVS_VOICE_CUR_PSL_START_BA                     23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSL_START_SSLA_COUNT             7:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSL_START_SSLA_BASE              23:8 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSL_START_PS_7_0                 31:24 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE                       0x00000024 /* -W-4R */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE_LBO                   23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE_CSI                   7:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE_CSSL                  23:8 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE_PS_15_8               31:24 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLA                             0x00000028 /* -W-4R */
#define NV_PAVS_VOICE_CUR_VOLA_VOLUME6_B3_0                3:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLA_VOLUME0                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLA_VOLUME7_B3_0                19:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLA_VOLUME1                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLB                             0x0000002C /* -W-4R */
#define NV_PAVS_VOICE_CUR_VOLB_VOLUME6_B7_4                3:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLB_VOLUME2                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLB_VOLUME7_B7_4                19:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLB_VOLUME3                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLC                             0x00000030 /* -W-4R */
#define NV_PAVS_VOICE_CUR_VOLC_VOLUME6_B11_8               3:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLC_VOLUME4                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLC_VOLUME7_B11_8               19:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLC_VOLUME5                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_CUR_ECNT                             0x00000034 /* -W-4R */
#define NV_PAVS_VOICE_CUR_ECNT_EACOUNT                     15:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_ECNT_EFCOUNT                     31:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PRD                              0x00000038 /* -W-4R */
#define NV_PAVS_VOICE_CUR_PRD_ADDRESS                      31:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FCA                              0x0000003C /* -W-4R */
#define NV_PAVS_VOICE_CUR_FCA_FC0                          15:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FCA_FC1                          31:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FCB                              0x00000040 /* -W-4R */
#define NV_PAVS_VOICE_CUR_FCB_FC2                          15:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FCB_FC3                          31:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSA                              0x00000044 /* -W-4R */
#define NV_PAVS_VOICE_CUR_FSA_FS0                          23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSA_FS3_B7_0                     31:24 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSB                              0x00000048 /* -W-4R */
#define NV_PAVS_VOICE_CUR_FSB_FS1                          23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSB_FS3_B15_8                    31:24 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSC                              0x0000004C /* -W-4R */
#define NV_PAVS_VOICE_CUR_FSC_FS2                          23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSC_FS3_B23_16                   31:24 /* -W-UF */
#define NV_PAVS_VOICE_PAR_LFO                              0x00000050 /* -W-4R */
#define NV_PAVS_VOICE_PAR_LFO_LFOALVL                      14:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_LFO_LFOADR                       15:15 /* -W-UF */
#define NV_PAVS_VOICE_PAR_LFO_LFOFLVL                      30:16 /* -W-UF */
#define NV_PAVS_VOICE_PAR_LFO_LFOFDR                       31:31 /* -W-UF */
#define NV_PAVS_VOICE_PAR_STATE                            0x00000054 /* -W-4R */
#define NV_PAVS_VOICE_PAR_STATE_FRACTION                   15:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_STATE_LFOA_DELAYMODE             16:16 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_LFOA_DELAYMODE_NORMAL      0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_LFOA_DELAYMODE_DELAY       0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_LFOF_DELAYMODE             17:17 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_LFOF_DELAYMODE_NORMAL      0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_LFOF_DELAYMODE_DELAY       0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_PAUSED                     18:18 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_PAUSED_NO                  0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_PAUSED_YES                 0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_SSL_INDICATOR              19:19 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_SSL_INDICATOR_A            0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_SSL_INDICATOR_B            0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_NEW_VOICE                  20:20 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_NEW_VOICE_NO               0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_NEW_VOICE_YES              0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE               21:21 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE_NO            0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE_YES           0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_VOICE_START                22:22 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_VOICE_START_LOOPED         0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_VOICE_START_FIRSTPASS      0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_PRD_VALID                  23:23 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_PRD_VALID_NO               0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_PRD_VALID_YES              0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR                      27:24 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_OFF                  0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_DELAY                0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_ATTACK               0x02 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_HOLD                 0x03 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_DECAY                0x04 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_SUSTAIN              0x05 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_RELEASE              0x06 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_FORCE_RELEASE        0x07 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR                      31:28 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_OFF                  0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_DELAY                0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_ATTACK               0x02 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_HOLD                 0x03 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_DECAY                0x04 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_SUSTAIN              0x05 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_RELEASE              0x06 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_FORCE_RELEASE        0x07 /* -W--V */
#define NV_PAVS_VOICE_PAR_OFFSET                           0x00000058 /* -W-4R */
#define NV_PAVS_VOICE_PAR_OFFSET_CBO                       23:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_OFFSET_CSO                       23:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_OFFSET_EALVL                     31:24 /* -W-UF */
#define NV_PAVS_VOICE_PAR_NEXT                             0x0000005C /* -W-4R */
#define NV_PAVS_VOICE_PAR_NEXT_SSLB_COUNT                  7:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_NEXT_SSLB_BASE                   23:8 /* -W-UF */
#define NV_PAVS_VOICE_PAR_NEXT_EBO                         23:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_NEXT_EFLVL                       31:24 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLA                             0x00000060 /* -W-4R */
#define NV_PAVS_VOICE_TAR_VOLA_VOLUME6_B3_0                3:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLA_VOLUME0                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLA_VOLUME7_B3_0                19:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLA_VOLUME1                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLB                             0x00000064 /* -W-4R */
#define NV_PAVS_VOICE_TAR_VOLB_VOLUME6_B7_4                3:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLB_VOLUME2                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLB_VOLUME7_B7_4                19:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLB_VOLUME3                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLC                             0x00000068 /* -W-4R */
#define NV_PAVS_VOICE_TAR_VOLC_VOLUME6_B11_8               3:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLC_VOLUME4                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLC_VOLUME7_B11_8               19:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLC_VOLUME5                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_ENV                          0x0000006C /* -W-4R */
#define NV_PAVS_VOICE_TAR_LFO_ENV_EA_RELEASERATE           11:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_ENV_LFOADLT                  21:12 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_ENV_LFOFDLT                  31:22 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_MOD                          0x00000070 /* -W-4R */
#define NV_PAVS_VOICE_TAR_LFO_MOD_LFOAAM                   7:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_MOD_LFOAFM                   15:8 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_MOD_LFOAFC                   23:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_MOD_LFOFFM                   31:24 /* -W-UF */
#define NV_PAVS_VOICE_TAR_FCA                              0x00000074 /* -W-4R */
#define NV_PAVS_VOICE_TAR_FCA_FC0                          15:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_FCA_FC1                          31:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_FCB                              0x00000078 /* -W-4R */
#define NV_PAVS_VOICE_TAR_FCB_FC2                          15:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_FCB_FC3                          31:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_PITCH_LINK                       0x0000007c /* -W-4R */
#define NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE     15:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_PITCH_LINK_PITCH                 31:16 /* -W-UF */
#define NV_PAHRTFC                                         0x0000035F:0x00000300 /* RW--D */
#define NV_PAHRTFC_SIZE                                    0x00000080 /* RW--V */
#define NV_PAHRTFC_SIZE_LG2                                0x7 /* RW--V */
#define NV_PAHRTFC_HRIR12A(i)                              (0x00000300+(i)*12) /* -W-4A */
#define NV_PAHRTFC_HRIR12A__SIZE_1                         7 /* */ 
#define NV_PAHRTFC_HRIR12A_LEFT0                           11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12A_RIGHT0                          23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12A_LEFT1_B7_0                      31:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12B(i)                              (0x00000304+(i)*12) /* -W-4A */
#define NV_PAHRTFC_HRIR12B__SIZE_1                         7 /* */ 
#define NV_PAHRTFC_HRIR12B_LEFT2                           11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12B_RIGHT2                          23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12B_RIGHT1_B11_8                    27:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12B_LEFT1_B11_8                     31:28 /* -W-UF */
#define NV_PAHRTFC_HRIR12C(i)                              (0x00000308+(i)*12) /* -W-4A */
#define NV_PAHRTFC_HRIR12C__SIZE_1                         7 /* */ 
#define NV_PAHRTFC_HRIR12C_LEFT3                           11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12C_RIGHT3                          23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12C_RIGHT1_B7_0                     31:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12D                                 0x00000354 /* -W-4R */
#define NV_PAHRTFC_HRIR12D_LEFT28                          11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12D_RIGHT28                         23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12D_LEFT29_B7_0                     31:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12E                                 0x00000358 /* -W-4R */
#define NV_PAHRTFC_HRIR12E_LEFT30                          11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12E_RIGHT30                         23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12E_RIGHT29_B11_8                   27:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12E_LEFT29_B11_8                    31:28 /* -W-UF */
#define NV_PAHRTFC_HRIR12X                                 0x0000035C /* -W-4R */
#define NV_PAHRTFC_HRIR12X_ITD                             15:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12X_RIGHT29_B7_0                    31:24 /* -W-UF */
#define NV_PAHRTFT                                         0x000003AF:0x00000380 /* RW--D */
#define NV_PAHRTFT_SIZE                                    0x00000040 /* RW--V */
#define NV_PAHRTFT_SIZE_LG2                                0x6 /* RW--V */
#define NV_PAHRTFT_HRIR8A(i)                               (0x00000380+(i)*4) /* -W-4A */
#define NV_PAHRTFT_HRIR8A__SIZE_1                          15 /* */ 
#define NV_PAHRTFT_HRIR8A_LEFT0                            7:0 /* -W-UF */
#define NV_PAHRTFT_HRIR8A_RIGHT0                           15:8 /* -W-UF */
#define NV_PAHRTFT_HRIR8A_LEFT1                            23:16 /* -W-UF */
#define NV_PAHRTFT_HRIR8A_RIGHT1                           31:24 /* -W-UF */
#define NV_PAHRTFT_HRIR8X                                  0x000003BC /* -W-4R */
#define NV_PAHRTFT_HRIR8X_LEFT30                           7:0 /* -W-UF */
#define NV_PAHRTFT_HRIR8X_RIGHT30                          15:8 /* -W-UF */
#define NV_PAHRTFT_HRIR8X_ITD                              31:16 /* -W-UF */
#define NV_PSSL                                            0x00001FFF:0x00001000 /* RW--D */
#define NV_PSSL_SIZE                                       0x00001000 /* RW--V */
#define NV_PSSL_SIZE_LG2                                   0xc /* RW--V */
#define NV_PSSL_PRD_ADDRESS(i)                             (0x00001000+(i)*8) /* -W-4A */
#define NV_PSSL_PRD_ADDRESS__SIZE_1                        512 /* */ 
#define NV_PSSL_PRD_ADDRESS_PARAMETER                      31:0 /* -W-UF */
#define NV_PSSL_PRD_CONTROL(i)                             (0x00001004+(i)*8) /* -W-4A */
#define NV_PSSL_PRD_CONTROL__SIZE_1                        512 /* */ 
#define NV_PSSL_PRD_CONTROL_LENGTH                         15:0 /* -W-UF */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE                 17:16 /* -W-VF */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE_B8              0x00 /* -W--V */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE_B16             0x01 /* -W--V */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE_ADPCM           0x02 /* -W--V */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE_B32             0x03 /* -W--V */
#define NV_PSSL_PRD_CONTROL_SAMPLES_PER_BLOCK              22:18 /* -W-UF */
#define NV_PSSL_PRD_CONTROL_STEREO                         23:23 /* -W-VF */
#define NV_PSSL_PRD_CONTROL_STEREO_NOTOK                   0x00 /* -W--V */
#define NV_PSSL_PRD_CONTROL_STEREO_OK                      0x01 /* -W--V */
#define NV_PSSL_PRD_CONTROL_OWN                            24:24 /* -W-VF */
#define NV_PSSL_PRD_CONTROL_OWN_HW                         0x00 /* -W--V */
#define NV_PSSL_PRD_CONTROL_OWN_NOT_HW                     0x01 /* -W--V */
#define NV_PSSL_PRD_CONTROL_IOC                            31:31 /* -W-VF */
#define NV_PSSL_PRD_CONTROL_IOC_DISABLE                    0x00 /* -W--V */
#define NV_PSSL_PRD_CONTROL_IOC_ENABLE                     0x01 /* -W--V */
#define NV_PSGE_SIZE                                       0x00000008 /* RW--V */
#define NV_PSGE_SIZE_LG2                                   0x3 /* RW--V */
#define NV_PAPU_BITS                                       18:0 /* RW--F */
#define NV_PAPU_W                                          19 /* RW--V */
#define NV_PAPU_SAVED_BITS                                 18:2 /* RW--F */
#define NV_PAPU_SAVED_W                                    17 /* RW--V */
#define NV_PAPU_SUBSPACE_BITS                              18:16 /* RW--F */
#define NV_PAPU_SUBSPACE_PRIV                              0x00000000 /* RW--V */
#define NV_PAPU_SUBSPACE_NV1BA0                            0x00000002 /* RW--V */
#define NV_PAPU_SUBSPACE_GP                                0x00000003 /* RW--V */
#define NV_PAPU_SUBSPACE_NV1BXX                            0x00000004 /* RW--V */
#define NV_PAPU_SUBSPACE_EP                                0x00000005 /* RW--V */
#define NV_PAPU_PRIV_BITS                                  15:0 /* RW--F */
#define NV_PAPU_PRIV_SAVED_BITS                            15:2 /* RW--F */
#define NV_PAPU_PRIV_SAVED_W                               14 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_BITS                          15:12 /* RW--F */
#define NV_PAPU_PRIV_SUBUNIT_CFG                           0x00000000 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_FE                            0x00000001 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_SE                            0x00000002 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_SE_GP                         0x00000003 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_SE_EP                         0x00000004 /* RW--V */
#define NV_PAPU_NV1BA0_BITS                                15:0 /* RW--F */
#define NV_PAPU                                            0x0007FFFF:0x00000000 /* RW--D */
#define NV_PAPU_PRIV                                       0x0000FFFF:0x00000000 /* RW--M */
#define NV_PAPU_NV1BA0                                     0x0002FFFF:0x00020000 /* RW--C */
#define NV_PAPU_GP                                         0x0003FFFF:0x00030000 /* RW--M */
#define NV_PAPU_NV1BXX                                     0x0004FFFF:0x00040000 /* RW--C */
#define NV_PAPU_EP                                         0x0005FFFF:0x00050000 /* RW--M */
#define NV_PAPU_ISTS                                       0x00001000 /* RW-4R */
#define NV_PAPU_ISTS_GINTSTS                               0:0 /* R--VF */
#define NV_PAPU_ISTS_GINTSTS_NO_INTR                       0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_GINTSTS_INTR                          0x00000001 /* R---V */
#define NV_PAPU_ISTS_DWINTSTS                              1:1 /* RW-VF */
#define NV_PAPU_ISTS_DWINTSTS_NO_INTR                      0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_DWINTSTS_INTR                         0x00000001 /* R---V */
#define NV_PAPU_ISTS_DWINTSTS_CLR                          0x00000001 /* -W--V */
#define NV_PAPU_ISTS_RTWSTS                                2:2 /* R--VF */
#define NV_PAPU_ISTS_RTWSTS_NO_INTR                        0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_RTWSTS_INTR                           0x00000001 /* R---V */
#define NV_PAPU_ISTS_DPINTSTS                              3:3 /* RW-VF */
#define NV_PAPU_ISTS_DPINTSTS_NO_INTR                      0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_DPINTSTS_INTR                         0x00000001 /* R---V */
#define NV_PAPU_ISTS_DPINTSTS_CLR                          0x00000001 /* -W--V */
#define NV_PAPU_ISTS_FETINTSTS                             4:4 /* RW-VF */
#define NV_PAPU_ISTS_FETINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_FETINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_FETINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_FENINTSTS                             5:5 /* RW-VF */
#define NV_PAPU_ISTS_FENINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_FENINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_FENINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_FEVINTSTS                             6:6 /* RW-VF */
#define NV_PAPU_ISTS_FEVINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_FEVINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_FEVINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_FEOINTSTS                             7:7 /* RW-VF */
#define NV_PAPU_ISTS_FEOINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_FEOINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_FEOINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_GPMINTSTS                             8:8 /* RW-VF */
#define NV_PAPU_ISTS_GPMINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_GPMINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_GPMINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_GPNINTSTS                             9:9 /* RW-VF */
#define NV_PAPU_ISTS_GPNINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_GPNINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_GPNINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_EPMINTSTS                             10:10 /* RW-VF */
#define NV_PAPU_ISTS_EPMINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_EPMINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_EPMINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_EPNINTSTS                             11:11 /* RW-VF */
#define NV_PAPU_ISTS_EPNINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_EPNINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_EPNINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_BITS                                  11:0 /* RW-VF */
#define NV_PAPU_ISTS_MOD_BITS                              11:1 /* RW-VF */
#define NV_PAPU_ISTS_MOD_UPPER_BITS                        11:3 /* RW-VF */
#define NV_PAPU_ISTS_MOD_LOWER_BITS                        1:1 /* RW-VF */
#define NV_PAPU_IEN                                        0x00001004 /* RW-4R */
#define NV_PAPU_IEN_GINTEN                                 0:0 /* R--VF */
#define NV_PAPU_IEN_GINTEN_DISABLED                        0x00000000 /* RWI-V */
#define NV_PAPU_IEN_GINTEN_ENABLED                         0x00000001 /* RW--V */
#define NV_PAPU_IEN_DWINTEN                                1:1 /* RW-VF */
#define NV_PAPU_IEN_DWINTEN_DISABLED                       0x00000000 /* RWI-V */
#define NV_PAPU_IEN_DWINTEN_ENABLED                        0x00000001 /* RW--V */
#define NV_PAPU_IEN_DPINTEN                                3:3 /* RW-VF */
#define NV_PAPU_IEN_DPINTEN_DISABLED                       0x00000000 /* RWI-V */
#define NV_PAPU_IEN_DPINTEN_ENABLED                        0x00000001 /* RW--V */
#define NV_PAPU_IEN_FETINTEN                               4:4 /* RW-VF */
#define NV_PAPU_IEN_FETINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_FETINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_FENINTEN                               5:5 /* RW-VF */
#define NV_PAPU_IEN_FENINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_FENINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_FEVINTEN                               6:6 /* RW-VF */
#define NV_PAPU_IEN_FEVINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_FEVINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_FEOINTEN                               7:7 /* RW-VF */
#define NV_PAPU_IEN_FEOINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_FEOINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_GPMINTEN                               8:8 /* RW-VF */
#define NV_PAPU_IEN_GPMINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_GPMINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_GPNINTEN                               9:9 /* RW-VF */
#define NV_PAPU_IEN_GPNINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_GPNINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_EPMINTEN                               10:10 /* RW-VF */
#define NV_PAPU_IEN_EPMINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_EPMINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_EPNINTEN                               11:11 /* RW-VF */
#define NV_PAPU_IEN_EPNINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_EPNINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_BITS                                   11:0 /* RW-VF */
#define NV_PAPU_IEN_SETTABLE_MASK                          0x00000ffb /* RW--V */
#define NV_PAPU_ISET                                       0x00001008 /* -W-4R */
#define NV_PAPU_ISET_DWINTSET                              1:1 /* -W-VF */
#define NV_PAPU_ISET_DWINTSET_NO_INTR                      0x00000000 /* -W--V */
#define NV_PAPU_ISET_DWINTSET_INTR                         0x00000001 /* -W--V */
#define NV_PAPU_ISET_DPINTSET                              3:3 /* -W-VF */
#define NV_PAPU_ISET_DPINTSET_NO_INTR                      0x00000000 /* -W--V */
#define NV_PAPU_ISET_DPINTSET_INTR                         0x00000001 /* -W--V */
#define NV_PAPU_ISET_FETINTSET                             4:4 /* -W-VF */
#define NV_PAPU_ISET_FETINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_FETINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_FENINTSET                             5:5 /* -W-VF */
#define NV_PAPU_ISET_FENINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_FENINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_FEVINTSET                             6:6 /* -W-VF */
#define NV_PAPU_ISET_FEVINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_FEVINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_FEOINTSET                             7:7 /* -W-VF */
#define NV_PAPU_ISET_FEOINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_FEOINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_GPMINTSET                             8:8 /* -W-VF */
#define NV_PAPU_ISET_GPMINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_GPMINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_GPNINTSET                             9:9 /* -W-VF */
#define NV_PAPU_ISET_GPNINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_GPNINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_EPMINTSET                             10:10 /* -W-VF */
#define NV_PAPU_ISET_EPMINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_EPMINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_EPNINTSET                             11:11 /* -W-VF */
#define NV_PAPU_ISET_EPNINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_EPNINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_BITS                                  11:1 /* RW-VF */
#define NV_PAPU_PRIV_FEMAJ_BITS                            11:8 /* RW--F */
#define NV_PAPU_PRIV_FEMAJ_INTR                            0x00000000 /* RW--V */
#define NV_PAPU_PRIV_FEMAJ_METH                            0x00000001 /* RW--V */
#define NV_PAPU_PRIV_FEMAJ_PERF                            0x00000002 /* RW--V */
#define NV_PAPU_PRIV_FEMAJ_INTERNAL                        0x00000003 /* RW--V */
#define NV_PAPU_PRIV_FEMAJ_UMETHFIFO                       0x00000004 /* RW--V */
#define NV_PAPU_PRIV_FEMIN_BITS                            7:0 /* RW--F */
#define NV_PAPU_FECTL                                      0x00001100 /* RW-4R */
#define NV_PAPU_FECTL_FENTYP                               0:0 /* RW-VF */
#define NV_PAPU_FECTL_FENTYP_NON_ISO                       0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FENTYP_ISO                           0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMRTYP                              1:1 /* RW-VF */
#define NV_PAPU_FECTL_FEMRTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEMRTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMWTYP                              2:2 /* RW-VF */
#define NV_PAPU_FECTL_FEMWTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEMWTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FENINT                               3:3 /* RW-VF */
#define NV_PAPU_FECTL_FENINT_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FENINT_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMETHMODE                           7:5 /* RW-VF */
#define NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING              0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEMETHMODE_HALTED                    0x00000004 /* RW--V */
#define NV_PAPU_FECTL_FEMETHMODE_TRAPPED                   0x00000007 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON                         11:8 /* RW-VF */
#define NV_PAPU_FECTL_FETRAPREASON_NONE                    0x00000000 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED         0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN          0x00000002 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT            0x00000003 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET         0x00000004 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET      0x00000005 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE           0x00000007 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER        0x00000008 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D    0x00000009 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID           0x0000000a /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_REQUESTED               0x0000000f /* RW--V */
#define NV_PAPU_FECTL_FEPIOCLASS                           12:12 /* RW-VF */
#define NV_PAPU_FECTL_FEPIOCLASS_NON_ISO                   0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEPIOCLASS_ISO                       0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMETH_PRIVLOCK                      13:13 /* RW-VF */
#define NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED         0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEMETH_PRIVLOCK_DISABLED             0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FECVLOCK                             14:14 /* RW-VF */
#define NV_PAPU_FECTL_FECVLOCK_UNLOCKED                    0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FECVLOCK_LOCKED                      0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMETHORIGIN                         15:15 /* R--VF */
#define NV_PAPU_FECTL_FEMETHORIGIN_USER                    0x00000000 /* R---V */
#define NV_PAPU_FECTL_FEMETHORIGIN_INTERNAL                0x00000001 /* R---V */
#define NV_PAPU_FECTL_FESESSLCTXPA_VALID                   16:16 /* R--VF */
#define NV_PAPU_FECTL_FESESSLCTXPA_VALID_NO                0x00000000 /* R-I-V */
#define NV_PAPU_FECTL_FESESSLCTXPA_VALID_YES               0x00000001 /* R---V */
#define NV_PAPU_FECTL_FESESGECTXPA_VALID                   17:17 /* R--VF */
#define NV_PAPU_FECTL_FESESGECTXPA_VALID_NO                0x00000000 /* R-I-V */
#define NV_PAPU_FECTL_FESESGECTXPA_VALID_YES               0x00000001 /* R---V */
#define NV_PAPU_FECTL_FEGPSGECTXPA_VALID                   18:18 /* R--VF */
#define NV_PAPU_FECTL_FEGPSGECTXPA_VALID_NO                0x00000000 /* R-I-V */
#define NV_PAPU_FECTL_FEGPSGECTXPA_VALID_YES               0x00000001 /* R---V */
#define NV_PAPU_FECTL_BITS                                 18:0 /* RW-VF */
#define NV_PAPU_FECTL_WR_BITS                              14:0 /* RW-VF */
#define NV_PAPU_FEMAXV                                     0x00001104 /* RW-4R */
#define NV_PAPU_FEMAXV_VALUE                               15:0 /* RWXUF */
#define NV_PAPU_FEMAXV_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXV_BITS                                15:0 /* RW-VF */
#define NV_PAPU_FEMAXTV                                    0x00001108 /* RW-4R */
#define NV_PAPU_FEMAXTV_VALUE                              15:0 /* RWXUF */
#define NV_PAPU_FEMAXTV_INIT                               0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXTV_BITS                               15:0 /* RW-VF */
#define NV_PAPU_FEAMAXV                                    0x0000110c /* R--4R */
#define NV_PAPU_FEAMAXV_VALUE                              15:0 /* R-XUF */
#define NV_PAPU_FEAMAXV_UNLIMITED                          0x0000ffff /* R---V */
#define NV_PAPU_FEAMAXV_BITS                               15:0 /* R--VF */
#define NV_PAPU_FECV                                       0x00001110 /* RW-4R */
#define NV_PAPU_FECV_VALUE                                 15:0 /* RWXUF */
#define NV_PAPU_FECV_VALUE_NULL                            0x0000ffff /* RWI-V */
#define NV_PAPU_FECV_BITS                                  15:0 /* RW-VF */
#define NV_PAPU_FECVDT                                     0x00001114 /* RW-4R */
#define NV_PAPU_FECVDT_DATA_TYPE                           1:0 /* RWXUF */
#define NV_PAPU_FECVDT_DATA_TYPE_BUFFER                    0x00000000 /* RW--V */
#define NV_PAPU_FECVDT_DATA_TYPE_STREAM                    0x00000001 /* RW--V */
#define NV_PAPU_FECVDT_DATA_TYPE_UNCACHED                  0x00000002 /* RWI-V */
#define NV_PAPU_FECVDT_CONTAINER_SIZE                      3:2 /* RWXUF */
#define NV_PAPU_FECVDT_CONTAINER_SIZE_B8                   0x00000000 /* RWI-V */
#define NV_PAPU_FECVDT_CONTAINER_SIZE_B16                  0x00000001 /* RW--V */
#define NV_PAPU_FECVDT_CONTAINER_SIZE_ADPCM                0x00000002 /* RW--V */
#define NV_PAPU_FECVDT_CONTAINER_SIZE_B32                  0x00000003 /* RW--V */
#define NV_PAPU_FECVDT_BITS                                3:0 /* RW-VF */
#define NV_PAPU_FEAV                                       0x00001118 /* RW-4R */
#define NV_PAPU_FEAV_VALUE                                 15:0 /* RWXUF */
#define NV_PAPU_FEAV_VALUE_NULL                            0x0000ffff /* RWI-V */
#define NV_PAPU_FEAV_LST                                   17:16 /* RWXUF */
#define NV_PAPU_FEAV_LST_INHERIT                           0x00000000 /* RWI-V */
#define NV_PAPU_FEAV_LST_2D_TOP                            0x00000001 /* RW--V */
#define NV_PAPU_FEAV_LST_3D_TOP                            0x00000002 /* RW--V */
#define NV_PAPU_FEAV_LST_MP_TOP                            0x00000003 /* RW--V */
#define NV_PAPU_FEAV_BITS                                  17:0 /* RW-VF */
#define NV_PAPU_FEMAXHT                                    0x0000111c /* RW-4R */
#define NV_PAPU_FEMAXHT_VALUE                              15:0 /* RWXUF */
#define NV_PAPU_FEMAXHT_INIT                               0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXHT_BITS                               15:0 /* RW-VF */
#define NV_PAPU_FECHT                                      0x00001120 /* RW-4R */
#define NV_PAPU_FECHT_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_FECHT_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_FECHT_BITS                                 15:0 /* RW-VF */
#define NV_PAPU_FEMAXSESSL                                 0x00001124 /* RW-4R */
#define NV_PAPU_FEMAXSESSL_VALUE                           15:0 /* RWXUF */
#define NV_PAPU_FEMAXSESSL_INIT                            0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXSESSL_BITS                            15:0 /* RW-VF */
#define NV_PAPU_FECSESSL                                   0x00001128 /* RW-4R */
#define NV_PAPU_FECSESSL_VALUE                             15:0 /* RWXUF */
#define NV_PAPU_FECSESSL_VALUE_NULL                        0x0000ffff /* RWI-V */
#define NV_PAPU_FECSESSL_BITS                              15:0 /* RW-VF */
#define NV_PAPU_FESESSLCTXPA                               0x0000112c /* RW-4R */
#define NV_PAPU_FESESSLCTXPA_VALUE                         31:12 /* RWXUF */
#define NV_PAPU_FESESSLCTXPA_BITS                          31:0 /* RW-VF */
#define NV_PAPU_FESESSLMAXOFF                              0x00001130 /* RW-4R */
#define NV_PAPU_FESESSLMAXOFF_VALUE                        31:12 /* RWXUF */
#define NV_PAPU_FESESSLMAXOFF_BITS                         31:0 /* RW-VF */
#define NV_PAPU_FESESSLPENDOFF                             0x00001134 /* RW-4R */
#define NV_PAPU_FESESSLPENDOFF_VALUE                       31:0 /* RWXUF */
#define NV_PAPU_FESESSLPENDOFF_BITS                        31:0 /* RW-VF */
#define NV_PAPU_FEMAXSESGE                                 0x00001138 /* RW-4R */
#define NV_PAPU_FEMAXSESGE_VALUE                           15:0 /* RWXUF */
#define NV_PAPU_FEMAXSESGE_INIT                            0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXSESGE_BITS                            15:0 /* RW-VF */
#define NV_PAPU_FECSESGE                                   0x0000113c /* RW-4R */
#define NV_PAPU_FECSESGE_VALUE                             15:0 /* RWXUF */
#define NV_PAPU_FECSESGE_VALUE_NULL                        0x0000ffff /* RWI-V */
#define NV_PAPU_FECSESGE_BITS                              15:0 /* RW-VF */
#define NV_PAPU_FESESGECTXPA                               0x00001140 /* RW-4R */
#define NV_PAPU_FESESGECTXPA_VALUE                         31:12 /* RWXUF */
#define NV_PAPU_FESESGECTXPA_BITS                          31:0 /* RW-VF */
#define NV_PAPU_FESESGEMAXOFF                              0x00001144 /* RW-4R */
#define NV_PAPU_FESESGEMAXOFF_VALUE                        31:12 /* RWXUF */
#define NV_PAPU_FESESGEMAXOFF_BITS                         31:0 /* RW-VF */
#define NV_PAPU_FEMAXGPSGE                                 0x00001148 /* RW-4R */
#define NV_PAPU_FEMAXGPSGE_VALUE                           15:0 /* RWXUF */
#define NV_PAPU_FEMAXGPSGE_INIT                            0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXGPSGE_BITS                            15:0 /* RW-VF */
#define NV_PAPU_FECGPSGE                                   0x0000114c /* RW-4R */
#define NV_PAPU_FECGPSGE_VALUE                             15:0 /* RWXUF */
#define NV_PAPU_FECGPSGE_VALUE_NULL                        0x0000ffff /* RWI-V */
#define NV_PAPU_FECGPSGE_BITS                              15:0 /* RW-VF */
#define NV_PAPU_FEGPSGECTXPA                               0x00001150 /* RW-4R */
#define NV_PAPU_FEGPSGECTXPA_VALUE                         31:12 /* RWXUF */
#define NV_PAPU_FEGPSGECTXPA_BITS                          31:0 /* RW-VF */
#define NV_PAPU_FEGPSGEMAXOFF                              0x00001154 /* RW-4R */
#define NV_PAPU_FEGPSGEMAXOFF_VALUE                        31:12 /* RWXUF */
#define NV_PAPU_FEGPSGEMAXOFF_BITS                         31:0 /* RW-VF */
#define NV_PAPU_FEMAXMB                                    0x00001158 /* RW-4R */
#define NV_PAPU_FEMAXMB_VALUE                              5:0 /* RWXUF */
#define NV_PAPU_FEMAXMB_BITS                               5:0 /* RW-VF */
#define NV_PAPU_FENADDR                                    0x0000115c /* RW-4R */
#define NV_PAPU_FENADDR_VALUE                              31:0 /* RWXUF */
#define NV_PAPU_FENADDR_BITS                               31:0 /* RW-VF */
#define NV_PAPU_AVGBW                                      0x00001200 /* R--4R */
#define NV_PAPU_AVGBW_VALUE                                20:0 /* R-XUF */
#define NV_PAPU_AVGBW_BITS                                 20:0 /* R--VF */
#define NV_PAPU_WCBW                                       0x00001204 /* RW-4R */
#define NV_PAPU_WCBW_VALUE                                 20:0 /* RWXUF */
#define NV_PAPU_WCBW_BITS                                  20:0 /* RW-VF */
#define NV_PAPU_CURBW                                      0x00001208 /* R--4R */
#define NV_PAPU_CURBW_VALUE                                20:0 /* R-XUF */
#define NV_PAPU_CURBW_BITS                                 20:0 /* R--VF */
#define NV_PAPU_CNTBW                                      0x0000120c /* R--4R */
#define NV_PAPU_CNTBW_VALUE                                19:0 /* R-XUF */
#define NV_PAPU_CNTBW_BITS                                 19:0 /* R--VF */
#define NV_PAPU_AVGLAT                                     0x00001210 /* R--4R */
#define NV_PAPU_AVGLAT_VALUE                               13:0 /* R-XUF */
#define NV_PAPU_AVGLAT_BITS                                13:0 /* R--VF */
#define NV_PAPU_WCLAT                                      0x00001214 /* RW-4R */
#define NV_PAPU_WCLAT_VALUE                                13:0 /* RWXUF */
#define NV_PAPU_WCLAT_BITS                                 13:0 /* RW-VF */
#define NV_PAPU_CURLAT                                     0x00001218 /* R--4R */
#define NV_PAPU_CURLAT_VALUE                               23:0 /* R-XUF */
#define NV_PAPU_CURLAT_BITS                                23:0 /* R--VF */
#define NV_PAPU_CURLAT_AVGLAT_BITS                         23:10 /* R--VF */
#define NV_PAPU_CNTLAT                                     0x0000121c /* R--4R */
#define NV_PAPU_CNTLAT_VALUE                               9:0 /* R-XUF */
#define NV_PAPU_CNTLAT_VALUE_MAX                           0x000003FF /* R---V */
#define NV_PAPU_CNTLAT_BITS                                9:0 /* R--VF */
#define NV_PAPU_FEDECMETH                                  0x00001300 /* R--4R */
#define NV_PAPU_FEDECMETH_METH                             15:0 /* R-XUF */
#define NV_PAPU_FEDECMETH_PHASE                            23:16 /* R-XUF */
#define NV_PAPU_FEDECMETH_PHASE_LAST                       24:24 /* R-XUF */
#define NV_PAPU_FEDECMETH_PHASE_LAST_FALSE                 0x00000000 /* R-I-V */
#define NV_PAPU_FEDECMETH_PHASE_LAST_TRUE                  0x00000001 /* R---V */
#define NV_PAPU_FEDECMETH_VALID                            25:25 /* R-XUF */
#define NV_PAPU_FEDECMETH_VALID_FALSE                      0x00000000 /* R-I-V */
#define NV_PAPU_FEDECMETH_VALID_TRUE                       0x00000001 /* R---V */
#define NV_PAPU_FEDECMETH_BITS                             25:0 /* R--VF */
#define NV_PAPU_FEDECPARAM                                 0x00001304 /* R--4R */
#define NV_PAPU_FEDECPARAM_VALUE                           31:0 /* R-XUF */
#define NV_PAPU_FEDECPARAM_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FEDECIMMED                                 0x00001308 /* R--4R */
#define NV_PAPU_FEDECIMMED_VALUE                           31:0 /* R-XUF */
#define NV_PAPU_FEDECIMMED_BITS                            31:0 /* R--VF */
#define NV_PAPU_FESCRATCH                                  0x0000130c /* RW-4R */
#define NV_PAPU_FESCRATCH_VALUE                            31:0 /* RWXUF */
#define NV_PAPU_FESCRATCH_BITS                             31:0 /* RW-VF */
#define NV_PAPU_FESCRATCH2                                 0x00001310 /* RW-4R */
#define NV_PAPU_FESCRATCH2_VALUE                           31:0 /* RWXUF */
#define NV_PAPU_FESCRATCH2_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FESCRATCH3                                 0x00001314 /* RW-4R */
#define NV_PAPU_FESCRATCH3_VALUE                           31:0 /* RWXUF */
#define NV_PAPU_FESCRATCH3_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FESCRATCH4                                 0x00001318 /* RW-4R */
#define NV_PAPU_FESCRATCH4_VALUE                           31:0 /* RWXUF */
#define NV_PAPU_FESCRATCH4_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FEMEMADDR                                  0x00001324 /* RW-4R */
#define NV_PAPU_FEMEMADDR_VALUE                            31:0 /* RWXUF */
#define NV_PAPU_FEMEMADDR_BITS                             31:0 /* RW-VF */
#define NV_PAPU_FEMEMSZ                                    0x00001328 /* RW-4R */
#define NV_PAPU_FEMEMSZ_VALUE                              5:0 /* RWXUF */
#define NV_PAPU_FEMEMSZ_BITS                               5:0 /* RW-VF */
#define NV_PAPU_FEMEMISO                                   0x0000132c /* RW-4R */
#define NV_PAPU_FEMEMISO_WR                                0:0 /* RWXUF */
#define NV_PAPU_FEMEMISO_WR_NON_ISO                        0x00000000 /* RWI-V */
#define NV_PAPU_FEMEMISO_WR_ISO                            0x00000001 /* RW--V */
#define NV_PAPU_FEMEMISO_RD                                1:1 /* RWXUF */
#define NV_PAPU_FEMEMISO_RD_NON_ISO                        0x00000000 /* RWI-V */
#define NV_PAPU_FEMEMISO_RD_ISO                            0x00000001 /* RW--V */
#define NV_PAPU_FEMEMISO_BITS                              1:0 /* RW-VF */
#define NV_PAPU_FEMEMWE                                    0x00001330 /* RW-4R */
#define NV_PAPU_FEMEMWE_VALUE                              3:0 /* RWXUF */
#define NV_PAPU_FEMEMWE_VALUE_ALL                          0x0000000f /* RWI-V */
#define NV_PAPU_FEMEMWE_BITS                               3:0 /* RW-VF */
#define NV_PAPU_FEMEMDATA                                  0x00001334 /* RW-4R */
#define NV_PAPU_FEMEMDATA_VALUE                            31:0 /* RWXUF */
#define NV_PAPU_FEMEMDATA_BITS                             31:0 /* RW-VF */
#define NV_PAPU_FESEIDLELINKS                              0x00001338 /* R--4R */
#define NV_PAPU_FESEIDLELINKS_PREV                         15:0 /* R-XUF */
#define NV_PAPU_FESEIDLELINKS_PREV_NULL                    0x0000ffff /* R---V */
#define NV_PAPU_FESEIDLELINKS_NEXT                         31:16 /* R-XUF */
#define NV_PAPU_FESEIDLELINKS_NEXT_NULL                    0x0000ffff /* R---V */
#define NV_PAPU_FESEIDLELINKS_BITS                         31:0 /* R--VF */
#define NV_PAPU_FESENOTIFY                                 0x0000133c /* R--4R */
#define NV_PAPU_FESENOTIFY_VOICE                           15:0 /* R-XUF */
#define NV_PAPU_FESENOTIFY_SSLA_COMPLETE                   16:16 /* R-XUF */
#define NV_PAPU_FESENOTIFY_SSLA_COMPLETE_NO                0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_SSLA_COMPLETE_YES               0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_SSLB_COMPLETE                   17:17 /* R-XUF */
#define NV_PAPU_FESENOTIFY_SSLB_COMPLETE_NO                0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_SSLB_COMPLETE_YES               0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_ENVELOPE_ACTIVE                 18:18 /* R-XUF */
#define NV_PAPU_FESENOTIFY_ENVELOPE_ACTIVE_NO              0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_ENVELOPE_ACTIVE_YES             0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_SAMPLES_ACTIVE                  19:19 /* R-XUF */
#define NV_PAPU_FESENOTIFY_SAMPLES_ACTIVE_NO               0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_SAMPLES_ACTIVE_YES              0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_INTERRUPT_ENABLE                20:20 /* R-XUF */
#define NV_PAPU_FESENOTIFY_INTERRUPT_ENABLE_NO             0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_INTERRUPT_ENABLE_YES            0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_BITS                            20:0 /* R--VF */
#define NV_PAPU_FEUFIFOCTL                                 0x00001340 /* RW-4R */
#define NV_PAPU_FEUFIFOCTL_COUNT                           5:0 /* RWXUF */
#define NV_PAPU_FEUFIFOCTL_HEAD                            12:8 /* RWXUF */
#define NV_PAPU_FEUFIFOCTL_HEAD_LSB                        8:8 /* RWXUF */
#define NV_PAPU_FEUFIFOCTL_TAIL                            20:16 /* RWXUF */
#define NV_PAPU_FEUFIFOCTL_BITS                            20:0 /* RW-VF */
#define NV_PAPU_FEUFIFOMETH(i)                             (0x00001400+(i)*8) /* -W-4A */
#define NV_PAPU_FEUFIFOMETH__SIZE_1                        32 /* */ 
#define NV_PAPU_FEUFIFOMETH_VALUE                          31:0 /* RWI-V */
#define NV_PAPU_FEUFIFOMETH_BITS                           31:0 /* RW-VF */
#define NV_PAPU_FEUFIFOMETH_ADDR_BITS                      7:0 /* */ 
#define NV_PAPU_FEUFIFOMETH_ADDR_SAVED_BITS                7:2 /* */ 
#define NV_PAPU_FEUFIFOPARAM(i)                            (0x00001404+(i)*8) /* -W-4A */
#define NV_PAPU_FEUFIFOPARAM__SIZE_1                       32 /* */ 
#define NV_PAPU_FEUFIFOPARAM_VALUE                         31:0 /* RWI-V */
#define NV_PAPU_FEUFIFOPARAM_BITS                          31:0 /* RW-VF */
#define NV_PAPU_FETFORCE0                                  0x00001500 /* RW-4R */
#define NV_PAPU_FETFORCE0_NOP                              0:0 /* RWXUF */
#define NV_PAPU_FETFORCE0_SYNCHRONIZE                      1:1 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_TIME                         2:2 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_MODE                         3:3 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_CURRENT_VOICE                4:4 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_ANTECEDENT_VOICE             5:5 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_ON                         6:6 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_OFF                        7:7 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_RELEASE                    8:8 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_PAUSE                      9:9 /* RWXUF */
#define NV_PAPU_FETFORCE0_GET_VOICE_POSITION               10:10 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_SUBMIX_HEADROOM              11:11 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_HRTF_SUBMIXES                12:12 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_HRTF_HEADROOM                13:13 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOLUME_TRACKING              14:14 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_PITCH_TRACKING               15:15 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_HRTF_TRACKING                16:16 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_ITD_TRACKING                 17:17 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_FILTER_TRACKING              18:18 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_LOCK                       19:19 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_CFG_VBIN               20:20 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_CFG_FMT                21:21 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_CFG_OTHER              22:22 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_TAR_HRTF               23:23 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_PAR_LFODLY             24:24 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_SSL                    25:25 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_CFG_BUF                26:26 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_TAR_VOL                27:27 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_LFO                    28:28 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_TAR_FC                 29:29 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_TAR_PITCH              30:30 /* RWXUF */
#define NV_PAPU_FETFORCE0_BITS                             30:0 /* RW-VF */
#define NV_PAPU_FETFORCE1                                  0x00001504 /* RW-4R */
#define NV_PAPU_FETFORCE1_SET_CURRENT_HRTF_ENTRY           0:0 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_HRIR                         1:1 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_HRIR_X                       2:2 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_SSL_CONTEXT_DMA      3:3 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_SSL                  4:4 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_SSL_SEGMENT_OFFSET           5:5 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_SSL_SEGMENT_LENGTH           6:6 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_INBUF_SGE_CONTEXT_DMA 7:7 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_INBUF_SGE            8:8 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_INBUF_SGE_OFFSET     9:9 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA 10:10 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_OUTBUF_SGE           11:11 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_OUTBUF_BA                    12:12 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_OUTBUF_LEN                   13:13 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_OUTBUF_SGE_OFFSET    14:14 /* RWXUF */
#define NV_PAPU_FETFORCE1_SE2FE_IDLE_VOICE                 15:15 /* RWXUF */
#define NV_PAPU_FETFORCE1_SE2FE_NOTIFY                     16:16 /* RWXUF */
#define NV_PAPU_FETFORCE1_SE2FE_RTINTR                     17:17 /* RWXUF */
#define NV_PAPU_FETFORCE1_UNKNOWN                          18:18 /* RWXUF */
#define NV_PAPU_FETFORCE1_BITS                             18:0 /* RW-VF */
#define NV_PAPU_FETIGNORE0                                 0x00001508 /* RW-4R */
#define NV_PAPU_FETIGNORE0_NOP                             0:0 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SYNCHRONIZE                     1:1 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_TIME                        2:2 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_MODE                        3:3 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_CURRENT_VOICE               4:4 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_ANTECEDENT_VOICE            5:5 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_ON                        6:6 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_OFF                       7:7 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_RELEASE                   8:8 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_PAUSE                     9:9 /* RWXUF */
#define NV_PAPU_FETIGNORE0_GET_VOICE_POSITION              10:10 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_SUBMIX_HEADROOM             11:11 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_HRTF_SUBMIXES               12:12 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_HRTF_HEADROOM               13:13 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOLUME_TRACKING             14:14 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_PITCH_TRACKING              15:15 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_HRTF_TRACKING               16:16 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_ITD_TRACKING                17:17 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_FILTER_TRACKING             18:18 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_LOCK                      19:19 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_CFG_VBIN              20:20 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_CFG_FMT               21:21 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_CFG_OTHER             22:22 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_TAR_HRTF              23:23 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_PAR_LFODLY            24:24 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_SSL                   25:25 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_CFG_BUF               26:26 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_TAR_VOL               27:27 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_LFO                   28:28 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_TAR_FC                29:29 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_TAR_PITCH             30:30 /* RWXUF */
#define NV_PAPU_FETIGNORE0_BITS                            30:0 /* RW-VF */
#define NV_PAPU_FETIGNORE1                                 0x0000150c /* RW-4R */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_HRTF_ENTRY          0:0 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_HRIR                        1:1 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_HRIR_X                      2:2 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_SSL_CONTEXT_DMA     3:3 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_SSL                 4:4 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_SSL_SEGMENT_OFFSET          5:5 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_SSL_SEGMENT_LENGTH          6:6 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_INBUF_SGE_CONTEXT_DMA 7:7 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_INBUF_SGE           8:8 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_INBUF_SGE_OFFSET    9:9 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA 10:10 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_OUTBUF_SGE          11:11 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_OUTBUF_BA                   12:12 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_OUTBUF_LEN                  13:13 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_OUTBUF_SGE_OFFSET   14:14 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SE2FE_IDLE_VOICE                15:15 /* RWXUF */
#define NV_PAPU_FETIGNORE1_UNKNOWN                         18:18 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_NOT_IMPLEMENTED      22:22 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_METHOD_UNKNOWN       23:23 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_BAD_ARGUMENT         24:24 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_CURRENT_NOT_SET      25:25 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_ANTECEDENT_NOT_SET   26:26 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_BAD_DATA_TYPE        28:28 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_BAD_LIST_POINTER     29:29 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_CURRENT_VOICE_NOT_3D 30:30 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_CTXPA_INVALID        31:31 /* RWXUF */
#define NV_PAPU_FETIGNORE1_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FEPRIVLOCK                                 0x00001510 /* RW-4R */
#define NV_PAPU_FEPRIVLOCK_VALUE                           0:0 /* RWXUF */
#define NV_PAPU_FEPRIVLOCK_VALUE_UNLOCKED                  0x00000000 /* RWI-V */
#define NV_PAPU_FEPRIVLOCK_VALUE_LOCKED                    0x00000001 /* RW--V */
#define NV_PAPU_FEPRIVLOCK_BITS                            0:0 /* RW-VF */
#define NV_PAPU_SECTL                                      0x00002000 /* RW-4R */
#define NV_PAPU_SECTL_SEPRTYP                              0:0 /* RW-VF */
#define NV_PAPU_SECTL_SEPRTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_SECTL_SEPRTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_SECTL_SEPWTYP                              1:1 /* RW-VF */
#define NV_PAPU_SECTL_SEPWTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_SECTL_SEPWTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_SECTL_SESRTYP                              2:2 /* RW-VF */
#define NV_PAPU_SECTL_SESRTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_SECTL_SESRTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_SECTL_XCNTMODE                             4:3 /* RW-VF */
#define NV_PAPU_SECTL_XCNTMODE_OFF                         0x00000000 /* RWI-V */
#define NV_PAPU_SECTL_XCNTMODE_AC_SYNC                     0x00000001 /* RW--V */
#define NV_PAPU_SECTL_XCNTMODE_SW                          0x00000002 /* RW--V */
#define NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING                0x00000003 /* RW--V */
#define NV_PAPU_STID                                       0x00002004 /* R--4R */
#define NV_PAPU_STID_SESTART                               0:0 /* R--VF */
#define NV_PAPU_STID_SESTART_NOT_STARTING                  0x00000000 /* R-I-V */
#define NV_PAPU_STID_SESTART_STARTING                      0x00000001 /* R---V */
#define NV_PAPU_STID_SEIDLE                                1:1 /* R--VF */
#define NV_PAPU_STID_SEIDLE_IDLE                           0x00000001 /* R-I-V */
#define NV_PAPU_STID_SEIDLE_NOT_IDLE                       0x00000000 /* R---V */
#define NV_PAPU_STID_VPSTART                               2:2 /* R--VF */
#define NV_PAPU_STID_VPSTART_NOT_STARTING                  0x00000000 /* R-I-V */
#define NV_PAPU_STID_VPSTART_STARTING                      0x00000001 /* R---V */
#define NV_PAPU_STID_VPIDLE                                3:3 /* R--VF */
#define NV_PAPU_STID_VPIDLE_IDLE                           0x00000001 /* R-I-V */
#define NV_PAPU_STID_VPIDLE_NOT_IDLE                       0x00000000 /* R---V */
#define NV_PAPU_STID_GPSTART                               4:4 /* R--VF */
#define NV_PAPU_STID_GPSTART_NOT_STARTING                  0x00000000 /* R-I-V */
#define NV_PAPU_STID_GPSTART_STARTING                      0x00000001 /* R---V */
#define NV_PAPU_STID_GPIDLE                                5:5 /* R--VF */
#define NV_PAPU_STID_GPIDLE_IDLE                           0x00000001 /* R-I-V */
#define NV_PAPU_STID_GPIDLE_NOT_IDLE                       0x00000000 /* R---V */
#define NV_PAPU_STID_EPSTART                               6:6 /* R--VF */
#define NV_PAPU_STID_EPSTART_NOT_STARTING                  0x00000000 /* R-I-V */
#define NV_PAPU_STID_EPSTART_STARTING                      0x00000001 /* R---V */
#define NV_PAPU_STID_EPIDLE                                7:7 /* R--VF */
#define NV_PAPU_STID_EPIDLE_IDLE                           0x00000001 /* R-I-V */
#define NV_PAPU_STID_EPIDLE_NOT_IDLE                       0x00000000 /* R---V */
#define NV_PAPU_IGSCNT                                     0x00002008 /* RW-4R */
#define NV_PAPU_IGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_IGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_XGSCNT                                     0x0000200C /* RW-4R */
#define NV_PAPU_XGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_XGSCNT_INIT                                0xFFFFFFFF /* RWI-V */
#define NV_PAPU_DGSCNT                                     0x00002010 /* RW-4R */
#define NV_PAPU_DGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_DGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_WGSCNT                                     0x00002014 /* RW-4R */
#define NV_PAPU_WGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_WGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_RGSCNT                                     0x00002018 /* RW-4R */
#define NV_PAPU_RGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_RGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_PGSCNT                                     0x0000201C /* RW-4R */
#define NV_PAPU_PGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_PGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_EGSCNT                                     0x00002020 /* RW-4R */
#define NV_PAPU_EGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_EGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_DEGSCNT                                    0x00002024 /* RW-4R */
#define NV_PAPU_DEGSCNT_VALUE                              31:0 /* RWXUF */
#define NV_PAPU_DEGSCNT_INIT                               0x00000000 /* RWI-V */
#define NV_PAPU_ECNTSTP                                    0x00002028 /* RW-4R */
#define NV_PAPU_ECNTSTP_VALUE                              15:0 /* RWXUF */
#define NV_PAPU_VPVADDR                                    0x0000202C /* RW-4R */
#define NV_PAPU_VPVADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_VPSGEADDR                                  0x00002030 /* RW-4R */
#define NV_PAPU_VPSGEADDR_VALUE                            31:14 /* RWXUF */
#define NV_PAPU_VPSSLADDR                                  0x00002034 /* RW-4R */
#define NV_PAPU_VPSSLADDR_VALUE                            31:14 /* RWXUF */
#define NV_PAPU_VPHTADDR                                   0x00002038 /* RW-4R */
#define NV_PAPU_VPHTADDR_VALUE                             31:14 /* RWXUF */
#define NV_PAPU_VPHCADDR                                   0x0000203C /* RW-4R */
#define NV_PAPU_VPHCADDR_VALUE                             31:14 /* RWXUF */
#define NV_PAPU_GPSADDR                                    0x00002040 /* RW-4R */
#define NV_PAPU_GPSADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_GPFADDR                                    0x00002044 /* RW-4R */
#define NV_PAPU_GPFADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_EPSADDR                                    0x00002048 /* RW-4R */
#define NV_PAPU_EPSADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_EPFADDR                                    0x0000204C /* RW-4R */
#define NV_PAPU_EPFADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_VLOCK                                      0x00002050 /* RW-4R */
#define NV_PAPU_VLOCK_VOICE                                15:0 /* RW-VF */
#define NV_PAPU_VLOCK_REQ                                  16:16 /* RW-VF */
#define NV_PAPU_VLOCK_REQ_LOCK                             0x00000001 /* RW--V */
#define NV_PAPU_VLOCK_REQ_UNLOCK                           0x00000000 /* RWI-V */
#define NV_PAPU_VLOCK_STATUS                               17:17 /* RW-VF */
#define NV_PAPU_VLOCK_STATUS_NOT_IN_PROGRESS               0x00000000 /* RW--V */
#define NV_PAPU_VLOCK_STATUS_IN_PROGRESS                   0x00000001 /* RWI-V */
#define NV_PAPU_TVL2D                                      0x00002054 /* RW-4R */
#define NV_PAPU_TVL2D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_TVL2D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_CVL2D                                      0x00002058 /* RW-4R */
#define NV_PAPU_CVL2D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_CVL2D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_NVL2D                                      0x0000205C /* RW-4R */
#define NV_PAPU_NVL2D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_NVL2D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_TVL3D                                      0x00002060 /* RW-4R */
#define NV_PAPU_TVL3D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_TVL3D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_CVL3D                                      0x00002064 /* RW-4R */
#define NV_PAPU_CVL3D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_CVL3D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_NVL3D                                      0x00002068 /* RW-4R */
#define NV_PAPU_NVL3D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_NVL3D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_TVLMP                                      0x0000206C /* RW-4R */
#define NV_PAPU_TVLMP_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_TVLMP_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_CVLMP                                      0x00002070 /* RW-4R */
#define NV_PAPU_CVLMP_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_CVLMP_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_NVLMP                                      0x00002074 /* RW-4R */
#define NV_PAPU_NVLMP_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_NVLMP_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_ALPHAV                                     0x00002078 /* RW-4R */
#define NV_PAPU_ALPHAV_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_ALPHAP                                     0x0000207C /* RW-4R */
#define NV_PAPU_ALPHAP_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_ALPHAF                                     0x00002080 /* RW-4R */
#define NV_PAPU_ALPHAF_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_ALPHAI                                     0x00002084 /* RW-4R */
#define NV_PAPU_ALPHAI_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_ALPHAH                                     0x00002088 /* RW-4R */
#define NV_PAPU_ALPHAH_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_MIXHRA                                     0x0000208C /* RW-4R */
#define NV_PAPU_MIXHRA_MHR0                                2:0 /* RWXUF */
#define NV_PAPU_MIXHRA_MHR0_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRA_MHR1                                10:8 /* RWXUF */
#define NV_PAPU_MIXHRA_MHR1_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRA_MHR2                                18:16 /* RWXUF */
#define NV_PAPU_MIXHRA_MHR2_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRA_MHR3                                26:24 /* RWXUF */
#define NV_PAPU_MIXHRA_MHR3_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRB                                     0x00002090 /* RW-4R */
#define NV_PAPU_MIXHRB_MHR4                                2:0 /* RWXUF */
#define NV_PAPU_MIXHRB_MHR4_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRB_MHR5                                10:8 /* RWXUF */
#define NV_PAPU_MIXHRB_MHR5_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRB_MHR6                                18:16 /* RWXUF */
#define NV_PAPU_MIXHRB_MHR6_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRB_MHR7                                26:24 /* RWXUF */
#define NV_PAPU_MIXHRB_MHR7_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRC                                     0x00002094 /* RW-4R */
#define NV_PAPU_MIXHRC_MHR8                                2:0 /* RWXUF */
#define NV_PAPU_MIXHRC_MHR8_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRC_MHR9                                10:8 /* RWXUF */
#define NV_PAPU_MIXHRC_MHR9_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRC_MHR10                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRC_MHR10_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRC_MHR11                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRC_MHR11_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRD                                     0x00002098 /* RW-4R */
#define NV_PAPU_MIXHRD_MHR12                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRD_MHR12_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRD_MHR13                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRD_MHR13_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRD_MHR14                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRD_MHR14_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRD_MHR15                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRD_MHR15_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRE                                     0x0000209C /* RW-4R */
#define NV_PAPU_MIXHRE_MHR16                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRE_MHR16_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRE_MHR17                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRE_MHR17_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRE_MHR18                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRE_MHR18_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRE_MHR19                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRF                                     0x000020A0 /* RW-4R */
#define NV_PAPU_MIXHRF_MHR19_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRF_MHR20                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRF_MHR20_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRF_MHR21                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRF_MHR21_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRF_MHR22                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRF_MHR22_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRF_MHR23                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRF_MHR23_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRG                                     0x000020A4 /* RW-4R */
#define NV_PAPU_MIXHRG_MHR24                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRG_MHR24_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRG_MHR25                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRG_MHR25_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRG_MHR26                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRG_MHR26_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRG_MHR27                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRG_MHR27_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRH                                     0x000020A8 /* RW-4R */
#define NV_PAPU_MIXHRH_MHR28                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRH_MHR28_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRH_MHR29                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRH_MHR29_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRH_MHR30                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRH_MHR30_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRH_MHR31                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRH_MHR31_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIX3D                                      0x000020AC /* RW-4R */
#define NV_PAPU_MIX3D_SMX3DFL                              4:0 /* RWXUF */
#define NV_PAPU_MIX3D_SMX3DFL_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_MIX3D_SMX3DFR                              12:8 /* RWXUF */
#define NV_PAPU_MIX3D_SMX3DFR_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_MIX3D_SMX3DRL                              20:16 /* RWXUF */
#define NV_PAPU_MIX3D_SMX3DRL_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_MIX3D_SMX3DRR                              28:24 /* RWXUF */
#define NV_PAPU_MIX3D_SMX3DRR_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_TDHR                                       0x000020B0 /* RW-4R */
#define NV_PAPU_TDHR_TDHR                                  2:0 /* RWXUF */
#define NV_PAPU_TDHR_TDHR_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_AVGSESTI                                   0x000020B4 /* RW-4R */
#define NV_PAPU_AVGSESTI_VALUE                             31:0 /* RWXUF */
#define NV_PAPU_WCSESTI                                    0x000020B8 /* RW-4R */
#define NV_PAPU_WCSESTI_VALUE                              31:0 /* RWXUF */
#define NV_PAPU_CURSESTI                                   0x000020BC /* RW-4R */
#define NV_PAPU_CURSESTI_VALUE                             31:0 /* RWXUF */
#define NV_PAPU_CNTSESTI                                   0x000020C0 /* RW-4R */
#define NV_PAPU_CNTSESTI_VALUE                             7:0 /* RWXUF */
#define NV_PAPU_AVGGPSTI                                   0x000020C4 /* RW-4R */
#define NV_PAPU_AVGGPSTI_VALUE                             31:0 /* RWXUF */
#define NV_PAPU_WCGPSTI                                    0x000020C8 /* RW-4R */
#define NV_PAPU_WCGPSTI_VALUE                              31:0 /* RWXUF */
#define NV_PAPU_CURGPSTI                                   0x000020CC /* RW-4R */
#define NV_PAPU_CURGPSTI_VALUE                             31:0 /* RWXUF */
#define NV_PAPU_CNTGPSTI                                   0x000020D0 /* RW-4R */
#define NV_PAPU_CNTGPSTI_VALUE                             7:0 /* RWXUF */
#define NV_PAPU_GPSMAXSGE                                  0x000020D4 /* RW-4R */
#define NV_PAPU_GPSMAXSGE_VALUE                            15:0 /* RWXUF */
#define NV_PAPU_GPSMAXSGE_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_GPSMAXSGE_BITS                             15:0 /* RW-VF */
#define NV_PAPU_GPFMAXSGE                                  0x000020D8 /* RW-4R */
#define NV_PAPU_GPFMAXSGE_VALUE                            15:0 /* RWXUF */
#define NV_PAPU_GPFMAXSGE_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_GPFMAXSGE_BITS                             15:0 /* RW-VF */
#define NV_PAPU_EPSMAXSGE                                  0x000020DC /* RW-4R */
#define NV_PAPU_EPSMAXSGE_VALUE                            15:0 /* RWXUF */
#define NV_PAPU_EPSMAXSGE_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_EPSMAXSGE_BITS                             15:0 /* RW-VF */
#define NV_PAPU_EPFMAXSGE                                  0x000020E0 /* RW-4R */
#define NV_PAPU_EPFMAXSGE_VALUE                            15:0 /* RWXUF */
#define NV_PAPU_EPFMAXSGE_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_EPFMAXSGE_BITS                             15:0 /* RW-VF */
#define NV_PAPU_GPNADDR                                    0x00003004 /* RW-4R */
#define NV_PAPU_GPNADDR_VALUE                              31:12 /* RWXUF */
#define NV_PAPU_GPCADDR                                    0x00003014 /* RW-4R */
#define NV_PAPU_GPCADDR_VALUE                              31:12 /* RWXUF */
#define NV_PAPU_GPOFBASE0                                  0x00003024 /* RW-4R */
#define NV_PAPU_GPOFBASE0_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPOFBASE1                                  0x00003034 /* RW-4R */
#define NV_PAPU_GPOFBASE1_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPOFBASE2                                  0x00003044 /* RW-4R */
#define NV_PAPU_GPOFBASE2_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPOFBASE3                                  0x00003054 /* RW-4R */
#define NV_PAPU_GPOFBASE3_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPOFEND0                                   0x00003028 /* RW-4R */
#define NV_PAPU_GPOFEND0_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPOFEND1                                   0x00003038 /* RW-4R */
#define NV_PAPU_GPOFEND1_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPOFEND2                                   0x00003048 /* RW-4R */
#define NV_PAPU_GPOFEND2_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPOFEND3                                   0x00003058 /* RW-4R */
#define NV_PAPU_GPOFEND3_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPOFCUR0                                   0x0000302C /* RW-4R */
#define NV_PAPU_GPOFCUR0_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPOFCUR1                                   0x0000303C /* RW-4R */
#define NV_PAPU_GPOFCUR1_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPOFCUR2                                   0x0000304C /* RW-4R */
#define NV_PAPU_GPOFCUR2_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPOFCUR3                                   0x0000305C /* RW-4R */
#define NV_PAPU_GPOFCUR3_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPIFBASE0                                  0x00003064 /* RW-4R */
#define NV_PAPU_GPIFBASE0_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPIFBASE1                                  0x00003074 /* RW-4R */
#define NV_PAPU_GPIFBASE1_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPIFEND0                                   0x00003068 /* RW-4R */
#define NV_PAPU_GPIFEND0_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPIFEND1                                   0x00003078 /* RW-4R */
#define NV_PAPU_GPIFEND1_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPIFCUR0                                   0x0000306C /* RW-4R */
#define NV_PAPU_GPIFCUR0_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPIFCUR1                                   0x0000307C /* RW-4R */
#define NV_PAPU_GPIFCUR1_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPNADDR                                    0x00004004 /* RW-4R */
#define NV_PAPU_EPNADDR_VALUE                              31:12 /* RWXUF */
#define NV_PAPU_EPCADDR                                    0x00004014 /* RW-4R */
#define NV_PAPU_EPCADDR_VALUE                              31:12 /* RWXUF */
#define NV_PAPU_EPOFBASE0                                  0x00004024 /* RW-4R */
#define NV_PAPU_EPOFBASE0_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPOFBASE1                                  0x00004034 /* RW-4R */
#define NV_PAPU_EPOFBASE1_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPOFBASE2                                  0x00004044 /* RW-4R */
#define NV_PAPU_EPOFBASE2_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPOFBASE3                                  0x00004054 /* RW-4R */
#define NV_PAPU_EPOFBASE3_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPOFEND0                                   0x00004028 /* RW-4R */
#define NV_PAPU_EPOFEND0_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPOFEND1                                   0x00004038 /* RW-4R */
#define NV_PAPU_EPOFEND1_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPOFEND2                                   0x00004048 /* RW-4R */
#define NV_PAPU_EPOFEND2_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPOFEND3                                   0x00004058 /* RW-4R */
#define NV_PAPU_EPOFEND3_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPOFCUR0                                   0x0000402C /* RW-4R */
#define NV_PAPU_EPOFCUR0_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPOFCUR1                                   0x0000403C /* RW-4R */
#define NV_PAPU_EPOFCUR1_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPOFCUR2                                   0x0000404C /* RW-4R */
#define NV_PAPU_EPOFCUR2_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPOFCUR3                                   0x0000405C /* RW-4R */
#define NV_PAPU_EPOFCUR3_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPIFBASE0                                  0x00004064 /* RW-4R */
#define NV_PAPU_EPIFBASE0_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPIFBASE1                                  0x00004074 /* RW-4R */
#define NV_PAPU_EPIFBASE1_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPIFEND0                                   0x00004068 /* RW-4R */
#define NV_PAPU_EPIFEND0_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPIFEND1                                   0x00004078 /* RW-4R */
#define NV_PAPU_EPIFEND1_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPIFCUR0                                   0x0000406C /* RW-4R */
#define NV_PAPU_EPIFCUR0_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPIFCUR1                                   0x0000407C /* RW-4R */
#define NV_PAPU_EPIFCUR1_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPXMEM(i)                                  (0x30000+4*(i)) /* RW--M */
#define NV_PAPU_GPXMEM__SIZE_1                             0x1000 /* */ 
#define NV_PAPU_GPMIXBUF(i)                                (0x35000+4*(i)) /* R---M */
#define NV_PAPU_GPMIXBUF__SIZE_1                           0x0400 /* */ 
#define NV_PAPU_GPYMEM(i)                                  (0x36000+4*(i)) /* RW--M */
#define NV_PAPU_GPYMEM__SIZE_1                             0x0800 /* */ 
#define NV_PAPU_GPPMEM(i)                                  (0x3A000+4*(i)) /* RW--M */
#define NV_PAPU_GPPMEM__SIZE_1                             0x1000 /* */ 
#define NV_PAPU_GPRST                                      0x0003FFFC /* RW-4R */
#define NV_PAPU_GPRST_GPRST                                0:0 /* RW-VF */
#define NV_PAPU_GPRST_GPRST_ENABLED                        0x00000000 /* RWI-V */
#define NV_PAPU_GPRST_GPRST_DISABLED                       0x00000001 /* RW--V */
#define NV_PAPU_GPRST_GPDSPRST                             1:1 /* RW-VF */
#define NV_PAPU_GPRST_GPDSPRST_ENABLED                     0x00000000 /* RWI-V */
#define NV_PAPU_GPRST_GPDSPRST_DISABLED                    0x00000001 /* RW--V */
#define NV_PAPU_GPRST_GPNMI                                2:2 /* -W-VF */
#define NV_PAPU_GPRST_GPNMI_DISABLED                       0x00000000 /* -WI-V */
#define NV_PAPU_GPRST_GPNMI_ENABLED                        0x00000001 /* -W--V */
#define NV_PAPU_GPRST_GPABORT                              3:3 /* -W-VF */
#define NV_PAPU_GPRST_GPABORT_DISABLED                     0x00000000 /* -WI-V */
#define NV_PAPU_GPRST_GPABORT_ENABLED                      0x00000001 /* -W--V */
#define NV_PAPU_GPCTLG                                     0x0003FF28 /* RW-4R */
#define NV_PAPU_GPCTLG_GPSTYP                              0:0 /* RW-VF */
#define NV_PAPU_GPCTLG_GPSTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLG_GPSTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_GPCTLG_SPARE                               23:1 /* RW-UF */
#define NV_PAPU_GPCTLG_SPARE_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT                                   0x0003FF20 /* RW-4R */
#define NV_PAPU_GPCTLOUT_GD0FMT                            1:0 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD0FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD0FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD0FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD0FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLOUT_GP0TYP                            2:2 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GP0TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GP0TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD0SIZ                            4:3 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD0SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD0SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD0SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1FMT                            6:5 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD1FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD1FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLOUT_GP1TYP                            7:7 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GP1TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GP1TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1SIZ                            9:8 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD1SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD1SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2FMT                            11:10 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD2FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD2FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLOUT_GP2TYP                            12:12 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GP2TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GP2TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2SIZ                            14:13 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD2SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD2SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3FMT                            16:15 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD3FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD3FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLOUT_GP3TYP                            17:17 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GP3TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GP3TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3SIZ                            19:18 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD3SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD3SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_SPARE                             23:20 /* RW-UF */
#define NV_PAPU_GPCTLOUT_SPARE_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN                                    0x0003FF24 /* RW-4R */
#define NV_PAPU_GPCTLIN_GDI0FMT                            1:0 /* RW-VF */
#define NV_PAPU_GPCTLIN_GDI0FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GDI0FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI0FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI0FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLIN_GPI0TYP                            2:2 /* RW-VF */
#define NV_PAPU_GPCTLIN_GPI0TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GPI0TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI0SIZ                            4:3 /* RW-VF */
#define NV_PAPU_GPCTLIN_GDI0SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GDI0SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI0SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1FMT                            6:5 /* RW-VF */
#define NV_PAPU_GPCTLIN_GDI1FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GDI1FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLIN_GPI1TYP                            7:7 /* RW-VF */
#define NV_PAPU_GPCTLIN_GPI1TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GPI1TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1SIZ                            9:8 /* RW-VF */
#define NV_PAPU_GPCTLIN_GDI1SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GDI1SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLIN_SPARE                              23:10 /* RW-UF */
#define NV_PAPU_GPCTLIN_SPARE_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_GPMBO                                      0x0003FF08 /* RW-4R */
#define NV_PAPU_GPMBO_VALUE                                23:0 /* RWXUF */
#define NV_PAPU_GPMBI                                      0x0003FF0C /* RW-4R */
#define NV_PAPU_GPMBI_VALUE                                23:0 /* RWXUF */
#define NV_PAPU_GPGET                                      0x0003FF00 /* RW-4R */
#define NV_PAPU_GPGET_VALUE                                11:2 /* RWXUF */
#define NV_PAPU_GPPUT                                      0x0003FF04 /* RW-4R */
#define NV_PAPU_GPPUT_VALUE                                11:2 /* RWXUF */
#define NV_PAPU_GPIDRDY                                    0x0003FF10 /* RW-4R */
#define NV_PAPU_GPIDRDY_GPSETIDLE                          0:0 /* RW-VF */
#define NV_PAPU_GPIDRDY_GPSETIDLE_NOT_SET                  0x00000000 /* -WI-V */
#define NV_PAPU_GPIDRDY_GPSETIDLE_SET                      0x00000001 /* RW--V */
#define NV_PAPU_GPIDRDY_GPSTOPPED                          1:1 /* RW-VF */
#define NV_PAPU_GPIDRDY_GPSTOPPED_NOT_SET                  0x00000000 /* RWI-V */
#define NV_PAPU_GPIDRDY_GPSTOPPED_SET                      0x00000001 /* RW--V */
#define NV_PAPU_GPIDRDY_GPSTOP_ENABLE                      2:2 /* -W-VF */
#define NV_PAPU_GPIDRDY_GPSTOP_NOT_ENABLED                 0x00000000 /* -WI-V */
#define NV_PAPU_GPIDRDY_GPSTOP_ENABLED                     0x00000001 /* -W--V */
#define NV_PAPU_GPIDRDY_GPSETNINT                          3:3 /* -W-VF */
#define NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET                  0x00000000 /* -WI-V */
#define NV_PAPU_GPIDRDY_GPSETNINT_SET                      0x00000001 /* -W--V */
#define NV_PAPU_GPT0CFG                                    0x0003FEC0 /* RW-4R */
#define NV_PAPU_GPT0CFG_GPT0RUN                            0:0 /* RW-VF */
#define NV_PAPU_GPT0CFG_GPT0RUN_IDLE                       0x00000000 /* RWI-V */
#define NV_PAPU_GPT0CFG_GPT0RUN_RUN                        0x00000001 /* RW--V */
#define NV_PAPU_GPT0CFG_GPT0DSTP                           1:1 /* RW-VF */
#define NV_PAPU_GPT0CFG_GPT0DSTP_RUN                       0x00000000 /* RWI-V */
#define NV_PAPU_GPT0CFG_GPT0DSTP_HOLD                      0x00000001 /* RW--V */
#define NV_PAPU_GPT1CFG                                    0x0003FED0 /* RW-4R */
#define NV_PAPU_GPT1CFG_GPT1RUN                            0:0 /* RW-VF */
#define NV_PAPU_GPT1CFG_GPT1RUN_IDLE                       0x00000000 /* RWI-V */
#define NV_PAPU_GPT1CFG_GPT1RUN_RUN                        0x00000001 /* RW--V */
#define NV_PAPU_GPT1CFG_GPT1DSTP                           1:1 /* RW-VF */
#define NV_PAPU_GPT1CFG_GPT1DSTP_RUN                       0x00000000 /* RWI-V */
#define NV_PAPU_GPT1CFG_GPT1DSTP_HOLD                      0x00000001 /* RW--V */
#define NV_PAPU_GPT0CTL                                    0x0003FEC4 /* RW-4R */
#define NV_PAPU_GPT0CTL_GPT0ACT                            1:0 /* -W-VF */
#define NV_PAPU_GPT0CTL_GPT0ACT_NOP                        0x00000000 /* -WI-V */
#define NV_PAPU_GPT0CTL_GPT0ACT_STZERO                     0x00000001 /* -W--V */
#define NV_PAPU_GPT0CTL_GPT0ACT_STCUR                      0x00000002 /* -W--V */
#define NV_PAPU_GPT0CTL_GPT0ACT_STOP                       0x00000003 /* -W--V */
#define NV_PAPU_GPT0CTL_GPT0ST                             2:2 /* R--VF */
#define NV_PAPU_GPT0CTL_GPT0ST_STOP                        0x00000000 /* R-I-V */
#define NV_PAPU_GPT0CTL_GPT0ST_RUN                         0x00000001 /* R---V */
#define NV_PAPU_GPT1CTL                                    0x0003FED4 /* RW-4R */
#define NV_PAPU_GPT1CTL_GPT1ACT                            1:0 /* -W-VF */
#define NV_PAPU_GPT1CTL_GPT1ACT_NOP                        0x00000000 /* -WI-V */
#define NV_PAPU_GPT1CTL_GPT1ACT_STZERO                     0x00000001 /* -W--V */
#define NV_PAPU_GPT1CTL_GPT1ACT_STCUR                      0x00000002 /* -W--V */
#define NV_PAPU_GPT1CTL_GPT1ACT_STOP                       0x00000003 /* -W--V */
#define NV_PAPU_GPT1CTL_GPT1ST                             2:2 /* R--VF */
#define NV_PAPU_GPT1CTL_GPT1ST_STOP                        0x00000000 /* R-I-V */
#define NV_PAPU_GPT1CTL_GPT1ST_RUN                         0x00000001 /* R---V */
#define NV_PAPU_GPT0TCNT                                   0x0003FEC8 /* RW-4R */
#define NV_PAPU_GPT0TCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_GPT1TCNT                                   0x0003FED8 /* RW-4R */
#define NV_PAPU_GPT1TCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_GPT0CCNT                                   0x0003FECC /* RW-4R */
#define NV_PAPU_GPT0CCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_GPT1CCNT                                   0x0003FEDC /* RW-4R */
#define NV_PAPU_GPT1CCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_GPISTS                                     0x0003FF14 /* RW-4R */
#define NV_PAPU_GPISTS_GPSTRTSTS                           0:0 /* RW-VF */
#define NV_PAPU_GPISTS_GPSTRTSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPSTRTSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPSTRTSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPABRTSTS                           1:1 /* RW-VF */
#define NV_PAPU_GPISTS_GPABRTSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPABRTSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPABRTSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPPUTSTS                            2:2 /* RW-VF */
#define NV_PAPU_GPISTS_GPPUTSTS_NO_INTR                    0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPPUTSTS_INTR                       0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPPUTSTS_CLR                        0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPMBISTS                            3:3 /* RW-VF */
#define NV_PAPU_GPISTS_GPMBISTS_NO_INTR                    0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPMBISTS_INTR                       0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPMBISTS_CLR                        0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPD1STS                             4:4 /* R--VF */
#define NV_PAPU_GPISTS_GPD1STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPD1STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPD1STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPD2STS                             5:5 /* RW-VF */
#define NV_PAPU_GPISTS_GPD2STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPD2STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPD2STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPD3STS                             6:6 /* RW-VF */
#define NV_PAPU_GPISTS_GPD3STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPD3STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPD3STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPDEOLSTS                           7:7 /* RW-VF */
#define NV_PAPU_GPISTS_GPDEOLSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPDEOLSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPDEOLSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPT0STS                             8:8 /* RW-VF */
#define NV_PAPU_GPISTS_GPT0STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPT0STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPT0STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPT1STS                             9:9 /* RW-VF */
#define NV_PAPU_GPISTS_GPT1STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPT1STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPT1STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPDERRSTS                           10:10 /* RW-VF */
#define NV_PAPU_GPISTS_GPDERRSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPDERRSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPDERRSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_GPHDRV(i)                                  (0x0003FE40+(i)*4) /* R--4A */
#define NV_PAPU_GPHDRV__SIZE_1                             32 /* */ 
#define NV_PAPU_GPHDRV_MHR                                 2:0 /* R--UF */
#define NV_PAPU_GPHDRV_VLD                                 3:3 /* R--UF */
#define NV_PAPU_GPHDRV_VLD_INVALID                         0x00000000 /* R-I-V */
#define NV_PAPU_GPHDRV_VLD_VALID                           0x00000001 /* R---V */
#define NV_PAPU_GPGSCNT                                    0x0003FF18 /* R--4R */
#define NV_PAPU_GPGSCNT_GSCNT                              23:0 /* R--UF */
#define NV_PAPU_GPDCFG                                     0x0003FF5C /* RW-4R */
#define NV_PAPU_GPDCFG_GPDASTRT                            0:0 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDASTRT_DISABLED                   0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDASTRT_ENABLED                    0x00000001 /* RW--V */
#define NV_PAPU_GPDCFG_GPDARDY                             1:1 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDARDY_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDARDY_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_GPDCFG_GPDIOCR                             2:2 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDIOCR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDIOCR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_GPDCFG_GPDEOLR                             3:3 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDEOLR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDEOLR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_GPDCFG_GPDERRR                             4:4 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDERRR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDERRR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_GPDCTL                                     0x0003FF58 /* RW-4R */
#define NV_PAPU_GPDCTL_GPDACT                              2:0 /* RW-VF */
#define NV_PAPU_GPDCTL_GPDACT_NOP                          0x00000000 /* RWI-V */
#define NV_PAPU_GPDCTL_GPDACT_START                        0x00000001 /* -W--V */
#define NV_PAPU_GPDCTL_GPDACT_STOP                         0x00000002 /* -W--V */
#define NV_PAPU_GPDCTL_GPDACT_FREEZE                       0x00000003 /* -W--V */
#define NV_PAPU_GPDCTL_GPDACT_UNFREEZE                     0x00000004 /* -W--V */
#define NV_PAPU_GPDCTL_GPDFRZ                              3:3 /* R--VF */
#define NV_PAPU_GPDCTL_GPDFRZ_NOT_FROZE                    0x00000000 /* R-I-V */
#define NV_PAPU_GPDCTL_GPDFRZ_FROZE                        0x00000001 /* R---V */
#define NV_PAPU_GPDCTL_GPDRUN                              4:4 /* R--VF */
#define NV_PAPU_GPDCTL_GPDRUN_NOT_RUN                      0x00000000 /* R-I-V */
#define NV_PAPU_GPDCTL_GPDRUN_RUNNING                      0x00000001 /* R---V */
#define NV_PAPU_GPDCTL_GPDSTP                              5:5 /* R--VF */
#define NV_PAPU_GPDCTL_GPDSTP_NOT_STOP                     0x00000000 /* R-I-V */
#define NV_PAPU_GPDCTL_GPDFRZ_STOPPED                      0x00000001 /* R---V */
#define NV_PAPU_GPDSPT                                     0x0003FF54 /* RW-4R */
#define NV_PAPU_GPDSPT_GPDSBPT                             13:0 /* RW-VF */
#define NV_PAPU_GPDSPT_GPDSBPT_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_GPDSPT_GPDEOL                              14:14 /* RW-VF */
#define NV_PAPU_GPDSPT_GPDEOL_EOL                          0x00000001 /* RWI-V */
#define NV_PAPU_GPDSPT_GPDEOL_NOT_EOL                      0x00000000 /* RW--V */
#define NV_PAPU_GPNSPT                                     0x0003FF50 /* RW-4R */
#define NV_PAPU_GPNSPT_GPNSBPT                             13:0 /* RW-VF */
#define NV_PAPU_GPNSPT_GPNSBPT_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_GPNSPT_GPNEOL                              14:14 /* RW-VF */
#define NV_PAPU_GPNSPT_GPNEOL_NOT_EOL                      0x00000000 /* RWI-V */
#define NV_PAPU_GPNSPT_GPNEOL_EOL                          0x00000001 /* RW--V */
#define NV_PAPU_GPDBASE(i)                                 (0x0003FF30+(i)*8) /* RW-4A */
#define NV_PAPU_GPDBASE__SIZE_1                            4 /* */ 
#define NV_PAPU_GPDBASE_BASE                               23:0 /* R--UF */
#define NV_PAPU_GPDSIZE(i)                                 (0x0003FF34+(i)*8) /* RW-4A */
#define NV_PAPU_GPDSIZE__SIZE_1                            4 /* */ 
#define NV_PAPU_GPDSIZE_SIZE                               23:0 /* R--UF */
#define NV_PAPU_GPDDEBUG                                   0x0003FF2C /* R--4R */
#define NV_PAPU_GPDDEBUG_PBADBLK                           13:0 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLSMBUFID                        14:14 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLSMBUFID_NOT_ILL                0x00000000 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLSMBUFID_ILL                    0x00000001 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLSMDATAFMT                      15:15 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLSMDATAFMT_NOT_ILL              0x00000000 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLSMDATAFMT_ILL                  0x00000001 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLCOUNT                          16:16 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLCOUNT_NOT_ILL                  0x00000000 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLCOUNT_ILL                      0x00000001 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLDSPADDR                        17:17 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLDSPADDR_NOT_ILL                0x00000000 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLDSPADDR_ILL                    0x00000001 /* R---V */
#define NV_PAPU_EPXMEM(i)                                  (0x50000+4*(i)) /* RW--M */
#define NV_PAPU_EPXMEM__SIZE_1                             0x0C00 /* */ 
#define NV_PAPU_EPYMEM(i)                                  (0x56000+4*(i)) /* RW--M */
#define NV_PAPU_EPYMEM__SIZE_1                             0x0100 /* */ 
#define NV_PAPU_EPPMEM(i)                                  (0x5A000+4*(i)) /* RW--M */
#define NV_PAPU_EPPMEM__SIZE_1                             0x1000 /* */ 
#define NV_PAPU_EPRST                                      0x0005FFFC /* RW-4R */
#define NV_PAPU_EPRST_EPRST                                0:0 /* RW-VF */
#define NV_PAPU_EPRST_EPRST_ENABLED                        0x00000000 /* RWI-V */
#define NV_PAPU_EPRST_EPRST_DISABLED                       0x00000001 /* RW--V */
#define NV_PAPU_EPRST_EPDSPRST                             1:1 /* RW-VF */
#define NV_PAPU_EPRST_EPDSPRST_ENABLED                     0x00000000 /* RWI-V */
#define NV_PAPU_EPRST_EPDSPRST_DISABLED                    0x00000001 /* RW--V */
#define NV_PAPU_EPRST_EPNMI                                2:2 /* -W-VF */
#define NV_PAPU_EPRST_EPNMI_DISABLED                       0x00000000 /* -WI-V */
#define NV_PAPU_EPRST_EPNMI_ENABLED                        0x00000001 /* -W--V */
#define NV_PAPU_EPRST_EPABORT                              3:3 /* -W-VF */
#define NV_PAPU_EPRST_EPABORT_DISABLED                     0x00000000 /* -WI-V */
#define NV_PAPU_EPRST_EPABORT_ENABLED                      0x00000001 /* -W--V */
#define NV_PAPU_EPCTLG                                     0x0005FF28 /* RW-4R */
#define NV_PAPU_EPCTLG_EPSTYP                              0:0 /* RW-VF */
#define NV_PAPU_EPCTLG_EPSTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLG_EPSTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_EPCTLG_SPARE                               23:1 /* RW-UF */
#define NV_PAPU_EPCTLG_SPARE_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT                                   0x0005FF20 /* RW-4R */
#define NV_PAPU_EPCTLOUT_ED0FMT                            1:0 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED0FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED0FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED0FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED0FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLOUT_EP0TYP                            2:2 /* RW-VF */
#define NV_PAPU_EPCTLOUT_EP0TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_EP0TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED0SIZ                            4:3 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED0SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED0SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED0SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1FMT                            6:5 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED1FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED1FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLOUT_EP1TYP                            7:7 /* RW-VF */
#define NV_PAPU_EPCTLOUT_EP1TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_EP1TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1SIZ                            9:8 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED1SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED1SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2FMT                            11:10 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED2FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED2FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLOUT_EP2TYP                            12:12 /* RW-VF */
#define NV_PAPU_EPCTLOUT_EP2TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_EP2TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2SIZ                            14:13 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED2SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED2SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3FMT                            16:15 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED3FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED3FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLOUT_EP3TYP                            17:17 /* RW-VF */
#define NV_PAPU_EPCTLOUT_EP3TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_EP3TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3SIZ                            19:18 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED3SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED3SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_SPARE                             23:20 /* RW-UF */
#define NV_PAPU_EPCTLOUT_SPARE_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN                                    0x0005FF24 /* RW-4R */
#define NV_PAPU_EPCTLIN_EDI0FMT                            1:0 /* RW-VF */
#define NV_PAPU_EPCTLIN_EDI0FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EDI0FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI0FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI0FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLIN_EPI0TYP                            2:2 /* RW-VF */
#define NV_PAPU_EPCTLIN_EPI0TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EPI0TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI0SIZ                            4:3 /* RW-VF */
#define NV_PAPU_EPCTLIN_EDI0SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EDI0SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI0SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1FMT                            6:5 /* RW-VF */
#define NV_PAPU_EPCTLIN_EDI1FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EDI1FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLIN_EPI1TYP                            7:7 /* RW-VF */
#define NV_PAPU_EPCTLIN_EPI1TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EPI1TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1SIZ                            9:8 /* RW-VF */
#define NV_PAPU_EPCTLIN_EDI1SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EDI1SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLIN_SPARE                              23:10 /* RW-UF */
#define NV_PAPU_EPCTLIN_SPARE_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_EPMBO                                      0x0005FF08 /* RW-4R */
#define NV_PAPU_EPMBO_VALUE                                23:0 /* RWXUF */
#define NV_PAPU_EPMBI                                      0x0005FF0C /* RW-4R */
#define NV_PAPU_EPMBI_VALUE                                23:0 /* RWXUF */
#define NV_PAPU_EPGET                                      0x0005FF00 /* RW-4R */
#define NV_PAPU_EPGET_VALUE                                11:2 /* RWXUF */
#define NV_PAPU_EPPUT                                      0x0005FF04 /* RW-4R */
#define NV_PAPU_EPPUT_VALUE                                11:2 /* RWXUF */
#define NV_PAPU_EPIDRDY                                    0x0005FF10 /* RW-4R */
#define NV_PAPU_EPIDRDY_EPSETIDLE                          0:0 /* RW-VF */
#define NV_PAPU_EPIDRDY_EPSETIDLE_NOT_SET                  0x00000000 /* RWI-V */
#define NV_PAPU_EPIDRDY_EPSETIDLE_SET                      0x00000001 /* -W--V */
#define NV_PAPU_EPIDRDY_EPSTOPPED                          1:1 /* RW-VF */
#define NV_PAPU_EPIDRDY_EPSTOPPED_NOT_SET                  0x00000000 /* RWI-V */
#define NV_PAPU_EPIDRDY_EPSTOPPED_SET                      0x00000001 /* RW--V */
#define NV_PAPU_EPIDRDY_EPSTOP_ENABLE                      2:2 /* -W-VF */
#define NV_PAPU_EPIDRDY_EPSTOP_NOT_ENABLED                 0x00000000 /* -WI-V */
#define NV_PAPU_EPIDRDY_EPSTOP_ENABLED                     0x00000001 /* -W--V */
#define NV_PAPU_EPIDRDY_EPSETNINT                          3:3 /* -W-VF */
#define NV_PAPU_EPIDRDY_EPSETNINT_NOT_SET                  0x00000000 /* -WI-V */
#define NV_PAPU_EPIDRDY_EPSETNINT_SET                      0x00000001 /* -W--V */
#define NV_PAPU_EPT0CFG                                    0x0005FEC0 /* RW-4R */
#define NV_PAPU_EPT0CFG_EPT0RUN                            0:0 /* RW-VF */
#define NV_PAPU_EPT0CFG_EPT0RUN_IDLE                       0x00000000 /* RWI-V */
#define NV_PAPU_EPT0CFG_EPT0RUN_RUN                        0x00000001 /* RW--V */
#define NV_PAPU_EPT0CFG_EPT0DSTP                           1:1 /* RW-VF */
#define NV_PAPU_EPT0CFG_EPT0DSTP_RUN                       0x00000000 /* RWI-V */
#define NV_PAPU_EPT0CFG_EPT0DSTP_HOLD                      0x00000001 /* RW--V */
#define NV_PAPU_EPT1CFG                                    0x0005FED0 /* RW-4R */
#define NV_PAPU_EPT1CFG_EPT1RUN                            0:0 /* RW-VF */
#define NV_PAPU_EPT1CFG_EPT1RUN_IDLE                       0x00000000 /* RWI-V */
#define NV_PAPU_EPT1CFG_EPT1RUN_RUN                        0x00000001 /* RW--V */
#define NV_PAPU_EPT1CFG_EPT1DSTP                           1:1 /* RW-VF */
#define NV_PAPU_EPT1CFG_EPT1DSTP_RUN                       0x00000000 /* RWI-V */
#define NV_PAPU_EPT1CFG_EPT1DSTP_HOLD                      0x00000001 /* RW--V */
#define NV_PAPU_EPT0CTL                                    0x0005FEC4 /* RW-4R */
#define NV_PAPU_EPT0CTL_EPT0ACT                            1:0 /* -W-VF */
#define NV_PAPU_EPT0CTL_EPT0ACT_NOP                        0x00000000 /* -WI-V */
#define NV_PAPU_EPT0CTL_EPT0ACT_STZERO                     0x00000001 /* -W--V */
#define NV_PAPU_EPT0CTL_EPT0ACT_STCUR                      0x00000002 /* -W--V */
#define NV_PAPU_EPT0CTL_EPT0ACT_STOP                       0x00000003 /* -W--V */
#define NV_PAPU_EPT0CTL_EPT0ST                             2:2 /* R--VF */
#define NV_PAPU_EPT0CTL_EPT0ST_STOP                        0x00000000 /* R-I-V */
#define NV_PAPU_EPT0CTL_EPT0ST_RUN                         0x00000001 /* R---V */
#define NV_PAPU_EPT1CTL                                    0x0005FED4 /* RW-4R */
#define NV_PAPU_EPT1CTL_EPT1ACT                            1:0 /* -W-VF */
#define NV_PAPU_EPT1CTL_EPT1ACT_NOP                        0x00000000 /* -WI-V */
#define NV_PAPU_EPT1CTL_EPT1ACT_STZERO                     0x00000001 /* -W--V */
#define NV_PAPU_EPT1CTL_EPT1ACT_STCUR                      0x00000002 /* -W--V */
#define NV_PAPU_EPT1CTL_EPT1ACT_STOP                       0x00000003 /* -W--V */
#define NV_PAPU_EPT1CTL_EPT1ST                             2:2 /* R--VF */
#define NV_PAPU_EPT1CTL_EPT1ST_STOP                        0x00000000 /* R-I-V */
#define NV_PAPU_EPT1CTL_EPT1ST_RUN                         0x00000001 /* R---V */
#define NV_PAPU_EPT0TCNT                                   0x0005FEC8 /* RW-4R */
#define NV_PAPU_EPT0TCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_EPT1TCNT                                   0x0005FED8 /* RW-4R */
#define NV_PAPU_EPT1TCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_EPT0CCNT                                   0x0005FECC /* RW-4R */
#define NV_PAPU_EPT0CCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_EPT1CCNT                                   0x0005FEDC /* RW-4R */
#define NV_PAPU_EPT1CCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_EPISTS                                     0x0005FF14 /* RW-4R */
#define NV_PAPU_EPISTS_EPSTRTSTS                           0:0 /* RW-VF */
#define NV_PAPU_EPISTS_EPSTRTSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPSTRTSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPSTRTSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPABRTSTS                           1:1 /* RW-VF */
#define NV_PAPU_EPISTS_EPABRTSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPABRTSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPABRTSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPPUTSTS                            2:2 /* RW-VF */
#define NV_PAPU_EPISTS_EPPUTSTS_NO_INTR                    0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPPUTSTS_INTR                       0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPPUTSTS_CLR                        0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPMBISTS                            3:3 /* RW-VF */
#define NV_PAPU_EPISTS_EPMBISTS_NO_INTR                    0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPMBISTS_INTR                       0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPMBISTS_CLR                        0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPD1STS                             4:4 /* R--VF */
#define NV_PAPU_EPISTS_EPD1STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPD1STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPD1STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPD2STS                             5:5 /* RW-VF */
#define NV_PAPU_EPISTS_EPD2STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPD2STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPD2STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPD3STS                             6:6 /* RW-VF */
#define NV_PAPU_EPISTS_EPD3STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPD3STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPD3STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPDEOLSTS                           7:7 /* RW-VF */
#define NV_PAPU_EPISTS_EPDEOLSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPDEOLSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPDEOLSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPT0STS                             8:8 /* RW-VF */
#define NV_PAPU_EPISTS_EPT0STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPT0STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPT0STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPT1STS                             9:9 /* RW-VF */
#define NV_PAPU_EPISTS_EPT1STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPT1STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPT1STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPDERRSTS                           10:10 /* RW-VF */
#define NV_PAPU_EPISTS_EPDERRSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPDERRSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPDERRSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_EPGSCNT                                    0x0005FF18 /* R--4R */
#define NV_PAPU_EPGSCNT_GSCNT                              23:0 /* R--UF */
#define NV_PAPU_EPDCFG                                     0x0005FF5C /* RW-4R */
#define NV_PAPU_EPDCFG_EPDASTRT                            0:0 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDASTRT_DISABLED                   0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDASTRT_ENABLED                    0x00000001 /* RW--V */
#define NV_PAPU_EPDCFG_EPDARDY                             1:1 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDARDY_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDARDY_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_EPDCFG_EPDIOCR                             2:2 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDIOCR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDIOCR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_EPDCFG_EPDEOLR                             3:3 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDEOLR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDEOLR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_EPDCFG_EPDERRR                             4:4 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDERRR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDERRR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_EPDCTL                                     0x0005FF58 /* RW-4R */
#define NV_PAPU_EPDCTL_EPDACT                              2:0 /* RW-VF */
#define NV_PAPU_EPDCTL_EPDACT_NOP                          0x00000000 /* RWI-V */
#define NV_PAPU_EPDCTL_EPDACT_START                        0x00000001 /* -W--V */
#define NV_PAPU_EPDCTL_EPDACT_STOP                         0x00000002 /* -W--V */
#define NV_PAPU_EPDCTL_EPDACT_FREEZE                       0x00000003 /* -W--V */
#define NV_PAPU_EPDCTL_EPDACT_UNFREEZE                     0x00000004 /* -W--V */
#define NV_PAPU_EPDCTL_EPDFRZ                              3:3 /* R--VF */
#define NV_PAPU_EPDCTL_EPDFRZ_NOT_FROZE                    0x00000000 /* R-I-V */
#define NV_PAPU_EPDCTL_EPDFRZ_FROZE                        0x00000001 /* R---V */
#define NV_PAPU_EPDCTL_EPDRUN                              4:4 /* R--VF */
#define NV_PAPU_EPDCTL_EPDRUN_NOT_RUN                      0x00000000 /* R-I-V */
#define NV_PAPU_EPDCTL_EPDRUN_RUNNING                      0x00000001 /* R---V */
#define NV_PAPU_EPDCTL_EPDSTP                              5:5 /* R--VF */
#define NV_PAPU_EPDCTL_EPDSTP_NOT_STOP                     0x00000000 /* R-I-V */
#define NV_PAPU_EPDCTL_EPDFRZ_STOPPED                      0x00000001 /* R---V */
#define NV_PAPU_EPDSPT                                     0x0005FF54 /* RW-4R */
#define NV_PAPU_EPDSPT_EPDSBPT                             13:0 /* RW-VF */
#define NV_PAPU_EPDSPT_EPDSBPT_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_EPDSPT_EPDEOL                              14:14 /* RW-VF */
#define NV_PAPU_EPDSPT_EPDEOL_EOL                          0x00000001 /* RWI-V */
#define NV_PAPU_EPDSPT_EPDEOL_NOT_EOL                      0x00000000 /* RW--V */
#define NV_PAPU_EPNSPT                                     0x0005FF50 /* RW-4R */
#define NV_PAPU_EPNSPT_EPNSBPT                             13:0 /* RW-VF */
#define NV_PAPU_EPNSPT_EPNSBPT_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_EPNSPT_EPNEOL                              14:14 /* RW-VF */
#define NV_PAPU_EPNSPT_EPNEOL_EOL                          0x00000001 /* RWI-V */
#define NV_PAPU_EPNSPT_EPNEOL_NOT_EOL                      0x00000000 /* RW--V */
#define NV_PAPU_EPDBASE(i)                                 (0x0005FF30+(i)*8) /* RW-4A */
#define NV_PAPU_EPDBASE__SIZE_1                            4 /* */ 
#define NV_PAPU_EPDBASE_BASE                               23:0 /* R--UF */
#define NV_PAPU_EPDSIZE(i)                                 (0x0005FF34+(i)*8) /* RW-4A */
#define NV_PAPU_EPDSIZE__SIZE_1                            4 /* */ 
#define NV_PAPU_EPDSIZE_SIZE                               23:0 /* R--UF */
#define NV_PAPU_EPDDEBUG                                   0x0005FF2C /* R--4R */
#define NV_PAPU_EPDDEBUG_PBADBLK                           13:0 /* R--VF */
#define NV_PAPU_EPDDEBUG_ILLSMBUFID                        14:14 /* R--VF */
#define NV_PAPU_EPDDEBUG_ILLSMBUFID_NOT_ILL                0x00000000 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLSMBUFID_ILL                    0x00000001 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLSMDATAFMT                      15:15 /* R--VF */
#define NV_PAPU_EPDDEBUG_ILLSMDATAFMT_NOT_ILL              0x00000000 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLSMDATAFMT_ILL                  0x00000001 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLCOUNT                          16:16 /* R--VF */
#define NV_PAPU_EPDDEBUG_ILLCOUNT_NOT_ILL                  0x00000000 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLCOUNT_ILL                      0x00000001 /* R---V */

#endif /* __NV_PAPU_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpxcore.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpxcore.cpp
 *  Content:    MCP-X core object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/24/01    dereks  Separated from APU object for kernel ROM bring-up.
 *
 ****************************************************************************/

#include "dsoundi.h"


/****************************************************************************
 *
 *  CMcpxCore
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::CMcpxCore"

const DWORD CMcpxCore::m_adwGPOutputBufferSizes[MCPX_GPOUTPUT_COUNT] =
{
    0x2000  // MCPX_GPOUTPUT_BOOT_SOUND
};

const DWORD CMcpxCore::m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_COUNT] =
{
    0x2000, // MCPX_EPOUTPUT_AC97_ANALOG
    0x4000  // MCPX_EPOUTPUT_AC97_DIGITAL
};

MCPX_ALLOC_CONTEXT CMcpxCore::m_ctxMemory[MCPX_MEM_COUNT];

CMcpxCore::CMcpxCore
(
    CDirectSoundSettings *  pSettings
)
{
    DPF_ENTER();

    m_pSettings = ADDREF(pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxCore
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::~CMcpxCore"

CMcpxCore::~CMcpxCore
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();

#ifdef MCPX_BOOT_LIB

    Reset();

#else // MCPX_BOOT_LIB

    //
    // We're assuming the derived object already called Reset
    //

#endif // MCPX_BOOT_LIB

    //
    // Free the DSP managers
    //

    DELETE(m_pGpDspManager);

#ifndef MCPX_BOOT_LIB

    DELETE(m_pEpDspManager);

#endif // MCPX_BOOT_LIB

    //
    // Free APU memory
    //

    for(i = 0; i < MCPX_MEM_COUNT; i++)
    {

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

        if(m_ctxMemory[i].fOwned)

#endif // ENABLE_SLOP_MEMORY_RECOVERY

        {
            PHYSFREE(m_ctxMemory[i].VirtualAddress);
        }

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

        else
        {
            m_ctxMemory[i].VirtualAddress = NULL;
        }

#endif // ENABLE_SLOP_MEMORY_RECOVERY

        m_ctxMemory[i].PhysicalAddress = 0;
        m_ctxMemory[i].Size = 0;
    }

    //
    // Release object references
    //

    RELEASE(m_pSettings);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

    RELEASE(m_pSlopMemoryHeap);

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Intializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::Initialize"

HRESULT 
CMcpxCore::Initialize
(
    void
)
{
    HRESULT                 hr;

    DPF_ENTER();

    //
    // Make sure we're in a known good state
    //
    
    Reset();

    //
    // Allocate memory
    //

    hr = AllocateApuMemory();

    //
    // Set up the front-end and voice processor
    //

    if(SUCCEEDED(hr))
    {
        SetupFrontEndProcessor();
        SetupVoiceProcessor();
    }

    //
    // Set up the AC97
    //

    if(SUCCEEDED(hr))
    {
        hr = SetupAc97();
    }

    //
    // Set up the DSPs
    //

    if(SUCCEEDED(hr)) 
    {
        SetupDSPs();
    }    

    //
    // Set up the APU/ACI link
    //

    if(SUCCEEDED(hr))
    {
        SetSetupEngineState(MCPX_SE_STATE_DEFAULT);
    }

    //
    // Start the ACI channels running
    //

    if(SUCCEEDED(hr))
    {       
        m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Run();
        m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Run();
    }

    DPF_LEAVE_HRESULT(hr);

	return hr;
}


/****************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Resets the APU state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to only do a partial reset.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::Reset"

void
CMcpxCore::Reset
(
    void
)
{
    DPF_ENTER();

    //
    // Shut down the AC'97
    //

    m_Ac97.Terminate();

    //
    // Shut down the APU components
    //

    IdleVoiceProcessor(TRUE);
    SetInterruptState(FALSE);
    SetPrivLockState(TRUE);
    SetFrontEndState(MCPX_FE_STATE_HALTED);
    SetSetupEngineState(MCPX_SE_STATE_OFF);

    MCPX_REG_WRITE(NV_PAPU_TVL2D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_TVL3D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_TVLMP, 0xFFFF);

    MCPX_REG_WRITE(NV_PAPU_CVL2D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_CVL3D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_CVLMP, 0xFFFF);

    MCPX_REG_WRITE(NV_PAPU_NVL2D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_NVL3D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_NVLMP, 0xFFFF);

    MCPX_REG_WRITE(NV_PAPU_GPRST, 0);
    MCPX_REG_WRITE(NV_PAPU_EPRST, 1);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetupFrontEndProcessor
 *
 *  Description:
 *      Sets up the front-end processor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetupFrontEndProcessor"

void
CMcpxCore::SetupFrontEndProcessor
(
    void
)
{
    DWORD                   dwForce[2]      = { 0, 0 };
    DWORD                   dwIgnore[2]     = { 0, 0 };
    R_INTR                  rInterruptMask;
    R_FE_CONTROL            rFeControl;
    R_SE_CONTROL            rSeControl;
    DWORD                   i;

    DPF_ENTER();

    //
    // Setup interrupt masks
    //

    rInterruptMask.uValue = 0;
    rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;

#ifdef MCPX_ENABLE_DELTA_WARNINGS

    rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_ENABLED;

#else // MCPX_ENABLE_DELTA_WARNINGS

    rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_DISABLED;

#endif // MCPX_ENABLE_DELTA_WARNINGS

    rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_ENABLED;
    rInterruptMask.FETrap = NV_PAPU_IEN_FETINTEN_ENABLED;
    rInterruptMask.FENotify = NV_PAPU_IEN_FENINTEN_DISABLED;
    rInterruptMask.FEVoice = NV_PAPU_IEN_FEVINTEN_ENABLED;
    rInterruptMask.FEMethodOverFlow = NV_PAPU_IEN_FEOINTEN_ENABLED;
    rInterruptMask.GPMailbox = NV_PAPU_IEN_GPMINTEN_DISABLED;
    rInterruptMask.GPNotify = NV_PAPU_IEN_GPNINTEN_DISABLED;
    rInterruptMask.EPMailbox = NV_PAPU_IEN_EPMINTEN_DISABLED;
    rInterruptMask.EPNotify = NV_PAPU_IEN_EPNINTEN_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_IEN, rInterruptMask.uValue);

    //
    // Set default FE control bits
    //

    rFeControl.uValue = 0;
    rFeControl.TrapOnNotifier = NV_PAPU_FECTL_FENINT_ENABLED;
    rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
    rFeControl.EnableLock = NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_FECTL, rFeControl.uValue);

    //
    // Set default SE control bits
    //
    
    rSeControl.uValue = 0;
    rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

    MCPX_REG_WRITE(NV_PAPU_SECTL, rSeControl.uValue);

    //
    // We're overriding the internal SE2FE_IDLE_MESSAGE because a couple
    // of things don't work the way they should.  First, the hardware has
    // a race condition that can cause voice list corruption if a VoiceOn
    // method is received with an antecedent voice that has already gone
    // idle.  Second, VoiceRelease causes a PERSIST voice to be removed
    // from the processing list when the envelope completes.  By overriding
    // SE2FE_IDLE_VOICE in software, we can address both of these issues
    //

    dwForce[1] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETFORCE1_SE2FE_IDLE_VOICE);

    MCPX_REG_WRITE(NV_PAPU_FETFORCE0, dwForce[0]);
    MCPX_REG_WRITE(NV_PAPU_FETFORCE1, dwForce[1]);

    //
    // SET_VOICE_TAR_Hrtf has a bug in it that prevents us from setting 
    // a NULL HRTF filter handle (0xFFFF).  This is strictly a parameter
    // validation bug since NULL is a valid value.
    //
    // VoiceOn will cause a BAD_LIST_POINTER trap if the VP isn't idle
    // and we use the INHERIT list type.  We're working around this in
    // CMcpxVoiceClient::ActivateVoice.
    //

    dwIgnore[0] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETIGNORE0_SET_VOICE_TAR_HRTF);
    dwIgnore[0] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETIGNORE0_VOICE_ON);

    MCPX_REG_WRITE(NV_PAPU_FETIGNORE0, dwIgnore[0]);
    MCPX_REG_WRITE(NV_PAPU_FETIGNORE1, dwIgnore[1]);

    //
    // Initialize global counts so we can track how far ahead the output 
    // counter stays from the input
    //

    ResetGlobalCounters();
    
    //
    // Set up boundaries
    //

    MCPX_REG_WRITE(NV_PAPU_FEMAXV, MCPX_HW_MAX_VOICES - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXTV, MCPX_HW_MAX_3D_VOICES - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXHT, MCPX_HW_MAX_3D_VOICES * MCPX_HW_3DFILTERS_PER_VOICE - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXSESSL, MCPX_HW_MAX_SSL_PRDS - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXSESGE, MCPX_HW_MAX_BUFFER_PRDS - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXMB, MCPX_HW_MAX_SUBMIX_BINS);

    MCPX_REG_WRITE(NV_PAPU_FESESSLCTXPA, 0);
    MCPX_REG_WRITE(NV_PAPU_FESESSLMAXOFF, MCPX_MAX_VALID_ADDRESS);

    MCPX_REG_WRITE(NV_PAPU_FESESGECTXPA, 0);
    MCPX_REG_WRITE(NV_PAPU_FESESGEMAXOFF, MCPX_MAX_VALID_ADDRESS);

    MCPX_REG_WRITE(NV_PAPU_FEGPSGECTXPA, 0);
    MCPX_REG_WRITE(NV_PAPU_FEGPSGEMAXOFF, MCPX_MAX_VALID_ADDRESS);

    //
    // Unlock the front end and setup engine
    //

    SetPrivLockState(FALSE);
    SetFrontEndState(MCPX_FE_STATE_FREE_RUNNING);
    SetFrontEndState(MCPX_FE_STATE_ISO);
    SetSetupEngineState(MCPX_SE_STATE_ISO);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AllocateApuMemory
 *
 *  Description:
 *      Allocates system memory buffers ued by the APU.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::AllocateApuMemory"

HRESULT
CMcpxCore::AllocateApuMemory
(
    void
)
{
    BEGIN_DEFINE_STRUCT()
        DWORD               Size;
        DWORD               Alignment;
    END_DEFINE_STRUCT(MCPX_ALLOC_CTX);

    HRESULT                 hr                      = DS_OK;
    MCPX_ALLOC_CTX          Alloc[MCPX_MEM_COUNT];
    DWORD                   i;

    DPF_ENTER();

    //
    // Calculate allocation sizes and alignment.  We piggy-back the SGE heap
    // run markers on the magic write buffer since the magic write only needs
    // a single DWORD.  When we're building the boot sound, we allocate memory
    // for the I3DL2 reverb in the GP scratch.
    //
    // WARNING: to use some of the slop memory allocated due to alignement
    // restrictions, we're piggybacking some data structures on these
    // buffers.  Use extreme care when changing any of these sizes.
    //

    for(i = 0, Alloc[MCPX_MEM_GPOUTPUT].Size = 0; i < NUMELMS(m_adwGPOutputBufferSizes); i++)
    {
        ASSERT(!(m_adwGPOutputBufferSizes[i] % PAGE_SIZE));
        Alloc[MCPX_MEM_GPOUTPUT].Size += m_adwGPOutputBufferSizes[i];
    }

    Alloc[MCPX_MEM_GPOUTPUT].Alignment = PAGE_SIZE;

    for(i = 0, Alloc[MCPX_MEM_EPOUTPUT].Size = 0; i < NUMELMS(m_adwEPOutputBufferSizes); i++)
    {
        ASSERT(!(m_adwEPOutputBufferSizes[i] % PAGE_SIZE));
        Alloc[MCPX_MEM_EPOUTPUT].Size += m_adwEPOutputBufferSizes[i];
    }

    Alloc[MCPX_MEM_EPOUTPUT].Alignment = PAGE_SIZE;

    Alloc[MCPX_MEM_MAGICWRITE].Size = sizeof(DWORD);
    Alloc[MCPX_MEM_MAGICWRITE].Alignment = PAGE_SIZE;

    Alloc[MCPX_MEM_VOICE].Size = MCPX_HW_MAX_VOICES * NV_PAVS_SIZE;
    Alloc[MCPX_MEM_VOICE].Alignment = 0x8000;

    Alloc[MCPX_MEM_NOTIFIERS].Size = sizeof(MCPX_HW_NOTIFICATION) * MCPX_HW_MAX_NOTIFIERS;
    Alloc[MCPX_MEM_NOTIFIERS].Alignment = 0x4000;

    Alloc[MCPX_MEM_INPUTSGE].Size = MCPX_HW_MAX_BUFFER_PRDS * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_INPUTSGE].Alignment = 0x4000;

    Alloc[MCPX_MEM_INPUTPRD].Size = MCPX_HW_MAX_SSL_PRDS * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_INPUTPRD].Alignment = 0x4000;

    Alloc[MCPX_MEM_HRTFTARGET].Size = MCPX_HW_MAX_3D_VOICES * MCPX_HW_3DFILTERS_PER_VOICE * NV_PAHRTFT_SIZE;
    Alloc[MCPX_MEM_HRTFTARGET].Alignment = 0x4000;

    Alloc[MCPX_MEM_HRTFCURRENT].Size = MCPX_HW_MAX_3D_VOICES * NV_PAHRTFC_SIZE;
    Alloc[MCPX_MEM_HRTFCURRENT].Alignment = 0x4000;

    Alloc[MCPX_MEM_GPOUTPUTSGE].Size = Alloc[MCPX_MEM_GPOUTPUT].Size / PAGE_SIZE * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_GPOUTPUTSGE].Alignment = 0x4000;

    Alloc[MCPX_MEM_EPOUTPUTSGE].Size = Alloc[MCPX_MEM_EPOUTPUT].Size / PAGE_SIZE * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_EPOUTPUTSGE].Alignment = 0x4000;

    Alloc[MCPX_MEM_GPMULTIPASS].Size = MCPX_HW_MULTIPASS_NUM_PAGES * PAGE_SIZE;
    Alloc[MCPX_MEM_GPMULTIPASS].Alignment = 0x4000;

    Alloc[MCPX_MEM_GPSCRATCH].Size = ((MCPX_HW_MULTIPASS_NUM_PAGES + MCPX_HW_AC3_NUM_INPUT_PAGES) * PAGE_SIZE) + MCPX_GLOBAL_PROC_SCRATCH_SIZE;
    Alloc[MCPX_MEM_GPSCRATCH].Alignment = 0x4000;

#ifdef MCPX_BOOT_LIB
         
    Alloc[MCPX_MEM_GPSCRATCH].Size += 0x600000;

#endif // MCPX_BOOT_LIB

    Alloc[MCPX_MEM_GPSCRATCHSGE].Size = (MCPX_HW_MAX_FX_SCRATCH_PAGES + (Alloc[MCPX_MEM_GPSCRATCH].Size / PAGE_SIZE)) * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_GPSCRATCHSGE].Alignment = 0x4000;

    Alloc[MCPX_MEM_EPSCRATCH].Size = ((CMcpxEPDspManager::AC3GetTotalScratchSize() / PAGE_SIZE) + 1 + MCPX_HW_AC3_NUM_INPUT_PAGES) * PAGE_SIZE;
    Alloc[MCPX_MEM_EPSCRATCH].Alignment = 0x4000;

    Alloc[MCPX_MEM_EPSCRATCHSGE].Size = Alloc[MCPX_MEM_EPSCRATCH].Size / PAGE_SIZE * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_EPSCRATCHSGE].Alignment = 0x4000;

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

    //
    // Allocate the heap to track unused physical memory so we can reuse it
    // later
    //

    if(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap)
    {
        m_pSlopMemoryHeap = ADDREF(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap);
    }
    else
    {
        hr = HRFROMP(m_pSlopMemoryHeap = NEW(CMcpxSlopMemoryHeap));
    }

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    //
    // Allocate APU memory
    //

    for(i = 0; (i < NUMELMS(Alloc)) && SUCCEEDED(hr); i++)
    {
        m_ctxMemory[i].Size = Alloc[i].Size;
        
        hr = AllocateContext(&m_ctxMemory[i], Alloc[i].Alignment, PAGE_READWRITE);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

        if(SUCCEEDED(hr))
        {
            m_ctxMemory[i].fOwned = !m_pSlopMemoryHeap->AddRun(m_ctxMemory[i].VirtualAddress, BLOCKALIGNPAD(m_ctxMemory[i].Size, PAGE_SIZE), m_ctxMemory[i].Size);
        }

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetupVoiceProcessor
 *
 *  Description:
 *      Sets up the voice processor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetupVoiceProcessor"

void 
CMcpxCore::SetupVoiceProcessor
(
    void
)
{
    DWORD                   dwHrtfMixBins;
    DWORD                   i;

    DPF_ENTER();
    MCPX_CHECK_VOICE_FIFO_INIT(8);

    //
    // Set up the HW voice data structures to point to themselves
    //

    for(i = 0; i < MCPX_HW_MAX_VOICES; i++) 
    {
        MCPX_VOICE_STRUCT_WRITE(i, NV_PAVS_VOICE_TAR_PITCH_LINK, MCPX_MAKE_REG_VALUE(i, NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE));
    }

    //
    // Program the DMA PRD/SGE lists base addresses
    //

    MCPX_REG_WRITE(NV_PAPU_VPVADDR, m_ctxMemory[MCPX_MEM_VOICE].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_VPHTADDR, m_ctxMemory[MCPX_MEM_HRTFTARGET].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_VPHCADDR, m_ctxMemory[MCPX_MEM_HRTFCURRENT].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_VPSGEADDR, m_ctxMemory[MCPX_MEM_INPUTSGE].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_VPSSLADDR, m_ctxMemory[MCPX_MEM_INPUTPRD].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_FENADDR, m_ctxMemory[MCPX_MEM_NOTIFIERS].PhysicalAddress);

    //
    // Initialize all the global tracking parameters
    //

    MCPX_VOICE_WRITE(SetPitchTracking, MCPX_HW_DEFAULT_TRACKING);
    MCPX_VOICE_WRITE(SetFilterTracking, MCPX_HW_DEFAULT_TRACKING);
    MCPX_VOICE_WRITE(SetVolumeTracking, MCPX_HW_DEFAULT_TRACKING);
    MCPX_VOICE_WRITE(SetHRTFTracking, MCPX_HW_DEFAULT_TRACKING);
    MCPX_VOICE_WRITE(SetITDTracking, MCPX_HW_DEFAULT_TRACKING);

    //
    // Map the GP multipass page into the reserved SGE
    //

    MCPX_VOICE_WRITE(SetCurrentInBufSGE, MCPX_HW_MAX_BUFFER_PRDS - 1);
    MCPX_VOICE_WRITE(SetCurrentInBufSGEOffset, m_ctxMemory[MCPX_MEM_GPMULTIPASS].PhysicalAddress);

    //
    // Set 3D mixbins
    //

    dwHrtfMixBins = MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[0].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN0);
    dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[1].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN1);
    dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[2].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN2);
    dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[3].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN3);

    MCPX_VOICE_WRITE(SetHRTFSubmixes, dwHrtfMixBins);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetupGlobalProcessor
 *
 *  Description:
 *      Sets up the global processor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetupGlobalProcessor"

void 
CMcpxCore::SetupGlobalProcessor
(
    void
)                               
{                               
    DWORD                   adwSgeCounts[MCPX_GPOUTPUT_COUNT];
    DWORD                   dwTotalSgeCount;
    DWORD                   dwSgeOffset;
    DWORD                   dwAddress;
    R_GP_RESET              rReset;
    R_GPDMA_CONFIG          rGpDmaConfig;
    R_GP_CONTROL            rControl;
    DSP_CONTROL             DspControl;
    DWORD                   dwPos;
    DWORD                   i, z;
    MCP1_PRD *              pPrd;

    DPF_ENTER();
    
    //
    // Output buffer SGE table base address for output buffers and input buffers
    //

    MCPX_REG_WRITE(NV_PAPU_GPFADDR, m_ctxMemory[MCPX_MEM_GPOUTPUTSGE].PhysicalAddress);

    //
    // Initialize the get/put pointers
    //

    MCPX_REG_WRITE(NV_PAPU_GPGET, 0);
    MCPX_REG_WRITE(NV_PAPU_GPPUT, 0);

    //
    // Tell the hw how big the output SGE array needs to be
    //

    ASSERT(!(m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress % PAGE_SIZE));
    ASSERT(!(m_ctxMemory[MCPX_MEM_GPOUTPUT].Size % PAGE_SIZE));

    dwTotalSgeCount = m_ctxMemory[MCPX_MEM_GPOUTPUT].Size / PAGE_SIZE;

    ASSERT(!(dwTotalSgeCount & 0xFFFF0000));

	MCPX_REG_WRITE(NV_PAPU_GPFMAXSGE, dwTotalSgeCount - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXGPSGE, dwTotalSgeCount - 1);

    MCPX_REG_WRITE(NV_PAPU_GPOFBASE0, 0);
    MCPX_REG_WRITE(NV_PAPU_GPOFEND0,  m_adwGPOutputBufferSizes[0]);

    //
    // Set up the output SGEs
    //

    pPrd = (MCP1_PRD *)m_ctxMemory[MCPX_MEM_GPOUTPUTSGE].VirtualAddress;

    for(i = 0, dwSgeOffset = 0; i < MCPX_GPOUTPUT_COUNT; i++)
    {
        for(z = 0; z < m_adwGPOutputBufferSizes[i] / PAGE_SIZE; z++)
        {
            dwAddress = m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress + ((dwSgeOffset + z) * PAGE_SIZE);
            
            MCPX_CHECK_VOICE_FIFO_INIT(2);
            MCPX_VOICE_WRITE(SetCurrentOutBufSGE, dwSgeOffset + z);
            MCPX_VOICE_WRITE(SetOutBufSGEOffset, dwAddress);

            pPrd[dwSgeOffset + z].uAddr = dwAddress;
            pPrd[dwSgeOffset + z].Control.uValue = 0;
            pPrd[dwSgeOffset + z].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

        }
        
        MCPX_CHECK_VOICE_FIFO_INIT(2);
        MCPX_VOICE_WRITE(SetOutBuf[i].BA, dwSgeOffset * PAGE_SIZE);
        MCPX_VOICE_WRITE(SetOutBuf[i].Len, m_adwGPOutputBufferSizes[i]);

        dwSgeOffset += z;
    }

    //
    // Allocate the scratch space management code and GP DSP code management
    //

    if(!m_pGpDspManager)
    {
        if(!(m_pGpDspManager = NEW(CMcpxGPDspManager)))
        {
            ASSERTMSG("Failed to alloc DSP and scratch classes");
        }

        m_pGpDspManager->Initialize();
    }

    //
    // Take the GP peripherals out of reset, leave DSP core in reset state
    //

    rReset.uValue = 0;
    rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
    rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
    rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
    rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_GPRST, rReset.uValue);

    //
    // Enable the GP
    //

    rControl.Idle = NV_PAPU_GPIDRDY_GPSETIDLE_SET;
    rControl.IntrNotify = NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET;

    MCPX_REG_WRITE(NV_PAPU_GPIDRDY, rControl.uValue);

    //
    // Clear the interrupt status
    //

    MCPX_REG_WRITE(NV_PAPU_GPISTS, 0xFF);

    //
    // Reset the FIFO positions
    //

    MCPX_REG_READ(NV_PAPU_GPOFBASE0, &dwPos);
    MCPX_REG_WRITE(NV_PAPU_GPOFCUR0, dwPos);

    MCPX_REG_READ(NV_PAPU_GPOFBASE1, &dwPos);
    MCPX_REG_WRITE(NV_PAPU_GPOFCUR1, dwPos);

    MCPX_REG_READ(NV_PAPU_GPOFBASE2, &dwPos);
    MCPX_REG_WRITE(NV_PAPU_GPOFCUR2, dwPos);

    MCPX_REG_READ(NV_PAPU_GPOFBASE3, &dwPos);
    MCPX_REG_WRITE(NV_PAPU_GPOFCUR3, dwPos);

    //
    // Now take DSP core out of reset as well
    //

    rReset.DSP = NV_PAPU_GPRST_GPDSPRST_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_GPRST, rReset.uValue);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetupEncodeProcessor
 *
 *  Description:
 *      Sets up the encode processor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetupEncodeProcessor"

void 
CMcpxCore::SetupEncodeProcessor
(
    void
)
{
    DWORD                   dwTotalSgeCount;
    DWORD                   dwSgeOffset;
    DWORD                   dwAddress;
    R_GP_RESET              rReset;
    R_GP_CONTROL            rControl;
    MCP1_PRD *              pPrd;
    R_GPDMA_CONFIG          rConfig;
    DOLBY_CONFIG_TABLE *    pTable;
    BOOL                    fInitial;
    DWORD                   i, z;

    DPF_ENTER();

    //
    // take EP out of reset, but leave DSP core in reset
    //

    rReset.uValue = 0;
    rReset.Global = NV_PAPU_EPRST_EPRST_DISABLED;
    rReset.DSP = NV_PAPU_EPRST_EPDSPRST_ENABLED;
    rReset.NMI = NV_PAPU_EPRST_EPNMI_DISABLED;
    rReset.Abort = NV_PAPU_EPRST_EPABORT_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_EPRST, rReset.uValue);

    //
    // setup the scratch space management and dsp download 
    //

    if(fInitial = !m_pEpDspManager)
    {
        if(!(m_pEpDspManager = NEW(CMcpxEPDspManager))) 
        {
            ASSERTMSG("Failed to alloc Dsp and scratch classes");
        }

        m_pEpDspManager->Initialize(m_pGpDspManager);
    }
    
    //
    // Output buffer SGE table base address for output buffers
    //

    MCPX_REG_WRITE(NV_PAPU_EPFADDR, m_ctxMemory[MCPX_MEM_EPOUTPUTSGE].PhysicalAddress);

    //
    // Initialize the get/put pointers
    //

    MCPX_REG_WRITE(NV_PAPU_EPGET, 0);
    MCPX_REG_WRITE(NV_PAPU_EPPUT, 0);

    //
    // Tell the hw how big the output SGE array needs to be
    //

    dwTotalSgeCount = m_ctxMemory[MCPX_MEM_EPOUTPUT].Size / PAGE_SIZE;

    ASSERT(!(dwTotalSgeCount & 0xFFFF0000));
	MCPX_REG_WRITE(NV_PAPU_EPFMAXSGE, dwTotalSgeCount - 1);

    //
    // Set up the actual PRDs (aka SGEs) in the hardware-owned PRD table
    //

    pPrd = (MCP1_PRD *)m_ctxMemory[MCPX_MEM_EPOUTPUTSGE].VirtualAddress;

    for(i = 0, dwSgeOffset = 0; i < MCPX_EPOUTPUT_COUNT; i++)
    {
        for(z = 0; z < m_adwEPOutputBufferSizes[i] / PAGE_SIZE; z++)
        {
            dwAddress = m_ctxMemory[MCPX_MEM_EPOUTPUT].PhysicalAddress + ((dwSgeOffset + z) * PAGE_SIZE);
            
            pPrd[dwSgeOffset + z].uAddr = dwAddress;
            pPrd[dwSgeOffset + z].Control.uValue = 0;
            pPrd[dwSgeOffset + z].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;
        }
        
        MCPX_REG_WRITE(NV_PAPU_EPOFBASE0 + (0x10 * i), dwSgeOffset * PAGE_SIZE);
        MCPX_REG_WRITE(NV_PAPU_EPOFEND0 + (0x10 * i), dwSgeOffset * PAGE_SIZE + m_adwEPOutputBufferSizes[i]); 

        dwSgeOffset += z;
    }

    if(fInitial)
    {
        //
        // update the DSP dolby code loader table with the output buffer offsets
        //

        m_pEpDspManager->AC3SetAnalogOutput(MCPX_EPOUTPUT_AC97_ANALOG, m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_ANALOG]);

        //
        // Now the digital fifo. Its base offset is right after the analog FIFO
        // update the loader table
        //

        m_pEpDspManager->AC3SetDigitalOutput(MCPX_EPOUTPUT_AC97_DIGITAL, m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_DIGITAL]);

        //
        // add the pages used for multipass buffer output from the GP, into the GP scratch
        // we do this here since the EpDspManager->Initialize() needs to run first and add 
        // its AC3 pages at the end of scratch first. It needs to happen in this order
        //

        m_pGpDspManager->SetMultipassBuffer(&m_ctxMemory[MCPX_MEM_GPMULTIPASS], MCPX_HW_MULTIPASS_NUM_PAGES);   

        //
        // based on the speaker config, setup the dolby DSP code to do the right thing
        //

        if(!DSSPEAKER_IS_SURROUND(m_pSettings->m_dwSpeakerConfig))
        {
            pTable = m_pEpDspManager->GetDolbyConfigTable();

            pTable->do_surround_encode = FALSE;
            pTable->do_game_encode = FALSE;

            if(DSSPEAKER_BASIC(m_pSettings->m_dwSpeakerConfig) == DSSPEAKER_MONO) 
            {
                pTable->do_downmix_encode = 1;
            } 
            else 
            {
                pTable->do_downmix_encode = 2;
            }
        }
    }

    //
    // setup cfg reg
    //

    MCPX_REG_WRITE(NV_PAPU_EPDCFG, 0);

    //
    // setup RDY reg
    //

    rControl.uValue = 0;
    rControl.Idle = NV_PAPU_EPIDRDY_EPSETIDLE_SET;
    rControl.IntrNotify = NV_PAPU_EPIDRDY_EPSETNINT_NOT_SET;

    MCPX_REG_WRITE(NV_PAPU_EPIDRDY, rControl.uValue);
    
    //
    // clear the EPISTS bit
    //

    MCPX_REG_WRITE(NV_PAPU_EPISTS, 0xFFFFFFFF);

    //
    // turn EP dsp core on..
    // BUGBUG nvidia writes a 0x1 as the last thing to turn on the EP (??)
    //

    rReset.DSP = NV_PAPU_EPRST_EPDSPRST_DISABLED;
    MCPX_REG_WRITE(NV_PAPU_EPRST,rReset.uValue);

    DPF_LEAVE_VOID();
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  SetupAc97
 *
 *  Description:
 *      Sets up the AC97.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetupAc97"

HRESULT
CMcpxCore::SetupAc97
(
    void
)
{
    HRESULT                 hr              = DS_OK;
    DWORD                   dwBufferAddress;
    LPCDWORD                adwBufferSizes;
    DWORD                   i;

    DPF_ENTER();

#ifndef MCPX_BOOT_LIB

    dwBufferAddress = m_ctxMemory[MCPX_MEM_EPOUTPUT].PhysicalAddress;
    adwBufferSizes = m_adwEPOutputBufferSizes;

#else

    dwBufferAddress = m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress;
    adwBufferSizes = m_adwGPOutputBufferSizes;

#endif // MCPX_BOOT_LIB

    //
    // Initialize the AC97
    //

    hr = m_Ac97.Initialize(AC97_OBJECTF_DIRECTISR);

    //
    // Create AC97 output channels.  If Dolby Digital isn't turned on in the
    // speaker config, both the analog and digital channels will read from
    // the analog buffer.
    //

    if(SUCCEEDED(hr))
    {
        hr = m_Ac97.CreateChannel(AC97_CHANNELTYPE_ANALOG);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->AttachPacket(dwBufferAddress, adwBufferSizes[AC97_CHANNELTYPE_ANALOG]);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_Ac97.CreateChannel(AC97_CHANNELTYPE_DIGITAL);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Initialize();
    }

    if(SUCCEEDED(hr))
    {

#ifndef MCPX_BOOT_LIB

        if(DSSPEAKER_IS_AC3(m_pSettings->m_dwSpeakerConfig))
        {
            m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->AttachPacket(dwBufferAddress + adwBufferSizes[AC97_CHANNELTYPE_ANALOG], adwBufferSizes[AC97_CHANNELTYPE_DIGITAL]);
            m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->SetMode(DSAC97_MODE_ENCODED);
        }
        else

#endif // MCPX_BOOT_LIB

        {
            m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->AttachPacket(dwBufferAddress, adwBufferSizes[AC97_CHANNELTYPE_ANALOG]);
            m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->SetMode(DSAC97_MODE_PCM);
        }
    }

    DPF_LEAVE_HRESULT(hr);

	return hr;
}


/****************************************************************************
 *
 *  SetInterruptState
 *
 *  Description:
 *      Sets the APU interrupt state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable interrupts, FALSE to disable.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetInterruptState"

void 
CMcpxCore::SetInterruptState
(
    BOOL                    fEnabled
)
{
    R_INTR                  rInterruptMask;

    DPF_ENTER();
    AutoIrql();

    MCPX_REG_READ(NV_PAPU_IEN, &rInterruptMask.uValue);

    rInterruptMask.General = fEnabled ? NV_PAPU_IEN_GINTEN_ENABLED : NV_PAPU_IEN_GINTEN_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_IEN, rInterruptMask.uValue);

    // DPF_BLAB("Interrupts %s", fEnabled ? "enabled" : "disabled");

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetPrivLockState
 *
 *  Description:
 *      Sets the APU priv lock (?) state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to lock, FALSE to unlock.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetPrivLockState"

void 
CMcpxCore::SetPrivLockState
(
    BOOL                    fLocked
)
{
    DWORD                   dwPrivLock;

    DPF_ENTER();
    AutoIrql();

    MCPX_REG_READ(NV_PAPU_FEPRIVLOCK, &dwPrivLock);

    dwPrivLock = MCPX_SET_REG_VALUE(dwPrivLock, fLocked ? NV_PAPU_FEPRIVLOCK_VALUE_LOCKED : NV_PAPU_FEPRIVLOCK_VALUE_UNLOCKED, NV_PAPU_FEPRIVLOCK_VALUE);

    MCPX_REG_WRITE(NV_PAPU_FEPRIVLOCK, dwPrivLock);

    // DPF_BLAB("Priv lock %s", fLocked ? "locked" : "unlocked");

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetFrontEndState
 *
 *  Description:
 *      Sets the front-end state.
 *
 *  Arguments:
 *      MCPX_FE_STATE [in]: state.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetFrontEndState"

void 
CMcpxCore::SetFrontEndState
(
    MCPX_FE_STATE           nState
)
{
    R_FE_CONTROL            rFeControl;

    DPF_ENTER();
    AutoIrql();

    MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);

    switch(nState) 
    {
        case MCPX_FE_STATE_HALTED:
            // DPF_BLAB("FE state set to HALTED");
            
            rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;

            break;

        case MCPX_FE_STATE_FREE_RUNNING:
            // DPF_BLAB("FE state set to FREE_RUNNING");
            
            rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING;

            break;

        case MCPX_FE_STATE_ISO:
            // DPF_BLAB("FE state set to ISO");
            
            rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_ISO;
            rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_ISO;
            rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_ISO;
            rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_ISO;

            break;

        case MCPX_FE_STATE_NON_ISO:
            // DPF_BLAB("FE state set to NON_ISO");
            
            rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_NON_ISO;
            rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_NON_ISO;
            rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_NON_ISO;
            rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_NON_ISO;

            break;

        default:
            ASSERTMSG("Invalid FE state");

            break;
    }

    MCPX_REG_WRITE(NV_PAPU_FECTL, rFeControl.uValue);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetSetupEngineState
 *
 *  Description:
 *      Sets the setup engine state.
 *
 *  Arguments:
 *      MCPX_SE_STATE [in]: state.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::SetSetupEngineState"

void 
CMcpxCore::SetSetupEngineState
(
    MCPX_SE_STATE           nState
)
{
    R_SE_CONTROL            rSeControl;

    DPF_ENTER();
    AutoIrql();

    MCPX_REG_READ(NV_PAPU_SECTL, &rSeControl.uValue);

    switch(nState)
    {
        case MCPX_SE_STATE_OFF:
            // DPF_BLAB("SE state set to OFF");
            
            rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

            break;

        case MCPX_SE_STATE_AC_SYNC:
            // DPF_BLAB("SE state set to AC_SYNC");
            
            rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;

            break;

        case MCPX_SE_STATE_SW:
            // DPF_BLAB("SE state set to SW");
            
            rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_SW;

            break;

        case MCPX_SE_STATE_FREE_RUNNING:
            // DPF_BLAB("SE state set to FREE_RUNNING");
            
            rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;

            break;

        case MCPX_SE_STATE_ISO:
            // DPF_BLAB("SE state set to ISO");
            
            rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_ISO;
            rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_ISO;
            rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_ISO;

            break;

        case MCPX_SE_STATE_NON_ISO:
            // DPF_BLAB("SE state set to NON_ISO");
            
            rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_NON_ISO;
            rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_NON_ISO;
            rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_NON_ISO;

            break;

        default:
            ASSERTMSG("Invalid SE state");

            break;
    }

    MCPX_REG_WRITE(NV_PAPU_SECTL, rSeControl.uValue);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetPhysicalMemoryProperties
 *
 *  Description:
 *      Gets the physical address of a memory buffer, the byte offset into 
 *      the first page and the count of physically contiguous bytes in the
 *      buffer.
 *
 *  Arguments:
 *      LPVOID [in]: buffer virtual address.
 *      DWORD [in]: buffer size.
 *      LPDWORD [out]: page offset.
 *      LPDWORD [out]: contiguous length, in bytes.
 *
 *  Returns:  
 *      DWORD: buffer physical address.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::GetPhysicalMemoryProperties"

DWORD
CMcpxCore::GetPhysicalMemoryProperties
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwPageOffset,
    LPDWORD                 pdwContiguousLength
)
{
    DWORD                   dwBasePhysicalAddress;
    DWORD                   dwBasePageOffset;
    DWORD                   dwContiguousLength;
    DWORD                   dwPhysicalAddress;

    DPF_ENTER();

    //
    // Get the base physical address
    //

    dwBasePhysicalAddress = MmGetPhysicalAddress(pvBuffer);

    //
    // Get the base page offset
    //

    dwBasePageOffset = BYTE_OFFSET(pvBuffer);

    if(pdwPageOffset)
    {
        *pdwPageOffset = dwBasePageOffset;
    }

    //
    // Find the count of contiguous bytes in the remaining pages
    //

    if(pdwContiguousLength)
    {
        dwContiguousLength = PAGE_SIZE - dwBasePageOffset; 

        while(dwContiguousLength < dwBufferSize)
        {
            dwPhysicalAddress = MmGetPhysicalAddress((LPBYTE)pvBuffer + dwContiguousLength);
            ASSERT(!(dwPhysicalAddress & (PAGE_SIZE - 1)));

            if(dwBasePhysicalAddress + dwContiguousLength != dwPhysicalAddress)
            {
                break;
            }

            dwContiguousLength += PAGE_SIZE;
        }

        *pdwContiguousLength = min(dwContiguousLength, dwBufferSize);
    }

    DPF_LEAVE(dwBasePhysicalAddress);

    return dwBasePhysicalAddress;
}


/****************************************************************************
 *
 *  MapTransfer
 *
 *  Description:
 *      Replacement for IoMapTransfer.
 *
 *  Arguments:
 *      LPVOID * [in/out]: buffer virtual address.
 *      LPDWORD [in/out]: buffer size, in bytes.
 *      LPDWORD [out]: count of bytes mapped.
 *
 *  Returns:  
 *      DWORD: buffer physical address.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::MapTransfer"

DWORD
CMcpxCore::MapTransfer
(
    LPVOID *                ppvBuffer,
    LPDWORD                 pdwBufferSize,
    LPDWORD                 pdwBytesMapped
)
{
    DWORD                   dwPhysicalAddress;
    DWORD                   dwPageOffset;
    DWORD                   dwBytesMapped;

    DPF_ENTER();

    dwPhysicalAddress = GetPhysicalMemoryProperties(*ppvBuffer, *pdwBufferSize, &dwPageOffset, NULL);

    dwBytesMapped = min(PAGE_SIZE - dwPageOffset, *pdwBufferSize);

    *ppvBuffer = (LPBYTE)*ppvBuffer + dwBytesMapped;
    *pdwBufferSize -= dwBytesMapped;

    if(pdwBytesMapped)
    {
        *pdwBytesMapped = dwBytesMapped;
    }

    DPF_LEAVE(dwPhysicalAddress);

    return dwPhysicalAddress;
}


/****************************************************************************
 *
 *  AllocateContext
 *
 *  Description:
 *      Allocates physically contiguous memory.
 *
 *  Arguments:
 *      PMCPX_ALLOC_CONTEXT [in/out]: allocation context data.
 *      DWORD [in]: allocation size, in bytes.
 *      DWORD [in]: allocation alignment, in bytes.
 *      DWORD [in]: allocation flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::AllocateContext"

HRESULT
CMcpxCore::AllocateContext
(
    PMCPX_ALLOC_CONTEXT     pContext,
    DWORD                   dwAlignment,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    ASSERT(!pContext->VirtualAddress);
    ASSERT(!pContext->PhysicalAddress);
    ASSERT(pContext->Size);
    ASSERT(dwAlignment);

    if(SUCCEEDED(hr = HRFROMP(pContext->VirtualAddress = PHYSALLOC(BYTE, pContext->Size, dwAlignment, dwFlags))))
    {
        pContext->PhysicalAddress = MmGetPhysicalAddress(pContext->VirtualAddress);
        ASSERT(!(pContext->PhysicalAddress & (dwAlignment - 1)));
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ResetGlobalCounters
 *
 *  Description:
 *      Resets the APU global counters.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::ResetGlobalCounters"

void
CMcpxCore::ResetGlobalCounters
(
    void
)
{
    static const DWORD      dwDelta = m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_ANALOG] / 4;

    DPF_ENTER();

    MCPX_REG_WRITE(NV_PAPU_IGSCNT, dwDelta); 
    MCPX_REG_WRITE(NV_PAPU_XGSCNT, 0);
    MCPX_REG_WRITE(NV_PAPU_DGSCNT, dwDelta);
    MCPX_REG_WRITE(NV_PAPU_WGSCNT, dwDelta / 2);
    MCPX_REG_WRITE(NV_PAPU_RGSCNT, dwDelta - 1);
    MCPX_REG_WRITE(NV_PAPU_PGSCNT, 0);

    MCPX_REG_WRITE(NV_PAPU_EGSCNT, 6 * MCPX_HW_EP_STEP_SIZE);
    MCPX_REG_WRITE(NV_PAPU_DEGSCNT, MCPX_HW_EP_STEP_SIZE);
    MCPX_REG_WRITE(NV_PAPU_ECNTSTP, MCPX_HW_EP_STEP_SIZE);

    MCPX_REG_WRITE(NV_PAPU_EPOFCUR0, 1536);
    MCPX_REG_WRITE(NV_PAPU_EPOFCUR1, m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_ANALOG] + 6144);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  IdleVoiceProcessor
 *
 *  Description:
 *      Puts the VP into an idle state, or restores it from one.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to idle, FALSE to run.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCore::IdleVoiceProcessor"

BOOL
CMcpxCore::IdleVoiceProcessor
(
    BOOL                    fIdle
)
{
    DWORD                   dwTimeout   = MCPX_HW_FRAME_LENGTH_US;
    R_FE_CONTROL            rFeControl;
    R_SE_CONTROL            rSeControl;
    CMcpxNotifier           Notifier;

    DPF_ENTER();
    AutoIrql();

    if(fIdle)
    {
        //
        // Check the current FE and SE states.  If they're not running, we
        // don't need to idle the VP.
        //

        fIdle = FALSE;
        
        MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);
        
        if(NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING == rFeControl.Mode)
        {
            MCPX_REG_READ(NV_PAPU_SECTL, &rSeControl.uValue)
    
            if(NV_PAPU_SECTL_XCNTMODE_OFF != rSeControl.GSCUpdate)
            {
                fIdle = TRUE;
    
                //
                // Turn off the VP
                //
    
                MCPX_CHECK_VOICE_FIFO(1);
                MCPX_VOICE_WRITE(SetProcessorMode, NV1BA0_PIO_SET_MODE_PARAMETER_OFF);

                //
                // Wait for the VP to tell us it's idle
                //

                if(m_ctxMemory[MCPX_MEM_NOTIFIERS].VirtualAddress)
                {
                    Notifier.Initialize(0, 1);
    
                    MCPX_VOICE_WRITE(Synchronize, NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE_WRITE_PE_NOTIFY);

                    while(!Notifier.GetStatus(0))
                    {
                        KeStallExecutionProcessor(1);

                        if(!dwTimeout--)
                        {
                            break;
                        }
                    }

                    Notifier.Reset();
                }
                else
                {
                    KeStallExecutionProcessor(dwTimeout);
                }
            }
        }
    }
    else
    {
        //
        // Turn the VP back on
        //
        
        MCPX_CHECK_VOICE_FIFO(1);
        MCPX_VOICE_WRITE(SetProcessorMode, NV1BA0_PIO_SET_MODE_PARAMETER_RUN);
    }        

    DPF_LEAVE(fIdle);

    return fIdle;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\nv_uap.h ===
/*  FILE: nv_uap.h
 *  CREATED: Mon Nov 20 21:05:43 2000
 *
 *  Copyright (c) 2000, by NVIDIA CORP
 *  All Rights Reserved.
 */

 /*** DO NOT EDIT, THIS FILE GENERATED FROM ../../../manuals/usr_audio_proc.ref ***/


#ifndef __NV_UAP_H__
#define __NV_UAP_H__


/***********************************************/
/* Macros and constants                        */
/***********************************************/

#ifndef REF_VAL
#define DRF_SHIFT(drf)    ((0?drf) % 32)
#define DRF_MASK(drf)     (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define REF_VAL(drf,v)    (((v)>>DRF_SHIFT(drf))&DRF_MASK(drf))
#define REF_NUM(drf,n)    (((n)&DRF_MASK(drf))<<DRF_SHIFT(drf))
#endif /* !REF_VAL */

/***********************************************/
/*    #defines from the manuals                */
/***********************************************/

#define NV1BA0_PIO_FREE                                    0x00000010 /* R--4R */
#define NV1BA0_PIO_FREE_COUNT                              11:2 /* R-X4F */
#define NV1BA0_PIO_FREE_COUNT_FIFO_FULL                    0x00 /* R---V */
#define NV1BA0_PIO_INFO                                    0x00000014 /* R--4R */
#define NV1BA0_PIO_INFO_PIO                                0:0 /* R-X4F */
#define NV1BA0_PIO_INFO_PIO_EMPTY_AND_IDLE                 0x00 /* R---V */
#define NV1BA0_PIO_INFO_PIO_BUSY                           0x01 /* R---V */
#define NV1BA0_PIO_INFO_DMA                                1:1 /* R-X4F */
#define NV1BA0_PIO_INFO_DMA_EMPTY_AND_IDLE                 0x00 /* R---V */
#define NV1BA0_PIO_INFO_DMA_BUSY                           0x01 /* R---V */
#define NV1BA0_CHANNEL_DMA_PUT                             0x00000040 /* -W-4R */
#define NV1BA0_CHANNEL_DMA_PUT_OFFSET                      11:2 /* -WXUF */
#define NV1BA0_CHANNEL_DMA_GET                             0x00000044 /* R--4R */
#define NV1BA0_CHANNEL_DMA_GET_OFFSET                      11:2 /* R-X4F */
#define NV1BA0_PIO_NOP                                     0x00000100 /* -W-4R */
#define NV1BA0_PIO_NOP_PARAMETER                           31:0 /* -W-VF */
#define NV1BA0_PIO_NOTIFICATION_STATUS_DONE_SUCCESS        0x00000001 /* -W--V */
#define NV1BA0_PIO_SYNCHRONIZE                             0x00000104 /* -W-4R */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER                   31:0 /* -W-VF */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER_NO_OPERATION      0x00000000 /* -W--V */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE     0x00000001 /* -W--V */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE_WRITE_PE_NOTIFY 0x00000002 /* -W--V */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE_WRITE_PE_NOTIFY_AWAKEN 0x00000003 /* -W--V */
#define NV1BA0_PIO_SET_TIME                                0x00000108 /* -W-4R */
#define NV1BA0_PIO_SET_TIME_VALUE                          31:0 /* -W-UF */
#define NV1BA0_PIO_SET_MODE                                0x0000010C /* -W-4R */
#define NV1BA0_PIO_SET_MODE_PARAMETER                      31:0 /* -W-VF */
#define NV1BA0_PIO_SET_MODE_PARAMETER_OFF                  0x00000000 /* -W--V */
#define NV1BA0_PIO_SET_MODE_PARAMETER_RUN                  0x00000001 /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE                    0x00000120 /* -W-4R */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE             15:0 /* -W-VF */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE_NULL        0xFFFF /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST               17:16 /* -W-VF */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_INHERIT       0x00 /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_2D_TOP        0x01 /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_3D_TOP        0x02 /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_MP_TOP        0x03 /* -W--V */
#define NV1BA0_PIO_VOICE_ON                                0x00000124 /* -W-4R */
#define NV1BA0_PIO_VOICE_ON_HANDLE                         15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_ON_ENVF                           27:24 /* -W-VF */
#define NV1BA0_PIO_VOICE_ON_ENVF_DISABLE                   0x00 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVF_DELAY                     0x01 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVF_ATTACK                    0x02 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVF_HOLD                      0x03 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVA                           31:28 /* -W-VF */
#define NV1BA0_PIO_VOICE_ON_ENVA_DISABLE                   0x00 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVA_DELAY                     0x01 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVA_ATTACK                    0x02 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVA_HOLD                      0x03 /* -W--V */
#define NV1BA0_PIO_VOICE_OFF                               0x00000128 /* -W-4R */
#define NV1BA0_PIO_VOICE_OFF_HANDLE                        15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_RELEASE                           0x0000012C /* -W-4R */
#define NV1BA0_PIO_VOICE_RELEASE_HANDLE                    15:0 /* -W-VF */
#define NV1BA0_PIO_GET_VOICE_POSITION                      0x00000130 /* -W-4R */
#define NV1BA0_PIO_GET_VOICE_POSITION_HANDLE               15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_PAUSE                             0x00000140 /* -W-4R */
#define NV1BA0_PIO_VOICE_PAUSE_HANDLE                      15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_PAUSE_ACTION                      18:18 /* -W-VF */
#define NV1BA0_PIO_VOICE_PAUSE_ACTION_RESUME               0x00 /* -W--V */
#define NV1BA0_PIO_VOICE_PAUSE_ACTION_STOP                 0x01 /* -W--V */
#define NV1BA0_PIO_SET_CONTEXT_DMA_NOTIFY                  0x00000180 /* -W-4R */
#define NV1BA0_PIO_SET_CONTEXT_DMA_NOTIFY_HANDLE           31:0 /* -W-VF */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM(i)                  (0x00000200+(i)*4) /* -W-4A */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM__SIZE_1             32 /* */ 
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT              2:0 /* -W-VF */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_ZEROBITS     0x00 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_ONEBIT       0x01 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_TWOBITS      0x02 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_THREEBITS    0x03 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_FOURBITS     0x04 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_FIVEBITS     0x05 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_SIXBITS      0x06 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_SEVENBITS    0x07 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM                       0x00000280 /* -W-4R */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT                2:0 /* -W-VF */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_ZEROBITS       0x00 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_ONEBIT         0x01 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_TWOBITS        0x02 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_THREEBITS      0x03 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_FOURBITS       0x04 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_FIVEBITS       0x05 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_SIXBITS        0x06 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_SEVENBITS      0x07 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_SUBMIX(i)                      (0x00000290+(i)*4) /* -W-4A */
#define NV1BA0_PIO_SET_HRTF_SUBMIX__SIZE_1                 4 /* */ 
#define NV1BA0_PIO_SET_HRTF_SUBMIX_BIN                     4:0 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES                       0x000002C0 /* -W-4R */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN0                  4:0 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN1                  12:8 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN2                  20:16 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN3                  28:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOLUME_TRACKING                     0x000002A0 /* -W-4R */
#define NV1BA0_PIO_SET_VOLUME_TRACKING_PARAMETER           11:0 /* -W-UF */
#define NV1BA0_PIO_SET_PITCH_TRACKING                      0x000002A4 /* -W-4R */
#define NV1BA0_PIO_SET_PITCH_TRACKING_PARAMETER            11:0 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_TRACKING                       0x000002A8 /* -W-4R */
#define NV1BA0_PIO_SET_HRTF_TRACKING_PARAMETER             11:0 /* -W-UF */
#define NV1BA0_PIO_SET_ITD_TRACKING                        0x000002AC /* -W-4R */
#define NV1BA0_PIO_SET_ITD_TRACKING_PARAMETER              11:0 /* -W-UF */
#define NV1BA0_PIO_SET_FILTER_TRACKING                     0x000002B0 /* -W-4R */
#define NV1BA0_PIO_SET_FILTER_TRACKING_PARAMETER           11:0 /* -W-UF */
#define NV1BA0_PIO_SET_CURRENT_VOICE                       0x000002F8 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_VOICE_HANDLE                15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_LOCK                              0x000002FC /* -W-4R */
#define NV1BA0_PIO_VOICE_LOCK_PARAMETER                    7:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF                0x00000000 /* -W--V */
#define NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON                 0x00000001 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN                      0x00000300 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V0BIN                4:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V1BIN                9:5 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V2BIN                14:10 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V3BIN                20:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V4BIN                25:21 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V5BIN                30:26 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT                       0x00000304 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V6BIN                 4:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V7BIN                 9:5 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V6PHASE               10:10 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V6PHASE_POSITIVE      0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V6PHASE_NEGATIVE      0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V7PHASE               11:11 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V7PHASE_POSITIVE      0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V7PHASE_NEGATIVE      0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_GAIN                  12:12 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_GAIN_X1               0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_GAIN_X2               0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM              15:13 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC0_FLT0    0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC0_FLT1    0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC0_FLT2    0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC0_FLT3    0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC1_FLT0    0x04 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC1_FLT1    0x05 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC1_FLT2    0x06 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC1_FLT3    0x07 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS0   0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS1   0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS2   0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS3   0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS4   0x04 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS5   0x05 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS6   0x06 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS7   0x07 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLES_PER_BLOCK     20:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS_BIN__ALIAS__ 20:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS             21:21 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS_OFF         0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS_ON          0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LINKED_VOICE          22:22 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LINKED_VOICE_OFF      0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LINKED_VOICE_ON       0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST               23:23 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_OFF           0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_ON            0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE             24:24 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE_BUFFER      0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE_STREAM      0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP                  25:25 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_OFF              0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_ON               0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CLEAR_MIX             26:26 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CLEAR_MIX_FALSE       0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CLEAR_MIX_TRUE        0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO                27:27 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO_DISABLE        0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO_ENABLE         0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE           29:28 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_U8        0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S16       0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S24       0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S32       0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE        31:30 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B8     0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B16    0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM  0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B32    0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV0                      0x00000308 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV0_EA_ATTACKRATE        11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV0_EA_DELAYTIME         23:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV0_EF_PITCHSCALE        31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVA                      0x0000030C /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_DECAYRATE         11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_HOLDTIME          23:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_SUSTAINLEVEL      31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV1                      0x00000310 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_ATTACKRATE        11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_DELAYTIME         23:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_FCSCALE           31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVF                      0x00000314 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_DECAYRATE         11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_HOLDTIME          23:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_SUSTAINLEVEL      31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC                      0x00000318 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_EF_RELEASERATE       11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOA_DELAYMODE       14:14 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOA_DELAYMODE_NORMAL 0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOA_DELAYMODE_DELAY 0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOF_DELAYMODE       15:15 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOF_DELAYMODE_NORMAL 0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOF_DELAYMODE_DELAY 0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE                17:16 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_BYPASS         0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_STEREO_DLS2    0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_STEREO_P_EQ    0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_STEREO_BYPASS  0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_MONO_DLS2      0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_MONO_P_EQ      0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_MONO_DLS2_P_EQ 0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_THREED_DLS2_I3DL2 0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_THREED_P_EQ_I3DL2 0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_THREED_I3DL2   0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_BPQ                  20:18 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT     23:23 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT_DISABLE 0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT_ENABLE 0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_V_GSCNT              31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_HRTF                      0x0000031C /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_HRTF_HANDLE               15:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY                    0x00000350 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOADLY            14:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOADR             15:15 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOFDLY            30:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOFDR             31:31 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_SSL_A                         0x00000320 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_SSL_A_COUNT                   7:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_SSL_A_BASE                    23:8 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_SSL_B                         0x0000035C /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_SSL_B_COUNT                   7:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_SSL_B_BASE                    23:8 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_BASE                  0x000003A0 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_BASE_OFFSET           23:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_LBO                   0x000003A4 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_LBO_OFFSET            23:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_BUF_CBOFRAC                   0x000003D4 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_BUF_CBOFRAC_FRACTION          15:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_BUF_CBO                       0x000003D8 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_BUF_CBO_OFFSET                23:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_EBO                   0x000003DC /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_EBO_OFFSET            23:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA                      0x00000360 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME6_B3_0         3:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME0              15:4 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME7_B3_0         19:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME1              31:20 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB                      0x00000364 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME6_B7_4         3:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME2              15:4 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME7_B7_4         19:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME3              31:20 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC                      0x00000368 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME6_B11_8        3:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME4              15:4 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME7_B11_8        19:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME5              31:20 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_ENV                       0x0000036C /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_LFO_ENV_EA_RELEASERATE        11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_ENV_LFOADLT               21:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_ENV_LFOFDLT               31:22 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD                       0x00000370 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAAM                7:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAFM                15:8 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAFC                23:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOFFM                31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_FCA                       0x00000374 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_FCA_FC0                   15:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_FCA_FC1                   31:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_FCB                       0x00000378 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_FCB_FC2                   15:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_FCB_FC3                   31:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_PITCH                     0x0000037c /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_PITCH_STEP                31:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_PITCH_STEP_SMAX           0x00001fff /* -W--V */
#define NV1BA0_PIO_SET_CURRENT_HRTF_ENTRY                  0x00000160 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_HRTF_ENTRY_HANDLE           15:0 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR(i)                             (0x00000400+(i)*4) /* -W-4A */
#define NV1BA0_PIO_SET_HRIR__SIZE_1                        15 /* */ 
#define NV1BA0_PIO_SET_HRIR_LEFT0                          7:0 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_RIGHT0                         15:8 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_LEFT1                          23:16 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_RIGHT1                         31:24 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_X                              0x0000043C /* -W-4R */
#define NV1BA0_PIO_SET_HRIR_X_LEFT30                       7:0 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_X_RIGHT30                      15:8 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_X_ITD                          31:16 /* -W-SF */
#define NV1BA0_PIO_SET_HRIR_X_ITD_SMIN                     0x0000ac01 /* RW--V */
#define NV1BA0_PIO_SET_HRIR_X_ITD_SMAX                     0x000053ff /* RW--V */
#define NV1BA0_PIO_SET_CURRENT_SSL_CONTEXT_DMA             0x0000018C /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_SSL_CONTEXT_DMA_HANDLE      31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_SSL                         0x00000190 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_SSL_BASE_PAGE               21:6 /* -W-VF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET(i)               (0x00000600+(i)*8) /* -W-4A */
#define NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET__SIZE_1          64 /* */ 
#define NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET_PARAMETER        31:0 /* -W-VF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH(i)               (0x00000604+(i)*8) /* -W-4A */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH__SIZE_1          64 /* */ 
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_PARAMETER        15:0 /* -W-UF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE   17:16 /* -W-VF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B8 0x00 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B16 0x01 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_ADPCM 0x02 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B32 0x03 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_SAMPLES_PER_BLOCK 22:18 /* -W-UF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO           23:23 /* -W-VF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO_NOTOK     0x00 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO_OK        0x01 /* -W--V */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_CONTEXT_DMA       0x00000800 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_CONTEXT_DMA_HANDLE 31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE                   0x00000804 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_HANDLE            31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_OFFSET            0x00000808 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_OFFSET_PARAMETER  31:12 /* -W-VF */
#define NV1BA0_PIO_SET_OUTBUF_BA(i)                        (0x00001000+(i)*8) /* -W-4A */
#define NV1BA0_PIO_SET_OUTBUF_BA__SIZE_1                   4 /* */ 
#define NV1BA0_PIO_SET_OUTBUF_BA_ADDRESS                   22:8 /* -W-UF */
#define NV1BA0_PIO_SET_OUTBUF_LEN(i)                       (0x00001004+(i)*8) /* -W-4A */
#define NV1BA0_PIO_SET_OUTBUF_LEN__SIZE_1                  4 /* */ 
#define NV1BA0_PIO_SET_OUTBUF_LEN_VALUE                    22:8 /* -W-UF */
#define NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE                  0x00001800 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_HANDLE           31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA      0x00001804 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA_HANDLE 31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET           0x00001808 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET_PARAMETER 31:12 /* -W-VF */
#define NV1BA0_DMA_NOP                                     0x00000100 /* -W-4R */
#define NV1BA0_DMA_NOP_PARAMETER                           31:0 /* -W-VF */

#endif /* __NV_UAP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\mcpxcore.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpxcore.h
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __MCPXCORE_H__
#define __MCPXCORE_H__

// #define MCPX_LOG_APU_WRITES
// #define MCPX_LOG_APU_READS
// #define MCPX_LOG_VP_WRITES
// #define MCPX_LOG_VOICE_STRUCT_READS
// #define MCPX_LOG_VOICE_STRUCT_WRITES

#define MCPX_DEBUG_STUCK_VOICES
// #define MCPX_NO_VOICE_OFF
#define MCPX_HANDLE_DELTA_PANICS_FROM_ISR
// #define MCPX_ENABLE_DELTA_WARNINGS
// #define MCPX_SIMULATE_STUCK_VOICE
#define MCPX_NO_OVERLAP_MIXBINS

#ifdef DEBUG
// #define MCPX_ENABLE_ISR_DEBUGGING
#endif // DEBUG

#include "mcpxhw.h"

DEFINETYPE(MCPX_VOICE_HANDLE, WORD);

#define MCPX_VOICE_HANDLE_INVALID ((MCPX_VOICE_HANDLE)~0UL)

#ifdef __cplusplus

//
// Register value macros
//

#define MCPX_REF_SHIFT(drf) \
    (0 ? drf)

#define MCPX_REF_MASK(drf) \
    ((1 << ((1 ? drf) - (0 ? drf) + 1)) - 1)

#define MCPX_CLEAR_REG_VALUE(arg, drf) \
    ((arg) & ~(MCPX_REF_MASK(drf) << MCPX_REF_SHIFT(drf)))

#define MCPX_MAKE_REG_VALUE(val, drf) \
    ((((DWORD)(val)) & MCPX_REF_MASK(drf)) << MCPX_REF_SHIFT(drf))

#define MCPX_GET_REG_VALUE(arg, drf) \
    (((arg) >> MCPX_REF_SHIFT(drf)) & MCPX_REF_MASK(drf))

#define MCPX_SET_REG_VALUE(arg, val, drf) \
    (MCPX_CLEAR_REG_VALUE(arg, drf) | MCPX_MAKE_REG_VALUE(val, drf))

#define MCPX_DEVICE_BASE(d) \
    (0 ? d)

//
// APU core register access macros
//

#ifdef MCPX_LOG_APU_WRITES
#define DPF_MCPX_APU_WRITE DPF_ABSOLUTE
#else // MCPX_LOG_APU_WRITES
#define DPF_MCPX_APU_WRITE()
#endif // MCPX_LOG_APU_WRITES

#ifdef MCPX_LOG_APU_READS
#define DPF_MCPX_APU_READ DPF_ABSOLUTE
#else // MCPX_LOG_APU_READS
#define DPF_MCPX_APU_READ()
#endif // MCPX_LOG_APU_READS

#define MCPX_REGISTER_ADDRESS(reg) \
    (XPCICFG_APU_MEMORY_REGISTER_BASE_0 + (reg))

#define MCPX_REGISTER(reg) \
    (*(volatile DWORD *)MCPX_REGISTER_ADDRESS(reg))

#define MCPX_REG_WRITE(reg, value) \
    { \
        DPF_MCPX_APU_WRITE("APU write: offset %x (%x), value %x", (DWORD)(reg), MCPX_REGISTER_ADDRESS(reg), (DWORD)(value)); \
        MCPX_REGISTER(reg) = (DWORD)(value); \
    }

#define MCPX_REG_READ(reg, value) \
    { \
        *(value) = MCPX_REGISTER(reg); \
        DPF_MCPX_APU_READ("APU read: offset %x (%x), value %x", (DWORD)(reg), MCPX_REGISTER_ADDRESS(reg), (DWORD)*(value)); \
    }

//
// VP register access macros
//

#ifdef MCPX_LOG_VP_WRITES
#define DPF_MCPX_VP_WRITE DPF_ABSOLUTE
#else // MCPX_LOG_VP_WRITES
#define DPF_MCPX_VP_WRITE()
#endif // MCPX_LOG_VP_WRITES

#define MCPX_VOICE_PROCESSOR_BASE \
    MCPX_REGISTER_ADDRESS(MCPX_DEVICE_BASE(NV_PAPU_NV1BA0))

#define MCPX_VOICE_REGISTER(reg) \
    (((LPMCPXVPREGSET)MCPX_VOICE_PROCESSOR_BASE)->reg)

#define MCPX_CHECK_VOICE_FIFO_INIT(method_count) \
    { \
        ASSERT((method_count) <= PIO_METHOD_QUEUE_CLEAR); \
        while(MCPX_VOICE_REGISTER(PIOFree) / 4 < (DWORD)(method_count)) \
        { \
            DPF_MCPX_VP_WRITE("Waiting for PIO to free up..."); \
        } \
    }

#define MCPX_CHECK_VOICE_FIFO(method_count) \
    { \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL); \
        MCPX_CHECK_VOICE_FIFO_INIT(method_count); \
    }

#define MCPX_VOICE_WRITE(reg, value) \
    { \
        DPF_MCPX_VP_WRITE("VP write: " QUOTE1(reg) " (offset %x, address %x), value %x", offsetof(MCPXVPREGSET, reg), &MCPX_VOICE_REGISTER(reg), (DWORD)(value)); \
        MCPX_VOICE_REGISTER(reg) = (DWORD)(value); \
    }

//
// Voice data access macros
//

#ifdef MCPX_LOG_VOICE_STRUCT_READS
#define DPF_MCPX_VOICE_STRUCT_READ DPF_ABSOLUTE
#else // MCPX_LOG_VOICE_STRUCT_READS
#define DPF_MCPX_VOICE_STRUCT_READ()
#endif // MCPX_LOG_VOICE_STRUCT_READS

#ifdef MCPX_LOG_VOICE_STRUCT_WRITES
#define DPF_MCPX_VOICE_STRUCT_WRITE DPF_ABSOLUTE
#else // MCPX_LOG_VOICE_STRUCT_WRITES
#define DPF_MCPX_VOICE_STRUCT_WRITE()
#endif // MCPX_LOG_VOICE_STRUCT_WRITES

#define MCPX_VOICE_STRUCT_BASE(voice_index) \
    ((DWORD)(CMcpxCore::m_ctxMemory[MCPX_MEM_VOICE].VirtualAddress) + ((DWORD)(voice_index) * NV_PAVS_SIZE))

#define MCPX_VOICE_STRUCT_OFFSET(voice_index, reg) \
    (MCPX_VOICE_STRUCT_BASE(voice_index) + (reg))

#define MCPX_VOICE_STRUCT(voice_index, reg) \
    (*(volatile DWORD *)MCPX_VOICE_STRUCT_OFFSET(voice_index, reg))

#define MCPX_VOICE_STRUCT_READ(voice_index, reg, value) \
    { \
        *(value) = MCPX_VOICE_STRUCT(voice_index, reg); \
        DPF_MCPX_VOICE_STRUCT_READ("Voice struct read: voice %x, reg %x, address %x, value %x", (DWORD)(voice_index), (DWORD)(reg), MCPX_VOICE_STRUCT_OFFSET(voice_index, reg), (DWORD)*(value)); \
    }

#define MCPX_VOICE_STRUCT_WRITE(voice_index, reg, value) \
    { \
        MCPX_VOICE_STRUCT(voice_index, reg) = (DWORD)(value); \
        DPF_MCPX_VOICE_STRUCT_WRITE("Voice struct write: voice %x, reg %x, address %x, value %x", (DWORD)(voice_index), (DWORD)(reg), MCPX_VOICE_STRUCT_OFFSET(voice_index, reg), (DWORD)(value)); \
    }

// 
// MCP-X physical resource descriptor
//

BEGIN_DEFINE_STRUCT()
	PVOID   VirtualAddress;
	ULONG   PhysicalAddress;
	ULONG   Size;
#ifdef ENABLE_SLOP_MEMORY_RECOVERY
    BOOL    fOwned;
#endif // ENABLE_SLOP_MEMORY_RECOVERY
END_DEFINE_STRUCT(MCPX_ALLOC_CONTEXT);

//
// GP output buffers
//

BEGIN_DEFINE_ENUM()
    MCPX_GPOUTPUT_BOOTSOUND = 0,
    MCPX_GPOUTPUT_COUNT
END_DEFINE_ENUM_();

//
// EP output buffers
//

BEGIN_DEFINE_ENUM()
    MCPX_EPOUTPUT_AC97_ANALOG = 0,
    MCPX_EPOUTPUT_AC97_DIGITAL,
    MCPX_EPOUTPUT_COUNT
END_DEFINE_ENUM_();

//
// Front-end states
//

BEGIN_DEFINE_ENUM()
    MCPX_FE_STATE_HALTED,
    MCPX_FE_STATE_FREE_RUNNING,
    MCPX_FE_STATE_ISO,
    MCPX_FE_STATE_NON_ISO,
END_DEFINE_ENUM(MCPX_FE_STATE);

//
// Setup engine states
//

BEGIN_DEFINE_ENUM()
    MCPX_SE_STATE_OFF = 0,
    MCPX_SE_STATE_AC_SYNC,
    MCPX_SE_STATE_SW,
    MCPX_SE_STATE_FREE_RUNNING,
    MCPX_SE_STATE_ISO,
    MCPX_SE_STATE_NON_ISO,
END_DEFINE_ENUM(MCPX_SE_STATE);

#define MCPX_SE_STATE_DEFAULT MCPX_SE_STATE_AC_SYNC

//
// APU memory.  The order actually matters, so don't mess with it
//

BEGIN_DEFINE_ENUM()
    MCPX_MEM_GPOUTPUT = 0,
    MCPX_MEM_EPOUTPUT,
    MCPX_MEM_MAGICWRITE,
    MCPX_MEM_VOICE,
    MCPX_MEM_NOTIFIERS,
    MCPX_MEM_INPUTSGE,
    MCPX_MEM_INPUTPRD,
    MCPX_MEM_HRTFTARGET,
    MCPX_MEM_HRTFCURRENT,
    MCPX_MEM_GPOUTPUTSGE,    
    MCPX_MEM_EPOUTPUTSGE,
    MCPX_MEM_GPMULTIPASS,
    MCPX_MEM_GPSCRATCH,
    MCPX_MEM_GPSCRATCHSGE,
    MCPX_MEM_EPSCRATCH,
    MCPX_MEM_EPSCRATCHSGE,
    MCPX_MEM_COUNT,
END_DEFINE_ENUM_();

//
// Voice list identifiers.  Add 1 to this value to get the hardware register 
// equivalent.
//

BEGIN_DEFINE_ENUM()
    MCPX_VOICELIST_2D = 0,
    MCPX_VOICELIST_3D,
    MCPX_VOICELIST_MP,
    MCPX_VOICELIST_COUNT,
    MCPX_VOICELIST_INVALID = 0xFF
END_DEFINE_ENUM_();

//
// Voice notifiers
//

#define MCPX_NOTIFIER_BASE_OFFSET 2
                                        
BEGIN_DEFINE_ENUM()
    MCPX_NOTIFIER_SSLA_DONE = 0,
    MCPX_NOTIFIER_SSLB_DONE,
    MCPX_NOTIFIER_SSLA_GETPOS,
    MCPX_NOTIFIER_VOICE_OFF,
    MCPX_NOTIFIER_COUNT
END_DEFINE_ENUM_();

//
// Forward declarations
//

namespace DirectSound
{
    class CDirectSoundSettings;
    class CDirectSoundVoiceSettings;
    class CDirectSoundBufferSettings;
    class CDirectSoundStreamSettings;
    class CMcpxGPDspManager;
    class CMcpxEPDspManager;
}

//
// The MCPX APU core object
//

namespace DirectSound
{
    class CMcpxCore
    {
    public:
        static const DWORD          m_adwGPOutputBufferSizes[MCPX_GPOUTPUT_COUNT];  // GP Output buffer sizes, in bytes
        static const DWORD          m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_COUNT];  // EP Output buffer sizes, in bytes
	    static MCPX_ALLOC_CONTEXT   m_ctxMemory[MCPX_MEM_COUNT];                    // APU memory
        CDirectSoundSettings *      m_pSettings;                                    // Shared settings object

    protected:                      

#ifdef ENABLE_SLOP_MEMORY_RECOVERY
    
        CMcpxSlopMemoryHeap *       m_pSlopMemoryHeap;                              // Slop memory heap

#endif // ENABLE_SLOP_MEMORY_RECOVERY

        CMcpxGPDspManager *         m_pGpDspManager;                                // GP DSP manager object

#ifndef MCPX_BOOT_LIB

        CMcpxEPDspManager *         m_pEpDspManager;                                // EP DSP manager object

#endif // MCPX_BOOT_LIB

        CAc97Device                 m_Ac97;                                         // AC97 device object

    public:
        CMcpxCore(CDirectSoundSettings *pSettings);
        virtual ~CMcpxCore(void);

    public:
        // Initialization
        HRESULT Initialize(void);

        // APU component state
        BOOL IdleVoiceProcessor(BOOL fIdle);

        // Utility functions
        static DWORD GetPhysicalMemoryProperties(LPVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwPageOffset, LPDWORD pdwContiguousLength);
        static DWORD MapTransfer(LPVOID *ppvBuffer, LPDWORD pdwBufferSize, LPDWORD pdwBytesMapped);
        static HRESULT AllocateContext(PMCPX_ALLOC_CONTEXT pContext, DWORD dwAlignment, DWORD dwFlags);

    protected:
        // Shutdown
        void Reset(void);

        // APU component state
        void SetInterruptState(BOOL fEnabled);
        void SetPrivLockState(BOOL fLocked);
        void SetFrontEndState(MCPX_FE_STATE nState);
        void SetSetupEngineState(MCPX_SE_STATE nState);
        void ResetGlobalCounters(void);

        // APU setup
        HRESULT AllocateApuMemory(void);
        void SetupFrontEndProcessor(void);
        void SetupVoiceProcessor(void);
        void SetupDSPs(void);
        void SetupGlobalProcessor(void);

#ifndef MCPX_BOOT_LIB

        void SetupEncodeProcessor(void);

#endif // MCPX_BOOT_LIB

        HRESULT SetupAc97(void);
    };

    __inline void CMcpxCore::SetupDSPs(void)
    {
        SetupGlobalProcessor();

#ifndef MCPX_BOOT_LIB

        SetupEncodeProcessor();
        KeStallExecutionProcessor(10 * 1000);

#endif // MCPX_BOOT_LIB

    }
}

//
// MCPX notifier wrapper class
//

namespace DirectSound
{
    class CMcpxNotifier
    {
    private:
        PMCPX_HW_NOTIFICATION       m_paNotifier;       // Base notifier pointer
        DWORD                       m_dwNotifierCount;  // Count of notifiers controlled by this object

    public:
        CMcpxNotifier(void);

    public:
        // Initialization
        void Initialize(DWORD dwBaseNotifierIndex, DWORD dwNotifierCount);
        void Free(void);

        // Notifier status
        BOOL GetStatus(DWORD dwNotifierIndex);
        void SetStatus(DWORD dwNotifierIndex, BOOL fSignaled);
        void Reset(void);
    };

    __inline CMcpxNotifier::CMcpxNotifier(void)
    {
        Free();
    }

    __inline void CMcpxNotifier::Initialize(DWORD dwBaseNotifierIndex, DWORD dwNotifierCount)
    {
        ASSERT(!m_paNotifier);
        ASSERT(!m_dwNotifierCount);

        m_paNotifier = (PMCPX_HW_NOTIFICATION)CMcpxCore::m_ctxMemory[MCPX_MEM_NOTIFIERS].VirtualAddress + dwBaseNotifierIndex;
        m_dwNotifierCount = dwNotifierCount;

        Reset();
    }

    __inline void CMcpxNotifier::Free(void)
    {
        m_paNotifier = NULL;
        m_dwNotifierCount = 0;
    }

    __inline BOOL CMcpxNotifier::GetStatus(DWORD dwNotifierIndex)
    {
        ASSERT(m_paNotifier);
        ASSERT(dwNotifierIndex < m_dwNotifierCount);
    
        switch(m_paNotifier[dwNotifierIndex].Status)
        {
            case NV1BA0_NOTIFICATION_STATUS_DONE_SUCCESS:
                return TRUE;

            case NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS:
                return FALSE;

            default:
                ASSERTMSG("Unexpected notifier status");
                return FALSE;
        }
    }

    __inline void CMcpxNotifier::SetStatus(DWORD dwNotifierIndex, BOOL fSignaled)
    {
        ASSERT(m_paNotifier);
        ASSERT(dwNotifierIndex < m_dwNotifierCount);

        m_paNotifier[dwNotifierIndex].Status = fSignaled ? NV1BA0_NOTIFICATION_STATUS_DONE_SUCCESS : NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS;
    }

    __inline void CMcpxNotifier::Reset(void)
    {
        DWORD                   dwNotifierIndex;
    
        ASSERT(m_paNotifier);
        ASSERT(m_dwNotifierCount);

        for(dwNotifierIndex = 0; dwNotifierIndex < m_dwNotifierCount; dwNotifierIndex++)
        {
            m_paNotifier[dwNotifierIndex].Status = NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS;
        }
    }
}

//
// Miscelaneous MCPX includes
//

#include "dspdma.h"
#include "gpdsp.h"
#include "epdsp.h"
#include "mcpapu.h"
#include "mcpvoice.h"
#include "mcpbuf.h"
#include "mcpstrm.h"

#endif // __cplusplus

#endif // __MCPXCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\nv_uep.h ===
#ifndef __NV_EAP_H__
#define __NV_EAP_H__

// software methods for the EP...
#define NV1BAE_PIO_SET_OUTBUF_BA(i)                             (0x00000000+(i)*8) /* -W-4A */
#define NV1BAE_PIO_SET_OUTBUF_BA__SIZE_1                        4 /* */ 
#define NV1BAE_PIO_SET_OUTBUF_BA_ADDRESS                        23:0 /* -W-UF */
#define NV1BAE_PIO_SET_OUTBUF_LEN(i)                            (0x00000004+(i)*8) /* -W-4A */
#define NV1BAE_PIO_SET_OUTBUF_LEN__SIZE_1                       4 /* */ 
#define NV1BAE_PIO_SET_OUTBUF_LEN_VALUE                         23:0 /* -W-UF */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE                       0x00000028 /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_HANDLE                31:0 /* -W-VF */
#define NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA           0x0000002C /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA_HANDLE    31:0 /* -W-VF */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET                0x00000030 /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET_PARAMETER      31:12 /* -W-VF */
#define NV1BAE_PIO_SET_STATE                                    0x00000034
#define NV1BAE_PIO_SET_STATE_VALUE                              1:0
#define NV1BAE_PIO_SET_STATE_OFF                                0x00
#define NV1BAE_PIO_SET_STATE_ON                                 0x01
#define NV1BAE_PIO_SET_STATE_DSP_ON                             0x03
#define NV1BAE_PIO_SET_AC3_FIFO                                 0x00000038
#define NV1BAE_PIO_SET_AC3_FIFO_ANALOG_INDEX                    2:0
#define NV1BAE_PIO_SET_AC3_FIFO_DIGITAL_INDEX                   5:3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\nv_ugp.h ===
#ifndef __NV_UGP_H__
#define __NV_UGP_H__

// Gp interface methods for a MCP1 client
// The client will use NV1BA0_CHANNEL_DMA_PUT to put the functions in the commandQ.
// methods are 32 bits.  data is 32 bits

// Address in GP DSP PMEM to place offset of shared EP/GP AC3 output buffer
#define NV_AUDGP_DSP_AC3_OFFSET_ADDR            0x28
#define NV_AUDGP_DSP_GPCOMMANDNODE_OFFSET_ADDR  0x29	// GP Command Node Base Address

// METHOD: SetContextDmaDspBlock - sets context DMA for memory holding the DSP data
// DATA(32) : Context DMA handle
//#define NV_AUDGP_SET_CONTEXT_DMA_DSP_BLOCK               0x0000000
//#define NV_AUDGP_SET_CONTEXT_DMA_DSP_BLOCK_HANDLE        31:0

// METHOD: ReadDSPBlock  read one block from scratch memory
// DATA(32): block ID  (code, module list, state block)
// DATA(32): block byte address
// DATA(32): block byte size
#define NV_AUDGP_READ_DSP_BLOCK                    0x00000001
#define NV_AUDGP_READ_DSP_BLOCK_ID					31:0
#define NV_AUDGP_READ_DSP_BLOCK_ADDRESS				31:0
#define NV_AUDGP_READ_DSP_BLOCK_SIZE				31:0

// METHOD: WriteDSPBlock  write one block to scratch memory
// DATA(32): block ID  (code, module list, state block)
// DATA(32): block byte address
// DATA(32): block byte size
#define NV_AUDGP_WRITE_DSP_BLOCK                    0x00000002
#define NV_AUDGP_WRITE_DSP_BLOCK_ID					31:0
#define NV_AUDGP_WRITE_DSP_BLOCK_ADDRESS			31:0
#define NV_AUDGP_WRITE_DSP_BLOCK_SIZE				31:0

#define NV_AUDGP_DSP_BLOCK_ID_COMMAND_NODE         0x0
#define NV_AUDGP_DSP_BLOCK_ID_MODULE_LIST          0x1
#define NV_AUDGP_DSP_BLOCK_ID_STATE_XRAM           0x2
#define NV_AUDGP_DSP_BLOCK_ID_STATE_YRAM           0x3
#define NV_AUDGP_DSP_BLOCK_ID_CODE                 0x4
#define NV_AUDGP_DSP_BLOCK_ID_STATE_LARGE          0x5

// Some DSP block byte addresses (set in command node)
#define NV_AUDGP_DSP_BLOCK_ID_COMMAND_NODE_OFFSET    19000	// $ 4A38
#define NV_AUDGP_DSP_BLOCK_ID_MODULE_LIST_OFFSET     19100	// $ 4A9C
#define NV_AUDGP_DSP_BLOCK_ID_STATE_XRAM_OFFSET      19500	// $ 4C2C
#define NV_AUDGP_DSP_BLOCK_ID_STATE_YRAM_OFFSET      31788	// $ 7C2C
#define NV_AUDGP_DSP_BLOCK_ID_CODE_OFFSET			 39980	// $ 9C2C
#define NV_AUDGP_DSP_BLOCK_ID_STATE_LARGE_OFFSET     56464	// $ DC90

/*
METHOD: RouteEffect
DATA(32):   effect instance id
            Bit identifying if the effect is the source, or destination,
            Effect Pin 
            Mixer buffer ID
            enable or disable data connection
*/
//#define NV_AUDGP_ROUTE_EFFECT                           0x00000003
#define NV_AUDGP_ROUTE_EFFECT_FILLER                    7:0	// was effectID
#define NV_AUDGP_ROUTE_EFFECT_ORIENTATION               8:8
#define NV_AUDGP_ROUTE_EFFECT_ORIENTATION_SOURCE        0x0
#define NV_AUDGP_ROUTE_EFFECT_ORIENTATION_DEST          0x1
#define NV_AUDGP_ROUTE_EFFECT_PIN                       12:9
#define NV_AUDGP_ROUTE_EFFECT_BUFFER_ID                 20:13
#define NV_AUDGP_ROUTE_EFFECT_CONNECTION                21:21
#define NV_AUDGP_ROUTE_EFFECT_CONNECTION_ENABLE         0x0
#define NV_AUDGP_ROUTE_EFFECT_CONNECTION_DISABLE        0x1

typedef union _routeEffect
{
    struct
    {
        U032 stuf           : 8;	// Filler material
        U032 orientation    : 1;
        U032 pin            : 4;
        U032 bufid          : 8;
        U032 connection     : 1;
        U032                : 10;
    };

	U032 effectID;
    U032 uValue;
} STRUCT_ROUTE_EFFECT;

/*
METHOD: RouteToFIFO - Connects either an effect or buffer to a FIFO 
DATA(32) :  source type (effect or buffer)
            source id (if effect then effect ID, else buffer ID)
            source pin (only used if source type = effect, in which case it's the effect pin)
            fifo type (input fifo, or output fifo) - configure with NV_AUDGP_CONFIGURE_XXX_FIFO
            fifo pin
            connection enable or disable
*/
//#define NV_AUDGP_ROUTE_TO_FIFO                      0x00000004
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_TYPE          0:0
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_TYPE_EFFECT   0x0
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_TYPE_BUFFER   0x1
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_ID            8:1
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_PIN           12:9
#define NV_AUDGP_ROUTE_TO_FIFO_TYPE                 13:13
#define NV_AUDGP_ROUTE_TO_FIFO_TYPE_INPUT           0x0
#define NV_AUDGP_ROUTE_TO_FIFO_TYPE_OUTPUT          0x1
#define NV_AUDGP_ROUTE_TO_FIFO_NUMBER               15:14
#define NV_AUDGP_ROUTE_TO_FIFO_PIN                  19:16
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_0                0x0
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_1                0x1
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_2                0x2
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_3                0x3
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_4                0x4
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_5                0x5
#define NV_AUDGP_ROUTE_TO_FIFO_CONNECTION           20:20
#define NV_AUDGP_ROUTE_TO_FIFO_CONNECTION_ENABLE    0x0
#define NV_AUDGP_ROUTE_TO_FIFO_CONNECTION_DISABLE   0x1

typedef union _routeEffectToFifo
{
    struct
    {
        U032 sourceType : 1;
        U032 sourceID   : 8;
        U032 sourcePin  : 4;
        U032 fifoType   : 1;
        U032 fifoNum    : 2;
        U032 fifoPin    : 4; 
        U032 connection : 1;
        U032            : 11;
    };

    U032 uValue;
} STRUCT_ROUTE_TO_FIFO;

/* 
METHOD: GetMixerBuffer - Reserves a mixer buffer ID to used for connecting/routing effects.
This ID is used in RouteEffect calls, and is returned in a notifier as a 8-bit identifier.
DATA(32): Allocate HW mix bin, or a SW mix bin (mix bin in the DSP/scratch memory)
Return(8) : Mixer buffer ID
*/
#define NV_AUDGP_GET_MIX_BUFFER                         0x0000000B
#define NV_AUDGP_GET_MIX_BUFFER_TYPE                    1:0
#define NV_AUDGP_GET_MIX_BUFFER_TYPE_HW                 0x0
#define NV_AUDGP_GET_MIX_BUFFER_TYPE_SW                 0x1
#define NV_AUDGP_GET_MIX_BUFFER_TYPE_DONT_CARE          0x2

/* 
METHOD: FreeMixerBuffer - Frees an allocated mix buffer
DATA(32): ID of buffer to free
*/
#define NV_AUDGP_FREE_MIX_BUFFER                        0x0000000C
#define NV_AUDGP_FREE_MIX_BUFFER_ID                     7:0

/*
METHOD: SetContextDmaNotifier - Sets the context DMA for the GP notifier
DATA(32): Handle returned from AllocContextDma
*/
#define NV_AUDGP_SET_CONTEXT_DMA_NOTIFIER               0x0000000D
#define NV_AUDGP_SET_CONTEXT_DMA_NOTIFIER_VALUE         31:0

/*
METHOD: ConfigureOutputFIFO(i) - configure the output fifo - do this before you point an
effect to it.
DATA(32) : Data format
            If the data transfers are isochronous
            Data size and container size where
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_8_8       =  8-bit data in 8-bit container(always in blocks of 4)
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_16_16     = 16-bit data in 16-bit container (always in blocks of two)
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_24_32_MSB = 24 bit data in 32-bit container (msb justified)
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_24_32_LSB = 24-bit data in 32-bit container (lsb justified)
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_32_32     = 32 bit data in 32-bit container
*/
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO(i)               (0x00000010+(i))
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT           1:0
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT_MONO      0x0
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT_STEREO    0x1
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT_QUAD      0x2
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT_HEX       0x3
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_TYPE             2:2
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_TYPE_NONISO      0x0
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_TYPE_ISO         0x1
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE             5:3
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_8_8         0x0
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_16_16       0x1
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_24_32_MSB   0x2
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_24_32_LSB   0x3
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_32_32       0x4

// METHOD: ConfigureInputFIFO(i) - configure the input fifo
#define NV_AUDGP_CONFIGURE_INPUT_FIFO(i)                (0x00000014+(i))
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT            1:0
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT_MONO       0x0
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT_STEREO     0x1
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT_QUAD       0x2
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT_HEX        0x3
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_TYPE              2:2
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_TYPE_NONISO       0x0
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_TYPE_ISO          0x1
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE              5:3
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_8_8          0x0
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_16_16        0x1
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_24_32_MSB    0x2
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_24_32_LSB    0x3
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_32_32        0x4



typedef union _configureFifo
{
    struct
    {
        U032 format         : 2;
        U032 type           : 1;
        U032 size           : 3;
        U032                : 26;
    };

    U032 uValue;
} STRUCT_CONFIGURE_FIFO;


// METHOD: AllocScratchMemory - Used to allocate scratch memory
// DATA(32) : Number of bytes to allocate
// Return(32) : Offset into scratch memory
#define NV_AUDGP_ALLOC_SCRATCH_MEMORY                   0x00000017
#define NV_AUDGP_ALLOC_SCRATCH_MEMORY_BYTES             31:0

// METHOD: FreeScratchMemory - Used to free allocated scratch memory
// DATA(32) : Offset into scratch memory
// DATA(32) : Number of bytes to free
#define NV_AUDGP_FREE_SCRATCH_MEMORY                    0x00000018
#define NV_AUDGP_FREE_SCRATCH_MEMORY_OFFSET             31:0
#define NV_AUDGP_FREE_SCRATCH_MEMORY_SIZE               31:0

// METHOD: SetScratchMemory - Used to set scratch memory to a value
// DATA(32) : Offset into scratch memory
// DATA(32) : Number of DWORDS to set
// DATA(32) : Value to set memory
#define NV_AUDGP_SET_SCRATCH_MEMORY                     0x00000019
#define NV_AUDGP_SET_SCRATCH_MEMORY_OFFSET              31:0
#define NV_AUDGP_SET_SCRATCH_MEMORY_SIZE				31:0
#define NV_AUDGP_SET_SCRATCH_MEMORY_VALUE               31:0

// METHOD: ReadScratchMemory  read blocks to scratch memory
// DATA(32): block system memory byte address offset
// DATA(32): block byte size
#define NV_AUDGP_READ_SCRATCH_MEMORY                 0x0000001A
#define NV_AUDGP_READ_SCRATCH_MEMORY_OFFSET				31:0
#define NV_AUDGP_READ_SCRATCH_MEMORY_ADDRESS			31:0
#define NV_AUDGP_READ_SCRATCH_MEMORY_SIZE				31:0

// METHOD: WriteScratchMemory  write blocks to scratch memory
// DATA(32): block system memory byte address offset
// DATA(32): block byte size
#define NV_AUDGP_WRITE_SCRATCH_MEMORY                 0x0000001B
#define NV_AUDGP_WRITE_SCRATCH_MEMORY_OFFSET			31:0
#define NV_AUDGP_WRITE_SCRATCH_MEMORY_ADDRESS			31:0
#define NV_AUDGP_WRITE_SCRATCH_MEMORY_SIZE				31:0

/*
METHOD: SetCallbackTimer - sets the callback timer at which the callback registered
                           by the client in AUDIO_INIT_DEVICE.pISRFn is called
DATA(32) : callback control field
*/

#define NV_AUDGP_SET_CALLBACK_TIMER                     0x00000020
#define NV_AUDGP_SET_CALLBACK_TIMER_OPERATION           0:0
#define NV_AUDGP_SET_CALLBACK_TIMER_OPERATION_STOP      0x0
#define NV_AUDGP_SET_CALLBACK_TIMER_OPERATION_START     0x1
#define NV_AUDGP_SET_CALLBACK_TIMER_TYPE                1:1
#define NV_AUDGP_SET_CALLBACK_TIMER_TYPE_1_SHOT         0x0
#define NV_AUDGP_SET_CALLBACK_TIMER_TYPE_PERIODIC       0x1
#define NV_AUDGP_SET_CALLBACK_TIMER_OPERATION_INTERVAL  18:2        /* time interval in milliseconds */
                                                                    /* finer resolution sacrificed for performance */

typedef union _callbackTimer
{
    struct
    {
        U032 op             : 1;
        U032 type           : 1;
        U032 interval       : 18;
        U032                : 12;
    };
    
    U032 uValue;
} STRUCT_SET_TIMER;

/*
METHOD: SetCallbackTimerServiceContext - sets the service context for the above timer
DATA(32) : value
*/

/*
i'm holding this off till we get a good case to set service context out here
instead of in AUDIO_INIT_DEVICE.pServiceContext

#define NV_AUDGP_SET_CALLBACK_TIMER_SERVICE_CONTEXT         0x00000021 
#define NV_AUDGP_SET_CALLBACK_TIMER_SERVICE_CONTEXT_VALUE   31:0
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\wavexmo.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 12/10/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       waveldr.cpp
 *  Content:    Wave file XMO wrappers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/10/2001   dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"


/****************************************************************************
 *
 *  CWaveFileMediaObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFileMediaObject::CWaveFileMediaObject"

CWaveFileMediaObject::CWaveFileMediaObject
(
    void
)
{
    DPF_ENTER();

    //
    // Initialize defaults
    //
    
    m_dwReadOffset = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CWaveFileMediaObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFileMediaObject::~CWaveFileMediaObject"

CWaveFileMediaObject::~CWaveFileMediaObject
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the object supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [in/out]: info structure.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFileMediaObject::GetInfo"

HRESULT
CWaveFileMediaObject::GetInfo
(
    LPXMEDIAINFO            pInfo
)
{
    DPF_ENTER();

    pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE;
    pInfo->dwMaxLookahead = 0;
    pInfo->dwInputSize = 0;
    pInfo->dwOutputSize = m_pwfxFormat->nBlockAlign;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Submits buffers to the stream.
 *
 *  Arguments:
 *      LPCXMEDIAPACKET  [in]: input buffer.
 *      LPCXMEDIAPACKET  [in]: output buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFileMediaObject::Process"

HRESULT
CWaveFileMediaObject::Process
(
    LPCXMEDIAPACKET         pxmbSource, 
    LPCXMEDIAPACKET         pxmbDest 
)
{
    LPBYTE                  pbDst;
    DWORD                   cbDst;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pwfxFormat);
    
    //
    // We're an output-only XMO, so we only use pxmbDest.  We'll just assume
    // that it's valid and pxmbSource isn't.
    //

    ASSERT(!pxmbSource);
    ASSERT(pxmbDest);
    ASSERT(pxmbDest->pvBuffer);
    ASSERT(pxmbDest->dwMaxSize);

    pbDst = (LPBYTE)pxmbDest->pvBuffer;
    cbDst = pxmbDest->dwMaxSize;

    //
    // Block-align the size
    //

    cbDst /= m_pwfxFormat->nBlockAlign;
    cbDst *= m_pwfxFormat->nBlockAlign;

    //
    // Initialize packet output parameters
    //

    XMOAcceptPacket(pxmbDest);

    //
    // Read from the file
    //

    hr = CWaveFile::ReadSample(m_dwReadOffset, pbDst, cbDst, &cbDst);

    //
    // Update the read offset
    //

    if(SUCCEEDED(hr))
    {
        m_dwReadOffset += cbDst;
    }

    //
    // Complete the packet
    //

    if(SUCCEEDED(hr))
    {
        XMOCompletePacket(pxmbDest, cbDst);
    }
    else
    {
        XMOCompletePacket(pxmbDest, 0, NULL, NULL, XMEDIAPACKET_STATUS_FAILURE);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Seek
 *
 *  Description:
 *      Sets the current read or write position in the stream.
 *
 *  Arguments:
 *      LONG [in]: relative offset.
 *      DWORD [in]: offset origin.
 *      LPDWORD [out]: absolute stream position.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFileMediaObject::Seek"

HRESULT
CWaveFileMediaObject::Seek
(
    LONG                    lOffset,
    DWORD                   dwOrigin,
    LPDWORD                 pdwAbsolute
)
{
    DPF_ENTER();
    
    switch(dwOrigin)
    {
        case FILE_BEGIN:
            m_dwReadOffset = 0;
            break;

        case FILE_END:
            m_dwReadOffset = m_DataChunk.GetDataSize();
            break;
    }

    m_dwReadOffset += lOffset;

    if(pdwAbsolute)
    {
        *pdwAbsolute = m_dwReadOffset;
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  CFileMediaObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFileMediaObject::CFileMediaObject"

CFileMediaObject::CFileMediaObject
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CFileMediaObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFileMediaObject::~CFileMediaObject"

CFileMediaObject::~CFileMediaObject
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the object supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [in/out]: info structure.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFileMediaObject::GetInfo"

HRESULT
CFileMediaObject::GetInfo
(
    LPXMEDIAINFO            pInfo
)
{
    DPF_ENTER();

    ASSERT(pInfo);
    
    pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE;
    pInfo->dwMaxLookahead = 0;
    pInfo->dwInputSize = 1;
    pInfo->dwOutputSize = 1;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Submits buffers to the stream.
 *
 *  Arguments:
 *      LPCXMEDIAPACKET  [in]: input buffer.
 *      LPCXMEDIAPACKET  [in]: output buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CFileMediaObject::Process"

HRESULT
CFileMediaObject::Process
(
    LPCXMEDIAPACKET         pxmbSource, 
    LPCXMEDIAPACKET         pxmbDest 
)
{
    HRESULT                 hr      = E_FAIL;
    LPBYTE                  pbSrc;
    DWORD                   cbSrc;
    LPBYTE                  pbDst;
    DWORD                   cbDst;

    DPF_ENTER();

    ASSERT(pxmbSource || pxmbDest);
    ASSERT(!(pxmbSource && pxmbDest));
    
    if(pxmbSource)
    {
        ASSERT(pxmbSource->pvBuffer);
        ASSERT(pxmbSource->dwMaxSize);

        pbSrc = (LPBYTE)pxmbSource->pvBuffer;
        cbSrc = pxmbSource->dwMaxSize;

        XMOAcceptPacket(pxmbSource);

        hr = Write(pbSrc, cbSrc, &cbSrc);

        if(SUCCEEDED(hr))
        {
            XMOCompletePacket(pxmbSource, cbSrc);
        }
        else
        {
            XMOCompletePacket(pxmbSource, 0, NULL, NULL, XMEDIAPACKET_STATUS_FAILURE);
        }
    }
    else if(pxmbDest)
    {
        ASSERT(pxmbDest->pvBuffer);
        ASSERT(pxmbDest->dwMaxSize);

        pbDst = (LPBYTE)pxmbDest->pvBuffer;
        cbDst = pxmbDest->dwMaxSize;

        XMOAcceptPacket(pxmbDest);

        hr = Read(pbDst, cbDst, &cbDst);
        
        if(SUCCEEDED(hr))
        {
            XMOCompletePacket(pxmbDest, cbDst);
        }
        else
        {
            XMOCompletePacket(pxmbDest, 0, NULL, NULL, XMEDIAPACKET_STATUS_FAILURE);
        }
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\wavexmo.h ===
/***************************************************************************
 *
 *  Copyright (C) 12/10/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wavexmo.cpp
 *  Content:    Wave file XMO wrappers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/10/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WAVEXMO_H__
#define __WAVEXMO_H__

#ifdef __cplusplus

//
// Wave file XMO
//

namespace DirectSound
{
    class CWaveFileMediaObject
        : public XWaveFileMediaObject, public CRefCount, protected CWaveFile
    {
    protected:
        DWORD                   m_dwReadOffset;     // Current read offset

    public:
        CWaveFileMediaObject(void);
        virtual ~CWaveFileMediaObject(void);

    public:
        // Initialization
        HRESULT STDMETHODCALLTYPE Initialize(LPCSTR pszFileName);
        HRESULT STDMETHODCALLTYPE Initialize(HANDLE hFile);

        // IUnknown methods
        virtual ULONG STDMETHODCALLTYPE AddRef(void);
        virtual ULONG STDMETHODCALLTYPE Release(void);

        // XMediaObject methods
        virtual HRESULT STDMETHODCALLTYPE GetInfo(LPXMEDIAINFO pInfo);
        virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
        virtual HRESULT STDMETHODCALLTYPE Process(LPCXMEDIAPACKET pxmbInput, LPCXMEDIAPACKET pxmbOutput);
        virtual HRESULT STDMETHODCALLTYPE Discontinuity(void);
        virtual HRESULT STDMETHODCALLTYPE Flush(void);

        // XFileMediaObject methods
        virtual HRESULT STDMETHODCALLTYPE Seek(LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute);
        virtual HRESULT STDMETHODCALLTYPE GetLength(LPDWORD pdwLength);

        // XWaveFileMediaObject methods
        virtual HRESULT STDMETHODCALLTYPE GetFormat(LPCWAVEFORMATEX *ppwfxFormat);
        virtual HRESULT STDMETHODCALLTYPE GetLoopRegion(LPDWORD pdwLoopStart, LPDWORD pdwLoopLength);
    };

    __inline ULONG CWaveFileMediaObject::AddRef(void)
    {
        return CRefCount::AddRef();
    }

    __inline ULONG CWaveFileMediaObject::Release(void)
    {
        return CRefCount::Release();
    }

    __inline HRESULT CWaveFileMediaObject::Initialize(LPCSTR pszFileName)
    {
        return CWaveFile::Open(pszFileName, NULL);
    }

    __inline HRESULT CWaveFileMediaObject::Initialize(HANDLE hFile)
    {
        return CWaveFile::Open(NULL, hFile);
    }

    __inline HRESULT CWaveFileMediaObject::GetStatus(LPDWORD pdwStatus)
    {
        *pdwStatus = XMO_STATUSF_ACCEPT_OUTPUT_DATA;
        return DS_OK;
    }

    __inline HRESULT CWaveFileMediaObject::Discontinuity(void)
    {
        return S_OK;
    }

    __inline HRESULT CWaveFileMediaObject::Flush(void)
    {
        return Seek(0, FILE_BEGIN, NULL);
    }

    __inline HRESULT CWaveFileMediaObject::GetLength(LPDWORD pdwLength)
    {
        return CWaveFile::GetDuration(pdwLength);
    }

    __inline HRESULT CWaveFileMediaObject::GetFormat(LPCWAVEFORMATEX *ppwfxFormat)
    {
        return CWaveFile::GetFormat(ppwfxFormat);
    }

    __inline HRESULT CWaveFileMediaObject::GetLoopRegion(LPDWORD pdwLoopStart, LPDWORD pdwLoopLength)
    {
        return CWaveFile::GetLoopRegion(pdwLoopStart, pdwLoopLength);
    }
}

//
// File XMO
//

namespace DirectSound
{
    class CFileMediaObject
        : public XFileMediaObject, public CRefCount, protected CStdFileStream
    {
    public:
        CFileMediaObject(void);
        virtual ~CFileMediaObject(void);

    public:
        // Initialization
        HRESULT STDMETHODCALLTYPE Initialize(LPCSTR pszFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes);
        HRESULT STDMETHODCALLTYPE Initialize(HANDLE hFile);

        // IUnknown methods
        virtual ULONG STDMETHODCALLTYPE AddRef(void);
        virtual ULONG STDMETHODCALLTYPE Release(void);

        // XMediaObject methods
        virtual HRESULT STDMETHODCALLTYPE GetInfo(LPXMEDIAINFO pInfo);
        virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
        virtual HRESULT STDMETHODCALLTYPE Process(LPCXMEDIAPACKET pxmbInput, LPCXMEDIAPACKET pxmbOutput);
        virtual HRESULT STDMETHODCALLTYPE Discontinuity(void);
        virtual HRESULT STDMETHODCALLTYPE Flush(void);

        // XFileMediaObject methods
        virtual HRESULT STDMETHODCALLTYPE Seek(LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute);
        virtual HRESULT STDMETHODCALLTYPE GetLength(LPDWORD pdwLength);
    };

    __inline ULONG CFileMediaObject::AddRef(void)
    {
        return CRefCount::AddRef();
    }

    __inline ULONG CFileMediaObject::Release(void)
    {
        return CRefCount::Release();
    }

    __inline HRESULT CFileMediaObject::Initialize(LPCSTR pszFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes)
    {
        return CStdFileStream::Open(pszFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, dwFlagsAndAttributes);
    }

    __inline HRESULT CFileMediaObject::Initialize(HANDLE hFile)
    {
        CStdFileStream::Attach(hFile);
        return DS_OK;
    }

    __inline HRESULT CFileMediaObject::GetStatus(LPDWORD pdwStatus)
    {
        *pdwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;
        return DS_OK;
    }

    __inline HRESULT CFileMediaObject::Discontinuity(void)
    {
        return S_OK;
    }

    __inline HRESULT CFileMediaObject::Flush(void)
    {
        return Seek(0, FILE_BEGIN, NULL);
    }

    __inline HRESULT CFileMediaObject::Seek(LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute)
    {
        return CStdFileStream::Seek(lOffset, dwOrigin, pdwAbsolute);
    }

    __inline HRESULT CFileMediaObject::GetLength(LPDWORD pdwLength)
    {
        return CStdFileStream::GetLength(pdwLength);
    }
}

#endif // __cplusplus

#endif // __WAVEXMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\encds.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 02/04/02, 18:30:39
;	Program info
;	  Program number: 1
;	  Revision number: 1.114
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 754 words
;	  Checksum: $F7F511

		dc	$D01B40,$0002F2,$010172,$F7F511,$050C40,$040C37,$048AA7,$051884
		dc	$05B7B1,$066A4A,$0732AE,$081385,$090FCC,$0A2ADB,$0B6873,$0CCCCD
		dc	$0E5CA1,$101D3F,$12149A,$144961,$16C311,$198A13,$1CA7D7,$2026F3
		dc	$241347,$287A27,$2D6A86,$32F52D,$392CEE,$4026E7,$47FACD,$50C336
		dc	$5A9DF8,$65AC8C,$721483,$7FFFFF,$607000,$00062E,$20000B,$05A406
		dc	$44F400,$008002,$447000,$000604,$050C05,$44F400,$000002,$447000
		dc	$000604,$44F400,$00000A,$447000,$000600,$44F400,$00060A,$447000
		dc	$000601,$44F400,$000610,$447000,$000602,$44F400,$000616,$447000
		dc	$000603,$44F400,$00061C,$447000,$000605,$44F400,$000622,$447000
		dc	$000606,$44F400,$000628,$447000,$000607,$44F400,$000000,$447000
		dc	$000608,$44F400,$000100,$447000,$000609,$60F400,$00060A,$44F400
		dc	$000000,$445800,$44F400,$000100,$445800,$44F400,$000200,$445800
		dc	$44F400,$000300,$445800,$44F400,$000400,$445800,$44F400,$FFFFFF
		dc	$446000,$60F400,$000610,$44F400,$000001,$445800,$445800,$445800
		dc	$445800,$445800,$240000,$446000,$60F400,$000616,$44F400,$FFFFFF
		dc	$445800,$445800,$445800,$445800,$445800,$446000,$60F400,$00061C
		dc	$44F400,$000400,$445800,$44F400,$FFFFFF,$445800,$44F400,$000500
		dc	$445800,$44F400,$FFFFFF,$445800,$44F400,$FFFFFF,$445800,$44F400
		dc	$FFFFFF,$445800,$60F400,$000622,$44F400,$000001,$445800,$240000
		dc	$445800,$44F400,$000001,$445800,$240000,$445800,$240000,$445800
		dc	$240000,$445800,$60F400,$000628,$44F400,$FFFFFF,$445800,$445800
		dc	$445800,$445800,$445800,$445800,$56F400,$000007,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000007,$60F400,$000100
		dc	$70F400,$000100,$390100,$0D0180,$56F400,$000007,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$56F400,$000007,$60F400,$000300
		dc	$70F400,$000100,$390300,$0D0180,$56F400,$000007,$60F400,$000400
		dc	$70F400,$000100,$390400,$0D0180,$62F013,$00062E,$021ADC,$44F400
		dc	$000001,$200045,$202941,$44F400,$00001F,$200045,$202741,$219800
		dc	$60F400,$000305,$07E885,$050897,$60F413,$000600,$57F400,$000016
		dc	$0D1080,$00005B,$62F413,$000400,$20001B,$060091,$000005,$44DA00
		dc	$20008A,$200047,$029040,$200026,$0C1C91,$567000,$00062F,$21A700
		dc	$212600,$2F4013,$061790,$000009,$21C510,$000000,$21C400,$200084
		dc	$200030,$20AE00,$202110,$20002A,$567000,$000631,$62F413,$000500
		dc	$20001B,$060091,$000005,$44DA00,$20008A,$200047,$029040,$200026
		dc	$0C1C91,$567000,$000630,$21A700,$212600,$2F4013,$061790,$000009
		dc	$21C510,$000000,$21C400,$200084,$200030,$20AE00,$202110,$20002A
		dc	$567000,$000632,$56F400,$000008,$60F400,$000400,$70F400,$000100
		dc	$390000,$0D0180,$56F400,$000008,$60F400,$000500,$70F400,$000100
		dc	$390100,$0D0180,$56F400,$00000F,$60F400,$00062F,$380400,$390000
		dc	$0D0180,$00000C,$60F400,$000000,$068092,$000005,$44D800,$46D0A1
		dc	$5658E9,$575800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0
		dc	$0465A0,$0466A0,$00F3B8,$44F400,$000016,$20004D,$0D104A,$000008
		dc	$300000,$56F400,$000000,$57F400,$FFFFFF,$00000C,$0D1080,$0000B8
		dc	$56F000,$000636,$200003,$05A406,$0D1080,$000150,$0D1080,$00012F
		dc	$050C03,$0D1080,$000153,$0D1080,$000130,$56F000,$000637,$014085
		dc	$05A417,$66F000,$000633,$3E0300,$60EE00,$3E0400,$61EE00,$66F000
		dc	$000634,$3E0300,$70EE00,$3E0400,$71EE00,$46F400,$5A827A,$62F000
		dc	$00063C,$06D210,$000005,$44E000,$44C9D0,$2000D3,$564800,$66F000
		dc	$000633,$3E0000,$60EE00,$3E0200,$61EE00,$3E0100,$62EE00,$66F000
		dc	$000638,$3E0000,$64EE00,$3E0200,$65EE00,$66F000,$000634,$3E0000
		dc	$70EE00,$3E0200,$71EE00,$3E0100,$72EE00,$66F000,$000639,$3E0000
		dc	$74EE00,$76F400,$000002,$75EE00,$45F400,$5A827A,$66F000,$00063C
		dc	$06D600,$0004A6,$44CA00,$56C800,$57C9A3,$564CAB,$574D00,$61F400
		dc	$00063D,$65F000,$00068B,$62F400,$000671,$66F000,$000638,$3E0000
		dc	$60EE00,$221400,$66F000,$000639,$70EE00,$231C00,$50F000,$00063C
		dc	$00000A,$211E00,$72F400,$000004,$0BF080,$0005CA,$61F400,$00064D
		dc	$65F000,$00068B,$62F400,$000679,$66F000,$000638,$3E0200,$60EE00
		dc	$221400,$66F000,$000639,$70EE00,$231C00,$50F000,$00063C,$00000A
		dc	$211E00,$72F400,$000004,$0BF080,$0005CA,$61F400,$00065D,$65F000
		dc	$00068C,$62F400,$000681,$66F000,$000633,$3E0300,$60EE00,$221400
		dc	$66F000,$000634,$70EE00,$231C00,$50F000,$00063C,$00000A,$211E00
		dc	$72F400,$000005,$0BF080,$0005CA,$66F000,$000638,$3E0000,$60EE00
		dc	$3E0200,$61EE00,$66F000,$000633,$3E0300,$62EE00,$66F000,$000639
		dc	$3E0000,$70EE00,$3E0200,$71EE00,$66F000,$000634,$3E0300,$72EE00
		dc	$45F400,$5A827A,$64F000,$00063C,$06D400,$00050A,$44CA00,$56E000
		dc	$57E1A3,$5648AF,$574900,$0D1080,$0000B4,$00000C,$205800,$44D800
		dc	$447000,$000633,$44D800,$447000,$000634,$44D800,$447000,$000635
		dc	$57D800,$0C1890,$001027,$507000,$000636,$0C1890,$001019,$507000
		dc	$000637,$44D800,$447000,$000638,$44D800,$447000,$000639,$44D800
		dc	$447000,$00063A,$57D800,$0C1890,$002024,$507000,$00063B,$44D800
		dc	$447000,$00063C,$00000C,$C0958D,$000000,$7ED4E5,$C00000,$000000
		dc	$4FE24A,$3F67CC,$3F67CC,$4FE24A,$7FFFFF,$855BE8,$756638,$756638
		dc	$855BE8,$7FFFFF,$EA1F92,$E2404B,$E2404B,$EA1F92,$7FFFFF,$812B1B
		dc	$7DAC85,$7ED594,$812A6C,$7ED594,$4FE24A,$3F67CC,$579426,$55FF7F
		dc	$579426,$4FE24A,$3F67CC,$579426,$55FF7F,$579426,$823E22,$7B876D
		dc	$7B876D,$823E22,$7FFFFF,$B23B5E,$27F74F,$27F74F,$B23B5E,$7FFFFF
		dc	$C08974,$000000,$7EED19,$C00000,$000000,$462AF8,$378620,$378620
		dc	$462AF8,$7FFFFF,$84EF9E,$763A35,$763A35,$84EF9E,$7FFFFF,$E648FE
		dc	$E4B78A,$E4B78A,$E648FE,$7FFFFF,$8112E7,$7DDC7F,$7EEDAC,$811254
		dc	$7EEDAC,$462AF8,$378620,$511DF3,$4EF590,$511DF3,$462AF8,$378620
		dc	$511DF3,$4EF590,$511DF3,$82101A,$7BE2ED,$7BE2ED,$82101A,$7FFFFF
		dc	$AF2EFC,$2C7800,$2C7800,$AF2EFC,$7FFFFF,$61F413,$00063D,$064E90
		dc	$000002,$565900,$00000C,$60F400,$000533,$61F400,$000000,$065A90
		dc	$000003,$07D884,$4C5900,$56F000,$00063B,$240000,$60F400,$00002D
		dc	$61F445,$000041,$05A405,$60F400,$000000,$61F400,$000014,$607000
		dc	$00068B,$617000,$00068C,$00000C,$56F400,$000011,$57F400,$000000
		dc	$384E00,$0BF080,$000180,$00000C,$56F400,$000011,$57F400,$000001
		dc	$60F400,$00063D,$384E00,$390000,$0BF080,$000180,$00000C,$56F400
		dc	$000011,$57F400,$000002,$60F400,$00063D,$384E00,$390000,$0BF080
		dc	$000180,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10
		dc	$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4,$F039D6
		dc	$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09,$444C4C
		dc	$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010
		dc	$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000,$239800
		dc	$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\encdsnorm.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 01/10/01, 11:04:13
;	Program info
;	  Program number: 1
;	  Revision number: 1.51
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 659 words
;	  Checksum: $4D63EB

		dc	$D01B40,$000293,$010133,$4D63EB,$607000,$00062E,$20000B,$05A406
		dc	$44F400,$008002,$447000,$000604,$050C05,$44F400,$000002,$447000
		dc	$000604,$44F400,$00000A,$447000,$000600,$44F400,$00060A,$447000
		dc	$000601,$44F400,$000610,$447000,$000602,$44F400,$000616,$447000
		dc	$000603,$44F400,$00061C,$447000,$000605,$44F400,$000622,$447000
		dc	$000606,$44F400,$000628,$447000,$000607,$44F400,$000000,$447000
		dc	$000608,$44F400,$000100,$447000,$000609,$60F400,$00060A,$44F400
		dc	$000000,$445800,$44F400,$000100,$445800,$44F400,$000200,$445800
		dc	$44F400,$000300,$445800,$44F400,$000400,$445800,$44F400,$FFFFFF
		dc	$446000,$60F400,$000610,$44F400,$000001,$445800,$445800,$445800
		dc	$445800,$445800,$240000,$446000,$60F400,$000616,$44F400,$FFFFFF
		dc	$445800,$445800,$445800,$445800,$445800,$446000,$60F400,$00061C
		dc	$44F400,$000400,$445800,$44F400,$FFFFFF,$445800,$44F400,$000500
		dc	$445800,$44F400,$FFFFFF,$445800,$44F400,$FFFFFF,$445800,$44F400
		dc	$FFFFFF,$445800,$60F400,$000622,$44F400,$000001,$445800,$240000
		dc	$445800,$44F400,$000001,$445800,$240000,$445800,$240000,$445800
		dc	$240000,$445800,$60F400,$000628,$44F400,$FFFFFF,$445800,$445800
		dc	$445800,$445800,$445800,$445800,$56F400,$000005,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000005,$60F400,$000100
		dc	$70F400,$000100,$390100,$0D0180,$56F400,$000005,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$56F400,$000005,$60F400,$000300
		dc	$70F400,$000100,$390300,$0D0180,$56F400,$000005,$60F400,$000400
		dc	$70F400,$000100,$390400,$0D0180,$62F000,$00062E,$024295,$023ADE
		dc	$200003,$052018,$60F413,$000600,$57F400,$000016,$0D1080,$00001C
		dc	$56F400,$000006,$60F400,$000400,$70F400,$000100,$390000,$0D0180
		dc	$56F400,$000006,$60F400,$000500,$70F400,$000100,$390100,$0D0180
		dc	$00000C,$60F400,$000000,$068092,$000005,$44D800,$46D0A1,$5658E9
		dc	$575800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0,$0465A0
		dc	$0466A0,$00F3B8,$44F400,$000016,$20004D,$0D104A,$000008,$300000
		dc	$56F400,$000000,$57F400,$FFFFFF,$00000C,$0D1080,$0000B8,$56F000
		dc	$000632,$200003,$05A406,$0D1080,$00015A,$0D1080,$000139,$050C03
		dc	$0D1080,$00015D,$0D1080,$00013A,$56F000,$000633,$014085,$05A417
		dc	$66F000,$00062F,$3E0300,$60EE00,$3E0400,$61EE00,$66F000,$000630
		dc	$3E0300,$70EE00,$3E0400,$71EE00,$46F400,$5A827A,$62F000,$000638
		dc	$06D210,$000005,$44E000,$44C9D0,$2000D3,$564800,$66F000,$00062F
		dc	$3E0000,$60EE00,$3E0200,$61EE00,$3E0100,$62EE00,$66F000,$000634
		dc	$3E0000,$64EE00,$3E0200,$65EE00,$66F000,$000630,$3E0000,$70EE00
		dc	$3E0200,$71EE00,$3E0100,$72EE00,$66F000,$000635,$3E0000,$74EE00
		dc	$76F400,$000002,$75EE00,$45F400,$5A827A,$66F000,$000638,$06D600
		dc	$00043D,$44CA00,$56C800,$57C9A3,$564CAB,$574D00,$61F400,$000639
		dc	$65F000,$00068D,$62F400,$000671,$66F000,$000634,$3E0000,$60EE00
		dc	$221400,$66F000,$000635,$70EE00,$231C00,$50F000,$000638,$00000A
		dc	$211E00,$72F400,$000004,$0BF080,$00056B,$61F400,$000649,$65F000
		dc	$00068D,$62F400,$000679,$66F000,$000634,$3E0200,$60EE00,$221400
		dc	$66F000,$000635,$70EE00,$231C00,$50F000,$000638,$00000A,$211E00
		dc	$72F400,$000004,$0BF080,$00056B,$61F400,$000659,$65F000,$00068E
		dc	$62F400,$000681,$66F000,$00062F,$3E0300,$60EE00,$221400,$66F000
		dc	$000630,$70EE00,$231C00,$50F000,$000638,$00000A,$211E00,$72F400
		dc	$000006,$0BF080,$00056B,$66F000,$000634,$3E0000,$60EE00,$3E0200
		dc	$61EE00,$66F000,$00062F,$3E0300,$62EE00,$66F000,$000635,$3E0000
		dc	$70EE00,$3E0200,$71EE00,$66F000,$000630,$3E0300,$72EE00,$45F400
		dc	$5A827A,$64F000,$000638,$06D400,$0004A1,$44CA00,$56E000,$57E1A3
		dc	$5648AF,$574900,$0D1080,$0000BE,$00000C,$205800,$44D800,$447000
		dc	$00062F,$44D800,$447000,$000630,$44D800,$447000,$000631,$57D800
		dc	$0C1890,$001027,$507000,$000632,$0C1890,$001019,$507000,$000633
		dc	$44D800,$447000,$000634,$44D800,$447000,$000635,$44D800,$447000
		dc	$000636,$57D800,$0C1890,$002024,$507000,$000637,$44D800,$447000
		dc	$000638,$00000C,$A2DD74,$3AE54D,$C51AB3,$5D228C,$800000,$CAE85F
		dc	$47C25A,$47C25A,$CAE85F,$7FFFFF,$855BE8,$756638,$756638,$855BE8
		dc	$7FFFFF,$EA1F92,$E2404B,$E2404B,$EA1F92,$7FFFFF,$812B1B,$7DAC85
		dc	$7ED594,$812A6C,$7ED594,$C48FCE,$1B99D0,$092E48,$092E5B,$092E6E
		dc	$CAE85F,$47C25A,$1768D5,$1768BD,$1768A5,$CAE85F,$47C25A,$1768D5
		dc	$1768BD,$1768A5,$823E22,$7B876D,$7B876D,$823E22,$7FFFFF,$B23B5E
		dc	$27F74F,$27F74F,$B23B5E,$7FFFFF,$A062D3,$3FC327,$C03CD9,$5F9D2D
		dc	$800000,$C37356,$4A2F0E,$4A2F0E,$C37356,$7FFFFF,$84EF9E,$763A35
		dc	$763A35,$84EF9E,$7FFFFF,$E648FE,$E4B78A,$E4B78A,$E648FE,$7FFFFF
		dc	$8112E7,$7DDC7F,$7EEDAC,$811254,$7EEDAC,$BFB2BF,$204D6F,$07ECAA
		dc	$07ECBB,$07ECCD,$C37356,$4A2F0E,$1448F5,$1448DE,$1448C8,$C37356
		dc	$4A2F0E,$1448F5,$1448DE,$1448C8,$82101A,$7BE2ED,$7BE2ED,$82101A
		dc	$7FFFFF,$AF2EFC,$2C7800,$2C7800,$AF2EFC,$7FFFFF,$61F413,$000639
		dc	$065490,$000002,$565900,$00000C,$60F400,$0004CA,$61F400,$000000
		dc	$066490,$000003,$07D884,$4C5900,$56F000,$000637,$240000,$60F400
		dc	$000032,$61F445,$000046,$05A405,$60F400,$000000,$61F400,$000014
		dc	$607000,$00068D,$617000,$00068E,$00000C,$56F400,$00000C,$57F400
		dc	$000000,$385400,$0BF080,$000180,$00000C,$56F400,$00000C,$57F400
		dc	$000001,$60F400,$000639,$385400,$390000,$0BF080,$000180,$00000C
		dc	$56F400,$00000C,$57F400,$000002,$60F400,$000639,$385400,$390000
		dc	$0BF080,$000180,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600
		dc	$06DA10,$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4
		dc	$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09
		dc	$444C4C,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2
		dc	$200010,$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000
		dc	$239800,$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\defaultexec\defaultEngine.asm ===
;*******************************************************************
;  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
; 
;  Author: George Chrysanthakopoulos (georgioc)
;  Creation Date: 4/1/2001
;  Comments: default execution engine for downloading FX code and doing basic
;  passthrough DMA from VP-> gp FIFOs (system ram)
;******************************************************************        
        include 'Util.h'

CIRCULAR_DMA            equ     0

        org     x:kGPMemory_XRAM_Base

commandBlock                    ds      DATASIZE_COMMAND_BLOCK  

dmaCommandBlock                 ds      kDMANode_Size_DSPnSM
dmaStateXRAMNode                ds      kDMANode_Size_DSPnSM
dmaCodeNode                     ds      kDMANode_Size_DSPnSM
dmaWriteCommandBlock            ds      kDMANode_Size_DSPnSM
dmaMultipassWriteCommandBlock   ds      kDMANode_Size_DSPnSM


AC3_DMA_TEMP                    dc      0
DMA_BLOCK_BASE           	ds      kDMANode_Size_FIFO+(6*kDMANode_MaxSize)

MAX_GP_CYCLES                   equ 106000      ; 160Mhz

DMA_CONTROL_WORD8		equ DMA_BLOCK_BASE+$7
DMA_CONTROL_WORD9		equ $0059D2

DMA_CONTROL_WORD10		equ kFrameLength
DMA_CONTROL_WORD12		equ $000000			;System memory offset
DMA_CONTROL_WORD14		equ $0007ff			;System memory size minus one

        org     x:DEBUG_VARIABLES_OFFSET

        IF @DEF('DEBUG')
FX_ELAPSED_TIME                 ds      1
FX_PREV_TIME                    ds      1
ELAPSED_TIME                    ds      1
PREV_TIME                       ds      1
        ENDIF

        org     x:GLOBAL_FX_STATE_XRAM_BASE_OFFSET
dspStateBlockXRAM               ds      DATASIZE_GLOBAL_FX_STATE

;***********************************************************
        org     p:$0      ; Place just before START

START
main
        IF !@DEF('SIM')
        jsr     GPInit          
        ENDIF


        ;
        ; Set up DMA to read GP command block
        ; create a an array of DMA words that read the command block
        ; 

        move    #dmaCommandBlock,r0
        move    #(kGPMemory_XRAM_Base+commandBlock),r1          
        move    #SM_OFFSET_COMMAND_BLOCK,r2                     
        move    #DATASIZE_COMMAND_BLOCK,r3                      

        ;
        ; prepare the dma words
        ;

        IF !@DEF('SIM')
        jsr     DMANewNode_Read_Eol     
        ENDIF

        ;
        ; set up DMA to write back to system memory an updated
        ; command block...
        ;

        move    #dmaWriteCommandBlock,r0
        move    #commandBlock,r1          
        move    #SM_OFFSET_COMMAND_BLOCK,r2                     
        move    #DATASIZE_COMMAND_BLOCK,r3                      

        ;
        ; prepare the dma words
        ;

        IF !@DEF('SIM')
        jsr     DMANewNode_Write_Eol     
        jsr     InitFIFOAndEPDma
        ENDIF

        ;
        ; set up DMA to write back to system memory all the FX send
        ; mixbins in one concatenated buffer...
        ;

        move    #dmaMultipassWriteCommandBlock,r0
        move    #kFxSendMixBuf00,r1          
        move    #SM_OFFSET_MULTIPASS_BUFFER,r2                     
        move    #DATASIZE_MULTIPASS_BUFFER,r3                      

        ;
        ; prepare the dma words
        ;

        IF !@DEF('SIM')
        jsr     DMANewNode_Write_Eol     
        ENDIF

        ; modify the control bits for multipass write dma
        move    #>DMA_MULTIPASS_WRITE1,x0
        move    x0,x:(r0+1)

        IF @DEF('DEBUG')

        ;
        ; init timer variables
        ;

        move    #0,x0
        move    x0,x:PREV_TIME
        move    x0,x:ELAPSED_TIME

        ; setup timer registers

        movep   #$FFFFFF,x:TIMER1_TERMINAL_COUNT
        movep   #1,x:TIMER1_CONFIG

        ; start the timer from 0
        movep   #1,x:TIMER1_CONTROL

        ENDIF


;*********************************************************
; Main loop
;*********************************************************
MainLoop

        GPSetIdleBit    

        IF !@DEF('SIM')
        jsr             GPWaitForStartFrame  
        ENDIF

        IF @DEF('DEBUG')

        ;
        ; read the time counter now
        ;

        move    x:TIMER1_COUNT,x0
        move    x0,x:PREV_TIME

        ENDIF

        jsr             GPProcessCommandBlock

        IF @DEF('DEBUG')

        ;
        ; read the time counter now
        ;

        move    x:TIMER1_COUNT,x0
        move    x0,x:FX_PREV_TIME

        ENDIF

        ;
        ; the code block should be have already been moved into P-ram
        ; jump to the first line of the first FX in the code block
        ;

        IF @DEF('FX_TEST')

        jsr     PrepareAndExecuteFX        

        ELSE

        jsr     FX0_BASE    

        ENDIF

        IF @DEF('DEBUG')

        ; see how much the FX took 

        clr     a
        move    x:TIMER1_COUNT,a1
        move    x:FX_PREV_TIME,x0
        cmpu    x0,a
        blt     <MainLoop_StartDMA     

        move    a1,a
        sub     x0,a        
        move    a1,x:FX_ELAPSED_TIME       	

        ENDIF

        ;
        ; after all the FX execute, an rts instruction should bring execution
        ; back into the following line
        ; Using the dma fifo words we setup at start of this program,
        ; we DMA X-RAM MixBufs 0&1 -> Out Fifo #0 and mixbufs0->5 to AC3 output
        ;

        IF !@DEF('SIM') 

MainLoop_StartDMA

        move	#>DMA_BLOCK_BASE,a
	jsr	DMAStartNode_Wait

        ;
        ; do the multipass DMA
        ;

        move    #>dmaMultipassWriteCommandBlock,a
        jsr	DMAStartNode_Wait

        ENDIF

        IF @DEF('DEBUG')

        ;
        ; see how much this iteration took
        ; 

        clr     a
        move    x:TIMER1_COUNT,a1
        move    x:PREV_TIME,x0
        cmpu    x0,a
        blt     <MainLoop     

        move    a1,a
        sub     x0,a        
        move    a1,x:ELAPSED_TIME       	

        ; check if we exceed max cycles

        move    #>MAX_GP_CYCLES,x0
        cmpu    x0,a
        blt     <MainLoop

        ; we did, halt the DSP

        ;bra     <*

        ENDIF

        bra     <MainLoop                    
; ---- end MainLoop ----


;************************************************************
; GPProcessCommandBlock         Load and inspect command block
;
;************************************************************
GPProcessCommandBlock

LoadCommandNode    
            
        ;
        ; perform the actual dma that brings in the command block data struct
        ;

        move    #>dmaCommandBlock,a         
        IF !@DEF('SIM')
        jsr     DMAStartNode_Wait 
        ENDIF

        ;
        ; Check if a command has been submitted from the host
        ;
          
        move    x:(commandBlock+COMMAND_BLOCK_FIELD_COMMAND_FLAGS),x0
        move    #>0,a            
        cmp     x0,a
        beq     GPProcessCommandBlock_End

        ;
        ; check if they want us to download new code
        ;

        jclr    #BIT_COMMAND_BLOCK_COMMAND_LOAD_CODE,x:(commandBlock+COMMAND_BLOCK_FIELD_COMMAND_FLAGS),LoadBlock_DSPStateXRAM

LoadBlock_DSPCode

        ;
        ; always X and Y ram before loading new code
        ;

	move    #>GLOBAL_FX_STATE_XRAM_BASE_OFFSET,r0
	move    #>(kGPMemory_Size_XRAM-GLOBAL_FX_STATE_XRAM_BASE_OFFSET),x0
        jsr     GPClearXRAM_All
        jsr     GPClearYRAM_All	

        ;
        ; set linear addressing mode
        ;

	move	#$ffffff,m0
        move    m0,m1
	move	m0,m2	   
	move	m0,m3
	move	m0,m4
	move	m0,m5

        ;
        ; DMA in the concatenated blocks of DSP FX code
        ;

        move    #>dmaCodeNode,r0
        ; specify P-RAM offset to place DSP code into
        move    #>(kGPMemory_Base_PRAM+FX0_BASE),r1         

        ; specify SM offset to read code words from.
        move    #>SM_OFFSET_CODE_BLOCK,r2

        ; specify the transfer length using command block dwCodeLength field
        move    x:(commandBlock+COMMAND_BLOCK_FIELD_CODE_LENGTH),r3                      

        ;
        ; create the DMA words
        ;

        jsr     DMANewNode_Read_Eol     
        move    #>dmaCodeNode,a               

        ;
        ; execute dma program
        ;

        IF !@DEF('SIM')
        jsr     DMAStartNode_Wait
        ENDIF

LoadBlock_DSPStateXRAM    

        ;
        ; see if they want us to update state block
        ;
                
        jclr    #BIT_COMMAND_BLOCK_COMMAND_LOAD_XRAM_STATE,x:(commandBlock+COMMAND_BLOCK_FIELD_COMMAND_FLAGS),GPProcessCommandBlock_End
        
        ;
        ; DMA in the concatenated blocks of state variables for all FX
        ; the state block starts after the command block and the dsp code block
        ;

        move    #>dmaStateXRAMNode,r0

        ; create Xram offset
        move    #>(kGPMemory_Base_XRAM+dspStateBlockXRAM),a         
        move    x:(commandBlock+COMMAND_BLOCK_FIELD_OFFSET),x0
        add     x0,a
        move    a,r1

        ; specify SM offset
        move    x:(commandBlock+COMMAND_BLOCK_FIELD_STATE_OFFSET),x0
        move    x0,r2

        ; specify the transfer length using command block dwStateLength field
        move    x:(commandBlock+COMMAND_BLOCK_FIELD_STATE_LENGTH),r3                     

        ;
        ; create the DMA words
        ;

        jsr     DMANewNode_Read_Eol     
        move    #>dmaStateXRAMNode,a                

        ;
        ; execute dma program
        ;

        IF !@DEF('SIM')
        jsr     DMAStartNode_Wait
        ENDIF

        ;
        ; after reading an active command node, update the system memory command node
        ; zero-ing out the command flags. this way we will not be doing DMA on every cycle..
        ;

        move #>0,x0
        move x0,x:(commandBlock+COMMAND_BLOCK_FIELD_COMMAND_FLAGS)
        move #>dmaWriteCommandBlock,a                

        ;
        ; execute dma program
        ;

        IF !@DEF('SIM')
        jsr     DMAStartNode_Wait   
        ENDIF

GPProcessCommandBlock_End

        rts

; ---- end GPProcessCommandNode ----
        

InitFIFOAndEPDma

        ;
        ; Create the 5 word DMA node used to spit interleaved stereo
        ; out to system memory. Only used for debug and DVT with no REVB
        ;

	move 	#>DMA_BLOCK_BASE,r4      	  

        ; 
        ; the scratch offset were we deliver the 6 buffer 512 sample interleave
        ; is communicated by the driver
        ;

        move    #>SM_OFFSET_AC3_DMA_OUTPUT,x0  
	move	#>AC3_DMA_TEMP,r1
        move    x0,x:(r1)

	move	#>DMA_CONTROL_WORD8,a		;Next DMA Control Structure
	move	#>DMA_MIXBUFFER_MAP,r2

        ;
        ; Create 6 AC3 DMA control structures
        ; They will dma out 512 samples for each mixbin (0->5)
        ; The base system memory offset is set by the mcpx driver(it pokes it in our XRAM)
        ;

	dor	#6,AC3_DMA_LOOP

	move    a,x:(r4)+
	add	#>kDMANode_MaxSize,a   				;Increment next DMA control struct pointer	

	move    #>DMA_CONTROL_WORD9,x0			
	move    x0,x:(r4)+	
	move    #>DMA_CONTROL_WORD10,x0			
	move    x0,x:(r4)+	

	move	p:(r2)+,x0					; Get Mixbuffer address from table
	move    x0,x:(r4)+

	move    #>DMA_CONTROL_WORD12,x0			
	move    x0,x:(r4)+
		
	move	x:(r1),b
	move	b,x:(r4)+
	add	#>AC3_BUFFER_SIZE,b			;Increment system memory base 
	move    b,x:(r1)
		
	move    #>DMA_CONTROL_WORD14,x0			
	move    x0,x:(r4)+	
AC3_DMA_LOOP

        ; put an EOL on the last nodes nextCmd word

        move	#>DMA_BLOCK_BASE,a		        ;base DMA Control Structure
	jsr	DMAInit

        add	#>kDMANode_MaxSize*5,a
        move    a,r4

	move	#>$4000,x0 ; EOL bit in word0
        move    x0,x:(r4)+	
        

        rts

DMA_MIXBUFFER_MAP:
	dc	kMixBuf00                               ; front left
	dc	kMixBuf02                               ; center
	dc	kMixBuf01                               ; front right
	dc	kMixBuf04                               ; rear left
	dc	kMixBuf05                               ; rear right
	dc	kMixBuf03                               ; LFE


        IF @DEF('FX_TEST')
PrepareAndExecuteFX

        ; *******************************************************************
        ; for testing FX: we jump directly to a linked FX setting up I/O ptrs
        ; *******************************************************************
        move    #>dspStateBlockXRAM,rD

        jsr     FX_START_ROUTINE
        rts

        ENDIF ; FX_TEST

        ;
        ; library code..
        ;

	include 'DMAUtil.asm' 
	include 'Util.asm' 

        IF @DEF('FX_TEST')

        include "FX_FILENAME"

        ENDIF

FX0_BASE
        nop
        rts
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\encds_passthru133.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 01/11/01, 16:55:53
;	Program info
;	  Program number: 1
;	  Revision number: 1.3
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 503 words
;	  Checksum: $E65DF2

		dc	$D01B40,$0001F7,$010103,$E65DF2,$56F400,$000005,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000005,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$60F400,$000000,$61F400,$000400
		dc	$060091,$000003,$44D800,$445900,$60F400,$000200,$61F400,$000500
		dc	$060091,$000003,$44D800,$445900,$56F400,$000006,$60F400,$000400
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000006,$60F400,$000500
		dc	$70F400,$000100,$390100,$0D0180,$00000C,$60F400,$000000,$068092
		dc	$000005,$44D800,$46D0A1,$5658E9,$575800,$00000C,$05F420,$FFFFFF
		dc	$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000016
		dc	$20004D,$0D104A,$000008,$300000,$56F400,$000000,$57F400,$FFFFFF
		dc	$00000C,$0D1080,$0000B8,$56F000,$000632,$200003,$05A406,$0D1080
		dc	$00015A,$0D1080,$000139,$050C03,$0D1080,$00015D,$0D1080,$00013A
		dc	$56F000,$000633,$014085,$05A417,$66F000,$00062F,$3E0300,$60EE00
		dc	$3E0400,$61EE00,$66F000,$000630,$3E0300,$70EE00,$3E0400,$71EE00
		dc	$46F400,$5A827A,$62F000,$000638,$06D210,$000005,$44E000,$44C9D0
		dc	$2000D3,$564800,$66F000,$00062F,$3E0000,$60EE00,$3E0200,$61EE00
		dc	$3E0100,$62EE00,$66F000,$000634,$3E0000,$64EE00,$3E0200,$65EE00
		dc	$66F000,$000630,$3E0000,$70EE00,$3E0200,$71EE00,$3E0100,$72EE00
		dc	$66F000,$000635,$3E0000,$74EE00,$76F400,$000002,$75EE00,$45F400
		dc	$5A827A,$66F000,$000638,$06D600,$0003A1,$44CA00,$56C800,$57C9A3
		dc	$564CAB,$574D00,$61F400,$000639,$65F000,$00068D,$62F400,$000671
		dc	$66F000,$000634,$3E0000,$60EE00,$221400,$66F000,$000635,$70EE00
		dc	$231C00,$50F000,$000638,$00000A,$211E00,$72F400,$000004,$0BF080
		dc	$0004CF,$61F400,$000649,$65F000,$00068D,$62F400,$000679,$66F000
		dc	$000634,$3E0200,$60EE00,$221400,$66F000,$000635,$70EE00,$231C00
		dc	$50F000,$000638,$00000A,$211E00,$72F400,$000004,$0BF080,$0004CF
		dc	$61F400,$000659,$65F000,$00068E,$62F400,$000681,$66F000,$00062F
		dc	$3E0300,$60EE00,$221400,$66F000,$000630,$70EE00,$231C00,$50F000
		dc	$000638,$00000A,$211E00,$72F400,$000006,$0BF080,$0004CF,$66F000
		dc	$000634,$3E0000,$60EE00,$3E0200,$61EE00,$66F000,$00062F,$3E0300
		dc	$62EE00,$66F000,$000635,$3E0000,$70EE00,$3E0200,$71EE00,$66F000
		dc	$000630,$3E0300,$72EE00,$45F400,$5A827A,$64F000,$000638,$06D400
		dc	$000405,$44CA00,$56E000,$57E1A3,$5648AF,$574900,$0D1080,$0000BE
		dc	$00000C,$205800,$44D800,$447000,$00062F,$44D800,$447000,$000630
		dc	$44D800,$447000,$000631,$57D800,$0C1890,$001027,$507000,$000632
		dc	$0C1890,$001019,$507000,$000633,$44D800,$447000,$000634,$44D800
		dc	$447000,$000635,$44D800,$447000,$000636,$57D800,$0C1890,$002024
		dc	$507000,$000637,$44D800,$447000,$000638,$00000C,$A2DD74,$3AE54D
		dc	$C51AB3,$5D228C,$800000,$CAE85F,$47C25A,$47C25A,$CAE85F,$7FFFFF
		dc	$855BE8,$756638,$756638,$855BE8,$7FFFFF,$EA1F92,$E2404B,$E2404B
		dc	$EA1F92,$7FFFFF,$812B1B,$7DAC85,$7ED594,$812A6C,$7ED594,$C48FCE
		dc	$1B99D0,$092E48,$092E5B,$092E6E,$CAE85F,$47C25A,$1768D5,$1768BD
		dc	$1768A5,$CAE85F,$47C25A,$1768D5,$1768BD,$1768A5,$823E22,$7B876D
		dc	$7B876D,$823E22,$7FFFFF,$B23B5E,$27F74F,$27F74F,$B23B5E,$7FFFFF
		dc	$A062D3,$3FC327,$C03CD9,$5F9D2D,$800000,$C37356,$4A2F0E,$4A2F0E
		dc	$C37356,$7FFFFF,$84EF9E,$763A35,$763A35,$84EF9E,$7FFFFF,$E648FE
		dc	$E4B78A,$E4B78A,$E648FE,$7FFFFF,$8112E7,$7DDC7F,$7EEDAC,$811254
		dc	$7EEDAC,$BFB2BF,$204D6F,$07ECAA,$07ECBB,$07ECCD,$C37356,$4A2F0E
		dc	$1448F5,$1448DE,$1448C8,$C37356,$4A2F0E,$1448F5,$1448DE,$1448C8
		dc	$82101A,$7BE2ED,$7BE2ED,$82101A,$7FFFFF,$AF2EFC,$2C7800,$2C7800
		dc	$AF2EFC,$7FFFFF,$61F413,$000639,$065490,$000002,$565900,$00000C
		dc	$60F400,$00042E,$61F400,$000000,$066490,$000003,$07D884,$4C5900
		dc	$56F000,$000637,$240000,$60F400,$000032,$61F445,$000046,$05A405
		dc	$60F400,$000000,$61F400,$000014,$607000,$00068D,$617000,$00068E
		dc	$00000C,$56F400,$00000C,$57F400,$000000,$385400,$0BF080,$000180
		dc	$00000C,$56F400,$00000C,$57F400,$000001,$60F400,$000639,$385400
		dc	$390000,$0BF080,$000180,$00000C,$56F400,$00000C,$57F400,$000002
		dc	$60F400,$000639,$385400,$390000,$0BF080,$000180,$00000C,$71F400
		dc	$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021,$57DA00,$51D200
		dc	$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409,$444C4C,$03F184
		dc	$555A00,$515A00,$22D400,$229000,$239800,$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\dmautil.h ===
;*******************************************************************
;
;    DMAUtil.h		DMA header file for Global/Encode Audio Processor   
;
;
;		Written by Gints Klimanis
;
;******************************************************************        

; ==============================================================
;  DMA Engine stuff
; ==============================================================

kDMANode_MaxSize	equ		7	
kDMANode_Size		equ		6	
kDMANode_EOL		equ		$004000		; Bit 14 = Eol
kDMANode_EOLMask	equ		$003fff		; Will Clear Eol bit

DMA_CONTROL_REGISTER 		equ $FFFFD6	; Address of DMA control register
kDMA_ActionRequest_Start    	equ 1		 
kDMA_ActionRequest_Stop    		equ 2		 
kDMA_ActionRequest_Freeze    	equ 3		 
kDMA_ActionRequest_UnFreeze   	equ 4		 
kDMA_ActionRequest_Abort		equ 5
	 
kDMA_FrozenBit		equ		3	
kDMA_RunningBit		equ		4
kDMA_StoppedBit		equ		5

DMA_CONFIGURATION_REGISTER	equ $FFFFD7	; Address of DMA configuration register
kDMA_AutoStartBit		equ		0			; Bit 0
kDMA_AutoRdyBit			equ		1
kDMA_IocRequireClrBit	equ		2
kDMA_EolRequireClrBit	equ		3
kDMA_ErrRequireClrBit	equ		4

kDMASampleFormat_08bits		equ		0
kDMASampleFormat_16bits		equ		1
kDMASampleFormat_24msbits	equ		2
kDMASampleFormat_32bits		equ		3
kDMASampleFormat_24lsbits	equ		6

DMA_NEXT_BLOCK_CONTROL_REGISTER		equ $FFFFD4 ; Bit 14 eol, Bits 13:0  Head of List Address
												; Alter only in Idle State or frozen bit asserted
DMA_START_BLOCK_CONTROL_REGISTER	equ $FFFFD5	; Bit 14 e0l, Bits 13:0  Head of List Address

; *********** DMA Read/Write Words **************
; 
; dspBaseAddress = $000000 (0)
; blockSize      = $000000 (0)

; ---- Word 0
; eol         = $1 (1) 
; nextCmd     = $000000 (0)

; ---- Word 1
; interleave  = $0 ( 0) (bit    :0)
; rdDspMem    = $0 ( 0) (bit    :1)(DSP Memory <- System Memory)
; IOC         = $0 ( 0) (bit   3:2)
; smPtrWrBk   = $0 ( 0) (bit     4)
; smBufID     = $F (15) (bit   8:5)
; iso         = $0 ( 0) (bit     9)
; smDataFmt   = $6 ( 6) (bit 12:10)
; >>>>> CONTROLBITS = $19E0
; incr        = $1 ( 1) 

; ---- Word 1 without smDataFmt
; interleave  = $0 ( 0) (bit    :0)
; rdDspMem    = $0 ( 0) (bit    :1)(DSP Memory <- System Memory)
; IOC         = $0 ( 0) (bit   3:2)
; smPtrWrBk   = $0 ( 0) (bit     4)
; smBufID     = $F (15) (bit   8:5)
; iso         = $0 ( 0) (bit     9)
; smDataFmt   = $0 ( 0) (bit 12:10)
; >>>>> CONTROLBITS = $01E0
; incr        = $1 ( 1) 

; ---- Word 2
; Count1      = $0000 (0)
; Count0      = $0000 (0)

; ---- Word 3
; Nul         = $0 (0)
; PDspStart   = $000000 (0)

; ---- Word 4
; smOffset      = $000000 (0)

; ---- Word 5 (Used in circular buffers)
; smBaseAddress = $000000 (0)

; ---- Word 6 (Used in circular buffers)
; smSizeMinus1  = $000000 (0)

; >>>>>> Only need Words 0..4
;
;  Generated by dmawords.exe

DMA_BASE_READ0	equ	$004000
DMA_BASE_READ1	equ	$0059E0
DMA_BASE_READ1_ISO	equ	$005BE0
DMA_BASE_READ2	equ	$000000
DMA_BASE_READ3	equ	$000000
DMA_BASE_READ4	equ	$000000
DMA_BASE_READ5	equ	$000000

DMA_BASE_WRITE0	equ	DMA_BASE_READ0
DMA_BASE_WRITE1	equ	$0059E2
DMA_BASE_WRITE1_ISO	equ	$005BE2
DMA_BASE_WRITE2	equ	DMA_BASE_READ2
DMA_BASE_WRITE3	equ	DMA_BASE_READ3
DMA_BASE_WRITE4	equ	DMA_BASE_READ4
DMA_BASE_WRITE5	equ	DMA_BASE_READ5

DMA_BASE_WRITEFIFO1 equ $004402       ; 16-bit output, write to FIFO
DMA_BASE_WRITEFIFO2 equ $000403       ; 16-bit output, write to FIFO, Interleaved

DMA_BASE_WRITEFIFO1_ISO equ $004602       ; 16-bit output, write to FIFO
DMA_BASE_WRITEFIFO2_ISO equ $000603       ; 16-bit output, write to FIFO, Interleaved

DMA_NODE_EOL0	equ	$004000
DMA_NODE_EOL1	equ	$000000
DMA_NODE_EOL2	equ	$000000
DMA_NODE_EOL3	equ	$000000
DMA_NODE_EOL4	equ	$000000
DMA_NODE_EOL5	equ	$000000

;************************************************************
; GPClearDMAConfigRegister	Clear  register
;************************************************************
GPClearDMAConfigRegister macro
      	movep    #>0,x:DMA_CONFIGURATION_REGISTER	
	endm
; ---- end GPClearDMAConfigRegister ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\eputil.h ===
;*******************************************************************
;
;    EpUtil.h		Global header file for Encode Audio Processor   
;
;
;       Modified by Ethan Brodsky
;		Based on EpUtil.h Written by Gints Klimanis, September 2000
;
;
;******************************************************************        

kFrameLength	equ		32
kPCValue		equ		0
kCounter		equ		0

; ==============================================================
; EP Address Map 
; ==============================================================
; Relative to EPBase (24 bit words (3 bytes) in 32-bit containers (4 bytes))
;     0x0000 - 0x2FFC   EP DSP X-Memory 3K Words (24 lsbits of Dword)     
;     0x6000 - 0x63FC   EP DSP Y-Memory 256 Words (24 lsbits of Dword) 
;     0xA000 - 0xDFFC   EP DSP P-Memory 4K Words (24 lsbits of Dword) 
;     0xFE00 - 0xFFF8   EP DSP Peripheral Registers
;     0xFFFC            EP DSP Reset
;
; Peripheral registers (Control,Status) mapped to upper 128 words
; of X-memory (0xFFFF80 to 0xFFFFFF) so they can be accessed with movep 
;
; EP DSP memory addresses 24-bit words
; System memory address    8-bit words 

kEPMemory_Base		equ $000000
kEPMemory_Base_XRAM	equ (kEPMemory_Base+$000000)
kEPMemory_Base_YRAM	equ (kEPMemory_Base+$001800)
kEPMemory_Base_PRAM	equ (kEPMemory_Base+$002800)

kEPMemory_Size_XRAM	equ 3072
kEPMemory_Size_YRAM	equ 256
kEPMemory_Size_PRAM	equ 4096

kEPMemory_Base_BootROM			equ $FF0000	; X-memory, 128 words
;kEPMemory_Base_PeripheralRegisters	equ $FFFF80	; X-memory, to 0xFFFFFF

INTERRUPT_TABLE_BASE 		equ $FF0000

; VBA at $FF0000 (requires 256 word alignment).  
; The vector table is exactly where the power-up reset starts fetching instructions.
; The first interrupt vector is hardware RESET.
; Only needs up to $24 (36d) .. $44 (68d) interrupts or so, not full 256 word table.

INTERRUPT_REGISTER		equ $FFFFC5	; Interrupt request/clear register
kAbortFrameBit		equ		0			; Bit 0
kStartFrameBit		equ		1			
kPutUpdateBit		equ		2
kMailInUpdateBit	equ		3
kDMAComplete1Bit	equ		4
kDMAComplete2Bit	equ		5
kDMAComplete3Bit	equ		6	
kDMAEndOfListBit	equ		7
kTimer1Bit			equ		8
kTimer2Bit			equ		9
kDMAErrorBit		equ		10
kAddressErrorBit	equ		11

; ==============================================================
;  FIFO stuff  
; ==============================================================
FIFOOUT_CONTROL_REGISTER	equ		$FFFFC8
FIFOIN_CONTROL_REGISTER		equ		$FFFFC9
SAMPLE_CONTROL_REGISTER		equ		$FFFFCA

kFIFO_Channels1			equ	$0
kFIFO_Channels2			equ	$1
kFIFO_Channels4			equ	$2
kFIFO_Channels6			equ	$3

kFIFO_SampleFormat08	equ	$0
kFIFO_SampleFormat16	equ	$1
kFIFO_SampleFormat24	equ	$2
kFIFO_SampleFormat32	equ	$3

; Output FIFO Configuration word:  
;   Bits 4:3  Sample Format = 10  (24-bits, 3 byte words ??)
;   Bits   2  Iso Bit       = 0 
;   Bits 1:0  # channels    = 2    (Stereo)
; 10-0-10 = $12
kFifoOut0_DefaultWord	equ	$12	

; Current Value is bits 23:2  (22 bits)	(from dev_apu.ref)
NV_PAPU_EPOFCUR0  equ	$0000302C 
NV_PAPU_EPOFCUR1  equ	$0000303C 
NV_PAPU_EPOFCUR2  equ	$0000304C 
NV_PAPU_EPOFCUR3  equ	$0000305C 

; End Value is bits 23:8  (16 bits) (from dev_apu.ref)
NV_PAPU_EPOFEND0  equ	$00003028 
NV_PAPU_EPOFEND1  equ	$00003038 
NV_PAPU_EPOFEND2  equ	$00003048 
NV_PAPU_EPOFEND3  equ	$00003058 

; Base Value is bits 23:8 (16 bits) (from dev_apu.ref)
NV_PAPU_EPOFBASE0  equ	$00003024 
NV_PAPU_EPOFBASE1  equ	$00003034 
NV_PAPU_EPOFBASE2  equ	$00003044 
NV_PAPU_EPOFBASE3  equ	$00003054 

; ==============================================================
;  Command stuff		Bits 11:2  offset in 4KB circular buffer
; ==============================================================
kEPMemory_Base_CommandCue		equ $FFF000		; Top 4KByte page

COMMAND_GET_REGISTER 		equ $FFFFC0	; Ptr to next read location
COMMAND_PUT_REGISTER 		equ $FFFFC1	; Ptr to 1st empty write location


MAILBOX_OUT                 equ $ffffC2
MAILBOX_IN                  equ $ffffC3

TIMER1_CONFIG               equ $FFFFB0
TIMER2_CONFIG               equ $FFFFB4

TIMER1_CONTROL              equ $FFFFB1
TIMER2_CONTROL              equ $FFFFB5

TIMER1_TERMINAL_COUNT       equ $ffffB2
TIMER2_TERMINAL_COUNT       equ $ffffB6

TIMER1_COUNT                equ $ffffB3
TIMER2_COUNT                equ $ffffB7



; ==============================================================
;  Processing control
; ==============================================================
PROCESSING_CONTROL_REGISTER		equ $FFFFC4	
kProcessingControl_SetIdleBit				equ 0		; Bit 0
kProcessingControl_NotifyInterruptBit		equ 1		

; ==============================================================
;  Global Sample Count Register		Bits 23:0
; ==============================================================
GLOBAL_SAMPLE_COUNT_REGISTER		equ $FFFFC6	

;************************************************************
; EPClearInterruptRegister	Clear  EP register
;************************************************************
EPClearInterruptRegister macro
      	movep    #$FFF,x:INTERRUPT_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end EPClearInterruptRegister ----

;************************************************************
; EPClearProcessingControlRegister	Clear  EP register
;************************************************************
EPClearProcessingControlRegister macro
      	movep    #$3,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"	
	endm
; ---- end EPClearProcessingControlRegister ----

;************************************************************
; EPClearSampleControlRegister	Clear  EP register
;************************************************************
EPClearSampleControlRegister macro
      	movep    #$0,x:SAMPLE_CONTROL_REGISTER	 
	endm
; ---- end EPClearSampleControlRegister ----

;************************************************************
; EPSetIdleBit		Assert EP Idle signal (Bit 0)
;************************************************************
EPSetIdleBit macro
	movep    #1,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end EPSetIdleBit ----

;************************************************************
; EPClearStartFrameBit		Start Frame (Bit 1)
;************************************************************
EPClearStartFrameBit macro
	movep    #2,x:INTERRUPT_REGISTER  ; "Write-1-To-Clear-One"	
	endm
; ---- end EPClearStartFrameBit ----

;************************************************************
; EPClearDataRAM	 Zero-fill X and Y memories
;************************************************************
EPClearDataRAM macro
	jsr	 EPClearXRAM
	jsr	 EPClearYRAM
	endm
; ---- end EPClearDataRAM ----

;************************************************************
; EPWritePC	 For IKOS debug, write Program Counter value to memory
;************************************************************
EPWritePC macro
	move	#0,r5
	lra		r5,x0	; yep, here's the PC relative address PC+0
	move	x0,a
	nop				; to avoid warnings
	dec		a
	nop				; to avoid warnings
	move	a,y:kCounter
	endm
; ---- end EPWritePC ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\llef13.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 02/04/02, 18:31:12
;	Program info
;	  Program number: 2
;	  Revision number: 1.114
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2146 words
;	  Checksum: $686B56

		dc	$D01B40,$000862,$020172,$686B56,$447000,$000965,$607000,$000968
		dc	$20000B,$05A407,$0508DF,$0D1080,$0007CE,$0D1080,$00080B,$050C05
		dc	$0D1080,$0007D4,$0D1080,$0007F8,$0508D9,$62F000,$000968,$60F400
		dc	$000FC2,$0A72D8,$000005,$240000,$447000,$000966,$5EE800,$021A9F
		dc	$20000B,$05A402,$014180,$547000,$000967,$44F000,$000966,$050952
		dc	$050811,$44F000,$000966,$0D1080,$000802,$56F000,$000966,$014180
		dc	$44F000,$000967,$547000,$000966,$200045,$0597D0,$0D1080,$0007BC
		dc	$00000C,$56F000,$000966,$44F000,$000965,$0C1940,$008020,$547000
		dc	$000943,$56F000,$000966,$200003,$05245A,$62F000,$000968,$60F400
		dc	$000953,$44F400,$000080,$060690,$000002,$445800,$0212DE,$021A94
		dc	$0C1940,$00101B,$547000,$000936,$44F413,$000012,$0C1940,$005021
		dc	$547000,$00093A,$02229E,$022AD4,$0C1940,$001021,$022A94,$0C1940
		dc	$001022,$0222D4,$0C1940,$001023,$547000,$00093B,$200013,$024A94
		dc	$0C1940,$00201A,$547000,$000947,$021AD4,$447000,$000948,$200013
		dc	$023A94,$0C1940,$001018,$023294,$0C1940,$001019,$547000,$000944
		dc	$023AD4,$447000,$000946,$0232D4,$447000,$000945,$60F413,$000932
		dc	$57F400,$000010,$0D1080,$0002A9,$44F400,$000000,$200045,$057400
		dc	$00000C,$30001B,$0D1080,$0002A1,$00000C,$44F400,$000015,$447000
		dc	$000932,$44F400,$000953,$447000,$000933,$44F400,$00095F,$447000
		dc	$000934,$44F400,$000959,$447000,$000935,$44F400,$00FFFF,$447000
		dc	$000939,$44F400,$000947,$447000,$00093C,$240000,$447000,$000937
		dc	$447000,$000938,$447000,$00093D,$447000,$00093E,$447000,$00093F
		dc	$447000,$000940,$447000,$000941,$447000,$000942,$60F400,$00094D
		dc	$44F400,$000000,$445800,$44F400,$000002,$445800,$44F400,$000003
		dc	$445800,$44F400,$000004,$445800,$44F400,$000001,$445800,$44F400
		dc	$000005,$445800,$60F400,$00095F,$44F400,$000001,$060690,$000002
		dc	$445800,$60F400,$000959,$44F400,$00FFFF,$060690,$000002,$445800
		dc	$00000C,$62F000,$000968,$45F400,$000003,$0212D6,$2000E0,$62F400
		dc	$000F92,$210E00,$200040,$60F400,$000080,$219A00,$70F400,$000100
		dc	$56F400,$000007,$79EA00,$0D0180,$200003,$052400,$00000C,$230800
		dc	$00000A,$04C8A0,$0461A0,$0464A0,$0465A0,$0004F8,$230E00,$200022
		dc	$219800,$221400,$044811,$223500,$5FE000,$4FE100,$5EE078,$06D810
		dc	$000009,$45D919,$200016,$8F8000,$8AB868,$4FE119,$200016,$CF1C00
		dc	$CA1D78,$230E00,$223022,$219800,$221400,$044811,$223500,$5FE000
		dc	$4FE100,$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868
		dc	$4FE119,$200016,$CF1C00,$CA1D78,$223000,$221400,$044811,$223500
		dc	$5FE000,$45E100,$5EE06C,$06D810,$000009,$4FD919,$200016,$8F8000
		dc	$8AB878,$45E119,$200016,$CF1C00,$CA1D6C,$230E00,$3A0222,$223000
		dc	$219900,$221100,$233200,$221400,$66F400,$000F52,$204900,$223500
		dc	$045A18,$231C00,$231D00,$205200,$5FE000,$F4C100,$4CDE00,$4FD9AE
		dc	$5EE0BF,$06DA10,$000020,$06D210,$000007,$8F8016,$45E1EE,$8AB8CB
		dc	$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016,$8AA8EE,$45E1CB,$CF0C16
		dc	$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016,$45E1AE,$8AB8BF,$CF1C16
		dc	$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE,$F4C1BF,$4CDE00,$CF0C16
		dc	$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032,$21B900,$219A00,$0CCD80
		dc	$FFFFCA,$380200,$221400,$231C00,$235200,$66F400,$000F52,$045811
		dc	$231900,$223500,$231D00,$205200,$5FE000,$F4C100,$4CDE00,$4FC9AE
		dc	$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16,$06D210,$000010
		dc	$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$F4C1BF,$4CDE00,$CF0C16
		dc	$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16,$4FC9EA
		dc	$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF,$05F420,$00FFFF,$574C16
		dc	$0461A0,$564D00,$0464A0,$0465A0,$00F3B8,$00000C,$71F400,$FFFFFE
		dc	$75F400,$FFFFFC,$229600,$06DA10,$00001A,$F0B900,$06DE10,$00000A
		dc	$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D3,$10DD00
		dc	$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D3
		dc	$564C00,$03F18E,$22D400,$229000,$239800,$0460A4,$00000C,$71F400
		dc	$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021,$57DA00,$51D200
		dc	$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409,$444C4C,$03F184
		dc	$555A00,$515A00,$22D400,$229000,$239800,$0460A4,$00000C,$44C800
		dc	$2000A0,$44C814,$200011,$06DE10,$000005,$180CA0,$44C8BA,$200014
		dc	$200011,$182400,$2000BA,$00000C,$46C813,$2000E1,$06DE10,$000003
		dc	$46C800,$564CE1,$566400,$00000C,$394000,$233D00,$204900,$204D00
		dc	$045112,$045516,$06D910,$000004,$46D900,$B0B200,$445600,$38FF00
		dc	$231C00,$204100,$204500,$044812,$044C16,$380200,$72F400,$FFFFFE
		dc	$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5659C8,$D088EB
		dc	$063F90,$000005,$D5CAD4,$575DF3,$5659C8,$D088EB,$575D00,$204000
		dc	$204400,$387F00,$231A00,$231C00,$231E00,$204100,$204500,$204000
		dc	$204A00,$204400,$204E00,$380200,$72F400,$FFFFFE,$3C0200,$76F400
		dc	$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8,$D088EB,$063F90,$000005
		dc	$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00,$00000C,$F1C000,$4DDA00
		dc	$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006,$F1C0A7,$4DDA00,$4ED8C8
		dc	$565CEB,$5F64B0,$2000A7,$565C00,$00000C,$F1C000,$4DDA00,$4EE1C8
		dc	$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB,$5F65B0,$06DA10,$00000A
		dc	$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0,$44D9A7,$5F64C8,$565CEB
		dc	$5F65B0,$2000A7,$565D00,$00000C,$F1C000,$4DDA00,$4EC8A8,$2000BB
		dc	$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00,$4EC8A8,$564CBB,$574DE0
		dc	$2000C7,$564C00,$00000C,$F1C100,$4DDA00,$4EE1A8,$4EE0BB,$44C8E0
		dc	$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7,$06DA10,$00000B,$F1C100
		dc	$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0
		dc	$574DC7,$564C00,$00000C,$56D800,$06D910,$000007,$0C1E01,$20003E
		dc	$23A403,$02A048,$56D800,$575900,$205000,$00000C,$46F400,$000001
		dc	$23AE00,$223555,$05A40D,$22B400,$06DC10,$000009,$56F400,$7FFFFF
		dc	$06DD10,$000004,$44DC00,$200045,$027040,$544D00,$223500,$234F00
		dc	$56E20B,$052406,$44F400,$00000F,$200045,$027040,$546200,$218500
		dc	$06DC10,$000004,$56E500,$218564,$544D00,$223500,$238759,$45F400
		dc	$000002,$56E500,$45F465,$FFFFFE,$057417,$45F465,$000002,$059411
		dc	$204D58,$20007D,$05744D,$0597D6,$56E500,$45F465,$FFFFFE,$057413
		dc	$45F465,$000002,$059406,$204D58,$20007D,$057442,$0597CB,$05A7D5
		dc	$20455C,$05A40D,$56E500,$200054,$544D00,$56E500,$45F450,$000002
		dc	$544500,$050FC0,$45F454,$000002,$546500,$050FC7,$234E00,$204D03
		dc	$05A407,$56E200,$200054,$546200,$56E500,$200050,$546500,$56E200
		dc	$200054,$546200,$56E500,$45F450,$000002,$546558,$050F8B,$223500
		dc	$45E200,$06DC10,$000005,$56E500,$200060,$218500,$544D00,$23AE00
		dc	$223555,$05A409,$22B400,$06DC10,$000006,$44CD00,$06DD10,$000002
		dc	$445C00,$000000,$00000C,$44F000,$000B41,$56F000,$000B97,$200045
		dc	$05A413,$209600,$60F400,$000180,$61F400,$000241,$56F400,$000BA5
		dc	$22C400,$200040,$219200,$71E200,$06D910,$000005,$44D900,$56E000
		dc	$0C1E48,$545800,$050C10,$56F000,$000B7E,$200003,$05A40C,$60F400
		dc	$000235,$61F400,$0002F6,$390700,$06D910,$000005,$44D900,$56E000
		dc	$0C1E48,$545800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0
		dc	$0465A0,$0466A0,$00F3B8,$44F400,$000000,$20004D,$05A40C,$44F400
		dc	$000010,$20004D,$0D104A,$000011,$300000,$56F400,$000000,$57F400
		dc	$FFFFFF,$00000C,$200013,$567000,$000912,$300000,$56F400,$000000
		dc	$57F400,$000608,$00000C,$05085C,$0D1080,$000096,$56F000,$000B96
		dc	$200003,$057453,$0D1080,$0000C4,$56F000,$000B96,$200003,$05744D
		dc	$0D1080,$00016E,$0D1080,$0001B1,$0D1080,$0001F4,$240000,$447000
		dc	$000931,$56F000,$000B41,$44F000,$000B97,$200045,$05A409,$0D1080
		dc	$000146,$0D1080,$00022F,$557000,$000931,$0D1080,$000317,$0D1080
		dc	$00032F,$0D1080,$00033E,$0D1080,$000399,$0D1080,$000355,$56F000
		dc	$000B41,$200003,$0D100A,$000440,$0D1080,$0003A2,$0D1080,$0003CF
		dc	$0D1080,$0003EA,$0D1080,$FFFF81,$200013,$21101B,$00000C,$205800
		dc	$44D800,$447000,$000B42,$44D800,$447000,$000B43,$44D800,$447000
		dc	$000B44,$57D800,$0C1890,$002024,$507000,$000B7B,$0C1890,$00101B
		dc	$507000,$000B7E,$0C1890,$003018,$507000,$000B7D,$44D800,$447000
		dc	$000B45,$44D800,$447000,$000B46,$44D800,$447000,$000B47,$57D800
		dc	$0C1890,$006020,$507000,$000B7C,$57D800,$0C1890,$001023,$507000
		dc	$00023D,$0C1890,$001022,$507000,$00023E,$0C1890,$001021,$507000
		dc	$00023F,$0C1890,$004018,$507000,$000240,$61D800,$380600,$204800
		dc	$57D900,$0C1890,$00201A,$507000,$000B4E,$57D900,$015F8E,$577000
		dc	$000B49,$57D800,$0C1890,$008018,$507000,$000B41,$0C1890,$008020
		dc	$507000,$000B40,$57D800,$0C1890,$001018,$507000,$000B4C,$0C1890
		dc	$001019,$507000,$000B4A,$57D800,$577000,$000B4B,$57E000,$577000
		dc	$000B4D,$00000C,$44F400,$000000,$447000,$000B96,$56F000,$000240
		dc	$44F400,$000009,$200045,$202741,$547000,$000240,$56F000,$000B49
		dc	$44F400,$00001F,$45F445,$000000,$202741,$200065,$202961,$547000
		dc	$000B49,$56F000,$000B7D,$44F400,$000007,$45F445,$000006,$05A414
		dc	$44F465,$000003,$05A411,$45F445,$000002,$05A40E,$44F465,$000004
		dc	$05A40B,$45F445,$000005,$05A408,$44F465,$000001,$05A405,$44F400
		dc	$000002,$447000,$000B96,$547000,$000B7D,$00000C,$56F000,$000912
		dc	$44F400,$020765,$200045,$052406,$56F000,$000B40,$200003,$05A45E
		dc	$00000C,$60F413,$0004FD,$060690,$000003,$545800,$545800,$60F413
		dc	$0005A8,$060590,$000002,$545800,$60F413,$00057B,$062890,$000002
		dc	$545800,$60F413,$0005AE,$065A90,$000002,$545800,$60F413,$000608
		dc	$060590,$000002,$545800,$60F413,$00060D,$060590,$000002,$545800
		dc	$60F413,$000509,$061090,$000002,$545800,$60F413,$000519,$060890
		dc	$000002,$545800,$60F413,$000521,$063C90,$000002,$545800,$60F413
		dc	$00055D,$061E90,$000002,$545800,$60F413,$000612,$060093,$000002
		dc	$545800,$44F400,$020765,$447000,$000912,$44F400,$000000,$447000
		dc	$000B96,$61F400,$000FC2,$71F000,$000B7D,$44F000,$000B7E,$5EE900
		dc	$547040,$000B97,$547000,$000B98,$44F01B,$000B97,$2D0513,$2C024D
		dc	$05945A,$44F01B,$000B98,$2D0613,$2C024D,$059455,$56F000,$000B7C
		dc	$200023,$547000,$000B99,$44F01B,$000B7B,$2D0313,$2C044D,$05944B
		dc	$44F01B,$000B99,$2D1313,$2C034D,$059446,$56F000,$000B7C,$0140C4
		dc	$000024,$21DA00,$44F000,$000B7B,$46F400,$000006,$2344D0,$0C1D2E
		dc	$44F440,$000F4C,$200040,$219100,$5EE100,$21CF22,$218422,$200022
		dc	$577040,$000B9A,$218500,$21E46C,$46F400,$000008,$21A7D0,$5070E8
		dc	$000B9D,$457000,$000B9B,$5170B0,$000B9E,$477000,$000B9C,$507000
		dc	$000B9F,$050C03,$547000,$000B96,$00000C,$56F400,$000914,$44F000
		dc	$000B41,$200040,$219100,$56E100,$0C1E01,$44F43E,$000001,$20004C
		dc	$20291B,$45F403,$000003,$02A068,$20006D,$027068,$56F400,$000B61
		dc	$44F000,$000B41,$200040,$219000,$556000,$00000C,$44F000,$000B7D
		dc	$46F400,$000006,$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040
		dc	$219400,$56F000,$000B44,$4CE400,$200040,$219100,$05E120,$56F000
		dc	$000B42,$4CE400,$200040,$219100,$56F000,$000B43,$4CE400,$200040
		dc	$219200,$44F400,$000100,$46E200,$2000D0,$240022,$210600,$2400D0
		dc	$46E200,$2400D2,$0C1D2E,$44E140,$200040,$219000,$70E200,$64F400
		dc	$0002FD,$3C0100,$3EFF00,$45F400,$3FF7CF,$56F000,$00023F,$200003
		dc	$05A40F,$56F000,$000B41,$44F432,$0004FD,$200040,$219100,$47F400
		dc	$000347,$57D900,$51D100,$0D04E7,$555900,$516100,$050C02,$0D04F4
		dc	$05F420,$00FFFF,$00000C,$56F000,$000B41,$44F000,$000B97,$200045
		dc	$05A44D,$56F000,$00023D,$200003,$05A45B,$60F400,$0002FD,$221400
		dc	$380100,$231C00,$44F000,$000B41,$46F400,$00000C,$44F4D0,$000521
		dc	$0C1D2E,$200040,$219100,$44F000,$000B41,$46F400,$000006,$44F4D0
		dc	$00055D,$0C1D2E,$200040,$219200,$56F000,$000240,$0140C4,$000007
		dc	$21DA00,$234400,$46F400,$00000F,$44F4D0,$000814,$0C1D2E,$200040
		dc	$219500,$3A0300,$3EFF00,$0D049E,$050C13,$56F000,$00023E,$200003
		dc	$05A40F,$60F400,$0002FD,$221400,$380100,$231C00,$61F400,$000509
		dc	$62F400,$000519,$65F400,$000800,$3A0400,$3EFF00,$0D04BF,$00000C
		dc	$44F000,$000B7D,$46F400,$000006,$44F0D0,$000B41,$0C1D2E,$44F440
		dc	$000F92,$200040,$219100,$4CE100,$447000,$000913,$61F400,$0002FD
		dc	$200013,$44D91B,$060091,$000004,$200047,$029040,$44D98A,$60F400
		dc	$0005A8,$70F000,$000B41,$200032,$44E826,$566847,$029040,$21C700
		dc	$56F400,$000914,$44F000,$000B41,$200040,$219000,$476000,$0C1C91
		dc	$44F000,$000B41,$46F400,$000002,$44F4D0,$000920,$0C1D2E,$200040
		dc	$219000,$555800,$516000,$56F400,$00091A,$44F000,$000B41,$200040
		dc	$219000,$21A700,$212600,$2F4013,$061790,$000008,$21C510,$21C400
		dc	$200084,$200030,$20AE00,$202110,$20002A,$200032,$566000,$00000C
		dc	$60F400,$0002FD,$64F400,$0003FD,$380100,$231C00,$44F000,$000B41
		dc	$46F400,$000008,$44F4D0,$00057B,$0C1D2E,$200040,$219100,$65F400
		dc	$0008A2,$3A0200,$3EFF00,$0D049E,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380E00,$61F400,$0003FD
		dc	$204800,$060490,$000009,$200013,$064090,$000004,$44D900,$200047
		dc	$029040,$200026,$565800,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380800,$57F400,$000002,$204800
		dc	$380600,$060290,$00000B,$221100,$044812,$06CD10,$000006,$44DA00
		dc	$56DA00,$200045,$029040,$565900,$20402A,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600,$62F400
		dc	$0008AF,$390200,$45F41B,$000001,$20A600,$060390,$00000D,$221100
		dc	$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068
		dc	$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800
		dc	$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$000920
		dc	$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040
		dc	$219000,$44E100,$46F400,$7FFFFF,$44E0D0,$200045,$20291B,$56F400
		dc	$00092C,$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$62F400,$0008AC,$390200,$20A61B,$060390,$00000D,$221100,$4FDA00
		dc	$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068,$20CE00
		dc	$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE
		dc	$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800,$200045
		dc	$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$000920,$0C1D2E
		dc	$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040,$219000
		dc	$44E100,$46F400,$400000,$46E0D0,$446055,$20291B,$56F400,$000B7F
		dc	$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600,$20AE00
		dc	$060390,$00000A,$221100,$219900,$221200,$204900,$44D900,$445A00
		dc	$44D900,$445A00,$204832,$00000C,$56F400,$000B7F,$44F000,$000B41
		dc	$200040,$219000,$56F400,$00060D,$44F000,$000B41,$200040,$219100
		dc	$56F400,$000B84,$44F000,$000B41,$200040,$219200,$44E01B,$56E100
		dc	$45F442,$000001,$02A068,$576200,$446100,$00000C,$60F400,$0002FD
		dc	$44F000,$000B41,$46F400,$000080,$44F4D0,$000612,$0C1D2E,$200040
		dc	$219100,$64F400,$0008B2,$65F400,$000000,$0D04FC,$00000C,$56F000
		dc	$000931,$200003,$05A40E,$60F400,$000000,$61F400,$000040,$221400
		dc	$223500,$62F400,$000AB2,$66F400,$000AF2,$3A3F00,$0D054D,$050C0A
		dc	$60F400,$000000,$221400,$62F400,$0009B2,$66F400,$000A32,$3A7F00
		dc	$0D053E,$00000C,$0500A0,$0461A0,$56F000,$000931,$200003,$05A415
		dc	$60F400,$000000,$61F400,$000040,$64F400,$0003FD,$65F400,$0004FC
		dc	$62F400,$000AB2,$66F400,$000AF2,$382000,$231900,$3A3F00,$3C0300
		dc	$75F400,$FFFFFD,$0D0573,$050C11,$60F400,$000000,$64F400,$0003FD
		dc	$65F400,$0004FC,$62F400,$0009B2,$66F400,$000A32,$384000,$3A7F00
		dc	$3C0200,$75F400,$FFFFFE,$0D0564,$05F420,$00FFFF,$0461A0,$56F000
		dc	$000B41,$44F000,$000B97,$60F445,$0003FD,$05A408,$61F400,$000180
		dc	$06B590,$000003,$44D800,$445900,$050C07,$61F400,$000235,$060790
		dc	$000003,$44D800,$445900,$00000C,$56F000,$000931,$200003,$05A40A
		dc	$60F400,$000000,$384000,$0D03EF,$60F400,$000040,$384000,$0D03EF
		dc	$050C05,$60F400,$000000,$388000,$0D03EF,$00000C,$56F000,$000B97
		dc	$44F000,$000B41,$45F445,$000001,$05A403,$05080D,$050C03,$457000
		dc	$000B8F,$60F400,$000B7F,$61F400,$0005A3,$060590,$000003,$44D800
		dc	$445900,$00000C,$290300,$70F000,$000B41,$60F400,$000B7F,$56E800
		dc	$014185,$05A410,$60F400,$00092C,$56E800,$014185,$05A40B,$56F000
		dc	$000B40,$014085,$05A406,$60F400,$0005A3,$56E800,$014185,$05A402
		dc	$290200,$60F400,$000B8A,$516800,$00000C,$3D1800,$44F000,$000B41
		dc	$56F000,$000B97,$60F445,$000180,$05A40C,$209600,$61F400,$000241
		dc	$56F400,$000BA5,$22C400,$200040,$219200,$71E200,$0D058B,$050C0A
		dc	$56F000,$000B7E,$60F403,$000235,$05A405,$61F400,$0002F6,$390700
		dc	$0D058B,$00000C,$44F000,$000B41,$56F000,$000B97,$61F445,$000241
		dc	$05A459,$56F400,$000B8A,$44F000,$000B41,$200040,$219000,$56F400
		dc	$000BA5,$44F000,$000B41,$200040,$219200,$56E000,$71E200,$219400
		dc	$223600,$56F400,$000B5C,$44F000,$000B41,$200040,$219000,$56F400
		dc	$000B91,$44F000,$000B41,$200040,$219200,$232E00,$014184,$0B74C4
		dc	$000F16,$218500,$47F4AD,$000001,$0B74C4,$000F12,$21E600,$209DD0
		dc	$0C1D2E,$46F465,$2AAAAB,$202978,$556000,$21A500,$21BCE9,$0C1D82
		dc	$200010,$200065,$202978,$556200,$223200,$205900,$3A0000,$0D0596
		dc	$050C11,$56F000,$000B7E,$60F403,$000B8F,$05A40C,$61F400,$0002F6
		dc	$390700,$223600,$223200,$205900,$3A0000,$3C0600,$7DF000,$000F13
		dc	$0D0596,$00000C,$56F000,$000240,$0C1D04,$21C700,$46F400,$000003
		dc	$2000B0,$0C1D2E,$0140C0,$000049,$21C600,$61F400,$000BA0,$62F400
		dc	$000BA5,$45F000,$000B97,$06C510,$000003,$475900,$465A00,$57F400
		dc	$000001,$56F000,$000B40,$200003,$05A402,$20001B,$577000,$000B90
		dc	$00000C,$56F400,$000012,$57F400,$000000,$70F400,$000416,$0BF080
		dc	$000180,$200003,$052400,$00000C,$56F400,$000012,$57F400,$000001
		dc	$60F400,$0004FD,$70F400,$000416,$390000,$0BF080,$000180,$200003
		dc	$052400,$00000C,$56F400,$000012,$57F400,$000002,$60F400,$0004FD
		dc	$70F400,$000416,$390000,$0BF080,$000180,$200003,$052400,$56F400
		dc	$00000E,$60F400,$000914,$380C00,$390000,$0BF080,$000180,$200003
		dc	$052400,$00000C,$56F400,$000019,$57F400,$000001,$390000,$70F400
		dc	$000080,$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C
		dc	$56F400,$000015,$57F400,$000000,$70F400,$000390,$0BF080,$000180
		dc	$200003,$052400,$56F400,$000016,$57F400,$000000,$70F400,$000390
		dc	$0BF080,$000180,$200003,$052400,$00000C,$447000,$000969,$56F000
		dc	$000B97,$200045,$052407,$71F400,$000389,$380700,$60F400,$000235
		dc	$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000180,$211900,$56F400
		dc	$000015,$57F400,$000002,$0BF080,$000180,$200003,$052400,$44F000
		dc	$000969,$56F000,$000B97,$200045,$052407,$71F400,$000389,$380700
		dc	$60F400,$0002F6,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000241
		dc	$211900,$56F400,$000016,$57F400,$000002,$0BF080,$000180,$200003
		dc	$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\ldr_sip.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			ldr_sip.inc
;												
;   Contents:		Loader Software Interface Protocol (SIP) for 
;					Dolby Game Encoder
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	8/16/2000 12:07:45 PM		jmw
;	Created.
;
;
; ******************************************************************

;	Loader system equates

LDR_HDR_SIZE		equ		4		; program header size

;	Buffer ID equates

LID_MIN				equ		0		; min valid ID
LID_MAX				equ		31		; max valid ID

LID_LOADER_INIT		equ		0		; Loader initialization request

LID_PROG_DSURRE		equ		1		; Dolby Surround Encoder program
LID_PROG_DGAME1		equ		2		; Dolby Game Encoder #1 program
LID_PROG_DGAME2		equ		3		; Dolby Game Encoder #2 program
LID_PROG_DGAME3		equ		4		; Dolby Game Encoder #3 program
LID_PROG_DMMONO		equ		5	   	; Dolby Mono Downmix program
LID_PROG_DMSTEREO	equ		6	   	; Dolby Stereo Downmix program

LID_MAX_PROG		equ		6		; max valid program ID

LID_BUF_PCM			equ		7		; Input PCM buffer
LID_BUF_LTRT		equ		8		; Output Lt/Rt buffer
LID_BUF_AC3			equ		9		; Output AC-3 buffer

LID_CONFIG_LIST		equ		10		; system configuration data		

LID_PING_PONG		equ		11		; NVIDIA ping pong Loader ID
LID_AC3_ZEROS		equ		12
LID_AC3_PREAMBLE	equ		13
LID_LEVELS_AC3		equ		14
LID_LEVELS_ANALOG	equ		15		; Analog Output Levels
LID_UNUSED_2		equ		16
LID_BUF_DATA		equ		17		; Output data buffer base

LDR_NUM_DATA		equ		(LID_MAX-LID_BUF_DATA+1)	; max # data buffers

;	Loader table equates

LDR_TABLE_SIZE		equ		((LID_MAX+1)*2)			; DSP loader table size
LDR_SYSTABLE_SIZE	equ		((LID_BUF_DATA+1)*2)	; SysMem loader table size
LDR_HEAP_ADDR		equ		(LID_BUF_DATA*2)		; heap address offset
LDR_HEAP_SIZE		equ		((LID_BUF_DATA*2)+1)	; heap size offset
LDR_PINGPONG_OFFSET equ     (LID_PING_PONG*2)

;	Action equates

LDR_ACT_MIN			equ		0		; min valid action

LDR_ACT_ALLOC		equ		0		; allocate data buffer
LDR_ACT_TO_DSPX		equ		1		; copy to DSP x:
LDR_ACT_FROM_DSPX	equ		2		; copy from DSP x:
LDR_ACT_TO_DSPY		equ		3		; copy to DSP y:
LDR_ACT_FROM_DSPY	equ		4		; copy from DSP y:
LDR_ACT_TO_DSPP		equ		5		; copy to DSP p:
LDR_ACT_FROM_DSPP	equ		6		; copy from DSP p:

LDR_ACT_MAX			equ		6		; max valid action

;	PCM offset equates

LDR_OFF_PCM_L		equ		0		; left PCM offset
LDR_OFF_PCM_C		equ		1		; center PCM offset
LDR_OFF_PCM_R		equ		2		; right PCM offset
LDR_OFF_PCM_LS		equ		3		; left surround PCM offset
LDR_OFF_PCM_RS		equ		4		; right surround PCM offset
LDR_OFF_PCM_LFE		equ		5		; LFE PCM offset

LDR_OFF_PCM_LT		equ		0		; left total PCM offset
LDR_OFF_PCM_RT		equ		1		; right total PCM offset

;	Error codes

LDR_ERR_NONE		equ		0		; no error
LDR_ERR_ID			equ		1		; invalid buffer ID
LDR_ERR_ACTION		equ		2		; invalid action
LDR_ERR_LENGTH		equ		3		; invalid length/offset combination
LDR_ERR_ALLOC		equ		4		; buffer allocation error
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\ldr_tab.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			ldr_tab.asm
;												
;   Contents:		Loader Table for System Memory addresses for X-Box
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/13/2000 8:30:42 AM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'Loader Table'

	section	Loader_Table

;**** include files ***********

	nolist
	include 'ldr_sip.inc'
	list

;**** program code ************

	xdef	LdrTable

	org		p(101):					; Loader Table runtime counter is 101

LdrTable		ds		LDR_TABLE_SIZE

; ******************************************************************

	endsec		; Loader_Table

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\lleconfg.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			lleconfg.asm
;												
;   Contents:		System memory simulation of configuration data
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/14/2000 10:51:57 AM		jmw
;	Created.
;
;
; ******************************************************************

	IF		@DEF('RTSYS')

;	Dolby's Cagent 6 Development hardware

	dc		SE_IN_MAX		; input parameter list size
	dc		0				; do Dolby Surround Encoder flag
	dc		1				; do Dolby Game Encoder flag
	dc		0				; PCM sampling rate code
	dc		3				; input channel configuration
	dc		1				; low frequency effects channel present flag
	dc		16				; dialnorm setting 
	dc		5				; manual channel bandwidth 
	dc		0				; channel LPF enabled flag 
	dc		0				; LFE LPF flag 
	dc		0				; DC HPF flag
	dc		0				; dynrng exists flag
	dc		$0				; AC-3 dynamic range code 
	dc		1				; compr exists flag
	dc		$ef				; AC-3 compression code ($ef = -6dB in RF mode) 
	dc		1				; Surround gain enabled
	dc		0.562341325		; Surround gain: 0.562341325 = -5 dB, 0.177827941 = -15dB
	dc		$02				; Dolby Surround mode in 2/0 Mode (dsurmod)

	ELSE

;	NVIDIA hardware and Motorola Simulator

	dc		SE_IN_MAX		; input parameter list size
	dc		0				; do Dolby Surround Encoder flag
	dc		1				; do Dolby Game Encoder flag
	dc		0				; PCM sampling rate code
	dc		7				; input channel configuration
	dc		1				; low frequency effects channel present flag
	dc		16				; dialnorm setting 
	dc		9				; manual channel bandwidth 
	dc		1				; channel LPF enabled flag 
	dc		1				; LFE LPF flag 
	dc		1				; DC HPF flag 
	dc		0				; dynrng exists flag
	dc		$0				; AC-3 dynamic range code 
	dc		0				; compr exists flag
	dc		$ef				; AC-3 compression code 
	dc		1				; Surround gain enabled
	dc		0.562341325		; Surround gain: 0.562341325 = -5 dB, 0.177827941 = -15dB 
	dc		$02				; Dolby Surround mode in 2/0 Mode (dsurmod)

	ENDIF	; @DEF('RTSYS')
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\llef13yrom.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 01/04/01, 19:12:36
;	Program info
;	  Program number: 2
;	  Revision number: 1.4
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2058 words
;	  Checksum: $090400

		dc	$D01B40,$00080A,$020104,$090400,$447000,$00095F,$607000,$000962
		dc	$20000B,$05A407,$0508D9,$0D1080,$000780,$0D1080,$0007B3,$050C05
		dc	$0D1080,$000786,$0D1080,$0007A0,$0508D3,$62F000,$000962,$60F400
		dc	$000FC2,$0A72D8,$000004,$240000,$447000,$000960,$5EE800,$0212DF
		dc	$20000B,$05A402,$014180,$547000,$000961,$44F000,$000960,$05094C
		dc	$050811,$44F000,$000960,$0D1080,$0007AA,$56F000,$000960,$014180
		dc	$44F000,$000961,$547000,$000960,$200045,$0597D0,$0D1080,$00076E
		dc	$00000C,$56F000,$000960,$44F000,$00095F,$0C1940,$008020,$547000
		dc	$00093D,$56F000,$000960,$200003,$052454,$62F000,$000962,$60F400
		dc	$00094D,$44F400,$000080,$060690,$000002,$445800,$02129E,$0212D4
		dc	$0C1940,$00101B,$547000,$000930,$44F413,$000012,$0C1940,$005021
		dc	$547000,$000934,$021ADE,$022A94,$0C1940,$001021,$0222D4,$0C1940
		dc	$001022,$022294,$0C1940,$001023,$547000,$000935,$021A94,$447000
		dc	$000942,$200013,$0232D4,$0C1940,$001018,$022AD4,$0C1940,$001019
		dc	$547000,$00093E,$023A94,$447000,$000940,$023294,$447000,$00093F
		dc	$60F413,$00092C,$57F400,$000010,$0D1080,$0002A9,$44F400,$000000
		dc	$200045,$057400,$00000C,$30001B,$0D1080,$0002A1,$00000C,$44F400
		dc	$000015,$447000,$00092C,$44F400,$00094D,$447000,$00092D,$44F400
		dc	$000959,$447000,$00092E,$44F400,$000953,$447000,$00092F,$44F400
		dc	$00FFFF,$447000,$000933,$44F400,$000941,$447000,$000936,$240000
		dc	$447000,$000931,$447000,$000932,$447000,$000937,$447000,$000938
		dc	$447000,$000939,$447000,$00093A,$447000,$00093B,$447000,$00093C
		dc	$60F400,$000947,$44F400,$000000,$445800,$44F400,$000002,$445800
		dc	$44F400,$000003,$445800,$44F400,$000004,$445800,$44F400,$000001
		dc	$445800,$44F400,$000005,$445800,$60F400,$000959,$44F400,$000001
		dc	$060690,$000002,$445800,$60F400,$000953,$44F400,$00FFFF,$060690
		dc	$000002,$445800,$00000C,$62F000,$000962,$45F400,$000003,$021296
		dc	$2000E0,$62F400,$000F92,$210E00,$200040,$60F400,$000080,$219A00
		dc	$70F400,$000100,$56F400,$000005,$79EA00,$0D0180,$200003,$052400
		dc	$00000C,$230800,$00000A,$04C8A0,$0461A0,$0464A0,$0465A0,$0004F8
		dc	$230E00,$200022,$219800,$221400,$044811,$223500,$5FE000,$4FE100
		dc	$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868,$4FE119
		dc	$200016,$CF1C00,$CA1D78,$230E00,$223022,$219800,$221400,$044811
		dc	$223500,$5FE000,$4FE100,$5EE078,$06D810,$000009,$45D919,$200016
		dc	$8F8000,$8AB868,$4FE119,$200016,$CF1C00,$CA1D78,$223000,$221400
		dc	$044811,$223500,$5FE000,$45E100,$5EE06C,$06D810,$000009,$4FD919
		dc	$200016,$8F8000,$8AB878,$45E119,$200016,$CF1C00,$CA1D6C,$230E00
		dc	$3A0222,$223000,$219900,$221100,$233200,$221400,$66F400,$000F52
		dc	$204900,$223500,$045A18,$231C00,$231D00,$205200,$5FE000,$F4C100
		dc	$4CDE00,$4FD9AE,$5EE0BF,$06DA10,$000020,$06D210,$000007,$8F8016
		dc	$45E1EE,$8AB8CB,$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016,$8AA8EE
		dc	$45E1CB,$CF0C16,$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016,$45E1AE
		dc	$8AB8BF,$CF1C16,$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE,$F4C1BF
		dc	$4CDE00,$CF0C16,$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032,$21B900
		dc	$219A00,$0CCD80,$FFFFCA,$380200,$221400,$231C00,$235200,$66F400
		dc	$000F52,$045811,$231900,$223500,$231D00,$205200,$5FE000,$F4C100
		dc	$4CDE00,$4FC9AE,$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16
		dc	$06D210,$000010,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$F4C1BF
		dc	$4CDE00,$CF0C16,$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE,$45E1CB
		dc	$CF0C16,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF,$05F420
		dc	$00FFFF,$574C16,$0461A0,$564D00,$0464A0,$0465A0,$00F3B8,$00000C
		dc	$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$00001A,$F0B900
		dc	$06DE10,$00000A,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2
		dc	$4549D3,$10DD00,$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$F0A1E2,$4559D3,$564C00,$03F18E,$22D400,$229000,$239800,$0460A4
		dc	$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021
		dc	$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4
		dc	$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409
		dc	$444C4C,$03F184,$555A00,$515A00,$22D400,$229000,$239800,$0460A4
		dc	$00000C,$44C800,$2000A0,$44C814,$200011,$06DE10,$000005,$180CA0
		dc	$44C8BA,$200014,$200011,$182400,$2000BA,$00000C,$46C813,$2000E1
		dc	$06DE10,$000003,$46C800,$564CE1,$566400,$00000C,$394000,$233D00
		dc	$204900,$204D00,$045112,$045516,$06D910,$000004,$46D900,$B0B200
		dc	$445600,$38FF00,$231C00,$204100,$204500,$044812,$044C16,$380200
		dc	$72F400,$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3
		dc	$5659C8,$D088EB,$063F90,$000005,$D5CAD4,$575DF3,$5659C8,$D088EB
		dc	$575D00,$204000,$204400,$387F00,$231A00,$231C00,$231E00,$204100
		dc	$204500,$204000,$204A00,$204400,$204E00,$380200,$72F400,$FFFFFE
		dc	$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8,$D088EB
		dc	$063F90,$000005,$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00,$00000C
		dc	$F1C000,$4DDA00,$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006,$F1C0A7
		dc	$4DDA00,$4ED8C8,$565CEB,$5F64B0,$2000A7,$565C00,$00000C,$F1C000
		dc	$4DDA00,$4EE1C8,$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB,$5F65B0
		dc	$06DA10,$00000A,$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0,$44D9A7
		dc	$5F64C8,$565CEB,$5F65B0,$2000A7,$565D00,$00000C,$F1C000,$4DDA00
		dc	$4EC8A8,$2000BB,$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00,$4EC8A8
		dc	$564CBB,$574DE0,$2000C7,$564C00,$00000C,$F1C100,$4DDA00,$4EE1A8
		dc	$4EE0BB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7,$06DA10
		dc	$00000B,$F1C100,$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7,$4EE1B8
		dc	$565CAB,$44C9E0,$574DC7,$564C00,$00000C,$56D800,$06D910,$000007
		dc	$0C1E01,$20003E,$23A403,$02A048,$56D800,$575900,$205000,$00000C
		dc	$46F400,$000001,$23AE00,$223555,$05A40D,$22B400,$06DC10,$000009
		dc	$56F400,$7FFFFF,$06DD10,$000004,$44DC00,$200045,$027040,$544D00
		dc	$223500,$234F00,$56E20B,$052406,$44F400,$00000F,$200045,$027040
		dc	$546200,$218500,$06DC10,$000004,$56E500,$218564,$544D00,$223500
		dc	$238759,$45F400,$000002,$56E500,$45F465,$FFFFFE,$057417,$45F465
		dc	$000002,$059411,$204D58,$20007D,$05744D,$0597D6,$56E500,$45F465
		dc	$FFFFFE,$057413,$45F465,$000002,$059406,$204D58,$20007D,$057442
		dc	$0597CB,$05A7D5,$20455C,$05A40D,$56E500,$200054,$544D00,$56E500
		dc	$45F450,$000002,$544500,$050FC0,$45F454,$000002,$546500,$050FC7
		dc	$234E00,$204D03,$05A407,$56E200,$200054,$546200,$56E500,$200050
		dc	$546500,$56E200,$200054,$546200,$56E500,$45F450,$000002,$546558
		dc	$050F8B,$223500,$45E200,$06DC10,$000005,$56E500,$200060,$218500
		dc	$544D00,$23AE00,$223555,$05A409,$22B400,$06DC10,$000006,$44CD00
		dc	$06DD10,$000002,$445C00,$000000,$00000C,$44F000,$000B41,$56F000
		dc	$000B94,$200045,$05A413,$209600,$60F400,$000180,$61F400,$000241
		dc	$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$06D910,$000005
		dc	$44D900,$56E000,$0C1E48,$545800,$050C10,$56F000,$000B7B,$200003
		dc	$05A40C,$60F400,$000235,$61F400,$0002F6,$390700,$06D910,$000005
		dc	$44D900,$56E000,$0C1E48,$545800,$00000C,$05F420,$FFFFFF,$0461A0
		dc	$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000000,$20004D
		dc	$05A40C,$44F400,$000010,$20004D,$0D104A,$000011,$300000,$56F400
		dc	$000000,$57F400,$FFFFFF,$00000C,$200013,$567000,$000912,$300000
		dc	$56F400,$000000,$57F400,$000608,$00000C,$050856,$0D1080,$00008C
		dc	$56F000,$000B93,$200003,$05744D,$0D1080,$000136,$0D1080,$000179
		dc	$0D1080,$0001BC,$240000,$447000,$00092B,$56F000,$000B41,$44F000
		dc	$000B94,$200045,$05A409,$0D1080,$00010E,$0D1080,$0001E3,$557000
		dc	$00092B,$0D1080,$0002CB,$0D1080,$0002E3,$0D1080,$0002F2,$0D1080
		dc	$00034D,$0D1080,$000309,$56F000,$000B41,$200003,$0D100A,$0003FE
		dc	$0D1080,$000356,$0D1080,$000383,$0D1080,$00039E,$0D1080,$FFFF87
		dc	$200013,$21101B,$00000C,$205800,$44D800,$447000,$000B42,$44D800
		dc	$447000,$000B43,$44D800,$447000,$000B44,$57D800,$0C1890,$002024
		dc	$507000,$000B78,$0C1890,$00101B,$507000,$000B7B,$0C1890,$003018
		dc	$507000,$000B7A,$44D800,$447000,$000B45,$44D800,$447000,$000B46
		dc	$44D800,$447000,$000B47,$57D800,$0C1890,$006020,$507000,$000B79
		dc	$57D800,$0C1890,$001023,$507000,$00023D,$0C1890,$001022,$507000
		dc	$00023E,$0C1890,$001021,$507000,$00023F,$0C1890,$004018,$507000
		dc	$000240,$61D800,$380600,$204800,$205900,$57D900,$015F8E,$577000
		dc	$000B49,$57D800,$0C1890,$008018,$507000,$000B41,$0C1890,$008020
		dc	$507000,$000B40,$57D800,$0C1890,$001018,$507000,$000B4C,$0C1890
		dc	$001019,$507000,$000B4A,$57D800,$577000,$000B4B,$57E000,$577000
		dc	$000B4D,$00000C,$56F000,$000912,$44F400,$020765,$200045,$052406
		dc	$56F000,$000B40,$200003,$05A45E,$00000C,$60F413,$0004FD,$060690
		dc	$000003,$545800,$545800,$60F413,$0005A8,$060590,$000002,$545800
		dc	$60F413,$00057B,$062890,$000002,$545800,$60F413,$0005AE,$065A90
		dc	$000002,$545800,$60F413,$000608,$060590,$000002,$545800,$60F413
		dc	$00060D,$060590,$000002,$545800,$60F413,$000509,$061090,$000002
		dc	$545800,$60F413,$000519,$060890,$000002,$545800,$60F413,$000521
		dc	$063C90,$000002,$545800,$60F413,$00055D,$061E90,$000002,$545800
		dc	$60F413,$000612,$060093,$000002,$545800,$44F400,$020765,$447000
		dc	$000912,$44F400,$000000,$447000,$000B93,$61F400,$000FC2,$71F000
		dc	$000B7A,$44F000,$000B7B,$5EE900,$547040,$000B94,$547000,$000B95
		dc	$44F01B,$000B94,$2D0513,$2C024D,$05945A,$44F01B,$000B95,$2D0613
		dc	$2C024D,$059455,$56F000,$000B79,$200023,$547000,$000B96,$44F01B
		dc	$000B78,$2D0313,$2C044D,$05944B,$44F01B,$000B96,$2D1313,$2C034D
		dc	$059446,$56F000,$000B79,$0140C4,$000024,$21DA00,$44F000,$000B78
		dc	$46F400,$000006,$2344D0,$0C1D2E,$44F440,$000F4C,$200040,$219100
		dc	$5EE100,$21CF22,$218422,$200022,$577040,$000B97,$218500,$21E46C
		dc	$46F400,$000008,$21A7D0,$5070E8,$000B9A,$457000,$000B98,$5170B0
		dc	$000B9B,$477000,$000B99,$507000,$000B9C,$050C03,$547000,$000B93
		dc	$00000C,$56F400,$000914,$44F000,$000B41,$200040,$219100,$56E100
		dc	$0C1E01,$44F43E,$000001,$20004C,$20291B,$45F403,$000003,$02A068
		dc	$20006D,$027068,$56F400,$000B5E,$44F000,$000B41,$200040,$219000
		dc	$556000,$00000C,$44F000,$000B7A,$46F400,$000006,$44F0D0,$000B41
		dc	$0C1D2E,$44F440,$000F92,$200040,$219400,$56F000,$000B44,$4CE400
		dc	$200040,$219100,$05E120,$56F000,$000B42,$4CE400,$200040,$219100
		dc	$56F000,$000B43,$4CE400,$200040,$219200,$44F400,$000100,$46E200
		dc	$2000D0,$240022,$210600,$2400D0,$46E200,$2400D2,$0C1D2E,$44E140
		dc	$200040,$219000,$70E200,$64F400,$0002FD,$3C0100,$3EFF00,$45F400
		dc	$3FF7CF,$56F000,$00023F,$200003,$05A40F,$56F000,$000B41,$44F432
		dc	$0004FD,$200040,$219100,$47F400,$000347,$57D900,$51D100,$0D04E1
		dc	$555900,$516100,$050C02,$0D04EE,$05F420,$00FFFF,$00000C,$56F000
		dc	$000B41,$44F000,$000B94,$200045,$05A44D,$56F000,$00023D,$200003
		dc	$05A45B,$60F400,$0002FD,$221400,$380100,$231C00,$44F000,$000B41
		dc	$46F400,$00000C,$44F4D0,$000521,$0C1D2E,$200040,$219100,$44F000
		dc	$000B41,$46F400,$000006,$44F4D0,$00055D,$0C1D2E,$200040,$219200
		dc	$56F000,$000240,$0140C4,$000007,$21DA00,$234400,$46F400,$00000F
		dc	$44F4D0,$000814,$0C1D2E,$200040,$219500,$3A0300,$3EFF00,$0D0498
		dc	$050C13,$56F000,$00023E,$200003,$05A40F,$60F400,$0002FD,$221400
		dc	$380100,$231C00,$61F400,$000509,$62F400,$000519,$65F400,$000800
		dc	$3A0400,$3EFF00,$0D04B9,$00000C,$44F000,$000B7A,$46F400,$000006
		dc	$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040,$219100,$4CE100
		dc	$447000,$000913,$61F400,$0002FD,$200013,$44D91B,$060091,$000004
		dc	$200047,$029040,$44D98A,$60F400,$0005A8,$70F000,$000B41,$200032
		dc	$44E826,$566847,$029040,$21C700,$56F400,$000914,$44F000,$000B41
		dc	$200040,$219000,$476000,$0C1C91,$44F000,$000B41,$46F400,$000002
		dc	$44F4D0,$00091A,$0C1D2E,$200040,$219000,$555800,$516000,$00000C
		dc	$60F400,$0002FD,$64F400,$0003FD,$380100,$231C00,$44F000,$000B41
		dc	$46F400,$000008,$44F4D0,$00057B,$0C1D2E,$200040,$219100,$65F400
		dc	$0008A2,$3A0200,$3EFF00,$0D0498,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380E00,$61F400,$0003FD
		dc	$204800,$060490,$000009,$200013,$064090,$000004,$44D900,$200047
		dc	$029040,$200026,$565800,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380800,$57F400,$000002,$204800
		dc	$380600,$060290,$00000B,$221100,$044812,$06CD10,$000006,$44DA00
		dc	$56DA00,$200045,$029040,$565900,$20402A,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600,$62F400
		dc	$0008AF,$390200,$45F41B,$000001,$20A600,$060390,$00000D,$221100
		dc	$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068
		dc	$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800
		dc	$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A
		dc	$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040
		dc	$219000,$44E100,$46F400,$7FFFFF,$44E0D0,$200045,$20291B,$56F400
		dc	$000926,$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$62F400,$0008AC,$390200,$20A61B,$060390,$00000D,$221100,$4FDA00
		dc	$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068,$20CE00
		dc	$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE
		dc	$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800,$200045
		dc	$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A,$0C1D2E
		dc	$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040,$219000
		dc	$44E100,$46F400,$400000,$46E0D0,$446055,$20291B,$56F400,$000B7C
		dc	$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600,$20AE00
		dc	$060390,$00000A,$221100,$219900,$221200,$204900,$44D900,$445A00
		dc	$44D900,$445A00,$204832,$00000C,$56F400,$000B7C,$44F000,$000B41
		dc	$200040,$219000,$56F400,$00060D,$44F000,$000B41,$200040,$219100
		dc	$56F400,$000B81,$44F000,$000B41,$200040,$219200,$44E01B,$56E100
		dc	$45F442,$000001,$02A068,$576200,$446100,$00000C,$60F400,$0002FD
		dc	$44F000,$000B41,$46F400,$000080,$44F4D0,$000612,$0C1D2E,$200040
		dc	$219100,$64F400,$0008B2,$65F400,$000000,$0D04F6,$00000C,$56F000
		dc	$00092B,$200003,$05A40E,$60F400,$000000,$61F400,$000040,$221400
		dc	$223500,$62F400,$000AB2,$66F400,$000AF2,$3A3F00,$0D0547,$050C0A
		dc	$60F400,$000000,$221400,$62F400,$0009B2,$66F400,$000A32,$3A7F00
		dc	$0D0538,$00000C,$0500A0,$0461A0,$56F000,$00092B,$200003,$05A415
		dc	$60F400,$000000,$61F400,$000040,$64F400,$0003FD,$65F400,$0004FC
		dc	$62F400,$000AB2,$66F400,$000AF2,$382000,$231900,$3A3F00,$3C0300
		dc	$75F400,$FFFFFD,$0D056D,$050C11,$60F400,$000000,$64F400,$0003FD
		dc	$65F400,$0004FC,$62F400,$0009B2,$66F400,$000A32,$384000,$3A7F00
		dc	$3C0200,$75F400,$FFFFFE,$0D055E,$05F420,$00FFFF,$0461A0,$56F000
		dc	$000B41,$44F000,$000B94,$60F445,$0003FD,$05A408,$61F400,$000180
		dc	$06B590,$000003,$44D800,$445900,$050C07,$61F400,$000235,$060790
		dc	$000003,$44D800,$445900,$00000C,$56F000,$00092B,$200003,$05A40A
		dc	$60F400,$000000,$384000,$0D03E9,$60F400,$000040,$384000,$0D03E9
		dc	$050C05,$60F400,$000000,$388000,$0D03E9,$00000C,$56F000,$000B94
		dc	$44F000,$000B41,$45F445,$000001,$05A403,$05080D,$050C03,$457000
		dc	$000B8C,$60F400,$000B7C,$61F400,$0005A3,$060590,$000003,$44D800
		dc	$445900,$00000C,$290300,$70F000,$000B41,$60F400,$000B7C,$56E800
		dc	$014185,$05A410,$60F400,$000926,$56E800,$014185,$05A40B,$56F000
		dc	$000B40,$014085,$05A406,$60F400,$0005A3,$56E800,$014185,$05A402
		dc	$290200,$60F400,$000B87,$516800,$00000C,$3D1800,$44F000,$000B41
		dc	$56F000,$000B94,$60F445,$000180,$05A40C,$209600,$61F400,$000241
		dc	$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$0D0585,$050C0A
		dc	$56F000,$000B7B,$60F403,$000235,$05A405,$61F400,$0002F6,$390700
		dc	$0D0585,$00000C,$000000,$000000,$000000,$000000,$000000,$000000
		dc	$320000,$06FF9F,$000002,$5EDA00,$44F000,$000B41,$56F000,$000B94
		dc	$61F445,$000241,$05A459,$56F400,$000B87,$44F000,$000B41,$200040
		dc	$219000,$56F400,$000BA2,$44F000,$000B41,$200040,$219200,$56E000
		dc	$71E200,$219400,$223600,$56F400,$000B59,$44F000,$000B41,$200040
		dc	$219000,$56F400,$000B8E,$44F000,$000B41,$200040,$219200,$232E00
		dc	$014184,$0B74C4,$000F16,$218500,$47F4AD,$000001,$0B74C4,$000F12
		dc	$21E600,$209DD0,$0C1D2E,$46F465,$2AAAAB,$202978,$556000,$21A500
		dc	$21BCE9,$0C1D82,$200010,$200065,$202978,$556200,$223200,$205900
		dc	$3A0000,$0D0590,$050C11,$56F000,$000B7B,$60F403,$000B8C,$05A40C
		dc	$61F400,$0002F6,$390700,$223600,$223200,$205900,$3A0000,$3C0600
		dc	$7DF000,$000F13,$0D0590,$00000C,$56F000,$000240,$0C1D04,$21C700
		dc	$46F400,$000003,$2000B0,$0C1D2E,$0140C0,$000049,$21C600,$61F400
		dc	$000B9D,$62F400,$000BA2,$45F000,$000B94,$06C510,$000003,$475900
		dc	$465A00,$57F400,$000001,$56F000,$000B40,$200003,$05A402,$20001B
		dc	$577000,$000B8D,$00000C,$56F400,$00000A,$57F400,$000000,$70F400
		dc	$000416,$0BF080,$000180,$200003,$052400,$00000C,$56F400,$00000A
		dc	$57F400,$000001,$60F400,$0004FD,$70F400,$000416,$390000,$0BF080
		dc	$000180,$200003,$052400,$00000C,$56F400,$00000A,$57F400,$000002
		dc	$60F400,$0004FD,$70F400,$000416,$390000,$0BF080,$000180,$200003
		dc	$052400,$00000C,$56F400,$000011,$57F400,$000001,$390000,$70F400
		dc	$000080,$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C
		dc	$56F400,$00000D,$57F400,$000000,$70F400,$000390,$0BF080,$000180
		dc	$200003,$052400,$56F400,$00000E,$57F400,$000000,$70F400,$000390
		dc	$0BF080,$000180,$200003,$052400,$00000C,$447000,$000963,$56F000
		dc	$000B94,$200045,$052407,$71F400,$000389,$380700,$60F400,$000235
		dc	$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000180,$211900,$56F400
		dc	$00000D,$57F400,$000002,$0BF080,$000180,$200003,$052400,$44F000
		dc	$000963,$56F000,$000B94,$200045,$052407,$71F400,$000389,$380700
		dc	$60F400,$0002F6,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000241
		dc	$211900,$56F400,$00000E,$57F400,$000002,$0BF080,$000180,$200003
		dc	$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\llef13break.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 01/05/01, 09:15:05
;	Program info
;	  Program number: 2
;	  Revision number: 1.4
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2049 words
;	  Checksum: $9BD1DF

		dc	$D01B40,$000801,$020104,$9BD1DF,$447000,$00095F,$607000,$000962
		dc	$050C00,$20000B,$05A407,$0508D9,$0D1080,$000776,$0D1080,$0007A9
		dc	$050C05,$0D1080,$00077C,$0D1080,$000796,$0508D3,$62F000,$000962
		dc	$60F400,$000FC2,$0A72D8,$000004,$240000,$447000,$000960,$5EE800
		dc	$0212DF,$20000B,$05A402,$014180,$547000,$000961,$44F000,$000960
		dc	$05094C,$050811,$44F000,$000960,$0D1080,$0007A0,$56F000,$000960
		dc	$014180,$44F000,$000961,$547000,$000960,$200045,$0597D0,$0D1080
		dc	$000764,$00000C,$56F000,$000960,$44F000,$00095F,$0C1940,$008020
		dc	$547000,$00093D,$56F000,$000960,$200003,$052454,$62F000,$000962
		dc	$60F400,$00094D,$44F400,$000080,$060690,$000002,$445800,$02129E
		dc	$0212D4,$0C1940,$00101B,$547000,$000930,$44F413,$000012,$0C1940
		dc	$005021,$547000,$000934,$021ADE,$022A94,$0C1940,$001021,$0222D4
		dc	$0C1940,$001022,$022294,$0C1940,$001023,$547000,$000935,$021A94
		dc	$447000,$000942,$200013,$0232D4,$0C1940,$001018,$022AD4,$0C1940
		dc	$001019,$547000,$00093E,$023A94,$447000,$000940,$023294,$447000
		dc	$00093F,$60F413,$00092C,$57F400,$000010,$0D1080,$0002A9,$44F400
		dc	$000000,$200045,$057400,$00000C,$30001B,$0D1080,$0002A1,$00000C
		dc	$44F400,$000015,$447000,$00092C,$44F400,$00094D,$447000,$00092D
		dc	$44F400,$000959,$447000,$00092E,$44F400,$000953,$447000,$00092F
		dc	$44F400,$00FFFF,$447000,$000933,$44F400,$000941,$447000,$000936
		dc	$240000,$447000,$000931,$447000,$000932,$447000,$000937,$447000
		dc	$000938,$447000,$000939,$447000,$00093A,$447000,$00093B,$447000
		dc	$00093C,$60F400,$000947,$44F400,$000000,$445800,$44F400,$000002
		dc	$445800,$44F400,$000003,$445800,$44F400,$000004,$445800,$44F400
		dc	$000001,$445800,$44F400,$000005,$445800,$60F400,$000959,$44F400
		dc	$000001,$060690,$000002,$445800,$60F400,$000953,$44F400,$00FFFF
		dc	$060690,$000002,$445800,$00000C,$62F000,$000962,$45F400,$000003
		dc	$021296,$2000E0,$62F400,$000F92,$210E00,$200040,$60F400,$000080
		dc	$219A00,$70F400,$000100,$56F400,$000005,$79EA00,$0D0180,$200003
		dc	$052400,$00000C,$230800,$00000A,$04C8A0,$0461A0,$0464A0,$0465A0
		dc	$0004F8,$230E00,$200022,$219800,$221400,$044811,$223500,$5FE000
		dc	$4FE100,$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868
		dc	$4FE119,$200016,$CF1C00,$CA1D78,$230E00,$223022,$219800,$221400
		dc	$044811,$223500,$5FE000,$4FE100,$5EE078,$06D810,$000009,$45D919
		dc	$200016,$8F8000,$8AB868,$4FE119,$200016,$CF1C00,$CA1D78,$223000
		dc	$221400,$044811,$223500,$5FE000,$45E100,$5EE06C,$06D810,$000009
		dc	$4FD919,$200016,$8F8000,$8AB878,$45E119,$200016,$CF1C00,$CA1D6C
		dc	$230E00,$3A0222,$223000,$219900,$221100,$233200,$221400,$66F400
		dc	$000F52,$204900,$223500,$045A18,$231C00,$231D00,$205200,$5FE000
		dc	$F4C100,$4CDE00,$4FD9AE,$5EE0BF,$06DA10,$000020,$06D210,$000007
		dc	$8F8016,$45E1EE,$8AB8CB,$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016
		dc	$8AA8EE,$45E1CB,$CF0C16,$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016
		dc	$45E1AE,$8AB8BF,$CF1C16,$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE
		dc	$F4C1BF,$4CDE00,$CF0C16,$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032
		dc	$21B900,$219A00,$0CCD80,$FFFFCA,$380200,$221400,$231C00,$235200
		dc	$66F400,$000F52,$045811,$231900,$223500,$231D00,$205200,$5FE000
		dc	$F4C100,$4CDE00,$4FC9AE,$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB
		dc	$CF0C16,$06D210,$000010,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE
		dc	$F4C1BF,$4CDE00,$CF0C16,$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE
		dc	$45E1CB,$CF0C16,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF
		dc	$05F420,$00FFFF,$574C16,$0461A0,$564D00,$0464A0,$0465A0,$00F3B8
		dc	$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$00001A
		dc	$F0B900,$06DE10,$00000A,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D3,$10DD00,$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2
		dc	$4459E2,$F0A1E2,$4559D3,$564C00,$03F18E,$22D400,$229000,$239800
		dc	$0460A4,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10
		dc	$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4,$F039D6
		dc	$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09,$444C4C
		dc	$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010
		dc	$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000,$239800
		dc	$0460A4,$00000C,$44C800,$2000A0,$44C814,$200011,$06DE10,$000005
		dc	$180CA0,$44C8BA,$200014,$200011,$182400,$2000BA,$00000C,$46C813
		dc	$2000E1,$06DE10,$000003,$46C800,$564CE1,$566400,$00000C,$394000
		dc	$233D00,$204900,$204D00,$045112,$045516,$06D910,$000004,$46D900
		dc	$B0B200,$445600,$38FF00,$231C00,$204100,$204500,$044812,$044C16
		dc	$380200,$72F400,$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4
		dc	$2000F3,$5659C8,$D088EB,$063F90,$000005,$D5CAD4,$575DF3,$5659C8
		dc	$D088EB,$575D00,$204000,$204400,$387F00,$231A00,$231C00,$231E00
		dc	$204100,$204500,$204000,$204A00,$204400,$204E00,$380200,$72F400
		dc	$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8
		dc	$D088EB,$063F90,$000005,$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00
		dc	$00000C,$F1C000,$4DDA00,$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006
		dc	$F1C0A7,$4DDA00,$4ED8C8,$565CEB,$5F64B0,$2000A7,$565C00,$00000C
		dc	$F1C000,$4DDA00,$4EE1C8,$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB
		dc	$5F65B0,$06DA10,$00000A,$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0
		dc	$44D9A7,$5F64C8,$565CEB,$5F65B0,$2000A7,$565D00,$00000C,$F1C000
		dc	$4DDA00,$4EC8A8,$2000BB,$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00
		dc	$4EC8A8,$564CBB,$574DE0,$2000C7,$564C00,$00000C,$F1C100,$4DDA00
		dc	$4EE1A8,$4EE0BB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7
		dc	$06DA10,$00000B,$F1C100,$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7
		dc	$4EE1B8,$565CAB,$44C9E0,$574DC7,$564C00,$00000C,$56D800,$06D910
		dc	$000007,$0C1E01,$20003E,$23A403,$02A048,$56D800,$575900,$205000
		dc	$00000C,$46F400,$000001,$23AE00,$223555,$05A40D,$22B400,$06DC10
		dc	$000009,$56F400,$7FFFFF,$06DD10,$000004,$44DC00,$200045,$027040
		dc	$544D00,$223500,$234F00,$56E20B,$052406,$44F400,$00000F,$200045
		dc	$027040,$546200,$218500,$06DC10,$000004,$56E500,$218564,$544D00
		dc	$223500,$238759,$45F400,$000002,$56E500,$45F465,$FFFFFE,$057417
		dc	$45F465,$000002,$059411,$204D58,$20007D,$05744D,$0597D6,$56E500
		dc	$45F465,$FFFFFE,$057413,$45F465,$000002,$059406,$204D58,$20007D
		dc	$057442,$0597CB,$05A7D5,$20455C,$05A40D,$56E500,$200054,$544D00
		dc	$56E500,$45F450,$000002,$544500,$050FC0,$45F454,$000002,$546500
		dc	$050FC7,$234E00,$204D03,$05A407,$56E200,$200054,$546200,$56E500
		dc	$200050,$546500,$56E200,$200054,$546200,$56E500,$45F450,$000002
		dc	$546558,$050F8B,$223500,$45E200,$06DC10,$000005,$56E500,$200060
		dc	$218500,$544D00,$23AE00,$223555,$05A409,$22B400,$06DC10,$000006
		dc	$44CD00,$06DD10,$000002,$445C00,$000000,$00000C,$44F000,$000B41
		dc	$56F000,$000B94,$200045,$05A413,$209600,$60F400,$000180,$61F400
		dc	$000241,$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$06D910
		dc	$000005,$44D900,$56E000,$0C1E48,$545800,$050C10,$56F000,$000B7B
		dc	$200003,$05A40C,$60F400,$000235,$61F400,$0002F6,$390700,$06D910
		dc	$000005,$44D900,$56E000,$0C1E48,$545800,$00000C,$05F420,$FFFFFF
		dc	$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000000
		dc	$20004D,$05A40C,$44F400,$000010,$20004D,$0D104A,$000011,$300000
		dc	$56F400,$000000,$57F400,$FFFFFF,$00000C,$200013,$567000,$000912
		dc	$300000,$56F400,$000000,$57F400,$000608,$00000C,$050856,$0D1080
		dc	$00008C,$56F000,$000B93,$200003,$05744D,$0D1080,$000136,$0D1080
		dc	$000179,$0D1080,$0001BC,$240000,$447000,$00092B,$56F000,$000B41
		dc	$44F000,$000B94,$200045,$05A409,$0D1080,$00010E,$0D1080,$0001E3
		dc	$557000,$00092B,$0D1080,$0002CB,$0D1080,$0002E3,$0D1080,$0002F2
		dc	$0D1080,$00034D,$0D1080,$000309,$56F000,$000B41,$200003,$0D100A
		dc	$0003F4,$0D1080,$000356,$0D1080,$000383,$0D1080,$00039E,$0D1080
		dc	$FFFF87,$200013,$21101B,$00000C,$205800,$44D800,$447000,$000B42
		dc	$44D800,$447000,$000B43,$44D800,$447000,$000B44,$57D800,$0C1890
		dc	$002024,$507000,$000B78,$0C1890,$00101B,$507000,$000B7B,$0C1890
		dc	$003018,$507000,$000B7A,$44D800,$447000,$000B45,$44D800,$447000
		dc	$000B46,$44D800,$447000,$000B47,$57D800,$0C1890,$006020,$507000
		dc	$000B79,$57D800,$0C1890,$001023,$507000,$00023D,$0C1890,$001022
		dc	$507000,$00023E,$0C1890,$001021,$507000,$00023F,$0C1890,$004018
		dc	$507000,$000240,$61D800,$380600,$204800,$205900,$57D900,$015F8E
		dc	$577000,$000B49,$57D800,$0C1890,$008018,$507000,$000B41,$0C1890
		dc	$008020,$507000,$000B40,$57D800,$0C1890,$001018,$507000,$000B4C
		dc	$0C1890,$001019,$507000,$000B4A,$57D800,$577000,$000B4B,$57E000
		dc	$577000,$000B4D,$00000C,$56F000,$000912,$44F400,$020765,$200045
		dc	$052406,$56F000,$000B40,$200003,$05A45E,$00000C,$60F413,$0004FD
		dc	$060690,$000003,$545800,$545800,$60F413,$0005A8,$060590,$000002
		dc	$545800,$60F413,$00057B,$062890,$000002,$545800,$60F413,$0005AE
		dc	$065A90,$000002,$545800,$60F413,$000608,$060590,$000002,$545800
		dc	$60F413,$00060D,$060590,$000002,$545800,$60F413,$000509,$061090
		dc	$000002,$545800,$60F413,$000519,$060890,$000002,$545800,$60F413
		dc	$000521,$063C90,$000002,$545800,$60F413,$00055D,$061E90,$000002
		dc	$545800,$60F413,$000612,$060093,$000002,$545800,$44F400,$020765
		dc	$447000,$000912,$44F400,$000000,$447000,$000B93,$61F400,$000FC2
		dc	$71F000,$000B7A,$44F000,$000B7B,$5EE900,$547040,$000B94,$547000
		dc	$000B95,$44F01B,$000B94,$2D0513,$2C024D,$05945A,$44F01B,$000B95
		dc	$2D0613,$2C024D,$059455,$56F000,$000B79,$200023,$547000,$000B96
		dc	$44F01B,$000B78,$2D0313,$2C044D,$05944B,$44F01B,$000B96,$2D1313
		dc	$2C034D,$059446,$56F000,$000B79,$0140C4,$000024,$21DA00,$44F000
		dc	$000B78,$46F400,$000006,$2344D0,$0C1D2E,$44F440,$000F4C,$200040
		dc	$219100,$5EE100,$21CF22,$218422,$200022,$577040,$000B97,$218500
		dc	$21E46C,$46F400,$000008,$21A7D0,$5070E8,$000B9A,$457000,$000B98
		dc	$5170B0,$000B9B,$477000,$000B99,$507000,$000B9C,$050C03,$547000
		dc	$000B93,$00000C,$56F400,$000914,$44F000,$000B41,$200040,$219100
		dc	$56E100,$0C1E01,$44F43E,$000001,$20004C,$20291B,$45F403,$000003
		dc	$02A068,$20006D,$027068,$56F400,$000B5E,$44F000,$000B41,$200040
		dc	$219000,$556000,$00000C,$44F000,$000B7A,$46F400,$000006,$44F0D0
		dc	$000B41,$0C1D2E,$44F440,$000F92,$200040,$219400,$56F000,$000B44
		dc	$4CE400,$200040,$219100,$05E120,$56F000,$000B42,$4CE400,$200040
		dc	$219100,$56F000,$000B43,$4CE400,$200040,$219200,$44F400,$000100
		dc	$46E200,$2000D0,$240022,$210600,$2400D0,$46E200,$2400D2,$0C1D2E
		dc	$44E140,$200040,$219000,$70E200,$64F400,$0002FD,$3C0100,$3EFF00
		dc	$45F400,$3FF7CF,$56F000,$00023F,$200003,$05A40F,$56F000,$000B41
		dc	$44F432,$0004FD,$200040,$219100,$47F400,$000347,$57D900,$51D100
		dc	$0D04E2,$555900,$516100,$050C02,$0D04EF,$05F420,$00FFFF,$00000C
		dc	$56F000,$000B41,$44F000,$000B94,$200045,$05A44D,$56F000,$00023D
		dc	$200003,$05A45B,$60F400,$0002FD,$221400,$380100,$231C00,$44F000
		dc	$000B41,$46F400,$00000C,$44F4D0,$000521,$0C1D2E,$200040,$219100
		dc	$44F000,$000B41,$46F400,$000006,$44F4D0,$00055D,$0C1D2E,$200040
		dc	$219200,$56F000,$000240,$0140C4,$000007,$21DA00,$234400,$46F400
		dc	$00000F,$44F4D0,$000814,$0C1D2E,$200040,$219500,$3A0300,$3EFF00
		dc	$0D0499,$050C13,$56F000,$00023E,$200003,$05A40F,$60F400,$0002FD
		dc	$221400,$380100,$231C00,$61F400,$000509,$62F400,$000519,$65F400
		dc	$000800,$3A0400,$3EFF00,$0D04BA,$00000C,$44F000,$000B7A,$46F400
		dc	$000006,$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040,$219100
		dc	$4CE100,$447000,$000913,$61F400,$0002FD,$200013,$44D91B,$060091
		dc	$000004,$200047,$029040,$44D98A,$60F400,$0005A8,$70F000,$000B41
		dc	$200032,$44E826,$566847,$029040,$21C700,$56F400,$000914,$44F000
		dc	$000B41,$200040,$219000,$476000,$0C1C91,$44F000,$000B41,$46F400
		dc	$000002,$44F4D0,$00091A,$0C1D2E,$200040,$219000,$555800,$516000
		dc	$00000C,$60F400,$0002FD,$64F400,$0003FD,$380100,$231C00,$44F000
		dc	$000B41,$46F400,$000008,$44F4D0,$00057B,$0C1D2E,$200040,$219100
		dc	$65F400,$0008A2,$3A0200,$3EFF00,$0D0499,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380E00,$61F400
		dc	$0003FD,$204800,$060490,$000009,$200013,$064090,$000004,$44D900
		dc	$200047,$029040,$200026,$565800,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380800,$57F400,$000002
		dc	$204800,$380600,$060290,$00000B,$221100,$044812,$06CD10,$000006
		dc	$44DA00,$56DA00,$200045,$029040,$565900,$20402A,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$62F400,$0008AF,$390200,$45F41B,$000001,$20A600,$060390,$00000D
		dc	$221100,$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145
		dc	$027068,$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200
		dc	$56E800,$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0
		dc	$00091A,$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41
		dc	$200040,$219000,$44E100,$46F400,$7FFFFF,$44E0D0,$200045,$20291B
		dc	$56F400,$000926,$44F000,$000B41,$200040,$219000,$556000,$44F000
		dc	$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000
		dc	$380600,$62F400,$0008AC,$390200,$20A61B,$060390,$00000D,$221100
		dc	$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068
		dc	$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800
		dc	$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A
		dc	$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040
		dc	$219000,$44E100,$46F400,$400000,$46E0D0,$446055,$20291B,$56F400
		dc	$000B7C,$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$20AE00,$060390,$00000A,$221100,$219900,$221200,$204900,$44D900
		dc	$445A00,$44D900,$445A00,$204832,$00000C,$56F400,$000B7C,$44F000
		dc	$000B41,$200040,$219000,$56F400,$00060D,$44F000,$000B41,$200040
		dc	$219100,$56F400,$000B81,$44F000,$000B41,$200040,$219200,$44E01B
		dc	$56E100,$45F442,$000001,$02A068,$576200,$446100,$00000C,$60F400
		dc	$0002FD,$44F000,$000B41,$46F400,$000080,$44F4D0,$000612,$0C1D2E
		dc	$200040,$219100,$64F400,$0008B2,$65F400,$000000,$0D04F7,$00000C
		dc	$56F000,$00092B,$200003,$05A40E,$60F400,$000000,$61F400,$000040
		dc	$221400,$223500,$62F400,$000AB2,$66F400,$000AF2,$3A3F00,$0D0548
		dc	$050C0A,$60F400,$000000,$221400,$62F400,$0009B2,$66F400,$000A32
		dc	$3A7F00,$0D0539,$00000C,$0500A0,$0461A0,$56F000,$00092B,$200003
		dc	$05A415,$60F400,$000000,$61F400,$000040,$64F400,$0003FD,$65F400
		dc	$0004FC,$62F400,$000AB2,$66F400,$000AF2,$382000,$231900,$3A3F00
		dc	$3C0300,$75F400,$FFFFFD,$0D056E,$050C11,$60F400,$000000,$64F400
		dc	$0003FD,$65F400,$0004FC,$62F400,$0009B2,$66F400,$000A32,$384000
		dc	$3A7F00,$3C0200,$75F400,$FFFFFE,$0D055F,$05F420,$00FFFF,$0461A0
		dc	$56F000,$000B41,$44F000,$000B94,$60F445,$0003FD,$05A408,$61F400
		dc	$000180,$06B590,$000003,$44D800,$445900,$050C07,$61F400,$000235
		dc	$060790,$000003,$44D800,$445900,$00000C,$56F000,$00092B,$200003
		dc	$05A40A,$60F400,$000000,$384000,$0D03EA,$60F400,$000040,$384000
		dc	$0D03EA,$050C05,$60F400,$000000,$388000,$0D03EA,$00000C,$56F000
		dc	$000B94,$44F000,$000B41,$45F445,$000001,$05A403,$05080D,$050C03
		dc	$457000,$000B8C,$60F400,$000B7C,$61F400,$0005A3,$060590,$000003
		dc	$44D800,$445900,$00000C,$290300,$70F000,$000B41,$60F400,$000B7C
		dc	$56E800,$014185,$05A410,$60F400,$000926,$56E800,$014185,$05A40B
		dc	$56F000,$000B40,$014085,$05A406,$60F400,$0005A3,$56E800,$014185
		dc	$05A402,$290200,$60F400,$000B87,$516800,$00000C,$3D1800,$44F000
		dc	$000B41,$56F000,$000B94,$60F445,$000180,$05A40C,$209600,$61F400
		dc	$000241,$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$0D0586
		dc	$050C0A,$56F000,$000B7B,$60F403,$000235,$05A405,$61F400,$0002F6
		dc	$390700,$0D0586,$00000C,$44F000,$000B41,$56F000,$000B94,$61F445
		dc	$000241,$05A459,$56F400,$000B87,$44F000,$000B41,$200040,$219000
		dc	$56F400,$000BA2,$44F000,$000B41,$200040,$219200,$56E000,$71E200
		dc	$219400,$223600,$56F400,$000B59,$44F000,$000B41,$200040,$219000
		dc	$56F400,$000B8E,$44F000,$000B41,$200040,$219200,$232E00,$014184
		dc	$0B74C4,$000F16,$218500,$47F4AD,$000001,$0B74C4,$000F12,$21E600
		dc	$209DD0,$0C1D2E,$46F465,$2AAAAB,$202978,$556000,$21A500,$21BCE9
		dc	$0C1D82,$200010,$200065,$202978,$556200,$223200,$205900,$3A0000
		dc	$0D0591,$050C11,$56F000,$000B7B,$60F403,$000B8C,$05A40C,$61F400
		dc	$0002F6,$390700,$223600,$223200,$205900,$3A0000,$3C0600,$7DF000
		dc	$000F13,$0D0591,$00000C,$56F000,$000240,$0C1D04,$21C700,$46F400
		dc	$000003,$2000B0,$0C1D2E,$0140C0,$000049,$21C600,$61F400,$000B9D
		dc	$62F400,$000BA2,$45F000,$000B94,$06C510,$000003,$475900,$465A00
		dc	$57F400,$000001,$56F000,$000B40,$200003,$05A402,$20001B,$577000
		dc	$000B8D,$00000C,$56F400,$00000A,$57F400,$000000,$70F400,$000416
		dc	$0BF080,$000180,$200003,$052400,$00000C,$56F400,$00000A,$57F400
		dc	$000001,$60F400,$0004FD,$70F400,$000416,$390000,$0BF080,$000180
		dc	$200003,$052400,$00000C,$56F400,$00000A,$57F400,$000002,$60F400
		dc	$0004FD,$70F400,$000416,$390000,$0BF080,$000180,$200003,$052400
		dc	$00000C,$56F400,$000011,$57F400,$000001,$390000,$70F400,$000080
		dc	$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C,$56F400
		dc	$00000D,$57F400,$000000,$70F400,$000390,$0BF080,$000180,$200003
		dc	$052400,$56F400,$00000E,$57F400,$000000,$70F400,$000390,$0BF080
		dc	$000180,$200003,$052400,$00000C,$447000,$000963,$56F000,$000B94
		dc	$200045,$052407,$71F400,$000389,$380700,$60F400,$000235,$050C07
		dc	$46F400,$0000B5,$20D8D0,$60F422,$000180,$211900,$56F400,$00000D
		dc	$57F400,$000002,$0BF080,$000180,$200003,$052400,$44F000,$000963
		dc	$56F000,$000B94,$200045,$052407,$71F400,$000389,$380700,$60F400
		dc	$0002F6,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000241,$211900
		dc	$56F400,$00000E,$57F400,$000002,$0BF080,$000180,$200003,$052400
		dc	$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\llef23.asm ===
;	File info
;	  File name: llef23.asm
;	  Build date: 02/04/02, 18:31:18
;	Program info
;	  Program number: 3
;	  Revision number: 1.114
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 1618 words
;	  Checksum: $8C0B50

		dc	$D01B40,$000652,$030172,$8C0B50,$20000B,$0D1002,$00064B,$0D1080
		dc	$00063B,$57F400,$000010,$300000,$0D1080,$000233,$44F400,$000000
		dc	$200045,$057400,$0D1080,$00063F,$00000C,$46F461,$000010,$230700
		dc	$06D910,$00000A,$50D97C,$057407,$21E478,$0C1E46,$0C1E90,$21E449
		dc	$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F461,$000010,$230700
		dc	$50D97C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$46F400,$000010,$230700,$06D910,$00000D
		dc	$56D900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449
		dc	$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400,$000010,$230700
		dc	$06D910,$00000D,$5ED900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400
		dc	$000010,$230700,$56D900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400
		dc	$000010,$230700,$5ED900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$61F400
		dc	$000D12,$46F400,$0000FF,$06D810,$00000E,$0C1C90,$200056,$51D800
		dc	$219900,$0C1D91,$4CE900,$20004B,$0C1C90,$200056,$219900,$0C1D91
		dc	$4CE900,$20004B,$0C1E91,$21AE00,$0C1C11,$00000C,$61F41B,$000E12
		dc	$46F400,$0000FF,$204800,$06D810,$00000D,$21AE5E,$44F800,$21B900
		dc	$0C1ED0,$200042,$4CE900,$200043,$218F56,$219900,$0C1ED1,$4CE900
		dc	$20004B,$0C1E91,$21AE00,$0C1C11,$00000C,$000418,$000418,$000418
		dc	$00042A,$00042A,$00042A,$000425,$000442,$000442,$000442,$000442
		dc	$000442,$000442,$000442,$000442,$000442,$000442,$000442,$000442
		dc	$000442,$00044E,$00044E,$00044E,$00045F,$00045F,$00045F,$00045F
		dc	$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F
		dc	$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F
		dc	$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$22B100
		dc	$231900,$204800,$204900,$45F41B,$000040,$51F400,$000C00,$44D801
		dc	$06DC10,$000003,$44D8A6,$505901,$240000,$447000,$000492,$240000
		dc	$447000,$000491,$231000,$22B800,$74F400,$0003A5,$65F400,$000B32
		dc	$44F000,$000B7B,$46F400,$000032,$2244D0,$0C1D2E,$44F440,$000C1C
		dc	$200040,$219600,$390100,$0B72CE,$000F1A,$23C400,$220745,$027040
		dc	$232474,$57E844,$205800,$45E800,$05A40D,$47F400,$0000D1,$06CC10
		dc	$000009,$21EE6C,$029060,$20582E,$45E82B,$21BD7D,$4CED00,$202F40
		dc	$21CF00,$225400,$44F461,$000100,$07EC94,$47F044,$000491,$0AE480
		dc	$57700D,$000493,$05F408,$20EE6D,$05F458,$0140C4,$000040,$202913
		dc	$218700,$050C53,$47F400,$000180,$050C50,$218600,$23CE00,$014785
		dc	$05A40D,$20CE00,$20000D,$05F408,$20EE6D,$05F408,$0140C4,$000040
		dc	$202913,$218700,$050C03,$47F400,$000180,$44F000,$000493,$56F04D
		dc	$000492,$557000,$000493,$059404,$232E00,$717000,$000492,$200003
		dc	$05A414,$050C1E,$20000D,$05F408,$20EE6D,$05F41A,$0140C4,$000040
		dc	$202913,$218700,$050C15,$47F400,$000140,$050C12,$200071,$0140C4
		dc	$000080,$202913,$218700,$050C0C,$44F001,$00048F,$44F044,$00048E
		dc	$547001,$00048B,$477044,$000491,$547074,$00048A,$050C1B,$56F000
		dc	$00048B,$44F000,$00048D,$44F044,$00048F,$218601,$45F044,$00048A
		dc	$44F055,$00048C,$029050,$547061,$00048B,$44F044,$00048E,$218601
		dc	$477044,$000491,$44F055,$00048B,$029050,$547074,$00048A,$200045
		dc	$029040,$44F000,$000490,$4EDE4C,$0C1C85,$202914,$200055,$029050
		dc	$546A00,$220E00,$23C400,$205A45,$0596D7,$00000C,$56F000,$0004B7
		dc	$44F003,$0004A2,$05A407,$20EE00,$240064,$06CC10,$000002,$445900
		dc	$050C4D,$64F400,$000CBA,$66F400,$0004A5,$57DA00,$46F04C,$0004BF
		dc	$20005C,$20291B,$0140CE,$001FE0,$5EDD58,$200075,$027070,$21C564
		dc	$014184,$219E00,$56D800,$46F414,$00003F,$202913,$0C1ECA,$200055
		dc	$027050,$219C00,$06DE10,$00000B,$56D800,$7EEC14,$202913,$0C1ECA
		dc	$765955,$027050,$219C00,$56EE00,$014180,$546E00,$7EEC00,$765900
		dc	$56EE00,$014180,$546E71,$200065,$057799,$00000C,$60F400,$000B68
		dc	$70F000,$000B40,$57E800,$44F000,$000B7A,$20004C,$20000B,$05140C
		dc	$200013,$567000,$000B66,$567000,$000B67,$567000,$0004A4,$567000
		dc	$000B6E,$0D10C0,$000027,$200013,$21D800,$44F000,$000B70,$200045
		dc	$059404,$56F400,$000009,$21D800,$200005,$05F409,$200013,$567000
		dc	$000B66,$567000,$000B67,$567000,$0004A4,$050C13,$56F400,$000001
		dc	$567000,$000B66,$21EE00,$230400,$200044,$0C1C06,$280000,$567000
		dc	$000B67,$0C1D06,$230400,$200040,$567000,$0004A4,$21C400,$20004C
		dc	$56F000,$000B40,$44F400,$000005,$200045,$052413,$56F000,$000B9F
		dc	$44F000,$000B7A,$200044,$44F000,$000B53,$200044,$21D900,$577000
		dc	$000B6E,$200003,$059404,$200005,$05F402,$050C03,$232400,$208F00
		dc	$56F000,$000B70,$200003,$05F40A,$44F400,$000001,$447000,$000B66
		dc	$44F000,$000B67,$200040,$567000,$000B67,$00000C,$221100,$22B200
		dc	$46F469,$000002,$06D810,$000005,$56C900,$218F14,$200050,$545A00
		dc	$234E00,$234432,$230440,$240044,$05A404,$06CC10,$000002,$445A00
		dc	$22B000,$229100,$65F400,$000D0D,$75F400,$FFFFFE,$06DA10,$000007
		dc	$F0B800,$F0B8D0,$D0B8D2,$2000D2,$200022,$585900,$00000C,$05F420
		dc	$FFFFFF,$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400
		dc	$000000,$20004D,$05A40C,$44F400,$000010,$20004D,$0D104A,$00000F
		dc	$300000,$56F400,$000000,$57F400,$FFFFFF,$00000C,$200013,$300000
		dc	$56F400,$000000,$57F400,$000608,$00000C,$56F000,$000B96,$200003
		dc	$05741E,$56F000,$000B40,$2E0003,$052402,$014180,$567000,$000B89
		dc	$0D1080,$00038B,$44F400,$0007B0,$447000,$000B72,$0D1080,$000014
		dc	$56F000,$000B40,$2E0003,$052403,$0D1080,$000353,$0D1080,$00009D
		dc	$56F000,$000B96,$200003,$052403,$0D1080,$00019C,$200013,$21101B
		dc	$00000C,$00000C,$44F400,$000001,$447000,$000B6F,$56F01B,$000B40
		dc	$200003,$052402,$000009,$517000,$0004C0,$300200,$310100,$320100
		dc	$350200,$0B70C4,$000C08,$447000,$00048D,$0B71C4,$000C04,$447000
		dc	$00048C,$0B72C4,$000C14,$447000,$00048F,$0B75C4,$000C18,$447000
		dc	$000490,$360000,$44F000,$000B97,$06C410,$00004E,$280100,$507000
		dc	$0004C0,$300400,$0B70C4,$000C0C,$447000,$00048E,$44F400,$FF8000
		dc	$447000,$00048A,$44F400,$FF8000,$447000,$00048B,$22C400,$46F400
		dc	$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040,$219000,$22C400,$46F400
		dc	$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040,$219500,$22C400,$46F400
		dc	$000032,$44F4D0,$000000,$0C1D2E,$200040,$219A00,$380000,$56F400
		dc	$000BA5,$22C400,$200040,$219100,$74E100,$76E100,$320000,$667000
		dc	$000B41,$0D03D7,$66F000,$000B41,$56F400,$0004C1,$22C400,$200040
		dc	$219000,$626000,$56F400,$000494,$22C400,$200040,$219000,$44F000
		dc	$00048A,$446000,$56F400,$000499,$22C400,$200040,$219000,$44F000
		dc	$00048B,$446000,$205E00,$56F000,$000B7E,$200003,$05A41C,$280100
		dc	$507000,$0004C0,$300400,$0B70C4,$000C0C,$447000,$00048E,$44F400
		dc	$FF8000,$447000,$00048A,$44F400,$FF8000,$447000,$00048B,$60F400
		dc	$000483,$65F400,$000483,$72F400,$0004B8,$380000,$3C0700,$3E0700
		dc	$320000,$0D03D7,$00000C,$56F000,$000B40,$200003,$052404,$240000
		dc	$447000,$000B6E,$340000,$20001B,$44F000,$000B97,$06C410,$000003
		dc	$014188,$014188,$014188,$56F000,$000B7D,$200003,$052402,$014188
		dc	$56F000,$000B4A,$44F403,$000008,$05A402,$200048,$014188,$56F000
		dc	$000B89,$200003,$05A402,$014188,$56F000,$000B7D,$014285,$052407
		dc	$014188,$56F000,$000B40,$44F403,$000004,$202A48,$44F000,$000B97
		dc	$06C410,$000002,$014288,$56F000,$000B7E,$200003,$05A402,$014188
		dc	$56F400,$000B8A,$240000,$200040,$219000,$44F000,$000B97,$06C410
		dc	$000006,$56D800,$200003,$05A402,$014688,$000000,$60F400,$000B8A
		dc	$61F400,$000B91,$46F400,$000007,$44F000,$000B97,$06C410,$00000A
		dc	$56D800,$44D903,$05A406,$014488,$2000D0,$0C1D2E,$200018,$014288
		dc	$000000,$56F000,$000B7E,$200003,$05A408,$56F000,$000B8F,$44F403
		dc	$00000E,$05A403,$014488,$200048,$014188,$56F000,$000B90,$200003
		dc	$05A406,$014288,$014288,$014288,$014288,$014388,$014188,$56F000
		dc	$000B6F,$200003,$05A40E,$014688,$44F000,$000B97,$06C410,$000003
		dc	$014488,$014388,$56F000,$000B7E,$200003,$05A403,$014488,$014388
		dc	$014188,$014188,$21E71B,$56F000,$000B40,$0140C5,$000003,$0D1042
		dc	$00000D,$21E779,$014988,$21E779,$014188,$014188,$56F000,$000B40
		dc	$0140C5,$000003,$052402,$016F88,$014788,$0C1EC7,$557000,$000B70
		dc	$0C1E87,$21E479,$200048,$557000,$000B71,$56F000,$000B40,$200003
		dc	$052407,$20001B,$014188,$014188,$015088,$557000,$000B53,$56F000
		dc	$000B40,$200003,$05248C,$57F000,$000B51,$44F000,$000B53,$200048
		dc	$44F000,$000B9A,$46F400,$000008,$2000D0,$210E00,$200014,$547000
		dc	$000B52,$56F000,$000B53,$44F000,$000B9F,$200045,$057485,$44F41B
		dc	$155555,$56F000,$000B52,$0140C4,$00002F,$218500,$2000A8,$21AF00
		dc	$44F000,$000B71,$20004D,$05F458,$21A500,$44F400,$000006,$2000A0
		dc	$0C1D2E,$44F036,$000B52,$200040,$0140C4,$00002F,$21C700,$0140C8
		dc	$000001,$56F400,$000B68,$240000,$200040,$219000,$20F800,$06D810
		dc	$000002,$575800,$0140CC,$000001,$56F400,$000006,$200074,$200003
		dc	$05F405,$21D800,$06D810,$000002,$575800,$56F400,$000B68,$44F400
		dc	$000003,$200040,$219000,$56E000,$016F80,$566000,$56F400,$000B68
		dc	$240000,$200040,$219000,$70F000,$000B40,$56E800,$44F000,$000B71
		dc	$200044,$566800,$00000C,$44F400,$000001,$447000,$000B96,$00000C
		dc	$0D1080,$000023,$200003,$05A41B,$0D1080,$FFFDA2,$56F400,$000005
		dc	$44F000,$000B40,$200045,$05F417,$56F400,$000B68,$44F000,$000B40
		dc	$200040,$0140C0,$000001,$21D000,$56D000,$44D800,$200040,$44F000
		dc	$000B7A,$45F044,$0004A4,$200064,$566000,$050C05,$0D1080,$000158
		dc	$0D1080,$FFFD86,$00000C,$45F400,$FFFF90,$457000,$00049F,$0D1080
		dc	$00007C,$44F400,$000008,$447000,$00049E,$240000,$447000,$0004B5
		dc	$50F000,$00049E,$00000A,$507000,$00049E,$0D1080,$000087,$20000B
		dc	$059409,$44F400,$000001,$447000,$0004B5,$44F000,$00049F,$447000
		dc	$0004B6,$56F000,$0004B5,$200003,$05A40F,$56F400,$000010,$21C400
		dc	$567000,$0004A0,$56F000,$00049F,$567000,$0004A1,$200040,$200022
		dc	$567000,$00049F,$050C0E,$56F400,$FFFF10,$21C400,$567000,$0004A1
		dc	$56F000,$00049F,$567000,$0004A0,$200040,$200022,$567000,$00049F
		dc	$0D1080,$000043,$0D1080,$00005A,$20000B,$05940E,$44F000,$00049F
		dc	$447000,$0004A1,$44F400,$000001,$447000,$0004B5,$44F000,$00049F
		dc	$447000,$0004B6,$050C05,$44F000,$00049F,$447000,$0004A0,$56F000
		dc	$0004A0,$44F000,$0004A1,$21C644,$0140C5,$000001,$052408,$0D1080
		dc	$000128,$44F400,$000001,$447000,$0004B5,$050C1B,$200051,$200040
		dc	$200022,$200045,$057404,$208E00,$014180,$050C05,$200055,$059403
		dc	$20CE00,$014184,$547000,$00049F,$56F000,$00049E,$014184,$547000
		dc	$00049E,$057787,$56F000,$0004B5,$014185,$052403,$0D1080,$000109
		dc	$56F000,$0004B5,$00000C,$56F000,$00049F,$0140C0,$0000F0,$0C1C08
		dc	$218400,$2C0000,$0C1D08,$218600,$60F400,$000B73,$62F400,$000B79
		dc	$64F400,$000B74,$3C0500,$70F000,$000B97,$229500,$445800,$465A00
		dc	$06D810,$000002,$465D00,$00000C,$70F000,$000B40,$60F400,$000B68
		dc	$57E800,$21FA00,$56F000,$0004C0,$200003,$05A545,$56F400,$000001
		dc	$567000,$0004B7,$56F400,$000000,$44F000,$000B73,$200045,$05A404
		dc	$240000,$447000,$0004B7,$46F400,$000000,$60F400,$000B74,$44F000
		dc	$000B97,$06C410,$000008,$56D800,$200055,$05A404,$200013,$567000
		dc	$0004B7,$000000,$56F000,$000B7E,$200003,$05A408,$56F000,$000B79
		dc	$200055,$05A404,$200013,$567000,$0004B7,$300700,$0B70C4,$000CB2
		dc	$447000,$0004BF,$60F413,$0004A5,$061090,$000002,$565800,$360000
		dc	$44F000,$000B97,$06C410,$000036,$56F400,$000B74,$22C400,$200040
		dc	$219000,$56F000,$000B73,$44E000,$014F84,$0C1D08,$200040,$0C1D04
		dc	$547000,$0004A2,$56F400,$000BA5,$22C400,$200040,$219000,$250000
		dc	$47E000,$22C400,$46F400,$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040
		dc	$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72,$0C1D2E,$200040
		dc	$219100,$22C400,$46F400,$000032,$44F4D0,$000000,$0C1D2E,$200040
		dc	$219200,$65F400,$000F1A,$667000,$000B41,$0D0486,$66F000,$000B41
		dc	$205E00,$56F000,$000B7E,$200003,$05A417,$56F000,$000B73,$44F000
		dc	$000B79,$014F84,$0C1D08,$200040,$0C1D04,$547000,$0004A2,$250000
		dc	$47F400,$000007,$60F400,$000483,$61F400,$000B39,$62F400,$0004B8
		dc	$65F400,$000F1A,$0D0486,$60F400,$0004A6,$66F41B,$000CFB,$44D800
		dc	$47F413,$D55555,$20E800,$4EDEC6,$218413,$44D8DA,$20E800,$4EDEC6
		dc	$218400,$F0D8DA,$44D8DA,$47F413,$C00000,$20E800,$4EDEC6,$218400
		dc	$2000DA,$F0D800,$060A90,$000002,$F0D8DA,$2000DA,$0C1DAE,$567000
		dc	$000B7A,$050C02,$050C00,$44F01B,$000B7A,$234F00,$20004C,$21FA00
		dc	$20000B,$051402,$050C03,$0D1080,$FFFC33,$00000C,$60F41B,$000B7A
		dc	$576000,$60F400,$000B73,$62F400,$000B79,$64F400,$000B74,$70F000
		dc	$000B97,$229500,$576000,$576200,$06D810,$000002,$575D00,$360000
		dc	$44F000,$000B97,$06C410,$000012,$22C400,$46F400,$0000B5,$44F0D0
		dc	$000B72,$0C1D2E,$200040,$219000,$56F400,$000BA5,$22C400,$200040
		dc	$219200,$066210,$000002,$575800,$205E00,$56F000,$000B7E,$200003
		dc	$05A406,$60F400,$000B39,$060790,$000002,$575800,$00000C,$44F000
		dc	$0004B6,$447000,$00049F,$0D1080,$FFFEF8,$050A0F,$00000C,$20001B
		dc	$015088,$015088,$014288,$014688,$014588,$014388,$014388,$56F000
		dc	$000B7D,$014185,$05A404,$014186,$05A402,$014288,$56F000,$000B7D
		dc	$014486,$05A402,$014288,$56F000,$000B7D,$014285,$052402,$014288
		dc	$014188,$014588,$014188,$56F000,$000B4C,$44F403,$000008,$05A402
		dc	$200048,$014188,$014188,$014188,$014188,$014188,$014188,$014188
		dc	$577000,$000B51,$00000C,$360000,$44F000,$000B97,$06C410,$000034
		dc	$56F400,$000B8A,$22C400,$200040,$219000,$56E000,$219203,$05A44B
		dc	$22C400,$46F400,$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040,$219000
		dc	$56F400,$000B5C,$22C400,$200040,$219100,$70E100,$0B72D9,$000F12
		dc	$56F400,$000B91,$22C400,$200040,$219100,$72E100,$45D800,$22C400
		dc	$46F400,$0000B5,$44F4D0,$0007B0,$0C1D2E,$200040,$219500,$455D00
		dc	$22C400,$46F400,$00001F,$44F4D0,$000000,$0C1D2E,$200040,$219400
		dc	$4D5C00,$0D051E,$205E00,$56F000,$000B7E,$200003,$05A413,$56F000
		dc	$000B8F,$200003,$05A40F,$60F400,$000483,$380600,$79F000,$000F13
		dc	$3A0200,$45D800,$65F400,$000B39,$455D00,$64F400,$00009B,$4D5C00
		dc	$0D051E,$00000C,$56F400,$000016,$57F400,$000001,$70F400,$000390
		dc	$390000,$60F400,$0000FA,$0BF080,$000180,$200003,$052400,$00000C
		dc	$00000C,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\loader.asm ===
; ******************************************************************
;
;       Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
;       All Rights Reserved.
;                                                                                               
;       File:                   loader.asm
;                                                                                               
;   Contents:           Loader for Dolby Game Encoder
;
;       Author:                 jmw
;                                                                                       
;       Revision:               1.00b
;                                                                                       
;       History:
;
;               Rev 1.00        10/11/2000 7:23:25 AM           jmw
;                 Created.
;               Rev 1.00b       12/11/2000 4:11:12 PM           Ethan Brodsky
;                 brought DMA code over from Dolby/v1.20 package
;
;
; ******************************************************************

        page    132,66,3,3
        opt             cre,loc,cc,cex,mex,mu,so

        title   'Dolby Loader'

        section Loader

;**** include files ************************************************

        nolist
        include 'ldr_sip.inc'
        include 'eputil.h'    ; EP constants
        include 'dmautil.h'   ; DMA constants
        list

;**** equates ******************************************************

        ;DEFINE ERRCHK  '1'                     ; Enable error checking

        IF              !@DEF('RTSYS')
;       DEFINE  CHKSUM  '0'                     ; Enable program checksum
        ENDIF

        DEFINE  PREAMBLE                '1'     ; Enable AC3 SPDIF Preamble
        DEFINE  ZEROFILL                '1'     ; Enable AC3 SPDIF Zero Fill
        DEFINE  EP_RETURNS_LEVELS       '1'


;**** macros ******************************************************


debug_wait macro
_wait_for_flag
    move    p:debug_enable,a
    cmp     #0,a
    beq     _wait_no_debug
    move    p:debug_wait_flag,a
    cmp     #0,a
        beq     _wait_for_flag
_wait_no_debug
    move    #0,x0
    move    x0,p:debug_wait_flag
        endm

;**** program code *************************************************

        xref    LdrTable


        org             p(100):                         ; Loader Runtime Counter is 100

;******************************************************************************
;*                                                                                
;*   Subroutine Name:   Loader
;*                                                                
;*   Description:               Loader
;*                                                                                    
;*   Input:                             a       - Buffer ID word
;*                                              b       - Loader action
;*                                              r0      - DSP memory address
;*                                              n0      - number of words to transfer
;*                                              n1      - System memory offset
;*
;*   Output:                    a       - error return code: nonzero if error
;*
;*   Modifies:                  
;*
;*       Locals:                        
;*
;*       Stack Space Used:      
;*                                                                                    
;******************************************************************************

loader:
        move    #LdrTable,r2                    ; set up loader table base
        move    a1,n2                                   ; set up loader table offset
    move    #1,n5                   ; set Flag indicating DMAs are blocking type
        

;       Check Buffer ID to see what to do, check for errors along the way

        IF              @DEF('ERRCHK')
        cmp             #LID_MIN,a                              ; is ID too small?
        blt             <abort_id                               ; if so, abort
        cmp             #LID_MAX,a                              ; is ID too big?
        bgt             <abort_id                               ; if so, abort
        ENDIF


        cmp             #LID_LOADER_INIT,a              ; loader init request?
        beq             <loader_init                ; if so, go init the loader

        move    (r2)+n2                                 ; point into table (halfway)
        move    (r2)+n2                                 ; point into table
        move    p:(r2)+,r1                              ; get system memory address
                                                        ; (or FIFO index, in case of ac3/rtlt)

        cmp             #LID_BUF_DATA,a                 ; is ID a heap data buffer?
        bge             <heap_id                                ; if so, go parse heap buffer params
        cmp             #LID_MAX_PROG,a                 ; is ID a program?
        ble             <load_program                   ; if so, go load program
        cmp             #LID_BUF_AC3,a                  ; is ID for output AC-3?
        beq             <save_ac3                               ; if so, save AC-3
        cmp             #LID_CONFIG_LIST,a              ; is ID system configuration data?
        beq             <load_config                    ; if so, go load configuration list
        cmp             #LID_PING_PONG,a                ; should we toggle the PCM input ping pong
        beq             <toggle_ping_pong

        cmp             #LID_AC3_ZEROS,a                ; is ID for zero fill of AC-3 output buffer?
        beq             <SPDIFzerofill                  ; if so, go zero fill
        cmp             #LID_AC3_PREAMBLE,a             ; is ID to write AC3 S/PDIF preamble?
        beq             <SPDIFpreamble                  ; if so, go write SPDIF preamble

        cmp             #LID_BUF_LTRT,a
        beq             <save_ltrt                              ; save Lt/Rt

        cmp             #LID_LEVELS_AC3,a               ; peak and RMS levels from AC-3 inputs
        beq             <save_levels_digital
        cmp             #LID_LEVELS_ANALOG,a            ; peak and RMS levels from analog outputs
        beq             <save_levels_analog

        bra             <load_pcm                       ; if so, load pcm

;***********************************************************************
;       Data storage for loader variables

ldr_heap_ptr                dc      0           ; current heap pointer
ldr_heap_size               dc      0           ; current heap size
        IF              @DEF('CHKSUM')
ldr_r0_copy                 dc      0           ; copy of r0 input argument
ldr_n0_copy                 dc      0           ; copy of n0
        ENDIF   ; @DEF('CHKSUM')

debug_wait_flag             dc      0           ;
debug_enable                dc      1

dmaNode                     dc      0
dmaNode1                    dc      0
dmaNode2                    dc      0
dmaNode3                    dc      0
dmaNode4                    dc      0
dmaNode5                    dc      0
dmaNode6                    dc      0
prev_time                   dc      0
elapsed_time                dc      0

        IF              @DEF('EP_RETURNS_LEVELS')

levels_analog_peak          dc      0
                            dc      0
levels_analog_RMS           dc      0
                            dc      0
levels_digital_peak         dc      0
                            dc      0
                            dc      0
                            dc      0
                            dc      0
                            dc      0
levels_digital_RMS          dc      0
                            dc      0
                            dc      0
                            dc      0
                            dc      0
                            dc      0
        ENDIF

;***********************************************************************
;       Load configuration data from system
;               uses input DSP address, gets length from loader table
;               ignores input action, offset, and length

load_config:

        move    p:(r2)+,a                               ; get length from Sys Mem
        move    n0,x0                                   ; copy max length to x0
        cmp             x0,a a1,n0                              ; compare two lengths. preload length
        IF              @DEF('ERRCHK')
        bgt             <abort_length                   ; if SysMem length to large, fail
        ENDIF

        bsr             <CopySysToDSPX                  ; copy list

        bra             <done

;***********************************************************************
;       Load a program
;               uses input DSP address, gets length from loader table
;               ignores input action, offset, and length
;               error checking for program checksum

load_program:
        move    p:(r2)+,n0                              ; get program size
        IF              @DEF('CHKSUM')
        move    r0,p:ldr_r0_copy                ; save r0
        move    n0,p:ldr_n0_copy                ; save n0
        ENDIF   ; @DEF('CHKSUM')
        bsr             <CopySysToDSPP                  ; copy program
        IF              @DEF('CHKSUM')
        clr             a                                               ; init checksum
        move    p:ldr_n0_copy,n0                ; restore n0
        move    p:ldr_r0_copy,r0                ; restore r0
        dor             n0,checksumlp
        move    p:(r0)+,x0                              ; get DSP word
        add             x0,a                                    ; add to checksum
checksumlp:
        move    #>0,a2                                  ; clear msword, use as return code
        rts                                                             ; return from here
        ELSE
        bra             <done                                   ; exit
        ENDIF



;***********************************************************************
;       Toggle ping pong buffer on PCM input

toggle_ping_pong:
        move    p:LdrTable+LDR_PINGPONG_OFFSET,x0
        bchg    #8,x0                               
        move    x0,p:LdrTable+LDR_PINGPONG_OFFSET

        bra             <done                                   ; exit

;***********************************************************************
;       Load input PCM data
;               uses input DSP address, length, offset
;               ignores input action
;               error checking for buffer overflow

load_pcm:

;       The following lines convert an interleave buffer index into an offset
;       suitable for contiguous audio buffers.  

        move    n1,b                                    ; get interleave buffer index
        asl     #9,b,b                                  ; multiply by 512
        move    r1,x0                                   ; rewritten to avoid pipeline stall
        add     x0,b
        move    p:LdrTable+LDR_PINGPONG_OFFSET,a
        add     b,a
        move    a1,r1

load_pcm_block0:
        bsr     <CopySysToDSPX                  ; copy buffer data

        bra     <done                                   ; exit


;***********************************************************************
;       Save output Lt/Rt data
;               uses input DSP address, length, offset
;               ignores input action
;               error checking for buffer overflow
;       Note:   FIFO index is in r1 instead of system memory address

save_ltrt:

        IF @DEF('PERF_COUNTERS')
        ;***********************************************************************
        move    x:TIMER1_COUNT,x0
        movem   x0,p:prev_time
        ;***********************************************************************
        ENDIF

        ;ignore the second save_ltrt, we do interleave

        move    n1,a
        cmp     #0,a
        bne     <done

        move    #1,n2                                           ;This flag indicates number of channels -1 to interleave
        move    #0,n4                       ;This flag indicates null ouput
        bsr     <CopyDSPXToFIFO

        IF @DEF('PERF_COUNTERS')
        ;***********************************************************************
        clr     a
        move    x:TIMER1_COUNT,a1
        movem   p:prev_time,x0
        cmpu    x0,a
        blt     <done     

        move    a1,a
        sub     x0,a        
        movem   a1,p:elapsed_time               
        ;***********************************************************************
        ENDIF

        bra             <done                                   ; exit

;***********************************************************************
;       Save output AC-3 data
;               uses input DSP address, length, offset
;               ignores input action
;               error checking for buffer overflow
;       Note:   FIFO index is in r1 instead of system memory address

save_ac3:

;;;;;; Note: Dolby memory-based code
;;;;;   move    (r1)+n1                                 ; adjust output pointer
;       Note: XXXXX TODO - this might be a problem - we've switched to a FIFO,
;             so we can't support the n1 offset into the buffer.  Hopefully
;             Dolby will be writing everything in order...
;;;;;   bsr             <CopyDSPXToSys                  ; copy buffer data


        move    #0,n2                                           ;This flag indicates number of channels -1 to interleave
        move    #0,n4                       ;This flag indicates null ouput
    ;move    #0,n5                       ;Clear blocking flag
        bsr             <CopyDSPXToFIFO
;       Note:   this currently blocks until DMA completion...  If we're working
;               with a FIFO, will it complete quickly or slowly?  If slowly,
;               we probably need to make this non-blocking.  In which case we
;               need to have multiple DMA nodes instead of using a single node
;               for everything...

        bra             <done                                   ; exit


; code to update peak And RMS peak levels in system memory
;

save_levels_analog:
        move    #levels_analog_peak,r1
        bra     <levelbegin

save_levels_digital:
        move    #levels_digital_peak,r1

levelbegin:
        dor     n0,levelloop
                move x:(r0)+,x0
                move x0,p:(r1)+
                nop
levelloop:
        bra             <done


;***********************************************************************
; Zero Fill AC-3 output buffer
;       uses length (n0), offset (n1)


SPDIFzerofill:
        IF              @DEF('ZEROFILL')

        move    #0,n2                                           ;This flag indicates number of channels -1 to interleave
        move    #1,n4                       ;This flag indicates null ouput
    move    #0,n5                       ;Clear blocking flag
        bsr             <CopyDSPXToFIFO

    ENDIF
        bra             <done                                   ; exit




;***********************************************************************
; Load preamble from DSP X memory
;       (essentially the same routine as used for "save_ac3")
;       uses input DSP address (r0), offset (n1), length (n0)

SPDIFpreamble:

        IF              @DEF('PREAMBLE')

        move    #0,n2                                           ;This flag indicates number of channels -1 to interleave
        move    #0,n4                       ;This flag indicates null ouput
        bsr             <CopyDSPXToFIFO
;       Note:   this currently blocks until DMA completion...  If we're working
;               with a FIFO, will it complete quickly or slowly?  If slowly,
;               we probably need to make this non-blocking.  In which case we
;               need to have multiple DMA nodes instead of using a single node
;               for everything...

    ENDIF
        bra             <done                                   ; exit


;***********************************************************************
;       Heap handler

heap_jmptbl             dc              CopySysToDSPX,CopyDSPXToSys
                                dc              CopySysToDSPY,CopyDSPYToSys
                                dc              CopySysToDSPP,CopyDSPPToSys

heap_id:
        cmp             #LDR_ACT_ALLOC,b                ; is action alloc?
        beq             <alloc_heap                             ; if so, skip ahead

;***********************************************************************
;       Heap access code
;               Transfers data to/from allocated data buffers
;               Uses all input parameters
;               Checks for following errors:
;                       Buffer not yet allocated
;                       Invalid length
;                       Invalid offset
;                       Buffer overflow

access_heap:
        IF              @DEF('ERRCHK')
        tst             b r1,a                                  ; is action too small?, copy buffer pointer
        ble             <abort_action                   ; if so, abort
        cmp             #LDR_ACT_MAX,b                  ; is action too big?
        bgt             <abort_action                   ; if so, abort
        tst             a n0,a                                  ; is the buffer allocated?      get length
        beq             <abort_alloc                    ; if not, abort
;       move    n0,a                                    ; get length (no longer needed, done above)
        tst             a a1,x0                                 ; is length valid?
        ble             <abort_length                   ; if not, abort
        move    n1,a                                    ; get offset
        tst             a                                               ; is offset valid?
        blt             <abort_length                   ; if not, abort
        add             x0,a                                    ; add together
        move    p:(r2)+,x0                              ; get buffer size
        cmp             x0,a                                    ; check for overflow
        bgt             <abort_length                   ; if so, abort
        ENDIF

        move    b1,n4                                   ; set up table index
        move    #heap_jmptbl-1,r4               ; set up jump table base
        move    (r1)+n1                                 ; adjust pointer
        move    p:(r4+n4),r6                    ; get jump address
        jsr             (r6)                                    ; call handler routine
        bra             <done

;***********************************************************************
;       Heap allocation code
;               Allocates new data buffer from heap
;               Uses input length, ignores other parameters
;               Checks for following errors:
;                       Buffer already allocated
;                       Requested length <= 0
;                       Heap underflow

alloc_heap:
        IF              @DEF('ERRCHK')
        move    r1,a                                    ; copy buffer pointer
        tst             a n0,b                                  ; is the buffer allocated?, copy length
        bne             <abort_alloc                    ; if so, abort
        tst             b                                               ; is the length valid?
        ble             <abort_alloc                    ; if not, abort
        ELSE
        move    n0,b                                    ; copy length
        ENDIF

        move    p:ldr_heap_size,a               ; get current heap size
        move    p:ldr_heap_ptr,x0               ; get current heap pointer
        sub             b,a                                             ; update heap size
        blt             <abort_alloc                    ; if underflow, abort
        add             x0,b (r2)-                              ; update heap pointer, back up table ptr
        move    x0,p:(r2)+                              ; save buffer pointer to loader table
        move    n0,p:(r2)+                              ; save buffer size to loader table
        move    a1,p:ldr_heap_size              ; save heap size
        move    b1,p:ldr_heap_ptr               ; save heap pointer

;***********************************************************************
;       Exit points

done:

        clr             a                                               ; no error status
        rts

abort_alloc:
        move    #>LDR_ERR_ALLOC,a               ; set up error status
        rts
        IF              @DEF('ERRCHK')
abort_id:
        move    #>LDR_ERR_ID,a                  ; set up error status
        rts
abort_action:
        move    #>LDR_ERR_ACTION,a              ; set up error status
        rts
abort_length:
        move    #>LDR_ERR_LENGTH,a              ; set up error status
        rts
        ENDIF
                                                                                                  
;***********************************************************************
;       Loader initialization code
;               Copies loader table from system memory to DSP memory
;               Clears dynamic table entries
;               Initializes local heap variables

loader_init:
; Note: we no longer need to copy the loader table, since the RM prepositions
;       it in system memory so that it is automatically loaded by the DSP
;       bootstrap.
;       move    #LdrTable,r0                            ; point to loader table
;       move    #LDR_SYSTABLE_SIZE,n0                   ; set up length
;       move    #SYSMEMTABLEBASE,r1                     ; point to SysMem loader table
;       bsr             <CopySysToDSPP                  ; copy loader table
        move    p:LdrTable+LDR_HEAP_ADDR,x0             ; get heap address
        move    x0,p:ldr_heap_ptr                       ; save to local memory
        move    p:LdrTable+LDR_HEAP_SIZE,x0             ; get heap size
        move    x0,p:ldr_heap_size                      ; save to local memory
        clr     a #LdrTable+LDR_HEAP_ADDR,r0            ; set up pointer
        dor     #LDR_NUM_DATA*2,clrlp
        move    a,p:(r0)+                                               ; clear table value
clrlp:


        bsr     DMAInit                                 ; one-time DMA initialization
        
        bra     <done                                   ; exit

;******************************************************************************
;*                                                                                
;*   Subroutine Name:   CopySysToDSPX
;*                                                                
;*   Description:       Copy from System Memory to DSP x: space
;*                                                                                    
;*   Input:             r0      - DSP address (x:)
;*                      n0      - number of words to copy
;*                      r1      - System Memory address
;*                                                                                    
;******************************************************************************

CopySysToDSPX:
        IF              @DEF('RTSYS')
        jsr             set_timing
        ENDIF

; Note: Dolby-only testing code
;       dor             n0,systoxlp
;       move    x:(r1)+,x0
;       move    x0,x:(r0)+
;systoxlp:

        move    #dmaNode,r4                     ; r4 <- address of dma node
        
        move    r0,a1
        add     #kEPMemory_Base_XRAM,a          ; adjust DSP address for X base
        move    a1,r0
        
        jsr     DMANewNode_Read                 ; create DMA node
        
        jsr     DMAStartNodeP_Wait              ; initiate DMA 
                                                ; (and wait for completion)

        IF              @DEF('RTSYS')
        jsr             clr_timing
        ENDIF
        rts

;******************************************************************************
;*                                                                                
;*   Subroutine Name:   CopyDSPXToSys
;*                                                                
;*   Description:       Copy from DSP x: space to System Memory
;*                                                                                    
;*   Input:             r0      - DSP address (x:)
;*                      n0      - number of words to copy
;*                      r1      - System Memory address
;*                                                                                    
;******************************************************************************

CopyDSPXToSys:
        IF              @DEF('RTSYS')
        jsr             set_timing
        ENDIF
        
; Note: Dolby-only testing code
;       dor             n0,xtosyslp
;       move    x:(r0)+,x0
;       move    x0,x:(r1)+
;xtosyslp:

        move    #dmaNode,r4                     ; r4 <- address of dma node
        
        move    r0,a1
        add     #kEPMemory_Base_XRAM,a          ; adjust DSP address for X base
        move    a1,r0
        
        jsr     DMANewNode_Write                ; create DMA node
        
        jsr     DMAStartNodeP_Wait              ; initiate DMA 
                                                ; (and wait for completion)
        
        IF              @DEF('RTSYS')
        jsr             clr_timing
        ENDIF
        rts

;******************************************************************************
;*                                                                                
;*   Subroutine Name:   CopyDSPXToFIFO
;*                                                                
;*   Description:       Copy from DSP x: space to FIFO
;*                                                                            
;*   Input:             r0      - DSP address (x:)
;*                      n0      - number of words to copy
;*                      r1      - FIFO index
;*                      n2  - (Channels -1) to interleave
;*                      n4  - Flag indicating NULL ouput
;*                                                                                    
;******************************************************************************

CopyDSPXToFIFO:

        move    #dmaNode,r4                     ; r4 <- address of dma node
        
        move    r0,a1
        add     #kEPMemory_Base_XRAM,a          ; adjust DSP address for X base
        move    a1,r0
        
        move    n2,a
        cmp             #0,a
        bne             CopyDSPXToFIFO_Interleaved
        jsr         DMANewNode_WriteFIFO                ; create DMA node
        bra             CopyDSPXToFIFOStart

CopyDSPXToFIFO_Interleaved:     
        jsr         DMANewNode_WriteFIFOInterleaved             ; create DMA node

CopyDSPXToFIFOStart:
        jsr         DMAStartNodeP_Wait          ; initiate DMA 
                                                ; (and wait for completion)
        
        rts

;******************************************************************************
;*                                                                                
;*   Subroutine Name:   CopySysToDSPY
;*                                                                
;*   Description:       Copy from System Memory to DSP y: space
;*                                                                            
;*   Input:             r0      - DSP address (y:)
;*                      n0      - number of words to copy
;*                      r1      - System Memory address
;*                                                                                    
;******************************************************************************

CopySysToDSPY:

; Note: Dolby-only testing code
;       dor             n0,systoylp
;       move    x:(r1)+,x0
;       move    x0,y:(r0)+
;systoylp:

        move    #dmaNode,r4                     ; r4 <- address of dma node
        
        move    r0,a1
        add     #kEPMemory_Base_YRAM,a          ; adjust DSP address for Y base
        move    a1,r0
        
        jsr     DMANewNode_Read                 ; create DMA node
        
        jsr     DMAStartNodeP_Wait              ; initiate DMA 
                                                ; (and wait for completion)

        rts

;******************************************************************************
;*                                                                                
;*   Subroutine Name:   CopyDSPYToSys
;*                                                                
;*   Description:       Copy from DSP y: space to System Memory
;*                                                                                    
;*   Input:             r0      - DSP address (y:)
;*                      n0      - number of words to copy
;*                      r1      - System Memory address
;*                                                                                    
;******************************************************************************

CopyDSPYToSys:

; Note: Dolby-only testing code
;       dor             n0,ytosyslp
;       move    y:(r0)+,x0
;       move    x0,x:(r1)+
;ytosyslp:


        move    #dmaNode,r4                     ; r4 <- address of dma node
        
        move    r0,a1
        add     #kEPMemory_Base_YRAM,a          ; adjust DSP address for Y base
        move    a1,r0
        
        jsr     DMANewNode_Write                ; create DMA node
        
        jsr     DMAStartNodeP_Wait              ; initiate DMA 
                                                ; (and wait for completion)

        rts

;******************************************************************************
;*                                                                                
;*   Subroutine Name:   CopySysToDSPP
;*                                                                
;*   Description:       Copy from System Memory to DSP p: space
;*                                                                                    
;*   Input:             r0      - DSP address (p:)
;*                      n0      - number of words to copy
;*                      r1      - System Memory address
;*                                                                                    
;******************************************************************************

CopySysToDSPP:

; Note: Dolby-only testing code
;       dor             n0,systoplp
;       move    x:(r1)+,x0
;       move    x0,p:(r0)+
;       nop
;systoplp:

        move    #dmaNode,r4                     ; r4 <- address of dma node
        
        move    r0,a1
        add     #kEPMemory_Base_PRAM,a          ; adjust DSP address for Y base
        move    a1,r0
        
        jsr     DMANewNode_Read                 ; create DMA node
        
        jsr     DMAStartNodeP_Wait              ; initiate DMA 
                                                ; (and wait for completion)

        rts

;******************************************************************************
;*                                                                                
;*   Subroutine Name:   CopyDSPPToSys
;*                                                                
;*   Description:       Copy from DSP p: space to System Memory
;*                                                                                    
;*   Input:             r0      - DSP address (p:)
;*                      n0      - number of words to copy
;*                      r1      - System Memory address
;*                                                                                    
;******************************************************************************

CopyDSPPToSys:
        
; Note: Dolby-only testing code
;       dor             n0,ptosyslp
;       move    p:(r0)+,x0
;       move    x0,x:(r1)+
;ptosyslp:

        move    #dmaNode,r4                     ; r4 <- address of dma node
        
        move    r0,a1
        add     #kEPMemory_Base_PRAM,a          ; adjust DSP address for Y base
        move    a1,r0
        
        jsr     DMANewNode_Write                ; create DMA node
        
        jsr     DMAStartNodeP_Wait              ; initiate DMA 
                                                ; (and wait for completion)
        rts
        
        
;************************************************************
; DMANewNode_Read
;
;       This DMA Read node is configured for the System
;       Memory -> DSP transfer
;       This node is also set up to be the last node in
;       the list, so it is self-linked with the EndOfList
;       bit set
;
;       Parameters:     r4      node DSP PRAM address
;                       r0      DSP Memory address
;                       r1      System Memory address
;           n0      Length
;************************************************************
DMANewNode_Read

        jsr     DMAWaitForIdle                      ; Wait fro DMA to be idle

; Word0
        move    r4,r5                   ; r5 <- copy of node base 
        
        move    r4,a1
        and             #>kDMANode_EOLMask,a    ; Clear reserved upper bits
        or              #>kDMANode_EOL,a        ; set EOL bit
        
    movem   a1,p:(r5)+          ; Link to itself                        
; Word1
    move    #>DMA_BASE_READ1_ISO,a1
    ;move    #>DMA_BASE_READ1,a1
        movem   a1,p:(r5)+
; Word2
        movem   n0,p:(r5)+              ; Length        
; Word3
        movem   r0,p:(r5)+              ; DSP RAM address (System memory space) 
; Word4                                         
        move    r1,a
        lsl             #2,a                                    
        movem   a1,p:(r5)+              ; System memory address


        rts
; ---- end DMANewNode_Read


;************************************************************
; DMANewNode_Write      
;
;       This DMA Write node is configured for the DSP -> SM
;       transfer 
;       This node is also set up to be the last node in
;       the list, so it is self-linked with the EndOfList
;       bit set
;
;       Parameters:     r4      node DSP PRAM address
;                       r0      DSP Memory address 
;                       r1      System Memory address
;                       n0      Length
;************************************************************
DMANewNode_Write        

        jsr     DMAWaitForIdle                      ; Wait fro DMA to be idle

; Word0
        move    r4,r5                   ; r5 <- copy of node base 
        
        move    r4,a1
        and             #>kDMANode_EOLMask,a    ; Clear reserved upper bits
        or              #>kDMANode_EOL,a        ; set EOL bit
        
; Word0
        move    a1,p:(r5)+              ; Link to itself                        

; Word1
        move    #>DMA_BASE_WRITE1_ISO,a1
        ;move    #>DMA_BASE_WRITE1,a1
        movem   a1,p:(r5)+                      
; Word2
        movem   n0,p:(r5)+              ; Length
; Word3
        movem   r0,p:(r5)+              ; DSP RAM address (System memory space) 
; Word4 
        move    r1,a
        lsl             #2,a                                    
        movem   a1,p:(r5)+              ; System memory address

        rts
; ---- end DMANewNode_Write ----

;************************************************************
; DMANewNode_WriteFIFO
;
;       This DMA Write node is configured for the DSP -> FIFO
;       transfer 
;       This node is also set up to be the last node in
;       the list, so it is self-linked with the EndOfList
;       bit set
;
;       Parameters:     r4      node DSP PRAM address
;                       r0      DSP Memory address 
;                       r1      FIFO number
;                       n0      Length
;                       n4  NULL output flag
;************************************************************
DMANewNode_WriteFIFO

        jsr     DMAWaitForIdle                      ; Wait fro DMA to be idle

; Word0
        move    r4,r5                   ; r5 <- copy of node base 
        
        move    r4,a1
        and             #>kDMANode_EOLMask,a    ; Clear reserved upper bits
        or              #>kDMANode_EOL,a        ; Set EOL bit
        
        move    a1,p:(r5)+              ; Link to itself                        

; Word1
    move    #>DMA_BASE_WRITEFIFO1_ISO,a1        ; start with "write to FIFO/16-bit" control word
    ;move    #>DMA_BASE_WRITEFIFO1,a1
        move    r1,b                    ; FIFO index from r1
    lsl     #5,b                        ; shift FIFO index smBufId bits
        move    b,x1
        or          x1,a                        ; put FIFO index into control word
        movem   a1,p:(r5)+              ; write control word
; Word2
        movem   n0,p:(r5)+                      
; Word3
        move    n4,a                    ; Null Flag
    lsl     #14,a
        move    r0,x0
        add             x0,a                    ; Add DSP Address
        movem   a1,p:(r5)+              ; DSP RAM address (System memory space) 
; Word4 is no longer used

        rts
; ---- end DMANewNode_WriteFIFO ----


;************************************************************
; DMANewNode_WriteFIFOInterleaved
;
;       This DMA Write node is configured for the DSP -> FIFO
;       transfer 
;       This node is also set up to be the last node in
;       the list, so it is self-linked with the EndOfList
;       bit set
;
;       Parameters:     r4      node DSP PRAM address
;                       r0      DSP Memory address 
;                       r1      FIFO number
;                       n0      Length
;                       n2  Channels per block
;                       n4  NULL output flag
;************************************************************
DMANewNode_WriteFIFOInterleaved

        jsr     DMAWaitForIdle                      ; Wait fro DMA to be idle

; Word0
        move    r4,r5                   ; r5 <- copy of node base 
        
        move    r4,a1
        and     #>kDMANode_EOLMask,a    ; Clear reserved upper bits
        or              #>kDMANode_EOL,a        ; Set EOL bit
        move    a1,p:(r5)+              ; Link to itself                        

; Word1
    move    #>DMA_BASE_WRITEFIFO2_ISO,a1        ; start with "write to FIFO/16-bit interleaved" control word
    ;move    #>DMA_BASE_WRITEFIFO2,a1
        move    r1,b                    ; FIFO index from r1
    lsl     #5,b                        ; shift FIFO index smBufId bits
        move    b,x1
        or          x1,a                        ; put FIFO index into control word

        move    n0,b                    ; Set Incr value
    lsl     #14,b                       ; shift incr value bits (Increment by size of a single channel buffer)
        move    b,x1
        or          x1,a                        ; put FIFO index into control word
        movem   a1,p:(r5)+              ; write control word
; Word2
        move    n0,b                    ; Set Length value
    lsl     #4,b                        ; shift Length bits (Increment by size of a single channel buffer)
        move    n2,x1
        add             x1,b                    ; Add samples per block
        movem   b1,p:(r5)+              ; write control word
; Word3
        move    n4,a                    ; Null Flag
    lsl     #14,a
        move    r0,x0
        add             x0,a                    ; Add DSP Address
        movem   a1,p:(r5)+              ; DSP RAM address (System memory space) 
; Word4 is no longer used

        rts
; ---- end DMANewNode_WriteFIFO ----





;************************************************************
; DMAWaitForStop        
;
;               Alters DMA Running state 
;************************************************************
DMAWaitForIdle 


; Wait for DMA engine to enter Idle state: 0 = Idle, 1 = Running
        jset    #kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAWaitForIdle

; Clear DMA EndofList, Bit 7
        movep    #$80,x:INTERRUPT_REGISTER      ; "Write-1-To-Clear-One" 

        rts
; ---- end DMAStopAndFreeze ----

;************************************************************
; DMAStart
;
;               Alters DMA Running state 
;************************************************************
DMAStart 


; Write "run" command
    movep    #>kDMA_ActionRequest_Start,x:DMA_CONTROL_REGISTER  

; Wait for DMA engine to enter Running state: 0 = Idle, 1 = Running
DMAUnFreezeAndStart_WaitForStart
;       jset    #kDMAErrorBit,x:INTERRUPT_REGISTER,DMAError
        jclr    #kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAUnFreezeAndStart_WaitForStart

        rts
; ---- end DMAUnFreezeAndStart ----

;************************************************************
; DMAWaitForEOL         Wait for DMA EOL interrupt and clear register bit
;************************************************************
DMAWaitForEOL 

; Poll for DMA EOL interrupt
DMAWaitForEOL_Poll
        jset    #kDMAErrorBit,x:INTERRUPT_REGISTER,DMAError
        jclr    #kDMAEndOfListBit,x:INTERRUPT_REGISTER,DMAWaitForEOL_Poll

; Clear DMA EndofList, Bit 7
        movep    #$80,x:INTERRUPT_REGISTER      ; "Write-1-To-Clear-One" 

    ;debug_wait


        rts
; ---- end DMAWaitForEOL ----

;************************************************************
; DMAStartNodeP_Wait    
;
;       Replace start block, initiate transfer and Wait for
;                               completion
;
;       This function assumes a single DMA node that is
;       setup as the EOL block.
;
;       Parameters:      r4     next node DSP PRAM address
;************************************************************
DMAStartNodeP_Wait 
        
        move    r4,a
        add             #kEPMemory_Base_PRAM,a                  ; block is in PRAM 
        movep   a,x:DMA_NEXT_BLOCK_CONTROL_REGISTER
        
        jsr     DMAStart                                ; Start transfer
        
    clr     b
    move    n5,b
    cmp     #0,b
    beq     DMAStartNodeP_NoWait

        jsr     DMAWaitForEOL                           ; Wait for completion

DMAStartNodeP_NoWait
        rts
; ---- end DMAStartNodeX_Wait ----


;******************************************************************************
;*
;*   Subroutine Name:   DMAInit             
;*
;*   Description:               Inits the EP for DMA (based on Gints' GP code)
;*
;******************************************************************************
;
;

DMAInit:
        ;GPClearInterruptRegister
        movep    #$FFF,x:INTERRUPT_REGISTER      ; "Write-1-To-Clear-One"
        
        ;GPClearProcessingControlRegister
        movep    #$1,x:PROCESSING_CONTROL_REGISTER       ; "Set Idle bit"       

        ;GPClearSampleControlRegister
        movep    #$0,x:SAMPLE_CONTROL_REGISTER   
        
        ;abort any DMA transfers
;    movep    #>kDMA_ActionRequest_Abort,x:DMA_CONTROL_REGISTER

    move    #$4000,x0   
        move    x0,x:DMA_START_BLOCK_CONTROL_REGISTER
        move    x0,x:DMA_NEXT_BLOCK_CONTROL_REGISTER

        ;GPClearDMAConfigRegister 
        movep    #>0,x:DMA_CONFIGURATION_REGISTER

        rts


DMAError
        bra     DMAError




;** Loader Status

;status_active  dc      0
;status_ID              dc      -1
;status_action  dc      -1
;status_dspaddr dc      -1
;status_length  dc      -1
;status_sysaddr dc      -1
;status_wait            dc      0

        endsec
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\lleyrom.asm ===
dc	$80B652
	dc	$7E94D5
	dc	$081251
	dc	$F7EE67
	dc	$081251
	dc	$805361
	dc	$7F6007
	dc	$1C8662
	dc	$E37CFE
	dc	$1C8662
	dc	$808C65
	dc	$7EEB1C
	dc	$010B74
	dc	$FEF67B
	dc	$010B74
	dc	$801DB0
	dc	$7FCD25
	dc	$1142D5
	dc	$EEC16A
	dc	$1142D5
	dc	$FFD43D
	dc	$119829
	dc	$26DA06
	dc	$21C64D
	dc	$26DA06
	dc	$159B58
	dc	$55B759
	dc	$605766
	dc	$201F9E
	dc	$605766
	dc	$1FA4D2
	dc	$774339
	dc	$687FE3
	dc	$30FF87
	dc	$687FE3
	dc	$0B0E75
	dc	$1251AB
	dc	$35486E
	dc	$1EEEDC
	dc	$35486E
	dc	$251CD5
	dc	$57319E
	dc	$4C080D
	dc	$449C2A
	dc	$4C080D
	dc	$30C7F7
	dc	$77ADA6
	dc	$74AE92
	dc	$360AEE
	dc	$74AE92
	dc	$16C3AB
	dc	$14ACB7
	dc	$39D4BB
	dc	$27454B
	dc	$39D4BB
	dc	$3441F9
	dc	$5978D5
	dc	$536EAE
	dc	$4D7C52
	dc	$536EAE
	dc	$40ECCE
	dc	$7843E0
	dc	$763244
	dc	$44C8FA
	dc	$763244
	dc	$230D4D
	dc	$18EE97
	dc	$420FC8
	dc	$2D74D1
	dc	$420FC8
	dc	$42D5AD
	dc	$5C8EC1
	dc	$5AD851
	dc	$5644BD
	dc	$5AD851
	dc	$4FC627
	dc	$7902EE
	dc	$72771E
	dc	$5779E0
	dc	$72771E
	dc	$300690
	dc	$1F7818
	dc	$47C4B6
	dc	$37FDE7
	dc	$47C4B6
	dc	$509D22
	dc	$6073ED
	dc	$6215CE
	dc	$5EC14B
	dc	$6215CE
	dc	$5D0C75
	dc	$79E730
	dc	$756077
	dc	$6220C1
	dc	$756077
	dc	$3DCBB1
	dc	$28CEA4
	dc	$4D2AF1
	dc	$450812
	dc	$4D2AF1
	dc	$5D56F0
	dc	$6526DF
	dc	$6906E1
	dc	$66CA75
	dc	$6906E1
	dc	$687E85
	dc	$7AEC6C
	dc	$7A76E9
	dc	$68F757
	dc	$7A76E9
	dc	$4C781F
	dc	$35A91E
	dc	$5738EF
	dc	$5013BE
	dc	$5738EF
	dc	$68BA93
	dc	$6AA314
	dc	$6FAFD0
	dc	$6E5C4D
	dc	$6FAFD0
	dc	$71E246
	dc	$7C0DD3
	dc	$7A3EE3
	dc	$72EB44
	dc	$7A3EE3
	dc	$5C2288
	dc	$4701E7
	dc	$612530
	dc	$5E7E4C
	dc	$612530
	dc	$72788D
	dc	$70DFBD
	dc	$75B679
	dc	$7515A8
	dc	$75B679
	dc	$790593
	dc	$7D4612
	dc	$7CCFFF
	dc	$78205F
	dc	$7CCFFF
	dc	$6CD503
	dc	$5E2F5B
	dc	$6E5E78
	dc	$6D8E38
	dc	$6E5E78
	dc	$7A3B64
	dc	$77CE50
	dc	$7B18F9
	dc	$7AEBEE
	dc	$7B18F9
	dc	$7DBF1C
	dc	$7E8F57
	dc	$7DC387
	dc	$7C7BEB
	dc	$7DC387
	dc	$52680A
	dc	$3D2546
	dc	$27E5C9
	dc	$12A305
	dc	$47C84B
	dc	$328588
	dc	$1D42C4
	dc	$CD7DE9
	dc	$17E153
	dc	$2CD213
	dc	$D36808
	dc	$2CD213
	dc	$BF3A00
	dc	$47D461
	dc	$3B1618
	dc	$C6A2F1
	dc	$3B1618
	dc	$0CCCCD
	dc	$09999A
	dc	$066666
	dc	$333333
	dc	$200000
	dc	$133333
	dc	$000475
	dc	$0007FE
	dc	$000C02
	dc	$0010A3
	dc	$0015F5
	dc	$001C08
	dc	$0022ED
	dc	$002AB5
	dc	$003371
	dc	$003D32
	dc	$00480A
	dc	$00540D
	dc	$00614B
	dc	$006FDA
	dc	$007FCD
	dc	$009138
	dc	$00A431
	dc	$00B8CC
	dc	$00CF1F
	dc	$00E741
	dc	$010148
	dc	$011D4B
	dc	$013B61
	dc	$015BA2
	dc	$017E25
	dc	$01A302
	dc	$01CA51
	dc	$01F42C
	dc	$0220A9
	dc	$024FE2
	dc	$0281F0
	dc	$02B6EA
	dc	$02EEE9
	dc	$032A07
	dc	$03685A
	dc	$03A9FC
	dc	$03EF04
	dc	$04378A
	dc	$0483A5
	dc	$04D36D
	dc	$0526F7
	dc	$057E5B
	dc	$05D9AE
	dc	$063904
	dc	$069C74
	dc	$070410
	dc	$076FEB
	dc	$07E01A
	dc	$0854AC
	dc	$08CDB3
	dc	$094B40
	dc	$09CD61
	dc	$0A5425
	dc	$0ADF98
	dc	$0B6FC8
	dc	$0C04BF
	dc	$0C9E87
	dc	$0D3D2A
	dc	$0DE0AE
	dc	$0E891A
	dc	$0F3674
	dc	$0FE8C0
	dc	$109FFF
	dc	$115C34
	dc	$121D5D
	dc	$12E37B
	dc	$13AE89
	dc	$147E84
	dc	$155366
	dc	$162D27
	dc	$170BBF
	dc	$17EF23
	dc	$18D748
	dc	$19C421
	dc	$1AB59F
	dc	$1BABB2
	dc	$1CA648
	dc	$1DA54F
	dc	$1EA8B0
	dc	$1FB058
	dc	$20BC2D
	dc	$21CC18
	dc	$22DFFD
	dc	$23F7C2
	dc	$251348
	dc	$263272
	dc	$275520
	dc	$287B31
	dc	$29A482
	dc	$2AD0F1
	dc	$2C0059
	dc	$2D3294
	dc	$2E677C
	dc	$2F9EE8
	dc	$30D8B1
	dc	$3214AC
	dc	$3352B0
	dc	$349290
	dc	$35D422
	dc	$371738
	dc	$385BA5
	dc	$39A13B
	dc	$3AE7CC
	dc	$3C2F2A
	dc	$3D7725
	dc	$3EBF8D
	dc	$400834
	dc	$4150E9
	dc	$42997D
	dc	$43E1C0
	dc	$452981
	dc	$467092
	dc	$47B6C3
	dc	$48FBE3
	dc	$4A3FC6
	dc	$4B823B
	dc	$4CC316
	dc	$4E0228
	dc	$4F3F45
	dc	$507A40
	dc	$51B2EF
	dc	$52E925
	dc	$541CBA
	dc	$554D85
	dc	$567B5E
	dc	$57A61D
	dc	$58CD9E
	dc	$59F1BB
	dc	$5B1252
	dc	$5C2F3F
	dc	$5D4863
	dc	$5E5D9D
	dc	$5F6ED0
	dc	$607BDE
	dc	$6184AD
	dc	$628923
	dc	$638927
	dc	$6484A3
	dc	$657B81
	dc	$666DAF
	dc	$675B19
	dc	$6843B1
	dc	$692767
	dc	$6A062D
	dc	$6ADFF9
	dc	$6BB4C2
	dc	$6C847D
	dc	$6D4F27
	dc	$6E14B8
	dc	$6ED52F
	dc	$6F9089
	dc	$7046C6
	dc	$70F7E9
	dc	$71A3F3
	dc	$724AEA
	dc	$72ECD3
	dc	$7389B6
	dc	$74219D
	dc	$74B490
	dc	$75429B
	dc	$75CBCC
	dc	$765031
	dc	$76CFD8
	dc	$774AD3
	dc	$77C132
	dc	$783308
	dc	$78A068
	dc	$790968
	dc	$796E1C
	dc	$79CE9A
	dc	$7A2AF9
	dc	$7A8350
	dc	$7AD7B8
	dc	$7B2849
	dc	$7B751D
	dc	$7BBE4C
	dc	$7C03F1
	dc	$7C4625
	dc	$7C8504
	dc	$7CC0A8
	dc	$7CF92C
	dc	$7D2EAA
	dc	$7D613E
	dc	$7D9101
	dc	$7DBE10
	dc	$7DE883
	dc	$7E1076
	dc	$7E3603
	dc	$7E5943
	dc	$7E7A4F
	dc	$7E9942
	dc	$7EB633
	dc	$7ED13A
	dc	$7EEA6F
	dc	$7F01EA
	dc	$7F17C0
	dc	$7F2C08
	dc	$7F3ED7
	dc	$7F5043
	dc	$7F605E
	dc	$7F6F3C
	dc	$7F7CF1
	dc	$7F898E
	dc	$7F9525
	dc	$7F9FC6
	dc	$7FA982
	dc	$7FB268
	dc	$7FBA86
	dc	$7FC1EB
	dc	$7FC8A4
	dc	$7FCEBE
	dc	$7FD443
	dc	$7FD941
	dc	$7FDDC2
	dc	$7FE1CF
	dc	$7FE572
	dc	$7FE8B4
	dc	$7FEB9E
	dc	$7FEE36
	dc	$7FF086
	dc	$7FF293
	dc	$7FF463
	dc	$7FF5FD
	dc	$7FF765
	dc	$7FF8A1
	dc	$7FF9B6
	dc	$7FFAA7
	dc	$7FFB79
	dc	$7FFC2F
	dc	$7FFCCB
	dc	$7FFD52
	dc	$7FFDC6
	dc	$7FFE28
	dc	$7FFE7B
	dc	$7FFEC2
	dc	$7FFEFD
	dc	$7FFF2F
	dc	$7FFF58
	dc	$7FFF7B
	dc	$7FFF97
	dc	$7FFFAE
	dc	$7FFFC0
	dc	$7FFFCF
	dc	$7FFFDB
	dc	$7FFFE4
	dc	$7FFFEC
	dc	$7FFFF1
	dc	$7FFFF6
	dc	$7FFFF9
	dc	$7FFFFB
	dc	$7FFFFD
	dc	$7FFFFE
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$80000A
	dc	$80031F
	dc	$800B24
	dc	$801818
	dc	$8029FA
	dc	$8040C9
	dc	$805C86
	dc	$807D2E
	dc	$80A2C1
	dc	$80CD3C
	dc	$80FC9F
	dc	$8130E8
	dc	$816A14
	dc	$81A821
	dc	$81EB0E
	dc	$8232D6
	dc	$827F79
	dc	$82D0F2
	dc	$83273E
	dc	$83825B
	dc	$83E244
	dc	$8446F7
	dc	$84B06E
	dc	$851EA6
	dc	$85919B
	dc	$860949
	dc	$8685AA
	dc	$8706BA
	dc	$878C74
	dc	$8816D3
	dc	$88A5D1
	dc	$89396A
	dc	$89D196
	dc	$8A6E51
	dc	$8B0F94
	dc	$8BB55A
	dc	$8C5F9B
	dc	$8D0E51
	dc	$8DC176
	dc	$8E7902
	dc	$8F34EF
	dc	$8FF535
	dc	$90B9CC
	dc	$9182AE
	dc	$924FD3
	dc	$932132
	dc	$93F6C3
	dc	$94D07F
	dc	$95AE5D
	dc	$969054
	dc	$97765B
	dc	$98606A
	dc	$994E78
	dc	$9A407C
	dc	$9B366B
	dc	$9C303E
	dc	$9D2DE9
	dc	$9E2F64
	dc	$9F34A4
	dc	$A03DA0
	dc	$A14A4C
	dc	$A25AA0
	dc	$A36E8F
	dc	$A48610
	dc	$A5A118
	dc	$A6BF9C
	dc	$A7E191
	dc	$A906EC
	dc	$AA2FA0
	dc	$AB5BA4
	dc	$AC8AEB
	dc	$ADBD6A
	dc	$AEF315
	dc	$B02BDF
	dc	$B167BE
	dc	$B2A6A4
	dc	$B3E886
	dc	$B52D56
	dc	$B67509
	dc	$B7BF92
	dc	$B90CE4
	dc	$BA5CF2
	dc	$BBAFB0
	dc	$BD050F
	dc	$BE5D04
	dc	$BFB780
	dc	$C11477
	dc	$C273DB
	dc	$C3D59F
	dc	$C539B4
	dc	$C6A00D
	dc	$C8089D
	dc	$C97355
	dc	$CAE027
	dc	$CC4F05
	dc	$CDBFE2
	dc	$CF32AF
	dc	$D0A75D
	dc	$D21DDF
	dc	$D39625
	dc	$D51022
	dc	$D68BC7
	dc	$D80904
	dc	$D987CD
	dc	$DB0810
	dc	$DC89C1
	dc	$DE0CD0
	dc	$DF912D
	dc	$E116CB
	dc	$E29D9A
	dc	$E4258B
	dc	$E5AE8F
	dc	$E73896
	dc	$E8C392
	dc	$EA4F74
	dc	$EBDC2B
	dc	$ED69AA
	dc	$EEF7DF
	dc	$F086BD
	dc	$F21634
	dc	$F3A634
	dc	$F536AD
	dc	$F6C792
	dc	$F858D1
	dc	$F9EA5B
	dc	$FB7C22
	dc	$FD0E16
	dc	$FEA026
	dc	$FFCDBC
	dc	$FE3BA0
	dc	$FCA995
	dc	$FB17AC
	dc	$F985F3
	dc	$F7F479
	dc	$F6634F
	dc	$F4D284
	dc	$F34228
	dc	$F1B249
	dc	$F022F7
	dc	$EE9442
	dc	$ED0638
	dc	$EB78EA
	dc	$E9EC67
	dc	$E860BD
	dc	$E6D5FD
	dc	$E54C35
	dc	$E3C374
	dc	$E23BCB
	dc	$E0B547
	dc	$DF2FF7
	dc	$DDABEC
	dc	$DC2933
	dc	$DAA7DD
	dc	$D927F6
	dc	$D7A98F
	dc	$D62CB7
	dc	$D4B17B
	dc	$D337EA
	dc	$D1C013
	dc	$D04A05
	dc	$CED5CE
	dc	$CD637C
	dc	$CBF31D
	dc	$CA84C1
	dc	$C91874
	dc	$C7AE45
	dc	$C64641
	dc	$C4E078
	dc	$C37CF6
	dc	$C21BC9
	dc	$C0BCFF
	dc	$BF60A5
	dc	$BE06C9
	dc	$BCAF79
	dc	$BB5AC0
	dc	$BA08AE
	dc	$B8B94D
	dc	$B76CAC
	dc	$B622D8
	dc	$B4DBDC
	dc	$B397C6
	dc	$B256A2
	dc	$B1187D
	dc	$AFDD62
	dc	$AEA55F
	dc	$AD707E
	dc	$AC3ECC
	dc	$AB1054
	dc	$A9E523
	dc	$A8BD44
	dc	$A798C2
	dc	$A677A8
	dc	$A55A02
	dc	$A43FDB
	dc	$A3293D
	dc	$A21634
	dc	$A106C9
	dc	$9FFB08
	dc	$9EF2FA
	dc	$9DEEAB
	dc	$9CEE23
	dc	$9BF16C
	dc	$9AF892
	dc	$9A039C
	dc	$991295
	dc	$982586
	dc	$973C78
	dc	$965774
	dc	$957683
	dc	$9499AD
	dc	$93C0FB
	dc	$92EC75
	dc	$921C24
	dc	$91500F
	dc	$90883F
	dc	$8FC4BB
	dc	$8F058B
	dc	$8E4AB6
	dc	$8D9443
	dc	$8CE239
	dc	$8C349F
	dc	$8B8B7D
	dc	$8AE6D7
	dc	$8A46B5
	dc	$89AB1E
	dc	$891416
	dc	$8881A3
	dc	$87F3CC
	dc	$876A96
	dc	$86E606
	dc	$866621
	dc	$85EAED
	dc	$85746D
	dc	$8502A6
	dc	$84959E
	dc	$842D57
	dc	$83C9D7
	dc	$836B20
	dc	$831138
	dc	$82BC20
	dc	$826BDC
	dc	$822070
	dc	$81D9DE
	dc	$819829
	dc	$815B54
	dc	$812360
	dc	$80F051
	dc	$80C228
	dc	$8098E6
	dc	$80748E
	dc	$805521
	dc	$803A9F
	dc	$80250B
	dc	$801464
	dc	$8008AD
	dc	$8001E4
	dc	$800027
	dc	$800C7E
	dc	$802C8F
	dc	$806056
	dc	$80A7CB
	dc	$8102E4
	dc	$817191
	dc	$81F3C3
	dc	$828964
	dc	$83325F
	dc	$83EE98
	dc	$84BDF3
	dc	$85A04F
	dc	$86958B
	dc	$879D7F
	dc	$88B804
	dc	$89E4EE
	dc	$8B240E
	dc	$8C7533
	dc	$8DD82A
	dc	$8F4CBB
	dc	$90D2AD
	dc	$9269C4
	dc	$9411C1
	dc	$95CA62
	dc	$979365
	dc	$996C81
	dc	$9B5570
	dc	$9D4DE4
	dc	$9F5590
	dc	$A16C24
	dc	$A3914E
	dc	$A5C4B8
	dc	$A8060D
	dc	$AA54F3
	dc	$ACB10E
	dc	$AF1A03
	dc	$B18F70
	dc	$B410F7
	dc	$B69E33
	dc	$B936C0
	dc	$BBDA37
	dc	$BE8830
	dc	$C14042
	dc	$C40201
	dc	$C6CD00
	dc	$C9A0D2
	dc	$CC7D05
	dc	$CF612B
	dc	$D24CCF
	dc	$D53F80
	dc	$D838C8
	dc	$DB3833
	dc	$DE3D49
	dc	$E14795
	dc	$E4569D
	dc	$E769E9
	dc	$EA80FF
	dc	$ED9B67
	dc	$F0B8A4
	dc	$F3D83C
	dc	$F6F9B5
	dc	$FA1C91
	dc	$FD4056
	dc	$FF9B78
	dc	$FC7756
	dc	$F953C0
	dc	$F63130
	dc	$F31025
	dc	$EFF117
	dc	$ECD484
	dc	$E9BAE5
	dc	$E6A4B6
	dc	$E39270
	dc	$E0848B
	dc	$DD7B82
	dc	$DA77CB
	dc	$D779DE
	dc	$D48231
	dc	$D19138
	dc	$CEA769
	dc	$CBC535
	dc	$C8EB10
	dc	$C61969
	dc	$C350AF
	dc	$C09151
	dc	$BDDBBB
	dc	$BB3059
	dc	$B88F92
	dc	$B5F9D0
	dc	$B36F78
	dc	$B0F0EF
	dc	$AE7E96
	dc	$AC18CF
	dc	$A9BFF9
	dc	$A7746F
	dc	$A5368C
	dc	$A306AA
	dc	$A0E51E
	dc	$9ED23C
	dc	$9CCE56
	dc	$9AD9BC
	dc	$98F4BC
	dc	$971F9F
	dc	$955AAE
	dc	$93A62F
	dc	$920266
	dc	$906F92
	dc	$8EEDF3
	dc	$8D7DC4
	dc	$8C1F3C
	dc	$8AD294
	dc	$8997FD
	dc	$886FA8
	dc	$8759C3
	dc	$865679
	dc	$8565F2
	dc	$848852
	dc	$83BDBD
	dc	$830651
	dc	$82622B
	dc	$81D163
	dc	$815411
	dc	$80EA47
	dc	$809416
	dc	$80518B
	dc	$8022B1
	dc	$80078E
	dc	$000040
	dc	$00003F
	dc	$00003E
	dc	$00003D
	dc	$00003C
	dc	$00003B
	dc	$00003A
	dc	$000039
	dc	$000038
	dc	$000037
	dc	$000036
	dc	$000035
	dc	$000034
	dc	$000034
	dc	$000033
	dc	$000032
	dc	$000031
	dc	$000030
	dc	$00002F
	dc	$00002F
	dc	$00002E
	dc	$00002D
	dc	$00002C
	dc	$00002C
	dc	$00002B
	dc	$00002A
	dc	$000029
	dc	$000029
	dc	$000028
	dc	$000027
	dc	$000026
	dc	$000026
	dc	$000025
	dc	$000024
	dc	$000024
	dc	$000023
	dc	$000023
	dc	$000022
	dc	$000021
	dc	$000021
	dc	$000020
	dc	$000020
	dc	$00001F
	dc	$00001E
	dc	$00001E
	dc	$00001D
	dc	$00001D
	dc	$00001C
	dc	$00001C
	dc	$00001B
	dc	$00001B
	dc	$00001A
	dc	$00001A
	dc	$000019
	dc	$000019
	dc	$000018
	dc	$000018
	dc	$000017
	dc	$000017
	dc	$000016
	dc	$000016
	dc	$000015
	dc	$000015
	dc	$000015
	dc	$000014
	dc	$000014
	dc	$000013
	dc	$000013
	dc	$000013
	dc	$000012
	dc	$000012
	dc	$000012
	dc	$000011
	dc	$000011
	dc	$000011
	dc	$000010
	dc	$000010
	dc	$000010
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$00003F
	dc	$000053
	dc	$000067
	dc	$00007B
	dc	$00000F
	dc	$000011
	dc	$000013
	dc	$000015
	dc	$000080
	dc	$000100
	dc	$000180
	dc	$000200
	dc	$000280
	dc	$000300
	dc	$000380
	dc	$000400
	dc	$000540
	dc	$0004D8
	dc	$000478
	dc	$000410
	dc	$000000
	dc	$000700
	dc	$000900
	dc	$000B00
	dc	$0004D0
	dc	$0004D0
	dc	$000440
	dc	$000400
	dc	$0003E0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000370
	dc	$000360
	dc	$000360
	dc	$000350
	dc	$000350
	dc	$000340
	dc	$000340
	dc	$000330
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000310
	dc	$000340
	dc	$000390
	dc	$0003E0
	dc	$000420
	dc	$000460
	dc	$000490
	dc	$0004A0
	dc	$000460
	dc	$000440
	dc	$000440
	dc	$000520
	dc	$000800
	dc	$000840
	dc	$000840
	dc	$0004F0
	dc	$0004F0
	dc	$000460
	dc	$000410
	dc	$0003E0
	dc	$0003D0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000370
	dc	$000360
	dc	$000360
	dc	$000350
	dc	$000350
	dc	$000340
	dc	$000340
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000320
	dc	$000350
	dc	$000390
	dc	$0003E0
	dc	$000420
	dc	$000450
	dc	$0004A0
	dc	$000490
	dc	$000460
	dc	$000440
	dc	$000480
	dc	$000630
	dc	$000840
	dc	$000840
	dc	$000580
	dc	$000580
	dc	$0004B0
	dc	$000450
	dc	$000420
	dc	$0003F0
	dc	$0003E0
	dc	$0003D0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000360
	dc	$000350
	dc	$000340
	dc	$000330
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000310
	dc	$000330
	dc	$000350
	dc	$0003C0
	dc	$000410
	dc	$000470
	dc	$0004A0
	dc	$000460
	dc	$000440
	dc	$000450
	dc	$0004E0
	dc	$0002F0
	dc	$0002B0
	dc	$000270
	dc	$000230
	dc	$0001F0
	dc	$000170
	dc	$0000F0
	dc	$FFF800
	dc	$000000
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000002
	dc	$000002
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000004
	dc	$000004
	dc	$000005
	dc	$000005
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$000000
	dc	$000005
	dc	$000007
	dc	$000003
	dc	$000007
	dc	$000004
	dc	$000005
	dc	$000006
	dc	$000007
	dc	$000008
	dc	$000009
	dc	$00000A
	dc	$00000B
	dc	$00000C
	dc	$00000E
	dc	$000010
	dc	$000009
	dc	$000003
	dc	$000001
	dc	$000019
	dc	$000005
	dc	$000001
	dc	$00000B
	dc	$000001
	dc	$000000
	dc	$008005
	dc	$00800F
	dc	$00000A
	dc	$00801B
	dc	$00001E
	dc	$000014
	dc	$008011
	dc	$008033
	dc	$000036
	dc	$00003C
	dc	$008039
	dc	$000028
	dc	$00802D
	dc	$008027
	dc	$000022
	dc	$008063
	dc	$000066
	dc	$00006C
	dc	$008069
	dc	$000078
	dc	$00807D
	dc	$008077
	dc	$000072
	dc	$000050
	dc	$008055
	dc	$00805F
	dc	$00005A
	dc	$00804B
	dc	$00004E
	dc	$000044
	dc	$008041
	dc	$0080C3
	dc	$0000C6
	dc	$0000CC
	dc	$0080C9
	dc	$0000D8
	dc	$0080DD
	dc	$0080D7
	dc	$0000D2
	dc	$0000F0
	dc	$0080F5
	dc	$0080FF
	dc	$0000FA
	dc	$0080EB
	dc	$0000EE
	dc	$0000E4
	dc	$0080E1
	dc	$0000A0
	dc	$0080A5
	dc	$0080AF
	dc	$0000AA
	dc	$0080BB
	dc	$0000BE
	dc	$0000B4
	dc	$0080B1
	dc	$008093
	dc	$000096
	dc	$00009C
	dc	$008099
	dc	$000088
	dc	$00808D
	dc	$008087
	dc	$000082
	dc	$008183
	dc	$000186
	dc	$00018C
	dc	$008189
	dc	$000198
	dc	$00819D
	dc	$008197
	dc	$000192
	dc	$0001B0
	dc	$0081B5
	dc	$0081BF
	dc	$0001BA
	dc	$0081AB
	dc	$0001AE
	dc	$0001A4
	dc	$0081A1
	dc	$0001E0
	dc	$0081E5
	dc	$0081EF
	dc	$0001EA
	dc	$0081FB
	dc	$0001FE
	dc	$0001F4
	dc	$0081F1
	dc	$0081D3
	dc	$0001D6
	dc	$0001DC
	dc	$0081D9
	dc	$0001C8
	dc	$0081CD
	dc	$0081C7
	dc	$0001C2
	dc	$000140
	dc	$008145
	dc	$00814F
	dc	$00014A
	dc	$00815B
	dc	$00015E
	dc	$000154
	dc	$008151
	dc	$008173
	dc	$000176
	dc	$00017C
	dc	$008179
	dc	$000168
	dc	$00816D
	dc	$008167
	dc	$000162
	dc	$008123
	dc	$000126
	dc	$00012C
	dc	$008129
	dc	$000138
	dc	$00813D
	dc	$008137
	dc	$000132
	dc	$000110
	dc	$008115
	dc	$00811F
	dc	$00011A
	dc	$00810B
	dc	$00010E
	dc	$000104
	dc	$008101
	dc	$008303
	dc	$000306
	dc	$00030C
	dc	$008309
	dc	$000318
	dc	$00831D
	dc	$008317
	dc	$000312
	dc	$000330
	dc	$008335
	dc	$00833F
	dc	$00033A
	dc	$00832B
	dc	$00032E
	dc	$000324
	dc	$008321
	dc	$000360
	dc	$008365
	dc	$00836F
	dc	$00036A
	dc	$00837B
	dc	$00037E
	dc	$000374
	dc	$008371
	dc	$008353
	dc	$000356
	dc	$00035C
	dc	$008359
	dc	$000348
	dc	$00834D
	dc	$008347
	dc	$000342
	dc	$0003C0
	dc	$0083C5
	dc	$0083CF
	dc	$0003CA
	dc	$0083DB
	dc	$0003DE
	dc	$0003D4
	dc	$0083D1
	dc	$0083F3
	dc	$0003F6
	dc	$0003FC
	dc	$0083F9
	dc	$0003E8
	dc	$0083ED
	dc	$0083E7
	dc	$0003E2
	dc	$0083A3
	dc	$0003A6
	dc	$0003AC
	dc	$0083A9
	dc	$0003B8
	dc	$0083BD
	dc	$0083B7
	dc	$0003B2
	dc	$000390
	dc	$008395
	dc	$00839F
	dc	$00039A
	dc	$00838B
	dc	$00038E
	dc	$000384
	dc	$008381
	dc	$000280
	dc	$008285
	dc	$00828F
	dc	$00028A
	dc	$00829B
	dc	$00029E
	dc	$000294
	dc	$008291
	dc	$0082B3
	dc	$0002B6
	dc	$0002BC
	dc	$0082B9
	dc	$0002A8
	dc	$0082AD
	dc	$0082A7
	dc	$0002A2
	dc	$0082E3
	dc	$0002E6
	dc	$0002EC
	dc	$0082E9
	dc	$0002F8
	dc	$0082FD
	dc	$0082F7
	dc	$0002F2
	dc	$0002D0
	dc	$0082D5
	dc	$0082DF
	dc	$0002DA
	dc	$0082CB
	dc	$0002CE
	dc	$0002C4
	dc	$0082C1
	dc	$008243
	dc	$000246
	dc	$00024C
	dc	$008249
	dc	$000258
	dc	$00825D
	dc	$008257
	dc	$000252
	dc	$000270
	dc	$008275
	dc	$00827F
	dc	$00027A
	dc	$00826B
	dc	$00026E
	dc	$000264
	dc	$008261
	dc	$000220
	dc	$008225
	dc	$00822F
	dc	$00022A
	dc	$00823B
	dc	$00023E
	dc	$000234
	dc	$008231
	dc	$008213
	dc	$000216
	dc	$00021C
	dc	$008219
	dc	$000208
	dc	$00820D
	dc	$008207
	dc	$000202
	dc	$000000
	dc	$007F81
	dc	$00FF02
	dc	$008083
	dc	$007E01
	dc	$000180
	dc	$008103
	dc	$00FE82
	dc	$00FC02
	dc	$008383
	dc	$000300
	dc	$007C81
	dc	$008203
	dc	$00FD82
	dc	$007D01
	dc	$000280
	dc	$007801
	dc	$000780
	dc	$008703
	dc	$00F882
	dc	$000600
	dc	$007981
	dc	$00F902
	dc	$008683
	dc	$008403
	dc	$00FB82
	dc	$007B01
	dc	$000480
	dc	$00FA02
	dc	$008583
	dc	$000500
	dc	$007A81
	dc	$00F002
	dc	$008F83
	dc	$000F00
	dc	$007081
	dc	$008E03
	dc	$00F182
	dc	$007101
	dc	$000E80
	dc	$000C00
	dc	$007381
	dc	$00F302
	dc	$008C83
	dc	$007201
	dc	$000D80
	dc	$008D03
	dc	$00F282
	dc	$008803
	dc	$00F782
	dc	$007701
	dc	$000880
	dc	$00F602
	dc	$008983
	dc	$000900
	dc	$007681
	dc	$007401
	dc	$000B80
	dc	$008B03
	dc	$00F482
	dc	$000A00
	dc	$007581
	dc	$00F502
	dc	$008A83
	dc	$006001
	dc	$001F80
	dc	$009F03
	dc	$00E082
	dc	$001E00
	dc	$006181
	dc	$00E102
	dc	$009E83
	dc	$009C03
	dc	$00E382
	dc	$006301
	dc	$001C80
	dc	$00E202
	dc	$009D83
	dc	$001D00
	dc	$006281
	dc	$001800
	dc	$006781
	dc	$00E702
	dc	$009883
	dc	$006601
	dc	$001980
	dc	$009903
	dc	$00E682
	dc	$00E402
	dc	$009B83
	dc	$001B00
	dc	$006481
	dc	$009A03
	dc	$00E582
	dc	$006501
	dc	$001A80
	dc	$009003
	dc	$00EF82
	dc	$006F01
	dc	$001080
	dc	$00EE02
	dc	$009183
	dc	$001100
	dc	$006E81
	dc	$006C01
	dc	$001380
	dc	$009303
	dc	$00EC82
	dc	$001200
	dc	$006D81
	dc	$00ED02
	dc	$009283
	dc	$00E802
	dc	$009783
	dc	$001700
	dc	$006881
	dc	$009603
	dc	$00E982
	dc	$006901
	dc	$001680
	dc	$001400
	dc	$006B81
	dc	$00EB02
	dc	$009483
	dc	$006A01
	dc	$001580
	dc	$009503
	dc	$00EA82
	dc	$00C002
	dc	$00BF83
	dc	$003F00
	dc	$004081
	dc	$00BE03
	dc	$00C182
	dc	$004101
	dc	$003E80
	dc	$003C00
	dc	$004381
	dc	$00C302
	dc	$00BC83
	dc	$004201
	dc	$003D80
	dc	$00BD03
	dc	$00C282
	dc	$00B803
	dc	$00C782
	dc	$004701
	dc	$003880
	dc	$00C602
	dc	$00B983
	dc	$003900
	dc	$004681
	dc	$004401
	dc	$003B80
	dc	$00BB03
	dc	$00C482
	dc	$003A00
	dc	$004581
	dc	$00C502
	dc	$00BA83
	dc	$003000
	dc	$004F81
	dc	$00CF02
	dc	$00B083
	dc	$004E01
	dc	$003180
	dc	$00B103
	dc	$00CE82
	dc	$00CC02
	dc	$00B383
	dc	$003300
	dc	$004C81
	dc	$00B203
	dc	$00CD82
	dc	$004D01
	dc	$003280
	dc	$004801
	dc	$003780
	dc	$00B703
	dc	$00C882
	dc	$003600
	dc	$004981
	dc	$00C902
	dc	$00B683
	dc	$00B403
	dc	$00CB82
	dc	$004B01
	dc	$003480
	dc	$00CA02
	dc	$00B583
	dc	$003500
	dc	$004A81
	dc	$00A003
	dc	$00DF82
	dc	$005F01
	dc	$002080
	dc	$00DE02
	dc	$00A183
	dc	$002100
	dc	$005E81
	dc	$005C01
	dc	$002380
	dc	$00A303
	dc	$00DC82
	dc	$002200
	dc	$005D81
	dc	$00DD02
	dc	$00A283
	dc	$00D802
	dc	$00A783
	dc	$002700
	dc	$005881
	dc	$00A603
	dc	$00D982
	dc	$005901
	dc	$002680
	dc	$002400
	dc	$005B81
	dc	$00DB02
	dc	$00A483
	dc	$005A01
	dc	$002580
	dc	$00A503
	dc	$00DA82
	dc	$005001
	dc	$002F80
	dc	$00AF03
	dc	$00D082
	dc	$002E00
	dc	$005181
	dc	$00D102
	dc	$00AE83
	dc	$00AC03
	dc	$00D382
	dc	$005301
	dc	$002C80
	dc	$00D202
	dc	$00AD83
	dc	$002D00
	dc	$005281
	dc	$002800
	dc	$005781
	dc	$00D702
	dc	$00A883
	dc	$005601
	dc	$002980
	dc	$00A903
	dc	$00D682
	dc	$00D402
	dc	$00AB83
	dc	$002B00
	dc	$005481
	dc	$00AA03
	dc	$00D582
	dc	$005501
	dc	$002A80
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000004
	dc	$000000
	dc	$800000
	dc	$C00000
	dc	$E00000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$000006
	dc	$000007
	dc	$000008
	dc	$000009
	dc	$00000A
	dc	$00000B
	dc	$00000C
	dc	$00000D
	dc	$00000E
	dc	$00000F
	dc	$000010
	dc	$000011
	dc	$000012
	dc	$000013
	dc	$000014
	dc	$000015
	dc	$000016
	dc	$000017
	dc	$000018
	dc	$000019
	dc	$00001A
	dc	$00001B
	dc	$00001C
	dc	$00001F
	dc	$000022
	dc	$000025
	dc	$000028
	dc	$00002B
	dc	$00002E
	dc	$000031
	dc	$000037
	dc	$00003D
	dc	$000043
	dc	$000049
	dc	$00004F
	dc	$000055
	dc	$000061
	dc	$00006D
	dc	$000079
	dc	$000085
	dc	$00009D
	dc	$0000B5
	dc	$0000CD
	dc	$0000E5
	dc	$0000FD
	dc	$000500
	dc	$000500
	dc	$000571
	dc	$000572
	dc	$000780
	dc	$000780
	dc	$800000
	dc	$000000
	dc	$A57D86
	dc	$5A827A
	dc	$89BE51
	dc	$30FBC5
	dc	$CF043B
	dc	$7641AF
	dc	$8275A1
	dc	$18F8B8
	dc	$B8E313
	dc	$6A6D99
	dc	$959267
	dc	$471CED
	dc	$E70748
	dc	$7D8A5F
	dc	$809DC9
	dc	$0C8BD3
	dc	$AECC33
	dc	$62F202
	dc	$8F1D34
	dc	$3C56BA
	dc	$DAD7F4
	dc	$7A7D05
	dc	$8582FB
	dc	$25280C
	dc	$C3A946
	dc	$70E2CC
	dc	$9D0DFE
	dc	$5133CD
	dc	$F3742D
	dc	$7F6237
	dc	$802778
	dc	$0647D9
	dc	$AA0A5B
	dc	$5ED77D
	dc	$8C4A14
	dc	$36BA20
	dc	$D4E0CB
	dc	$788484
	dc	$83D604
	dc	$1F19F9
	dc	$BE31E2
	dc	$6DCA0D
	dc	$99307F
	dc	$4C3FE0
	dc	$ED37F0
	dc	$7E9D56
	dc	$8162AA
	dc	$12C810
	dc	$B3C020
	dc	$66CF81
	dc	$9235F3
	dc	$41CE1E
	dc	$E0E607
	dc	$7C29FC
	dc	$877B7C
	dc	$2B1F35
	dc	$C945E0
	dc	$73B5EC
	dc	$A12883
	dc	$55F5A5
	dc	$F9B827
	dc	$7FD888
	dc	$000000
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000001
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000003
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000005
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$000002
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000003
	dc	$000004
	dc	$000004
	dc	$000005
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\llef33.asm ===
;	File info
;	  File name: llef33.asm
;	  Build date: 02/04/02, 18:31:21
;	Program info
;	  Program number: 4
;	  Revision number: 1.114
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 1747 words
;	  Checksum: $0FC6C2

		dc	$D01B40,$0006D3,$040172,$0FC6C2,$447000,$0000FB,$20000B,$05A403
		dc	$0D1080,$0006C0,$0D1080,$00066C,$57F000,$0000FB,$60F40B,$00001F
		dc	$052412,$240000,$447000,$000B4F,$447000,$000B50,$44F400,$F87200
		dc	$445800,$44F400,$4E1F00,$445800,$44F400,$000100,$445800,$44F400
		dc	$500000,$445800,$56F000,$000B4F,$44F003,$000B50,$05A402,$445800
		dc	$57F400,$000010,$0D1080,$0001A6,$44F400,$000000,$200045,$057400
		dc	$205800,$56D800,$57F000,$0000FB,$44F40B,$000004,$202A40,$57F000
		dc	$000B4F,$44F40B,$000001,$202240,$240000,$250000,$60F400,$00001F
		dc	$0CCC80,$000007,$0ACC40,$219800,$44F400,$000001,$45E800,$447000
		dc	$000B4F,$457000,$000B50,$218400,$56F000,$0000FB,$0D1080,$000636
		dc	$00000C,$46F461,$000010,$230700,$06D910,$00000A,$50D97C,$057407
		dc	$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500
		dc	$00000C,$46F461,$000010,$230700,$50D97C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400
		dc	$000010,$230700,$06D910,$00000D,$56D900,$0C1E6E,$20AC7C,$057407
		dc	$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500
		dc	$00000C,$46F400,$000010,$230700,$06D910,$00000D,$5ED900,$0C1E6E
		dc	$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$46F400,$000010,$230700,$56D900,$0C1E6E
		dc	$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$46F400,$000010,$230700,$5ED900,$0C1E6E
		dc	$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$61F400,$000D12,$46F400,$0000FF,$06D810
		dc	$00000E,$0C1C90,$200056,$51D800,$219900,$0C1D91,$4CE900,$20004B
		dc	$0C1C90,$200056,$219900,$0C1D91,$4CE900,$20004B,$0C1E91,$21AE00
		dc	$0C1C11,$00000C,$61F41B,$000E12,$46F400,$0000FF,$204800,$06D810
		dc	$00000D,$21AE5E,$44F800,$21B900,$0C1ED0,$200042,$4CE900,$200043
		dc	$218F56,$219900,$0C1ED1,$4CE900,$20004B,$0C1E91,$21AE00,$0C1C11
		dc	$00000C,$000479,$0003FA,$000417,$000434,$00043B,$000454,$00045B
		dc	$00045E,$000461,$000464,$000467,$00046A,$00046D,$000470,$000473
		dc	$000476,$74F400,$0003E1,$06D810,$000086,$64DD00,$56E000,$07EC96
		dc	$218500,$0AE680,$44F400,$000003,$62F4A0,$000005,$72F040,$000002
		dc	$234F22,$39010B,$546A00,$052404,$607000,$00000D,$050C0E,$66F400
		dc	$000D0A,$232400,$39024D,$05A409,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2
		dc	$00000D,$0C1D24,$390000,$506600,$717013,$000002,$050CC3,$44F400
		dc	$000005,$62F4A0,$000008,$72F040,$000003,$234F22,$39010B,$546A00
		dc	$052404,$607000,$00000E,$050C0E,$66F400,$000D0D,$232400,$39024D
		dc	$05A409,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000E,$0C1D20,$390000
		dc	$506600,$717013,$000003,$050C86,$44F400,$000007,$2000A0,$200040
		dc	$0C1D38,$0C1C10,$050C5F,$44F400,$00000B,$62F4A0,$00000B,$72F040
		dc	$000004,$234F22,$39010B,$66F400,$000D10,$546A00,$052404,$607000
		dc	$00000F,$050C08,$F0DA00,$F0DAD0,$66F0D2,$00000F,$0C1D20,$390000
		dc	$506600,$717013,$000004,$050C46,$44F400,$00000F,$2000A0,$200040
		dc	$0C1D36,$0C1C10,$050C1F,$56F400,$040000,$050C1B,$56F400,$020000
		dc	$050C18,$56F400,$010000,$050C15,$56F400,$008000,$050C12,$56F400
		dc	$004000,$050C0F,$56F400,$002000,$050C0C,$56F400,$001000,$050C09
		dc	$56F400,$000800,$050C06,$56F400,$000400,$050C03,$56F400,$000100
		dc	$200060,$565800,$00000C,$0004C6,$0004B2,$0004A8,$0004BB,$00049E
		dc	$0004BB,$0004BB,$0004BB,$0004BB,$0004BB,$0004BB,$0004BB,$0004BB
		dc	$0004BB,$0004BB,$0004BB,$62F000,$000B55,$05F022,$000B47,$56F000
		dc	$000B56,$45F000,$000B57,$46F400,$000010,$74F400,$00047B,$06D810
		dc	$00002F,$64DD00,$07EC96,$0B74C7,$000CFA,$0AE680,$57F000,$000004
		dc	$01418C,$557000,$000004,$052443,$390200,$717000,$000004,$050C14
		dc	$57F000,$000003,$01418C,$557000,$000003,$052419,$390300,$717000
		dc	$000003,$050C0A,$57F000,$000002,$01418C,$557000,$000002,$05240F
		dc	$390300,$717000,$000002,$200069,$50E07C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$21A500,$205800,$547000
		dc	$000B56,$457000,$000B57,$627000,$000B55,$05F422,$00FFFF,$00000C
		dc	$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8
		dc	$44F400,$000000,$20004D,$05A40C,$44F400,$000010,$20004D,$0D104A
		dc	$00000F,$300000,$56F400,$000000,$57F400,$FFFFFF,$00000C,$200013
		dc	$300000,$56F400,$000000,$57F400,$000608,$00000C,$56F000,$000B96
		dc	$200003,$057458,$607000,$000B45,$607000,$000B55,$45F400,$0007B0
		dc	$457000,$000B72,$56F000,$000B40,$240003,$052409,$447000,$000B56
		dc	$447000,$000B57,$447000,$000B9D,$0D1080,$00008C,$0D1080,$000129
		dc	$0D1080,$00019E,$0D1080,$000366,$56F000,$000B40,$014585,$052403
		dc	$0D1080,$000393,$56F000,$000B55,$44F000,$000B45,$200044,$547000
		dc	$000B58,$0D1080,$0003D0,$56F000,$000B40,$014585,$05A40B,$44F000
		dc	$000B58,$45F400,$000010,$44F0A0,$000B9D,$0C1D2E,$200040,$567000
		dc	$000B9D,$0D1080,$000008,$00000C,$44F400,$000100,$447000,$000010
		dc	$00000C,$56F000,$000B96,$200003,$05F407,$44F013,$000B45,$447000
		dc	$000B55,$547000,$000B9A,$60F400,$000011,$44F400,$00000D,$445800
		dc	$56F000,$000B55,$44F000,$000B45,$200044,$545800,$44F000,$000B55
		dc	$445800,$240000,$445800,$445800,$445800,$445800,$44F413,$000009
		dc	$447000,$00001E,$44F000,$00001E,$0C1940,$004018,$545800,$240000
		dc	$445800,$20001B,$200013,$0C1EDF,$21A400,$0C1940,$008020,$20001B
		dc	$0C1EDF,$21A400,$0C1940,$008018,$545800,$57F013,$000B7D,$45F40B
		dc	$000080,$052407,$20001B,$0C1CA1,$200068,$21A400,$0C1940,$008020
		dc	$20001B,$0C1CA1,$200068,$21A400,$0C1940,$008018,$545800,$57F013
		dc	$000B7D,$20000B,$052407,$20001B,$0C1CA1,$200068,$21A400,$0C1940
		dc	$008020,$0C1CA1,$200068,$21A400,$0C1940,$008018,$545800,$200013
		dc	$545800,$60F400,$000011,$56F000,$000B96,$57F400,$000608,$00000C
		dc	$62F000,$000B45,$05F022,$000B47,$57F400,$000010,$250000,$44F400
		dc	$000B77,$447000,$000000,$44F400,$000000,$447000,$000B54,$61F400
		dc	$000000,$381000,$0D0393,$61F400,$000B54,$381000,$0D0393,$61F400
		dc	$000B7B,$380200,$0D0393,$61F400,$000B7C,$380600,$0D0393,$280400
		dc	$507000,$00001E,$61F400,$00001E,$380500,$0D0393,$280000,$507000
		dc	$00001E,$61F400,$00001E,$380300,$0D0393,$61F400,$000B7D,$380300
		dc	$0D0393,$56F000,$000B7D,$014185,$05A40A,$014186,$05A408,$280000
		dc	$507000,$00001E,$61F400,$00001E,$380200,$0D0393,$56F000,$000B7D
		dc	$014486,$05A408,$280000,$507000,$00001E,$61F400,$00001E,$380200
		dc	$0D0393,$56F000,$000B7D,$014285,$052405,$61F400,$000B4E,$380200
		dc	$0D0393,$61F400,$000B7E,$380100,$0D0393,$61F400,$000B49,$380500
		dc	$0D0393,$61F400,$000B4C,$380100,$0D0393,$56F000,$000B4C,$200003
		dc	$05A405,$61F400,$000B4D,$380800,$0D0393,$280000,$507000,$00001E
		dc	$61F400,$00001E,$380100,$0D0393,$280000,$507000,$00001E,$61F400
		dc	$00001E,$380100,$0D0393,$280000,$507000,$00001E,$61F400,$00001E
		dc	$380100,$0D0393,$280100,$507000,$00001E,$61F400,$00001E,$380100
		dc	$0D0393,$200013,$567000,$00001E,$61F400,$00001E,$380100,$0D0393
		dc	$200013,$567000,$00001E,$61F400,$00001E,$380100,$0D0393,$200013
		dc	$507000,$00001E,$61F400,$00001E,$380100,$0D0393,$457000,$000B56
		dc	$577000,$000B57,$627000,$000B55,$05F422,$00FFFF,$00000C,$200013
		dc	$567000,$000002,$567000,$000003,$567000,$000004,$360000,$44F000
		dc	$000B97,$06C410,$00001D,$56F400,$000BA5,$22C400,$200040,$219000
		dc	$70E000,$22C400,$46F400,$0000B5,$44F4D0,$000100,$0C1D2E,$200040
		dc	$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72,$0C1D2E,$200040
		dc	$219500,$667000,$000B41,$0D03F1,$66F000,$000B41,$205E00,$56F000
		dc	$000B7E,$200003,$05A407,$380700,$60F400,$000489,$65F400,$000B39
		dc	$0D03F1,$57F000,$000002,$20000B,$05A414,$62F400,$000005,$66F400
		dc	$000D0A,$224E00,$44F410,$000001,$01438C,$21D03E,$06CD10,$000002
		dc	$445800,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000D,$0C1D24,$506600
		dc	$57F000,$000003,$20000B,$05A414,$62F400,$000008,$66F400,$000D0D
		dc	$224E00,$44F410,$000002,$01438C,$21D03E,$06CD10,$000002,$445800
		dc	$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000E,$0C1D20,$506600,$57F000
		dc	$000004,$20000B,$05A413,$62F400,$00000B,$66F400,$000D10,$224E00
		dc	$44F410,$000005,$01428C,$21D03E,$06CD10,$000002,$445800,$F0DA00
		dc	$F0DAD0,$66F0D2,$00000F,$0C1D20,$506600,$00000C,$62F000,$000B55
		dc	$05F022,$000B47,$57F000,$000B57,$45F000,$000B56,$61F400,$000B7F
		dc	$71F000,$000B97,$380100,$0D036F,$61F400,$000B84,$71F000,$000B97
		dc	$380100,$0D036F,$61F400,$000B4A,$380100,$0D0393,$56F000,$000B4A
		dc	$200003,$05A405,$61F400,$000B4B,$380800,$0D0393,$200013,$567000
		dc	$00001E,$61F400,$000B89,$380100,$0D0393,$56F900,$200003,$05A405
		dc	$61F400,$00001E,$380100,$0D0393,$56F000,$000B7D,$0140C5,$000002
		dc	$052412,$44F400,$000010,$447000,$00001E,$56F000,$000B40,$200003
		dc	$052406,$61F400,$00001E,$380500,$0D0393,$050C05,$61F400,$00001E
		dc	$380100,$0D0393,$61F400,$000B8A,$71F000,$000B97,$380200,$0D036F
		dc	$56F000,$000B7E,$200003,$05A405,$61F400,$000B8F,$380100,$0D0393
		dc	$360000,$44F000,$000B97,$06C410,$000011,$56F400,$000B8A,$22C400
		dc	$200040,$219100,$56E100,$200003,$05A408,$56F400,$000BA0,$22C400
		dc	$200040,$219100,$380600,$0D0393,$205E00,$360000,$44F000,$000B97
		dc	$06C410,$000023,$56F400,$000B8A,$22C400,$200040,$219100,$56E100
		dc	$200003,$05A41A,$22C400,$46F400,$00001F,$44F4D0,$000000,$0C1D2E
		dc	$200040,$219100,$380400,$0D03A3,$56F400,$000B91,$22C400,$200040
		dc	$219000,$71E000,$380700,$0D0381,$56F400,$000B61,$22C400,$200040
		dc	$219100,$380200,$0D0393,$205E00,$56F000,$000B7E,$200003,$05A40C
		dc	$56F000,$000B8F,$200003,$05A408,$61F400,$00009B,$380400,$0D03A3
		dc	$390200,$380700,$0D0381,$61F400,$000B90,$380100,$0D0393,$56F900
		dc	$200003,$05A449,$56F400,$000002,$567000,$00001E,$61F400,$00001E
		dc	$380200,$0D0393,$56F400,$000001,$567000,$00001E,$61F400,$00001E
		dc	$380200,$0D0393,$56F400,$000001,$567000,$00001E,$61F400,$00001E
		dc	$380200,$0D0393,$56F400,$000002,$567000,$00001E,$61F400,$00001E
		dc	$380200,$0D0393,$56F400,$000007,$567000,$00001E,$61F400,$00001E
		dc	$380300,$0D0393,$61F400,$000B6F,$380100,$0D0393,$56F900,$200003
		dc	$05A44A,$61F400,$000B73,$380600,$0D0393,$360000,$44F000,$000B97
		dc	$06C410,$000011,$56F400,$000B74,$22C400,$200040,$219100,$380400
		dc	$0D0393,$56F400,$000004,$567000,$00001E,$61F400,$00001E,$380300
		dc	$0D0393,$205E00,$56F000,$000B7E,$200003,$05A40D,$61F400,$000B79
		dc	$380400,$0D0393,$56F400,$000004,$567000,$00001E,$61F400,$00001E
		dc	$380300,$0D0393,$61F413,$00001E,$566100,$380100,$0D0393,$050C01
		dc	$56F000,$000B40,$014385,$052455,$224E00,$44F000,$000B45,$46F444
		dc	$000010,$21C700,$21EE00,$44F436,$000010,$200040,$21C400,$47F0B0
		dc	$000B9D,$0C1D2E,$200040,$44F070,$000B67,$21C741,$0C1D06,$18B000
		dc	$000B9E,$44F054,$000B7A,$200044,$200074,$200003,$05F41A,$014780
		dc	$44F000,$000B67,$0C1C06,$21C441,$200040,$567000,$000B67,$0140C5
		dc	$0001FF,$05F402,$00000C,$56F000,$000B71,$21C441,$0C1D06,$21C441
		dc	$200040,$567000,$000B71,$60F400,$000B6C,$56E000,$200044,$566000
		dc	$61F400,$000B66,$380100,$0D0393,$56F900,$200003,$05A501,$61F400
		dc	$000B67,$380900,$0D0393,$56F000,$000B70,$200003,$05F49F,$44F400
		dc	$000001,$447000,$000B5B,$61F413,$00001E,$566100,$380100,$0D0393
		dc	$240000,$447000,$00001E,$61F400,$00001E,$380100,$0D0393,$56F000
		dc	$000B5B,$014180,$567000,$000B5B,$56F000,$000B40,$014385,$052441
		dc	$240000,$447000,$00001E,$21EE00,$015085,$05A40B,$44F000,$000B5B
		dc	$200040,$21E400,$567000,$000B5B,$61F400,$00001E,$209800,$0D0393
		dc	$224E00,$567000,$000B59,$61F400,$00001E,$381000,$0D0393,$61F400
		dc	$00001E,$381000,$0D0393,$56F000,$000B5B,$016080,$567000,$000B5B
		dc	$240000,$447000,$00001E,$56F000,$000B70,$0C1D06,$44F000,$000B5B
		dc	$200044,$0C1C06,$06CC10,$00000A,$61F400,$00001E,$380800,$0D0393
		dc	$56F000,$000B5B,$014880,$567000,$000B5B,$56F000,$000B70,$0C1D06
		dc	$44F000,$000B5B,$200044,$61F400,$00001E,$219800,$0D0393,$56F000
		dc	$000B67,$44F000,$000B70,$200044,$050C0F,$56F000,$000B67,$2E0003
		dc	$05F40B,$240000,$447000,$00001E,$61F400,$00001E,$380800,$0D0393
		dc	$56F000,$000B67,$014184,$200003,$05A40B,$06CC10,$000009,$200013
		dc	$567000,$000010,$61F400,$000010,$380800,$0D0361,$000000,$457000
		dc	$000B56,$577000,$000B57,$627000,$000B55,$05F422,$00FFFF,$00000C
		dc	$390100,$717000,$000002,$717000,$000003,$717000,$000004,$360000
		dc	$44F000,$000B97,$06C410,$00001D,$56F400,$000BA5,$22C400,$200040
		dc	$219000,$70E000,$22C400,$46F400,$0000B5,$44F4D0,$000100,$0C1D2E
		dc	$200040,$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72,$0C1D2E
		dc	$200040,$219500,$667000,$000B41,$0D048B,$66F000,$000B41,$205E00
		dc	$56F000,$000B7E,$200003,$05A407,$380700,$60F400,$000489,$65F400
		dc	$000B39,$0D048B,$00000C,$62F000,$000B55,$05F022,$000B47,$57F000
		dc	$000B57,$45F000,$000B56,$240000,$447000,$00001E,$56F000,$000B6E
		dc	$015085,$059409,$015084,$547000,$000B6E,$61F400,$00001E,$381000
		dc	$0D0393,$050FD5,$200003,$05A405,$61F400,$00001E,$219800,$0D0393
		dc	$200013,$567000,$000001,$567000,$00001E,$61F400,$00001E,$380100
		dc	$0D0393,$61F400,$000001,$380100,$0D0393,$61F400,$00001E,$381000
		dc	$0D0393,$457000,$000B56,$577000,$000B57,$627000,$000B55,$05F422
		dc	$00FFFF,$56F000,$000B55,$44F000,$000B45,$200044,$21C400,$45F400
		dc	$000010,$2000A0,$0C1D2E,$44F000,$000B9D,$200040,$567000,$000B9D
		dc	$00000C,$56F000,$000B40,$014085,$052410,$60F000,$000B45,$205800
		dc	$05F020,$000B47,$56F000,$000B58,$014184,$21D81B,$0D03B3,$557000
		dc	$000B5A,$05F420,$00FFFF,$050CDA,$014185,$05A403,$014285,$05240F
		dc	$60F000,$000B45,$05F020,$000B47,$70F01B,$000B58,$55F000,$000B5A
		dc	$0D03B3,$557000,$000B5A,$05F420,$00FFFF,$050CC8,$014385,$052482
		dc	$56F000,$000B59,$44F000,$000B45,$200044,$014180,$21D800,$209000
		dc	$05F020,$000B47,$55F000,$000B5A,$0D03B3,$0C1E91,$61F000,$000B59
		dc	$556100,$0C1C91,$44F000,$000B9D,$250800,$2000A0,$44F000,$000B9B
		dc	$21C441,$200044,$230400,$200044,$209A00,$21D800,$56F000,$000B59
		dc	$014180,$21D000,$0D03CA,$56F000,$000B59,$014180,$21D000,$0C1E91
		dc	$556000,$0C1C91,$56F000,$000B55,$44F000,$000B45,$200044,$234400
		dc	$200044,$230400,$200044,$21D800,$56F000,$000B45,$200040,$234400
		dc	$200040,$21D000,$20001B,$0D03B3,$557000,$000B5A,$05F420,$00FFFF
		dc	$050C45,$014485,$05240F,$05F020,$000B47,$60F000,$000B45,$70F000
		dc	$000B58,$57F000,$000B5A,$0D03B3,$557000,$000B5A,$05F420,$00FFFF
		dc	$050C15,$014585,$052413,$05F020,$000B47,$60F000,$000B45,$70F000
		dc	$000B58,$57F000,$000B5A,$0D03B3,$56F000,$000B55,$014184,$21D000
		dc	$0C1E91,$556000,$0C1C91,$05F420,$00FFFF,$00000C,$56F400,$000015
		dc	$57F400,$000001,$70F400,$000390,$390000,$60F400,$000100,$0BF080
		dc	$000180,$200003,$052400,$00000C,$547000,$0000FD,$447000,$0000FE
		dc	$607000,$0000FF,$200003,$052410,$56F400,$00000C,$70F400,$0005DA
		dc	$390000,$0BF080,$000180,$200003,$052400,$56F000,$0000FD,$60F000
		dc	$0000FF,$44F000,$0000FE,$45F403,$0005DA,$052403,$457000,$000B48
		dc	$209800,$56F000,$000B48,$219940,$547000,$000B48,$56F400,$000009
		dc	$57F400,$000002,$0BF080,$000180,$200003,$052400,$56F000,$0000FD
		dc	$014585,$052409,$56F400,$00000C,$70F400,$000122,$71F400,$000ADE
		dc	$0BF080,$000180,$56F400,$000019,$57F400,$000002,$390000,$70F400
		dc	$000080,$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C
		dc	$56F400,$000019,$57F400,$000000,$70F400,$000080,$0BF080,$000180
		dc	$200003,$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\se_sip.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			se_sip.inc
;												
;   Contents:		Super Exec Configuration Software Interface Protocol (SIP)
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/14/2000 10:08:08 AM		jmw
;	Created.
;
;
; ******************************************************************

;**** SuperExec input parameter list equates ****

SE_IN_SIZE			equ		0		; input parameter list size
SE_IN_DO_SURROUND	equ		1		; do Dolby Surround Encoder flag
SE_IN_DO_GAME		equ		2		; do Dolby Game Encoder flag
SE_IN_DO_DOWNMIX	equ		3		; do Dolby Downmix (1 for Mono, 2 for Stereo)
SE_IN_FSCODE		equ		4		; PCM sampling rate code
SE_IN_ACMODE		equ		5		; input channel configuration
SE_IN_LFE			equ		6		; low frequency effects channel present flag
SE_IN_DIALNORM		equ		7		; dialnorm setting
SE_IN_BW			equ		8		; manual channel bandwidth
SE_IN_LPF			equ		9		; channel LPF enabled flag
SE_IN_LFELPF		equ		10		; LFE LPF flag
SE_IN_HPF			equ		11		; DC HPF flag
SE_IN_DYNRNGE		equ		12		; dynrng exists flag
SE_IN_DYNRNG		equ		13		; AC-3 dynamic range code
SE_IN_COMPRE		equ		14		; compr exists flag
SE_IN_COMPR			equ		15		; AC-3 compression code
SE_IN_SURR_GE		equ		16		; Dolby Surround gain enabled flag
SE_IN_SURR_GAIN		equ		17		; Dolby Surround gain
SE_IN_DSURMOD		equ		18		; Dolby Surround Mode.  Only used for 2/0 Mode
SE_IN_RESERVED_1	equ		19
SE_IN_RESERVED_2	equ		20
SE_IN_RESERVED_3	equ		21
SE_IN_RESERVED_4	equ		22
SE_IN_RESERVED_5	equ		23

SE_IN_MAX			equ		24		; maximum input parameter list size
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\sehelper.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			sehelper.asm
;												
;   Contents:		Helper Functions for SuperExec
;					Only used for simulator version.
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/12/2000 3:49:54 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'SuperExec Helper Fcns'

	section	SuperExecHelper
	
;**** include files ************************************************

	nolist
	include 'mot_equ.inc'
	list

;**** external references ******************************************

	xdef	CopyInFilesToSysMem
	xdef	Copy6ChInFileToSysMem

	xdef	CopySysMemToOutputFiles
	xdef	CopySysMemToAC3OutputFile

;**** equates ******************************************************

simulator_l_pcm_input		equ		$ef0000		; DSP chip locations for simulator
simulator_r_pcm_input		equ		$ef0001		; These will not be needed in NVIDIA
simulator_c_pcm_input		equ		$ef0002		; implementation
simulator_ls_pcm_input  	equ		$ef0003		;
simulator_rs_pcm_input  	equ		$ef0004		;

BLOCK_LEN					equ		256
AC3_BLOCK0_OFFSET			equ		(3072-1280-290)
AC3WORDSPERFRAME			equ		1280

;**** data *********************************************************

	mode rel
	org	p(202):

;*******************************************************************
;*
;*	Subroutine Name:	CopyInFilesToSysMem
;*																								
;*  Description:		Copies Input data to Simulated X-Box System memory
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
CopyInFilesToSysMem:

	move	#SYSMEMPCMBASE,r1
	
	dor		#BLOCK_LEN,l_loop
		move	x:simulator_l_pcm_input,a
		move	a,x:(r1)+
l_loop:

	dor		#BLOCK_LEN,c_loop
		move	x:simulator_c_pcm_input,a
		move	a,x:(r1)+
c_loop:

	dor		#BLOCK_LEN,r_loop
		move	x:simulator_r_pcm_input,a
		move	a,x:(r1)+
r_loop:

	dor		#BLOCK_LEN,ls_loop
		move	x:simulator_ls_pcm_input,a
		move	a,x:(r1)+
ls_loop:

	dor		#BLOCK_LEN,rs_loop
		move	x:simulator_rs_pcm_input,a
		move	a,x:(r1)+
rs_loop:

	rts


;*******************************************************************
;*
;*	Subroutine Name:	CopySysMemToOutputFiles
;*																								
;*  Description:		Copies simulated X-Box Sys Mem to Output debug files
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
CopySysMemToOutputFiles:

	move	#SYSMEMLTRTBASE,r0
	move	#SYSMEMLTRTBASE+BLOCK_LEN,r1

	dor		#BLOCK_LEN,outcopy
		movep	x:(r0)+,x:M_TX00
		movep	x:(r1)+,x:M_TX00
outcopy:

	rts


;*******************************************************************
;*
;*	Subroutine Name:	Copy6ChInFileToSysMem
;*																								
;*  Description:		Copies a single 6-channel block of Input data 
;*						to Simulated X-Box System memory
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
Copy6ChInFileToSysMem:

	move	#SYSMEMPCMBASE,r0
	move	#BLOCK_LEN,n1

	dor		#BLOCK_LEN,loop_6ch
		move	r0,r1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		move	(r0)+
loop_6ch:

	rts

;*******************************************************************
;*
;*	Subroutine Name:	CopySysMemToAC3OutputFile
;*																								
;*  Description:		Copies simulated X-Box Sys Mem to Output debug files
;*
;*	Input:				n0 - number of words to copy
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************

CopySysMemToAC3OutputFile:

	move	#SYSMEMAC3BASE+AC3_BLOCK0_OFFSET,r0
	
	dor		#AC3WORDSPERFRAME,outcopyAC3
	movep	x:(r0)+,x:M_TX00
outcopyAC3:

	rts

;******************************************************************************

	endsec	; SuperExecHelper
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\mot_equ.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			mot_equ.inc
;												
;   Contents:		EQUATES for 56301 registers and ports
;					Reference: 56301 Specifications Revision 3.00
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/19/2000 8:49:01 PM		jmw
;	Copied.
;
;
; ******************************************************************

	page	132,55,0,0,0
	opt	mex

ioequ   ident   1,0

;------------------------------------------------------------------------
;
;       EQUATES for I/O Port Programming
;
;------------------------------------------------------------------------

;       Register Addresses

M_DATH   EQU     $FFFFCF         ; Port B (host) GPIO data Register
M_DIRH   EQU     $FFFFCE         ; Port B (host) GPIO direction Register

M_PCRC   EQU     $FFFFBF         ; Port C (ESSI0) Control Register
M_PRRC   EQU     $FFFFBE         ; Port C (ESSI0) Direction Register
M_PDRC   EQU     $FFFFBD         ; Port C (ESSI0) GPIO Data Register

M_PCRD   EQU     $FFFFAF         ; Port D (ESSI1) Control register
M_PRRD   EQU     $FFFFAE         ; Port D (ESSI1) Direction Data Register
M_PDRD   EQU     $FFFFAD         ; Port D (ESSI1) GPIO Data Register

M_PCRE   EQU     $FFFF9F         ; Port E (SCI) Control register
M_PRRE   EQU     $FFFF9E         ; Port E (SCI) Direction Register
M_PDRE   EQU     $FFFF9D         ; Port E (SCI) Data Register

M_OGDB   EQU     $FFFFFC         ; OnCE GDB Register 

;------------------------------------------------------------------------
;
;       EQUATES for Host Interface
;
;------------------------------------------------------------------------

;       Register Addresses
 
M_DTXS   EQU     $FFFFCD         ; DSP SLAVE TRANSMIT DATA FIFO (DTXS)
M_DTXM   EQU     $FFFFCC         ; DSP MASTER TRANSMIT DATA FIFO (DTXM)
M_DRXR   EQU     $FFFFCB         ; DSP RECEIVE DATA FIFO (DRXR)
M_DPSR   EQU     $FFFFCA         ; DSP PCI STATUS REGISTER (DPSR)
M_DSR    EQU     $FFFFC9         ; DSP STATUS REGISTER (DSR)
M_DPAR   EQU     $FFFFC8         ; DSP PCI ADDRESS REGISTER (DPAR)
M_DPMC   EQU     $FFFFC7         ; DSP PCI MASTER CONTROL REGISTER (DPMC)
M_DPCR   EQU     $FFFFC6         ; DSP PCI CONTROL REGISTER (DPCR)
M_DCTR   EQU     $FFFFC5         ; DSP CONTROL REGISTER (DCTR)    
 
;       Host Control Register Bit Flags

M_HCIE   EQU     0               ; Host Command Interrupt Enable
M_STIE   EQU     1               ; Slave Transmit Interrupt Enable
M_SRIE   EQU     2               ; Slave Receive Interrupt Enable
M_HF35   EQU     $38             ; Host Flags 5-3 Mask
M_HF3    EQU     3               ; Host Flag 3
M_HF4    EQU     4               ; Host Flag 4
M_HF5    EQU     5               ; Host Flag 5
M_HINT   EQU     6               ; Host Interrupt A
M_HDSM   EQU     13              ; Host Data Strobe Mode
M_HRWP   EQU     14              ; Host RD/WR Polarity
M_HTAP   EQU     15              ; Host Transfer Acknowledge Polarity
M_HDRP   EQU     16              ; Host Dma Request Polarity
M_HRSP   EQU     17              ; Host Reset Polarity
M_HIRP   EQU     18              ; Host Interrupt  Request Polarity
M_HIRC   EQU     19              ; Host Interupt Request Control
M_HM0    EQU     20              ; Host Interface Mode
M_HM1    EQU     21              ; Host Interface Mode
M_HM2    EQU     22              ; Host Interface Mode
M_HM     EQU     $700000         ; Host Interface Mode Mask

;       Host PCI Control Register Bit Flags

M_PMTIE  EQU     1               ; PCI Master Transmit         Interrupt Enable
M_PMRIE  EQU     2               ; PCI Master Receive          Interrupt Enable
M_PMAIE  EQU     4               ; PCI Master Address          Interrupt Enable
M_PPEIE  EQU     5               ; PCI Parity Error            Interrupt Enable
M_PTAIE  EQU     7               ; PCI Transaction Abort       Interrupt Enable
M_PTTIE  EQU     9               ; PCI Transaction Termination Interrupt Enable
M_PTCIE  EQU     12              ; PCI Transfer Complete       Interrupt Enable
M_CLRT   EQU     14              ; Clear Transmitter
M_MTT    EQU     15              ; Master Transfer Terminate
M_SERF   EQU     16              ; HSERR~ Force
M_MACE   EQU     18              ; Master Access Counter Enable
M_MWSD   EQU     19              ; Master Wait States Disable
M_RBLE   EQU     20              ; Receive Buffer Lock Enable
M_IAE    EQU     21              ; Insert Address Enable 

;       Host PCI Master Control Register Bit Flags

M_ARH    EQU     $00ffff         ; DSP PCI Transaction Address (High)
M_BL     EQU     $3f0000         ; PCI Data Burst Length
M_FC     EQU     $c00000         ; Data Transfer Format Control

;       Host PCI Address Register Bit Flags

M_ARL    EQU     $00ffff         ; DSP PCI Transaction Address (Low)
M_C      EQU     $0f0000         ; PCI Bus Command
M_BE     EQU     $f00000         ; PCI Byte Enables

;       DSP Status Register Bit Flags
 
M_HCP    EQU     0               ; Host Command pending
M_STRQ   EQU     1               ; Slave Transmit Data Request
M_SRRQ   EQU     2               ; Slave Receive Data Request
M_HF02   EQU     $38             ; Host Flag 0-2 Mask
M_HF0    EQU     3               ; Host Flag 0
M_HF1    EQU     4               ; Host Flag 1
M_HF2    EQU     5               ; Host Flag 2

;       DSP PCI Status Register Bit Flags

M_MWS    EQU    0               ; PCI Master Wait States
M_MTRQ   EQU    1               ; PCI Master Transmit Data Request
M_MRRQ   EQU    2               ; PCI Master Receive Data Request
M_MARQ   EQU    4               ; PCI Master Address Request
M_APER   EQU    5               ; PCI Address Parity Error
M_DPER   EQU    6               ; PCI Data Parity Error
M_MAB    EQU    7               ; PCI Master Abort
M_TAB    EQU    8               ; PCI Target Abort
M_TDIS   EQU    9               ; PCI Target Disconnect
M_TRTY   EQU    10              ; PCI Target Retry
M_TO     EQU    11              ; PCI Time Out Termination
M_RDC    EQU    $3F0000         ; Remaining Data Count Mask (RDC5-RDC0)
M_RDC0   EQU    16              ; Remaining Data Count  0
M_RDC1   EQU    17              ; Remaining Data Count  1
M_RDC2   EQU    18              ; Remaining Data Count  2
M_RDC3   EQU    19              ; Remaining Data Count  3
M_RDC4   EQU    20              ; Remaining Data Count  4
M_RDC5   EQU    21              ; Remaining Data Count  5
M_HACT   EQU    23              ; Hi32 Active


;------------------------------------------------------------------------
;
;       EQUATES for Serial Communications Interface (SCI)
;
;------------------------------------------------------------------------

;       Register Addresses

M_STXH   EQU     $FFFF97         ; SCI Transmit Data Register (high)
M_STXM   EQU     $FFFF96         ; SCI Transmit Data Register (middle)
M_STXL   EQU     $FFFF95         ; SCI Transmit Data Register (low)
M_SRXH   EQU     $FFFF9A         ; SCI Receive Data Register (high)
M_SRXM   EQU     $FFFF99         ; SCI Receive Data Register (middle)
M_SRXL   EQU     $FFFF98         ; SCI Receive Data Register (low)
M_STXA   EQU     $FFFF94         ; SCI Transmit Address Register
M_SCR    EQU     $FFFF9C         ; SCI Control Register
M_SSR    EQU     $FFFF93         ; SCI Status Register
M_SCCR   EQU     $FFFF9B         ; SCI Clock Control Register

;       SCI Control Register Bit Flags

M_WDS    EQU     $7              ; Word Select Mask (WDS0-WDS3)
M_WDS0   EQU     0               ; Word Select 0
M_WDS1   EQU     1               ; Word Select 1
M_WDS2   EQU     2               ; Word Select 2
M_SSFTD  EQU     3               ; SCI Shift Direction 
M_SBK    EQU     4               ; Send Break
M_WAKE   EQU     5               ; Wakeup Mode Select
M_RWU    EQU     6               ; Receiver Wakeup Enable
M_WOMS   EQU     7               ; Wired-OR Mode Select
M_SCRE   EQU     8               ; SCI Receiver Enable
M_SCTE   EQU     9               ; SCI Transmitter Enable
M_ILIE   EQU     10              ; Idle Line Interrupt Enable
M_SCRIE  EQU     11              ; SCI Receive Interrupt Enable
M_SCTIE  EQU     12              ; SCI Transmit Interrupt Enable
M_TMIE   EQU     13              ; Timer Interrupt Enable
M_TIR    EQU     14              ; Timer Interrupt Rate
M_SCKP   EQU     15              ; SCI Clock Polarity
M_REIE   EQU     16              ; SCI Error Interrupt Enable (REIE)

;       SCI Status Register Bit Flags

M_TRNE   EQU     0               ; Transmitter Empty
M_TDRE   EQU     1               ; Transmit Data Register Empty
M_RDRF   EQU     2               ; Receive Data Register Full
M_IDLE   EQU     3               ; Idle Line Flag
M_OR     EQU     4               ; Overrun Error Flag 
M_PE     EQU     5               ; Parity Error
M_FE     EQU     6               ; Framing Error Flag
M_R8     EQU     7               ; Received Bit 8 (R8) Address

;       SCI Clock Control Register 

M_CD     EQU     $FFF            ; Clock Divider Mask (CD0-CD11)
M_COD    EQU     12              ; Clock Out Divider
M_SCP    EQU     13              ; Clock Prescaler
M_RCM    EQU     14              ; Receive Clock Mode Source Bit
M_TCM    EQU     15              ; Transmit Clock Source Bit

;------------------------------------------------------------------------
;
;       EQUATES for Enhanced Synchronous Serial Interface (ESSI)
;
;------------------------------------------------------------------------

;
;       Register Addresses Of ESSI0 
M_TX00   EQU     $FFFFBC         ; ESSI0 Transmit Data Register 0
M_TX01   EQU     $FFFFBB         ; ESSIO Transmit Data Register 1
M_TX02   EQU     $FFFFBA         ; ESSIO Transmit Data Register 2
M_TSR0   EQU     $FFFFB9         ; ESSI0 Time Slot Register
M_RX0    EQU     $FFFFB8         ; ESSI0 Receive Data Register
M_SSISR0 EQU     $FFFFB7         ; ESSI0 Status Register
M_CRB0   EQU     $FFFFB6         ; ESSI0 Control Register B
M_CRA0   EQU     $FFFFB5         ; ESSI0 Control Register A
M_TSMA0  EQU     $FFFFB4         ; ESSI0 Transmit Slot Mask Register A
M_TSMB0  EQU     $FFFFB3         ; ESSI0 Transmit Slot Mask Register B
M_RSMA0  EQU     $FFFFB2         ; ESSI0 Receive Slot Mask Register A
M_RSMB0  EQU     $FFFFB1         ; ESSI0 Receive Slot Mask Register B

;       Register Addresses Of ESSI1                                        
M_TX10   EQU     $FFFFAC         ; ESSI1 Transmit Data Register 0
M_TX11   EQU     $FFFFAB         ; ESSI1 Transmit Data Register 1
M_TX12   EQU     $FFFFAA         ; ESSI1 Transmit Data Register 2
M_TSR1   EQU     $FFFFA9         ; ESSI1 Time Slot Register
M_RX1    EQU     $FFFFA8         ; ESSI1 Receive Data Register
M_SSISR1 EQU     $FFFFA7         ; ESSI1 Status Register
M_CRB1   EQU     $FFFFA6         ; ESSI1 Control Register B
M_CRA1   EQU     $FFFFA5         ; ESSI1 Control Register A
M_TSMA1  EQU     $FFFFA4         ; ESSI1 Transmit Slot Mask Register A
M_TSMB1  EQU     $FFFFA3         ; ESSI1 Transmit Slot Mask Register B
M_RSMA1  EQU     $FFFFA2         ; ESSI1 Receive Slot Mask Register A
M_RSMB1  EQU     $FFFFA1         ; ESSI1 Receive Slot Mask Register B

;       ESSI Control Register A Bit Flags

M_PM     EQU     $FF             ; Prescale Modulus Select Mask (PM0-PM7)              
M_PSR    EQU     11              ; Prescaler Range       
M_DC     EQU     $1F000          ; Frame Rate Divider Control Mask (DC0-DC7)
M_ALC    EQU     18	         ; Alignment Control (ALC)
M_WL     EQU     $380000         ; Word Length Control Mask (WL0-WL7)
M_SSC1   EQU     22	         ; Select SC1 as TR #0 drive enable (SSC1)

;       ESSI Control Register B Bit Flags                                   

M_OF     EQU     $3              ; Serial Output Flag Mask
M_OF0    EQU     0               ; Serial Output Flag 0                     
M_OF1    EQU     1               ; Serial Output Flag 1                     
M_SCD    EQU     $1C             ; Serial Control Direction Mask            
M_SCD0   EQU     2               ; Serial Control 0 Direction                
M_SCD1   EQU     3               ; Serial Control 1 Direction               
M_SCD2   EQU     4               ; Serial Control 2 Direction               
M_SCKD   EQU     5               ; Clock Source Direction
M_SHFD   EQU     6               ; Shift Direction                          
M_FSL    EQU     $180            ; Frame Sync Length Mask (FSL0-FSL1)
M_FSL0   EQU     7               ; Frame Sync Length 0
M_FSL1   EQU     8               ; Frame Sync Length 1
M_FSR    EQU     9               ; Frame Sync Relative Timing
M_FSP    EQU     10              ; Frame Sync Polarity
M_CKP    EQU     11              ; Clock Polarity                           
M_SYN    EQU     12              ; Sync/Async Control                       
M_MOD    EQU     13              ; ESSI Mode Select
M_SSTE   EQU     $1C000          ; ESSI Transmit enable Mask                  
M_SSTE2  EQU     14              ; ESSI Transmit #2 Enable                   
M_SSTE1  EQU     15              ; ESSI Transmit #1 Enable                    
M_SSTE0  EQU     16              ; ESSI Transmit #0 Enable                    
M_SSRE   EQU     17              ; ESSI Receive Enable                       
M_SSTIE  EQU     18              ; ESSI Transmit Interrupt Enable            
M_SSRIE  EQU     19              ; ESSI Receive Interrupt Enable              
M_STLIE  EQU     20              ; ESSI Transmit Last Slot Interrupt Enable 
M_SRLIE  EQU     21              ; ESSI Receive Last Slot Interrupt Enable 
M_STEIE  EQU     22              ; ESSI Transmit Error Interrupt Enable 
M_SREIE  EQU     23              ; ESSI Receive Error Interrupt Enable              

;       ESSI Status Register Bit Flags                                       

M_IF     EQU     $3              ; Serial Input Flag Mask           
M_IF0    EQU     0               ; Serial Input Flag 0                      
M_IF1    EQU     1               ; Serial Input Flag 1                      
M_TFS    EQU     2               ; Transmit Frame Sync Flag                 
M_RFS    EQU     3               ; Receive Frame Sync Flag                  
M_TUE    EQU     4               ; Transmitter Underrun Error FLag          
M_ROE    EQU     5               ; Receiver Overrun Error Flag              
M_TDE    EQU     6               ; Transmit Data Register Empty             
M_RDF    EQU     7               ; Receive Data Register Full

;       ESSI Transmit Slot Mask Register A

M_SSTSA  EQU     $FFFF           ; ESSI Transmit Slot Bits Mask A (TS0-TS15)

;       ESSI Transmit Slot Mask Register B

M_SSTSB  EQU     $FFFF           ; ESSI Transmit Slot Bits Mask B (TS16-TS31)

;       ESSI Receive Slot Mask Register A

M_SSRSA  EQU     $FFFF           ; ESSI Receive Slot Bits Mask A (RS0-RS15)
 
;       ESSI Receive Slot Mask Register B

M_SSRSB  EQU     $FFFF           ; ESSI Receive Slot Bits Mask B (RS16-RS31)

              

;------------------------------------------------------------------------
;
;       EQUATES for Exception Processing                                    
;
;------------------------------------------------------------------------


;       Register Addresses

M_IPRC   EQU     $FFFFFF         ; Interrupt Priority Register Core
M_IPRP   EQU     $FFFFFE         ; Interrupt Priority Register Peripheral

;       Interrupt Priority Register Core (IPRC) 

M_IAL    EQU     $7              ; IRQA Mode Mask
M_IAL0   EQU     0               ; IRQA Mode Interrupt Priority Level (low)
M_IAL1   EQU     1               ; IRQA Mode Interrupt Priority Level (high)
M_IAL2   EQU     2               ; IRQA Mode Trigger Mode
M_IBL    EQU     $38             ; IRQB Mode Mask
M_IBL0   EQU     3               ; IRQB Mode Interrupt Priority Level (low)
M_IBL1   EQU     4               ; IRQB Mode Interrupt Priority Level (high)
M_IBL2   EQU     5               ; IRQB Mode Trigger Mode
M_ICL    EQU     $1C0            ; IRQC Mode Mask
M_ICL0   EQU     6               ; IRQC Mode Interrupt Priority Level (low)
M_ICL1   EQU     7               ; IRQC Mode Interrupt Priority Level (high)
M_ICL2   EQU     8               ; IRQC Mode Trigger Mode
M_IDL    EQU     $E00            ; IRQD Mode Mask
M_IDL0   EQU     9               ; IRQD Mode Interrupt Priority Level (low)
M_IDL1   EQU     10              ; IRQD Mode Interrupt Priority Level (high)
M_IDL2   EQU     11              ; IRQD Mode Trigger Mode
M_D0L    EQU     $3000           ; DMA0 Interrupt priority Level Mask
M_D0L0   EQU     12              ; DMA0 Interrupt Priority Level (low)
M_D0L1   EQU     13              ; DMA0 Interrupt Priority Level (high)
M_D1L    EQU     $C000           ; DMA1 Interrupt Priority Level Mask
M_D1L0   EQU     14              ; DMA1 Interrupt Priority Level (low)
M_D1L1   EQU     15              ; DMA1 Interrupt Priority Level (high)
M_D2L    EQU     $30000          ; DMA2 Interrupt priority Level Mask
M_D2L0   EQU     16              ; DMA2 Interrupt Priority Level (low)
M_D2L1   EQU     17              ; DMA2 Interrupt Priority Level (high)
M_D3L    EQU     $C0000          ; DMA3 Interrupt Priority Level Mask
M_D3L0   EQU     18              ; DMA3 Interrupt Priority Level (low)
M_D3L1   EQU     19              ; DMA3 Interrupt Priority Level (high)
M_D4L    EQU     $300000         ; DMA4 Interrupt priority Level Mask
M_D4L0   EQU     20              ; DMA4 Interrupt Priority Level (low)
M_D4L1   EQU     21              ; DMA4 Interrupt Priority Level (high)
M_D5L    EQU     $C00000         ; DMA5 Interrupt priority Level Mask
M_D5L0   EQU     22              ; DMA5 Interrupt Priority Level (low)
M_D5L1   EQU     23              ; DMA5 Interrupt Priority Level (high)


;       Interrupt Priority Register Peripheral (IPRP)

M_HPL    EQU     $3              ; Host Interrupt Priority Level Mask
M_HPL0   EQU     0               ; Host Interrupt Priority Level (low)
M_HPL1   EQU     1               ; Host Interrupt Priority Level (high)
M_S0L    EQU     $C              ; ESSI0 Interrupt Priority Level Mask
M_S0L0   EQU     2               ; ESSI0 Interrupt Priority Level (low)
M_S0L1   EQU     3               ; ESSI0 Interrupt Priority Level (high)
M_S1L    EQU     $30             ; ESSI1 Interrupt Priority Level Mask
M_S1L0   EQU     4               ; ESSI1 Interrupt Priority Level (low)
M_S1L1   EQU     5               ; ESSI1 Interrupt Priority Level (high)
M_SCL    EQU     $C0             ; SCI  Interrupt Priority Level  Mask       
M_SCL0   EQU     6               ; SCI  Interrupt Priority Level  (low)
M_SCL1   EQU     7               ; SCI  Interrupt Priority Level  (high)
M_T0L    EQU     $300            ; TIMER Interrupt Priority Level Mask
M_T0L0   EQU     8               ; TIMER Interrupt Priority Level (low)
M_T0L1   EQU     9               ; TIMER Interrupt Priority Level (high)


;------------------------------------------------------------------------
;
;       EQUATES for TIMER 
;
;------------------------------------------------------------------------

;       Register Addresses Of TIMER0

M_TCSR0  EQU     $FFFF8F         ; TIMER0 Control/Status Register            
M_TLR0	 EQU	 $FFFF8E	 ; TIMER0 Load Reg   
M_TCPR0  EQU     $FFFF8D         ; TIMER0 Compare Register
M_TCR0	 EQU	 $FFFF8C 	 ; TIMER0 Count Register

;       Register Addresses Of TIMER1

M_TCSR1  EQU     $FFFF8B         ; TIMER1 Control/Status Register            
M_TLR1	 EQU	 $FFFF8A	 ; TIMER1 Load Reg   
M_TCPR1  EQU     $FFFF89         ; TIMER1 Compare Register
M_TCR1	 EQU	 $FFFF88	 ; TIMER1 Count Register


;       Register Addresses Of TIMER2

M_TCSR2  EQU     $FFFF87         ; TIMER2 Control/Status Register            
M_TLR2	 EQU	 $FFFF86	 ; TIMER2 Load Reg   
M_TCPR2  EQU     $FFFF85         ; TIMER2 Compare Register
M_TCR2	 EQU	 $FFFF84	 ; TIMER2 Count Register
M_TPLR	 EQU	 $FFFF83	 ; TIMER Prescaler Load Register
M_TPCR	 EQU	 $FFFF82	 ; TIMER Prescalar Count Register


;       Timer Control/Status Register Bit Flags                                        

M_TE     EQU     0               ; Timer Enable 
M_TOIE   EQU     1               ; Timer Overflow Interrupt Enable
M_TCIE   EQU     2               ; Timer Compare Interrupt Enable
M_TC     EQU     $F0             ; Timer Control Mask (TC0-TC3)
M_INV    EQU     8               ; Inverter Bit
M_TRM    EQU     9               ; Timer Restart Mode 
M_DIR    EQU     11              ; Direction Bit
M_DI     EQU     12              ; Data Input
M_DO     EQU     13              ; Data Output
M_PCE	 EQU	 15		 ; Prescaled Clock Enable
M_TOF    EQU     20              ; Timer Overflow Flag
M_TCF    EQU     21              ; Timer Compare Flag 

;       Timer Prescaler Register Bit Flags                                        

M_PS	EQU	 $600000 	 ; Prescaler Source Mask
M_PS0	EQU	 21
M_PS1	EQU	 22

;	Timer Control Bits
M_TC0    EQU     4               ; Timer Control 0
M_TC1    EQU     5               ; Timer Control 1
M_TC2    EQU     6               ; Timer Control 2
M_TC3    EQU     7               ; Timer Control 3


;------------------------------------------------------------------------
;
;       EQUATES for Direct Memory Access (DMA)                                 
;
;------------------------------------------------------------------------

;       Register Addresses Of DMA
M_DSTR	 EQU	$FFFFF4		; DMA Status Register
M_DOR0   EQU     $FFFFF3         ; DMA Offset Register 0
M_DOR1   EQU     $FFFFF2         ; DMA Offset Register 1
M_DOR2   EQU     $FFFFF1         ; DMA Offset Register 2
M_DOR3   EQU     $FFFFF0         ; DMA Offset Register 3


;       Register Addresses Of DMA0

M_DSR0   EQU     $FFFFEF         ; DMA0 Source Address Register
M_DDR0   EQU     $FFFFEE         ; DMA0 Destination Address Register 
M_DCO0   EQU     $FFFFED         ; DMA0 Counter
M_DCR0   EQU     $FFFFEC         ; DMA0 Control Register 

;       Register Addresses Of DMA1

M_DSR1   EQU     $FFFFEB         ; DMA1 Source Address Register
M_DDR1   EQU     $FFFFEA         ; DMA1 Destination Address Register 
M_DCO1   EQU     $FFFFE9         ; DMA1 Counter
M_DCR1   EQU     $FFFFE8         ; DMA1 Control Register

;       Register Addresses Of DMA2

M_DSR2   EQU     $FFFFE7         ; DMA2 Source Address Register
M_DDR2   EQU     $FFFFE6         ; DMA2 Destination Address Register 
M_DCO2   EQU     $FFFFE5         ; DMA2 Counter
M_DCR2   EQU     $FFFFE4         ; DMA2 Control Register
 
;       Register Addresses Of DMA4

M_DSR3   EQU     $FFFFE3         ; DMA3 Source Address Register
M_DDR3   EQU     $FFFFE2         ; DMA3 Destination Address Register 
M_DCO3   EQU     $FFFFE1         ; DMA3 Counter
M_DCR3   EQU     $FFFFE0         ; DMA3 Control Register

;       Register Addresses Of DMA4


M_DSR4   EQU     $FFFFDF         ; DMA4 Source Address Register
M_DDR4   EQU     $FFFFDE         ; DMA4 Destination Address Register 
M_DCO4   EQU     $FFFFDD         ; DMA4 Counter
M_DCR4   EQU     $FFFFDC         ; DMA4 Control Register 

;       Register Addresses Of DMA5

M_DSR5   EQU     $FFFFDB         ; DMA5 Source Address Register
M_DDR5   EQU     $FFFFDA         ; DMA5 Destination Address Register 
M_DCO5   EQU     $FFFFD9         ; DMA5 Counter
M_DCR5   EQU     $FFFFD8         ; DMA5 Control Register

;	DMA Control Register

M_DSS	 EQU	$3		; DMA Source Space Mask (DSS0-Dss1)
M_DSS0	 EQU	0		; DMA Source Memory space 0
M_DSS1	 EQU	1		; DMA Source Memory space 1	
M_DDS	 EQU	$C		; DMA Destination Space Mask (DDS-DDS1)
M_DDS0	 EQU	2		; DMA Destination Memory Space 0
M_DDS1	 EQU	3		; DMA Destination Memory Space 1
M_DAM	 EQU	$3f0		; DMA Address Mode Mask (DAM5-DAM0)
M_DAM0 	 EQU	4		; DMA Address Mode 0
M_DAM1 	 EQU	5		; DMA Address Mode 1
M_DAM2 	 EQU	6		; DMA Address Mode 2
M_DAM3 	 EQU	7		; DMA Address Mode 3
M_DAM4 	 EQU	8		; DMA Address Mode 4
M_DAM5 	 EQU	9		; DMA Address Mode 5
M_D3D	 EQU 	10		; DMA Three Dimensional Mode
M_DRS	 EQU	$F800		; DMA Request Source Mask (DRS0-DRS4)
M_DCON	 EQU	16		; DMA Continuous Mode
M_DPR	 EQU	$60000		; DMA Channel Priority
M_DPR0	 EQU	17		; DMA Channel Priority Level (low)
M_DPR1	 EQU	18		; DMA Channel Priority Level (high)
M_DTM	 EQU	$380000		; DMA Transfer Mode Mask (DTM2-DTM0)
M_DTM0	 EQU	19		; DMA Transfer Mode 0
M_DTM1	 EQU	20		; DMA Transfer Mode 1
M_DTM2	 EQU	21		; DMA Transfer Mode 2
M_DIE	 EQU	22		; DMA Interrupt Enable bit
M_DE	 EQU	23		; DMA Channel Enable bit 

;       DMA Status Register

M_DTD	 EQU	$3F		; Channel Transfer Done Status MASK (DTD0-DTD5)
M_DTD0   EQU     0               ; DMA Channel Transfer Done Status 0
M_DTD1   EQU     1               ; DMA Channel Transfer Done Status 1
M_DTD2   EQU     2               ; DMA Channel Transfer Done Status 2
M_DTD3   EQU     3               ; DMA Channel Transfer Done Status 3
M_DTD4   EQU     4               ; DMA Channel Transfer Done Status 4
M_DTD5   EQU     5               ; DMA Channel Transfer Done Status 5
M_DACT	 EQU	 8		 ; DMA Active State
M_DCH	 EQU	 $E00		 ; DMA Active Channel Mask (DCH0-DCH2)
M_DCH0	 EQU	 9		 ; DMA Active Channel 0
M_DCH1	 EQU	 10		 ; DMA Active Channel 1
M_DCH2	 EQU	 11	 	 ; DMA Active Channel 2


;------------------------------------------------------------------------
;
;       EQUATES for Phase Locked Loop (PLL) 
;
;------------------------------------------------------------------------

;       Register Addresses Of PLL

M_PCTL   EQU     $FFFFFD         ; PLL Control Register

;       PLL Control Register

M_MF     EQU     $FFF            ; Multiplication Factor Bits Mask (MF0-MF11)
M_DF     EQU     $7000           ; Division Factor Bits Mask (DF0-DF2)
M_XTLR   EQU     15              ; XTAL Range select bit
M_XTLD   EQU     16              ; XTAL Disable Bit
M_PSTP   EQU     17              ; STOP Processing State Bit 
M_PEN    EQU     18              ; PLL Enable Bit
M_PCOD   EQU     19              ; PLL Clock Output Disable Bit
M_PD	 EQU	$F00000		; PreDivider Factor Bits Mask (PD0-PD3)


;------------------------------------------------------------------------
;
;       EQUATES for BIU 
;
;------------------------------------------------------------------------

;       Register Addresses Of BIU


M_BCR    EQU     $FFFFFB         ; Bus Control Register
M_DCR    EQU     $FFFFFA         ; DRAM Control Register
M_AAR0   EQU     $FFFFF9         ; Address Attribute Register 0 
M_AAR1   EQU     $FFFFF8         ; Address Attribute Register 1 
M_AAR2   EQU     $FFFFF7         ; Address Attribute Register 2 
M_AAR3   EQU     $FFFFF6         ; Address Attribute Register 3 
M_IDR	 EQU	$FFFFF5		; ID Register

;       Bus Control Register

M_BA0W   EQU     $1F             ; Area 0 Wait Control Mask (BA0W0-BA0W4)
M_BA1W   EQU     $3E0            ; Area 1 Wait Control Mask (BA1W0-BA14)
M_BA2W   EQU     $1C00           ; Area 2 Wait Control Mask (BA2W0-BA2W2)
M_BA3W   EQU     $E000           ; Area 3 Wait Control Mask (BA3W0-BA3W3)
M_BDFW   EQU     $1F0000         ; Default Area Wait Control Mask (BDFW0-BDFW4)
M_BBS    EQU     21              ; Bus State
M_BLH    EQU     22              ; Bus Lock Hold
M_BRH    EQU     23              ; Bus Request Hold

;       DRAM Control Register

M_BCW    EQU     $3              ; In Page Wait States Bits Mask (BCW0-BCW1)
M_BRW    EQU     $C              ; Out Of Page Wait States Bits Mask (BRW0-BRW1)
M_BPS    EQU     $300            ; DRAM Page Size Bits Mask (BPS0-BPS1)
M_BPLE   EQU     11              ; Page Logic Enable
M_BME    EQU     12              ; Mastership Enable
M_BRE    EQU     13              ; Refresh Enable
M_BSTR   EQU     14              ; Software Triggered Refresh
M_BRF    EQU     $7F8000         ; Refresh Rate Bits Mask (BRF0-BRF7)
M_BRP    EQU     23              ; Refresh prescaler

;       Address Attribute Registers

M_BAT    EQU     $3              ; External Access Type and Pin Definition Bits Mask (BAT0-BAT1)
M_BAAP   EQU     2               ; Address Attribute Pin Polarity
M_BPEN   EQU     3               ; Program Space Enable
M_BXEN   EQU     4               ; X Data Space Enable
M_BYEN   EQU     5               ; Y Data Space Enable
M_BAM    EQU     6               ; Address Muxing
M_BPAC 	 EQU	 7		 ; Packing Enable
M_BNC    EQU     $F00            ; Number of Address Bits to Compare Mask (BNC0-BNC3)
M_BAC    EQU     $FFF000         ; Address to Compare Bits Mask (BAC0-BAC11)

;       control and status bits in SR

M_CP	EQU	$c00000          ; mask for CORE-DMA priority bits in SR
M_CA    equ     0                ; Carry
M_V     equ     1                ; Overflow      
M_Z     equ     2                ; Zero
M_N     equ     3                ; Negative      
M_U     equ     4                ; Unnormalized
M_E     equ     5                ; Extension     
M_L     equ     6                ; Limit
M_S     equ     7                ; Scaling Bit   
M_I0    equ     8                ; Interupt Mask Bit 0
M_I1    equ     9                ; Interupt Mask Bit 1
M_S0    equ     10               ; Scaling Mode Bit 0
M_S1    equ     11               ; Scaling Mode Bit 1
M_SC    equ     13               ; Sixteen_Bit Compatibility
M_DM    equ     14               ; Double Precision Multiply
M_LF    equ     15               ; DO-Loop Flag
M_FV    equ     16               ; DO-Forever Flag
M_SA    equ     17               ; Sixteen-Bit Arithmetic
M_CE    equ     19               ; Instruction Cache Enable
M_SM    equ     20               ; Arithmetic Saturation
M_RM    equ     21               ; Rounding Mode
M_CP0	EQU	22               ; bit 0 of priority bits in SR
M_CP1   EQU     23               ; bit 1 of priority bits in SR

;       control and status bits in OMR
M_CDP	EQU	$300             ; mask for CORE-DMA priority bits in OMR
M_MA    equ     0                ; Operating Mode A
M_MB   equ      1                ; Operating Mode B
M_MC    equ     2                ; Operating Mode C
M_MD    equ     3                ; Operating Mode D
M_EBD   equ     4                ; External Bus Disable bit in OMR
M_SD    equ     6                ; Stop Delay  
M_CDP0	EQU	8                ; bit 0 of priority bits in OMR
M_CDP1	EQU	9                ; bit 1 of priority bits in OMR
M_BEN   EQU     10               ; Burst Enable 
M_TAS   EQU     11               ; TA Synchronize Select
M_BRT   EQU     12               ; Bus Release Timing 
M_XYS   equ     16               ; Stack Extension space select bit in OMR.
M_EUN   equ     17               ; Extensed stack UNderflow flag in OMR.
M_EOV   equ     18               ; Extended stack OVerflow flag in OMR.
M_WRP   equ     19               ; Extended WRaP flag in OMR.
M_SEN   equ     20               ; Stack Extension Enable bit in OMR.




;*********************************************************************************
;
;     EQUATES for 56301 interrupts
;     Reference: 56301 Specifications Revision 3.00 
;
;     Last update: August   16 1994
;
;*********************************************************************************

	page	132,55,0,0,0
	opt	mex

intequ  ident   1,0

	if	@DEF(I_VEC)
	;leave user definition as is.
	else
I_VEC	equ	$0
	endif

;------------------------------------------------------------------------
; Non-Maskable interrupts
;------------------------------------------------------------------------
I_RESET  EQU  I_VEC+$00   ; Hardware RESET
I_STACK  EQU  I_VEC+$02   ; Stack Error
I_ILL    EQU  I_VEC+$04   ; Illegal Instruction
I_DBG    EQU  I_VEC+$06   ; Debug Request      
I_TRAP   EQU  I_VEC+$08   ; Trap
I_NMI    EQU  I_VEC+$0A   ; Non Maskable Interrupt

;------------------------------------------------------------------------
; Interrupt Request Pins
;------------------------------------------------------------------------
I_IRQA   EQU  I_VEC+$10   ; IRQA
I_IRQB   EQU  I_VEC+$12   ; IRQB
I_IRQC   EQU  I_VEC+$14   ; IRQC
I_IRQD   EQU  I_VEC+$16   ; IRQD

;------------------------------------------------------------------------
; DMA Interrupts
;------------------------------------------------------------------------
I_DMA0   EQU  I_VEC+$18   ; DMA Channel 0
I_DMA1   EQU  I_VEC+$1A   ; DMA Channel 1
I_DMA2   EQU  I_VEC+$1C   ; DMA Channel 2
I_DMA3   EQU  I_VEC+$1E   ; DMA Channel 3
I_DMA4   EQU  I_VEC+$20   ; DMA Channel 4
I_DMA5   EQU  I_VEC+$22   ; DMA Channel 5

;------------------------------------------------------------------------
; Timer Interrupts
;------------------------------------------------------------------------
I_TIM0C  EQU  I_VEC+$24   ; TIMER 0 compare
I_TIM0OF EQU  I_VEC+$26   ; TIMER 0 overflow
I_TIM1C  EQU  I_VEC+$28   ; TIMER 1 compare
I_TIM1OF EQU  I_VEC+$2A   ; TIMER 1 overflow
I_TIM2C  EQU  I_VEC+$2C   ; TIMER 2 compare
I_TIM2OF EQU  I_VEC+$2E   ; TIMER 2 overflow

;------------------------------------------------------------------------
; ESSI Interrupts
;------------------------------------------------------------------------
I_SI0RD  EQU  I_VEC+$30   ; ESSI0 Receive Data
I_SI0RDE EQU  I_VEC+$32   ; ESSI0 Receive Data With Exception Status
I_SI0RLS EQU  I_VEC+$34   ; ESSI0 Receive last slot
I_SI0TD  EQU  I_VEC+$36   ; ESSI0 Transmit data
I_SI0TDE EQU  I_VEC+$38   ; ESSI0 Transmit Data With Exception Status
I_SI0TLS EQU  I_VEC+$3A   ; ESSI0 Transmit last slot
I_SI1RD  EQU  I_VEC+$40   ; ESSI1 Receive Data
I_SI1RDE EQU  I_VEC+$42   ; ESSI1 Receive Data With Exception Status
I_SI1RLS EQU  I_VEC+$44   ; ESSI1 Receive last slot
I_SI1TD  EQU  I_VEC+$46   ; ESSI1 Transmit data
I_SI1TDE EQU  I_VEC+$48   ; ESSI1 Transmit Data With Exception Status
I_SI1TLS EQU  I_VEC+$4A   ; ESSI1 Transmit last slot

;------------------------------------------------------------------------
; SCI Interrupts
;------------------------------------------------------------------------
I_SCIRD  EQU  I_VEC+$50   ; SCI Receive Data 
I_SCIRDE EQU  I_VEC+$52   ; SCI Receive Data With Exception Status
I_SCITD  EQU  I_VEC+$54   ; SCI Transmit Data
I_SCIIL  EQU  I_VEC+$56   ; SCI Idle Line
I_SCITM  EQU  I_VEC+$58   ; SCI Timer

;------------------------------------------------------------------------
; HOST Interrupts
;------------------------------------------------------------------------
I_HPTT   EQU  I_VEC+$60   ; Host PCI Transaction Termination
I_HPTA   EQU  I_VEC+$62   ; Host PCI Transaction Abort
I_HPPE   EQU  I_VEC+$64   ; Host PCI Parity Error
I_HPTC   EQU  I_VEC+$66   ; Host PCI Transfer Complete
I_HPMR   EQU  I_VEC+$68   ; Host PCI Master Receive
I_HSR    EQU  I_VEC+$6A   ; Host Slave Receive
I_HPMT   EQU  I_VEC+$6C   ; Host PCI Master Transmit
I_HST    EQU  I_VEC+$6E   ; Host Slave Transmit
I_HPMA   EQU  I_VEC+$70   ; Host PCI Master Address
I_HCNMI  EQU  I_VEC+$72   ; Host Command/Host NMI (Default)

;------------------------------------------------------------------------
; INTERRUPT ENDING ADDRESS
;------------------------------------------------------------------------
I_INTEND EQU  I_VEC+$FF   ; last address of interrupt vector space
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\sysmem.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			sysmem.asm
;												
;   Contents:		Game Encoder System memory Simulator
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/9/2000 5:46:11 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'System Memory'

	section	Sysmem

;**** include files ************************************************

	nolist
	include 'ldr_sip.inc'
	include 'se_sip.inc'
	list

;**** equates ******************************************************

SYSMEM_HEAP_SIZE		equ		8192
AC3_OUT_BUFF_SIZE		equ		3072
PCM_LTRT_OUT_BUFF_SIZE	equ		512
PCM_IN_BUFF_SIZE		equ		1536

;**** program code *************************************************

	org		x(100):

SysLdrTable:
	dc		LDR_SYSTABLE_SIZE		; table size
	dc		LID_MAX_PROG			; number of programs
	dc		prog_1_ptr				; pointer to program #1
	dc		prog_1_size				; size of program #1
	dc		prog_2_ptr				; pointer to program #2
	dc		prog_2_size				; size of program #2
	dc		prog_3_ptr				; pointer to program #3
	dc		prog_3_size				; size of program #3
	dc		prog_4_ptr				; pointer to program #4
	dc		prog_4_size				; size of program #4
	dc		pcm_ptr					; pointer to input PCM buffer
	dc		pcm_size				; size of input PCM buffer
	dc		ltrt_ptr				; pointer to output Lt/Rt buffer
	dc		ltrt_size				; size of output Lt/Rt buffer
	dc		ac3_ptr					; pointer to output AC-3 buffer
	dc		ac3_size				; size of output AC-3 buffer
	dc		config_ptr				; configuration data pointer
	dc		config_size				; configuration data size
	dc		heap_ptr				; pointer to heap data buffer
	dc		heap_size				; size of heap data buffer

prog_1_ptr:
	nolist
	include 'encds.asm'				; Dolby Surround Program Code
	list
prog_1_size	equ		(*)-prog_1_ptr

prog_2_ptr:
	nolist
	include 'llef13.asm'			; Game Encoder Fcn 1 Program Code
	list
prog_2_size	equ		(*)-prog_2_ptr

prog_3_ptr:
	nolist
	include 'llef23.asm'			; Game Encoder Fcn 2 Program Code
	list
prog_3_size	equ		(*)-prog_3_ptr

prog_4_ptr:
	nolist
	include 'llef33.asm'			; Game Encoder Fcn 3 Program Code
	list
prog_4_size	equ		(*)-prog_4_ptr

	org		x(101):

pcm_ptr		ds		PCM_IN_BUFF_SIZE		; PCM Input Buffer
pcm_size	equ		(*)-pcm_ptr

	org		x(102):

ltrt_ptr	ds		PCM_LTRT_OUT_BUFF_SIZE	; PCM Lt/Rt Output Buuffer
ltrt_size	equ		(*)-ltrt_ptr

	org		x(103):

ac3_ptr		bsc		AC3_OUT_BUFF_SIZE,0		; AC-3 Output Buffer
ac3_size	equ		(*)-ac3_ptr

	org		x(104):

config_ptr:
	nolist
	include 'lleconfg.asm'					; System Configuration data
	list
config_size	equ		(*)-config_ptr

	org		x(105):

heap_ptr	ds		SYSMEM_HEAP_SIZE		; Heap
heap_size	equ		(*)-heap_ptr

	org		y(301):
	nolist	
	include 'lleyrom.asm'					; Game Encoder ROM
	list	

;**** program code *************************************************

	endsec	; Sysmem
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\AmpMod.asm ===
;***********************************************************************
;
; AmpMod.asm    Amplitude Modulation by Waveform-Selectable Oscillator
;
;***********************************************************************        

        IF @DEF('STANDALONE')
        include "util.h"
        ENDIF

	include 'AmpMod.h'

        ;
        ; worst case cycle usage by this effect (includes one time Init)
        ; stereo: 7580 cycles
        ; mono: 3781 
        ;


StartAmpMod 
; Data structure pointer already loaded into rD

        FXEntryPoint

ComputeFX

	bsr	ComputeAmpMod

        IF @DEF('STEREO')
        FXStereoComputeRightChannel
        ENDIF

        FXExit

;************************************************************
; ComputeAmpMod
;************************************************************
ComputeFXSubroutine
ComputeAmpMod
; rD points to Data Structure 



        ; Add bias to oscillator signal before modulation
        ; r0 = audio input
        ; r1 = audio out
        ; r2 = oscillator output(3 input to this fx..)

        IF @DEF('STEREO')

        move    x:(rD+FX_STATE_FLAGS),x0       
        brset   #BIT_FX_STATE_FLAG_PROCESS_STEREO,x0,SETUP_RIGHT_CHANNEL

	move	x:(rD+FX_STATE_IO3_IN0),r0
	move	x:(rD+FX_STATE_IO3_OUT0),r1
        bra     ComputeAmpMod_StartLoop

SETUP_RIGHT_CHANNEL
	move	x:(rD+FX_STATE_IO3_IN1),r0
	move	x:(rD+FX_STATE_IO3_OUT1),r1
        ELSE
        ;
        ; mono case
        ;
	move	x:(rD+FX_STATE_IO2_IN0),r0
	move	x:(rD+FX_STATE_IO2_OUT0),r1
        move	x:(rD+FX_STATE_IO2_IN1),r2        

        ENDIF

ComputeAmpMod_StartLoop

        IF @DEF('STEREO')
	move	x:(rD+FX_STATE_IO3_IN2),r2        
        ENDIF

        dor      #>kFrameLength,ComputeAmpMod_Loop

        ; Shift oscillator output range from [-1..1] to [0..1]
	move	x:(r2)+,a
	asr	#1,a,a
	add	#>0.5,a
	move	a,x0
        ; Modulate !
	move	x:(r0)+,y0
	mpy	x0,y0,a

        ; check if we need to mix our output
        move    x:(rD+FX_STATE_FLAGS),x1       
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        move	x:(r1),x0
        add     x0,a            ; mix result to audio Output 
STOMP_OUTPUT
	move	a,x:(r1)+

ComputeAmpMod_Loop
        nop
        rts
FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\ampmod_boot.asm ===
;***********************************************************************
;
; AmpMod.asm    Amplitude Modulation by Waveform-Selectable Oscillator
;
;***********************************************************************        

	include 'AmpMod.h'

kAmpMod_Default_ModRate		set	1.0	; Hertz
kAmpMod_Default_ModAmount	set	1.0	  ; [0..1]% of delay length

kAmpMod_ModDepth		set	(kAmpMod_Default_ModAmount)
kAmpMod_ModScale		set	(kAmpMod_ModDepth/k2To24)

StartAmpMod 
; Data structure pointer already loaded into rD

        move    x:(rD+FX_STATE_FLAGS),x0
        brset   #BIT_FX_STATE_FLAG_INITIALIZED,x0,ComputeFXAmpMod               
        bset    #BIT_FX_STATE_FLAG_INITIALIZED,x0
        move    x0,x:(rD+FX_STATE_FLAGS)

	move	#>kAmpMod_ModScale,x0
	move	x0,x:(rD+AMPMOD_MOD_SCALE_H)

ComputeFXAmpMod

	bsr	ComputeAmpMod

        rts

;************************************************************
; ComputeAmpMod
;************************************************************
ComputeFXSubroutine
ComputeAmpMod
; rD points to Data Structure 



        ; Add bias to oscillator signal before modulation
        ; r0 = audio input
        ; r1 = audio out
        ; r2 = oscillator output(3 input to this fx..)

        ;
        ; mono case
        ;
	move	x:(rD+FX_STATE_IO2_IN0),r0
	move	x:(rD+FX_STATE_IO2_OUT0),r1
        move	x:(rD+FX_STATE_IO2_IN1),r2        

ComputeAmpMod_StartLoop

        dor      #>kFrameLength,ComputeAmpMod_Loop

        ; Shift oscillator output range from [-1..1] to [0..1]
	move	x:(r2)+,a
	asr	#1,a,a
	add	#>0.5,a
	move	a,x0
        ; Modulate !
	move	x:(r0)+,y0
	mpy	x0,y0,a

        ; check if we need to mix our output
        move    x:(rD+FX_STATE_FLAGS),x1       
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        move	x:(r1),x0
        add     x0,a            ; mix result to audio Output 
STOMP_OUTPUT
	move	a,x:(r1)+

ComputeAmpMod_Loop
        nop
        rts
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\bootsnd.asm ===
;*******************************************************************
;  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
; 
;  Author: George Chrysanthakopoulos (georgioc)
;  Creation Date: 4/1/2001
;  Comments: default execution engine for downloading FX code and doing basic
;  passthrough DMA from VP-> gp FIFOs (system ram)
;******************************************************************        
        include 'Util.h'

CIRCULAR_DMA            equ     0
SIZE_REVERB                 equ     512
SIZE_BOOTSND                equ     512

        org     x:kGPMemory_XRAM_Base
dmaOutFIFONode			ds	kDMANode_Size_FIFO       
ReverbFxData                    ds      SIZE_REVERB
ReverbFxTempData                ds      (kFrameLength*8)

; brian put your private data in this block
BootSndFxData                   ds      SIZE_BOOTSND

;***********************************************************
        org     p:$0      ; Place just before START

START
main
        IF !@DEF('SIM')
        jsr     GPInit          
        ENDIF

	move	#dmaOutFIFONode,r0
	move	#>(kDMANode_EOLBit+dmaOutFIFONode),x0
	move	x0,x:(r0)+
	move	#>kDMA_FIFOOut0_Word1,x0
	move	x0,x:(r0)+
	move	#>kDMA_FIFOOut0_Word2,x0
	move	x0,x:(r0)+
	move	#>kReadWriteMixBuf00,x0
	move	x0,x:(r0)+
	
	move	#dmaOutFIFONode,a
	jsr	DMAInit

        ; initialize boot snd FX

        jsr     FXInit

;*********************************************************
; Main loop
;*********************************************************
MainLoop

        GPSetIdleBit    

        IF !@DEF('SIM')
        jsr             GPWaitForStartFrame  
        ENDIF

        ;
        ; call bootsnd code
        ;

        jsr     FXCompute    

        ; call reverb code
        jsr     InvokeReverb

        IF !@DEF('SIM') 

MainLoop_StartDMA

        move	#dmaOutFIFONode,a
	jsr	DMAStartNode_Wait

        ENDIF


        bra     <MainLoop                    
; ---- end MainLoop ----


;
; bootsnd code init
;

FXInit
        rts

;
; bootsnd process audio frame routine
;

FXCompute

        rts



;
; reverb
;
InvokeReverb

        move    #>ReverbFxData,rD
        move    #>ReverbFxTempData,r6
        jsr     StartReverb


        rts





        ;
        ; library code..
        ;

	include 'DMAUtil.asm' 
	include 'Util.asm' 

        ;
        ; inplace FX code

        include "reverb_wrapper.asm"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\Chorus.asm ===
;***********************************************************************
;
; Flange.asm    
;
;***********************************************************************        

              IF @DEF('STANDALONE')
              include "util.h"
              ENDIF
              include "chorus.h"

        ;
        ; worst case cycle usage by this effect (includes one time Init)
        ; stereo: 13215 cycles (ouch)
        ; mono: 6617 
        ;



StartCHORUS

        FXEntryPoint

        IF @DEF('STEREO')

        ; 
        ; entire delay line is in Y memory
        ; copy some variables to right channel state
        ; then setup left channel first
        ;

        move    x:(rD+FX_DELAY_BASE),x0        
	move	x0,x:(rD+FX_DELAY_INDEX)

        ; calculate delay end index
        ; delay is length is halfed for each channel, since both channels use
        ; same delay line
	move	x:(rD+FX_DELAY_LENGTH),a
        asr     #1,a,a
        move	a,x:(rD+FX_DELAY_LENGTH)

        add     x0,a
        move    a,x:(rD+FX_DELAY_END)

        ; setup right channel

        move    x:(rD+FX_DELAY_LENGTH),x0
        move	x0,x:(rD+FX_DELAY_LENGTH+CHORUS_RIGHTCHANNEL_OFFSET)

	move	x:(rD+FX_DELAY_END),x0
	move	x0,x:(rD+FX_DELAY_INDEX+CHORUS_RIGHTCHANNEL_OFFSET)
        move	x0,x:(rD+FX_DELAY_BASE+CHORUS_RIGHTCHANNEL_OFFSET)

	move	x:(rD+FX_DELAY_LENGTH),a
        add     x0,a
        move    a,x:(rD+FX_DELAY_END+CHORUS_RIGHTCHANNEL_OFFSET)

	move	x:(rD+CHORUS_GAIN),x0
	move	x0,x:(rD+CHORUS_GAIN+CHORUS_RIGHTCHANNEL_OFFSET)

	move	x:(rD+CHORUS_MOD_SCALE_H),x0
	move	x0,x:(rD+CHORUS_MOD_SCALE_H+CHORUS_RIGHTCHANNEL_OFFSET)

        ELSE

        ;
        ; MONO init
        ; entire delay line is in Y memory
        ;

	move	x:(rD+FX_DELAY_BASE),x0
	move	x0,x:(rD+FX_DELAY_INDEX)

        ; calculate delay end index
	move    x:(rD+FX_DELAY_BASE),a
	move	x:(rD+FX_DELAY_LENGTH),x0
        add     x0,a
        move    a,x:(rD+FX_DELAY_END)

        move	x:(rD+FX_STATE_IO2_IN0),x0
        move    x0,x:(rD+FX_INPUT0)
        move	x:(rD+FX_STATE_IO2_IN1),x0
        move    x0,x:(rD+FX_INPUT1)

        move	x:(rD+FX_STATE_IO2_OUT0),x0
        move    x0,x:(rD+FX_OUTPUT0)

        ENDIF

ComputeFX

        IF @DEF('STEREO')
        
        ; duplicate flags for right channel

	move	x:(rD+CHORUS_GAIN),x0
	move	x0,x:(rD+CHORUS_GAIN+CHORUS_RIGHTCHANNEL_OFFSET)

	move	x:(rD+CHORUS_MOD_SCALE_H),x0
	move	x0,x:(rD+CHORUS_MOD_SCALE_H+CHORUS_RIGHTCHANNEL_OFFSET)

        move    x:(rD+FX_STATE_FLAGS),x0
        move    x0,x:(rD+FX_STATE_FLAGS+CHORUS_RIGHTCHANNEL_OFFSET)

        ; mirror input/output pointers from the base FX_STATE block
        ; into the ptrs for each channel

        move	x:(rD+FX_STATE_IO3_IN0),x0
        move    x0,x:(rD+FX_INPUT0)
        ; oscillator is common input for both channels
        move	x:(rD+FX_STATE_IO3_IN2),x0
        move    x0,x:(rD+FX_INPUT1)
        move	x:(rD+FX_STATE_IO3_OUT0),x0
        move    x0,x:(rD+FX_OUTPUT0)

        ; right channel

        move	x:(rD+FX_STATE_IO3_IN1),x0
        move    x0,x:(rD+FX_INPUT0+CHORUS_RIGHTCHANNEL_OFFSET)
        ; oscillator is common input for both channels
        move	x:(rD+FX_STATE_IO3_IN2),x0
        move    x0,x:(rD+FX_INPUT1+CHORUS_RIGHTCHANNEL_OFFSET)
        move	x:(rD+FX_STATE_IO3_OUT1),x0
        move    x0,x:(rD+FX_OUTPUT0+CHORUS_RIGHTCHANNEL_OFFSET)

        ENDIF

	bsr	ComputeCHORUS

        IF @DEF('STEREO')
        lua     (rD+CHORUS_RIGHTCHANNEL_OFFSET),rD
        bsr     ComputeCHORUS
        ENDIF

        FXExit

;************************************************************
; ComputeCHORUS:	
;************************************************************
ComputeCHORUS
; Data structure pointer pre-loaded in 'D' register

        ; r0 is oscillator 
        ; r1 is delay line index
        ; r2 is audio input 
        ; r3 is audio output

        
        move    x:(rD+FX_INPUT1),r0
	move	x:(rD+FX_INPUT0),r2	; Get x[n] 
        move    x:(rD+FX_OUTPUT0),r3

        dor     #kFrameLength,ComputeCHORUS_MonoLoop

        move    x:(r0)+,a

; Bias AC-waveform

	move    a,x0
	move    x:(rD+CHORUS_MOD_SCALE_H),y0
	mpy	x0,y0,a	

	sub	y0,a

	move    x:(rD+FX_DELAY_INDEX),x0        
	add	x0,a		

; Wrap
	move    x:(rD+FX_DELAY_END),x0
	move    x:(rD+FX_DELAY_BASE),y0
	move	x:(rD+FX_DELAY_LENGTH),x1

ComputeCHORUS_Mono_Wrap_IsABigger
	cmp	x0,a		; a - x0
	ble	ComputeCHORUS_Mono_Wrap_IsASmaller
	sub	x1,a
	bra	ComputeCHORUS_Mono_Wrap_AOk
ComputeCHORUS_Mono_Wrap_IsASmaller
	cmp	y0,a		; a - y0
	bge	ComputeCHORUS_Mono_Wrap_AOk
	add	x1,a
ComputeCHORUS_Mono_Wrap_AOk
	move	a,r1


ComputeCHORUS_Mono_Output
	move	y:(r1),x0		; Read from delay line
	move	x:(rD+CHORUS_GAIN),y0
	mpy	y0,x0,a
	move	x:(r2)+,x0		; Get x[n] 
	add	x0,a
                     
        ; Update current index
	move    x:(rD+FX_DELAY_INDEX),r4
	move	x0,y:(r4)+		       	; Write y[n] to delay line
	move    r4,x:(rD+FX_DELAY_INDEX)	; Store current index

        move    x:(r3),x0                       ; read existing audio output(if any)
                            
        move    x:(rD+FX_STATE_FLAGS),x1        ; read existing audio output(if any)
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        add     x0,a            ; mix result to audio Output 
STOMP_OUTPUT
	move	a,x:(r3)+		; add to existing output
                
        move    x:(rD+FX_DELAY_INDEX),x0            
        ; if (index >= end) index = base
	move	x:(rD+FX_DELAY_END),a
	cmp	x0,a			        ; a - x
	bge	ComputeCHORUS_NoUpdate
	move    x:(rD+FX_DELAY_BASE),x0         ; reset delay index  
	move    x0,x:(rD+FX_DELAY_INDEX)
ComputeCHORUS_NoUpdate
        nop

ComputeCHORUS_MonoLoop

ComputeCHORUS_MonoEnd

        rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\dolby\suprexec.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			Suprexec.asm
;												
;   Contents:		Superexec for Dolby Game Encoder
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	8/16/2000 3:51:37 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'Dolby Super Exec'

	section	SuperExec

;**** include files ************************************************

	nolist
	include 'ldr_sip.inc'
	include	'se_sip.inc'
	include 'eputil.h'        
	list

;**** Development Switches *****************************************

	IF			@DEF('SIM_XBOX_SYS_MEM') 	
 		DEFINE		TRASH_DSP_MEMORY	   	'1'		; Overwrite DSP memory each block
	ENDIF

;*** Switches (leave defined for X-Box) ****************************

	DEFINE		PERF_COUNTERS                       '1'
	DEFINE		INFINITE_LOOP_IF_TIME_OVERRUN		'1'
	;DEFINE		ERRHALT								'1'		; Halt on loader error	

;**** Development External References ******************************

	IF		@DEF('RTSYS')						; Dolby development HW only
		xref	rt_init,rt_input,rt_output
	ENDIF

	IF		@DEF('SIM_XBOX_SYS_MEM')			; Motorola simulator only
		xref	CopyInFilesToSysMem
		xref	CopySysMemToOutputFiles
		xref	Copy6ChInFileToSysMem
		xref	CopySysMemToAC3OutputFile
	ENDIF

;**** equates ******************************************************


;MAX_EP_CYCLES		  		equ		1060000 ;200mhz
;MAX_EP_CYCLES		  		equ		850000  ;160mhz
MAX_EP_CYCLES		  		equ     708000  ;133mhz

STACK_EXTSZ					equ		32		; stack extension size
CONFIG_SIZE					equ		32		; config data size
SE_NUM_BLOCKS				equ		6		; number of blocks per frame (6)
PMEMSIZE					equ		$001000	; p: is 4k words
YMEMSIZE					equ		$000100	; y: is 256 words
TRASHWORD					equ		$ffffff	; overwrite memory with this word

MONO_DNMIX_CODE				equ		$000001	; 
STEREO_DNMIX_CODE			equ		$000002	;

;	IF	@DEF('PERF_COUNTERS')
;MAX_TIMES_IGNORE_TIMER_AFTER_REBOOT		equ		0
;	ENDIF	; 	IF	@DEF('PERF_COUNTERS')

;*******************************************************************
;	Super Exec sets up stack extension at top of x: RAM.
	
	mode	rel
	org		x(201):					; place stack at top of RAM.

stack_ext	ds	STACK_EXTSZ			; stack extension

;*******************************************************************
; 	Config List from System. Place immediately below stack extension.

	mode	rel
	org		x(204):

config_list		ds	CONFIG_SIZE

;;;;; Note: Interrupt vectors are in ROM on nVidia system

;**** code *********************************************************
;	Start Program Code Here.

	mode	rel
	org		p(202):

SuperExec:

	bra		<SEStart				; skip over local variables

;	Local Variables

supexec_blknum	    dc		0 			; to sync all functions to same block.
surr_reset	    	dc		1 			; surround reset flag - init to one (!)
game_reset	    	dc		1 			; game encoder reset flag - init to one (!)

	IF @DEF('PERF_COUNTERS')
elapsed_time        dc      0
prev_time           dc      0
suprexec_temp	    dc	    $cccccc		; $cccccc is no time overflow, $bbbbbb if exceed 5.33 ms.
count               dc      0			; allows algorithm to exceed 5.33 ms during reboot only.
	ENDIF	; IF @DEF('PERF_COUNTERS')

;*******************************************************************
;	Start SuperExec Program Code.  

SEStart:

	IF @DEF('PERF_COUNTERS')
        ; init timer variables

        move    #0,x0
        move    x0,p:elapsed_time
        move    x0,p:prev_time

        ; setup timer registers

        movep   #$FFFFFF,x:TIMER1_TERMINAL_COUNT
        movep   #1,x:TIMER1_CONFIG

        ; start the timer from 0
        movep   #1,x:TIMER1_CONTROL
	ENDIF	; IF @DEF('PERF_COUNTERS')


;	Enable Stack extension.

	movec	#0,sp					; reset the stack pointer
	movec	#stack_ext,ep			; init extension pointer register
	movec	#STACK_EXTSZ,sz			; init stack size register
	bset	#20,omr					; enable stack extension

;	Enable any counters, etc. at reset.
	
	clr		a					   	; a0 = 0
	move	a0,p:supexec_blknum		; start with block zero at reset
	inc		a					   	; a0 = 1
	move	a0,p:surr_reset			; explicitly set reset flag
	move	a0,p:game_reset			; explicitly set reset flag

;	Initialize the loader

	move	#>LID_LOADER_INIT,a		; Packet ID
	jsr		LOADERBASE				; Call the Loader
	IF	@DEF('ERRHALT')
		tst	a						; check error status
		bne	<*
	ELSE
		tst     a
		bne     handle_error 
	ENDIF

;	Dolby development hardware only (RTSYS)

	IF	@DEF('RTSYS')
		bsr	rt_init					; init real-time hardware
	ENDIF

;	Clear the start frame bit
	EPClearStartFrameBit

	
;*******************************************************************
;	Enter Endless Loop to process each of the four possible Functions
;	in series.	Note that we might not process the function; it depends upon
;	the corresponding flag in the config_list.

;	1. Dolby Surround OR Downmix Function if Surround Not Enabled
;	2. Dolby Game Encoder Function 1
;	3. Dolby Game Encoder Function 2
;	4. Dolby Game Encoder Function 3

SELoop:

	IF @DEF('PERF_COUNTERS')
        move    p:count,a
        add     #1,a
        move    a,p:count
	ENDIF	; 	IF @DEF('PERF_COUNTERS')

; Write the idle bit
	EPSetIdleBit

;	Wait for Start Frame bit.
	clr     a
waitframe:
	add     #1,a
	jclr 	#kStartFrameBit,x:INTERRUPT_REGISTER,waitframe

	IF @DEF('PERF_COUNTERS')
        ;***********************************************************************
        move    x:TIMER1_COUNT,x0
        movem   x0,p:prev_time
        ;***********************************************************************
    ENDIF	; IF @DEF('PERF_COUNTERS')


ClearStartFrameBit:
; Clear GP Start Block (bit 1)
	EPClearStartFrameBit	

;	Simulate fact that memory is in unknown state

	IF	@DEF('TRASH_DSP_MEMORY')
		bsr	<trashmem
	ENDIF

;	following section is for Dolby development hardware only
;	gui can override config_list parameters 
;	call to rt_input returns a = audio/non-audio flag

	IF	@DEF('RTSYS')
		bsr	rt_input			; get input from real-time hardware
	ENDIF	; @DEF('RTSYS')

;	if block zero, get configuration data from system memory

	move	p:supexec_blknum,a			; get block number
	tst		a #config_list,r0			; is it zero? preload config_list address
	bne		<config_list_loaded			; if not, don't load list

	move	#>LID_CONFIG_LIST,a			; Packet ID
	move	#CONFIG_SIZE,n0				; tell Loader max number of words allowable
	jsr		LOADERBASE					; Call the Loader
	IF	@DEF('ERRHALT')
		tst	a							; check error status
		bne	<*							; stop if loader error
	ELSE
		tst     a
		bne     handle_error
	ENDIF	
	
config_list_loaded:
	
;-------------------------------------------------------------------
;	1A. Check if we're supposed to do Dolby Surround. If not, skip it.
;-------------------------------------------------------------------

SEDS:

	move	x:config_list+SE_IN_DO_SURROUND,a	; get DO_SURROUND flag
	tst		a #DOLBYEXECBASE,r0					; is zero? preload DSP memory address
	beq		<SEDownMix							; if so, bypass Surround

;	Load Program Code for Dolby Surround

SEDSLdP:

	move	#>LID_PROG_DSURRE,a						; Packet ID
	jsr	LOADERBASE								; Call the Loader
	IF	@DEF('ERRHALT')
		tst	a										; check error status
		bne	<*										; stop if loader error
	ELSE
		tst     a
		bne     handle_error
	ENDIF	

	IF	@DEF('SIM_XBOX_SYS_MEM')

;	Copy inputs to System memory (Simulator Only - NVIDIA: Remove this call!)

SECopyIn:

	jsr	<CopyInFilesToSysMem

	ENDIF	; @DEF('SIM_XBOX_SYS_MEM')


	;	Run Program Code for Dolby Surround

SEDSjsr:
	
	move	p:surr_reset,b							; get surround reset word
	move	#config_list,r0							; pass pointer to configuration data (in x:)
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of Dolby Surround Exec (skip header)
	   
;	clear surround reset word

	move	#0,x0
	move	x0,p:surr_reset


	IF	@DEF('SIM_XBOX_SYS_MEM')

;	copy System Memory to output files (Simulator Only - NVIDIA: Remove this call!)

SECopyOut:

	jsr	<CopySysMemToOutputFiles

	ENDIF	; @DEF('SIM_XBOX_SYS_MEM')

; All Done with Dolby Surround.
	bra		<SEF1

;-------------------------------------------------------------------
;	1B. Check if we're supposed to do DownMix, since we did not do Surround..
;-------------------------------------------------------------------

SEDownMix:

;	Get Info from System Configuration table.

	move	x:config_list+SE_IN_DO_DOWNMIX,b	; get SE_IN_DO_DOWNMIX flag
	tst		b #DOLBYEXECBASE,r0					; is zero? preload DSP memory address
	beq		<SEF1 								; if so, bypass Downmix

SEDMMono:
	clr		a #>LID_PROG_DMMONO,x0				; clear a, preload mono dnmix LID
	cmp		#>MONO_DNMIX_CODE,b					; is SE_IN_DO_DOWNMIX == MONO?
	tfr		x0,a ifeq							; if so, load mono LID into a

SEDMStereo:
	move	#>LID_PROG_DMSTEREO,x0				; preload stereo dnmix LID
	cmp		#>STEREO_DNMIX_CODE,b				; is SE_IN_DO_DOWNMIX == STEREO?
	tfr		x0,a ifeq							; if so, load stereo LID into a

SEDMInvalid:
	tst		a									; if neither was loaded, invalid SE_IN_DO_DOWNMIX
	beq		<SEF1								; so bypass to be safe.

;	Load code.

	jsr	LOADERBASE								; Call the Loader
	IF	@DEF('ERRHALT')
		tst	a								 	; check error status
		bne	<*								 	; stop if loader error
	ELSE
		tst     a
		bne     handle_error
	ENDIF	

	;	Run Program Code for Dolby Downmix.

SEDMJSR:
	
	move	#config_list,r0							; pass pointer to configuration data (in x:)
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of Dolby Surround Exec (skip header)

;	All done, go to next function.

	bra		<SEF1

;-------------------------------------------------------------------
;	2. Check if we're supposed to do Game Encoder. If not, skip it.
;-------------------------------------------------------------------

SEF1:

	move	x:config_list+SE_IN_DO_GAME,a	; get DO_GAME flag
	tst		a #DOLBYEXECBASE,r0				; is it zero? preload DSP memory address
	beq		<SEF3Done						; if so, bypass Game Encoder
	
;	Load Program Code for Function 1

SEF1LdP:

	move	#>LID_PROG_DGAME1,a						; Packet ID
	jsr		LOADERBASE								; Call the Loader
	IF	@DEF('ERRHALT')
		tst	a										; check error status
		bne	<*										; stop if loader error	
	ELSE
		tst     a
		bne     handle_error
	ENDIF


	IF	@DEF('SIM_XBOX_SYS_MEM')

;	Copy inputs to System memory (Simulator Only - NVIDIA: Remove this call!)

	jsr	Copy6ChInFileToSysMem

	ENDIF	; @DEF('SIM_XBOX_SYS_MEM')


;	Run Program Code for Function 1

SEF1jsr:
	
	move	#config_list,r0							; set up config list pointer
	move	p:game_reset,b							; get Game Encoder reset word
	move	p:supexec_blknum,x0						; set up x0 with current block number
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of GE Function 1 (skip past header)

; 	All Done with Function 1.

SEF1Done:


;-------------------------------------------------------------------
;	Game Encoder Fcn 2.
;-------------------------------------------------------------------

SEF2:

;	Load Program Code for Function 2

SEF2LdP:

	move	#DOLBYEXECBASE,r0						; r0 is DSP memory address
	move	#>LID_PROG_DGAME2,a						; Packet ID
	jsr		LOADERBASE								; Call the Loader
	IF	@DEF('ERRHALT')
		tst	a										; check error status
		bne	<*										; stop if loader error
	ELSE
		tst             a
		bne             handle_error
	ENDIF

;	Run Program Code for Function 2

SEF2jsr:
	
	move	p:game_reset,b							; get Game Encoder reset word
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of GE Function 2 (skip past header)

; 	All Done with Function 2.

SEF2Done:

;-------------------------------------------------------------------
;	Game Encoder Fcn 3.
;-------------------------------------------------------------------

SEF3:
	
;	Load Program Code for Function 3 Executive

SEF3LdP:

	move	#DOLBYEXECBASE,r0						; r0 is DSP memory address
	move	#>LID_PROG_DGAME3,a						; Packet ID
	jsr		LOADERBASE								; Call the Loader
	IF	@DEF('ERRHALT')
		tst	a										; check error status
		bne	<*										; stop if loader error
	ELSE
		tst     a
		bne     handle_error
	ENDIF	


;	Run Program Code for Function 3

SEF3jsr:
	
	move	p:game_reset,b							; get Game Encoder reset word
	move	p:supexec_blknum,x0						; set up x0 with current block number (need for output)
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of GE Function 3 (skip past header)

;	clear Game Encoder reset word

	move	#0,x0
	move	x0,p:game_reset

	IF	@DEF('SIM_XBOX_SYS_MEM')

;	Write Outputs (for Motorola Simulator only) at the end of block 5
;	NVIDIA - remove this call!

SEWriteAC3:

	move	p:supexec_blknum,a
	cmp	#SE_NUM_BLOCKS-1,a
	bseq	<CopySysMemToAC3OutputFile

	ENDIF	; @DEF('SIM_XBOX_SYS_MEM') 

; 	All Done with Function 3.

SEF3Done:

	IF	@DEF('RTSYS')

;	Dolby development hardware only (RTSYS)

	move	x:config_list+SE_IN_DO_GAME,a
	move	p:supexec_blknum,x0	; set up x0 with current block number
	bsr		rt_output			; send output to real-time hardware

	ENDIF	; @DEF('RTSYS')

;-------------------------------------------------------------------
; 	Increment Block Number, and wrap if necessary.

SEBlkAdj:

	move	p:supexec_blknum,a
	add		#1,a
	cmp		#SE_NUM_BLOCKS,a
	clr		a ifge
	move	a1,p:supexec_blknum

;	Increment the ping-pong for pcm input

	move	#>LID_PING_PONG,a					; Packet ID
	jsr		LOADERBASE							; Call the Loader


	IF @DEF('PERF_COUNTERS')
        ;***********************************************************************
		;
		; This section checks to see if we exceed time limit,
		; and if we did, it enters INFINITE LOOP (a VERY HARD CRASH).
		;
        move    x:TIMER1_COUNT,a	; calculate time algorithm took to run
        movem   p:prev_time,x0
        sub     x0,a        
        movem   a1,p:elapsed_time	; save it in elapsed time
        
        move    #MAX_EP_CYCLES,x0	; compare elapsed time to max allowed
        cmpu    x0,a
        blt     <SELoop				; if algoithm did NOT exceed, keep processing.

;        move    p:count,a			; if algorithm DID exceed, check if this happened
;									; immediately after chip rebooted. 
;        cmp     #>MAX_TIMES_IGNORE_TIMER_AFTER_REBOOT,a
;        blt     <SELoop				; If it did, ignore.

        move    #$bbbbbb,x0			; MAJOR FAILURE!  Algorithm exceed 5.33 ms allowed time.
        move    x0,p:suprexec_temp	; write tag to indicate failure.
		
		IF	@DEF('INFINITE_LOOP_IF_TIME_OVERRUN')
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		bra		<*					; HARD CRASH - INFINITE LOOP to isolate problem during debugging.
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		ENDIF	; IF @DEF('INFINITE_LOOP_IF_TIME_OVERRUN')

        IF      @DEF('ERRHALT')
        bra     <*
        ENDIF
        ;***********************************************************************
	ENDIF	; 	IF @DEF('PERF_COUNTERS')


	bra	<SELoop
		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;*******************************************************************
;*
;*	Subroutine Name:	handle_error
;*																								
;*  Description:		it will attempt to gracefully handle
;*                              an error condition
;*******************************************************************

handle_error:

	bra    <SELoop
         
	
	IF		@DEF('TRASH_DSP_MEMORY')
;*******************************************************************
;*
;*	Subroutine Name:	trashmem
;*																								
;*  Description:		trashes DSP memory as an acid test
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************

trashmem:

;	Overwrite p: DSP memory from DOLBYEXECBASE to top of p: space.

trashp:

	move	#>DOLBYEXECBASE,x0		; get base of Dolby functions
	move	x0,r0					; save as start address
	move	#>PMEMSIZE,a			; get size of p:
	sub		x0,a					; compute size of Dolby Fcn space
	move	a,n0					; and trash this many locations
	move	#>TRASHWORD,a			; overwrite word

	dor		n0,trashplp
		move a,p:(r0)+
trashplp:

;	Overwrite y: DSP memory from $0 to top of y: space

trashy:

	move	#YMEMSIZE,n0				; trash all of y:
	move	#0,r0						; start at zero
	
	dor		n0,trashylp
		move	a,y:(r0)+			
trashylp:		

;	Overwrite x: DSP memory from $0 to
;	to bottom of stack extension
;	(stack extension is located at top of x:)

trashx:

	move	#CONFIGBASE,n0		; trash everything in x: below config	
	move	#0,r0				; start at zero
	
	dor		n0,trashxlp
		move	a,x:(r0)+	
trashxlp:		

	rts

;*******************************************************************
	ENDIF	; @DEF('TRASH_DSP_MEMORY')


;*******************************************************************
	endsec		; SuperExec
	end			; end of file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\defaultEngine.asm ===
include '..\defaultexec\defaultengine.asm'
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\delay.asm ===
;**************************************************************************
;
;       Delay.asm    
;       	
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'Delay.h'


CIRCULAR_DMA            equ     1

;************************************************************
; StartDelay  
;************************************************************
StartDelay
; Data structure pointer already loaded into rD

        FXEntryPoint

        ;
        ; mono version
        ;

        bsr     PrepareDelayLineDMA
        
ComputeFX
        
	bsr	ComputeDelay

        FXExit

; ---- end StartEcho ----


;************************************************************
; ComputeDelay
;************************************************************
ComputeDelay

; dma 32 samples of the delay line in scratch memory
; stick it in temporary buffer in Y memory


; **********************************************************
        ; Read from delay line into input buffer
    	lua     (rD+DMA_NODE_READ0),r0		
        move    r0,a
        IF !@DEF('SIM')
	bsr    DMAStartNode_Wait    
        ENDIF

        ; update delay line with current input
    	lua     (rD+DMA_NODE_WRITE0),r0
        move    r0,a
        IF !@DEF('SIM')
	bsr    DMAStartNode_Wait
        ENDIF

       
        ; Add/overwrite delay data to output 
	move	x:(rD+FX_STATE_IO1_OUT1),r0
	move	x:(rD+FX_STATE_IO1_OUT0),r1

        move    x:(rD+FX_STATE_FLAGS),x1   
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        GPAddX  ; mix result to audio Output 
        rts

STOMP_OUTPUT
        GPCopyXtoXRAM ; stomp audio Output 	
        rts

; ---- end ComputeEcho_Stereo ----


PrepareDelayLineDMA

    lua	    (rD+DMA_NODE_READ0),r0
    move    r0,a                      
    ori     #kDMANode_EOL,a			
    
    move    a,x:(r0+kDMAWord0_NextCmd)	

    ;
    ; prepare read dma block
    ;

    move    x:(rD+FX_STATE_IO1_OUT1),a

    ; dsp mem base address
    move    #>kGPMemory_Base_XRAM,x0
    add     x0,a
    move    a,x:(r0+kDMAWord3_DSPAddress)		

    ; circular buffer base
    move    x:(rD+FX_STATE_SCRATCH_BASE),x0
    move    x0,x:(r0+kDMAWord5_SMBaseOffset)	

    ; buffer length
    move    x:(rD+FX_STATE_SCRATCH_LENGTH),a
    IF @DEF('STEREO')
    asr	    #1,a,a 
    ENDIF
    sub     #1,a
    move    a,x:(r0+kDMAWord6_SMLength)	

    move    #DMA_CIRCULAR_READ1_ISO,a
    move    a,x:(r0+kDMAWord1_ControlBits)			
    move    #kFrameLength,a1
    move    a1,x:(r0+kDMAWord2_Count)			
        
    ;
    ; prepare write dma block
    ;

    lua	    (rD+DMA_NODE_WRITE0),r0

    ; dsp mem address
    move    x:(rD+FX_STATE_IO1_IN),x0
    move    x0,x:(r0+kDMAWord3_DSPAddress)		
    
    ;
    ; circular buffer base
    ;

    move    x:(rD+FX_STATE_SCRATCH_BASE),x0
    move    x0,x:(r0+kDMAWord5_SMBaseOffset)	

    ;
    ; buffer length
    ;

    move    x:(rD+FX_STATE_SCRATCH_LENGTH),a
    sub     #1,a
    move    a,x:(r0+kDMAWord6_SMLength)	

    move    #DMA_CIRCULAR_WRITE1_ISO,a
    move    a,x:(r0+kDMAWord1_ControlBits)			
    move    #kFrameLength,a1
    move    a1,x:(r0+kDMAWord2_Count)			

    clr     a                      
    ori     #kDMANode_EOL,a			
    move    a,x:(r0+kDMAWord0_NextCmd)	
   
    rts



    IF @DEF('STANDALONE')
    include "fxDMAUtil.asm"
    ENDIF

FX_END
    nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\Distortion.asm ===
;**************************************************************************
;
; Distortion.asm    Distortion module
;       
;**************************************************************************        
        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'distortion.h'

        ;
        ; worst case cycle usage by this effect (includes one time Init)
        ; stereo: 
        ; mono: 11510 
        ;


Distortion_Default_Gain			set	(110.0/256.0)	
Distortion_Default_Edge			set	1.0
Distortion_Default_PostFilter_Frequency	set	1000.0	; Hertz
Distortion_Default_PostFilter_Q		set	10.0	
Distortion_Default_PreFilter_Frequency	set	2000.0	; Hertz	

eqFc		set (Distortion_Default_PostFilter_Frequency/Fs)
eqWc		set (Distortion_Default_PostFilter_Frequency/Fs)*kTwoPi
lpFc		set (Distortion_Default_PreFilter_Frequency/Fs)
lpWc		set (Distortion_Default_PreFilter_Frequency/Fs)*kTwoPi
EQScale24	set 1.0
g24		set 1.0

; IIR2: mode=Parametric fc=1000 Q=10 gainDB=10 h=< 0.50430103 -0.98592954 0.49172073 0.98592954 -0.49602176 >,< 408CEF 81CD10 3EF0B4 7E32F0 C0825C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
postFilter_H_Parametric_f01000_q10_b0    set  0.50430103       ; 408CEF
postFilter_H_Parametric_f01000_q10_b1    set -0.98592954       ; 81CD10
postFilter_H_Parametric_f01000_q10_b2    set  0.49172073       ; 3EF0B4
postFilter_H_Parametric_f01000_q10_a1    set  0.98592954       ; 7E32F0
postFilter_H_Parametric_f01000_q10_a2    set -0.49602176       ; C0825C

; IIR2: mode=LowPass fc=2000 Q=1 gainDB=0 h=< 0.01758625 0.03517250 0.01758625 0.83705819 -0.37223069 >,< 024044 048088 024044 6B24B9 D05ABF >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C)
preFilter_H_LowPass_f02000_q01_b0    set  0.01758625       ; 024044
preFilter_H_LowPass_f02000_q01_b1    set  0.03517250       ; 048088
preFilter_H_LowPass_f02000_q01_b2    set  0.01758625       ; 024044
preFilter_H_LowPass_f02000_q01_a1    set  0.83705819       ; 6B24B9
preFilter_H_LowPass_f02000_q01_a2    set -0.37223069       ; D05ABF

StartDistortion 

        FXEntryPoint

; Data structure pointer already loaded into rD

	move	#>Distortion_Default_Gain,x0
	move	x0,x:(rD+DISTORTION_GAIN)	

        ; delay elements are initialized to zero already(state always is 0 at init)

ComputeFX
	bsr	ComputeDistortion	

        FXExit

ComputeDistortion	
; rD points to Data Structure 

	move	x:(rD+FX_STATE_IO1_IN),r2
	move	x:(rD+FX_STATE_IO1_OUT0),r3

	dor	#>kFrameLength,ComputeDistortion_Loop
ComputeDistortion_PreFilter
	ori     #$08,mr         ; Set scaling mode to scale up
				; when data is moved from accumulator

        ; y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] + a1*y[n-1] + a2*y[n-2]
	lua	(rD+DISTORTION_PREFILTER_H_B0),r0

        ; load y-mem offset of our delay elements
        ; prefilter is at the base of our yram allocation
	move	x:(rD+FX_DELAY_BASE),r4 

	move	x:(r0)+,x0				
	move	x:(r2)+,y1				
	mpy	x0,y1,a	x:(r0)+,x0 y:(r4)+,y0		; b0*x[n]
        rep #3
	mac	x0,y0,a x:(r0)+,x0 y:(r4)+,y0     	; b1*x[n-1]+b2*x[n-2]+a1*y[n-1]+
	mac	x0,y0,a					; a2*y[n-2]

        ;
        ; save existing output for next stage
        ;

        move    x:(r3),x0
        move    x0,x:(rD+DISTORTION_TEMP)
	move	a,x:(r3)			

        ; Shift data
        move	x:(rD+FX_DELAY_BASE),r4 

	move	y:(r4+DISTORTION_PREFILTER_Z_X1),x0
	move	x0,y:(r4+DISTORTION_PREFILTER_Z_X2)
	move	y1,x0
	move	x0,y:(r4+DISTORTION_PREFILTER_Z_X1)

	move	y:(r4+DISTORTION_PREFILTER_Z_Y1),x0
	move	x0,y:(r4+DISTORTION_PREFILTER_Z_Y2)
	move	a,x0
	move	x0,y:(r4+DISTORTION_PREFILTER_Z_Y1)
        andi    #$f7,mr         ; Unset scaling mode

ComputeDistortion_Clipping
	
	move	x:(r3),a         ; read from output, to get results of prefilter
	asl	#4,a,a
	move	a,x1

	move	x:(rD+DISTORTION_GAIN),y0
	mpy	x1,y0,a			; Scale down by gain
	move	a,x:(r3)

ComputeDistortion_PostFilter

        ; y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] + a1*y[n-1] + a2*y[n-2]
	lua	(rD+DISTORTION_POSTFILTER_H_B0),r0

        move	x:(rD+FX_DELAY_BASE),a
        move    #>DISTORTION_POSTFILTER_Z_X1,x0	
        add     x0,a
        move    a,r4               

	ori     #$08,mr         ; Set scaling mode to scale up
				; when data is moved from accumulator

	move	x:(r0)+,x0				
	move	x:(r3),y1		; read previous stage results		
	mpy	x0,y1,a	x:(r0)+,x0 y:(r4)+,y0    	; b0*x[n]

        rep     #3
	mac	x0,y0,a x:(r0)+,x0 y:(r4)+,y0     	
	mac	x0,y0,a					

        ; Shift delay elements
        move	x:(rD+FX_DELAY_BASE),r4 
	move	y:(r4+DISTORTION_POSTFILTER_Z_X1),x0
	move	x0,y:(r4+DISTORTION_POSTFILTER_Z_X2)
	move	y1,x0
	move	x0,y:(r4+DISTORTION_POSTFILTER_Z_X1)

	move	y:(r4+DISTORTION_POSTFILTER_Z_Y1),x0
	move	x0,y:(r4+DISTORTION_POSTFILTER_Z_Y2)
	move	a,x0
	move	x0,y:(r4+DISTORTION_POSTFILTER_Z_Y1)

        andi    #$f7,mr				; Unset scaling mode

        move    x:(rD+FX_STATE_FLAGS),x1       
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        move	x:(rD+DISTORTION_TEMP),x0
        add     x0,a            ; mix result to audio Output 
STOMP_OUTPUT
        move    a,x:(r3)+

	nop		; DSP restriction:  can't change scaling mode too close to loop end
	nop
	nop
ComputeDistortion_Loop

ComputeDistortionEnd
        rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\Compressor.asm ===
;**************************************************************************
;
;       compressor.asm    
;       	
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'compressor.h'



;************************************************************
; StartSpliter	
;************************************************************
StartSpliter
; Data structure pointer already loaded into rD

        FXEntryPoint

        move    x:(rD+FX_DELAY_BASE),x0        
	move	x0,x:(rD+FX_DELAY_INDEX)
        move	x0,x:(rD+FX_OUTPUT_INDEX)

	move    x:(rD+FX_DELAY_BASE),a
	move	x:(rD+FX_DELAY_LENGTH),x0
        add     x0,a
        move    a,x:(rD+FX_DELAY_END)

        
ComputeFX
        
	bsr	ComputeSpliter

        FXExit



;************************************************************
; ComputeSpliter
; split channel 0 to channels 0,1,2,3,.., N of output data
;************************************************************
ComputeSpliter

        ; load input io ptr
	move	x:(rD+FX_STATE_IO1_IN),r0
        move	x:(rD+FX_STATE_IO1_OUT0),r1
        
	move    x:(rD+FX_DELAY_INDEX),a
	move    x:(rD+FX_DELAY_BASE),x0
        add     x0,a
        move    a,r4
               
        dor     #kFrameLength,DelayLoop
        move    x:(r0)+,x0      
        move    x0,y:(r4)+ 
        move    x0,x:(r1)+ 


DelayLoop
        nop

        ; update index
        move    r4,x:(rD+FX_DELAY_INDEX)
        move    r4,x0
       
        ; if (index >= end) index = base
	move	x:(rD+FX_DELAY_END),a
	cmp	x0,a			        ; a - x
	bge	NoUpdate
	move    x:(rD+FX_DELAY_BASE),x0         ; reset delay index  
	move    x0,x:(rD+FX_DELAY_INDEX)
NoUpdate


        ;
        ; now walk the delay line and use it to produce output
        ;

        move	x:(rD+FX_STATE_IO1_OUT0),r1
	move    x:(rD+FX_OUTPUT_INDEX),a
	move    x:(rD+FX_DELAY_BASE),x0
        add     x0,a
        move    a,r4

        move    #2,n4
        move    #2,n1

        dor     #kFrameLength/2,OutputLoop
        move    y:(r4)+n4,x0      
        move    x0,x:(r1)+ 

OutputLoop
        nop

        ; update index
        move    r4,x:(rD+FX_OUTPUT_INDEX)
        move    r4,x0
       
        ; if (index >= end) index = base
	move	x:(rD+FX_DELAY_END),a
	cmp	x0,a			        ; a - x
	bge	NoUpdateOutputIndex
	move    x:(rD+FX_DELAY_BASE),x0         ; reset delay index  
	move    x0,x:(rD+FX_OUTPUT_INDEX)
NoUpdateOutputIndex



        rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\DMAUtil.asm ===
;*******************************************************************
;
;       DMAUtil.asm    DSP DMA utility routines  
;
;******************************************************************        
		
;************************************************************
; DMAInit	Configure DMA engine for first program use
;
;
;	Parameters	a	dmaStart node
;
;		Stops DMA Engine, configures DMA node list
;		and clears DMA and Interrupt registers
;************************************************************
DMAInit
	bsr 	DMAStopAndFreeze	
	ClearDMAConfigRegister

	andi	#>kDMANode_EOLMask,a	; Clear reserved EOL and upper bits
	movep    a,x:DMA_START_BLOCK_CONTROL_REGISTER
	movep    a,x:DMA_NEXT_BLOCK_CONTROL_REGISTER	

 	rts
; ---- end DMAInit ----


;************************************************************
; DMANewNode_Read_Eol	
;
;	This DMA Read node is configured for the System
;	Memory -> DSP transfer of one buffer of specified length
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r0	node DSP XRAM address
;			r1	DSP    Memory address
;			r2	System Memory address
;			r3	buffer length
;************************************************************
DMANewNode_Read_Eol	
	move	r0,a
	andi	#>kDMANode_EOLMask,a	; Clear reserved upper bits
	ori		#>kDMANode_EOL,a			
        move    a,x:(r0+kDMAWord0_NextCmd) ; Link to itself			

        move    #>DMA_BASE_READ1,a		
	move	a,x:(r0+kDMAWord1_ControlBits)			
        move    r3,x:(r0+kDMAWord2_Count)			
	move    r1,x:(r0+kDMAWord3_DSPAddress)						
	move    r2,x:(r0+kDMAWord4_SMOffset)	

 	rts
; ---- end DMANewNode_Read_Eol ----

;************************************************************
; DMANewNode_Write_Eol	
;
;	This DMA write node is configured for the System
;	Memory <- DSP transfer of one buffer of specified length.
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r0	node DSP XRAM address
;			r1	DSP    Memory address
;			r2	System Memory address
;			r3	Buffer length
;************************************************************
DMANewNode_Write_Eol	
	move	r0,a
	andi	#>kDMANode_EOLMask,a	; Clear reserved upper bits
	ori	#>kDMANode_EOL,a			
        move    a,x:(r0+kDMAWord0_NextCmd)	; Link to itself			

        move    #>DMA_BASE_WRITE1,a		
	move	a,x:(r0+kDMAWord1_ControlBits)			
        move    r3,x:(r0+kDMAWord2_Count)			
	move    r1,x:(r0+kDMAWord3_DSPAddress)		
	move    r2,x:(r0+kDMAWord4_SMOffset)	
 	rts
; ---- end DMANewNode_Write_Eol ----

        include 'fxdmautil.asm'
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\Echo.asm ===
;**************************************************************************
;
;       Echo.asm    
;       	
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'echo.h'


CIRCULAR_DMA            equ     1

;************************************************************
; StartEcho	
;************************************************************
StartEcho 
; Data structure pointer already loaded into rD

        FXEntryPoint

        IF @DEF('STEREO')

        ;
        ; re-create two mono state blocks, one for left channel , one for right
        ;

        ; setup scratch variable for left channel
	move	x:(rD+FX_STATE_SCRATCH_BASE),x0        
	move	x:(rD+FX_STATE_SCRATCH_LENGTH),a        

        ; set the lenght on the second block
        move    a,x:(rD+FX_STATE_SCRATCH_LENGTH+ECHO_RIGHTCHANNEL_OFFSET)

        ;half the length between channels
	asr	#1,a,a 
        add     x0,a
        ; set the scratch base on the second block
        move    a,x:(rD+FX_STATE_SCRATCH_BASE+ECHO_RIGHTCHANNEL_OFFSET)

        ; setup right channel Y-mem base
	move	x:(rD+FX_STATE_YMEM_BASE),a        
        add     #>kFrameLength*2,a
        move	a,x:(rD+FX_STATE_YMEM_BASE+ECHO_RIGHTCHANNEL_OFFSET)        

        ; setup dma control words for both channels
        dor     #>2,EchoStereoInitLoop
        bsr     EchoPrepareDelayLineDMA
        lua     (rD+ECHO_RIGHTCHANNEL_OFFSET),rD
EchoStereoInitLoop

        lua     (rD-ECHO_RIGHTCHANNEL_OFFSET*2),rD

        ELSE

        ;
        ; mono version
        ;

        move	x:(rD+FX_STATE_IO1_IN),x0
        move    x0,x:(rD+FX_INPUT0)

        move	x:(rD+FX_STATE_IO1_OUT0),x0
        move    x0,x:(rD+FX_OUTPUT0)

	move	x:(rD+FX_STATE_SCRATCH_BASE),a

        bsr     EchoPrepareDelayLineDMA

        ENDIF
        
ComputeFX
        
        IF @DEF('STEREO')

        ; copy FX flags to right channel state block

        move    x:(rD+FX_STATE_FLAGS),x0
        move    x0,x:(rD+FX_STATE_FLAGS+ECHO_RIGHTCHANNEL_OFFSET)

        ; copy gain over
        move    x:(rD+ECHO_GAIN),x0
        move    x0,x:(rD+ECHO_GAIN+ECHO_RIGHTCHANNEL_OFFSET)

        ; mirror IO ptrs

        move	x:(rD+FX_STATE_IO2_INL),x0
        move    x0,x:(rD+FX_INPUT0)

        move	x:(rD+FX_STATE_IO2_OUTL),x0
        move    x0,x:(rD+FX_OUTPUT0)

        move	x:(rD+FX_STATE_IO2_INR),x0
        move    x0,x:(rD+FX_INPUT0+ECHO_RIGHTCHANNEL_OFFSET)

        move	x:(rD+FX_STATE_IO2_OUTR),x0
        move    x0,x:(rD+FX_OUTPUT0+ECHO_RIGHTCHANNEL_OFFSET)

        ENDIF

	bsr	ComputeEcho	

        IF @DEF('STEREO')

        ;
        ; update rD to point to state data for right channel
        ; the compute echo for right channel
        ;

        lua (rD+ECHO_RIGHTCHANNEL_OFFSET),rD
        bsr     ComputeEcho

        ENDIF

        FXExit

; ---- end StartEcho ----


;************************************************************
; ComputeEcho
;************************************************************
ComputeEcho	

; dma 32 samples of the delay line in scratch memory
; stick it in temporary buffer in Y memory


; **********************************************************
        ; Read from delay line into input buffer
    	lua     (rD+DMA_NODE_READ0),r0		
        move    r0,a
        IF !@DEF('SIM')
	bsr    DMAStartNode_Wait    
        ENDIF

        ; Scale input by feedback gain
	move	x:(rD+FX_DELAY_BUFFER_IN),r0
        move	x:(rD+FX_DELAY_BUFFER_OUT),r1
	move	x:(rD+ECHO_GAIN),x0
        GPScaleY
 
        ; Add input data to output buffer
	move	x:(rD+FX_INPUT0),r0
	move	x:(rD+FX_DELAY_BUFFER_OUT),r1
        GPAccXtoY 
                  
        ; Write sum into delay line
    	lua     (rD+DMA_NODE_WRITE0),r0
        move    r0,a
        IF !@DEF('SIM')
	bsr    DMAStartNode_Wait
        ENDIF

        ; Add/overwrite delay data to output 
	move	x:(rD+FX_DELAY_BUFFER_IN),r0
	move	x:(rD+FX_OUTPUT0),r1

        move    x:(rD+FX_STATE_FLAGS),x1   
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        GPAccYtoX    ; mix result to audio Output 
        rts

STOMP_OUTPUT
        GPCopyYtoXRAM ; stomp audio Output 	
        rts

; ---- end ComputeEcho_Stereo ----


EchoPrepareDelayLineDMA

    lua	    (rD+DMA_NODE_READ0),r0
    move    r0,a                      
    ori     #kDMANode_EOL,a			
    
    move    a,x:(r0+kDMAWord0_NextCmd)	

    ;
    ; prepare read dma block
    ;

    move    x:(rD+FX_STATE_YMEM_BASE),a
    move    a,x:(rD+FX_DELAY_BUFFER_IN)

    ; dsp mem base address
    move    #>kGPMemory_Base_YRAM,x0
    add     x0,a
    move    a,x:(r0+kDMAWord3_DSPAddress)		

    ; zero out sm offset
    move    #0,x0
    move    x0,x:(r0+kDMAWord4_SMOffset)	

    ; circular buffer base
    move    x:(rD+FX_STATE_SCRATCH_BASE),x0
    move    x0,x:(r0+kDMAWord5_SMBaseOffset)	

    ; buffer length
    move    x:(rD+FX_STATE_SCRATCH_LENGTH),a
    IF @DEF('STEREO')
    asr	    #1,a,a 
    ENDIF
    sub     #1,a
    move    a,x:(r0+kDMAWord6_SMLength)	

    move    #DMA_CIRCULAR_READ1_ISO,a
    move    a,x:(r0+kDMAWord1_ControlBits)			
    move    #kFrameLength,a1
    move    a1,x:(r0+kDMAWord2_Count)			
        
    ;
    ; prepare write dma block
    ;

    lua	    (rD+DMA_NODE_WRITE0),r0

    ; dsp mem address
    move    x:(rD+FX_STATE_YMEM_BASE),a
    move    #>kFrameLength,x0
    add     x0,a

    ; save delay buffer
    move    a,x:(rD+FX_DELAY_BUFFER_OUT)

    move    #>kGPMemory_Base_YRAM,x0
    add     x0,a
    move    a,x:(r0+kDMAWord3_DSPAddress)		
    
    ; zero out sm offset
    move    #0,x0
    move    x0,x:(r0+kDMAWord4_SMOffset)	

    ;
    ; circular buffer base
    ;

    move    x:(rD+FX_STATE_SCRATCH_BASE),x0
    move    x0,x:(r0+kDMAWord5_SMBaseOffset)	

    ;
    ; buffer length
    ;

    move    x:(rD+FX_STATE_SCRATCH_LENGTH),a
    IF @DEF('STEREO')
    asr	    #1,a,a 
    ENDIF
    sub     #1,a
    move    a,x:(r0+kDMAWord6_SMLength)	

    move    #DMA_CIRCULAR_WRITE1_ISO,a
    move    a,x:(r0+kDMAWord1_ControlBits)			
    move    #kFrameLength,a1
    move    a1,x:(r0+kDMAWord2_Count)			

    clr     a                      
    ori     #kDMANode_EOL,a			
    move    a,x:(r0+kDMAWord0_NextCmd)	
   
    ;
    ; clear delay lines
    ;

    clr	a
    move    x:(rD+FX_DELAY_BUFFER_IN),r0
    move    x:(rD+FX_DELAY_BUFFER_OUT),r1
    dor     #kFrameLength,ClearDelayLine
    move    a,y:(r0)+
    move    a,y:(r1)+
ClearDelayLine
    rts



       IF @DEF('STANDALONE')
       include "fxDMAUtil.asm"
       ENDIF

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\fft.asm ===
;**************************************************************************
;
;       fft.asm    
;       FFT and iFFT fx. Produces (using dma)
;
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF


        ; disabled dma for now since the host can get the results direct from xram
DMA_ENABLED             equ     0
CIRCULAR_DMA            equ     0
NORM_SCALE              set     (1.0/32.0)

        include 'fft.h'

        org     x:
        ;
        ; create a sin and cos table
        ;


;************************************************************
; StartFFT
;************************************************************
StartFFT
; Data structure pointer already loaded into rD

        FXEntryPoint
        IF DMA_ENABLED
        bsr     FFTPrepareDelayLineDMA
        ENDIF        

        ;
        ; the coefficient tables will be placed directly in X and Y
        ; memory from the host
        ;


ComputeFX
        
	bsr	ComputeFFT
        FXExit




;************************************************************
; ComputeFFT
;************************************************************
ComputeFFT	

        ;
        ; the computation routine process only 32 samples of data at a time
        ; the intermediate results are stored in memory.
        ; a current stage variable tells us where to pick up on the next frame
        ;

        move    #FFT_SIZE/2,n0  ; butterfiles per group
        move    #1,n2           ; groups per pass
        move    #FFT_SIZE/4,n6  ; coefficient increment
        move    -1,m0           ; linear addressing for inputs
        move    m0,m1
        move    m0,m4
        move    m0,m5
        move    #0,m6           ; bit reverse addressing for sin/cos tables

        ;
        ; triple nested DO loop for entire FFT pass
        ;

NUM_PASSES     equ     (@cvi(@log(FFT_SIZE)/(@log(2)+0.5))

        dor #NUM_PASSES, FFT_PassLoop

        move    #data,r0
        move    r0,r4                           ; initialize A input pointer
        lua     (r0)+n0,r1                      ; initialize A output pointer
        move    x:(rD+FX_COEFF_TABLE),r6        ; load table offset (init C pointer)
        move    rD,x:(rD+FX_STATE_PTR)          ; save state pointer r5
        lua     (r1)-1,r5                        ; initialize B output pointer
        move    n0,n1                           ; initialize pointer offsets
        move    n0,n4
        move    n0,n5

        dor n2,FFT_GroupLoop

        move    x:(r1),x1       y:(r6),y0       ; lookup -sine and -cos values
        move    x:(r5),a        y:(r0),b        ; preload data
        move    x:(r6)+n6,x0                    ; update C pointer

        do  n0,FFT_BfyLoop

        mac     x1,y0,b         y:(r1)+,y1
        macr    -x0,y1,b        a,x:(r5)+       y:(r0),a
        subl    b,a             b,x:(r4)+       y:(r0),b

FFT_BfyLoop

        move    a,x:(r5)+n5     y:(r1)+n1,y1    ; update A and B pointers
        move    x:(r0)+n0,x1    y:(r4)+n4,y1

FFT_GroupLoop

        move    n0,b1
        lsr     b               n2,a1
        lsl     a               b1,n0
        move    a1,n2

FFT_PassLoop

        rts





FFT_BfyLoop

FFT_GroupLoop

FFT_PassLoop



        IF DMA_ENABLED
        ; Write output values into delay line
    	lua     (rD+DMA_NODE_WRITE0),r0
        move    r0,a
        IF !@DEF('SIM')
	bsr    DMAStartNode_Wait
        ENDIF

        ENDIF


        rts

    IF DMA_ENABLED
RMSPrepareDelayLineDMA

    ;
    ; prepare write dma block
    ;

    ; dma block location
    lua	    (rD+DMA_NODE_WRITE0),r0
    ; dsp mem address to read RMS results from
    lua     (rD+FX_RMS_TEMP_OUTPUT),r1
    ; system memory address to stick it in
    move    x:(rD+FX_STATE_SCRATCH_BASE),r2
    ; size of dma in words
    move    x:(rD+FX_RMS_NUM_MIXBINS),r3

    ;
    ; prepare the dma words
    ;

    bsr     DMANewNode_Write_Eol     
   
    rts
    ENDIF

    IF @DEF('STANDALONE')
    include "DMAUtil.asm"
    ENDIF

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\fxdmautil.asm ===
;************************************************************
; DMAStart	Write word to start DMA engine and
;			wait until DMA has entered Running state
;
;		Alters DMA Running state (Well, duh !!)
;************************************************************
DMAStart
; Writes to status Bits 5:3 have no effect
    	movep    #>kDMA_ActionRequest_Start,x:DMA_CONTROL_REGISTER	

; Wait for DMA engine to enter Running state: 0 = Idle, 1 = Running
DMAStart_Wait
	brclr 	#kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAStart_Wait

 	rts
; ---- end DMAStart ----

;************************************************************
; DMAStop	Write word to stop DMA engine and
;			wait until DMA has entered Idle state
;
;		Alters DMA Running state (Well, duh !!)
;************************************************************
DMAStop 
; Writes to status Bits 5:3 have no effect
      	movep    #>kDMA_ActionRequest_Stop,x:DMA_CONTROL_REGISTER	

; Wait for DMA engine to enter Idle state: 0 = Idle, 1 = Running
DMAStop_Wait
	brset 	#kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAStop_Wait

 	rts
; ---- end DMAStop ----

;************************************************************
; DMAFreeze	Write word to freeze DMA engine and
;			wait until DMA has entered Freeze state
;
;		Does not alter DMA Running state 
;************************************************************
DMAFreeze 
; Writes to status Bits 5:3 have no effect
      	movep    #>kDMA_ActionRequest_Freeze,x:DMA_CONTROL_REGISTER	

; Wait for DMA engine to enter Frozen state :  0 = Not Frozen, 1 = Frozen
DMAFreeze_Wait
	brclr 	#kDMA_FrozenBit,x:DMA_CONTROL_REGISTER,DMAFreeze_Wait

 	rts
; ---- end DMAFreeze ----

;************************************************************
; DMAStopAndFreeze	Same as calling DMAStop() followed by
;			DMA Freeze
;
;		Alters DMA Running state (Well, duh !!)
;************************************************************
DMAStopAndFreeze 
; Writes to status Bits 5:3 have no effect
      	movep    #>kDMA_ActionRequest_Stop,x:DMA_CONTROL_REGISTER
	
; Wait for DMA engine to enter Idle state: 0 = Idle, 1 = Running
DMAStopAndFreeze_WaitForStop
	brset 	#kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAStopAndFreeze_WaitForStop

; Wait for DMA engine to enter Frozen state :  0 = Not Frozen, 1 = Frozen
      	movep    #>kDMA_ActionRequest_Freeze,x:DMA_CONTROL_REGISTER	
DMAStopAndFreeze_WaitForFreeze
	brclr 	#kDMA_FrozenBit,x:DMA_CONTROL_REGISTER,DMAStopAndFreeze_WaitForFreeze

 	rts
; ---- end DMAStopAndFreeze ----

;************************************************************
; DMAUnFreeze	Write word to unfreeze DMA engine and
;			wait until DMA has entered Freeze state
;
;		Does not alter DMA Running state 
;************************************************************
DMAUnFreeze 
; Writes to status Bits 5:3 have no effect
      	movep    #>kDMA_ActionRequest_UnFreeze,x:DMA_CONTROL_REGISTER	

; Wait for DMA engine to exit Frozen state :  0 = Not Frozen, 1 = Frozen
DMAUnFreeze_Wait
	brset 	#kDMA_FrozenBit,x:DMA_CONTROL_REGISTER,DMAUnFreeze_Wait

 	rts
; ---- end DMAUnFreeze ----

;************************************************************
; DMAUnFreezeAndStart	Same as calling DMAUnFreeze() followed by
;				DMAStart
;
;		Alters DMA Running state (Well, duh !!)
;************************************************************
DMAUnFreezeAndStart 
; Writes to status Bits 5:3 have no effect
      	movep    #>kDMA_ActionRequest_UnFreeze,x:DMA_CONTROL_REGISTER	

; Wait for DMA engine to exitFrozen state :  0 = Not Frozen, 1 = Frozen
DMAUnFreezeAndStart_WaitForUnfreeze
	brset 	#kDMA_FrozenBit,x:DMA_CONTROL_REGISTER,DMAUnFreezeAndStart_WaitForUnfreeze


; Wait for DMA engine to enter Running state: 0 = Idle, 1 = Running
    	movep    #>kDMA_ActionRequest_Start,x:DMA_CONTROL_REGISTER	
DMAUnFreezeAndStart_WaitForStart
	brclr 	#kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAUnFreezeAndStart_WaitForStart

 	rts
; ---- end DMAUnFreezeAndStart ----

;************************************************************
; DMAWaitForEOL		Wait for DMA EOL interrupt and clear register bit
;************************************************************
DMAWaitForEOL 
; Poll for DMA EOL interrupt
DMAWaitForEOL_Poll
	brclr 	#kDMAEndOfListBit,x:INTERRUPT_REGISTER,DMAWaitForEOL_Poll

; Clear DMA EndofList, Bit 7
	movep    #$80,x:INTERRUPT_REGISTER	; "Write-1-To-Clear-One" 
 	rts
; ---- end DMAWaitForEOL ----

;************************************************************
; DMAStartNode_Wait	
;
;	Replace DMA next block ptr, initiate transfer and 
;		Wait for completion
;
;	This function assumes a single DMA node that is
;	setup as the EOL block.
;
;	Parameters:  	 a	next node DSP RAM address 
;************************************************************
DMAStartNode_Wait	
	bsr 	DMAStopAndFreeze

	andi	#>$FFDFFF,a	; Mask out EOL bit	
	movep    a,x:DMA_NEXT_BLOCK_CONTROL_REGISTER

	bsr 	DMAUnFreezeAndStart
	bsr 	DMAWaitForEOL

 	rts
; ---- end DMAStartNode_Wait ----

;************************************************************
; DMAStartNode	
;
;	Replace DMA next block ptr, initiate transfer and 
;		Wait for completion
;
;	This function assumes a single DMA node that is
;	setup as the EOL block.
;
;	Parameters:  	 a	next node DSP RAM address 
;************************************************************
DMAStartNode	
	bsr 	DMAStopAndFreeze

	andi	#>$FFDFFF,a	; Mask out EOL bit	
	movep    a,x:DMA_NEXT_BLOCK_CONTROL_REGISTER

	bsr 	DMAUnFreezeAndStart

 	rts
; ---- end DMAStartNode_Wait ----


        IF      !CIRCULAR_DMA

;************************************************************
; DMANewNode_WriteFrame_Eol	
;
;	This DMA Read node is configured for the System
;	Memory -> DSP transfer of one sample frame buffer.
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r0	node DSP XRAM address
;			r1	DSP    Memory address
;			r2	System Memory address
;************************************************************
DMANewNode_WriteFrame_Eol	
	move	r0,a
	andi	#>kDMANode_EOLMask,a	; Clear reserved upper bits
	ori		#>kDMANode_EOL,a			
        move    a,x:(r0+kDMAWord0_NextCmd)		; Link to itself			

        move    #>DMA_BASE_WRITE1_ISO,a		
	move	a,x:(r0+kDMAWord1_ControlBits)			
        move    #>kFrameLength,a		
	move	a,x:(r0+kDMAWord2_Count)			
	move    r1,x:(r0+kDMAWord3_DSPAddress)		
	move    r2,x:(r0+kDMAWord4_SMOffset)	

 	rts
; ---- end DMANewNode_WriteFrame_Eol ----

;************************************************************
; DMANewNode_ReadFrame_Eol	
;
;	This DMA Read node is configured for the System
;	Memory -> DSP transfer of one sample frame buffer.
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r0	node DSP XRAM address
;			r1	DSP    Memory address
;			r2	System Memory address
;************************************************************
DMANewNode_ReadFrame_Eol	
	move	r0,a
	andi	#>kDMANode_EOLMask,a	; Clear reserved upper bits
	ori		#>kDMANode_EOL,a			
        move    a,x:(r0+kDMAWord0_NextCmd)	; Link to itself			

        move    #>DMA_BASE_READ1_ISO,a		
	move	a,x:(r0+kDMAWord1_ControlBits)			
        move    #>kFrameLength,a		
	move	a,x:(r0+kDMAWord2_Count)			
	move    r1,x:(r0+kDMAWord3_DSPAddress)	 	
	move    r2,x:(r0+kDMAWord4_SMOffset)	

 	rts

        ENDIF
; ---- end DMANewNode_ReadFrame_Eol ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\IIR2.asm ===
;**************************************************************************
;
; IIR2.asm    2nd Order, IIR filter module
;
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'iir2.h'

        ;
        ; worst case cycle usage by this effect (includes one time Init)
        ; stereo: 
        ; mono: 
        ;

IIR2_Default_Frequency	set 4500.0	; hertz
IIR2_Default_Q		set 1.0
IIR2_Default_GainDB	set 15.0
IIR2_Default_Mode	set 0		

Fc			set (IIR2_Default_Frequency/Fs)
Wc			set (IIR2_Default_Frequency/Fs)*kTwoPi
d			set 2.0*@tan(Wc/(2.0*IIR2_Default_Q))/@sin(Wc)

t			set 1.0/2.0*d*@sin(Wc)
beta		        set 0.5*((1.0-t)/(1.0+t))
gamma		        set (0.5+beta)*@cos(Wc)
alpha		        set (0.5+beta-gamma)/4.0
scale24		        set 1.0

iir2_H_LowPass1_b0      set (alpha*scale24)
iir2_H_LowPass1_b1      set (2.0*alpha*scale24)
iir2_H_LowPass1_b2      set (alpha*scale24)
iir2_H_LowPass1_a1      set (gamma*scale24)
iir2_H_LowPass1_a2      set (-beta*scale24)

StartIIR2 

        FXEntryPoint

ComputeFX
	bsr	ComputeIIR2	

        ;
        ; FX exit point
        ;

        FXExit


;************************************************************
; ComputeIIR2	5 MAC, Direct Form IIR, Order 2
;					Ok for in-place operation
;************************************************************
ComputeIIR2	
; rD points to Data Structure 

	move	x:(rD+FX_STATE_IO1_IN),r2
	move	x:(rD+FX_STATE_IO1_OUT0),r3
        move    #>kFrameLength,x0
	dor	x0,ComputeIIR2_Loop

	ori     #$08,mr         ; Set scaling mode to scale up
		    		; when data is moved from accumulator

        ; Do 5 multiply accumulates
        ; y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] + a1*y[n-1] + a2*y[n-2]

	lua	(rD+IIR2_H_B0),r0
	move	x:(rD+FX_DELAY_BASE),r4                 ; load y-mem offset of our delay elements
       
	move	x:(r0)+,x0				
	move	x:(r2)+,y1				
	mpy	x0,y1,a	x:(r0)+,x0 y:(r4)+,y0		; b0*x[n]
        rep     #3
	mac    	x0,y0,a x:(r0)+,x0 y:(r4)+,y0		; b1*x[n-1], b2*x[n-2], a1*y[n-1]
	mac    	x0,y0,a					; a2*y[n-2]        

        move	x:(rD+FX_DELAY_BASE),r4
        ; Shift delay elements
	move	y:(r4+IIR2_Z_X1),x0
	move	x0,y:(r4+IIR2_Z_X2)
	move	y1,x0
	move	x0,y:(r4+IIR2_Z_X1)

	move	y:(r4+IIR2_Z_Y1),x0
	move	x0,y:(r4+IIR2_Z_Y2)
	move	a,x0
	move	x0,y:(r4+IIR2_Z_Y1)

        andi    #$f7,mr         ; Unset scaling mode

        ; check if we need to mix our output
        move    x:(rD+FX_STATE_FLAGS),x1       
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        move	x:(r3),x0
        add     x0,a            ; mix result to audio Output 
STOMP_OUTPUT

	move	a,x:(r3)+

ComputeIIR2_Loop

        rts
; ---- end ComputeIIR2	----

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\init_params.asm ===
; This file was written to enable the reverb engine to run
; in stand-alone mode on the FPGA version of the xbox.
;
; The code in this file does the following
;	1.	Initialises all the constant data for the reverb engine
;	2.	Copies a set of low-level reverb parameters to the
;		reverb engine.

ReverbBase equ $C000

;
; debug only BASE XRAM offset is $80
;

XRAM_BASE               equ $0

; The following constants determine which reverb coefficients are used.
; A set is enabled by setting the appropriate constant equal to 1.
; Make sure that only one constant in the list is ever 1.
BATHROOM		set 1
HANGAR			set 0
TESTREVERB		set 0

;============================================================
;		Initialise the constant data in the reverb engine
;============================================================
InitialiseConstants
        move    #>CrossfeedMatrixChannel3-StaticWorkspaceBase,x0
        move    rD,a
        add     x0,a
        move    a,r0

	move	#>$C00000,x0					;-0.5
	move	x0,x:(r0)+
	move	#>$C00000,x0					;-0.5
	move	x0,x:(r0)+
	move	#>$C00000,x0					;-0.5
	move	x0,x:(r0)+
	move	#>$400000,x0					;0.5
	move	x0,x:(r0)+
	move	#>$C00000,x0					;-0.5
	move	x0,x:(r0)+
	move	#>$C00000,x0					;-0.5
	move	x0,x:(r0)+
	move	#>$C00000,x0					;-0.5
	move	x0,x:(r0)+


;	The following block defines the gains in the reflection feedback loop

        move    #>ReflectionsFeedbackGain-StaticWorkspaceBase,x0
        move    rD,a
        add     x0,a
        move    a,r0

	move	#>-3355443,x0
	move	x0,x:(r0)+
	move	#>3355443,x0
	move	x0,x:(r0)+
	move	#>-3355443,x0
	move	x0,x:(r0)+
	move	#>-3355443,x0
	move	x0,x:(r0)+



; The following array specifies the position of the short reverb input taps
; relative to 'ShortReverbInputDelay'.

        move    #>ShortReverbInputDelayList-StaticWorkspaceBase,x0
        move    rD,a
        add     x0,a
        move    a,r0

	move	#>DefaultShortReverbInputDelay0a*4,x0						; Channel 0a reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbInputDelay0b*4,x0						; Channel 0b reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbInputDelay1a*4,x0						; Channel 1a reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbInputDelay1b*4,x0						; Channel 1b reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbInputDelay2a*4,x0						; Channel 2a reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbInputDelay2b*4,x0						; Channel 2b reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbInputDelay3a*4,x0						; Channel 3a reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbInputDelay3b*4,x0						; Channel 3b reflection
	move	x0,x:(r0)+




; The following values are the constant delays (measured in 
; samples) for the 4 short reverb channels.

        move    #>ShortReverbDelayList-StaticWorkspaceBase,x0
        move    rD,a
        add     x0,a
        move    a,r0

	move	#>DefaultShortReverbDelay0*4,x0				;,x0 Channel 0 reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbDelay1*4,x0				;,x0 Channel 1 reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbDelay2*4,x0				;,x0 Channel 2 reflection
	move	x0,x:(r0)+
	move	#>DefaultShortReverbDelay3*4,x0				;,x0 Channel 3 reflection
	move	x0,x:(r0)+


	IF @DEF('HALFSAMPLERATE')
			; Second order antialiasing filter part 1

        move    #>IIR2_AntiAliasing_Coefficients1-XRAM_BASE,r0
	move	#0.517806,x0
	move	x0,x:(r0)+
	move	#0.587918,x0
	move	x0,x:(r0)+
	move	#0.517806,x0
	move	x0,x:(r0)+
	move	#0.280613,x0
	move	x0,x:(r0)+
	move	#-0.275552,x0
	move	x0,x:(r0)+

		; Second order antialiasing filter part 2
        move    #>IIR2_AntiAliasing_Coefficients2-XRAM_BASE,r0
	move	#0.517806,x0
	move	x0,x:(r0)+
	move	#0.034041,x0
	move	x0,x:(r0)+
	move	#0.517806,x0
	move	x0,x:(r0)+
	move	#0.136654,x0
	move	x0,x:(r0)+
	move	#-0.882101,x0
	move	x0,x:(r0)+
	ENDIF		; end HALFSAMPLERATE

	rts




	IF (BATHROOM)
	msg	"Bathroom reverb coefficients"
;============================================================
;	Download a set of coefficients to the reverb engine.
;============================================================
;	This code performs the task of transferring a set of
;	reverb parameters to the reverb engine.  These parameters
;	correspond to the I3DL2 'bathroom' environment.
;
DownloadCoefficients
        clr     a
	; Initialise the pointer to system memory
        move    #>HostBufferInfo-StaticWorkspaceBase,x0
        move    rD,a
        add     x0,a
        move    a,r0

	move	#>(ReverbBase+(131072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((11999+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(143072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((11999+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(155072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((11999+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(167072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((11999+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(179072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((1359+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(180432-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((1227+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(181660-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((1283+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(182944-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((1439+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(184384-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((2783+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(187168-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((3371+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(190540-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((4087+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(194628-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((4955+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(199584-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((31279+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(230864-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((31279+1)*4-1),x0
	move	x0,x:(r0)+
        
	; Initialise the reverb data parameters
	move	#>336*4,x0			; Reflections delays
	move	x0,x:(r0)+
	move	#>392*4,x0
	move	x0,x:(r0)+
	move	#>372*4,x0
	move	x0,x:(r0)+
	move	#>428*4,x0
	move	x0,x:(r0)+
	move	#>460*4,x0
	move	x0,x:(r0)+

	move	#>524*4,x0			; Short reverb input delay
	move	x0,x:(r0)+
	
	
	move	#>1920*4,x0			; Long reverb input delays
	move	x0,x:(r0)+
	move	#>1016*4,x0
	move	x0,x:(r0)+
	move	#>9044*4,x0
	move	x0,x:(r0)+
	move	#>12000*4,x0
	move	x0,x:(r0)+
	move	#>10960*4,x0
	move	x0,x:(r0)+
	move	#>11908*4,x0
	move	x0,x:(r0)+
	move	#>10960*4,x0
	move	x0,x:(r0)+
	move	#>6512*4,x0
	move	x0,x:(r0)+

	move	#>304*4,x0			; Reflections delays
	move	x0,x:(r0)+
	move	#>284*4,x0
	move	x0,x:(r0)+
	move	#>296*4,x0
	move	x0,x:(r0)+
	move	#>328*4,x0
	move	x0,x:(r0)+

	move	#>31280*4,x0			; Long reverb delay
	move	x0,x:(r0)+

	move	#>8388607,x0		; Short reverb input gains
	move	x0,x:(r0)+
	move	#>-8388607,x0
	move	x0,x:(r0)+
	move	#>-8388607,x0
	move	x0,x:(r0)+
	move	#>8388607,x0
	move	x0,x:(r0)+
	move	#>8388607,x0
	move	x0,x:(r0)+
	move	#>8388607,x0
	move	x0,x:(r0)+
	move	#>-8388607,x0
	move	x0,x:(r0)+
	move	#>-8388607,x0
	move	x0,x:(r0)+

	move	#>0,x0				; Long reverb input gain
	move	x0,x:(r0)+

	move	#>1677721,x0		; Long reverb crossfeed gain
	move	x0,x:(r0)+

	move	#>7715,x0			; Reflections output gains
	move	x0,x:(r0)+
	move	#>7038,x0
	move	x0,x:(r0)+
	move	#>7309,x0
	move	x0,x:(r0)+
	move	#>8121,x0
	move	x0,x:(r0)+

	move	#>67839,x0			; Short reverb output gain
	move	x0,x:(r0)+

	move	#>67839,x0			; Long reverb output gain
	move	x0,x:(r0)+

	move	#>2,x0				; Number of channels
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+
	move	#>7100993,x0		; Input IIR
	move	x0,x:(r0)+
	move	#>1287615,x0
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+
	move	#>6485885,x0		; Main delay line IIRs
	move	x0,x:(r0)+
	move	#>597551,x0       
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+
	move	#>6485885,x0
	move	x0,x:(r0)+
	move	#>597551,x0
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+
	move	#>6485885,x0
	move	x0,x:(r0)+
	move	#>597551,x0
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+        
	move	#>3694380,x0		; Short reverb IIRs
	move	x0,x:(r0)+
	move	#>3589749,x0
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+        
	move	#>4042153,x0
	move	x0,x:(r0)+
	move	#>3141486,x0
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+
	move	#>4406414,x0
	move	x0,x:(r0)+
	move	#>2686101,x0
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+
	move	#>4766351,x0
	move	x0,x:(r0)+
	move	#>2246359,x0
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+
	move	#>8285400,x0		; Long reverb IIRs
	move	x0,x:(r0)+
	move	#>1001,x0
	move	x0,x:(r0)+

        move    #>0,x0
        move    x0,x:(r0)+
	move	#>8285400,x0
	move	x0,x:(r0)+
	move	#>1001,x0
	move	x0,x:(r0)+

	rts

	ENDIF


	IF (HANGAR)
	msg	"Hangar reverb coefficients"
;============================================================
;	Download a set of coefficients to the reverb engine.
;============================================================
;	This code performs the task of transferring a set of
;	reverb parameters to the reverb engine.  These parameters
;	correspond to the I3DL2 hangar environment.
;
DownloadCoefficients
	; Initialise the pointer to system memory
	move	#>HostBufferInfo-XRAM_BASE,r0

;								Host addresses and sizes (converted to bytes)

	move	#>(ReverbBase+(131072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((11999+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(143072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((11999+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(155072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((11999+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(167072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((11999+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(179072-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((1359+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(180432-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((1227+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(181660-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((1283+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(182944-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((1439+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(184384-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((2783+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(187168-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((3371+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(190540-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((4087+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(194628-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((4955+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(199584-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((31279+1)*4-1),x0
	move	x0,x:(r0)+
	move	#>(ReverbBase+(230864-131072)*4),x0
	move	x0,x:(r0)+
	move	#>((31279+1)*4-1),x0
	move	x0,x:(r0)+

;									Delay buffer sizes (converted into bytes)
	move	#>956*4,x0
	move	x0,x:(r0)+
	move	#>1108*4,x0
	move	x0,x:(r0)+
	move	#>1052*4,x0
	move	x0,x:(r0)+
	move	#>1204*4,x0
	move	x0,x:(r0)+
	move	#>1300*4,x0
	move	x0,x:(r0)+
	move	#>1436*4,x0
	move	x0,x:(r0)+
	move	#>1920*4,x0
	move	x0,x:(r0)+
	move	#>1016*4,x0
	move	x0,x:(r0)+
	move	#>9044*4,x0
	move	x0,x:(r0)+
	move	#>12000*4,x0
	move	x0,x:(r0)+
	move	#>10960*4,x0
	move	x0,x:(r0)+
	move	#>11908*4,x0
	move	x0,x:(r0)+
	move	#>10960*4,x0
	move	x0,x:(r0)+
	move	#>6512*4,x0
	move	x0,x:(r0)+
	move	#>528*4,x0
	move	x0,x:(r0)+
	move	#>484*4,x0
	move	x0,x:(r0)+
	move	#>508*4,x0
	move	x0,x:(r0)+
	move	#>564*4,x0
	move	x0,x:(r0)+
	move	#>31280*4,x0
	move	x0,x:(r0)+

;									Gains
	move	#>8388607,x0
	move	x0,x:(r0)+
	move	#>-8388607,x0
	move	x0,x:(r0)+
	move	#>-8388607,x0
	move	x0,x:(r0)+
	move	#>8388607,x0
	move	x0,x:(r0)+
	move	#>8388607,x0
	move	x0,x:(r0)+
	move	#>8388607,x0
	move	x0,x:(r0)+
	move	#>-8388607,x0
	move	x0,x:(r0)+
	move	#>-8388607,x0
	move	x0,x:(r0)+

	move	#>0,x0
	move	x0,x:(r0)+
	move	#>1677721,x0
	move	x0,x:(r0)+
	move	#>5906,x0
	move	x0,x:(r0)+
	move	#>5388,x0
	move	x0,x:(r0)+
	move	#>5595,x0
	move	x0,x:(r0)+
	move	#>6217,x0
	move	x0,x:(r0)+
	move	#>26030,x0
	move	x0,x:(r0)+
	move	#>26030,x0
	move	x0,x:(r0)+

;									Number of channels
	move	#>2,x0


;									IIRs
	move	x0,x:(r0)+
	move	#>6773307,x0
	move	x0,x:(r0)+
	move	#>1615300,x0
	move	x0,x:(r0)+
	move	#>5432341,x0
	move	x0,x:(r0)+
	move	#>2490253,x0
	move	x0,x:(r0)+
	move	#>5432341,x0
	move	x0,x:(r0)+
	move	#>2490253,x0
	move	x0,x:(r0)+
	move	#>5432341,x0
	move	x0,x:(r0)+
	move	#>2490253,x0
	move	x0,x:(r0)+
	move	#>2778974,x0
	move	x0,x:(r0)+
	move	#>5394292,x0
	move	x0,x:(r0)+
	move	#>3097415,x0
	move	x0,x:(r0)+
	move	#>5047235,x0
	move	x0,x:(r0)+
	move	#>3426655,x0
	move	x0,x:(r0)+
	move	#>4684385,x0
	move	x0,x:(r0)+
	move	#>3765125,x0
	move	x0,x:(r0)+
	move	#>4309920,x0
	move	x0,x:(r0)+
	move	#>7862650,x0
	move	x0,x:(r0)+
	move	#>264515,x0
	move	x0,x:(r0)+
	move	#>7862650,x0
	move	x0,x:(r0)+
	move	#>264515,x0
	move	x0,x:(r0)+
	rts

	ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\Flange.asm ===
;***********************************************************************
;
; Flange.asm    
;
;***********************************************************************        

              IF @DEF('STANDALONE')
              include "util.h"
              ENDIF
              include "flange.h"

        ;
        ; worst case cycle usage by this effect (includes one time Init)
        ; stereo: 13215 cycles (ouch)
        ; mono: 6617 
        ;



StartFlange

        FXEntryPoint

        IF @DEF('STEREO')

        ; 
        ; entire delay line is in Y memory
        ; copy some variables to right channel state
        ; then setup left channel first
        ;

        move    x:(rD+FX_DELAY_BASE),x0        
	move	x0,x:(rD+FX_DELAY_INDEX)

        ; calculate delay end index
        ; delay is length is halfed for each channel, since both channels use
        ; same delay line
	move	x:(rD+FX_DELAY_LENGTH),a
        asr     #1,a,a
        move	a,x:(rD+FX_DELAY_LENGTH)

        add     x0,a
        move    a,x:(rD+FX_DELAY_END)

        ; setup right channel

        move    x:(rD+FX_DELAY_LENGTH),x0
        move	x0,x:(rD+FX_DELAY_LENGTH+FLANGE_RIGHTCHANNEL_OFFSET)

	move	x:(rD+FX_DELAY_END),x0
	move	x0,x:(rD+FX_DELAY_INDEX+FLANGE_RIGHTCHANNEL_OFFSET)
        move	x0,x:(rD+FX_DELAY_BASE+FLANGE_RIGHTCHANNEL_OFFSET)

	move	x:(rD+FX_DELAY_LENGTH),a
        add     x0,a
        move    a,x:(rD+FX_DELAY_END+FLANGE_RIGHTCHANNEL_OFFSET)

	move	x:(rD+FLANGE_FEEDBACK),x0
	move	x0,x:(rD+FLANGE_FEEDBACK+FLANGE_RIGHTCHANNEL_OFFSET)

	move	x:(rD+FLANGE_MOD_SCALE_H),x0
	move	x0,x:(rD+FLANGE_MOD_SCALE_H+FLANGE_RIGHTCHANNEL_OFFSET)

        ELSE

        ;
        ; MONO init
        ; entire delay line is in Y memory
        ;

	move	x:(rD+FX_DELAY_BASE),x0
	move	x0,x:(rD+FX_DELAY_INDEX)

        ; calculate delay end index
	move    x:(rD+FX_DELAY_BASE),a
	move	x:(rD+FX_DELAY_LENGTH),x0
        add     x0,a
        move    a,x:(rD+FX_DELAY_END)

        move	x:(rD+FX_STATE_IO2_IN0),x0
        move    x0,x:(rD+FX_INPUT0)
        move	x:(rD+FX_STATE_IO2_IN1),x0
        move    x0,x:(rD+FX_INPUT1)

        move	x:(rD+FX_STATE_IO2_OUT0),x0
        move    x0,x:(rD+FX_OUTPUT0)

        ENDIF

ComputeFX

        IF @DEF('STEREO')
        
        ; duplicate flags for right channel

	move	x:(rD+FLANGE_FEEDBACK),x0
	move	x0,x:(rD+FLANGE_FEEDBACK+FLANGE_RIGHTCHANNEL_OFFSET)

	move	x:(rD+FLANGE_MOD_SCALE_H),x0
	move	x0,x:(rD+FLANGE_MOD_SCALE_H+FLANGE_RIGHTCHANNEL_OFFSET)

        move    x:(rD+FX_STATE_FLAGS),x0
        move    x0,x:(rD+FX_STATE_FLAGS+FLANGE_RIGHTCHANNEL_OFFSET)

        ; mirror input/output pointers from the base FX_STATE block
        ; into the ptrs for each channel

        move	x:(rD+FX_STATE_IO3_IN0),x0
        move    x0,x:(rD+FX_INPUT0)
        ; oscillator is common input for both channels
        move	x:(rD+FX_STATE_IO3_IN2),x0
        move    x0,x:(rD+FX_INPUT1)
        move	x:(rD+FX_STATE_IO3_OUT0),x0
        move    x0,x:(rD+FX_OUTPUT0)

        ; right channel

        move	x:(rD+FX_STATE_IO3_IN1),x0
        move    x0,x:(rD+FX_INPUT0+FLANGE_RIGHTCHANNEL_OFFSET)
        ; oscillator is common input for both channels
        move	x:(rD+FX_STATE_IO3_IN2),x0
        move    x0,x:(rD+FX_INPUT1+FLANGE_RIGHTCHANNEL_OFFSET)
        move	x:(rD+FX_STATE_IO3_OUT1),x0
        move    x0,x:(rD+FX_OUTPUT0+FLANGE_RIGHTCHANNEL_OFFSET)

        ENDIF

	bsr	ComputeFlange

        IF @DEF('STEREO')
        lua     (rD+FLANGE_RIGHTCHANNEL_OFFSET),rD
        bsr     ComputeFlange
        ENDIF

        FXExit

;************************************************************
; ComputeFlange:	
;************************************************************
ComputeFlange
; Data structure pointer pre-loaded in 'D' register

        ; r0 is oscillator 
        ; r1 is delay line index
        ; r2 is audio input 
        ; r3 is audio output

        
        move    x:(rD+FX_INPUT1),r0
	move	x:(rD+FX_INPUT0),r2	; Get x[n] 
        move    x:(rD+FX_OUTPUT0),r3

        dor     #kFrameLength,ComputeFlange_MonoLoop

        move    x:(r0)+,a

; Bias AC-waveform

	move    a,x0
	move    x:(rD+FLANGE_MOD_SCALE_H),y0
	mpy	x0,y0,a	

	sub	y0,a

	move    x:(rD+FX_DELAY_INDEX),x0        
	add	x0,a		

; Wrap
	move    x:(rD+FX_DELAY_END),x0
	move    x:(rD+FX_DELAY_BASE),y0
	move	x:(rD+FX_DELAY_LENGTH),x1

ComputeFlange_Mono_Wrap_IsABigger
	cmp	x0,a		; a - x0
	ble	ComputeFlange_Mono_Wrap_IsASmaller
	sub	x1,a
	bra	ComputeFlange_Mono_Wrap_AOk
ComputeFlange_Mono_Wrap_IsASmaller
	cmp	y0,a		; a - y0
	bge	ComputeFlange_Mono_Wrap_AOk
	add	x1,a
ComputeFlange_Mono_Wrap_AOk
	move	a,r1


        ; y[n] = x[n] + g*y[n-M]
ComputeFlange_Mono_Output
	move	y:(r1),x0		; Read from delay line
	move	x:(rD+FLANGE_FEEDBACK),y0
	mpy	y0,x0,a
	move	x:(r2)+,x0		; Get x[n] 
	add	x0,a
                     
        ; Update current index
	move    x:(rD+FX_DELAY_INDEX),r4
	move	a,y:(r4)+		       	; Write y[n] to delay line
	move    r4,x:(rD+FX_DELAY_INDEX)	; Store current index

        move    x:(r3),x0                       ; read existing audio output(if any)
                            
        move    x:(rD+FX_STATE_FLAGS),x1        ; read existing audio output(if any)
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        add     x0,a            ; mix result to audio Output 
STOMP_OUTPUT
	move	a,x:(r3)+		; add to existing output
                
        move    x:(rD+FX_DELAY_INDEX),x0            
        ; if (index >= end) index = base
	move	x:(rD+FX_DELAY_END),a
	cmp	x0,a			        ; a - x
	bge	ComputeFlange_NoUpdate
	move    x:(rD+FX_DELAY_BASE),x0         ; reset delay index  
	move    x0,x:(rD+FX_DELAY_INDEX)
ComputeFlange_NoUpdate
        nop

ComputeFlange_MonoLoop

ComputeFlange_MonoEnd

        rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\Math.asm ===
;**************************************************************************
;
; Math.asm    
;       
; 
;		Written by Gints Klimanis
;
; Assembler provides:
; ACS - Arc cosine
; ASN - Arc sine
; AT2 - Arc tangent
; ATN - Arc tangent
; COH - Hyperbolic cosine
; COS - Cosine
; SIN - Sine
; SNH - Hyperbolic sine
; TAN - Tangent
; TNH - Hyperbolic tangent

; L10 - Log base 10
; LOG - Natural logarithm
; POW - Raise to a power
; XPN - Exponential function
; SQT - Square root

; ABS - Absolute value
; CEL - Ceiling function
; FLR - Floor function
; MAX - Maximum value
; MIN - Minimum value
; RND - Random value
; SGN - Return sign

; CVF - Convert integer to floating point
; CVI - Convert floating point to integer
; CVS - Convert memory space
; FLD - Shift and mask operation
; FRC - Convert floating point to fractional
; LFR - Convert floating point to long fractional
; LNG - Concatenate to double word
; LUN - Convert long fractional to floating point
; RVB - Reverse bits in field
; UNF - Convert fractional to floating point 

;**************************************************************************        
	list  

;*******************************************************************
;DivideA
;  Input:  y1  and  a
; Output:  a=a/y1
;************************************************************
DivideA
	and     #$fe,ccr
	rep     #$18
	div     y1,a
	move    a0,a1
	move    #0,a2

	rts
; ---- end DivideA ----

;*******************************************************************
;DivideB
;  Input:  y1  and  b
; Output:  b=b/y1
;************************************************************
DivideB
	and     #$fe,ccr
	rep     #$18
	div     y1,b
	move    b0,b1
	move    #0,b2

	rts
; ---- end DivideB ----

;***********************************************************************
;  Sqrt							       *	
;	Full 23 bit precision square root routine using                *
;       a successive approximation technique.		               * 		
; SQRT Macro
; y  = double precision (48 bit) positive input number
; b  = 24 bit output root
;
; a  = temporary storage
; x0 = guess
; x1 = bit being tested
; y1:y0 = input number
;***********************************************************************
;sqrt3   macro
;sqrt3   ident   1,0
; 
;sqrt3
;        clr     b    #<$40,x0           ; init root and guess
;        move          x0,x1             ; init bit to tes
;  do    #23,_endl                       ;START OF LOOP
;        mpy     -x0,x0,a                ; square and negate the guess
;        add     y,a                     ; compare to double precision input
;        tge     x0,b                    ; update root if input >= guess
;        mpy    x1,#1,a       
;        nop
;        add     b,a     a,x1            ; form new guess
;        nop
;        move                    a,x0            ; save new guess
;        
;_endl                                    ;END OF LOOP
;        endm
; ---- end Sqrt ----

;************************************************************
; Exp        x       (log2ofE * x)
;           e  =   2
;************************************************************
Exp 
; Operand in x0

; x         *= (float) kLog2_E;
; exp2Approx = 0.1713425f*x*x + 0.6674432f*x + 0.9979554f;
;                 a2            a1           a0


; 0.1713425*(kLog2_E * kLog2_E) = 0.3566269646
; 0.6674432*(kLog2_E)           = 0.9629169947
; expApprox = 0.3566269646*x*x + 0.9629169947*x + 0.9979554f;

        mpyr    x0,x0,a			;x**2
		move   #>.3566269646,y0
		move	a,x1
		mpyr    x1,y0,a		; Have a2*x*x
		move	a,x1

		move   #>.9629169947,y0
        mpyr    x0,y0,a			; Have a1*x
        add     x1,a            	; Add a2*x^2

		move   #>.9979554,y0
        add     y0,a           		; Add a0

 rts
; ---- end Exp ----

;************************************************************
; Exp2        x       
;           2  = .1713425 x*x + .6674432 x + .9979554
;
; Polynomial approximation, 8 bit accuracy.
;      for -1 < x <= 0
;
;       Input in x0, output in A
;************************************************************
Exp2 

;       2^x =.1713425*x^2 + .6674432*x + .9979554
;                 a2            a1           a0

        mpyr    x0,x0,a			;x**2
		move   #>.1713425,y0
		move	a,x1
		mpyr    x1,y0,a			; Have a2*x*x
		move	a,x1

		move   #>.6674432,y0
        mpyr    x0,y0,a			; Have a1*x
        add     x1,a            ; Add a2*x^2

		move   #>.9979554,y0
        add     y0,a           ; Add a0

 rts
; ---- end Exp2 ----

;************************************************************
; Sig24div		a/x0, where a >= x0
;
;		Quotient in x1, remainder in b1
;************************************************************
Sig24div
	abs 	a	a,b
	eor	x0,b b,x:$0
	and 	#$fe,ccr
	rep	#$18
	div	x0,a
	tfr	a,b
	jpl	Sig24div_savequo
	neg	b
Sig24div_savequo
	tfr	x0,b	b0,x1
	abs	b
	add	a,b
	jclr 	#23,x:$0,Sig24div_done
	move	#$0,b0
	neg	b
Sig24div_done

	rts
; ---- end Sig24div ----

;************************************************************
; nToSintSfrac		Convert negative 56-bit number in a
;			to signed integer in a1 and
;			signed fraction in b1
;
;************************************************************
nToSintSfrac
	abs 	a	
	lsl	a
	asr	a
	move	a0,b
	neg	b #0,a0
	neg	a

	rts
; ---- end nToSintSfrac ----

;************************************************************
; pToSintSfrac		Convert positive 56-bit number in a
;			to signed integer in a1 and
;			signed fraction in b1
;
;************************************************************
pToSintSfrac
	lsl	a
	asr	a
	move	a0,b
	move	#0,a0

	rts
; ---- end pToSintSfrac ----

;************************************************************
; SinX        Sine polynomial approximation
;                                   2           3             4            5
; sin(x) = 3.140625*x + 0.02026367*x -5.325196*x + 0.5446778*x - 1.800293*x
;
;  5.325196*(0.589767f,  0.003805f  , -1.000000f,  0.102283f , -0.338071f)
;
;      for 0 <= x <= 1.0
;
;       Input in x0, output in A
;************************************************************
SinX  

SinX_Quad1or2
	move	#>0.5,a
	cmp	x0,a
	bge	Sinx_ComputePoly
	move	#>1.0,a
	sub	x0,a
	move	a,x0

Sinx_ComputePoly
	move	#>0.589767,y0
	move	x0,x1		; x
	mpy	x0,y0,a		

	mpy	x0,x1,b
	move	b,x1		; x*x
	move	#>0.003805,y1
	mac	x1,y1,a

	mpy	x0,x1,b
	move	b,x1		; x*x*x
	move	#>-1.000000,y1
	mac	x1,y1,a

	mpy	x0,x1,b
	move	b,x1		; x*x*x*x
	move	#>0.102283,y1
	mac	x1,y1,a

	mpy	x0,x1,b
	move	b,x1		; x*x*x*x*x
	move	#>-0.338071,y1
	mac	x1,y1,a

;  Now, scale to output range with k=5.325196 = (4.0 + 1.0 + 0.325196)
SineX_ReScale
	move	a,x0
	asl	#2,a,a
	add	x0,a
	move	#>0.325196,y1
	mac	x0,y1,a

	rts	
; ---- end SinX() ----


;************************************************************
; CosX        Cosine polynomial approximation
;
;      for 0 <= x <= 1.0
;
;       Input in x0, output in A
;************************************************************
CosX  
;if (x > 0.5f)
;	y = -Sin(x-0.5f);
;else
;	y = Sin(x+0.5f);
	move	#>0.5,a
	cmp	x0,a
	bge	CosX_Quad1

CosX_Quad2
	neg	a
	add	x0,a	; x-0.5
	move	a,x0
	jsr	SinX
	neg	a
	bra	CosX_End
CosX_Quad1
	add	x0,a	; x+0.5
	move	a,x0
	jsr	SinX

CosX_End
	rts	
; ---- end CosX() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\mixer.asm ===
;**************************************************************************
;
;       mixer.asm    
;       	
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'mixer.h'


MixerDefault_Gain	equ	1

;************************************************************
; StartMixer	
;************************************************************
StartMixer 
; Data structure pointer already loaded into rD

        FXEntryPoint
        
ComputeFX
        
	bsr	ComputeMixer

        FXExit



;************************************************************
; ComputeMixer
;************************************************************
ComputeMixer

        FXSetSMMode

        ; mix channels 0,1 of input data to output buffer 0
	move	x:(rD+FX_STATE_IO2_IN0),r0
        move	x:(rD+FX_STATE_IO2_IN1),r1
	move	x:(rD+FX_STATE_IO2_OUT0),r2
        clr     a

        dor     #>kFrameLength,MixLoop1
        move    x:(r2),b

        move    x:(r0)+,x0
        move    x:(rD+GAIN_IN0),y0
        mpy     x0,y0,a
        add     a,b

        move    x:(r1)+,x0
        move    x:(rD+GAIN_IN1),y0
        mpy     x0,y0,a

        add     a,b
        move    b,x:(r2)+
MixLoop1
         
        IF      @DEF('IO_4IN_2OUT')
        ; mix channels 2,3 of input data to output buffer 1

	move	x:(rD+FX_STATE_IO2_IN2),r0
        move	x:(rD+FX_STATE_IO2_IN3),r1
	move	x:(rD+FX_STATE_IO2_OUT1),r2
        clr     a

        dor     #>kFrameLength,MixLoop2
        move    x:(r2),a
        move    x:(r0)+,x0
        add     x0,a
        move    x:(r1)+,x0
        add     x0,a
        move    a,x:(r2)+
MixLoop2
        nop

        ENDIF

        FXUnsetSMMode
        nop
        rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\osci_iir.asm ===
;**************************************************************************
;
;       osci.asm    
;       Generate sin from second order IIR
;       y[n] = h*y[n-1] - y[n-2] 
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'osci.h'


;************************************************************
; StartLFO	
;************************************************************
StartOscillator
; Data structure pointer already loaded into rD

        FXEntryPoint
        
ComputeFX
        
	bsr	ComputeOscillator

        FXExit



;************************************************************
; ComputeOscillator
;************************************************************
ComputeOscillator

	move	x:(rD+FX_STATE_IO0_OUT0),r3

        move    x:(rD+FX_OSCILLATOR_H),x0
        move    x:(rD+FX_OSCILLATOR_Y1),y0  
        move    x:(rD+FX_OSCILLATOR_Y2),b  

	dor	#kFrameLength,LoopEnd

        ;  y[n] = h*y[n-1] - y[n-2] 
	mpy     x0,y0,a                 ; Get  h*y1 in 2:14 format
        subl    b,a		        ; Get (h*y1 - y2)= y in 
                                        ; fractional format
        move    a,x:(rD+FX_OSCILLATOR_Y1)  
        move    y0,x:(rD+FX_OSCILLATOR_Y2)             

        move	a,x:(r3)+

LoopEnd

        rts


FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\osci.asm ===
;**************************************************************************
;
;       LFO.asm    
;       	
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'osci_table.h'

; since our table is 64 elements, one full pass through it generates a 48000/64=750 hz sine wave
; to allow the caller to specify small increments, dive their FX_FREQ0 param by 7500 so the units
; are in tenths of a Hz

FREQ_CONVERSION set     1.0/7500.0
GAIN            set     0.5

;************************************************************
; StartLFO	
;************************************************************
StartLFO
; Data structure pointer already loaded into rD

        FXEntryPoint

ComputeFX
        
	bsr	ComputeLFO
        FXExit



;************************************************************
; ComputeOscillator
; split channel 0 to channels 0,1,2,3,.., N of output data
;************************************************************
ComputeLFO

        ; load base of table
        lua     (rD+FX_SIN_TABLE),r2

        ; load base address of output IO ptr array
        lua	(rD+FX_STATE_IO0_OUT0),r1
        ; load index base
        lua	(rD+FX_TABLE_INDEX0),r6
        ; load freq factor
        lua	(rD+FX_FREQ0),r7

        move    x:(rD+FX_NUM_OUTPUTS),x0

        dor     x0,OutputsLoop

        ; load output IO ptr
        move    x:(r1)+,r4

        ; load current index       
        move    x:(r6),a0
        move    x:(r6+1),a1

        dor     #kFrameLength,FrameLoop

        ; retrieve base ptr of table
        move    r2,b
        add     a,b

        move    b1,r3

        move    x:(r3),x0
        move    x0,x:(r4)+

        ; load frequency
        move    x:(r7),x0
        move    #FREQ_CONVERSION,y0
        mpy     x0,y0,b

        add     b,a
        and     #$3f,a


FrameLoop        

        ; save integer part (high order bits of a) as the index
        move    a0,x:(r6)+
        move    a1,x:(r6)+
        ;increment freq base
        move    x:(r7)+,x0

OutputsLoop

        nop 
        rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\minirvb.asm ===
;**************************************************************************
;
;       minirvb.asm    
;       	
;**************************************************************************        
     
        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'minirvb.h'

        org    p:

        IF @DEF('STANDALONE')
CIRCULAR_DMA            equ     1
        ENDIF


;************************************************************
; StartReverb	
;************************************************************
StartReverb 
; Data structure pointer already loaded into rD

        FXEntryPoint

        IF @DEF('FX_TEST')

        ;
        ; fill in variable sin xram to simulate runtime conditions
        ;
            

        ; setup scratch

        move    #$C000,x0
        move    x0,x:(rD+FX_STATE_SCRATCH_BASE)

        move    #>kMixBuf0,x0     
	move	x0,x:(rD+FX_STATE_IO1_IN)                                      ; LEFT INPUT

        move    #>kReadWriteMixBuf00,x0         ; front left
        move	x0,x:(rD+FX_STATE_IO1_OUT0) 
        move    #>kReadWriteMixBuf01,x0         ; front right
        move	x0,x:(rD+FX_STATE_IO1_OUT1) 
        move    #>kReadWriteMixBuf04,x0         ; rl
        move	x0,x:(rD+FX_STATE_IO1_OUT2) 
        move    #>kReadWriteMixBuf05,x0         ; rl
        move	x0,x:(rD+FX_STATE_IO1_OUT3) 

        ; setup temp bins
        move    #>$cb,x0 
	move	x0,x:(rD+FX_STATE_IO1_OUT3+1) 
        move    #>$eb,x0 
	move	x0,x:(rD+FX_STATE_IO1_OUT3+2) 
        move    #>$10b,x0 
	move	x0,x:(rD+FX_STATE_IO1_OUT3+3) 
        move    #>$12b,x0 
	move	x0,x:(rD+FX_STATE_IO1_OUT3+4) 

        ; setup reflection lengths

        move    #>1024,x0 
	move	x0,x:(rD+Reflection0Length-StateBlock) 
        move    #>2048,x0 
	move	x0,x:(rD+Reflection1Length-StateBlock) 
        move    #>3072,x0 
	move	x0,x:(rD+Reflection2Length-StateBlock) 
        move    #>4096,x0 
	move	x0,x:(rD+Reflection3Length-StateBlock) 

        ; setup reflection taps

        move    #>124,x0 
	move	x0,x:(rD+Reflection0Tap-StateBlock) 
        move    #>248,x0 
	move	x0,x:(rD+Reflection1Tap-StateBlock) 
        move    #>372,x0 
	move	x0,x:(rD+Reflection2Tap-StateBlock) 
        move    #>496,x0 
	move	x0,x:(rD+Reflection3Tap-StateBlock) 

        ENDIF

        bsr     PrepareDelayLineDMA

ComputeFX
	bsr	ComputeReverb	

        FXExit

; ---- end StartEcho ----


;************************************************************
; ComputeEcho
;************************************************************
ComputeReverb	

; dma 32 samples of the delay line in scratch memory
; stick it in temporary buffer in Y memory


; **********************************************************
        ; Read all reflections from delay line into input buffer
        move    rD,a
        add     #(DMAReadBlock0-StateBlock),a		
        move    a,r0

        IF !@DEF('SIM')
	bsr    DMAStartNode_Wait    
        ENDIF

        ; Scale the direct path input data
	move	x:(rD+FX_STATE_IO1_IN),r0
	move	r0,r1
        move    #$400000,x0
        bsr     ScaleX 
                  
        ; scale first reflection

	move	x:(rD+pTemp-StateBlock),r0
        move    r0,r1
        move    x:(rD+Reflection0Gain-StateBlock),x0
        bsr     ScaleX

	move	x:(rD+pReflection1-StateBlock),r0
	move	x:(rD+pTemp-StateBlock),r1
        move    x:(rD+Reflection1Gain-StateBlock),x0
        bsr     ScaleXAddX

	move	x:(rD+pReflection2-StateBlock),r0
	move	x:(rD+pTemp-StateBlock),r1
        move    x:(rD+Reflection2Gain-StateBlock),x0
        bsr     ScaleXAddX

	move	x:(rD+pReflection2-StateBlock),r0
	move	x:(rD+pTemp-StateBlock),r1
        move    x:(rD+Reflection2Gain-StateBlock),x0
        bsr     ScaleXAddX

	move	x:(rD+pReflection3-StateBlock),r0
	move	x:(rD+pTemp-StateBlock),r1
        move    x:(rD+Reflection3Gain-StateBlock),x0
        bsr     ScaleXAddX

	move	x:(rD+pReflection4-StateBlock),r0
	move	x:(rD+pTemp-StateBlock),r1
        move    x:(rD+Reflection4Gain-StateBlock),x0
        bsr     ScaleXAddX

	move	x:(rD+pReflection5-StateBlock),r0
	move	x:(rD+pTemp-StateBlock),r1
        move    x:(rD+Reflection5Gain-StateBlock),x0
        bsr     ScaleXAddX

	move	x:(rD+pReflection6-StateBlock),r0
	move	x:(rD+pTemp-StateBlock),r1
        move    x:(rD+Reflection6Gain-StateBlock),x0
        bsr     ScaleXAddX

	move	x:(rD+pReflection7-StateBlock),r0
	move	x:(rD+pTemp-StateBlock),r1
        move    x:(rD+Reflection7Gain-StateBlock),x0
        bsr     ScaleXAddX

        ;
        ; add direct path to temp results
        ;

	move	x:(rD+FX_STATE_IO1_IN),r0
	move	x:(rD+pTemp-StateBlock),r1
        bsr     AddX


        ;
        ; filter reflection sum
        ;

        move    rD,a
        add     #(IIR0-StateBlock),a
        move    a,r1
        move	x:(rD+pTemp-StateBlock),r0
        bsr     IIR_InPlace

        move    rD,a
        add     #(IIR1-StateBlock),a
        move    a,r1
        move	x:(rD+pTemp-StateBlock),r0
        bsr     IIR_InPlace


        ; Write result into delay line
        move    rD,a
    	add     #(DMAWriteBlock0-StateBlock),a
        move    a,r0

        IF !@DEF('SIM')
	bsr    DMAStartNode_Wait
        ENDIF

        move    x:(rD+FX_STATE_FLAGS),x1   
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT

	
	lua	(rD+FX_STATE_IO1_OUT0),r2
        dor     #4,MixOutputLoop

	move	x:(rD+pTemp-StateBlock),r0
	move	x:(r2)+,r1
        bsr     AddX    
MixOutputLoop
        nop

        rts

STOMP_OUTPUT
	move	x:(rD+pTemp-StateBlock),r0
	lua	(rD+FX_STATE_IO1_OUT0),r2

        dor     #4,StompOutputLoop
	move	x:(rD+pTemp-StateBlock),r0
	move	x:(r2)+,r1

        bsr     CopyXtoXRAM ; stomp audio Output 	

StompOutputLoop
        nop

        rts

;-------------------------------------------

IIR_InPlace
	move	x:(r1+IIR_CoefficientA1),y0
	move	x:(r1+IIR_CoefficientB0),y1

	dor	#kFrameLength,IIRLoop
		move	x:(r1+IIR_DelayElement),x0
		mpy	x0,y0,a      x:(r0),x1
		mac	x1,y1,a

		move	a,x:(r1+IIR_DelayElement)
		move	a,x:(r0)+
IIRLoop
	rts

;-----------------------------------------------------------


PrepareDelayLineDMA

    ;
    ; create the read dma blocks
    ;

    move    rD,a
    add     #(DMAReadBlock0-StateBlock),a
    move    a,r0

    move    #kDMANode_MaxSize,n0

    move    rD,a
    add     #(DMAWriteBlock0-StateBlock),a
    move    a,r4

    move    #kDMANode_MaxSize,n4

    ; we make the assumption that the pTemp ptr and pReflectionXX
    ; are right next to each to other.Relfection0 gest DMAed in pTemp

    lua     (rD+pTemp-StateBlock),r1
    lua     (rD+Reflection0Length-StateBlock),r2
    lua     (rD+Reflection0Tap-StateBlock),r3

    dor     #NUM_REFLECTIONS,ExternalReadDmaLoop

        ; word3, dsp mem base address
        move    #>kGPMemory_Base_XRAM,a
        move    x:(r1)+,x0
        add     x0,a
        move    a,x:(r0+kDMAWord3_DSPAddress)		

        ; WRITEDMA word3, dsp mem base address
        move	x:(rD+pTemp-StateBlock),x0
        move    x0,x:(r4+kDMAWord3_DSPAddress)		

        move    x:(rD+FX_STATE_SCRATCH_BASE),a
        ;add delay tap to delay base
        move    x:(r3)+,x0
        add     x0,a        
        ;word5, circular buffer base
        move    a,x:(r0+kDMAWord5_SMBaseOffset)	

        ; writedma, word5
        move    a,x:(r4+kDMAWord5_SMBaseOffset)	


        ; read length
        move    x:(r2)+,x0
        move    x0,x:(r0+kDMAWord6_SMLength)	

        move    x0,x:(r4+kDMAWord6_SMLength)	

        ; word1, control bits
        move    #DMA_CIRCULAR_READ1_ISO,a
        move    a,x:(r0+kDMAWord1_ControlBits)			
        ; write dma
        move    #DMA_CIRCULAR_WRITE1_ISO,a
        move    a,x:(r4+kDMAWord1_ControlBits)			

        ; word2,  count
        move    #kFrameLength,a1
        move    a1,x:(r0+kDMAWord2_Count)			
        ; write dma
        move    a1,x:(r4+kDMAWord2_Count)			

        ; word0, nextCmd
        move    r0,a
        add     #kDMANode_MaxSize,a
        move    a,x:(r0)+n0	

        move    r4,a
        add     #kDMANode_MaxSize,a
        move    a,x:(r4)+n4	


ExternalReadDmaLoop

    ;
    ; on the last read block, set EOL bit
    ;

    clr     a
    ori     #kDMANode_EOL,a			    
    move    a,x:(r0-kDMANode_MaxSize)	
        
    clr     a
    ori     #kDMANode_EOL,a			    
    move    a,x:(r4-kDMANode_MaxSize)	

   
    rts

;-----------------------------------------------------------
CopyXtoXRAM
    dor      #kFrameLength,CopyXtoXRAM_Loop             
	move	x:(r0)+,x0
	move	x0,x:(r1)+
CopyXtoXRAM_Loop
 	

;-----------------------------------------------------------

AddX  
    dor      #kFrameLength,AddX_Loop             
	move	x:(r0)+,x0
	move	x:(r1),a
	add	x0,a
	move	a,x:(r1)+
AddX_Loop 	
    rts

;-----------------------------------------------------------

ScaleX 
    dor      #kFrameLength,ScaleX_Loop             
	move	x:(r0)+,y0
	mpy	x0,y0,a
	move	a,x:(r1)+
ScaleX_Loop
    rts
;-----------------------------------------------------------

;-----------------------------------------------------------

ScaleXAddX 
    dor      #kFrameLength,ScaleXAddX_Loop             
	move	x:(r0)+,y0
	mpy	x0,y0,a    x:(r1),x1
        add     x1,a
	move	a,x:(r1)+
ScaleXAddX_Loop
    rts
;-----------------------------------------------------------

    IF @DEF('STANDALONE')
    include "fxDMAUtil.asm"
    ENDIF

FX_END
    nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\osci_table.asm ===
;**************************************************************************
;
;       LFO.asm    
;       	
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'osci_table.h'

FREQ_CONVERSION set     1.0/4500.0
GAIN            set     0.5

;************************************************************
; StartLFO	
;************************************************************
StartLFO
; Data structure pointer already loaded into rD

        FXEntryPoint

ComputeFX
        
	bsr	ComputeLFO
        FXExit



;************************************************************
; ComputeOscillator
; split channel 0 to channels 0,1,2,3,.., N of output data
;************************************************************
ComputeLFO

        ; load base of table
        lua     (rD+FX_SIN_TABLE),r2


        ; load base address of output IO ptr array
        lua	(rD+FX_STATE_IO1_OUT0),r1


        ; load output IO ptr
        move    x:(r1)+,r4

        ; load current index       
        move    x:(rD+FX_TABLE_INDEX),a0
        move    x:(rD+FX_TABLE_INDEX+1),a1

        dor     #kFrameLength,FrameLoop

        ; retrieve base ptr of table
        move    r2,b
        add     a,b

        move    b1,r3

        move    x:(r3),x0
        move    x0,x:(r4)+

        move    x:(rD+FX_FREQ0),x0
        move    #FREQ_CONVERSION,y0
        mpy     x0,y0,b

        add     b,a
        and     #$3f,a


FrameLoop
        

        ; save integer part (high order bits of a) as the index
        move    a0,x:(rD+FX_TABLE_INDEX)
        move    a1,x:(rD+FX_TABLE_INDEX+1)

        nop 
        rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\rateconv.asm ===
;**************************************************************************
;
;       rateconv.asm    
;       	
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'rateconv.h'

CIRCULAR_DMA            equ     1


;************************************************************
; StartSRC	
;************************************************************
StartSRC
; Data structure pointer already loaded into rD

    FXEntryPoint
    move    #1,x0
    move    x0,x:(rD+FX_INDEX)
    bsr     PrepareDelayLineDMA
        
ComputeFX
        
    bsr	ComputeSRC

    FXExit



;************************************************************
; ComputeSRC
;************************************************************
ComputeSRC


    ; decimate the current input by using the SRC step parameter
    move    x:(rD+FX_STATE_IO1_IN),r0
    move    x:(rD+FX_TEMP_BUFFER),r1
    move    x:(rD+FX_INDEX),a
    move    x:(rD+FX_SRC_STEP),y0

    ; keep track of the # values we write into the temp buffer
    clr     b

    dor     #kFrameLength,Loop

    ; read input sample
    move    x:(r0)+,x0      

    cmp     y0,a
    blt     Skip
    ; clear index
    clr     a
    ; take input sample and move it into temp buffer
    move    x0,x:(r1)+ 
    add     #1,b

Skip
    add     #1,a

Loop
    ; save current index
    move    a,x:(rD+FX_INDEX)

    ; do write DMA
    lua     (rD+DMA_NODE_WRITE0),r0

    ; update word count for dma write block to reflect how many
    ; words we put in the delay buffer in this iteration
    move    b,x:(r0+kDMAWord2_Count)			

    move    r0,a
    IF !@DEF('SIM')
    bsr    DMAStartNode_Wait
    ENDIF
  
    rts

;************************************************************
; PrepareDelayLineDMA
;************************************************************

PrepareDelayLineDMA
        
    ;
    ; prepare write dma block
    ;

    lua	    (rD+DMA_NODE_WRITE0),r0

    ; dsp mem address
    move    x:(rD+FX_TEMP_BUFFER),a
    move    #>kGPMemory_Base_XRAM,x0
    add     x0,a
    move    a,x:(r0+kDMAWord3_DSPAddress)		
    
    ;
    ; circular buffer base
    ;

    move    x:(rD+FX_STATE_SCRATCH_BASE),x0
    move    x0,x:(r0+kDMAWord5_SMBaseOffset)	

    ;
    ; buffer length
    ;

    move    x:(rD+FX_STATE_SCRATCH_LENGTH),a
    sub     #1,a
    move    a,x:(r0+kDMAWord6_SMLength)	

    move    #DMA_CIRCULAR_WRITE1_ISO,a
    move    a,x:(r0+kDMAWord1_ControlBits)			

    move    #kFrameLength,a1
    move    a1,x:(r0+kDMAWord2_Count)			

    clr     a                      
    ori     #kDMANode_EOL,a			
    move    a,x:(r0+kDMAWord0_NextCmd)	
   
    rts



    IF @DEF('STANDALONE')
    include "fxDMAUtil.asm"
    ENDIF

FX_END
    nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\rms.asm ===
;**************************************************************************
;
;       rms.asm    
;       simple 'fx' that calculates the average value of eac 32 sample frame	
;       and outputs it using DMA to system memory (one dword for each mixbin)
;
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF


        ; disabled dma for now since the host can get the results direct from xram
NORM_SCALE              set     (1.0/32.0)

        include 'rms.h'

;************************************************************
; StartRMS
;************************************************************
StartRMS
; Data structure pointer already loaded into rD

        FXEntryPoint
        
ComputeFX
        
	bsr	ComputeRMS	
        FXExit


;************************************************************
; ComputeRMS
;************************************************************
ComputeRMS	

	lua	(rD+FX_STATE_IO6_IN0),r0
        lua     (rD+FX_RMS_AVG_OUTPUT),r1
        lua     (rD+FX_RMS_MAX_OUTPUT),r2
        move    x:(rD+FX_RMS_NUM_MIXBINS),x0

        ; use a circular buffer to store the last N values


        dor     x0,RMS_MIXBIN_LOOP

        move    x:(r0)+,r4

        ;
        ; create an RMS output out of the current 32 samples in the 6 speaker mixbins
        ; the RMS output will be DMAed back in system memory taking up 6 consecutive DWORDs
        ; of scratch space
        ;

        bsr     AccX

        ; save result, increment pointers

        move    a,x:(r1)+    

        ; increment r2
        move    x:(r2)+,a

RMS_MIXBIN_LOOP

        rts



AccX 
    ; zero out prev. frame cummulative value
    clr     a
    dor     #kFrameLength,AccX_Loop             

    move    x:(r4)+,b
    abs     b

    ; save A and B real quick.
    move    b,x0
    move    a,y0

    ; put current sample into A
    move    b,a

    ; compare this value with the maximum
    move    x:(r2),b
    max     a,b

    ;update maximum
    move    b,x:(r2)

    ; restore a
    move    y0,a

    move    #NORM_SCALE,y0
    mac     x0,y0,a

AccX_Loop


    rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\RvbFaderData.asm ===
;	File	:	RvbFaderData.asm
;	Version	:	1.0
;	Date	:	29/09/2000
;
;	Author	:	RDA
;				Sensaura Ltd
;
;
;
; Description
; ===========
; This file defines the data space for the reverb fader.
;
; ***************************************
; ** THIS FILE MUST BE INCLUDED AT THE **
; ** END OF THE FILE "REVERBDATA.ASM"  **
; ***************************************
;	The reason is because this file allocates data space using the 'org:x'
;	instruction and this data must be located with specific bounds for
;	the data space to be initialise correctly.
;
; Version history
; ===============
;	0.x		Development versions
;	1.0		First working version


	org	x:




;	RVB_FaderState determines the state of the fader and indicates which 
;	buffer is being faded at the moment.
;	Bit n of 'RVB_FaderState' is set to indicate that buffer 'n' is being
;	faded. If 'RVB_FaderState'=0 the fader is disabled. Only one buffer
;	can be faded at once.
;
;	RVB_FaderState
;		0	Not fading
;		2^n	Fading buffer n

RVB_FaderState
	dc	0



;	RVB_FaderStep denotes the stage of the current fading operation.  In 
;	practice RVB_FaderStep takes the value equal to the number of samples processed
;	during the current buffer.
;
;	A value between 0 to 255 indicates that the fader is ramping the amplitued down
;	A value equal to 256 indicates that the buffer should have faded
;		to zero so we can change the tap position
;	A value between 257 to 511 indicates that the fader is ramping the amplitued up
;	A value equal to 512 indicates that the fader has finished fading the current
;		buffer.
;
;		0	<= RVB_FaderStep <= 512
RVB_FaderStep
	dc	0



;	RVB_FaderStepSize is the size of the steps applied to RVB_FaderGain
;	on consecutive samples when fading.
;
;		RVB_FaderStepSize += 1/256
RVB_FaderStepSize
	dc	0



;	RVB_FaderGain is the gain of the fader.
;
;		1.0-(1/256) <= RVB_FaderGain < 0
RVB_FaderGain
	dc	0



;	RVB_FaderpDMAread is a pointer to the DMA read block corresponding to
;	the current buffer that is being faded
RVB_FaderpDMAread
	dc	0



;	RVB_FaderpDMAwrite is a pointer to the DMA write block corresponding to
;	the current buffer that is being faded.  This is required when the 
;	tap position is being updated because the DMA read block offset is
;	measured relative to this.
RVB_FaderpDMAwrite
	dc	0


;	After each buffer has been faded, the pointer to the DMA write 
;	control block is incremented by RVB_FaderDMAwriteIncrement.
;	By setting RVB_FaderDMAwriteIncrement to zero, consecutive
;	buffers can be processed that all refer to the same DMA write block.
RVB_FaderDMAwriteIncrement
	dc	0


;	RVB_FaderpNewTapList is a pointer into the block 'RVB_FaderNewTapList'
RVB_FaderpNewTapList
	dc	0



;	RVB_FaderNewTapList contains a list of new tap positions for the 
; current block
RVB_FaderNewTapList
	bsc	8,0


;	RVB_FaderAmplitudeState contins the state of the amplitude fader
;		A -ve value indicates that the amplitude fader is disabled
;		The amplitude fader is enabled by setting the variable to 0.
;		The code will then increment the variable to reflect the current
;		state of the fade process. Once the fade has finished, the variable
;		is set to -1.
RVB_FaderAmplitudeState
	dc	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\reverbdata.asm ===
;	File	:	ReverbData.asm
;	Version	:	2.01
;	Date	:	21/11/2000
;
;	Author	:	RDA
;				Sensaura Ltd
;
;
;
; Description
; ===========
; This file defines the data space for the reverb engine.
;
; Version history
; ===============
;	0.1		First implementation.
;	1.0		Completed and working implementation for version 1.0 of the reverb engine
;	2.0		Implementation for version 2.0 of the reverb engine
;	2.01	Added support for half rate processing.

        IF @DEF('SIM')
	org	x:$80
        ELSE
        org     x:
        ENDIF


;==============================================================
;	Static data that should be preserved across frames
;==============================================================
StaticWorkspaceBase

FX_STATE_BLOCK          ds     DATASIZE_DSP_FX_STATE_2IN_4OUT

;
; state info in X-ram
;

pBuffer									; An array of pointers to the 31 frame buffers.
										; If this block is within the first 32 words of the start of
										; 'pStaticWorkspaceBase' then instructions of the form
										;	move x:(r5+pBuffer5-pStaticWorkspaceBase),a
										; are encoded into one word.
										; The array of buffer pointer are initialise by the function
										; 'RVB_GenerateBufferList'
pBuffer0
	dc	0
pBuffer1
	dc	0
pBuffer2
	dc	0
pBuffer3
	dc	0
pBuffer4
	dc	0
pBuffer5
	dc	0
pBuffer6
	dc	0
pBuffer7
	dc	0
pBuffer8
	dc	0
pBuffer9
	dc	0
pBuffer10
	dc	0
pBuffer11
	dc	0
pBuffer12
	dc	0
pBuffer13
	dc	0
pBuffer14
	dc	0
pBuffer15
	dc	0
pBuffer16
	dc	0
pBuffer17
	dc	0
pBuffer18
	dc	0
pBuffer19
	dc	0
pBuffer20
	dc	0
pBuffer21
	dc	0
pBuffer22
	dc	0
pBuffer23
	dc	0
pBuffer24
	dc	0
pBuffer25
	dc	0
pBuffer26
	dc	0
pBuffer27
	dc	0
pBuffer28
	dc	0
pBuffer29
	dc	0
pBuffer30
	dc	0


;----------------------------------------------------------------
;	Host data transfer blocks
;----------------------------------------------------------------

										; The host buffer information block is used to communicate
										; with the host. Data is transferred into this block defines
										; the positions and size of the delay buffers in host memory
										;
HostBufferInfo
MainDelayLine
	dc	EVM_MainDelayLine
SizeOf_MainDelayLine
	dc	EVM_SizeOf_MainDelayLine-1

MainDelayLine1
	dc	EVM_MainDelayLine1
SizeOf_MainDelayLine1
	dc	EVM_SizeOf_MainDelayLine1-1

MainDelayLine2
	dc	EVM_MainDelayLine2
SizeOf_MainDelayLine2
	dc	EVM_SizeOf_MainDelayLine2-1

MainDelayLine3
	dc	EVM_MainDelayLine3
SizeOf_MainDelayLine3
	dc	EVM_SizeOf_MainDelayLine3-1

BufferReflection0
	dc	EVM_BufferReflection0
SizeOf_BufferReflection0
	dc	EVM_SizeOf_BufferReflection0-1

BufferReflection1
	dc	EVM_BufferReflection1
SizeOf_BufferReflection1
	dc	EVM_SizeOf_BufferReflection1-1

BufferReflection2
	dc	EVM_BufferReflection2
SizeOf_BufferReflection2
	dc	EVM_SizeOf_BufferReflection2-1

BufferReflection3
	dc	EVM_BufferReflection3
SizeOf_BufferReflection3
	dc	EVM_SizeOf_BufferReflection3-1
	
BufferShortReverb0
	dc	EVM_BufferShortReverb0
SizeOf_BufferShortReverb0
	dc	EVM_SizeOf_BufferShortReverb0-1

BufferShortReverb1
	dc	EVM_BufferShortReverb1
SizeOf_BufferShortReverb1
	dc	EVM_SizeOf_BufferShortReverb1-1

BufferShortReverb2
	dc	EVM_BufferShortReverb2
SizeOf_BufferShortReverb2
	dc	EVM_SizeOf_BufferShortReverb2-1

BufferShortReverb3
	dc	EVM_BufferShortReverb3
SizeOf_BufferShortReverb3
	dc	EVM_SizeOf_BufferShortReverb3-1

BufferLongReverb0
	dc	EVM_BufferLongReverb0
SizeOf_BufferLongReverb0
	dc	EVM_SizeOf_BufferLongReverb0-1

BufferLongReverb1
	dc	EVM_BufferLongReverb1
SizeOf_BufferLongReverb1
	dc	EVM_SizeOf_BufferLongReverb1-1


StartOfDspParameterBlock

											;====================================
											; Reflections input tap positions
											;====================================
											; ReflectionsDelay :
											;	The delay between the input and the reflection block
ReflectionsInputDelayList
ReflectionsInputDelay0
	dc	DefaultReflectionInputDelay0
ReflectionsInputDelay1
	dc	DefaultReflectionInputDelay1
ReflectionsInputDelay2
	dc	DefaultReflectionInputDelay2
ReflectionsInputDelay3
	dc	DefaultReflectionInputDelay3
ReflectionsInputDelay4
	dc	DefaultReflectionInputDelay4


											;====================================
											; Short reverb input delay
											;====================================

											; ShortReverbInputDelay :
											;   The delay measured from the start of the main delay line 
											; to the first short reverb tap.
ShortReverbInputDelay
	dc	DefaultShortReverbInputDelay


											;====================================
											; Long reverb input tap positions
											;====================================

LongReverbInputDelay0a
	dc	DefaultLongReverbInputDelay0a
LongReverbInputDelay0b
	dc	DefaultLongReverbInputDelay1a
LongReverbInputDelay1a
	dc	DefaultLongReverbInputDelay0b
LongReverbInputDelay1b
	dc	DefaultLongReverbInputDelay1b
LongReverbInputDelay2a
	dc	DefaultLongReverbInputDelay0c
LongReverbInputDelay2b
	dc	DefaultLongReverbInputDelay1c
LongReverbInputDelay3a
	dc	DefaultLongReverbInputDelay0d
LongReverbInputDelay3b
	dc	DefaultLongReverbInputDelay1d


											;====================================
											; Reflection feedback delay tap positions
											;====================================
											; The following 4 values are the delay tap positions for 
											; the delay buffers in the 4 reflection channels
ReflectionsDelayList
ReflectionDelay0
	dc	DefaultReflectionDelay0						; Channel 0 reflection
ReflectionDelay1
	dc	DefaultReflectionDelay1						; Channel 1 reflection
ReflectionDelay2
	dc	DefaultReflectionDelay2						; Channel 2 reflection
ReflectionDelay3
	dc	DefaultReflectionDelay3						; Channel 3 reflection


											;====================================
											; Long reverb feedback delay tap positions
											;====================================
LongReverbDelay
	dc	DefaultLongReverbDelay0



											;====================================
											; Short reverb gains
											;====================================
											; Input gains
ShortReverbInputGain_Channel0a
	dc	$0
ShortReverbInputGain_Channel0b
	dc	$0
ShortReverbInputGain_Channel1a
	dc	$0
ShortReverbInputGain_Channel1b
	dc	$0
ShortReverbInputGain_Channel2a
	dc	$0
ShortReverbInputGain_Channel2b
	dc	$0
ShortReverbInputGain_Channel3a
	dc	$0
ShortReverbInputGain_Channel3b
	dc	$0


											;====================================
											; Long reverb gains
											;====================================
											; Input gain
LongReverbInputGain
	dc	DefaultLongReverbInputGain

											; Crossfeed gain
LongReverbCrossfeedGain
	dc	DefaultLongReverbCrossfeedGain



											;====================================
											; Output gains
											;====================================
											;
											;	The reflections output gain
NewReflectionOutputGain_Channel0
	dc	$000000
NewReflectionOutputGain_Channel1
	dc	$000000
NewReflectionOutputGain_Channel2
	dc	$000000
NewReflectionOutputGain_Channel3
	dc	$000000

											;	The short reverb output gain
NewShortReverbOutputGain_Channel
	dc	$010000

											;	The long reverb output gain
NewLongReverbOutputGain_Channel
	dc	$000000


;------------------------------------------------------------
;			Number of output channels
;------------------------------------------------------------
; The variable 'nOutputChannels' determines the number of
; output channels. At present the system can operate only
; in 2 or 4 channel mode.  If an invalid value is specified
; the system will use 2 channel mode.
;
; Values
;	2	Two channel mode (Default)
;	4	Four channel mode
;
nOutputChannels
	dc	0



													; This label marks the end of the block where
													; parameters are copied from the host
EndOfSimpleDspParameterBlock

													; The following block contains IIR coefficients.
													; These value are inserted into an IIR data
													; structure.
;---------------------------------------------------------
;			Allocate space for the IIR filters
;---------------------------------------------------------
;	Note that the default values for the IIR filters quoted
;	in the following section are overwritten when the
;	reverb engine initialises itself.
;	The values below are therefore not important.



IIR_Input
	NewIIR_Coefficients 0,0					; First order input filter


IIR_LongReverb_MainDelay0
	NewIIR_Coefficients 0,0

IIR_LongReverb_MainDelay1
	NewIIR_Coefficients 0,0

IIR_LongReverb_MainDelay2
	NewIIR_Coefficients 0,0

IIR_ShortReverbChannel0
	NewIIR_Coefficients 0,0
 
IIR_ShortReverbChannel1
	NewIIR_Coefficients 0,0

IIR_ShortReverbChannel2
	NewIIR_Coefficients 0,0

IIR_ShortReverbChannel3
	NewIIR_Coefficients 0,0

IIR_LongReverb_Channel0
	NewIIR_Coefficients 0,0

IIR_LongReverb_Channel1
	NewIIR_Coefficients 0,0


;------------------------------------------------------------
;	Allocate space for constant data
;------------------------------------------------------------
; The constant data can be initialised by the host at start-up.
;
;			Crossfeed coefficients
;
; The following are the fixed crossfeed matrix coefficients
;	Note that the coefficients are interleaved to reduce storage space
;	from 16 coefficients to 7

CrossfeedMatrixChannel3
	dc	$C00000					;-0.5
CrossfeedMatrixChannel2
	dc	$C00000					;-0.5
CrossfeedMatrixChannel1
	dc	$C00000					;-0.5
CrossfeedMatrixChannel0
	dc	$400000					;0.5
	dc	$C00000					;-0.5
	dc	$C00000					;-0.5
	dc	$C00000					;-0.5


;	The following block defines the gains in the reflection feedback loop
ReflectionsFeedbackGain
	dc	-3355443
	dc	3355443
	dc	-3355443
	dc	-3355443
;	msg		"Set reverb feedback gain to zero"
;	dc	0
;	dc	0
;	dc	0
;	dc	0

; The following array specifies the position of the short reverb input taps
; relative to 'ShortReverbInputDelay'.

ShortReverbInputDelayList
	dc	DefaultShortReverbInputDelay0a						; Channel 0a reflection
	dc	DefaultShortReverbInputDelay0b						; Channel 0b reflection
	dc	DefaultShortReverbInputDelay1a						; Channel 1a reflection
	dc	DefaultShortReverbInputDelay1b						; Channel 1b reflection
	dc	DefaultShortReverbInputDelay2a						; Channel 2a reflection
	dc	DefaultShortReverbInputDelay2b						; Channel 2b reflection
	dc	DefaultShortReverbInputDelay3a						; Channel 3a reflection
	dc	DefaultShortReverbInputDelay3b						; Channel 3b reflection


; The following values are the constant delays (measured in 
; samples) for the 4 short reverb channels.
ShortReverbDelayList
	dc	DefaultShortReverbDelay0					; Channel 0 reflection
	dc	DefaultShortReverbDelay1					; Channel 1 reflection
	dc	DefaultShortReverbDelay2					; Channel 2 reflection
	dc	DefaultShortReverbDelay3					; Channel 3 reflection
  
	
	IF @DEF('HALFSAMPLERATE')
											;  Filter data for the antialiasing filters											; (Coefficients are stored elsewhere)
IIR2_AntiAlias_Input
	IIR2_Data
	IIR2_Data

IIR2_AntiAlias_LeftFront
	IIR2_Data
	IIR2_Data

IIR2_AntiAlias_RightFront
	IIR2_Data
	IIR2_Data

IIR2_AntiAlias_LeftRear
	IIR2_Data
	IIR2_Data

IIR2_AntiAlias_RightRear
	IIR2_Data
	IIR2_Data
	ENDIF

EndOfDspParameterBlock

	IF @DEF('HALFSAMPLERATE')        
IIR2_AntiAliasing_Coefficients1
  
	IIR2_Coefficients 0.517806,0.587918,0.517806,0.280613,-0.275552		; Second order antialiasing filter part 1
IIR2_AntiAliasing_Coefficients2
	IIR2_Coefficients 0.517806,0.034041,0.517806,0.136654,-0.882101		; Second order antialiasing filter part 2
	ENDIF


;---------------------------------------------------------------
;			DMA control blocks to write results back to host
;---------------------------------------------------------------

;																Filtered input - writing to main delay line
DMA_ControlBlock_Wr0
	NewDMAcbs DMA_ControlBlock_Wr1,DMAcbs_DspToHost,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,0				; Stop the transfere at the end of the writes

;																Main delay line first IIR
DMA_ControlBlock_Wr1
	NewDMAcbs DMA_ControlBlock_Wr2,DMAcbs_DspToHost,SizeOfFrame,14,EVM_MainDelayLine1,EVM_SizeOf_MainDelayLine1,0

;																Main delay line second IIR
DMA_ControlBlock_Wr2
	NewDMAcbs DMA_ControlBlock_Wr3,DMAcbs_DspToHost,SizeOfFrame,16,EVM_MainDelayLine2,EVM_SizeOf_MainDelayLine2,0

;																Main delay line third IIR
DMA_ControlBlock_Wr3
	NewDMAcbs DMA_ControlBlock_Wr4,DMAcbs_DspToHost,SizeOfFrame,18,EVM_MainDelayLine3,EVM_SizeOf_MainDelayLine3,0

;																Channel 0 - Reflection delay line write
DMA_ControlBlock_Wr4
	NewDMAcbs DMA_ControlBlock_Wr5,DMAcbs_DspToHost,SizeOfFrame,1,EVM_BufferReflection0,EVM_SizeOf_BufferReflection0,0

;																Channel 1 - Reflection delay line write
DMA_ControlBlock_Wr5
	NewDMAcbs DMA_ControlBlock_Wr6,DMAcbs_DspToHost,SizeOfFrame,2,EVM_BufferReflection1,EVM_SizeOf_BufferReflection1,0

;																Channel 2 - Reflection delay line write
DMA_ControlBlock_Wr6
	NewDMAcbs DMA_ControlBlock_Wr7,DMAcbs_DspToHost,SizeOfFrame,3,EVM_BufferReflection2,EVM_SizeOf_BufferReflection2,0

;																Channel 3 - Reflection delay line write
DMA_ControlBlock_Wr7
	NewDMAcbs DMA_ControlBlock_Wr8,DMAcbs_DspToHost,SizeOfFrame,4,EVM_BufferReflection3,EVM_SizeOf_BufferReflection3,0

;																Channel 0 - Short reverb delay line write
DMA_ControlBlock_Wr8
	NewDMAcbs DMA_ControlBlock_Wr9,DMAcbs_DspToHost,SizeOfFrame,5,EVM_BufferShortReverb0,EVM_SizeOf_BufferShortReverb0,0

;																Channel 1 - Short reverb delay line write
DMA_ControlBlock_Wr9
	NewDMAcbs DMA_ControlBlock_Wr10,DMAcbs_DspToHost,SizeOfFrame,6,EVM_BufferShortReverb1,EVM_SizeOf_BufferShortReverb1,0

;																Channel 2 - Short reverb delay line write
DMA_ControlBlock_Wr10
	NewDMAcbs DMA_ControlBlock_Wr11,DMAcbs_DspToHost,SizeOfFrame,7,EVM_BufferShortReverb2,EVM_SizeOf_BufferShortReverb2,0

;																Channel 3 - Short reverb delay line write
DMA_ControlBlock_Wr11
	NewDMAcbs DMA_ControlBlock_Wr12,DMAcbs_DspToHost,SizeOfFrame,8,EVM_BufferShortReverb3,EVM_SizeOf_BufferShortReverb3,0


;																Channel 0 - Long reverb delay line write
DMA_ControlBlock_Wr12
	NewDMAcbs DMA_ControlBlock_Wr13,DMAcbs_DspToHost,SizeOfFrame,9,EVM_BufferLongReverb0,EVM_SizeOf_BufferLongReverb0,0

;																Channel 1 - Long reverb delay line write
DMA_ControlBlock_Wr13
	NewDMAcbs DMAcbs_eol,DMAcbs_DspToHost,SizeOfFrame,10,EVM_BufferLongReverb1,EVM_SizeOf_BufferLongReverb1,0

	



;---------------------------------------------------------
;		DMA control blocks to read data from host
;---------------------------------------------------------


;																First reflection tap 0
DMA_ControlBlock_Rd0
	NewDMAcbs DMA_ControlBlock_Rd1,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultReflectionInputDelay+DefaultReflectionInputDelay0)

;																Channel 0 - Reflection tap 1
DMA_ControlBlock_Rd1
	NewDMAcbs DMA_ControlBlock_Rd2,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultReflectionInputDelay+DefaultReflectionInputDelay1)

;																Channel 1 - Reflection tap 2
DMA_ControlBlock_Rd2
	NewDMAcbs DMA_ControlBlock_Rd3,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultReflectionInputDelay+DefaultReflectionInputDelay2)

;																Channel 2 - Reflection tap 3
DMA_ControlBlock_Rd3
	NewDMAcbs DMA_ControlBlock_Rd4,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultReflectionInputDelay+DefaultReflectionInputDelay3)

;																Channel 3 - Reflection tap 1
DMA_ControlBlock_Rd4
	NewDMAcbs DMA_ControlBlock_Rd5,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultReflectionInputDelay+DefaultReflectionInputDelay4)







;																Channel 0 - Short reverb tap A
DMA_ControlBlock_Rd5
	NewDMAcbs DMA_ControlBlock_Rd6,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultShortReverbInputDelay+DefaultShortReverbInputDelay0a)

;																Channel 0 - Short reverb tap B
DMA_ControlBlock_Rd6
	NewDMAcbs DMA_ControlBlock_Rd7,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultShortReverbInputDelay+DefaultShortReverbInputDelay0b)

;																Channel 1 - Short reverb tap A
DMA_ControlBlock_Rd7
	NewDMAcbs DMA_ControlBlock_Rd8,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultShortReverbInputDelay+DefaultShortReverbInputDelay1a)

;																Channel 1 - Short reverb tap B
DMA_ControlBlock_Rd8
	NewDMAcbs DMA_ControlBlock_Rd9,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultShortReverbInputDelay+DefaultShortReverbInputDelay1b)

;																Channel 2 - Short reverb tap A
DMA_ControlBlock_Rd9
	NewDMAcbs DMA_ControlBlock_Rd10,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultShortReverbInputDelay+DefaultShortReverbInputDelay2a)

;																Channel 2 - Short reverb tap B
DMA_ControlBlock_Rd10
	NewDMAcbs DMA_ControlBlock_Rd11,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultShortReverbInputDelay+DefaultShortReverbInputDelay2b)

;																Channel 3 - Short reverb tap A
DMA_ControlBlock_Rd11
	NewDMAcbs DMA_ControlBlock_Rd12,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultShortReverbInputDelay+DefaultShortReverbInputDelay3a)

;																Channel 3 - Short reverb tap B
DMA_ControlBlock_Rd12
	NewDMAcbs DMA_ControlBlock_Rd13,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-(DefaultShortReverbInputDelay+DefaultShortReverbInputDelay3b)





;																Channel 0 - Long reverb tap a
DMA_ControlBlock_Rd13
	NewDMAcbs DMA_ControlBlock_Rd14,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-DefaultLongReverbInputDelay0a

;																Channel 1 - Long reverb tap a
DMA_ControlBlock_Rd14
	NewDMAcbs DMA_ControlBlock_Rd15,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine,EVM_SizeOf_MainDelayLine,EVM_SizeOf_MainDelayLine-DefaultLongReverbInputDelay1a

;																Channel 0 - Long reverb tap b
DMA_ControlBlock_Rd15
	NewDMAcbs DMA_ControlBlock_Rd16,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine1,EVM_SizeOf_MainDelayLine1,EVM_SizeOf_MainDelayLine1-DefaultLongReverbInputDelay0b

;																Channel 1 - Long reverb tap b
DMA_ControlBlock_Rd16
	NewDMAcbs DMA_ControlBlock_Rd17,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine1,EVM_SizeOf_MainDelayLine1,EVM_SizeOf_MainDelayLine1-DefaultLongReverbInputDelay1b


;																Channel 0 - Long reverb tap c
DMA_ControlBlock_Rd17
	NewDMAcbs DMA_ControlBlock_Rd18,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine2,EVM_SizeOf_MainDelayLine2,EVM_SizeOf_MainDelayLine2-DefaultLongReverbInputDelay0c

;																Channel 1 - Long reverb tap c
DMA_ControlBlock_Rd18
	NewDMAcbs DMA_ControlBlock_Rd19,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine2,EVM_SizeOf_MainDelayLine2,EVM_SizeOf_MainDelayLine2-DefaultLongReverbInputDelay1c

;																Channel 0 - Long reverb tap d
DMA_ControlBlock_Rd19
	NewDMAcbs DMA_ControlBlock_Rd20,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine3,EVM_SizeOf_MainDelayLine3,EVM_SizeOf_MainDelayLine3-DefaultLongReverbInputDelay0d

;																Channel 1 - Long reverb tap d
DMA_ControlBlock_Rd20
	NewDMAcbs DMA_ControlBlock_Rd21,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_MainDelayLine3,EVM_SizeOf_MainDelayLine3,EVM_SizeOf_MainDelayLine3-DefaultLongReverbInputDelay1d









;																Channel 0 - Reflection feedback delay buffer
DMA_ControlBlock_Rd21
	NewDMAcbs DMA_ControlBlock_Rd22,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferReflection0,EVM_SizeOf_BufferReflection0,EVM_SizeOf_BufferReflection0-DefaultReflectionDelay0

;																Channel 1 - Reflection feedback delay buffer
DMA_ControlBlock_Rd22
	NewDMAcbs DMA_ControlBlock_Rd23,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferReflection1,EVM_SizeOf_BufferReflection1,EVM_SizeOf_BufferReflection1-DefaultReflectionDelay1

;																Channel 2 - Reflection feedback delay buffer
DMA_ControlBlock_Rd23
	NewDMAcbs DMA_ControlBlock_Rd24,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferReflection2,EVM_SizeOf_BufferReflection2,EVM_SizeOf_BufferReflection2-DefaultReflectionDelay2

;																Channel 3 - Reflection feedback delay buffer
DMA_ControlBlock_Rd24
	NewDMAcbs DMA_ControlBlock_Rd25,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferReflection3,EVM_SizeOf_BufferReflection3,EVM_SizeOf_BufferReflection3-DefaultReflectionDelay3



;																Channel 0 - Reverb feedback delay buffer
DMA_ControlBlock_Rd25
	NewDMAcbs DMA_ControlBlock_Rd26,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferShortReverb0,EVM_SizeOf_BufferShortReverb0,EVM_SizeOf_BufferShortReverb0-DefaultShortReverbDelay0

;																Channel 1 - Reverb feedback delay buffer
DMA_ControlBlock_Rd26
	NewDMAcbs DMA_ControlBlock_Rd27,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferShortReverb1,EVM_SizeOf_BufferShortReverb1,EVM_SizeOf_BufferShortReverb1-DefaultShortReverbDelay1

;																Channel 2 - Reverb feedback delay buffer
DMA_ControlBlock_Rd27
	NewDMAcbs DMA_ControlBlock_Rd28,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferShortReverb2,EVM_SizeOf_BufferShortReverb2,EVM_SizeOf_BufferShortReverb2-DefaultShortReverbDelay2

;																Channel 3 - Reverb feedback delay buffer
DMA_ControlBlock_Rd28
	NewDMAcbs DMA_ControlBlock_Rd29,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferShortReverb3,EVM_SizeOf_BufferShortReverb3,EVM_SizeOf_BufferShortReverb3-DefaultShortReverbDelay3




;																Channel 0 - Long reveb feedback delay buffer
DMA_ControlBlock_Rd29
	NewDMAcbs DMA_ControlBlock_Rd30,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferLongReverb0,EVM_SizeOf_BufferLongReverb0,EVM_SizeOf_BufferLongReverb0-DefaultLongReverbDelay0

;																Channel 1 - Long reveb feedback delay buffer
DMA_ControlBlock_Rd30
	NewDMAcbs DMAcbs_eol,DMAcbs_HostToDsp,SizeOfFrame,0,EVM_BufferLongReverb1,EVM_SizeOf_BufferLongReverb1,EVM_SizeOf_BufferLongReverb1-DefaultLongReverbDelay1

;---------------------------------------------------------------
; Copy of output gains used by the fader
;
;---------------------------------------------------------------

ReflectionOutputGain_Channel0
	dc	$000000
ReflectionOutputGain_Channel1
	dc	$000000
ReflectionOutputGain_Channel2
	dc	$000000
ReflectionOutputGain_Channel3
	dc	$000000

											;	The short reverb output gain
ShortReverbOutputGain_Channel
	dc	$010000

											;	The long reverb output gain
LongReverbOutputGain_Channel
	dc	$000000


	IF FADER_ENABLED
													; If the fader has been enabled, allocated
													; memory for its data space
	include 'RvbFaderData.asm'
	ENDIF


EndOfPrivateData
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\reverb_wrapper.asm ===
;*******************************************************************
;
;		Rvb.asm
;               wrapper around sensaura ID3l2 reverb
;
;******************************************************************        

	IF @DEF('HALFSAMPLERATE')
	msg		'Half sample rate version compiling'
	ELSE
	msg		'Full sample rate version compiling'
	ENDIF

        IF @DEF('STANDALONE')
 	include 'Util.h'

        ;
        ; the following define will disable unused DMA routins in fxdmautil.asm
        ;
CIRCULAR_DMA            equ     1

        ENDIF

        org p:
StartReverb

        FXEntryPoint

        IF !@DEF('STANDALONE')

        ; ----------------------------------------------
        ; Custom initialisation for hardwired to the engine version

	bsr InitialiseConstants				; Initialise the constant data in the reverb engine.
							; These constants would normally be part of the 
							; binary file.
        
        
        ENDIF

;---------------------------------------------------------------------------------
;											Prepare input/output buffers
;---------------------------------------------------------------------------------

        IF @DEF('FX_TEST')
        
        ; setup scratch

        move    #$C000,x0
        move    x0,x:(rD+FX_STATE_SCRATCH_BASE)

        move    #>kFxSendMixBuf00,x0     
        move    #>kFxSendMixBuf00,y0

	move	x0,x:(r5+FX_STATE_IO2_IN0)                                      ; LEFT INPUT
	move	y0,x:(r5+FX_STATE_IO2_IN1)

        move    #>kReadWriteMixBuf00,x0         ; front left
        move    #>kReadWriteMixBuf01,x1         ; front right
        move    #>kReadWriteMixBuf04,y0         ; rear left
        move    #>kReadWriteMixBuf05,y1         ; rear right

	; Configure the output for the (front) left channel
	move	x0,x:(r5+FX_STATE_IO2_OUT0) 
	; Configure the output for the (front) right channel
	move	x1,x:(r5+FX_STATE_IO2_OUT1) 
	; Configure the output for the (rear) left channel
	move	y0,x:(r5+FX_STATE_IO2_OUT2) 
	; Configure the output for the (rear) right channel
	move	y1,x:(r5+FX_STATE_IO2_OUT3) 

        ;
        ; fill in the tempbixbins
        ;

        move    r6,a
        lua     (rD+FX_STATE_IO2_OUT3+1),r0 

        dor     #31,FillTempBinLoop

        move    a,x:(r0)+
        add     #kFrameLength,a

FillTempBinLoop

        ENDIF

;---------------------------------------------------------------------------------


;---------------------------------------------------------------------------------
;				Download a set of reverb parameters
;---------------------------------------------------------------------------------

        IF !@DEF('STANDALONE')
	bsr	DownloadCoefficients			; Configure the reverb engine with a specific set 
							; of parameters.  (This call takes the place of
							; the DMA transfer that would download the low level
							; reverb parameters).
;---------------------------------------------------------------------------------
        ELSE

        ;
        ; setup r0 with the base of HostInfo block so we can init the
        ; host scratch offsets for all delay taps
        ; the lengths are already initialized by dsound/xgpimage
        ;
             
	move	#>HostBufferInfo-StaticWorkspaceBase,x0
        move    rD,a
        add     x0,a
        move    a,r0
        add     #1,a
        move    a,r1
        move    #2,n0
        move    #2,n1

        move    x:(rD+FX_STATE_SCRATCH_BASE),x0
        move    x0,x:(r0)+n0

        dor     #((StartOfDspParameterBlock-HostBufferInfo)/2-1),InitHostBufferInfoLoop

        move    x:(r0-2),a
        move    x:(r1)+n1,x0
        add     x0,a
        add     #1,a
        move    a,x:(r0)+n0       
         
InitHostBufferInfoLoop

	IF @DEF('HALFSAMPLERATE')
	; Second order antialiasing filter part 1

        move    #>IIR2_AntiAliasing_Coefficients1-StaticWorkspaceBase,x0
        move    rD,a
        add     x0,a
        move    a,r0

	move	#0.517806,x0
	move	x0,x:(r0)+
	move	#0.587918,x0
	move	x0,x:(r0)+
	move	#0.517806,x0
	move	x0,x:(r0)+
	move	#0.280613,x0
	move	x0,x:(r0)+
	move	#-0.275552,x0
	move	x0,x:(r0)+

	; Second order antialiasing filter part 2
        move    #>IIR2_AntiAliasing_Coefficients2-StaticWorkspaceBase,x0
        move    rD,a
        add     x0,a
        move    a,r0

	move	#0.517806,x0
	move	x0,x:(r0)+
	move	#0.034041,x0
	move	x0,x:(r0)+
	move	#0.517806,x0
	move	x0,x:(r0)+
	move	#0.136654,x0
	move	x0,x:(r0)+
	move	#-0.882101,x0
	move	x0,x:(r0)+
	ENDIF		; end HALFSAMPLERATE


        ENDIF



;---------------------------------------------------------------------------------
;				Reset the reverb engine
;---------------------------------------------------------------------------------
;	Note that a set of parameters must have
;	been downloadedbefore the reverb engine
;       is reset.

	bsr	RVB_Reset
;---------------------------------------------------------------------------------

	
ComputeFX
    
; -------------------- DSP -------------------------------
        
        ;
        ; check if an update occured. If it did, invoke the fader
        ;

        move    x:(rD+FX_STATE_FLAGS),x0
        brclr   #BIT_FX_STATE_FLAG_UPDATE,x0,ProcessFrame

        ;
        ; clear update flag, call update routine
        ;

        bclr    #BIT_FX_STATE_FLAG_UPDATE,x0
        move    x0,x:(rD+FX_STATE_FLAGS)

        bsr	RVB_UpdateParameters

ProcessFrame
	bsr	RVB_ProcessFrame

	;The output of the reverb engine contains the reverb
	; component corresponding to its input signal.  For normal
	; listening the direct path needs to be added to this
	; result.


        FXExit
     
	include 'options.inc'
	include 'reverb.inc'
	include 'reverb.asm'

        IF !@DEF('STANDALONE')
	include 'Init_Params.asm'
        ELSE
        include 'fxdmautil.asm'
        ENDIF

FX_END
        nop

; ---- end MainLoop ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\RvbFuncs.asm ===
;	File	:	RvbFuncs.asm
;	Version	:	0.22
;	Date	:	20/09/2000
;
;	Author	:	RDA
;				Sensaura Ltd
;
;
;
; Description
; ===========
; Reverb support functions
;
; Version history
; ===============
;	0.1		All functions working and tested
;	0.2		Moved the function 'CopyFrame' from 'reverb.asm'
;	0.21	Added function 'ShiftLeftFrame_InPlace'
;	0.22	Added function 'AccumulateFrame_OutOfPlace'


	org	p:


;=========================
;	CopyFrame
;=========================
;	On Entry
;		r0=pointer to source
;		r1=poitner to destination
;	On Exit
;		r0	increased by SizeOfFrame
;		r1	increased by SizeOfFrame
;
;
;	Copy the source frame to the destination frame
;			r1[n]=r0[n]				0 <= n < SizeOfFrame
;
CopyFrame
	dor	#SizeOfFrame,RVB_CopyLoop
		move	x:(r0)+,x0							; Load from source frame
		move	x0,x:(r1)+							; Save in destination frame
RVB_CopyLoop
	rts



;===================================
;		ScaleFrame_InPlace
;===================================
;	On Entry
;		x0	Scaling factor
;		r0	Pointer to frame
;	On Exit
;		a	Undefined
;		x0	Preserved
;		x1	Undefined
;		r0	increased by SizeOfFrame
;		Frame pointed to by r0 on entry is scaled by x0
;
;			r0[n]=x0*r0[n]				0 <= n < SizeOfFrame

ScaleFrame_InPlace
	dor		#SizeOfFrame,RVB_ScaleLoop
		move	x:(r0),x1							; Load from source frame
		mpy		x1,x0,a								; Scale element
		move	a,x:(r0)+							; Store result back in source frame
RVB_ScaleLoop
	rts



;===========================================
;		MultiplyAccumulateFrame_InPlace
;===========================================
;	On Entry
;		x0	Scaling factor
;		r0	Pointer to frame 1
;		r1	Pointer to frame 2
;
;	On Exit
;		a	Undefined
;		x0	Preserved
;		x1	Undefined
;		r0	increased by SizeOfFrame
;		r1	increased by SizeOfFrame
;
;		Frame pointed to by r1 on entry is updated
;			r1[n]=r1[n]+x0*r0[n]				0 <= n < SizeOfFrame
;	
MultiplyAccumulateFrame_InPlace
	dor		#SizeOfFrame,RVB_MACLoop
		move	x:(r0)+,x1							; Load element from source frame 0
		move	x:(r1),a							; Load element from source frame 1
		macr	x1,x0,a								; Scale frame 0 and add it to frame 1
		move	a,x:(r1)+							; Store the result in frame 1
RVB_MACLoop
	rts




;===========================================
;		AccumulateFrame_InPlace
;===========================================
;	On Entry
;		r0	Pointer to frame
;		r1	Pointer to frame
;	On Exit
;		a	Undefined
;		x0	Preserved
;		r0	increased by SizeOfFrame
;		r1	increased by SizeOfFrame
;		Frame pointed to by r1 on entry is updated
;			r1[n]=r1[n]+r0[n]				0 <= n < SizeOfFrame
;	
AccumulateFrame_InPlace
	dor		#SizeOfFrame,RVB_AccumulateLoop
		move	x:(r0)+,x0							; Load element from frame 0
		move	x:(r1),a							; Load element from frame 1
		add		x0,a								; Add elements together
		move	a,x:(r1)+							; Store result in frame 1
RVB_AccumulateLoop
	rts




;===========================================
;		AccumulateFrame_OutOfPlace
;===========================================
;	On Entry
;		r0	Pointer to input frame 0
;		r1	Pointer to input frame 1
;		r2	Pointer to output frame
;	On Exit
;		a	Undefined
;		x0	Preserved
;		r0	increased by SizeOfFrame
;		r1	increased by SizeOfFrame
;		r2	increased by SizeOfFrame
;
;		Frame pointed to by r2 on entry is updated as follows
;			r2[n]=r1[n]+r0[n]				0 <= n < SizeOfFrame
;	
AccumulateFrame_OutOfPlace
	dor		#SizeOfFrame,RVB_AccumulateOOPLoop
		move	x:(r0)+,x0							; Load element from frame 0
		move	x:(r1)+,a							; Load element from frame 1
		add		x0,a								; Add elements together
		move	a,x:(r2)+							; Store result in frame 2
RVB_AccumulateOOPLoop
	rts




;===================================
;		ShiftLeftFrame_InPlace
;===================================
;	On Entry
;		x0	Number of places to shift frame
;		r0	Pointer to frame
;	On Exit
;		a	Undefined
;		x0	Preserved
;		r0	increased by SizeOfFrame (i.e. pointer to byte after end of input frame)
;		Frame pointed to by r0 on entry is multiplied by by 2^(x0)
;
;			r0[n]=r0[n] << x0				0 <= n < SizeOfFrame

ShiftLeftFrame_InPlace
	dor		#SizeOfFrame,RVB_ShiftLeftLoop
		move	x:(r0),a							; Load element from frame 0
		asl		x0,a,a								; Shift element left 'x0' places
		move	a,x:(r0)+							; Store result in frame 0
RVB_ShiftLeftLoop
	rts



;===========================================
;		MultiplyAccumulateShiftLeftFrame_InPlace
;===========================================
;	On Entry
;		x0	Scaling factor
;		x1	Bits to shift left
;		r0	Pointer to frame 1
;		r1	Pointer to frame 2
;
;	On Exit
;		a	Undefined
;		x0	Preserved
;		x1	Preserved
;		y1	Undefined
;		r0	increased by SizeOfFrame
;		r1	increased by SizeOfFrame
;
;		Frame2 pointed to by r1 on entry is updated
;			r1[n]=r1[n]+((x0*r0[n])<<x1)			0 <= n < SizeOfFrame
;	
MultiplyAccumulateShiftLeftFrame_InPlace
	dor		#SizeOfFrame,RVB_MACSLLoop
		move	x:(r0)+,y1							; Load element from frame 0
		move	x:(r1),a							; Load element from frame 1
		macr	y1,x0,a								; Scale frame 0 and add to frame 1
		asl		x1,a,a								; Shift result left 'x1' places
		move	a,x:(r1)+							; Store result in frame 1
RVB_MACSLLoop
	rts
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\Util.asm ===
;*******************************************************************
;
;       Util.asm    DSP utility routines  
;
;******************************************************************        
	
;************************************************************
; GPInit	Restore GP state to initial state, including
;		clearing XRAM and YRAM
;		
;************************************************************
GPInit
	GPClearInterruptRegister
        
        move #>0,r0
        move #>kGPMemory_Size_XRAM,x0

        jsr GPClearXRAM_All
        jsr GPClearYRAM_All	

 	rts
; ---- end GPInit----
	
;************************************************************
; GPWaitForStartFrame	Poll and wait for Start Frame (bit 1).
;			Afterward, clear the bit
;************************************************************
GPWaitForStartFrame 
	jclr 	#kStartFrameBit,x:INTERRUPT_REGISTER,GPWaitForStartFrame
; Clear start frame Bit 1
	movep    #>$2,x:INTERRUPT_REGISTER	; "Write-1-To-Clear-One" 
 	rts
; ---- end GPWaitForStartFrame ----


;************************************************************
; GPClearXRAM_All	Clear entire XRAM
; r0 has base address
; x0 has size
;************************************************************
GPClearXRAM_All
	clr	a
	rep	x0
	move	a,x:(r0)+
 	rts
; ---- end GPClearXRAM_All----

;************************************************************
; GPClearYRAM_All		Clear entire YRAM
;************************************************************
GPClearYRAM_All 
	move #>0,r0
	move #>kGPMemory_Size_YRAM,x0
	clr	a
	rep	x0
	move	a,y:(r0)+
 	rts
; ---- end GPClearYRAM_All ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\spliter.asm ===
;**************************************************************************
;
;       mixer.asm    
;       	
;**************************************************************************        

        IF @DEF('STANDALONE')
        include 'util.h'
        ENDIF

        include 'spliter.h'



;************************************************************
; StartSpliter	
;************************************************************
StartSpliter
; Data structure pointer already loaded into rD

        FXEntryPoint
        
ComputeFX
        
	bsr	ComputeSpliter

        FXExit



;************************************************************
; ComputeSpliter
; split channel 0 to channels 0,1,2,3,.., N of output data
;************************************************************
ComputeSpliter

        ; load base address of output IO ptr array
        lua	(rD+FX_STATE_IO1_OUT0),r1

        ; load base address of output gains
        lua     (rD+FX_OUTPUT_GAIN0),r2

        move    r2,x:(rD+FX_TEMP)
        move    x:(rD+FX_NUM_OUTPUTS),x0

        dor     x0,OutputLoop

        ; load input io ptr
	move	x:(rD+FX_STATE_IO1_IN),r0

        ; load output IO ptr
        move    x:(r1)+,r4
        ; load gain
        move    x:(r2)+,y0

        dor     #kFrameLength,MixLoop1

        ; multiple input sample by gain for output N
        move    x:(r0)+,x0
        mpy     x0,y0,a

        ; check if we need to mix our output
        move    x:(rD+FX_STATE_FLAGS),x1       
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT

        ; load sample from output bin
        move	x:(r4),x0
        ; mix result to audio Output 
        add     x0,a            

STOMP_OUTPUT
	move	a,x:(r4)+

MixLoop1
       nop
OutputLoop

        nop 
        rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\Reverb.asm ===
;	File	:	Reverb.asm
;	Version	:	2.11
;	Date	:	17/07/2001
;
;	Author	:	RDA
;				Sensaura Ltd
;
;
; Description
; ===========
; Sensaura's reverb engine
;
; Version history
; ===============
;	0.1		First implementation. Untested
;	0.2		Separated support functions into a separate file called 
;			'RvbFuncs.asm'
;			Implemented a cunning version of the crossfeed matrix 
;			(saved about 6 instructions)
;	0.3		Implemented the crossfeed matrix with a tripple nexted 
;			loop (saved 16 instructions). Tested thoroughly. 
;	0.4		The stereo input frames are now mixed into the main delay
;			buffer. The input and output frames are passed to the 
;			process function with R1 and R2.
;	0.41	Realised that the index into the delay line for the read 
;			taps need a lower value	than the write taps for correct 
;			operation. Modified the code accordingly
;	0.5		Functional reverb engine with compile time reverb constants.
;			The early reflections works correctly. The reverberation 
;			sounds like it works correctly although it need to be
;			validated.
;	0.51	Modified so that the workspace is accessed indirectly
;			through r5.
;			Initialisation of the DMA command blocks works correctly.
;			Removed the function 'RVB_SetnOutputChannels'. (Only called
;			once and it is just one instruction long).
;	0.52	An error was found in the structure of reverb engine. It
;			was corrected and recoded. The reverb now feeds back into 
;			the start of the crossfeed matrix.
;	0.53	Incorporated the correct scaling into the output mixing stage.
;
;	2.00	Begun the re-write for the version 2 reverb engine
;	2.01	Changed entry conditions : Pointers to the input and output 
;			frames are now located in the memory block 'pIO_Frames' 
;			(which can be found in the reverb engine's private workspace).
;			Replaced the variable 'TwoChannels' with the variable 
;			'nOutputChannels'. 'nOutputChannels' should be set equal to the
;			number of output channels
;	2.02	Added support for fading the output gains to their new values
;			and muting buffers while their delay taps are moved. The fader 
;			is enable/disabled by setting the variable FADER_ENABLED.
;	2.03	Modified to enable the internals of the reverb engine to 
;			operate at half the sample rate.
;			Run 'reverb2h" to initialise the debugger for half rate
;			processing. Presets and macros are stored in directories
;			"eax_2" and "macros_2".
;	2.04	The reverb engine is now operating correctly at half the sample
;			rate.
;			Added support for the debugger to reset the reverb engine.
;	2.10	Modified for XBox.
;				- r5 replaced by rD
;				- Made the code relocateable
;				- Removed RVB_Initialise
;				- Removed the guts of RVB_UpdateParameters
;				- Changed the location of the input buffers for RVB_ProcessFrame
;				- Added an option to skip first processing stage to mix the stereo 
;				inputs into a mono buffer & simply accept one mono input instead.
;				- Changed output mixing stage so we don't use the output buffers
;				as temporary storage. Now we accumulate into them.
;	2.11	Reinstated RVB_UpdateParameters
;			Bug fixes as follows:
;				- Fixed artefact in half-rate version by regenerating the correct
;				  pointers to the temp bins each time a new set of parameters is downloaded.
;				- Fixed bug in reverb delay tap fader so that it produces identical
;				  results to when not fading. (The bug was due to the difference 
;				  between bytes and words.)
;				- Fixed a potential overflow problem in RVB_UpdateDmaCommandBlockOffset 
;				  when updating command block offsets.
;
; Entry points into the reverb module are as follows:
;	RVB_Initialise
;	RVB_Reset
;	RVB_UpdateParameters
;	RVB_ProcessFrame
;
;
;
;
; 'RVB_ProcessFrame' performs the body of the processing within the reverb engine.  
; The function accepts audio data from 2 sources.  First there is a stereo pair 
; of frame buffers representing the primary input for the reverb engine.  Second
; are the 31 input buffers that provide taps on the various delay lines within 
; the system.
;
; The input buffers are labelled 0 to 30 and filled as follows via the DMA
; controller.
;
;	Read Buffer	Data on entry
;	----------------------
;		0		First reflection tap 0
;		1		Channel 0 - Reflection input tap 1 on main delay line
;		2		Channel 1 - Reflection input tap 2 on main delay line
;		3		Channel 2 - Reflection input tap 3 on main delay line
;		4		Channel 3 - Reflection input tap 4 on main delay line
;		5		Channel 0 - Short reverb input tap A on main delay line
;		6		Channel 0 - Short reverb input tap B on main delay line
;		7		Channel 1 - Short reverb input tap A on main delay line
;		8		Channel 1 - Short reverb input tap B on main delay line
;		9		Channel 2 - Short reverb input tap A on main delay line
;		10		Channel 2 - Short reverb input tap B on main delay line
;		11		Channel 3 - Short reverb input tap A on main delay line
;		12		Channel 3 - Short reverb input tap B on main delay line
;		13		Channel 0 - Long reverb input tap a on main delay line
;		14		Channel 1 - Long reverb input tap a on main delay line
;		15		Channel 0 - Long reverb input tap b on extension 1 of main delay line
;		16		Channel 1 - Long reverb input tap b on extension 1 of main delay line
;		17		Channel 0 - Long reverb input tap c on extension 2 of main delay line
;		18		Channel 1 - Long reverb input tap c on extension 2 of main delay line
;		19		Channel 0 - Long reverb input tap d on extension 3 of on main delay line
;		20		Channel 1 - Long reverb input tap d on extension 3 of on main delay line
;		21		Channel 0 - Reflection feedback delay buffer
;		22		Channel 1 - Reflection feedback delay buffer
;		23		Channel 2 - Reflection feedback delay buffer
;		24		Channel 3 - Reflection feedback delay buffer
;		25		Channel 0 - Reverb feedback delay buffer
;		26		Channel 1 - Reverb feedback delay buffer
;		27		Channel 2 - Reverb feedback delay buffer
;		28		Channel 3 - Reverb feedback delay buffer
;		29		Channel 0 - Long reveb feedback delay buffer
;		30		Channel 1 - Long reveb feedback delay buffer
;
;
; When the system has finished processing the reverb engine produces two sets
; of output frames. The primary output is either two or four audio
; data buffers corresponding to either stereo or quad output mode.
; The secondary output is 14 frames of audio data corresponding to inputs
; for the various delay lines within the system.  These buffers are stored
; in the memory allocated for the input buffers and have the following
; purpose.
;
;	Write buffer	Data on exit
;		0			Filtered input - writing to main delay line
;		1			Main delay line first IIR
;		2			Main delay line second IIR
;		3			Main delay line third IIR
;		4			Channel 0 - Reflection delay line write
;		5			Channel 1 - Reflection delay line write
;		6			Channel 2 - Reflection delay line write
;		7			Channel 3 - Reflection delay line write
;		8			Channel 0 - Short reverb delay line write
;		9			Channel 1 - Short reverb delay line write
;		10			Channel 2 - Short reverb delay line write
;		11			Channel 3 - Short reverb delay line write
;		12			Channel 0 - Long reverb delay line write
;		13			Channel 1 - Long reverb delay line write





;	include	'DMA_Emulator.asm'			; Emulates the DMA controller by transferring
;										; data to the external memory.

RVB_StartOfMemory
	include 'RvbFuncs.asm'				; Various support functions.
	include 'Parameters.inc'			; Defines various default parameters
	include 'ReverbData.asm'			; Defines the private and scratch workspace

	IF FADER_ENABLED
	include 'RVBFader.asm'				; Defines functions that fade between parameters sets
	ENDIF

	org	p:



;==================================
;		RVB_Reset
;==================================
;	On Entry
;		rD	Pointer to the private workspace of the reverb engine 
;			(rD+0) - a pointer to the DirectX parameters (Unused)
;			(rD+1) - a pointer to the scratch memory
;		The data block 'HostBufferInfo' contains information describing
;		the layout of the reverb buffers.
;
;	On Exit
;		rD	Preserved
;		Assume all other registers Undefined
;
;	Resetting the reverb module performs the following actions
;		1. Reinitialise all the variables to their default values
;		2. Reset the DMA command blocks
;		3. Back to 2 channels
;	Note that resetting the reverb engine is the only way to resize
;	reverb buffers on the host.

RVB_Reset
	bsr RVB_GenerateBufferList
	bsr RVB_CopyParameters

	IF	FADER_ENABLED

	;--------------------------------------
	; Initialise the fader if it is enabled
	;--------------------------------------

	bsr		RVB_Fader_Initialise

	ENDIF

	bsr		RVB_InitialiseDmaCommandBlocks
	rts
					
;==================================
;		RVB_UpdateParameters
;==================================
;	On Entry
;		r5=Pointer to private workspace
;	On Exit
;		

RVB_UpdateParameters
	bsr		RVB_GenerateBufferList

	IF FADER_ENABLED
	bsr		RVB_Fader_StartFading					; Trigger a gradual fading from one set of 
										; parameters to another.
	ENDIF																

	IF (FADER_ENABLED&FADER_ENABLE_DELAYTAPFADE)
		   								; The operation updates
		   								; DMA command blocks corresponding to 
		   								; buffers on the main delay line.
	  
		bsr RVB_UpdateDmaCommandBlocksNotProcessedByFader		; Update the remaining DMA command blocks

	ELSE

		bsr RVB_CopyParameters
        
		bsr RVB_UpdateAllDmaCommandBlocks

	ENDIF

	rts

;-----------------------------------
;		RVB_CopyParameters
;-----------------------------------
;	On Entry
;
;	rD=pointer to base of private data
;
;	On Exit
;		a  Undefined
;		r0 Undefined
;		r1 undefined


RVB_CopyParameters
        ;
        ; copy output gains from host block to internal block
        ;

	move	r5,a
	add    	#ReflectionOutputGain_Channel0-StaticWorkspaceBase,a
	move	a,r0

	add    	#NewReflectionOutputGain_Channel0-ReflectionOutputGain_Channel0,a
	move	a,r1

	dor    	#6,RVB_CopyTransformedOutputGainParametersLoop
		move	x:(r1)+,x0
		move	x0,x:(r0)+
RVB_CopyTransformedOutputGainParametersLoop

        rts




;-----------------------------------
;		RVB_GenerateBufferList
;-----------------------------------
;	On Entry
;
;	rD=pointer to base of private data
;		The entry 'pScratchMemory' should have been filled with
;		the address of the static workspace base address.
;
;	On Exit
;		a  Undefined
;		r0 Undefined
;		rD preserved
RVB_GenerateBufferList
	
	; georgioc - not used anymore the tool creates the pointers
	IF 0
;	move	rD,a
;	add	#(pBuffer-StaticWorkspaceBase),a	; Calculate a pointer to the base of 
;											; the private pointer array that is
;											; to be filled with pointers to the
;											; scratch memory.
;	move	a,r0	 						; R0 points to the base of the buffer pointer block
;
;			 								; Get a pointer to the scratch memory
;	move	x:(rD+pScratchXMemory-StaticWorkspaceBase),a
;	add	#(Buffer0-BaseScratchData),a		; 'a' points to the first frame buffer
;	
;	dor	#31,RVB_GenerateBufferListLoop
;		move	a,x:(r0)+
;		add		#SizeOfFrame,a
;RVB_GenerateBufferListLoop

	ENDIF

	IF @DEF('HALFSAMPLERATE')
	move	rD,a
	add	#(pBuffer0-StaticWorkspaceBase),a	; Calculate a pointer to the base of 
				      			; the private pointer array that is
				      			; to be filled with pointers to the
				      			; scratch memory.
	move	a,r0	 	      			; R0 points to the base of the buffer pointer block
	
	move	x:(r0),a
	
	dor	#31,RVB_GenerateBufferListLoop
		move	a,x:(r0)+
		add		#SizeOfFrame,a
RVB_GenerateBufferListLoop
	ENDIF

	rts




;==================================
;		RVB_ProcessFrame
;==================================
;	On Entry
;		rD=Pointer to reverb data structure
;
;	On Exit
;		a	Undefined
;		x	Undefined
;		y	Undefined
;		r0-r4	Undefined
;		n0,n2
;
;
; Process a frame of audio data to calculate its reverb contribution.
; The processing stages are as follows
;	0.	Transfer data from the Host memory to the DSP
;	1.	Apply the IIR filter to the input stage
;	2.	Wait until DMA transfer from host is complete
;	3.	Perform calculations associated with the reflection buffers
;	4.	Calculate the short reverb feedback and short reverb input 
;		in preparation for the crossfeed matrix
;	5.	Perform long reverb calculations
;	6.	Evaluate the crossfeed matrix
;	7.	Combine the crossfeed from the long reverb
;	8.	Apply short reverb IIRs
;	9.	Mix the output channels.
;
;	During the processing the output frame "IO_LeftFrontOut" is used as an 
;	intermediate buffer. Therefore if data representing the direct path is
;	requried
RVB_ProcessFrame
	
        ;====================================
        ; Initialise DMA transfer to read input frames from delay line scratch
        ;====================================
	
	bsr	RVB_ReadInputFrames
	

	move	#-1,m0
	move	m0,m1
	move	m0,m2
	move	m0,m3
	move	m0,m4
	move	m0,m5
	

	;====================================
	; Combine the stereo input frames into one mono frame
	;====================================
	; Input frames		: Source frame Left,Right
	; Output frames		: Source frame Right
	; Workspace frames	: Destination left front output buffer

	; Add the left and right input frames
	; Use one of the output buffers as a temporary buffer

	IF USE_TWO_INPUTS
                 
	move	x:(rD+FX_STATE_IO2_IN0),r0			; Pointer to the left input frame buffer
	move	x:(rD+FX_STATE_IO2_IN1),r1			; Pointer to the right input frame buffer
	move	x:(rD+FX_STATE_IO2_IN0),r2			;(ignore) Pointer to the front left output frame buffer
	bsr	AccumulateFrame_OutOfPlace
	IF @DEF('HALFSAMPLERATE')

        							; If we are running at half the sample
        							; rate, the input frames are twice the size
        							; of the internal frames, so we need to do
	bsr	AccumulateFrame_OutOfPlace			; another call to the accumulate function

	ENDIF

	ENDIF ; USE_TWO_INPUTS

	move	#$400000,x0		  			; Multiply the result by 1/2
	move	x:(rD+FX_STATE_IO2_IN0),r0                     ; left front out
	bsr	ScaleFrame_InPlace

	IF @DEF('HALFSAMPLERATE')

        ; If we are running at half the sample
        ; rate, the input frames are twice the size
        ; of the internal frames, so we need to do
        ; another call to the scale function

	bsr	ScaleFrame_InPlace
	ENDIF

        ;====================================
        ; Apply IIR filter to input
        ;====================================
        ; Input frames		: Source frame Left
        ; Output frames		: Source frame Left
        ; Workspace frames	: None

        ;------------------------------------
        ; Filter the input data stream at
        ; the full data rate
        ;------------------------------------

	move	x:(rD+FX_STATE_IO2_IN0),r0                     ; left front out
	move	rD,a
	add		#(IIR_Input-StaticWorkspaceBase),a
	move	a,r1						; Apply the input IIR filter
	bsr		RVB_IIR_InPlace
	
	IF @DEF('HALFSAMPLERATE')

        ; If we are running at half the sample
        ; rate, the input frames are twice the size
        ; of the internal frames, so we need to do
        ; another call to the filter function
	bsr		RVB_IIR_InPlace

	ENDIF



	IF @DEF('HALFSAMPLERATE')
        ;----------------------------------
        ;decimate the input data stream to
        ;half the input data rate
        ;----------------------------------
        ;apply the anti-aliasing IIR filter
        ;and the input filter

	move	x:(rD+FX_STATE_IO2_IN0),r0                     ; left front output
	move	rD,a
	add		#(IIR2_AntiAlias_Input-StaticWorkspaceBase),a
	move	a,r1
	bsr		RVB_AntiAlias_InPlace

        ; Decimate the filtered input by
        ; copying every other sample
	move	x:(rD+FX_STATE_IO2_IN0),r0                     ; left front output
	move	r0,r1
	move	#2,n0
	dor	#SizeOfFrame,RVB_DecimateInputLoop
		move	x:(r0)+n0,x0
		move	x0,x:(r1)+
RVB_DecimateInputLoop

	
	ENDIF							; endif HALFSAMPLERATE

	IF      !BLOCKING_DMA
        bsr	DMAWaitForEOL    
	ENDIF

        ;======================================
        ; Apply any fading to the input buffers
        ;======================================
	IF FADER_ENABLED
	
	bsr	RVB_Fader_Process

	ENDIF							; endif FADER_ENABLED

        ;====================================
        ; Calculate early reflections
        ;====================================
        ; Input frames		: 0 , 1 to 4 , 21 to 24
        ; Output frames		: 1 - 4
        ; Workspace frames	: None


        ; Buffer 0,1,21 -> Buffer 1
        ; Buffer 0,2,22 -> Buffer 2
        ; Buffer 0,3,23 -> Buffer 3
        ; Buffer 0,4,24 -> Buffer 4

	move	x:(rD+pBuffer1-StaticWorkspaceBase),r1		;r1=Pointer to the first of the 4 reflection taps
	dor	#4,RVB_EarlyReflectionsLoop1
		move	x:(rD+pBuffer0-StaticWorkspaceBase),r0	; r0=pointer to the common reflection tap
		bsr	AccumulateFrame_InPlace
		
		;nop							; Can't have a 'bsr' at the end of a loop
		move	rD,a					;( 'a' used after the loop )
RVB_EarlyReflectionsLoop1



	move	x:(rD+pBuffer21-StaticWorkspaceBase),r0	
	move	x:(rD+pBuffer1-StaticWorkspaceBase),r1	;r1=Pointer to the first of the 4 reflection taps
	
	move	rD,a
	add		#(ReflectionsFeedbackGain-StaticWorkspaceBase),a
	move	a,r2
	dor	#4,RVB_EarlyReflectionsLoop2
		move	x:(r2)+,x0
		bsr	MultiplyAccumulateFrame_InPlace		; frame1[n]=frame1[n]+x0*frame0[n]

		;nop		 ; Can't have a bsr at the end of a do loop
		move	rD,a	 ; This instruction is needed after the loop
RVB_EarlyReflectionsLoop2

        ; Buffer 0 is free
        ; Buffers 1-4 contain data that should be 
        ; written to reflection input delay buffer



        IF SKIP_SHORT_REVERB

        bra     RVB_SkipShortReverb  

        ELSE
                     
        ;====================================
        ; Add the short reverb feedback to 
        ; short reverb inputs
        ;====================================
        ; Input frames		: 25 to 28 , 5 to 12
        ; Output frames		: 25 to 28
        ; Workspace frames	: None


        ; Get a pointer to the short reverb input gains.
	add	#(ShortReverbInputGain_Channel0a-StaticWorkspaceBase),a
	move	a,r3
	
	move	x:(rD+pBuffer5-StaticWorkspaceBase),r0
	move	x:(rD+pBuffer25-StaticWorkspaceBase),r2
	
	move	#SizeOfFrame,n2

	dor	#4,RVB_ShortReverbLoop1
		dor	#2,RVB_ShortReverbLoop2
			move	r2,r1
			move	x:(r3)+,x0
			bsr	MultiplyAccumulateFrame_InPlace	; frame1[n]=frame1[n]+x0*frame0[n]
			nop
RVB_ShortReverbLoop2
		move	x:(r2)+n2,x0			       	; Increment r2 (Ignore result)
RVB_ShortReverbLoop1


        ; Buffers 25-28 contain input data for 
        ; the crossfeed matrix
        ; Buffers 5-12 are free

        ENDIF ; skip short reverb

RVB_SkipShortReverb

        ;====================================
        ; Long Reverb
        ;====================================
        ;   Input frames		: Buffers 13 - 20 , 29,30
        ;	Output frames		: Buffers 9,10,11,29,30
        ;	Workspace frames	: None


        ; Accumulate the long reverb input taps

	move	x:(rD+pBuffer14-StaticWorkspaceBase),r0
	move	x:(rD+pBuffer15-StaticWorkspaceBase),r1
	move	x:(rD+pBuffer9-StaticWorkspaceBase),r2
	bsr		AccumulateFrame_OutOfPlace

	move	x:(rD+pBuffer13-StaticWorkspaceBase),r0
	;move	x:(rD+pBuffer16-StaticWorkspaceBase),r1		; (Set up by exit conditions of previous subroutine)
	;move	x:(rD+pBuffer10-StaticWorkspaceBase),r2		; (Set up by exit conditions of previous subroutine)
	bsr		AccumulateFrame_OutOfPlace
	

	move	x:(rD+pBuffer17-StaticWorkspaceBase),r0
	move	x:(rD+pBuffer9-StaticWorkspaceBase),r1
	bsr		AccumulateFrame_InPlace

	;move	x:(rD+pBuffer18-StaticWorkspaceBase),r0		; (Set up by exit conditions of previous subroutine)
	;move	x:(rD+pBuffer10-StaticWorkspaceBase),r1		; (Set up by exit conditions of previous subroutine)
	bsr		AccumulateFrame_InPlace

	move	x:(rD+pBuffer20-StaticWorkspaceBase),r0
	move	x:(rD+pBuffer9-StaticWorkspaceBase),r1
	bsr		AccumulateFrame_InPlace

	move	x:(rD+pBuffer19-StaticWorkspaceBase),r0
	;move	x:(rD+pBuffer10-StaticWorkspaceBase),r1		; (Set up by exit conditions of previous subroutine)
	bsr		AccumulateFrame_InPlace


       	;-------------------------------------------
       	; Mix and scale the accumulated outputs into
       	; a separate buffer in preparation 
       	; for mixing with the outputs of the 
       	; crossfeed matrix
       	;-------------------------------------------

	move	x:(rD+pBuffer9-StaticWorkspaceBase),r0
	move	x:(rD+pBuffer10-StaticWorkspaceBase),r1
	move	x:(rD+pBuffer11-StaticWorkspaceBase),r2
	bsr    	AccumulateFrame_OutOfPlace
	
	move	x:(rD+pBuffer11-StaticWorkspaceBase),r0
	move	x:(rD+LongReverbCrossfeedGain-StaticWorkspaceBase),x0
	bsr    	ScaleFrame_InPlace

	

        ; Scale outputs of the large adder by the
        ; long reverb input gain

	move	x:(rD+pBuffer9-StaticWorkspaceBase),r0
	move	x:(rD+LongReverbInputGain-StaticWorkspaceBase),x0
	bsr    	ScaleFrame_InPlace			        ; Buffer9 =Buffer9 *LongReverbInputGain
	bsr    	ScaleFrame_InPlace			        ; Buffer10=Buffer10*LongReverbInputGain
	
	
	move	x:(rD+pBuffer29-StaticWorkspaceBase),r0
	move	x:(rD+pBuffer9-StaticWorkspaceBase),r1
	bsr    	AccumulateFrame_InPlace			        ; Buffer9 =Buffer9 +Buffer29
	bsr    	AccumulateFrame_InPlace			        ; Buffer10=Buffer10+Buffer30

	move	x:(rD+pBuffer9-StaticWorkspaceBase),r0	        ; Copy the buffers for 
	move	x:(rD+pBuffer29-StaticWorkspaceBase),r1	        ; the long reverb outputs
	bsr	CopyFrame
	bsr	CopyFrame

	; Apply the IIR within the long reverb feedback
	move	x:(rD+pBuffer9-StaticWorkspaceBase),r0
	move	rD,a
	add	#(IIR_LongReverb_Channel0-StaticWorkspaceBase),a
	move	a,r1
	bsr	RVB_IIR_InPlace

	move	rD,a
	add	#(IIR_LongReverb_Channel1-StaticWorkspaceBase),a
	move	a,r1
	bsr	RVB_IIR_InPlace


        ; Long reverb outputs in frames 29 and 30
        ; Long reverb delay buffers input in frames 9 and 10
        ; Long reverb crossfeed in frame 11


        ;================================
        ; Long reverb main delay line
        ;================================
        ; Calculate IIRs on the main delay line
        ; Process read buffers 14,16 and 18 in place.

	move	x:(rD+pBuffer14-StaticWorkspaceBase),r0
	move	rD,a
	add	#(IIR_LongReverb_MainDelay0-StaticWorkspaceBase),a
	move	a,r1
	move	#SizeOfFrame,n0
	move	#SizeOfIIR_Data,n1
	dor	#3,RVB_LongReverbLoop3
		bsr	RVB_IIR_InPlace

		move	x:(r0)+n0,x0				; Increment r0 so it points to the next frame

        	; The IIR operation increments r0 by SizeOfFrame,
        	; so after this instruction, r0 has been 
        	; incremented by a total of 2*SizeOfFrame.

		move	x:(r1)+n1,x0				; Increment r1 so it points to the next IIR block
RVB_LongReverbLoop3
				    				; Outputs in frames 22,24 and 26.

        ;====================================
        ; Crossfeed matrix
        ;====================================
        ; Input frames      : 25 to 28
        ; Output frames     : 5 to 8
        ; Workspace frames  : None

        IF      SKIP_CROSSFEED

        bra     SkipCrossfeed

        ELSE
                 
	move	x:(rD+pBuffer5-StaticWorkspaceBase),r4	        ; r4=Pointer to output frames
							 	; Output frames are in buffers 5 to 8
	
	move	rD,a
	add	#(CrossfeedMatrixChannel0-StaticWorkspaceBase),a
	move	a,r3					 	; r3=Pointer to coeffs
	
	move	#SizeOfFrame,n0

	dor	#4,RVB_Crossfeed_Loop2			        ; k loop
		move	x:(rD+pBuffer25-StaticWorkspaceBase),r1	; r1=pointer to input frames
								; Input frames are in buffers 25 to 28

		dor	#SizeOfFrame,RVB_Crossfeed_Loop1	; i loop
			move	r1,r0				; Get a pointer to the i'th element of the first input frame
			
			move	r3,r2				; Reset the pointer to the base of the coefficients
	
			clr	a

			dor	#4,RVB_Crossfeed_Loop	        ; j loop
				move	x:(r0)+n0,x0		; Read data from BufferIn[j][i]
				move	x:(r2)+,x1		; Read coefficient j
				macr	x0,x1,a
RVB_Crossfeed_Loop
			move	a,x:(r4)+			; Write FrameOut[i]
			
			move	x:(r1)+,x0			; Increment pointer to input frame
								; (Ignore result of load)
RVB_Crossfeed_Loop1
		move	x:(r3)-,x0				; Select the next set of coefficients
								; (Ignore result of load)
RVB_Crossfeed_Loop2


								; Results in frames 5-8
        ENDIF ; Crossfeed

SkipCrossfeed

        ;====================================
        ; Add long reverb to crossfeed output
        ;====================================
        ; Input frames		: 5-8,11
        ; Output frames		: 5-8
        ; Workspace frames	: None

	move	x:(rD+pBuffer5-StaticWorkspaceBase),r1
	dor	#4,RVB_AddLongReverbLoop
		move	x:(rD+pBuffer11-StaticWorkspaceBase),r0
		bsr	AccumulateFrame_InPlace

		;nop						; (Can't have a 'bsr' at the end of a do loop)
SkipCrossfeedAndLongReverb
		move	rD,a					; (This instruction is needed after the loop)
RVB_AddLongReverbLoop


        ;====================================
        ; Apply short Reverb IIRs
        ;====================================
        ; Input frames		: 5-8
        ; Output frames		: 5-8
        ; Workspace frames	: None

	;move	#SizeOfFrame,n2
	move	#SizeOfIIR_Data,n3

	move	x:(rD+pBuffer5-StaticWorkspaceBase),r0	        ; r0 points to the first of the 4 consecutive 
								; buffers to process
	
	;move	rD,a						;( This instruction is include in place of the 
								; 'nop' at the end of the previous 'do' loop.
	add	#(IIR_ShortReverbChannel0-StaticWorkspaceBase),a
	move	a,r3						; r3 points to the first of the 4 consecutive 
								; IIR filter structures

	dor	#4,RVB_ReverbIIRLoop
		move	r3,r1					; A pointer to the filter

;*********************************************************************		
; DEBUGGING CODE - to replace the IIR filter with a divide by 2
;*********************************************************************
;		msg		"Replaced short reverb IIR filters with a /2"
;		dor	#SizeOfFrame,RVB_TestIIR_Loop
;		move	x:(r0),a
;		asr		a
;		move	a,x:(r0)+
;RVB_TestIIR_Loop
;*********************************************************************
;	End of debugging code
;**	*******************************************************************
		bsr    	RVB_IIR_InPlace


        	; Filter the buffer.
        	; Increment r0 by 'SizeOfFrame'


		move	x:(r3)+n3,x0				; Increment r3 by the size of a IIR block
RVB_ReverbIIRLoop



		      						; Results in frames 5-8 (ready to be written to feedback buffers)



RVB_FinishedCrossfeed


		; The following buffers now contain data
		;	Buffer 0	Unused (Will be filled with data to send to BL40)
		;	Buffer 1	Short reflection 0 (Send to BL00 & output mixer)
		;	Buffer 2	Short reflection 1 (Send to BL01 & output mixer)
		;	Buffer 3	Short reflection 2 (Send to BL02 & output mixer)
		;	Buffer 4	Short reflection 3 (Send to BL03 & output mixer)
		;	Buffer 5	Short reverb 0 (Send to BL30)
		;	Buffer 6	Short reverb 1 (Send to BL31)
		;	Buffer 7	Short reverb 2 (Send to BL32)
		;	Buffer 8	Short reverb 3 (Send to BL33)
		;	Buffer 9	Long reverb 0 (Send to BL50)
		;	Buffer 10	Long reverb 1 (Send to BL51)
		;	Buffer 11	Unused
		;	Buffer 12	Unused
		;	Buffer 13	Unused
		;	Buffer 14	Filtered main buffer 0 (Send to BL41)
		;	Buffer 15	Unused
		;	Buffer 16	Filtered main buffer 1 (Send to BL42)
		;	Buffer 17	Unused
		;	Buffer 18	Filtered main buffer 2 (Send to BL43)
		;	Buffer 19	Unused
		;	Buffer 20	Unused
		;	Buffer 21	Unused
		;	Buffer 22	Unused
		;	Buffer 23	Unused
		;	Buffer 24	Unused
		;	Buffer 25	Short reverb 0 (Send to output mixer)
		;	Buffer 26	Short reverb 1 (Send to output mixer)
		;	Buffer 27	Short reverb 2 (Send to output mixer)
		;	Buffer 28	Short reverb 3 (Send to output mixer)
		;	Buffer 29	Long reverb 0 (Send to output mixer)
		;	Buffer 30	Long reverb 1 (Send to output mixer)


        ;====================================
        ; Copy the filered input frame into the buffer that
        ; will be copied into the main delay buffer
        ;====================================

	move	x:(rD+FX_STATE_IO2_IN0),r0	                ; Copy the (decimated) processed input frame to buffer 0
	move	x:(rD+pBuffer0-StaticWorkspaceBase),r1
	bsr		CopyFrame


        ;====================================
        ; Mix the output channels
        ;====================================
        ; Two channel mode
        ;   Input frames		: Buffers 1,2, 25,26, 29
        ;   Input frames		: Buffers 3,4, 27,28, 30
        ;	Output frames		: Left-Out, Right-Out
        ;	Workspace frames	: Buffers 21,22,23,24

        ;
        ; Four channel mode
        ;   Input frames		: Buffers 1,25,29
        ;   Input frames		: Buffers 2,26,29
        ;   Input frames		: Buffers 3,27,30
        ;   Input frames		: Buffers 4,28,30
        ;	Output frames		: Left-Front
        ;						: Left-Rear
        ;						: Right-Front
        ;						: Right-Rear
        ;	Workspace frames	: Buffers 21,22,23,24


        ; Reflections data in buffers 21-24
        ; Short reverb data in buffer 25-28
        ; Long reverb data in buffers 29-30


	
	move	x:(rD+pBuffer1-StaticWorkspaceBase),r1		; A pointer to reflections data buffers 0 & 1
	move	x:(rD+pBuffer25-StaticWorkspaceBase),r2		; A pointer to short reverb data buffers 0 & 1
	move	x:(rD+pBuffer29-StaticWorkspaceBase),r3		; A pointer to long reverb data buffer 0
	move	x:(rD+pBuffer21-StaticWorkspaceBase),r4		; A pointer to the output data buffer 0 (or 0&1 in 4 channel mode)
														;


	move	rD,a
	add		#(ReflectionOutputGain_Channel0-StaticWorkspaceBase),a
	move	a,r0							      							; A pointer to reflections
																			; output gain 0 and 1

	move	x:(rD+ShortReverbOutputGain_Channel-StaticWorkspaceBase),y0    	; Short reverb
	move	x:(rD+LongReverbOutputGain_Channel-StaticWorkspaceBase),y1    	; Long reverb gain

	; Are we in four channel mode?
	move	x:(rD+nOutputChannels-StaticWorkspaceBase),a
	cmp	#4,a
	beq	RVB_FourChannelMixFront

RVB_TwoChannelMixFront
														; Two channel mix
	bsr	RVB_TwoChannelOutputMix							; Process the left channel
														; Buffers 1,2, 25,26, 29 => 21

														; Initialise a pointer to the right output channel
	move	x:(rD+pBuffer22-StaticWorkspaceBase),r4		; A pointer to the output data buffer 1
														; (r4 set up by previous call to RVB_TwoChannelOutputMix)
	bra	RVB_MixedFront

RVB_FourChannelMixFront
														; Four channel mix
	bsr	RVB_FourChannelOutputMix						; Process the front channels
														; Buffers 1,25,29 => 21
														; Buffers 2,26,29 => 22

														; Initialise a pointer to the rear output channels
	move	x:(rD+pBuffer23-StaticWorkspaceBase),r4		; A pointer to the output data buffers 2&3
RVB_MixedFront


	move	x:(rD+pBuffer3-StaticWorkspaceBase),r1		; A pointer to reflections data buffer 2 & 3
	move	x:(rD+pBuffer27-StaticWorkspaceBase),r2		; A pointer to short reverb data buffer 2 & 3
	move	x:(rD+pBuffer30-StaticWorkspaceBase),r3		; A pointer to long reverb data buffer 1
														; (R3 set up by previous call to RVB_#OutputMix)
														; Pointer to output channel already initialised

	move	rD,a
	add	#(ReflectionOutputGain_Channel2-StaticWorkspaceBase),a
	move	a,r0															; A pointer to reflections
																			; output gain 2 and 3
	
	move	x:(rD+ShortReverbOutputGain_Channel-StaticWorkspaceBase),y0    	; Short reverb gain
	move	x:(rD+LongReverbOutputGain_Channel-StaticWorkspaceBase),y1     	; Long reverb gain

	       							; Are we in four channel mode?
	move	x:(rD+nOutputChannels-StaticWorkspaceBase),a
	cmp    	#4,a
	beq    	RVB_FourChannelMixRear

RVB_TwoChannelMixRear
	bsr	RVB_TwoChannelOutputMix			       			; Two channel mix
														; Mix the right channel
														; Buffers 3,4, 27,28, 30 => 22
	
	bra	RVB_MixedRear

RVB_FourChannelMixRear
	bsr	RVB_FourChannelOutputMix						; Four channel mix
														; Mix the rear channels
														; Buffers 3,27,30 => 23
														; Buffers 4,28,30 => 24
	
	move	x:(rD+pBuffer23-StaticWorkspaceBase),r0
	IF @DEF('HALFSAMPLERATE')
		move	x:(rD+pBuffer27-StaticWorkspaceBase),r1                     ; Use Buffer1 & 2 as temp buffer
		move	rD,a
		add		#(IIR2_AntiAlias_LeftRear-StaticWorkspaceBase),a
		move	a,r2
		bsr		RVB_InterpolateFrame

		move	x:(rD+pBuffer27-StaticWorkspaceBase),r0                     ; Buffer1 & 2 contains interpolated output data
	ENDIF							; HALFSAMPLERATE
	
	move	x:(rD+FX_STATE_IO2_OUT2),r1                     ; left rear out
	;bsr CopyFrame
	bsr	AccumulateFrame_InPlace
	IF @DEF('HALFSAMPLERATE')
		bsr	AccumulateFrame_InPlace
	ENDIF
	
	
	move	x:(rD+pBuffer24-StaticWorkspaceBase),r0
	IF @DEF('HALFSAMPLERATE')
		move	x:(rD+pBuffer27-StaticWorkspaceBase),r1                     ; Use Buffer1 & 2 as temp buffer
		move	rD,a
		add		#(IIR2_AntiAlias_RightRear-StaticWorkspaceBase),a
		move	a,r2
		bsr		RVB_InterpolateFrame

		move	x:(rD+pBuffer27-StaticWorkspaceBase),r0                     ; Buffer1 & 2 contains interpolated output data
	ENDIF							; HALFSAMPLERATE
	
	move	x:(rD+FX_STATE_IO2_OUT3),r1                     ; right rear out
	;bsr CopyFrame
	bsr	AccumulateFrame_InPlace
	IF @DEF('HALFSAMPLERATE')
		bsr	AccumulateFrame_InPlace
	ENDIF

RVB_MixedRear

	; All output channels mixed


	move	x:(rD+pBuffer21-StaticWorkspaceBase),r0
	IF @DEF('HALFSAMPLERATE')
		move	x:(rD+pBuffer27-StaticWorkspaceBase),r1                     ; Use Buffer1 & 2 as temp buffer
		move	rD,a
		add		#(IIR2_AntiAlias_LeftFront-StaticWorkspaceBase),a
		move	a,r2
		bsr		RVB_InterpolateFrame
		move	x:(rD+pBuffer27-StaticWorkspaceBase),r0                     ; Buffer1 & 2 contains interpolated output data
	ENDIF							; HALFSAMPLERATE

	move	x:(rD+FX_STATE_IO2_OUT0),r1                     ; left front out
	;bsr CopyFrame
	bsr	AccumulateFrame_InPlace
	IF @DEF('HALFSAMPLERATE')
		bsr	AccumulateFrame_InPlace
	ENDIF

	move	x:(rD+pBuffer22-StaticWorkspaceBase),r0
	IF @DEF('HALFSAMPLERATE')
		move	x:(rD+pBuffer27-StaticWorkspaceBase),r1                     ; Use Buffer1 & 2 as temp buffer
		move	rD,a
		add		#(IIR2_AntiAlias_RightFront-StaticWorkspaceBase),a
		move	a,r2
		bsr		RVB_InterpolateFrame
		move	x:(rD+pBuffer27-StaticWorkspaceBase),r0                     ; Buffer1 & 2 contains interpolated output data
	ENDIF							; HALFSAMPLERATE

	move	x:(rD+FX_STATE_IO2_OUT1),r1                     ; right front out
	;bsr CopyFrame
	bsr	AccumulateFrame_InPlace
	IF @DEF('HALFSAMPLERATE')
		bsr	AccumulateFrame_InPlace
	ENDIF

        ;====================================
        ; Finished processing all the data.
        ; Write the result to the host
        ;====================================
FinishedProcessing




	bsr		RVB_WriteOutputFrames
	rts





;----------------------------------
;	RVB_TwoChannelOutputMix
;----------------------------------
;	On entry
;		r0	points to Reflection 0 (or 1) gain
;		r1  points to reflection 0 (or 1) buffer
;		r2  points to ShortReverb 0 (or 1) buffer
;		r3  points to LongReverb 0 (or 1) buffer
;		r4	points to output buffer
;		y0	Short reverb 0 (or 1) gain
;		y1	Long reverb 0 (or 1) gain
;
;	On exit
;		a	Undefined
;		b	Undefined
;		x0	Undefined
;		x1	Undefined
;		r0	Undefined
;		r1	Incremented by SizeOfFrame
;		r2	Incremented by SizeOfFrame
;		r3	Incremented by SizeOfFrame
;		r4	Incremented by SizeOfFrame
;		The input channels have mixed into the buffer pointed to by r4 on entry
;		

RVB_TwoChannelOutputMix
	move	#SizeOfFrame,n1
	move	#SizeOfFrame,n2
	move	x:(r0)+,x0					; Increment r0 (Ignore the result)

	dor	#SizeOfFrame,RVB_TwoChannelOutputMixLoop
		move	x:(r1+n1),x1
		move	x:(r0)-,x0
		mpy	x1,x0,a					; Scaled reflection 1

		move	x:(r1)+,x1
		move	x:(r0)+,x0
		macr	x1,x0,a					; + Scaled reflection 0

		move	x:(r2+n2),x1
		macr	x1,y0,a					; + Scaled short reverb 1

		move	x:(r2)+,x1
		macr	x1,y0,a					; + Scaled short reverb 0

		move	x:(r3)+,x1
		macr	x1,y1,a					; + Scaled long reverb 0

		asl	#FixedOutputScaling,a,a

		move	a,x:(r4)+				; Store result
RVB_TwoChannelOutputMixLoop


	rts



;----------------------------------
;	RVB_FourChannelOutputMix
;----------------------------------
;	On entry
;		r0	points to Reflection 0 (or 1) gain
;		r1  points to reflection 0 (or 1) buffer
;		r2  points to ShortReverb 0 (or 1) buffer
;		r3  points to LongReverb 0 (or 1) buffer
;		r4	points to output buffer
;		y0	Short reverb gain
;		y1	Long reverb gain
;
;	On exit
;		a	Undefined
;		b	Undefined
;		x0	Undefined
;		x1	Undefined
;		r0	Undefined
;		r1	Incremented by SizeOfFrame
;		r2	Incremented by SizeOfFrame
;		r3	Incremented by SizeOfFrame
;		r4	Incremented by SizeOfFrame
;		The input channels have mixed into the buffer r4 and r4+SizeOfFrame
;				r4[0: n-1] = ( r0[0] * r1[0: n-1]  +  y0 * r2[0: n-1] + y1/2 * r3[0:n-1] ) << FixedOutputScaling
;				r4[n:2n-1] = ( r0[1] * r1[n:2n-2]  +  y0 * r2[n:2n-1] + y1/2 * r3[0:n-1] ) << FixedOutputScaling

RVB_FourChannelOutputMix
	
	move	#SizeOfFrame,n4
	move	#SizeOfFrame,n2
	move	#SizeOfFrame,n1

	move	x:(r0)+,x0					; Increment r0 (Ignore the result)

	move	y1,a						; Divide the long reverb 
	asr	a						; gain by 2
	move	a,y1

	dor		#SizeOfFrame,RVB_FourChannelOutputMixLoop
		move	x:(r1+n1),x1
		move	x:(r0)-,x0
		mpy    	x1,x0,b					; Scaled reflection 1

		move	x:(r1)+,x1
		move	x:(r0)+,x0
		mpy    	x1,x0,a					; + Scaled reflection 0

		move	x:(r2+n2),x1
		macr	x1,y0,b					; + Scaled short reverb 1

		move	x:(r2)+,x1
		macr	x1,y0,a					; + Scaled short reverb 0



		move	x:(r3)+,x1
		macr	x1,y1,b					; + Scaled long reverb 1
		macr	x1,y1,a					; + Scaled long reverb 0

		asl    	#FixedOutputScaling,b,b
		asl    	#FixedOutputScaling,a,a

		move	b,x:(r4+n4)				; Store result 1
		move	a,x:(r4)+				; Store result 0

RVB_FourChannelOutputMixLoop
	rts




;----------------------------------
;	RVB_ReadInputFrames
;----------------------------------
;	On Entry
;		rD	Pointer to Reverb engine workspace

;	Configure DMA controller to transfer data from the host into the GP memory
;	Wait until the transfer is complete before returning
RVB_ReadInputFrames

	;DEBUGGERLOG	#0
	;bsr		DMA_WaitUntilReady	; During debugging we don't return from the DMA 
		  				; transfer until the DMA transfer has completed,
		  				; so this call is unnecessary
	

	move	rD,a
	add	#(DMA_ControlBlock_Rd0-StaticWorkspaceBase),a
        IF !@DEF('SIM')

        IF      BLOCKING_DMA
	bsr     DMAStartNode_Wait   
        ELSE
	bsr 	DMAStartNode   
        ENDIF

        ENDIF

	rts



;----------------------------------
;	RVB_WriteOutputFrames
;----------------------------------
;
;	Configure the DMA controller to transfer results frames from the GP to the host
;	Wait until the transfer is complete before returning
RVB_WriteOutputFrames


	move	rD,a
	add	#(DMA_ControlBlock_Wr0-StaticWorkspaceBase),a

        IF !@DEF('SIM')

	bsr     DMAStartNode_Wait  

        ENDIF

	
	rts






;----------------------------------
;	 RVB_IIR_InPlace
;----------------------------------
;	On Entry
;		r0	Pointer to buffer to process
;		r1	Pointer to IIR data block
;
;	On Exit
;		a	Undefined
;		x	Undefined
;		y	Undefined
;		r0	Points to word after the end of the input buffer
;		r1	Preserved
;
;		Buffer pointed to by r0 on entry has been passed through the IIR filter
;
;	Apply an IIR filter to the specified frame.
;
RVB_IIR_InPlace
	move	x:(r1+IIR_CoefficientA1),y0
	move	x:(r1+IIR_CoefficientB0),y1

	dor		#SizeOfFrame,RVB_IIRLoop
		move	x:(r1+IIR_DelayElement),x0
		mpy		x0,y0,a

		move	x:(r0),x1
		mac		x1,y1,a

		move	a,x:(r1+IIR_DelayElement)
		move	a,x:(r0)+
RVB_IIRLoop
	rts




	IF @DEF('HALFSAMPLERATE')


;----------------------------------
;	RVB_InterpolateFrame					**** This function is only used when processing at half the sample rate ****
;----------------------------------
;	On Entry
;		r0	Pointer to input data frame (Length= SizeOfFrame)
;		r1	Pointer to output data (Length=SizeOfIoFrame)
;		r2	Pointer to IIR output filter data
;		rD	Pointer to reverb engine workspace
;
;	On Exit
;		a	Undefined
;		r0	Undefined
;		r1	Undefined
;		r2	Undefined
;		r3	Undefined
;	
; Interpolate the samples by a factor of 2 by
;	1. Repeating each sample twice.
;	2. Applying an antialiasing filter
; It is NOT acceptable for the input and output frames to be the same.(i.e. Ok for r0!=r1).

RVB_InterpolateFrame
	move	r1,r3						; Make a copy of the output pointer

        ;---------------------------------------
        ; Expand the input frame to the output
        ; frame by repeating input samples twice
        ;---------------------------------------
	dor	#SizeOfFrame,RVB_InterpolateFrameLoop
		move	x:(r0)+,x0
		move	x0,x:(r1)+
		move	x0,x:(r1)+
RVB_InterpolateFrameLoop

        ;--------------------------
        ; Filter the output block
        ;--------------------------

	move	r3,r0						; Pointer to output block
	move	r2,r1						; Pointer to filter
	bsr	RVB_AntiAlias_InPlace
													
	rts



;----------------------------------
;	 RVB_AntiAlias_InPlace					**** This function is only used when processing at half the sample rate ****
;----------------------------------
;	On Entry
;		r0	Pointer to buffer to process
;		r1	Pointer to IIR2 data block
;		rD	Pointer to reverb engine workspace
;
;	On Exit
;		a	Undefined
;		x	Undefined
;		y	Undefined
;		r0	Points to word after the end of the input buffer
;		r1	Preserved
;		r3	Undefined
;
;		Buffer pointed to by r0 on entry has been passed through the IIR filter
;
;	Apply a second order section IIR filter, with coefficients suitable 
;	for a 1 to 2 interpolation, to the specified frame.
;
RVB_AntiAlias_InPlace
	msg		"Turned off antialiasing"
	rts

	move	r0,r3							; Copy the buffer pointer
	move	rD,a
	add	#IIR2_AntiAliasing_Coefficients1-StaticWorkspaceBase,a
	move	a,r2
	bsr	RVB_IIR2_InPlace

	
	move	r3,r0
	move	x:(r1)+,x0						; Increment IIR data 
	move	x:(r1)+,x0						; pointer by 2
	
	move	rD,a
	add	#IIR2_AntiAliasing_Coefficients2-StaticWorkspaceBase,a
	move	a,r2
	bsr	RVB_IIR2_InPlace

	rts



;----------------------------------
;	 RVB_IIR2_InPlace					**** This function is only used when processing at half the sample rate ****
;----------------------------------
;	On Entry
;		r0	Pointer to buffer to process. (Length=SizeOfIoFrame)
;		r1	Pointer to IIR2 data block
;		r2	Pointer to IIR2 coefficient block
;
;	On Exit
;		a	Undefined
;		b	Undefined
;		x	Undefined
;		y	Undefined
;		r0	Points incremented by SizeOfIoFrame
;		r1	Preserved
;		r2	Preserved
;
;		Buffer pointed to by r0 on entry has been passed through the IIR filter
;
;	Apply a second order section IIR filter to the specified frame.
;
;       BUGBUG(georgioc) Optimize IIRs so they dont suck. make them use Y-mem like standalone IIR2

RVB_IIR2_InPlace


	move	x:(r1+IIR2_CoefficientY0),y0			; Load y0
	move	x:(r1+IIR2_CoefficientY1),y1			; Load y1
	
	dor	#SizeOfIoFrame,RVB_IIR2Loop
		move	x:(r2+IIR2_CoefficientA2),x0		; a2
		move	x:(r2+IIR2_CoefficientB2),x1		; b2
		
		mpy	x0,y1,a					; a2*y1
		mpy	x1,y1,b					; b2*y1
				
		move	x:(r2+IIR2_CoefficientA1),x0		; a1
		move	x:(r2+IIR2_CoefficientB1),x1		; b1
		move	y0,y1

		mac	x0,y0,a				        ; a1*y0 + a2*y1
		mac	x1,y0,b				        ; b1*y0 + b2*y1
		
		move	x:(r0),x0				; Sample
		add	x0,b				        ; Sample + b1*y0 + b2*y1

		move	x:(r2+IIR2_CoefficientA0),x1		; a0
		move	b,y0

		mac	y0,x1,a				        ; (Sample + b1*y0 + b2*y1) *a0 + (a1*y0 + a2*y1)
		
		move	a,x:(r0)+				; Store output
RVB_IIR2Loop
	
	move	y0,x:(r1+IIR2_CoefficientY0)			; Store y0
	move	y1,x:(r1+IIR2_CoefficientY1)			; Store y1

	rts

	ENDIF							;HALFSAMPLERATE





;----------------------------------
;	RVB_InitialiseDmaCommandBlocks
;----------------------------------
;	On Entry
;		rD	Pointer to Reverb engine workspace
;
;	On Exit
;		r0		Undefined
;		n0		Undefined
;		m0		-1
;		x0		Undefined
;		a		Undefined
;

;
;	This function initialises the linked list of DMA command blocks. The
;	following operations are performed:
;		1. Create the linked list for the read and write blocks
;		2. Sets up the pointers to the DSP memory.
;
;	The read linked list is 16 frames in length
;	The write linked list is 9 frames in length
;
RVB_InitialiseDmaCommandBlocks

        ;==================================================
        ; Fill the following elements of the DMA command block
        ;	'controlBits'
        ;	'Count' 
        ;	'Offset
        ;	'Base Address'
        ;	'SizeMinusOne'
        ;==================================================

	move	rD,a
	add	#DMA_ControlBlock_Wr0-StaticWorkspaceBase,a
	move	a,r0						; r0 points to the start of the first write control block


	move	#DMAcbs_SizeofDMAcbs,n0				; n0 = Size of DMA command block
	move	#0,a0
	move	#SizeOfFrame,a1					; a0=0  a1=SizeOfFrame

	move	#(DMAcbs_DspToHost+DMAcbs_InterleaveOFF+DMAcbs_IOCOFF+DMAcbs_smOffWrBkON+DMAcbs_smBufIdCircular+DMAcbs_isoON+DMAcbs_smDataFmt2+DMAcbs_inc1),x0
	move	#>14,y0						; Fill 15 DMA write blocks
	bsr	RVB_FillDmaCommandBlocks
	
	move	#(DMAcbs_HostToDsp+DMAcbs_InterleaveOFF+DMAcbs_IOCOFF+DMAcbs_smOffWrBkON+DMAcbs_smBufIdCircular+DMAcbs_isoON+DMAcbs_smDataFmt2+DMAcbs_inc1),x0
	move	#>31,y0						; Fill 31 DMA read blocks
	bsr	RVB_FillDmaCommandBlocks



        ;======================================
        ; Fill the DSP start address entries
        ; in the Write DMA command blocks
        ;======================================
        ; There are 14 write blocks

	move	#-1,m0
	move	#DMAcbs_SizeofDMAcbs,n0

	move	rD,a
	add	#(DMA_ControlBlock_Wr0-StaticWorkspaceBase+DMAcbs_pDspStart),a
	move	a,r0
	
                                                                ; The first DMA command block contains
	move	x:(rD+pBuffer0-StaticWorkspaceBase),a	        ; a pointer to buffer 0
	move	a,x:(r0)+n0

        ; The next 3 DMA write command blocks refer to
        ; the separate components of the main delay
        ; buffer used in the long reverb. Data for
        ; these buffer is contained in buffers 14,16 and 18.

	move	x:(rD+pBuffer14-StaticWorkspaceBase),a
	dor	#3,RVB_udcb_Wr_MainDelayBuffersLoop
		move	a,x:(r0)+n0
		add	#2*SizeOfFrame,a
RVB_udcb_Wr_MainDelayBuffersLoop

        ; The next 4 DMA write command blocks are the
        ; reflection delay buffers.  Data is contained
        ; in buffer 1,2,3 and 4
        ; The next 4 DMA write command blocks are the
        ; short reverb delay buffers.  Data is contained
        ; in buffer 5,6,7 and 8

	move	x:(rD+pBuffer1-StaticWorkspaceBase),a
	dor	#8,RVB_udcb_Wr_ReflectionsBuffersLoop
		move	a,x:(r0)+n0
		add	#SizeOfFrame,a
RVB_udcb_Wr_ReflectionsBuffersLoop
													
        ; The next 2 DMA write command blocks are the
        ; long reverb delay buffers.  Data is contained
        ; in buffer 9 and 10

	move	x:(rD+pBuffer9-StaticWorkspaceBase),a
	dor	#2,RVB_udcb_Wr_LongReverbBuffersLoop
		move	a,x:(r0)+n0
		add	#SizeOfFrame,a
RVB_udcb_Wr_LongReverbBuffersLoop


	;======================================
	; Fill the DSP start address entries
	; in the Read DMA command blocks
	;======================================
	; There are 16 read blocks

	move	rD,a
	add	#(DMA_ControlBlock_Rd0-StaticWorkspaceBase+DMAcbs_pDspStart),a
	move	a,r0
	move	#DMAcbs_SizeofDMAcbs,n0
	
	; DMA blocks 1 through to 16 map to 
	; directly to buffers 1 through 16

	move	x:(rD+pBuffer0-StaticWorkspaceBase),a
	dor	#31,RVB_udcb_Rd_BuffersLoop
		move	a,x:(r0)+n0
		add	#SizeOfFrame,a
RVB_udcb_Rd_BuffersLoop


	;================================================
	; Fill in the information about the host memory 
	; pointers & delay buffers
	;================================================
	;----------------------------
	; Fill the Read DMA blocks
	;----------------------------

	
	move	rD,a						; Get a pointer to the start of the
	add	#(DMA_ControlBlock_Rd0-StaticWorkspaceBase),a	; block of DMA read blocks
	move	a,r0

	move	rD,a	                                        ; Get a pointer to the start of the new
	add	#(HostBufferInfo-StaticWorkspaceBase),a		; parameters stored in the scratch which have
	move	a,r1						; been updated by the host.
								; r1 points to start of Host buffer information block


	; Read blocks 0-12

       	; The first 13 read blocks are the reflection taps
       	; and short reverb taps. These all access the main 
       	; delay line. Therefore they all contain the same
       	; host pointer and length

	move	x:(r1),x0					; Get the host address of the main delay buffer
	move	x:(r1+1),x1					; Get the length of the main delay -1
													;
	dor	#13,RVB_udcb_HostBaseAddressLoop
		move	x0,x:(r0+DMAcbs_smBaseAddress)		; Store host base address of main delay buffer
		move	x1,x:(r0+DMAcbs_smSizeMinus1)		; Store length of main delay buffer

		move	x:(r0)+n0,a1				; Point to the next DMA block
RVB_udcb_HostBaseAddressLoop


        ; Read blocks 13-20
        ; The next 8 read blocks are the long reverb delay taps
        ; Delay taps are found in pairs with the first on the
        ; main delay line, and the next pairs successive
        ; buffers described in the host transfer block.

        ;
	dor	#4,RVB_udcb_HostBaseAddressLoop1
		move	x:(r1)+,x0				; Get the host address of the main delay buffer
		move	x:(r1)+,x1				; Get the length of the main delay -1
		dor	#2,RVB_udcb_HostBaseAddressLoop2
			move	x0,x:(r0+DMAcbs_smBaseAddress)	; Store host base address of main delay buffer
			move	x1,x:(r0+DMAcbs_smSizeMinus1)	; Store length of main delay buffer
			move	x:(r0)+n0,a1			; Point to the next DMA block
RVB_udcb_HostBaseAddressLoop2
		nop
RVB_udcb_HostBaseAddressLoop1



        ; Read blocks 21-30
        ; Information for the next 12 DMA blocks are 
        ; copied directly from the host information
        ; block which is configured by the host

	dor	#10,RVB_udcb_HostBaseAddressLoop3
		move	x:(r1)+,x0
		move	x0,x:(r0+DMAcbs_smBaseAddress)		; into the DMA command block
		move	x:(r1)+,x1
		move	x1,x:(r0+DMAcbs_smSizeMinus1)		; into the DMA command block
		move	x:(r0)+n0,a1				; Point to the next DMA block
RVB_udcb_HostBaseAddressLoop3


        ;----------------------------
        ; Fill the Write DMA blocks
        ;----------------------------
        ; There are 14 write DMA blocks and these map
        ; to each of the 14 buffer information blocks
        ; in the host information block.

	move	rD,a
	add	#(DMA_ControlBlock_Wr0-StaticWorkspaceBase),a
	move	a,r0

        move	rD,a
	add	#(HostBufferInfo-StaticWorkspaceBase),a
	move	a,r1						; r1 points to start of Host buffer information block

	dor	#14,RVB_udcb_HostBaseAddresLoop2
		move	x:(r1)+,x0
		move	x0,x:(r0+DMAcbs_smBaseAddress)		; Write the buffer base address
		move	x:(r1)+,x1
		move	x1,x:(r0+DMAcbs_smSizeMinus1)		; Write the buffer size
		move	x:(r0)+n0,a1				; Point to the next DMA block
RVB_udcb_HostBaseAddresLoop2


        ;--------------------------------------------
        ; Set up the correct read delay taps
        ;--------------------------------------------

	bsr	RVB_UpdateAllDmaCommandBlocks

	rts




;---------------------------------
;	RVB_FillDmaCommandBlocks
;---------------------------------
;	On entry
;		x0	The control bits
;		a0	Zero
;		a1	The size of the frame
;		y0	The number of DMA blocks to be written
;		rD	Pointer to reverb engine workspace
;
;	On exit
;		x0,a0,a1,y0 preserved
;		x1 Undefined
;
;	Fill the specified number of DMA command blocks with data.
;		1. Create the linked list structure
;		2. Fill the control bits
;		3. Fill the count value
;		4. Set the offset into the buffer to zero
;
RVB_FillDmaCommandBlocks
	move r0,r1					        ; Within the loop r1 takes the 
								; value of the previous DMA block.

	dor	y0,RVB_udcb_FillLoop
		move	r0,x:(r1+DMAcbs_pNxtCmd)		; Store the address of the current DMA block
								; in the 'next' pointer of the previous DMA block
		move	x0,x:(r0+DMAcbs_controlBits)
		move	a1,x:(r0+DMAcbs_count)
		move	a0,x:(r0+DMAcbs_smOffset)
		move	r0,r1					; Record the address of the current DMA block
		move	x:(r0)+n0,x1
RVB_udcb_FillLoop

	move	#DMAcbs_eol,x0					; Terminate the linked list with the 
	move	x0,x:(r1)					; end of list identifier
	rts
	

;----------------------------------
;		RVB_UpdateAllDmaCommandBlocks
;----------------------------------
;	On Entry
;		rD	Pointer to reverb private workspace
;
;	On Exit
;		a	Undefined
;		x	Undefined
;		y	Undefined
;		r0-r4	Undefined
;		n0,n2

;		Private data updated to reflect the new delay constants
;
;
; This function updates the parameters in the linked list of DMA command blocks.
;
; It changes the tap position on a delay line by repositioning the read taps 
; with respect to a corresponsing write tap. This ensures that the mininum 
; audible discontinuitiy occurs.
; 
; The position of the new read tap is calculated as follows:
;	1.	Find the position of the specified host write pointer
;	2.	Get the new delay tap position
;	3.	Calculate the delay tap position relative to the current write position.
;		(Take in to account that the buffer is a cyclic buffer).
;	4.	Write the new read tap position for the specified buffer.
; This procedure ensures that the data going in to the delay buffer is always continuous.
;

RVB_UpdateAllDmaCommandBlocks

        ; Wait until the current DMA transfer has
        ; completed. This avoids potential problems
        ; with the DMA controller updating the buffer
        ; indices at the same time as us.


	bsr	RVB_UpdateDmaCommandBlocksProcessedByFader	; Update the DMA blocks that are processed
						    		; by the 'delay tap' fader.
															

	bsr    	RVB_UpdateDmaCommandBlocksNotProcessedByFader	; Update the other DMA blocks in the system
	rts



;=================================
;	RVB_UpdateDmaCommandBlocksProcessedByFader
;=================================
;	On Entry
;		rD	Pointer to reverb private workspace
;
;	On Exit
;		r0	Undefined
;		r1	Undefined
;		r2	Undefined
;		a	Undefined
;		b	Undefined
;		x0	Undefined
;		x1	Undefined
;		y0	Undefined
;		y1	Undefined
;		n0	Undefined
;		n1	Undefined
;		DMA blocks are updated
;
;	Update the delays on the main delay line
;
RVB_UpdateDmaCommandBlocksProcessedByFader

								; Update the positions of the 5 read taps
								; corresponding to the reflections
	
	move	rD,a						; The positions of the read taps
	add 	#ReflectionsInputDelayList-StaticWorkspaceBase,a ; are stored in 
	move	a,r2						; 'ReflectionsInputDelayList'


	;move	rD,a						; Delays are relative to the
	;add 	#DMA_ControlBlock_Wr0-StaticWorkspaceBase,a	; main delay buffer write block
	add 	#DMA_ControlBlock_Wr0-ReflectionsInputDelayList,a
	move	a,r0						 

	;move	rD,a						; We are updating the 5 read
	;add	#DMA_ControlBlock_Rd0-StaticWorkspaceBase,a	; blocks beginning with
	add    	#DMA_ControlBlock_Rd0-DMA_ControlBlock_Wr0,a
	move	a,r1						; 'DMA_ControlBlock_Rd0'
	
	move	#0,y0						; Reflection delays are absolute

	move	#>5,y1						; 5 reflections to update
	bsr    	RVB_UpdateDelaysOnMainDelayLine



								; Update the positions of the 8 read taps
								; corresponding to the short reverbs

	move	rD,a							; The positions of the read taps
	add    	#ShortReverbInputDelayList-StaticWorkspaceBase,a	; are spaced according to the
	move	a,r2							; delays in 'ShortReverbInputDelayList'


	move	rD,a							; The delays are relative to the
	add 	#DMA_ControlBlock_Wr0-StaticWorkspaceBase,a		; main delay buffer write block
	;add 	#DMA_ControlBlock_Wr0-ShortReverbInputDelayList,a
	move	a,r0								 

	;move	rD,a							; We are updating the 8 read
	;add		#DMA_ControlBlock_Rd5-StaticWorkspaceBase,a	; blocks beginning with
	add	#DMA_ControlBlock_Rd5-DMA_ControlBlock_Wr0,a
	move	a,r1							; 'DMA_ControlBlock_Rd5'

	
	move	x:(rD+ShortReverbInputDelay-StaticWorkspaceBase),y0	; Short reverb delays are relative
									; to 'ShortReverbInputDelay'

	move	#>8,y1							; 8 short reverb delays to update
	bsr	RVB_UpdateDelaysOnMainDelayLine



									;=================================
									;	Update the reflections feedback delays
									;=================================

	move	rD,a							; The tap positions for the reflections
	add	#ReflectionsDelayList-StaticWorkspaceBase,a		; delay buffers are stored in the block 
	move	a,r2							; starting at 'ReflectionsDelayList'.


	;move	rD,a							; The reflection delays are relative
	;add		#DMA_ControlBlock_Wr4-StaticWorkspaceBase,a	; to DMA_ControlBlock_Wr4,5,6 and 7
	add	#DMA_ControlBlock_Wr4-ReflectionsDelayList,a
	move	a,r0

	;move	rD,a							; Update the read DMA blocks
	;add		#DMA_ControlBlock_Rd21-StaticWorkspaceBase,a	; DMA_ControlBlock_Rd21,22,23 and 24
	add	#DMA_ControlBlock_Rd21-DMA_ControlBlock_Wr4,a
	move	a,r1
	
	
	move	#DMAcbs_SizeofDMAcbs,n0
	move	#DMAcbs_SizeofDMAcbs,n1
	dor	#4,RVB_FillReflectionDelaysLoop
		move	x:(r2)+,x1
		bsr	RVB_UpdateDmaCommandBlockOffset
		move	x:(r0)+n0,x0					; Increment r0
		move	x:(r1)+n1,x0					; Increment r1
RVB_FillReflectionDelaysLoop




									;=================================
									;	Update the long reverb feedback delays
									;=================================

	move	rD,a							; The long reverb delays are relative 
	add	#DMA_ControlBlock_Wr12-StaticWorkspaceBase,a		; to DMA_ControlBlock_Wr12 and 13
	move	a,r0

	;move	rD,a							; Update the read blocks 29 and 30
	;add		#DMA_ControlBlock_Rd29-StaticWorkspaceBase,a
	add	#DMA_ControlBlock_Rd29-DMA_ControlBlock_Wr12,a
	move	a,r1
	
	move	#DMAcbs_SizeofDMAcbs,n0
	move	#DMAcbs_SizeofDMAcbs,n1
	dor	#2,RVB_FillLongReverbDelaysLoop
		move	x:(rD+LongReverbDelay-StaticWorkspaceBase),x1	; Get LongReverb[i] delay (The same for both channels)
		bsr	RVB_UpdateDmaCommandBlockOffset
		move	x:(r0)+n0,x0					; Increment r0 (Ignore result of move)
		move	x:(r1)+n1,x0					; Increment r1 (Ignore result of move)
RVB_FillLongReverbDelaysLoop


	rts




;---------------------------------------------
;	RVB_UpdateDmaCommandBlocksNotProcessedByFader
;---------------------------------------------
;	Update the DMA command blocks that are not processed by the delay tap fader
;
RVB_UpdateDmaCommandBlocksNotProcessedByFader

									;=================================
									;	Update the long reverb delays
									;=================================

									; Update the positions of the 8 read taps
									; corresponding to the long reverbs

	move	rD,a							; The positions of the read taps
	add	#LongReverbInputDelay0a-StaticWorkspaceBase,a		; are defined by the variable block
	move	a,r2							; beginning at 'LongReverbInputDelay0a'


	;move	rD,a							; The delays are relative to the
	;add 	#DMA_ControlBlock_Wr0-StaticWorkspaceBase,a		; main delay buffer write block
	add 	#DMA_ControlBlock_Wr0-LongReverbInputDelay0a,a
	move	a,r0

	;move	rD,a							; We are updating the 8 read
	;add		#DMA_ControlBlock_Rd13-StaticWorkspaceBase,a	; blocks beginning with
	add	#DMA_ControlBlock_Rd13-DMA_ControlBlock_Wr0,a
	move	a,r1							; 'DMA_ControlBlock_Rd13'
	
	move	#DMAcbs_SizeofDMAcbs,n0
	dor	#4,RVB_UpdateLongDelaysLoop
		move	#0,y0						; Delays for the long reverb are absoute

		move	#>2,y1						; 4 lots of 2 long reverb delays to update
		bsr	RVB_UpdateDelaysOnMainDelayLine

		move	x:(r0)+n0,x0					; Point to the next DMA write block
																		; (Ignore result of load)
RVB_UpdateLongDelaysLoop




        ;=================================
        ;	Update the short reverb feedback delays
        ;=================================

	move	rD,a						     	; The short reverb delays are relative
	add	#DMA_ControlBlock_Wr8-StaticWorkspaceBase,a		; to DMA_ControlBlock_Wr8,9,10,11
	move	a,r0

	;move	rD,a						     	; Update the read DMA blocks
	;add		#DMA_ControlBlock_Rd25-StaticWorkspaceBase,a	; DMA_ControlBlock_Rd25,26,27 and 28
	add	#DMA_ControlBlock_Rd25-DMA_ControlBlock_Wr8,a
	move	a,r1
	
	move	rD,a						     	; The delay positions are stored in
	add	#ShortReverbDelayList-StaticWorkspaceBase,a    	        ; the constant array starting at
	;add	#ShortReverbDelayList-DMA_ControlBlock_Rd25,a
	move	a,r2						     	; 'ShortReverbDelayList'

	move	#DMAcbs_SizeofDMAcbs,n0
	move	#DMAcbs_SizeofDMAcbs,n1
	dor	#4,RVB_FillShortReverbDelaysLoop
		move	x:(r2)+,x1				     	; Get Reverb[i] delay
		bsr    	RVB_UpdateDmaCommandBlockOffset
		move	x:(r0)+n0,x0				     	; Increment r0 (Ignore result of move)
		move	x:(r1)+n1,x0				     	; Increment r1 (Ignore result of move)
RVB_FillShortReverbDelaysLoop




	rts




;------------------------------------------------------------
;		RVB_UpdateDelaysOnMainDelayLine
;------------------------------------------------------------
;	On entry
;		r0	Points to the reference write control block
;		r1	Points to first read control block to update
;		r2	Points to a list of relative delays
;		y0	Added to (r2) to give the total relative delay
;		y1	The number of continuous DMA blocks to update
;	On exit
;		a	Undefined
;		b	Undefined
;		n1	Undefined
;		x0	Undefined
;		x1	Undefined
;		r0	Preserved
;		r1	Incremented by x0*DMAcbs_SizeofDMAcbs
;		r2	Incremented by x0
;
;	Given a pointer to the DMA write blocks and an array of
;	delays, update the specified DMA read blocks 
;
RVB_UpdateDelaysOnMainDelayLine

	move	#DMAcbs_SizeofDMAcbs,n1

	dor	y1,RVB_UpdateMainBufferDelaysLoop
		move	x:(r2)+,a				; Get the delay offset corresponding to this buffer.
								; The delay offset is relative to y0

								; Add the relative offset to y0
		add    	y0,a
		move	a,x1					; x1=offset of read pointer relative to the write pointer
								; r0=pointer to the (reference) DMA write block
								; r1=pointer to the DMA read block to be updated
		bsr    	RVB_UpdateDmaCommandBlockOffset

		move	x:(r1)+n1,x0			        ; Increment r1 to point to the 
								; next read pointer
RVB_UpdateMainBufferDelaysLoop
	rts




;---------------------------------------------
;		RVB_UpdateDmaCommandBlockOffset
;---------------------------------------------
;	On entry
;		r0 	Points to base of a DMA block write pointer
;		r1 	Points to base of the DMA block read pointer to be modified
;		x1 	The delay of the new cyclic buffer (measured in samples).
;			This is actually the position of the read pointer relative 
;			to the appropriate write pointer.
;			Delays should all be positive and smaller than the size of
;			the buffer.
;		rD	Pointer to reverb engine workspace
;
;	On exit
;		r0	Preserved
;		r1	Preserved
;		x0	Undefined
;		b	Undefined
;		The DMA command block pointed to by R1 has been updated.
;
RVB_UpdateDmaCommandBlockOffset

	move	x:(r0+DMAcbs_smOffset),b			; Get the reverb write index
	
	sub	x1,b						; Calculate position of read index
	and	#$FFFFF0,b					; Make sure that the index is a multiple of 4*4=16
RVB_CheckAddressInRange
	cmp	#0,b						; If the new read index is -ve then
	bge	RVB_AddressInRange				; add the length of the buffer
	move	x:(r0+DMAcbs_smSizeMinus1),x0			; to the index.  This will ensure
	add	x0,b						; that is within the correct range
	add	#1,b
	bra RVB_CheckAddressInRange
RVB_AddressInRange
	move	b,x:(r1+DMAcbs_smOffset)			; Store the new read offset
	rts




RVB_EndOfFile
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\xtalk.asm ===
;	File	:	XTalk.asm
;	Version	:	1.01
;	Date	:	8/9/2000
;
;	Author	:	RDA
;       Modified/optimized by georgioc so single xtalk can do 4in->4out
;
;
; Description
; ===========
;	This file implements cross-talk cancellation functionality on
;	a Motorola 56362 processor.
;
;	This source file requires definitions from source "XTC.inc" to work 
;	correctly.  The file should usually be included the calling function
;	that controls the cross talk operation.
;
;	No data is allocated in the cross-talk canceller. On entry to
;	each function R5 contains a pointer to the approproate data block.
;	No registers are explicitely stacked in the code, however
;	subroutine calls and loop instructions will use the hardware 
;	stack.
;
;	Since no registers are preserved in the functions in this module,
;	the exit conditions for each function lists the registers that
;	are used (i.e. corrupted).  It is up to the caller to preserve
;	registers as necessary.
;
; Version History
; ===============
;	Version 1.0
;		Functional, but not optimised.
;
;	Version 1.01
;		Modified to use R5 instead of R0 as the workspace pointer

	org	p:

;###########################################################
;	The file "xtalk.inc" must either be included here or
;	before this point
;###########################################################
;	include 'xtalk.inc'


        IF @DEF('STANDALONE')
        include "util.h"
        ENDIF

	include 'xtc.inc'

;===================================
; 	CTC_Initialise
;===================================
;
; On Entry
;	r5=Pointer to crosstalk canceller data structure
;
; On Exit
;	x0	Corrupted
;	r0	Corrupted	n0	Corrupted	m0	-1
;
;	Initialise the system.
;		- Set up the default parameters
;		- Clear the delay buffers and IIR buffer
;

StartCTC

        FXEntryPoint

        IF @DEF('FX_TEST')

        ; setup I/O ptrs

        move    #>kMixBuf00,x0     
        move    #>kMixBuf01,y0
        move    x0,x:(rD+FX_STATE_IO4_IN0)
        move    y0,x:(rD+FX_STATE_IO4_IN1)

        move    #>kMixBuf04,x0     
        move    #>kMixBuf05,y0
        move    x0,x:(rD+FX_STATE_IO4_IN2)
        move    y0,x:(rD+FX_STATE_IO4_IN3)

        move    #>kReadWriteMixBuf00,x0     
        move    #>kReadWriteMixBuf01,y0
        move    #>kReadWriteMixBuf04,x1     
        move    #>kReadWriteMixBuf05,y1

        move    x0,x:(rD+FX_STATE_IO4_OUT0)
        move    y0,x:(rD+FX_STATE_IO4_OUT1)
        move    x1,x:(rD+FX_STATE_IO4_OUT2)
        move    y1,x:(rD+FX_STATE_IO4_OUT3)

        ENDIF

CTC_Initialise
	move	#CTC_COEFF_A1_DEFAULT,x0
	move	x0,x:(r5+CTC_Coeff_A1)

	move	#CTC_COEFF_B0_DEFAULT,x0
	move	x0,x:(r5+CTC_Coeff_B0)

ComputeFX

	move	#$ffffff,m1				      		; Set the linear addressing modes
	move	m1,m2					      		; for all the address registers
        move    m1,m0
	move	m1,m3
	move	m1,m4
	move	m1,m5

        bset    #20,sr
        ; process front left,right

        bsr     CTC_ProcessFrameFront

        ; Store the updated index to the delay buffers
	move	n3,x:(r5+CTC_FrontDelayBufferIndex)	     

        ; process rear left,right
        
        bsr     CTC_ProcessFrameRear
        
        bclr    #20,sr
        ; Store the updated index to the delay buffers
	move	n3,x:(r5+CTC_RearDelayBufferIndex)	     

        FXExit	

;===================================
; 	CTC_ProcessFrame
;===================================
;
; On entry
;	r5=Pointer to crosstalk canceller data structure
;
;	Data in the input frames should be aligned in the LSB of the words.
;
; On exit
;	Data in buffers input pointed to by r1 and r2 on entry are updated 
;	to contain processed data.
;
;	a	Corrupted
;	b	Corrupted
;	x	Corrupted
;	y	Corrupted
;

;	r1	Corrupted	n1	Corrupted	m1	-1
;	r2	Corrupted	n2	Corrupted	m2	-1
;	r3	Corrupted	n3	Corrupted	m3	-1
;	r4	Corrupted	n4	Corrupted	m4	-1
;									m5  -1


CTC_ProcessFrameFront

        ; r1=Pointer to 32 word left channel input sample frame
        ; r2=Pointer to 32 word right channel input sample frame
        ; r6=Pointer to 32 word left channel output sample frame
        ; r7=Pointer to 32 word right channel output sample frame

        move    x:(r5+FX_STATE_IO4_IN0),r1
        move    x:(r5+FX_STATE_IO4_IN1),r2
        move    x:(r5+FX_STATE_IO4_OUT0),r6
        move    x:(r5+FX_STATE_IO4_OUT1),r7

	move	r5,a
	add	#CTC_FrontDelayBuffer_Left,a
	move	a,r3
													; Initialise the pointer to the left delay buffer
	move	r5,a
	add	#CTC_FrontDelayBuffer_Right,a
	move	a,r4
													; Initialise the indices into the delay buffers
	move	x:(r5+CTC_FrontDelayBufferIndex),n3
	move	n3,n4

        lua     (r5+CTC_IIR_FrontDelayElement_Left),r0

        bra     CTC_Compute

CTC_ProcessFrameRear
        move    x:(r5+FX_STATE_IO4_IN2),r1
        move    x:(r5+FX_STATE_IO4_IN3),r2
        move    x:(r5+FX_STATE_IO4_OUT2),r6
        move    x:(r5+FX_STATE_IO4_OUT3),r7

	move	r5,a
	add	#CTC_RearDelayBuffer_Left,a
	move	a,r3
													; Initialise the pointer to the left delay buffer
	move	r5,a
	add	#CTC_RearDelayBuffer_Right,a
	move	a,r4
													; Initialise the indices into the delay buffers
	move	x:(r5+CTC_RearDelayBufferIndex),n3
	move	n3,n4

        lua     (r5+CTC_IIR_RearDelayElement_Left),r0

CTC_Compute

	; Initialise the pointer to the left delay buffer
       	; r5 = Pointer to base of crosstalk data structure
       	; r1 = Input sample buffer Left
       	; r2 = Input sample buffer Right
       	; r3 = Pointer to base of left delay buffer structure
       	; r4 = Pointer to base of right delay buffer structure

	move	x:(r5+CTC_Coeff_B0),y1			       	; y1 = Coefficient B0

	dor	#kFrameLength,CTC_LoopEnd		       	; Process the 32 samples in the two input frames

          	move	x:(r5+CTC_Coeff_A1),y0			       	; y0 = Coefficient A1

        	;-------------------------------
        	;	Implement the IIR filters
        	;-------------------------------								

		move 	x:(r0),x0	                        ; x0 = IIR delay element left

		mpy	x0,y0,b					; b  = A1*IIRleft
	
		move	x:(r3+n3),x1				; x1 = Output of left delay buffer
		mac	x1,y1,b					; b  = DelayedSampleLeft*B0 + A1*IIRleft

		move	b,x:(r0)	                        ; Store output of IIR filter in its delay element
	
		
		move 	x:(r0+CTC_DELAYBUFFER_SIZE+1),x0        ; x0 = IIR delay element right
		mpy	x0,y0,a			  		; a  = A1*IIRleft
	
		move	x:(r4+n4),x1		  		; x1 = Output of right delay buffer
		mac	x1,y1,a			  		; a  = DelayedSampleRight*B0 + A1*IIRright

		move	a,x:(r0+CTC_DELAYBUFFER_SIZE+1)	        ; Store output of IIR filter in its delay element


        	;-------------------------------
        	;	Combine output of IIR 
        	;	filters with input data
        	;-------------------------------
			
		move	x:(r1)+,x0				; Get input sample from left channel
		move	x:(r2)+,x1				; Get input sample from right channel

		add	x0,a					; Add to the output from the right IIR filter
		add	x1,b					; Add to the output of the left IIR filter

		move	a,x:(r3+n3)				; Store result in left delay buffer
		move	b,x:(r4+n4)				; Store result in right delay buffer

                ;
                ; check if we are supposed to be enabled. if not, just copy input->output
                ;

                move    x:(rD+FX_STATE_FLAGS),y0   
                brset   #BIT_FX_STATE_FLAG_GLOBAL_FX,y0,CTC_UpdateOutput

                ; xtalk is disabled, replace xtalk data with input samples

                clr     a
                clr     b
                move    x0,a
                move    x1,b

CTC_UpdateOutput

                ;
                ; combine crosstalk output with existing output mixbin data
                ;

                move    x:(r6),x0
                move    x:(r7),x1

                add     x0,a
                add     x1,b


		move	a,x:(r6)+				; Store result in left output buffer
		move	b,x:(r7)+				; Store result in right output buffer


        	;-------------------------------
        	;	Increment cyclic sample 
        	;	delay buffer index
        	;-------------------------------

		move	n3,a
		add	#1,a
		cmp	#CTC_DELAYBUFFER_SIZE,a
		blt	CTC_IndexUpdated
		clr	a
CTC_IndexUpdated
		move	a,n3
		move	a,n4

CTC_LoopEnd	
        nop
	rts

FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\AmpMod.h ===
; **************************************************************************
;
; AmpMod.h    
;
; **************************************************************************        

; Low Level Data

    IF @DEF('STEREO')

DATASIZE_AMPMOD	equ	(DATASIZE_DSP_FX_STATE_3IN_2OUT)	

    ELSE

DATASIZE_AMPMOD	equ	(DATASIZE_DSP_FX_STATE_2IN_1OUT)	

    ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Chorus.h ===
; **************************************************************************
;
; Chorus.h    
;
; **************************************************************************        

;
; delay line in Ymem
;

FX_DELAY_LENGTH         equ FX_STATE_YMEM_LENGTH
FX_DELAY_BASE           equ FX_STATE_YMEM_BASE


    IF @DEF('STEREO')
FX_OFFSET 	        set	(DATASIZE_DSP_FX_STATE_3IN_2OUT)
    ELSE
FX_OFFSET 	        set	(DATASIZE_DSP_FX_STATE_2IN_1OUT)
    ENDIF

CHORUS_GAIN			set FX_OFFSET
FX_OFFSET           set FX_OFFSET+1

CHORUS_MOD_SCALE_H	set FX_OFFSET
FX_OFFSET           set FX_OFFSET+1

FX_DELAY_INDEX      set FX_OFFSET
FX_OFFSET           set FX_OFFSET+1

FX_DELAY_END		set FX_OFFSET
FX_OFFSET           set FX_OFFSET+1

FX_INPUT0           set FX_OFFSET
FX_OFFSET           set FX_OFFSET+1

FX_INPUT1           set FX_OFFSET
FX_OFFSET           set FX_OFFSET+1

FX_OUTPUT0          set FX_OFFSET
FX_OFFSET           set FX_OFFSET+1

DATASIZE_CHORUS	    set FX_OFFSET

    IF @DEF('STEREO')
CHORUS_RIGHTCHANNEL_OFFSET equ DATASIZE_CHORUS+1
    ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\fx\rvbfader.asm ===
;	File	:	Reverb.asm
;	Version	:	1.01
;	Date	:	18/09/2000
;
;	Author	:	RDA
;				Sensaura (c)
;
;
; Description
; ===========
; The fader for the reverb engine.
;
; The fader for the reverb engine provides a gradual change in reverb 
; parameters settings to avoid audible clicks.  It does this by changing
; the positions of the delay taps one-by-one.  To further smooth the 
; transition, the buffer corresponding the the delay tap that is being
; repositioned is faded to zero then back to one over a total of 512
; samples.  When the buffer is faded to zero it is moved.  Fading
;
; The amplitudes of the output buffers are also faded from current values
; to target values
;
; Buffers that are
; Version history
; ===============
;	0.00		Development version
;	1.00		First working version
;	1.01		Guarantees that the maximum amplitude swing can be
;				achieved exactly.		
;


;
;	This file implements addition functionality to the reverb engine
;	giving it the ability to fade between new parameters sets.
;	
;	The variable 'FADER_ENABLED' (which can be found in 'reverb.asm')
;	can be set to zero to prevent the fader from being compiled into 
;	the project.  'FADER_ENABLED' should be set to 1 to enable the
;	fader.
;
;
;	The following buffers are faded:
;		The five reflections buffers reading from the main delay line
;		The eight short reveb buffer reading from the main delay line
;		The four reflection feedback buffers
;		The two long reveb buffer feedback buffers



	msg		'Reverb fader enabled'



;=========================================
;	Buffer Muting Constants
;=========================================

;	There are a total of 21 taps that are repositioned with the
;	fader. At the full sample rate each one takes a total of 
;	(256+256)=512 samples.  This means that it takes a total of 
;	512*21/48000=0.224 seconds to change between parameters sets.
;
;
;	'FADER_BUFFERMUTEDURATION' controls the number of samples over which
;	buffers are faded in and out while their delay taps are being 
;	repositioned
;	'FADER_STEPSIZE_FADEOUT' controls the size of the amplitude steps
;	for these buffers are they are being muted

	IF @DEF('HALFSAMPLERATE')
FADER_BUFFERMUTEDURATION	equ	128		;	Amplitudes are faded out over 128 samples
;FADER_BUFFERMUTEDURATION	equ	512		;	Amplitudes are faded out over 512 samples
	ELSE
FADER_BUFFERMUTEDURATION	equ	256		;	Amplitudes are faded out over 256 samples
;FADER_BUFFERMUTEDURATION	equ	1024	;	Amplitudes are faded out over 1024 samples
	ENDIF

FADER_STEPSIZE_FADEIN		equ 1.0/FADER_BUFFERMUTEDURATION
FADER_STEPSIZE_FADEOUT		equ -1.0/FADER_BUFFERMUTEDURATION



;=========================================
;	Output Amplitude Control Constants
;=========================================


; Amplitudes are faded by applying what is in essence an IIR filter to the amplitude
; value.  It causes the current amplitude to fade towards the targe amplitude
; exponentially.

; The system fades from one parameter set to another in 21*512 samples.
; The amplitude fader alters the amplitudes on a frame-by-frame basis. The
; amplitude fader therefore has
;		(21*512)/32 = 336 frames @ full sample rate and
;		(21*256)/16 = 336 frames @ half sample rate
; to fade the amplitude.
; 
; After this number of frames have been processed the output amplitude
; is set equal to the target amplitude in a final step.  In order to not
; perceive this final step, the output amplitude must be able to decay
; from 2^23 down to 512 over 336 frames.  This criterion defined the
; value of the decay rate for the output amplitude fader
; 
;		FaderAmplitudeDecayRate=1 - 1/#Frames * ln( 512/2^23 )
;		                       =1 - 1/336*ln(2^-14)

FaderAmplitudeDecayRate		equ 0.971
;FaderAmplitudeDecayRate		equ 0.993






	org	p:




;==============================
;		RVB_Fader_Initialise
;==============================
;	On entry
;		r5	Pointer to reverb engine workspace
;
;	On exit
;
;	Variables associated with the fader have been initialise
;
RVB_Fader_Initialise
	bsr		RVB_Fader_StopFading
	rts



;==============================
;		RVB_Fader_StartFading
;==============================
;	On entry
;		r5	Pointer to reverb engine workspace
;
;	On exit
;		a	Undefined
;
;	Begin the processing of fading from one set of delay taps to another
;
RVB_Fader_StartFading
	move	#0,a												; Initialise the amplitude fader
	move	a,x:(r5+RVB_FaderAmplitudeState-StaticWorkspaceBase)

																; Start the fading process at the 
	move	a,x:(r5+RVB_FaderStep-StaticWorkspaceBase)			; beginning of a buffer

	move	#>1,a												; Enable fading and begin fading
	move	a,x:(r5+RVB_FaderState-StaticWorkspaceBase)			; buffer 0


	rts



;==============================
;		RVB_Fader_StopFading
;==============================
;	On entry
;		r5	Pointer to reverb engine workspace
;
;	On exit
;		a	Undefined
;
;	Stop fading.
; This will stop the fader immediately.  Any buffer that is in the process
; of being faded will revert to full volume with whatever tap position is
; currently defined. (This may be the original or the final depending on when
; the function is called.)

RVB_Fader_StopFading
	move	#-1,a												; Disable the amplitude fader
	move	a,x:(r5+RVB_FaderAmplitudeState-StaticWorkspaceBase)

	move	#0,a												; Start the fading process at the 
	move	a,x:(r5+RVB_FaderStep-StaticWorkspaceBase)			; beginning of a buffer

	move	a,x:(r5+RVB_FaderState-StaticWorkspaceBase)			; Disable fading

	rts





;==============================
;		RVB_Fader_Process
;==============================
;	On entry
;		r5	Pointer to reverb engine workspace
;
;	On exit
;		a	Undefined
;		b	Undefined
;		x	Undefined
;		y	Undefined
;		r0	Undefined
;		r1	Undefined
;		r5	Preserved
;
;	This function should be called every frame immediately after the DMA controller
;	has filled the reverb's frame buffers.  If the fader not active, it exits
;	immediately.
;
RVB_Fader_Process

	IF FADER_ENABLE_OUTPUTAMPITUDEFADE

	msg		"Performing output amplitude fading"
	bsr		RVB_Fader_FadeOutputAmplitudes						; Fade the output amplitude between
																; the current values and the new
																; values
	ENDIF

	IF FADER_ENABLE_DELAYTAPFADE

	msg		"Performing delay tap fading"
	bsr		RVB_Fader_FadeDelayTaps								; Shuffle the delay tap positions
																; after ramping down the corresponsing
																; amplitude buffer
	ENDIF

	rts



RVB_Fader_FadeDelayTaps
																;===============================
																; Check to see if the fader
																; is active
																;===============================
	move	x:(r5+RVB_FaderState-StaticWorkspaceBase),a
	cmp		#0,a
	beq		RVB_Fader_Exit										; If inactive then exit


	


																;===============================
																; Check to see if the fader is
																; in a 'special' state
																;===============================
	move	x:(r5+RVB_FaderStep-StaticWorkspaceBase),a
	cmp		#0,a												; Check to see if we are starting
	beq		RVB_Fader_FadeNewBuffer								; to fade a new buffer
	
	cmp		#FADER_BUFFERMUTEDURATION,a												; Check to see if we are ready
	beq		RVB_Fader_MoveDelayTap								; to move the delay tap

	cmp		#2*FADER_BUFFERMUTEDURATION,a						; Check to see if we have finished
	beq		RVB_Fader_FinishedFading							; fading this buffer





RVB_Fader_FadeFrame
																;=========================================
																; Apply linear fade to the current buffer
																;=========================================
	move	x:(r5+RVB_FaderpDMAread-StaticWorkspaceBase),r0		; Get a pointer to the 
	move	x:(r0+DMAcbs_pDspStart),r0							; buffer we are fading

	move	x:(r5+RVB_FaderGain-StaticWorkspaceBase),b			; Get the current gain value
	move	x:(r5+RVB_FaderStepSize-StaticWorkspaceBase),y0		; Get the size of each step in the gain

	dor		#SizeOfFrame,RVB_Fader_LinearScaleFrameLoop
		move	b,x1											; 
		move	x:(r0),x0										; Get a data sample
		mpy		x0,x1,a											; Scale the sample by the gain
		move	a,x:(r0)+										; Store the result
		
		add		y0,b											; Update the gain
RVB_Fader_LinearScaleFrameLoop

	move	b,x:(r5+RVB_FaderGain-StaticWorkspaceBase)			; Store the last gain value

	move	x:(r5+RVB_FaderStep-StaticWorkspaceBase),a
	add		#SizeOfFrame,a
	move	a,x:(r5+RVB_FaderStep-StaticWorkspaceBase)
	
	

RVB_Fader_Exit
	rts





;===============================
; RVB_Fader_FadeNewBuffer
;===============================
;	We are about to begin fading a new buffer. Configure the fader
;	parameters accordingly
RVB_Fader_FadeNewBuffer

	move	x:(r5+RVB_FaderState-StaticWorkspaceBase),x0
	brset	#0,x0,RVB_Fader_ConfigureReflections				; Process the first reflections buffer
																; (There are 5 reflection buffers)

	brset	#5,x0,RVB_Fader_ConfigureShortReverb				; Process the first short reveb buffer
																; (There are 8 short reverb buffers)

	brset	#13,x0,RVB_Fader_ConfigureReflectionDelayLines		; Process the first reflection feedback buffers
																; (There are 4 reflection feedback buffers)

	brset	#17,x0,RVB_Fader_ConfigureLongReverbfeedback		; Process the first long reveb buffer
																; (There are 2 long reverb feedback buffers)

	brset	#19,x0,RVB_Fader_DoneAllBuffers						; The fader has repositioned all the delay taps


																; Update the pointer to the
																; DMA read control block
	move	x:(r5+RVB_FaderpDMAread-StaticWorkspaceBase),a
	add		#DMAcbs_SizeofDMAcbs,a
	move	a,x:(r5+RVB_FaderpDMAread-StaticWorkspaceBase)

																; Update the pointer to the DMA
																; write block
	move	x:(r5+RVB_FaderpDMAwrite-StaticWorkspaceBase),a
	move	x:(r5+RVB_FaderDMAwriteIncrement-StaticWorkspaceBase),x0
	add		x0,a
	move	a,x:(r5+RVB_FaderpDMAwrite-StaticWorkspaceBase)
	
	bra		RVB_Fader_Configure




;--------------------------------------------
;	Configure the fader for reflections taps
;--------------------------------------------
;	Initialise the following
;		1. A pointer to the read DMA block
;		2. A pointer to the write DMA block
;		3. The list of new delay tap positions measured 
;			relative to the write DMA block
RVB_Fader_ConfigureReflections
	move	r5,a												; Set the fader tap list pointer
	add		#ReflectionsInputDelayList-StaticWorkspaceBase,a	; equal to the updated list
																; of reflection delay tap positions
	move	a,x:(r5+RVB_FaderpNewTapList-StaticWorkspaceBase)	;


	;move	r5,a												; The DMA write block from which delays
	;add 	#DMA_ControlBlock_Wr0-StaticWorkspaceBase,a			; are measured is 'DMA_ControlBlock_Wr0'
	add		#DMA_ControlBlock_Wr0-ReflectionsInputDelayList,a
	move	a,x:(r5+RVB_FaderpDMAwrite-StaticWorkspaceBase)		; 

	;move	r5,a												; The first DMA read block to process
	;add 	#DMA_ControlBlock_Rd0-StaticWorkspaceBase,a			; for the first reflection is 'DMA_ControlBlock_Rd0'
	add		#DMA_ControlBlock_Rd0-DMA_ControlBlock_Wr0,a
	move	a,x:(r5+RVB_FaderpDMAread-StaticWorkspaceBase)		; 


	bra		RVB_Fader_Configure_SetDMAWriteIncrementZero



;--------------------------------------------
;	Configure the fader for short reverb taps
;--------------------------------------------

;	Initialise the following
;		1. A pointer to the read DMA block
;		2. A pointer to the write DMA block
;		3. The list of new delay tap positions measured 
;			relative to the write DMA block
RVB_Fader_ConfigureShortReverb
	move	r5,a												; The DMA write block from which 
	add		#DMA_ControlBlock_Wr0-StaticWorkspaceBase,a			; delay are measured
	move	a,x:(r5+RVB_FaderpDMAwrite-StaticWorkspaceBase)		; is 'DMA_ControlBlock_Wr0'


	;move	r5,a												; The first DMA read block to process
	;add	#DMA_ControlBlock_Rd5-StaticWorkspaceBase,a			; for the first short reverb is 'DMA_ControlBlock_Rd5'
	add		#DMA_ControlBlock_Rd5-DMA_ControlBlock_Wr0,a
	move	a,x:(r5+RVB_FaderpDMAread-StaticWorkspaceBase)		; 


	
	
	;move	r5,a												; Get the address of the list of
	;add	#ShortReverbInputDelayList-StaticWorkspaceBase,a	; input reverb tap offsets
	add		#ShortReverbInputDelayList-DMA_ControlBlock_Rd5,a
	move	a,r0												; (all measured wrt 'ShortReverbInputDelay')

	move	x:(r5+ShortReverbInputDelay-StaticWorkspaceBase),x0	; Read the 'ShortReverbInputDelay'


	;move	r5,a												; Get a pointer to the start of a
	;add	#RVB_FaderNewTapList-StaticWorkspaceBase,a			; block that we will fill with the
																; positions of the new delay taps
	add		#RVB_FaderNewTapList-ShortReverbInputDelayList,a
	move	a,r1												; 
	move	a,x:(r5+RVB_FaderpNewTapList-StaticWorkspaceBase)	; Store a pointer to that block.


	dor		#8,RVB_Fader_ConfigureShortReverbLoop				; Fill the block with the new tap positions
		move	x:(r0)+,a
		add		x0,a
		move	a,x:(r1)+
RVB_Fader_ConfigureShortReverbLoop

																; Perform the common configuration
																; functions for a reverb tap.
	bra		RVB_Fader_Configure_SetDMAWriteIncrementZero


;--------------------------------------------
;	Configure the fader for long reverb feedback taps
;--------------------------------------------
RVB_Fader_ConfigureLongReverbfeedback
	move	r5,a												; The DMA write block from which 
	add		#DMA_ControlBlock_Wr12-StaticWorkspaceBase,a			; delay are measured
	move	a,x:(r5+RVB_FaderpDMAwrite-StaticWorkspaceBase)		; is 'DMA_ControlBlock_Wr12'


	;move	r5,a												; The first DMA read block to process 
	;add 	#DMA_ControlBlock_Rd29-StaticWorkspaceBase,a		; for the reflection is 'DMA_ControlBlock_Rd29'
	add 	#DMA_ControlBlock_Rd29-DMA_ControlBlock_Wr12,a
	move	a,x:(r5+RVB_FaderpDMAread-StaticWorkspaceBase)


	;move	r5,a												; Get the address of the list of
	;add 	#RVB_FaderNewTapList-StaticWorkspaceBase,a			; input reverb tap offsets
	add 	#RVB_FaderNewTapList-DMA_ControlBlock_Rd29,a
	move	a,r0

	move	a,x:(r5+RVB_FaderpNewTapList-StaticWorkspaceBase)	; Store a pointer to that block.

	move	x:(r5+LongReverbDelay-StaticWorkspaceBase),a		; All the delay times are the same,
	move	a,x:(r0)+											; so fill the buffer with the 
	move	a,x:(r0) 											; value of 'LongReverbDelay'

																; The delays for the late reverb
																; refer to DMA_ControlBlock_Wr5,6,7,8
	move	#>DMAcbs_SizeofDMAcbs,a
																; Perform the common configuration
	bra		RVB_Fader_Configure_SetDMAWriteIncrement			; functions for a reverb tap.	
	



;--------------------------------------------
;	Configure the fader for reflection delay taps
;--------------------------------------------

;	Initialise the following
;		1. A pointer to the read DMA block
;		2. A pointer to the write DMA block
;		3. The list of new delay tap positions measured 
;			relative to the write DMA block
RVB_Fader_ConfigureReflectionDelayLines
	move	r5,a												; Get the address of the list of
	add 	#ReflectionsDelayList-StaticWorkspaceBase,a			; reflection tap offsets
	move	a,x:(r5+RVB_FaderpNewTapList-StaticWorkspaceBase)	; Store a pointer to that block.


	;move	r5,a												; The DMA write block from which delay
	;add 	#DMA_ControlBlock_Wr4-StaticWorkspaceBase,a			; are measured is 'DMA_ControlBlock_Wr4'
	add		#DMA_ControlBlock_Wr4-ReflectionsDelayList,a
	move	a,x:(r5+RVB_FaderpDMAwrite-StaticWorkspaceBase)		; 


	;move	r5,a												; The first DMA read block to process
	;add 	#DMA_ControlBlock_Rd21-StaticWorkspaceBase,a		; for the reflection is 'DMA_ControlBlock_Rd21'
	add 	#DMA_ControlBlock_Rd21-DMA_ControlBlock_Wr4,a
	move	a,x:(r5+RVB_FaderpDMAread-StaticWorkspaceBase)		; 
	
	

																; The delays for the late reverb
																; refer to DMA_ControlBlock_Wr5,6,7,8
	move	#>DMAcbs_SizeofDMAcbs,a
																; Perform the common configuration
	bra		RVB_Fader_Configure_SetDMAWriteIncrement			; functions for a reverb tap.
	
	
	
	



;--------------------------------------------
;	Common configuration for all taps
;--------------------------------------------
;----------------------------
;	RVB_Fader_Configure_SetDMAWriteIncrementZero
;----------------------------	
; On entry
;	No entry parameters
;
RVB_Fader_Configure_SetDMAWriteIncrementZero
	clr		a													; Set the increment for the 
																; pointer to the DMA write
																; control block to zero. 
;----------------------------
;	RVB_Fader_Configure_SetDMAWriteIncrement
;----------------------------	
; On entry
;	'a' contains the increment that should be applied 
;	to the pointer to the DMA write control block
RVB_Fader_Configure_SetDMAWriteIncrement
																; Store the increment that is
																; applied to the pointer to the
																; DMA write control block. This
																; is applied after each buffer
																; has finished fading.
	move	a,x:(r5+RVB_FaderDMAwriteIncrement-StaticWorkspaceBase)

;----------------------------
;	RVB_Fader_Configure
;----------------------------
; On entry
;	No entry parameters
;
RVB_Fader_Configure
	move	#>FADER_STEPSIZE_FADEOUT,a							; Begin by fading the amplitude
	move	a,x:(r5+RVB_FaderStepSize-StaticWorkspaceBase)		; downwards
	
	move	#1.0-FADER_STEPSIZE_FADEIN,a						; Set the initial amplitude
	move	a,x:(r5+RVB_FaderGain-StaticWorkspaceBase)			; to 1 - 1/256

	bra		RVB_Fader_FadeFrame






;	Move the tap position
;	Set the gain step so that we fade the buffer back in.
RVB_Fader_MoveDelayTap
	
	move	x:(r5+RVB_FaderpNewTapList-StaticWorkspaceBase),r0	; Get a pointer to the tap position
	move	x:(r0)+,a											; Get the new tap position
	move	r0,x:(r5+RVB_FaderpNewTapList-StaticWorkspaceBase)	; Point to the next tap position

	sub		#4*SizeOfFrame,a									; Subtract the size of a frame from the 
																; delay because the reference point (in 
																; the linked list of write blocks) has 
																; already been incremented by the DMA
																; controller.

	cmp		#0,a												; Make sure that the delay is always
	clr		a	Iflt											; positive. (Delays should always
	move	a,x1												; be greater than 32, but there could
																; be problems on startup if we don't
																; check)


	move	x:(r5+RVB_FaderpDMAwrite-StaticWorkspaceBase),r0	; A pointer to the write DMA block
	move	x:(r5+RVB_FaderpDMAread-StaticWorkspaceBase),r1		; A pointer to the read DMA block
	
	bsr		RVB_UpdateDmaCommandBlockOffset


	move	#>FADER_STEPSIZE_FADEIN,a							; Begin fading the amplitude
	move	a,x:(r5+RVB_FaderStepSize-StaticWorkspaceBase)		; upwards


	bra		RVB_Fader_FadeFrame






RVB_Fader_DoneAllBuffers
	bsr		RVB_Fader_StopFading
	;bra		RVB_Fader_FinishedFading                        ;Optimized-- Uncomment if code added before RVB_Fader_FinishedFading



; Finished fading a frame
;	- Prepare for the next frame...
RVB_Fader_FinishedFading
	move	#0,a												; Reset the fader to begin at the
	move	a,x:(r5+RVB_FaderStep-StaticWorkspaceBase)			; start of a fade-out sequence

	
	move	x:(r5+RVB_FaderState-StaticWorkspaceBase),a			; Update the state of the fader to
	asl		a													; process the next buffer
	move	a,x:(r5+RVB_FaderState-StaticWorkspaceBase)

	bra		RVB_Fader_Exit















        IF FADER_ENABLE_OUTPUTAMPITUDEFADE


;=========================================
;		RVB_Fader_FadeOutputAmplitudes
;=========================================
; The amplitudes are faded from their current values to the target value.
;	The size of the amplitude step for each channel is
;		0.02 * (TargetAmplitude - CurrentAmplitude)
;
; After the amplitude fader has processed the prescribed number of frames
; the output amplitudes are set equal to the 'TargetAmplitude' in a single 
; step.
; 
RVB_Fader_FadeOutputAmplitudes

													; Check to see if the amplitude fader is active
	move	x:(r5+RVB_FaderAmplitudeState-StaticWorkspaceBase),a
	cmp		#0,a
	blt		RVB_Fader_FadeOutputAmplitudeExit		; If not then exit
													

													; The amplitude fader is active

	move	r5,b									; Get a pointer to the target output amplitudes
	add		#(NewReflectionOutputGain_Channel0-StaticWorkspaceBase),b
	move	b,r0

	;move	r5,b									; Get a pointer to the current output amplitudes
	;add		#(ReflectionOutputGain_Channel0-StaticWorkspaceBase),b
	add		#(ReflectionOutputGain_Channel0-NewReflectionOutputGain_Channel0),b
	move	b,r1


	cmp		#336,a									; If this is the last frame to process
	beq		RVB_Fader_CopyTargetAmplitudes			; set all the current output amplitudes equal 
													; to the target amplitudes.
	

	add		#1,a									; Increment the state of the amplitude fader
	move	a,x:(r5+RVB_FaderAmplitudeState-StaticWorkspaceBase)

; DEBUGGING
;	move x:(r1+3),y0
;	DEBUGGERLOG y0
; ENDOF DEBUGGING

	dor		#6,RVB_Fader_FadeOutputAmplitudesLoop
		move	x:(r1),a							; Read the current output gain
		move	x:(r0)+,b							; Read the target output gain

		sub		b,a									; Calculate the difference 
		
		move	a,y0								; y0=Difference
		mpyi	#FaderAmplitudeDecayRate,y0,a		; a=Difference*0.98
		
		add		a,b									; Update the current amplitude

		move	b,x:(r1)+							; Write the current output gain

RVB_Fader_FadeOutputAmplitudesLoop


RVB_Fader_FadeOutputAmplitudeExit
	rts



RVB_Fader_CopyTargetAmplitudes

	dor		#6,RVB_Fader_CopyTargetAmplitudesLoop
		move	x:(r0)+,x0
		move	x0,x:(r1)+
RVB_Fader_CopyTargetAmplitudesLoop

													; Disable the amplitude fader
	move	#-1,a
	move	a,x:(r5+RVB_FaderAmplitudeState-StaticWorkspaceBase)
	bra		RVB_Fader_FadeOutputAmplitudeExit


        ENDIF ;FADER_ENABLE_OUTPUTAMPITUDEFADE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Compressor.h ===
;**************************************************************************
;
;       COMPRESSOR.h    
;
;**************************************************************************        

FX_DELAY_LENGTH         equ FX_STATE_YMEM_LENGTH
FX_DELAY_BASE           equ FX_STATE_YMEM_BASE

FX_OFFSET          set DATASIZE_DSP_FX_STATE_MONO 

FX_DELAY_INDEX     set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1


FX_DELAY_END       set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1

FX_OUTPUT_INDEX    set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1


DATASIZE_COMPRESSOR	equ	(FX_OFFSET)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Distortion.h ===
;**************************************************************************
;
; Distortion.h    Distortion module
;       
;
;
;**************************************************************************        

; DX8 struct 
; typedef struct _DSFXDistortion
; {
;     FLOAT   fGain;			
;     FLOAT   fOverDrive;
;     FLOAT   fPostEQCenterFrequency;
;     FLOAT   fPostEQQ;
;     FLOAT   fPostEQGain;
;    FLOAT   fPreLowpassCutoff;
; } DSFXDistortion, *LPDSFXDistortion;


FX_DELAY_BASE                   equ FX_STATE_YMEM_BASE

DISTORTION_GAIN					equ	DATASIZE_DSP_FX_STATE_MONO

; Pre filter (DX8 is low pass)
DISTORTION_PREFILTER_H_B0	equ	(DATASIZE_DSP_FX_STATE_MONO+1)
DISTORTION_PREFILTER_H_B1	equ	(DATASIZE_DSP_FX_STATE_MONO+2)
DISTORTION_PREFILTER_H_B2	equ	(DATASIZE_DSP_FX_STATE_MONO+3)
DISTORTION_PREFILTER_H_A1	equ	(DATASIZE_DSP_FX_STATE_MONO+4)
DISTORTION_PREFILTER_H_A2	equ	(DATASIZE_DSP_FX_STATE_MONO+5)

; Post filter (DX8 is parametric equalizer)
DISTORTION_POSTFILTER_H_B0	equ	(DATASIZE_DSP_FX_STATE_MONO+6)
DISTORTION_POSTFILTER_H_B1	equ	(DATASIZE_DSP_FX_STATE_MONO+7)
DISTORTION_POSTFILTER_H_B2	equ	(DATASIZE_DSP_FX_STATE_MONO+8)
DISTORTION_POSTFILTER_H_A1	equ	(DATASIZE_DSP_FX_STATE_MONO+9)
DISTORTION_POSTFILTER_H_A2	equ	(DATASIZE_DSP_FX_STATE_MONO+10)

DISTORTION_TEMP             equ (DATASIZE_DSP_FX_STATE_MONO+11)

DATASIZE_DISTORTION			equ	(1+DISTORTION_TEMP)

;
; the following delay variables are kept in Y RAM
;

DISTORTION_PREFILTER_Z_X1	equ	0
DISTORTION_PREFILTER_Z_X2	equ	1
DISTORTION_PREFILTER_Z_Y1	equ	2
DISTORTION_PREFILTER_Z_Y2	equ	3

DISTORTION_POSTFILTER_Z_X1	equ	4
DISTORTION_POSTFILTER_Z_X2	equ	5
DISTORTION_POSTFILTER_Z_Y1	equ	6
DISTORTION_POSTFILTER_Z_Y2	equ	7

	include 'IIR2_LowPass.h'
	include 'IIR2_BandPass.h'
	include 'IIR2_BandStop.h'
	include 'IIR2_Equalizer.h'
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Equalizer.h ===
;**************************************************************************
;
; Equalizer.h    IIR Tri-Parameter Equalizer module
;       
;		Written by Gints Klimanis
;
;**************************************************************************        

; typedef struct _DSFXParamEq
; {
;     FLOAT   fCenter;
;     FLOAT   fQ;		// was fBandwidth
;     FLOAT   fGain;
; } DSFXParamEq, *LPDSFXParamEq;


; High Level parameters
;DATASIZE_IO1 = 2
EQUALIZER_LENGTH	equ 2

EQUALIZER_FREQUENCY	equ	3
EQUALIZER_Q			equ	4
EQUALIZER_GAINDB	equ	5
EQUALIZER_MODE		equ	6

; Low Level parameters
EQUALIZER_H_B0	equ	7
EQUALIZER_H_B1	equ	8
EQUALIZER_H_B2	equ	9
EQUALIZER_H_A1	equ	10
EQUALIZER_H_A2	equ	11

EQUALIZER_Z_X1	equ	12
EQUALIZER_Z_X2	equ	13
EQUALIZER_Z_Y1	equ	14
EQUALIZER_Z_Y2	equ	15

DATA_SIZE_EQUALIZER	equ	(1+EQUALIZER_Z_Y2)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\delay.h ===
;**************************************************************************
;
;       delay.h    
;
;**************************************************************************        


FXMEM               set DATASIZE_DSP_FX_STATE_MONO

FX_TEMP_BUFFER      set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_READ0      set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_READ1      set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_READ2      set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_READ3      set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_READ4      set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_READ5      set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_READ6      set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE0     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE1     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE2     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE3     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE4     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE5     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE6     set FXMEM
FXMEM               set FXMEM+1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Echo.h ===
;**************************************************************************
;
;       Echo.h    
;
;**************************************************************************        


    IF @DEF('STEREO')
ECHO_GAIN   equ DATASIZE_DSP_FX_STATE_STEREO
    ELSE
ECHO_GAIN	equ	DATASIZE_DSP_FX_STATE_MONO 
    ENDIF

FX_DELAY_BUFFER_IN      equ (ECHO_GAIN+1)
FX_DELAY_BUFFER_OUT     equ (ECHO_GAIN+2)

DMA_NODE_READ0 equ (ECHO_GAIN+3)
DMA_NODE_READ1 equ (ECHO_GAIN+4)
DMA_NODE_READ2 equ (ECHO_GAIN+5)
DMA_NODE_READ3 equ (ECHO_GAIN+6)
DMA_NODE_READ4 equ (ECHO_GAIN+7)
DMA_NODE_READ5 equ (ECHO_GAIN+8)
DMA_NODE_READ6 equ (ECHO_GAIN+9)


DMA_NODE_WRITE0 equ (ECHO_GAIN+10)
DMA_NODE_WRITE1 equ (ECHO_GAIN+11)
DMA_NODE_WRITE2 equ (ECHO_GAIN+12)
DMA_NODE_WRITE3 equ (ECHO_GAIN+13)
DMA_NODE_WRITE4 equ (ECHO_GAIN+14)
DMA_NODE_WRITE5 equ (ECHO_GAIN+15)
DMA_NODE_WRITE6 equ (ECHO_GAIN+16)

FX_INPUT0       equ (ECHO_GAIN+17)
FX_OUTPUT0      equ (ECHO_GAIN+18)

DATASIZE_ECHO	equ	(1+FX_OUTPUT0)

    IF @DEF('STEREO')
ECHO_RIGHTCHANNEL_OFFSET equ DATASIZE_ECHO+1
    ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\fft.h ===
; **************************************************************************
;
; rms.h    
;
; **************************************************************************        


; memory locations and pointers

FX_OFFSET       set     (DATASIZE_DSP_FX_STATE_1IN_1OUT)    

FX_COEFF_TABLE  set  FX_OFFSET
FX_OFFSET       set  FX_OFFSET+1

FX_




DMA_NODE_WRITE0 set FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1
DMA_NODE_WRITE1 set FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1
DMA_NODE_WRITE2 set FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1
DMA_NODE_WRITE3 set FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1
DMA_NODE_WRITE4 set FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1
DMA_NODE_WRITE5 set FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1
DMA_NODE_WRITE6 set FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1


DATASIZE_RMS	    equ  FX_OFFSET	

; constants

RMS_NUM_MIXBINS     equ  6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\DMAUtil.h ===
;*******************************************************************
;
;    DMAUtil.h		DMA header file for Global/Encode Audio Processor   
;
;******************************************************************        

; ==============================================================
;  DMA Engine stuff
; ==============================================================

kDMANode_MaxSize	equ		7	
kDMANode_Size		equ		6	
kDMANode_Size_FIFO	equ		4
kDMANode_Size_DSPnSM	equ		6
kDMANode_EOL		equ		$004000		; Bit 14 = Eol
kDMANode_EOLBit		equ		kDMANode_EOL
kDMANode_EOLMask	equ		$003fff		; Will Clear Eol bit

DMA_CONTROL_REGISTER 		equ $FFFFD6	; Address of DMA control register
kDMA_ActionRequest_None	    	equ 0	; Useless		 
kDMA_ActionRequest_Start    	equ 1		 
kDMA_ActionRequest_Stop    		equ 2		 
kDMA_ActionRequest_Freeze    	equ 3		 
kDMA_ActionRequest_UnFreeze   	equ 4		 
kDMA_ActionRequest_Abort		equ 5
	 
kDMA_FrozenBit		equ		3	
kDMA_RunningBit		equ		4
kDMA_StoppedBit		equ		5

DMA_CONFIGURATION_REGISTER	equ $FFFFD7	; Address of DMA configuration register
kDMA_AutoStartBit		equ		0			; Bit 0
kDMA_AutoRdyBit			equ		1
kDMA_IocRequireClrBit	equ		2
kDMA_EolRequireClrBit	equ		3
kDMA_ErrRequireClrBit	equ		4

kDMASampleFormat_08bits		equ		0
kDMASampleFormat_16bits		equ		1
kDMASampleFormat_24msbits	equ		2
kDMASampleFormat_32bits		equ		3
kDMASampleFormat_24lsbits	equ		6

; Command Node structure for DSP<->System Memory transfers
kDMAWord0_NextCmd	equ	0
kDMAWord1_ControlBits	equ	1
kDMAWord2_Count		equ	2
kDMAWord3_DSPAddress	equ	3
kDMAWord4_SMOffset	equ	4
kDMAWord5_SMBaseOffset	equ	5
kDMAWord6_SMLength	equ	6

DMA_NEXT_BLOCK_CONTROL_REGISTER		equ $FFFFD4 ; Bit 14 eol, Bits 13:0  Head of List Address
												; Alter only in Idle State or frozen bit asserted
DMA_START_BLOCK_CONTROL_REGISTER	equ $FFFFD5	; Bit 14 e0l, Bits 13:0  Head of List Address

; *********** DMA Read/Write Words **************
; 
; dspBaseAddress = $000000 (0)
; blockSize      = $000000 (0)

; ---- Word 0
; eol         = $1 (1) 
; nextCmd     = $000000 (0)

; ---- Word 1
; interleave  = $0 ( 0) (bit    :0)
; rdDspMem    = $0 ( 0) (bit    :1)(DSP Memory <- System Memory)
; IOC         = $0 ( 0) (bit   3:2)
; smPtrWrBk   = $0 ( 0) (bit     4)
; smBufID     = $F (15) (bit   8:5)
; iso         = $0 ( 0) (bit     9)
; smDataFmt   = $6 ( 6) (bit 12:10)
; >>>>> CONTROLBITS = $19E0
; incr        = $1 ( 1) 

; ---- Word 2
; Count1      = $0000 (0)
; Count0      = $0000 (0)

; ---- Word 3
; Nul         = $0 (0)
; PDspStart   = $000000 (0)

; ---- Word 4
; smOffset      = $000000 (0)

; ---- Word 5 (Used in circular buffers)
; smBaseAddress = $000000 (0)

; ---- Word 6 (Used in circular buffers)
; smSizeMinus1  = $000000 (0)

; >>>>>> Only need Words 0..4
;
;  Generated by dmawords.exe

DMA_BASE_READ0	equ	$004000
DMA_BASE_READ1	equ	$0059E0
DMA_BASE_READ1_ISO	equ	$005BE0
DMA_BASE_READ2	equ	$000000
DMA_BASE_READ3	equ	$000000
DMA_BASE_READ4	equ	$000000
DMA_BASE_READ5	equ	$000000

DMA_BASE_WRITE0	equ	DMA_BASE_READ0
DMA_BASE_WRITE1	equ	$0059E2
DMA_BASE_WRITE1_ISO	equ	$005BE2
DMA_BASE_WRITE2	equ	DMA_BASE_READ2
DMA_BASE_WRITE3	equ	DMA_BASE_READ3
DMA_BASE_WRITE4	equ	DMA_BASE_READ4
DMA_BASE_WRITE5	equ	DMA_BASE_READ5

DMA_MULTIPASS_WRITE1 equ $0049E2
 
DMA_NODE_EOL0	equ	$004000
DMA_NODE_EOL1	equ	$000000
DMA_NODE_EOL2	equ	$000000
DMA_NODE_EOL3	equ	$000000
DMA_NODE_EOL4	equ	$000000
DMA_NODE_EOL5	equ	$000000

;
; Control words for ISO circular buffer dma
;

DMA_CIRCULAR_WRITE1_ISO equ $004bD2
DMA_CIRCULAR_READ1_ISO  equ $004bD0


; *********** DMA FIFO Words **************
; ---- Setup to use Output FIFO0
; DMA Word 1  
; interleave  = $1 (Bits    :0)
; rdDspMem    = $1 (Bits    :1)(DSP Memory -> System Memory)
; IOC         = $0 (Bits   3:2)
; smPtrWrBk   = $0 (Bits     4)
; smBufID     = $0 (Bits   8:5)
; iso         = $0 (Bits     9)
; smDataFmt   = $1 (Bits 12:10)()
; incr        = $1 ( 1) (Bits 23:14)

kDMA_FIFOOut0_Word1 equ $080403  ; 0000 1000 0000 0100 0000 0011

; Count0 = 1 channels/block
; Count1 = 32 transfer length

kDMA_FIFOOut0_Word2 equ $000201  ; 

; ---- Setup to use Output FIFO1
; DMA Word 1  
; interleave  = $1 (Bits    :0)
; rdDspMem    = $1 (Bits    :1)(DSP Memory -> System Memory)
; IOC         = $0 (Bits   3:2)
; smPtrWrBk   = $0 (Bits     4)
; smBufID     = $01 (Bits   8:5)(use FIFO 1)
; iso         = $0 (Bits     9)
; smDataFmt   = $1 (Bits 12:10)()
; incr        = $1 ( 1) (Bits 23:14)

kDMA_FIFOOut1_Word1 equ $080423  ; 0000 1000 0000 0100 0010 0011

; Count0 = 1 channels/block
; Count1 = 32 transfer length

kDMA_FIFOOut1_Word2 equ $000201  ; 


kDMA_FIFO_Channels1			equ	$0
kDMA_FIFO_Channels2			equ	$1
kDMA_FIFO_Channels4			equ	$2
kDMA_FIFO_Channels6			equ	$3

kDMA_FIFO_SampleFormat08	equ	$0
kDMA_FIFO_SampleFormat16	equ	$1
kDMA_FIFO_SampleFormat24	equ	$2
kDMA_FIFO_SampleFormat32	equ	$3

; Output FIFO #0  DMA words:  
; 32 stereo samples in 16-bit format. 


; ---- Setup to use Input FIFO
; DMA Word 1  
; interleave  = $0 ( 0) (Bits    :0)
; rdDspMem    = $0 ( 0) (Bits    :1)(DSP Memory <- System Memory)
; IOC         = $0 ( 0) (Bits   3:2)
; smPtrWrBk   = $0 ( 0) (Bits     4)
; smBufID     = $0 ( 0) (Bits   8:5)
; iso         = $0 ( 0) (Bits     9)
; smDataFmt   = $2 ( 2) (Bits 12:10)()
; >>>>> CONTROLBITS = $0800 = binary 0 1000 0000 0000
; incr        = $1 ( 1) (Bits 23:14)

kDMA_InFIFO_Word1   equ $4800
kDMA_InFIFO0_Word1	equ	(kDMA_InFIFO_Word1|$00) ; 0000 0000
kDMA_InFIFO1_Word1	equ	(kDMA_InFIFO_Word1|$20) ; 0010 0000


;************************************************************
; ClearDMAConfigRegister	Clear  register
;************************************************************
ClearDMAConfigRegister macro
      	movep    #>0,x:DMA_CONFIGURATION_REGISTER	
	endm
; ---- end ClearDMAConfigRegister ----



NewDMABlockSimple macro

    dc  0
    dc  0
    dc  0
    dc  0
    dc  0

    endm

NewDMABlock macro

    dc  0
    dc  0
    dc  0
    dc  0
    dc  0
    dc  0
    dc  0

    endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Flange.h ===
; **************************************************************************
;
; Flange.h    
;
; **************************************************************************        

; typedef struct _DSFXFlanger
; {
;     FLOAT       fWetDryMix;
;     FLOAT       fDepth;
;     FLOAT       fDecayTime;	// replaced fFeedback
;     FLOAT       fFrequency;
;     LONG        lWaveform;
;     FLOAT       fDelay;
;     LONG        lPhase;
; } DSFXFlanger, *LPDSFXFlanger;


;
; delay line in Y mem
;

FX_DELAY_LENGTH         equ FX_STATE_YMEM_LENGTH
FX_DELAY_BASE           equ FX_STATE_YMEM_BASE


    IF @DEF('STEREO')
FX_OFFSET       set     (DATASIZE_DSP_FX_STATE_3IN_2OUT)
    ELSE
FX_OFFSET       set     (DATASIZE_DSP_FX_STATE_2IN_1OUT)
    ENDIF

; Low Level Data
FLANGE_FEEDBACK     set  FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1

FLANGE_MOD_SCALE_H	set  FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1

FX_DELAY_INDEX	    set  FX_OFFSET 
FX_OFFSET           set  FX_OFFSET+1

FX_DELAY_END		set  FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1

FX_INPUT0           set  FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1

FX_INPUT1           set  FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1

FX_OUTPUT0          set  FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1


DATASIZE_FLANGE	    equ  FX_OFFSET	

    IF @DEF('STEREO')
FLANGE_RIGHTCHANNEL_OFFSET equ DATASIZE_FLANGE+1
    ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Iir1.h ===
;**************************************************************************
;
;       IIR1.h    1st Order, IIR filter module
;       
;		Written by Gints Klimanis
;
;**************************************************************************        
    

; High Level parameters
;DATASIZE_IO1 = 2
IIR1_LENGTH		equ	2

IIR1_FREQUENCY		equ	3
IIR1_MODE			equ	4

; Low Level Data
IIR1_H_B0	equ		5
IIR1_H_B1	equ		6
IIR1_H_A1	equ		7

IIR1_Z_X1	equ		8
IIR1_Z_Y1	equ		9

DATA_SIZE_IIR1	equ	(1+IIR1_Z_Y1)


iir1_H_LowPass_PassThru_b0    set 1.0       
iir1_H_LowPass_PassThru_b1    set 0.000000       
iir1_H_LowPass_PassThru_a1    set 0.0

;IIR1: fc=125 LowPass h=< 0.0176518 0 -0.982348 >,< 02426A 000000 82426B >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) radius=0.982348 (7DBD95)
iir1_H_LowPass_0125_b0    set 0.017652       ; 02426A
iir1_H_LowPass_0125_b1    set 0.000000       ; 000000
iir1_H_LowPass_0125_a1    set 0.982348       ; 82426B

;IIR1: fc=250 LowPass h=< 0.0349921 0 -0.965008 >,< 047A9E 000000 847A9F >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) radius=0.965008 (7B8561)
iir1_H_LowPass_0250_b0    set 0.034992       ; 047A9E
iir1_H_LowPass_0250_b1    set 0.000000       ; 000000
iir1_H_LowPass_0250_a1    set 0.965008       ; 847A9F

;IIR1: fc=500 LowPass h=< 0.0687597 0 -0.93124 >,< 08CD1E 000000 88CD1E >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) radius=0.93124 (7732E2)
iir1_H_LowPass_0500_b0    set 0.068760       ; 08CD1E
iir1_H_LowPass_0500_b1    set 0.000000       ; 000000
iir1_H_LowPass_0500_a1    set 0.931240       ; 88CD1E

;IIR1: fc=1000 LowPass h=< 0.132792 0 -0.867208 >,< 10FF4F 000000 90FF50 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) radius=0.867208 (6F00B0)
iir1_H_LowPass_1000_b0    set 0.132792       ; 10FF4F
iir1_H_LowPass_1000_b1    set 0.000000       ; 000000
iir1_H_LowPass_1000_a1    set 0.867208       ; 90FF50

;IIR1: fc=2000 LowPass h=< 0.247949 0 -0.752051 >,< 1FBCCE 000000 9FBCCF >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) radius=0.752051 (604331)
iir1_H_LowPass_2000_b0    set 0.247949       ; 1FBCCE
iir1_H_LowPass_2000_b1    set 0.000000       ; 000000
iir1_H_LowPass_2000_a1    set 0.752051       ; 9FBCCF

;IIR1: fc=125 HighPass h=< 0.982348 0 0.0176518 >,< 7DBD95 000000 02426A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) radius=0.982348 (7DBD95)
iir1_H_HighPass_0125_b0    set 0.982348       ; 7DBD95
iir1_H_HighPass_0125_b1    set 0.000000       ; 000000
iir1_H_HighPass_0125_a1    set -0.017652      ; 02426A

;IIR1: fc=250 HighPass h=< 0.965008 0 0.0349921 >,< 7B8561 000000 047A9E >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) radius=0.965008 (7B8561)
iir1_H_HighPass_0250_b0    set 0.965008       ; 7B8561
iir1_H_HighPass_0250_b1    set 0.000000       ; 000000
iir1_H_HighPass_0250_a1    set -0.034992      ; 047A9E

;IIR1: fc=500 HighPass h=< 0.93124 0 0.0687597 >,< 7732E2 000000 08CD1E >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) radius=0.93124 (7732E2)
iir1_H_HighPass_0500_b0    set 0.931240       ; 7732E2
iir1_H_HighPass_0500_b1    set 0.000000       ; 000000
iir1_H_HighPass_0500_a1    set -0.068760      ; 08CD1E

;IIR1: fc=1000 HighPass h=< 0.867208 0 0.132792 >,< 6F00B0 000000 10FF4F >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) radius=0.867208 (6F00B0)
iir1_H_HighPass_1000_b0    set 0.867208       ; 6F00B0
iir1_H_HighPass_1000_b1    set 0.000000       ; 000000
iir1_H_HighPass_1000_a1    set -0.132792      ; 10FF4F

;IIR1: fc=2000 HighPass h=< 0.752051 0 0.247949 >,< 604331 000000 1FBCCE >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) radius=0.752051 (604331)
iir1_H_HighPass_2000_b0    set 0.752051       ; 604331
iir1_H_HighPass_2000_b1    set 0.000000       ; 000000
iir1_H_HighPass_2000_a1    set -0.247949      ; 1FBCCE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\IIIR.h ===
;**************************************************************************
;
;       IIIR.h    Interpolated IIR module
;       
;		Written by Gints Klimanis
;
;**************************************************************************        


; High Level Data
;DATASIZE_IO1 = 2
IIIR_LENGTH			equ 2

IIIR_DELAY_LENGTH	equ	3
IIIR_GAIN			equ	4
IIIR_TYPE			equ	5

; Low Level Data
IIIR_DELAY_BASE		equ	6
IIIR_DELAY_END		equ	7
IIIR_DELAY_INDEX	equ	8
IIIR_DELAY_LENGTHM1	equ	9
IIIR_DELAY_INDEX2	equ	10

DATA_SIZE_IIIR	equ	(1+IIIR_DELAY_INDEX2)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Iir2_BandPass.h ===
;**************************************************************************
;
;       IIR2_Bandpass.h    Coefficients for 2nd order band pass filter
;       
;		Written by Gints Klimanis
;
;**************************************************************************        
    
; IIR2: mode=BandPass fc=62.5 Q=1 h=< 0.00230936 0.00000000 -0.00230936 0.99534181 -0.49538127 >,< 004BAC 000000 FFB454 7F675C C09759 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandPass_f00062_q01_b0    set 0.00230936 ; 004BAC
iir2_H_BandPass_f00062_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00062_q01_b2    set -0.00230936 ; FFB454
iir2_H_BandPass_f00062_q01_a1    set 0.99534181 ; 7F675C
iir2_H_BandPass_f00062_q01_a2    set -0.49538127 ; C09759

; IIR2: mode=BandPass fc=78.7451 Q=1 h=< 0.00290610 0.00000000 -0.00290610 0.99412522 -0.49418779 >,< 005F3A 000000 FFA0C6 7F3F7F C0BE75 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandPass_f00078_q01_b0    set 0.00290610 ; 005F3A
iir2_H_BandPass_f00078_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00078_q01_b2    set -0.00290610 ; FFA0C6
iir2_H_BandPass_f00078_q01_a1    set 0.99412522 ; 7F3F7F
iir2_H_BandPass_f00078_q01_a2    set -0.49418779 ; C0BE75

; IIR2: mode=BandPass fc=99.2126 Q=1 h=< 0.00365589 0.00000000 -0.00365589 0.99258904 -0.49268821 >,< 0077CB 000000 FF8835 7F0D28 C0EF98 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandPass_f00099_q01_b0    set 0.00365589 ; 0077CB
iir2_H_BandPass_f00099_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00099_q01_b2    set -0.00365589 ; FF8835
iir2_H_BandPass_f00099_q01_a1    set 0.99258904 ; 7F0D28
iir2_H_BandPass_f00099_q01_a2    set -0.49268821 ; C0EF98

; IIR2: mode=BandPass fc=125 Q=1 h=< 0.00459731 0.00000000 -0.00459731 0.99064825 -0.49080538 >,< 0096A5 000000 FF695B 7ECD90 C12D4A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandPass_f00125_q01_b0    set 0.00459731 ; 0096A5
iir2_H_BandPass_f00125_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00125_q01_b2    set -0.00459731 ; FF695B
iir2_H_BandPass_f00125_q01_a1    set 0.99064825 ; 7ECD90
iir2_H_BandPass_f00125_q01_a2    set -0.49080538 ; C12D4A

; IIR2: mode=BandPass fc=157.49 Q=1 h=< 0.00577826 0.00000000 -0.00577826 0.98819465 -0.48844348 >,< 00BD57 000000 FF42A9 7E7D29 C17AB0 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandPass_f00157_q01_b0    set 0.00577826 ; 00BD57
iir2_H_BandPass_f00157_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00157_q01_b2    set -0.00577826 ; FF42A9
iir2_H_BandPass_f00157_q01_a1    set 0.98819465 ; 7E7D29
iir2_H_BandPass_f00157_q01_a2    set -0.48844348 ; C17AB0

; IIR2: mode=BandPass fc=198.425 Q=1 h=< 0.00725800 0.00000000 -0.00725800 0.98509021 -0.48548400 >,< 00EDD4 000000 FF122C 7E176F C1DBA9 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandPass_f00198_q01_b0    set 0.00725800 ; 00EDD4
iir2_H_BandPass_f00198_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00198_q01_b2    set -0.00725800 ; FF122C
iir2_H_BandPass_f00198_q01_a1    set 0.98509021 ; 7E176F
iir2_H_BandPass_f00198_q01_a2    set -0.48548400 ; C1DBA9

; IIR2: mode=BandPass fc=250 Q=1 h=< 0.00910943 0.00000000 -0.00910943 0.98115840 -0.48178114 >,< 012A7F 000000 FED581 7D9699 C254FF >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandPass_f00250_q01_b0    set 0.00910943 ; 012A7F
iir2_H_BandPass_f00250_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00250_q01_b2    set -0.00910943 ; FED581
iir2_H_BandPass_f00250_q01_a1    set 0.98115840 ; 7D9699
iir2_H_BandPass_f00250_q01_a2    set -0.48178114 ; C254FF

; IIR2: mode=BandPass fc=314.98 Q=1 h=< 0.01142169 0.00000000 -0.01142169 0.97617282 -0.47715663 >,< 017644 000000 FE89BC 7CF33B C2EC88 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandPass_f00314_q01_b0    set 0.01142169 ; 017644
iir2_H_BandPass_f00314_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00314_q01_b2    set -0.01142169 ; FE89BC
iir2_H_BandPass_f00314_q01_a1    set 0.97617282 ; 7CF33B
iir2_H_BandPass_f00314_q01_a2    set -0.47715663 ; C2EC88

; IIR2: mode=BandPass fc=396.85 Q=1 h=< 0.01430274 0.00000000 -0.01430274 0.96984218 -0.47139451 >,< 01D4AC 000000 FE2B54 7C23CA C3A959 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandPass_f00396_q01_b0    set 0.01430274 ; 01D4AC
iir2_H_BandPass_f00396_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00396_q01_b2    set -0.01430274 ; FE2B54
iir2_H_BandPass_f00396_q01_a1    set 0.96984218 ; 7C23CA
iir2_H_BandPass_f00396_q01_a2    set -0.47139451 ; C3A959

; IIR2: mode=BandPass fc=500 Q=1 h=< 0.01788193 0.00000000 -0.01788193 0.96179050 -0.46423613 >,< 0249F4 000000 FDB60C 7B1BF3 C493E9 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandPass_f00500_q01_b0    set 0.01788193 ; 0249F4
iir2_H_BandPass_f00500_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00500_q01_b2    set -0.01788193 ; FDB60C
iir2_H_BandPass_f00500_q01_a1    set 0.96179050 ; 7B1BF3
iir2_H_BandPass_f00500_q01_a2    set -0.46423613 ; C493E9

; IIR2: mode=BandPass fc=629.961 Q=1 h=< 0.02231172 0.00000000 -0.02231172 0.95153097 -0.45537655 >,< 02DB1C 000000 FD24E4 79CBC4 C5B639 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandPass_f00629_q01_b0    set 0.02231172 ; 02DB1C
iir2_H_BandPass_f00629_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00629_q01_b2    set -0.02231172 ; FD24E4
iir2_H_BandPass_f00629_q01_a1    set 0.95153097 ; 79CBC4
iir2_H_BandPass_f00629_q01_a2    set -0.45537655 ; C5B639

; IIR2: mode=BandPass fc=793.701 Q=1 h=< 0.02776799 0.00000000 -0.02776799 0.93843163 -0.44446401 >,< 038DE6 000000 FC721A 781E87 C71BCE >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandPass_f00793_q01_b0    set 0.02776799 ; 038DE6
iir2_H_BandPass_f00793_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00793_q01_b2    set -0.02776799 ; FC721A
iir2_H_BandPass_f00793_q01_a1    set 0.93843163 ; 781E87
iir2_H_BandPass_f00793_q01_a2    set -0.44446401 ; C71BCE

; IIR2: mode=BandPass fc=1000 Q=1 h=< 0.03444743 0.00000000 -0.03444743 0.92167069 -0.43110514 >,< 0468C6 000000 FB973A 75F94E C8D18C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandPass_f01000_q01_b0    set 0.03444743 ; 0468C6
iir2_H_BandPass_f01000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01000_q01_b2    set -0.03444743 ; FB973A
iir2_H_BandPass_f01000_q01_a1    set 0.92167069 ; 75F94E
iir2_H_BandPass_f01000_q01_a2    set -0.43110514 ; C8D18C

; IIR2: mode=BandPass fc=1259.92 Q=1 h=< 0.04255994 0.00000000 -0.04255994 0.90017945 -0.41488011 >,< 05729A 000000 FA8D66 733914 CAE536 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandPass_f01259_q01_b0    set 0.04255994 ; 05729A
iir2_H_BandPass_f01259_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01259_q01_b2    set -0.04255994 ; FA8D66
iir2_H_BandPass_f01259_q01_a1    set 0.90017945 ; 733914
iir2_H_BandPass_f01259_q01_a2    set -0.41488011 ; CAE536

; IIR2: mode=BandPass fc=1587.4 Q=1 h=< 0.05231313 0.00000000 -0.05231313 0.87257147 -0.39537375 >,< 06B232 000000 F94DCE 6FB06C CD6465 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandPass_f01587_q01_b0    set 0.05231313 ; 06B232
iir2_H_BandPass_f01587_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01587_q01_b2    set -0.05231313 ; F94DCE
iir2_H_BandPass_f01587_q01_a1    set 0.87257147 ; 6FB06C
iir2_H_BandPass_f01587_q01_a2    set -0.39537375 ; CD6465

; IIR2: mode=BandPass fc=2000 Q=1 h=< 0.06388465 0.00000000 -0.06388465 0.83705819 -0.37223069 >,< 082D5F 000000 F7D2A1 6B24B9 D05ABF >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandPass_f02000_q01_b0    set 0.06388465 ; 082D5F
iir2_H_BandPass_f02000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02000_q01_b2    set -0.06388465 ; F7D2A1
iir2_H_BandPass_f02000_q01_a1    set 0.83705819 ; 6B24B9
iir2_H_BandPass_f02000_q01_a2    set -0.37223069 ; D05ABF

; IIR2: mode=BandPass fc=2519.84 Q=1 h=< 0.07737745 0.00000000 -0.07737745 0.79135461 -0.34524509 >,< 09E781 000000 F6187F 654B1B D3CF03 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandPass_f02519_q01_b0    set 0.07737745 ; 09E781
iir2_H_BandPass_f02519_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02519_q01_b2    set -0.07737745 ; F6187F
iir2_H_BandPass_f02519_q01_a1    set 0.79135461 ; 654B1B
iir2_H_BandPass_f02519_q01_a2    set -0.34524509 ; D3CF03

; IIR2: mode=BandPass fc=3174.8 Q=1 h=< 0.09275176 0.00000000 -0.09275176 0.73258259 -0.31449647 >,< 0BDF4A 000000 F420B6 5DC544 D7BE95 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandPass_f03174_q01_b0    set 0.09275176 ; 0BDF4A
iir2_H_BandPass_f03174_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f03174_q01_b2    set -0.09275176 ; F420B6
iir2_H_BandPass_f03174_q01_a1    set 0.73258259 ; 5DC544
iir2_H_BandPass_f03174_q01_a2    set -0.31449647 ; D7BE95

; IIR2: mode=BandPass fc=4000 Q=1 h=< 0.10972788 0.00000000 -0.10972788 0.65718163 -0.28054424 >,< 0E0B90 000000 F1F470 541E87 DC1721 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandPass_f04000_q01_b0    set 0.10972788 ; 0E0B90
iir2_H_BandPass_f04000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f04000_q01_b2    set -0.10972788 ; F1F470
iir2_H_BandPass_f04000_q01_a1    set 0.65718163 ; 541E87
iir2_H_BandPass_f04000_q01_a2    set -0.28054424 ; DC1721

; IIR2: mode=BandPass fc=5039.68 Q=1 h=< 0.12765236 0.00000000 -0.12765236 0.56083081 -0.24469528 >,< 1056E9 000000 EFA917 47C94E E0ADD4 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandPass_f05039_q01_b0    set 0.12765236 ; 1056E9
iir2_H_BandPass_f05039_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f05039_q01_b2    set -0.12765236 ; EFA917
iir2_H_BandPass_f05039_q01_a1    set 0.56083081 ; 47C94E
iir2_H_BandPass_f05039_q01_a2    set -0.24469528 ; E0ADD4

; IIR2: mode=BandPass fc=6349.6 Q=1 h=< 0.14531327 0.00000000 -0.14531327 0.43835645 -0.20937345 >,< 1299A0 000000 ED6660 381C10 E53341 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandPass_f06349_q01_b0    set 0.14531327 ; 1299A0
iir2_H_BandPass_f06349_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f06349_q01_b2    set -0.14531327 ; ED6660
iir2_H_BandPass_f06349_q01_a1    set 0.43835645 ; 381C10
iir2_H_BandPass_f06349_q01_a2    set -0.20937345 ; E53341

; IIR2: mode=BandPass fc=8000 Q=1 h=< 0.16065865 0.00000000 -0.16065865 0.28353326 -0.17868269 >,< 149076 000000 EB6F8A 244AD1 E920ED >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandPass_f08000_q01_b0    set 0.16065865 ; 149076
iir2_H_BandPass_f08000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f08000_q01_b2    set -0.16065865 ; EB6F8A
iir2_H_BandPass_f08000_q01_a1    set 0.28353326 ; 244AD1
iir2_H_BandPass_f08000_q01_a2    set -0.17868269 ; E920ED

; IIR2: mode=BandPass fc=10079.4 Q=1 h=< 0.17026582 0.00000000 -0.17026582 0.08858140 -0.15946836 >,< 15CB45 000000 EA34BB 0B56A2 EB968B >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandPass_f10079_q01_b0    set 0.17026582 ; 15CB45
iir2_H_BandPass_f10079_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f10079_q01_b2    set -0.17026582 ; EA34BB
iir2_H_BandPass_f10079_q01_a1    set 0.08858140 ; 0B56A2
iir2_H_BandPass_f10079_q01_a2    set -0.15946836 ; EB968B

; IIR2: mode=BandPass fc=12699.2 Q=1 h=< 0.16806977 0.00000000 -0.16806977 -0.15685606 -0.16386045 >,< 15834F 000000 EA7CB1 EBEC24 EB069F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandPass_f12699_q01_b0    set 0.16806977 ; 15834F
iir2_H_BandPass_f12699_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f12699_q01_b2    set -0.16806977 ; EA7CB1
iir2_H_BandPass_f12699_q01_a1    set -0.15685606 ; EBEC24
iir2_H_BandPass_f12699_q01_a2    set -0.16386045 ; EB069F

; IIR2: mode=BandPass fc=16000 Q=1 h=< 0.14172608 0.00000000 -0.14172608 -0.46642712 -0.21654784 >,< 122414 000000 EDDBEC C44C1E E44829 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandPass_f16000_q01_b0    set 0.14172608 ; 122414
iir2_H_BandPass_f16000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f16000_q01_b2    set -0.14172608 ; EDDBEC
iir2_H_BandPass_f16000_q01_a1    set -0.46642712 ; C44C1E
iir2_H_BandPass_f16000_q01_a2    set -0.21654784 ; E44829

; IIR2: mode=BandPass fc=20158.7 Q=1 h=< 0.06091086 0.00000000 -0.06091086 -0.84648918 -0.37817827 >,< 07CBED 000000 F83413 93A63E CF97DB >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandPass_f20158_q01_b0    set 0.06091086 ; 07CBED
iir2_H_BandPass_f20158_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f20158_q01_b2    set -0.06091086 ; F83413
iir2_H_BandPass_f20158_q01_a1    set -0.84648918 ; 93A63E
iir2_H_BandPass_f20158_q01_a2    set -0.37817827 ; CF97DB

; IIR2: mode=BandPass fc=62.5 Q=3 h=< 0.00074438 0.00000000 -0.00074438 0.99847165 -0.49851124 >,< 001864 000000 FFE79C 7FCDEB C030C9 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandPass_f00062_q03_b0    set 0.00074438 ; 001864
iir2_H_BandPass_f00062_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00062_q03_b2    set -0.00074438 ; FFE79C
iir2_H_BandPass_f00062_q03_a1    set 0.99847165 ; 7FCDEB
iir2_H_BandPass_f00062_q03_a2    set -0.49851124 ; C030C9

; IIR2: mode=BandPass fc=78.7451 Q=3 h=< 0.00093749 0.00000000 -0.00093749 0.99806220 -0.49812501 >,< 001EB8 000000 FFE148 7FC080 C03D71 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandPass_f00078_q03_b0    set 0.00093749 ; 001EB8
iir2_H_BandPass_f00078_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00078_q03_b2    set -0.00093749 ; FFE148
iir2_H_BandPass_f00078_q03_a1    set 0.99806220 ; 7FC080
iir2_H_BandPass_f00078_q03_a2    set -0.49812501 ; C03D71

; IIR2: mode=BandPass fc=99.2126 Q=3 h=< 0.00118058 0.00000000 -0.00118058 0.99753918 -0.49763885 >,< 0026AF 000000 FFD951 7FAF5D C04D5F >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandPass_f00099_q03_b0    set 0.00118058 ; 0026AF
iir2_H_BandPass_f00099_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00099_q03_b2    set -0.00118058 ; FFD951
iir2_H_BandPass_f00099_q03_a1    set 0.99753918 ; 7FAF5D
iir2_H_BandPass_f00099_q03_a2    set -0.49763885 ; C04D5F

; IIR2: mode=BandPass fc=125 Q=3 h=< 0.00148649 0.00000000 -0.00148649 0.99686890 -0.49702701 >,< 0030B5 000000 FFCF4B 7F9966 C0616C >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandPass_f00125_q03_b0    set 0.00148649 ; 0030B5
iir2_H_BandPass_f00125_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00125_q03_b2    set -0.00148649 ; FFCF4B
iir2_H_BandPass_f00125_q03_a1    set 0.99686890 ; 7F9966
iir2_H_BandPass_f00125_q03_a2    set -0.49702701 ; C0616C

; IIR2: mode=BandPass fc=157.49 Q=3 h=< 0.00187136 0.00000000 -0.00187136 0.99600649 -0.49625728 >,< 003D52 000000 FFC2AE 7F7D24 C07AA5 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandPass_f00157_q03_b0    set 0.00187136 ; 003D52
iir2_H_BandPass_f00157_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00157_q03_b2    set -0.00187136 ; FFC2AE
iir2_H_BandPass_f00157_q03_a1    set 0.99600649 ; 7F7D24
iir2_H_BandPass_f00157_q03_a2    set -0.49625728 ; C07AA5

; IIR2: mode=BandPass fc=198.425 Q=3 h=< 0.00235536 0.00000000 -0.00235536 0.99489157 -0.49528928 >,< 004D2E 000000 FFB2D2 7F589B C09A5D >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandPass_f00198_q03_b0    set 0.00235536 ; 004D2E
iir2_H_BandPass_f00198_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00198_q03_b2    set -0.00235536 ; FFB2D2
iir2_H_BandPass_f00198_q03_a1    set 0.99489157 ; 7F589B
iir2_H_BandPass_f00198_q03_a2    set -0.49528928 ; C09A5D

; IIR2: mode=BandPass fc=250 Q=3 h=< 0.00296371 0.00000000 -0.00296371 0.99344206 -0.49407259 >,< 00611D 000000 FF9EE3 7F291C C0C23B >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandPass_f00250_q03_b0    set 0.00296371 ; 00611D
iir2_H_BandPass_f00250_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00250_q03_b2    set -0.00296371 ; FF9EE3
iir2_H_BandPass_f00250_q03_a1    set 0.99344206 ; 7F291C
iir2_H_BandPass_f00250_q03_a2    set -0.49407259 ; C0C23B

; IIR2: mode=BandPass fc=314.98 Q=3 h=< 0.00372783 0.00000000 -0.00372783 0.99154504 -0.49254434 >,< 007A27 000000 FF85D9 7EEAF2 C0F44F >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandPass_f00314_q03_b0    set 0.00372783 ; 007A27
iir2_H_BandPass_f00314_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00314_q03_b2    set -0.00372783 ; FF85D9
iir2_H_BandPass_f00314_q03_a1    set 0.99154504 ; 7EEAF2
iir2_H_BandPass_f00314_q03_a2    set -0.49254434 ; C0F44F

; IIR2: mode=BandPass fc=396.85 Q=3 h=< 0.00468677 0.00000000 -0.00468677 0.98904338 -0.49062645 >,< 009993 000000 FF666D 7E98F9 C13327 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandPass_f00396_q03_b0    set 0.00468677 ; 009993
iir2_H_BandPass_f00396_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00396_q03_b2    set -0.00468677 ; FF666D
iir2_H_BandPass_f00396_q03_a1    set 0.98904338 ; 7E98F9
iir2_H_BandPass_f00396_q03_a2    set -0.49062645 ; C13327

; IIR2: mode=BandPass fc=500 Q=3 h=< 0.00588879 0.00000000 -0.00588879 0.98571594 -0.48822242 >,< 00C0F6 000000 FF3F0A 7E2BF0 C181EE >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandPass_f00500_q03_b0    set 0.00588879 ; 00C0F6
iir2_H_BandPass_f00500_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00500_q03_b2    set -0.00588879 ; FF3F0A
iir2_H_BandPass_f00500_q03_a1    set 0.98571594 ; 7E2BF0
iir2_H_BandPass_f00500_q03_a2    set -0.48822242 ; C181EE

; IIR2: mode=BandPass fc=629.961 Q=3 h=< 0.00739315 0.00000000 -0.00739315 0.98124802 -0.48521371 >,< 00F242 000000 FF0DBE 7D9989 C1E485 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandPass_f00629_q03_b0    set 0.00739315 ; 00F242
iir2_H_BandPass_f00629_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00629_q03_b2    set -0.00739315 ; FF0DBE
iir2_H_BandPass_f00629_q03_a1    set 0.98124802 ; 7D9989
iir2_H_BandPass_f00629_q03_a2    set -0.48521371 ; C1E485

; IIR2: mode=BandPass fc=793.701 Q=3 h=< 0.00927193 0.00000000 -0.00927193 0.97518748 -0.48145613 >,< 012FD2 000000 FED02E 7CD2F1 C25FA6 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandPass_f00793_q03_b0    set 0.00927193 ; 012FD2
iir2_H_BandPass_f00793_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00793_q03_b2    set -0.00927193 ; FED02E
iir2_H_BandPass_f00793_q03_a1    set 0.97518748 ; 7CD2F1
iir2_H_BandPass_f00793_q03_a2    set -0.48145613 ; C25FA6

; IIR2: mode=BandPass fc=1000 Q=3 h=< 0.01161165 0.00000000 -0.01161165 0.96687949 -0.47677671 >,< 017C7D 000000 FE8383 7BC2B5 C2F8FB >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandPass_f01000_q03_b0    set 0.01161165 ; 017C7D
iir2_H_BandPass_f01000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01000_q03_b2    set -0.01161165 ; FE8383
iir2_H_BandPass_f01000_q03_a1    set 0.96687949 ; 7BC2B5
iir2_H_BandPass_f01000_q03_a2    set -0.47677671 ; C2F8FB

; IIR2: mode=BandPass fc=1259.92 Q=3 h=< 0.01451390 0.00000000 -0.01451390 0.95537023 -0.47097221 >,< 01DB97 000000 FE2469 7A4992 C3B72F >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandPass_f01259_q03_b0    set 0.01451390 ; 01DB97
iir2_H_BandPass_f01259_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01259_q03_b2    set -0.01451390 ; FE2469
iir2_H_BandPass_f01259_q03_a1    set 0.95537023 ; 7A4992
iir2_H_BandPass_f01259_q03_a2    set -0.47097221 ; C3B72F

; IIR2: mode=BandPass fc=1587.4 Q=3 h=< 0.01809418 0.00000000 -0.01809418 0.93926647 -0.46381164 >,< 0250E8 000000 FDAF18 7839E2 C4A1D2 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandPass_f01587_q03_b0    set 0.01809418 ; 0250E8
iir2_H_BandPass_f01587_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01587_q03_b2    set -0.01809418 ; FDAF18
iir2_H_BandPass_f01587_q03_a1    set 0.93926647 ; 7839E2
iir2_H_BandPass_f01587_q03_a2    set -0.46381164 ; C4A1D2

; IIR2: mode=BandPass fc=2000 Q=3 h=< 0.02247658 0.00000000 -0.02247658 0.91653480 -0.45504684 >,< 02E083 000000 FD1F7D 755103 C5C107 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandPass_f02000_q03_b0    set 0.02247658 ; 02E083
iir2_H_BandPass_f02000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02000_q03_b2    set -0.02247658 ; FD1F7D
iir2_H_BandPass_f02000_q03_a1    set 0.91653480 ; 755103
iir2_H_BandPass_f02000_q03_a2    set -0.45504684 ; C5C107

; IIR2: mode=BandPass fc=2519.84 Q=3 h=< 0.02778086 0.00000000 -0.02778086 0.88422351 -0.44443828 >,< 038E52 000000 FC71AE 712E3C C71CA6 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandPass_f02519_q03_b0    set 0.02778086 ; 038E52
iir2_H_BandPass_f02519_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02519_q03_b2    set -0.02778086 ; FC71AE
iir2_H_BandPass_f02519_q03_a1    set 0.88422351 ; 712E3C
iir2_H_BandPass_f02519_q03_a2    set -0.44443828 ; C71CA6

; IIR2: mode=BandPass fc=3174.8 Q=3 h=< 0.03409573 0.00000000 -0.03409573 0.83809658 -0.43180854 >,< 045D3F 000000 FBA2C1 6B46BF C8BA80 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandPass_f03174_q03_b0    set 0.03409573 ; 045D3F
iir2_H_BandPass_f03174_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f03174_q03_b2    set -0.03409573 ; FBA2C1
iir2_H_BandPass_f03174_q03_a1    set 0.83809658 ; 6B46BF
iir2_H_BandPass_f03174_q03_a2    set -0.43180854 ; C8BA80

; IIR2: mode=BandPass fc=4000 Q=3 h=< 0.04142830 0.00000000 -0.04142830 0.77219172 -0.41714341 >,< 054D85 000000 FAB27B 62D72D CA9B0C >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandPass_f04000_q03_b0    set 0.04142830 ; 054D85
iir2_H_BandPass_f04000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f04000_q03_b2    set -0.04142830 ; FAB27B
iir2_H_BandPass_f04000_q03_a1    set 0.77219172 ; 62D72D
iir2_H_BandPass_f04000_q03_a2    set -0.41714341 ; CA9B0C

; IIR2: mode=BandPass fc=5039.68 Q=3 h=< 0.04961413 0.00000000 -0.04961413 0.67837216 -0.40077175 >,< 0659C1 000000 F9A63F 56D4E6 CCB383 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandPass_f05039_q03_b0    set 0.04961413 ; 0659C1
iir2_H_BandPass_f05039_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f05039_q03_b2    set -0.04961413 ; F9A63F
iir2_H_BandPass_f05039_q03_a1    set 0.67837216 ; 56D4E6
iir2_H_BandPass_f05039_q03_a2    set -0.40077175 ; CCB383

; IIR2: mode=BandPass fc=6349.6 Q=3 h=< 0.05816489 0.00000000 -0.05816489 0.54606291 -0.38367022 >,< 0771F2 000000 F88E0E 45E563 CEE3E5 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandPass_f06349_q03_b0    set 0.05816489 ; 0771F2
iir2_H_BandPass_f06349_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f06349_q03_b2    set -0.05816489 ; F88E0E
iir2_H_BandPass_f06349_q03_a1    set 0.54606291 ; 45E563
iir2_H_BandPass_f06349_q03_a2    set -0.38367022 ; CEE3E5

; IIR2: mode=BandPass fc=8000 Q=3 h=< 0.06602025 0.00000000 -0.06602025 0.36260743 -0.36795950 >,< 08735A 000000 F78CA6 2E69EB D0E6B4 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandPass_f08000_q03_b0    set 0.06602025 ; 08735A
iir2_H_BandPass_f08000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f08000_q03_b2    set -0.06602025 ; F78CA6
iir2_H_BandPass_f08000_q03_a1    set 0.36260743 ; 2E69EB
iir2_H_BandPass_f08000_q03_a2    set -0.36795950 ; D0E6B4

; IIR2: mode=BandPass fc=10079.4 Q=3 h=< 0.07115483 0.00000000 -0.07115483 0.11520706 -0.35769034 >,< 091B99 000000 F6E467 0EBF1A D23734 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandPass_f10079_q03_b0    set 0.07115483 ; 091B99
iir2_H_BandPass_f10079_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f10079_q03_b2    set -0.07115483 ; F6E467
iir2_H_BandPass_f10079_q03_a1    set 0.11520706 ; 0EBF1A
iir2_H_BandPass_f10079_q03_a2    set -0.35769034 ; D23734

; IIR2: mode=BandPass fc=12699.2 Q=3 h=< 0.06996585 0.00000000 -0.06996585 -0.20321579 -0.36006830 >,< 08F4A4 000000 F70B5C E5FD07 D1E949 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandPass_f12699_q03_b0    set 0.06996585 ; 08F4A4
iir2_H_BandPass_f12699_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f12699_q03_b2    set -0.06996585 ; F70B5C
iir2_H_BandPass_f12699_q03_a1    set -0.20321579 ; E5FD07
iir2_H_BandPass_f12699_q03_a2    set -0.36006830 ; D1E949

; IIR2: mode=BandPass fc=16000 Q=3 h=< 0.05638702 0.00000000 -0.05638702 -0.57752773 -0.38722595 >,< 0737B0 000000 F8C850 B61393 CE6F62 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandPass_f16000_q03_b0    set 0.05638702 ; 0737B0
iir2_H_BandPass_f16000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f16000_q03_b2    set -0.05638702 ; F8C850
iir2_H_BandPass_f16000_q03_a1    set -0.57752773 ; B61393
iir2_H_BandPass_f16000_q03_a2    set -0.38722595 ; CE6F62

; IIR2: mode=BandPass fc=20158.7 Q=3 h=< 0.02133601 0.00000000 -0.02133601 -0.92278277 -0.45732798 >,< 02BB23 000000 FD44DD 89E241 C57647 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandPass_f20158_q03_b0    set 0.02133601 ; 02BB23
iir2_H_BandPass_f20158_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f20158_q03_b2    set -0.02133601 ; FD44DD
iir2_H_BandPass_f20158_q03_a1    set -0.92278277 ; 89E241
iir2_H_BandPass_f20158_q03_a2    set -0.45732798 ; C57647

; IIR2: mode=BandPass fc=62.5 Q=9 h=< 0.00024736 0.00000000 -0.00024736 0.99946566 -0.49950529 >,< 00081A 000000 FFF7E6 7FEE7D C01036 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandPass_f00062_q09_b0    set 0.00024736 ; 00081A
iir2_H_BandPass_f00062_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00062_q09_b2    set -0.00024736 ; FFF7E6
iir2_H_BandPass_f00062_q09_a1    set 0.99946566 ; 7FEE7D
iir2_H_BandPass_f00062_q09_a2    set -0.49950529 ; C01036

; IIR2: mode=BandPass fc=78.7451 Q=9 h=< 0.00031161 0.00000000 -0.00031161 0.99931389 -0.49937679 >,< 000A35 000000 FFF5CB 7FE984 C0146C >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandPass_f00078_q09_b0    set 0.00031161 ; 000A35
iir2_H_BandPass_f00078_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00078_q09_b2    set -0.00031161 ; FFF5CB
iir2_H_BandPass_f00078_q09_a1    set 0.99931389 ; 7FE984
iir2_H_BandPass_f00078_q09_a2    set -0.49937679 ; C0146C

; IIR2: mode=BandPass fc=99.2126 Q=9 h=< 0.00039253 0.00000000 -0.00039253 0.99911511 -0.49921494 >,< 000CDC 000000 FFF324 7FE301 C019BA >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandPass_f00099_q09_b0    set 0.00039253 ; 000CDC
iir2_H_BandPass_f00099_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00099_q09_b2    set -0.00039253 ; FFF324
iir2_H_BandPass_f00099_q09_a1    set 0.99911511 ; 7FE301
iir2_H_BandPass_f00099_q09_a2    set -0.49921494 ; C019BA

; IIR2: mode=BandPass fc=125 Q=9 h=< 0.00049445 0.00000000 -0.00049445 0.99885268 -0.49901111 >,< 001033 000000 FFEFCD 7FDA67 C02068 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandPass_f00125_q09_b0    set 0.00049445 ; 001033
iir2_H_BandPass_f00125_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00125_q09_b2    set -0.00049445 ; FFEFCD
iir2_H_BandPass_f00125_q09_a1    set 0.99885268 ; 7FDA67
iir2_H_BandPass_f00125_q09_a2    set -0.49901111 ; C02068

; IIR2: mode=BandPass fc=157.49 Q=9 h=< 0.00062278 0.00000000 -0.00062278 0.99850301 -0.49875443 >,< 001468 000000 FFEB98 7FCEF2 C028D1 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandPass_f00157_q09_b0    set 0.00062278 ; 001468
iir2_H_BandPass_f00157_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00157_q09_b2    set -0.00062278 ; FFEB98
iir2_H_BandPass_f00157_q09_a1    set 0.99850301 ; 7FCEF2
iir2_H_BandPass_f00157_q09_a2    set -0.49875443 ; C028D1

; IIR2: mode=BandPass fc=198.425 Q=9 h=< 0.00078437 0.00000000 -0.00078437 0.99803230 -0.49843127 >,< 0019B3 000000 FFE64D 7FBF85 C03368 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandPass_f00198_q09_b0    set 0.00078437 ; 0019B3
iir2_H_BandPass_f00198_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00198_q09_b2    set -0.00078437 ; FFE64D
iir2_H_BandPass_f00198_q09_a1    set 0.99803230 ; 7FBF85
iir2_H_BandPass_f00198_q09_a2    set -0.49843127 ; C03368

; IIR2: mode=BandPass fc=250 Q=9 h=< 0.00098776 0.00000000 -0.00098776 0.99739144 -0.49802448 >,< 00205D 000000 FFDFA3 7FAA86 C040BC >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandPass_f00250_q09_b0    set 0.00098776 ; 00205D
iir2_H_BandPass_f00250_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00250_q09_b2    set -0.00098776 ; FFDFA3
iir2_H_BandPass_f00250_q09_a1    set 0.99739144 ; 7FAA86
iir2_H_BandPass_f00250_q09_a2    set -0.49802448 ; C040BC

; IIR2: mode=BandPass fc=314.98 Q=9 h=< 0.00124371 0.00000000 -0.00124371 0.99650828 -0.49751259 >,< 0028C0 000000 FFD740 7F8D95 C05182 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandPass_f00314_q09_b0    set 0.00124371 ; 0028C0
iir2_H_BandPass_f00314_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00314_q09_b2    set -0.00124371 ; FFD740
iir2_H_BandPass_f00314_q09_a1    set 0.99650828 ; 7F8D95
iir2_H_BandPass_f00314_q09_a2    set -0.49751259 ; C05182

; IIR2: mode=BandPass fc=396.85 Q=9 h=< 0.00156565 0.00000000 -0.00156565 0.99527565 -0.49686870 >,< 00334D 000000 FFCCB3 7F6531 C0669C >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandPass_f00396_q09_b0    set 0.00156565 ; 00334D
iir2_H_BandPass_f00396_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00396_q09_b2    set -0.00156565 ; FFCCB3
iir2_H_BandPass_f00396_q09_a1    set 0.99527565 ; 7F6531
iir2_H_BandPass_f00396_q09_a2    set -0.49686870 ; C0669C

; IIR2: mode=BandPass fc=500 Q=9 h=< 0.00197038 0.00000000 -0.00197038 0.99353289 -0.49605924 >,< 004090 000000 FFBF70 7F2C16 C08122 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandPass_f00500_q09_b0    set 0.00197038 ; 004090
iir2_H_BandPass_f00500_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00500_q09_b2    set -0.00197038 ; FFBF70
iir2_H_BandPass_f00500_q09_a1    set 0.99353289 ; 7F2C16
iir2_H_BandPass_f00500_q09_a2    set -0.49605924 ; C08122

; IIR2: mode=BandPass fc=629.961 Q=9 h=< 0.00247876 0.00000000 -0.00247876 0.99103724 -0.49504249 >,< 005139 000000 FFAEC7 7EDA4F C0A273 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandPass_f00629_q09_b0    set 0.00247876 ; 005139
iir2_H_BandPass_f00629_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00629_q09_b2    set -0.00247876 ; FFAEC7
iir2_H_BandPass_f00629_q09_a1    set 0.99103724 ; 7EDA4F
iir2_H_BandPass_f00629_q09_a2    set -0.49504249 ; C0A273

; IIR2: mode=BandPass fc=793.701 Q=9 h=< 0.00311657 0.00000000 -0.00311657 0.98741958 -0.49376685 >,< 00661F 000000 FF99E1 7E63C3 C0CC40 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandPass_f00793_q09_b0    set 0.00311657 ; 00661F
iir2_H_BandPass_f00793_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00793_q09_b2    set -0.00311657 ; FF99E1
iir2_H_BandPass_f00793_q09_a1    set 0.98741958 ; 7E63C3
iir2_H_BandPass_f00793_q09_a2    set -0.49376685 ; C0CC40

; IIR2: mode=BandPass fc=1000 Q=9 h=< 0.00391541 0.00000000 -0.00391541 0.98211599 -0.49216917 >,< 00804C 000000 FF7FB4 7DB5FA C1009A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandPass_f01000_q09_b0    set 0.00391541 ; 00804C
iir2_H_BandPass_f01000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01000_q09_b2    set -0.00391541 ; FF7FB4
iir2_H_BandPass_f01000_q09_a1    set 0.98211599 ; 7DB5FA
iir2_H_BandPass_f01000_q09_a2    set -0.49216917 ; C1009A

; IIR2: mode=BandPass fc=1259.92 Q=9 h=< 0.00491340 0.00000000 -0.00491340 0.97426271 -0.49017321 >,< 00A100 000000 FF5F00 7CB4A4 C14201 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandPass_f01259_q09_b0    set 0.00491340 ; 00A100
iir2_H_BandPass_f01259_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01259_q09_b2    set -0.00491340 ; FF5F00
iir2_H_BandPass_f01259_q09_a1    set 0.97426271 ; 7CB4A4
iir2_H_BandPass_f01259_q09_a2    set -0.49017321 ; C14201

; IIR2: mode=BandPass fc=1587.4 Q=9 h=< 0.00615546 0.00000000 -0.00615546 0.96253583 -0.48768909 >,< 00C9B3 000000 FF364D 7B3460 C19368 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandPass_f01587_q09_b0    set 0.00615546 ; 00C9B3
iir2_H_BandPass_f01587_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01587_q09_b2    set -0.00615546 ; FF364D
iir2_H_BandPass_f01587_q09_a1    set 0.96253583 ; 7B3460
iir2_H_BandPass_f01587_q09_a2    set -0.48768909 ; C19368

; IIR2: mode=BandPass fc=2000 Q=9 h=< 0.00769246 0.00000000 -0.00769246 0.94491070 -0.48461508 >,< 00FC11 000000 FF03EF 78F2D5 C1F822 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandPass_f02000_q09_b0    set 0.00769246 ; 00FC11
iir2_H_BandPass_f02000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02000_q09_b2    set -0.00769246 ; FF03EF
iir2_H_BandPass_f02000_q09_a1    set 0.94491070 ; 78F2D5
iir2_H_BandPass_f02000_q09_a2    set -0.48461508 ; C1F822

; IIR2: mode=BandPass fc=2519.84 Q=9 h=< 0.00957780 0.00000000 -0.00957780 0.91830849 -0.48084441 >,< 0139D8 000000 FEC628 758B22 C273B1 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandPass_f02519_q09_b0    set 0.00957780 ; 0139D8
iir2_H_BandPass_f02519_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02519_q09_b2    set -0.00957780 ; FEC628
iir2_H_BandPass_f02519_q09_a1    set 0.91830849 ; 758B22
iir2_H_BandPass_f02519_q09_a2    set -0.48084441 ; C273B1

; IIR2: mode=BandPass fc=3174.8 Q=9 h=< 0.01185884 0.00000000 -0.01185884 0.87809764 -0.47628233 >,< 018497 000000 FE7B69 706581 C3092F >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandPass_f03174_q09_b0    set 0.01185884 ; 018497
iir2_H_BandPass_f03174_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f03174_q09_b2    set -0.01185884 ; FE7B69
iir2_H_BandPass_f03174_q09_a1    set 0.87809764 ; 706581
iir2_H_BandPass_f03174_q09_a2    set -0.47628233 ; C3092F

; IIR2: mode=BandPass fc=4000 Q=9 h=< 0.01455861 0.00000000 -0.01455861 0.81743775 -0.47088278 >,< 01DD0E 000000 FE22F2 68A1CD C3BA1D >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandPass_f04000_q09_b0    set 0.01455861 ; 01DD0E
iir2_H_BandPass_f04000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f04000_q09_b2    set -0.01455861 ; FE22F2
iir2_H_BandPass_f04000_q09_a1    set 0.81743775 ; 68A1CD
iir2_H_BandPass_f04000_q09_a2    set -0.47088278 ; C3BA1D

; IIR2: mode=BandPass fc=5039.68 Q=9 h=< 0.01763948 0.00000000 -0.01763948 0.72653245 -0.46472105 >,< 024202 000000 FDBDFE 5CFF04 C48406 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandPass_f05039_q09_b0    set 0.01763948 ; 024202
iir2_H_BandPass_f05039_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f05039_q09_b2    set -0.01763948 ; FDBDFE
iir2_H_BandPass_f05039_q09_a1    set 0.72653245 ; 5CFF04
iir2_H_BandPass_f05039_q09_a2    set -0.46472105 ; C48406

; IIR2: mode=BandPass fc=6349.6 Q=9 h=< 0.02093572 0.00000000 -0.02093572 0.59207436 -0.45812856 >,< 02AE05 000000 FD51FB 4BC917 C55C0B >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandPass_f06349_q09_b0    set 0.02093572 ; 02AE05
iir2_H_BandPass_f06349_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f06349_q09_b2    set -0.02093572 ; FD51FB
iir2_H_BandPass_f06349_q09_a1    set 0.59207436 ; 4BC917
iir2_H_BandPass_f06349_q09_a2    set -0.45812856 ; C55C0B

; IIR2: mode=BandPass fc=8000 Q=9 h=< 0.02403668 0.00000000 -0.02403668 0.39768638 -0.45192663 >,< 0313A2 000000 FCEC5E 32E763 C62745 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandPass_f08000_q09_b0    set 0.02403668 ; 0313A2
iir2_H_BandPass_f08000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f08000_q09_b2    set -0.02403668 ; FCEC5E
iir2_H_BandPass_f08000_q09_a1    set 0.39768638 ; 32E763
iir2_H_BandPass_f08000_q09_a2    set -0.45192663 ; C62745

; IIR2: mode=BandPass fc=10079.4 Q=9 h=< 0.02610247 0.00000000 -0.02610247 0.12731014 -0.44779505 >,< 035753 000000 FCA8AD 104BB2 C6AEA7 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandPass_f10079_q09_b0    set 0.02610247 ; 035753
iir2_H_BandPass_f10079_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f10079_q09_b2    set -0.02610247 ; FCA8AD
iir2_H_BandPass_f10079_q09_a1    set 0.12731014 ; 104BB2
iir2_H_BandPass_f10079_q09_a2    set -0.44779505 ; C6AEA7

; IIR2: mode=BandPass fc=12699.2 Q=9 h=< 0.02562133 0.00000000 -0.02562133 -0.22417111 -0.44875734 >,< 03478F 000000 FCB871 E34E5D C68F1F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandPass_f12699_q09_b0    set 0.02562133 ; 03478F
iir2_H_BandPass_f12699_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f12699_q09_b2    set -0.02562133 ; FCB871
iir2_H_BandPass_f12699_q09_a1    set -0.22417111 ; E34E5D
iir2_H_BandPass_f12699_q09_a2    set -0.44875734 ; C68F1F

; IIR2: mode=BandPass fc=16000 Q=9 h=< 0.02024366 0.00000000 -0.02024366 -0.62458180 -0.45951268 >,< 029758 000000 FD68A8 B00DB4 C52EB1 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandPass_f16000_q09_b0    set 0.02024366 ; 029758
iir2_H_BandPass_f16000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f16000_q09_b2    set -0.02024366 ; FD68A8
iir2_H_BandPass_f16000_q09_a1    set -0.62458180 ; B00DB4
iir2_H_BandPass_f16000_q09_a2    set -0.45951268 ; C52EB1

; IIR2: mode=BandPass fc=20158.7 Q=9 h=< 0.00729066 0.00000000 -0.00729066 -0.94985982 -0.48541869 >,< 00EEE6 000000 FF111A 866AFF C1DDCD >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandPass_f20158_q09_b0    set 0.00729066 ; 00EEE6
iir2_H_BandPass_f20158_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f20158_q09_b2    set -0.00729066 ; FF111A
iir2_H_BandPass_f20158_q09_a1    set -0.94985982 ; 866AFF
iir2_H_BandPass_f20158_q09_a2    set -0.48541869 ; C1DDCD

; IIR2: mode=BandPass fc=62.5 Q=1 h=< 0.00230936 0.00000000 -0.00230936 0.99534181 -0.49538127 >,< 004BAC 000000 FFB454 7F675C C09759 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandPass_f00062_q01_b0    set 0.00230936 ; 004BAC
iir2_H_BandPass_f00062_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00062_q01_b2    set -0.00230936 ; FFB454
iir2_H_BandPass_f00062_q01_a1    set 0.99534181 ; 7F675C
iir2_H_BandPass_f00062_q01_a2    set -0.49538127 ; C09759

; IIR2: mode=BandPass fc=78.7451 Q=1 h=< 0.00290610 0.00000000 -0.00290610 0.99412522 -0.49418779 >,< 005F3A 000000 FFA0C6 7F3F7F C0BE75 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandPass_f00078_q01_b0    set 0.00290610 ; 005F3A
iir2_H_BandPass_f00078_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00078_q01_b2    set -0.00290610 ; FFA0C6
iir2_H_BandPass_f00078_q01_a1    set 0.99412522 ; 7F3F7F
iir2_H_BandPass_f00078_q01_a2    set -0.49418779 ; C0BE75

; IIR2: mode=BandPass fc=99.2126 Q=1 h=< 0.00365589 0.00000000 -0.00365589 0.99258904 -0.49268821 >,< 0077CB 000000 FF8835 7F0D28 C0EF98 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandPass_f00099_q01_b0    set 0.00365589 ; 0077CB
iir2_H_BandPass_f00099_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00099_q01_b2    set -0.00365589 ; FF8835
iir2_H_BandPass_f00099_q01_a1    set 0.99258904 ; 7F0D28
iir2_H_BandPass_f00099_q01_a2    set -0.49268821 ; C0EF98

; IIR2: mode=BandPass fc=125 Q=1 h=< 0.00459731 0.00000000 -0.00459731 0.99064825 -0.49080538 >,< 0096A5 000000 FF695B 7ECD90 C12D4A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandPass_f00125_q01_b0    set 0.00459731 ; 0096A5
iir2_H_BandPass_f00125_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00125_q01_b2    set -0.00459731 ; FF695B
iir2_H_BandPass_f00125_q01_a1    set 0.99064825 ; 7ECD90
iir2_H_BandPass_f00125_q01_a2    set -0.49080538 ; C12D4A

; IIR2: mode=BandPass fc=157.49 Q=1 h=< 0.00577826 0.00000000 -0.00577826 0.98819465 -0.48844348 >,< 00BD57 000000 FF42A9 7E7D29 C17AB0 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandPass_f00157_q01_b0    set 0.00577826 ; 00BD57
iir2_H_BandPass_f00157_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00157_q01_b2    set -0.00577826 ; FF42A9
iir2_H_BandPass_f00157_q01_a1    set 0.98819465 ; 7E7D29
iir2_H_BandPass_f00157_q01_a2    set -0.48844348 ; C17AB0

; IIR2: mode=BandPass fc=198.425 Q=1 h=< 0.00725800 0.00000000 -0.00725800 0.98509021 -0.48548400 >,< 00EDD4 000000 FF122C 7E176F C1DBA9 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandPass_f00198_q01_b0    set 0.00725800 ; 00EDD4
iir2_H_BandPass_f00198_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00198_q01_b2    set -0.00725800 ; FF122C
iir2_H_BandPass_f00198_q01_a1    set 0.98509021 ; 7E176F
iir2_H_BandPass_f00198_q01_a2    set -0.48548400 ; C1DBA9

; IIR2: mode=BandPass fc=250 Q=1 h=< 0.00910943 0.00000000 -0.00910943 0.98115840 -0.48178114 >,< 012A7F 000000 FED581 7D9699 C254FF >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandPass_f00250_q01_b0    set 0.00910943 ; 012A7F
iir2_H_BandPass_f00250_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00250_q01_b2    set -0.00910943 ; FED581
iir2_H_BandPass_f00250_q01_a1    set 0.98115840 ; 7D9699
iir2_H_BandPass_f00250_q01_a2    set -0.48178114 ; C254FF

; IIR2: mode=BandPass fc=314.98 Q=1 h=< 0.01142169 0.00000000 -0.01142169 0.97617282 -0.47715663 >,< 017644 000000 FE89BC 7CF33B C2EC88 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandPass_f00314_q01_b0    set 0.01142169 ; 017644
iir2_H_BandPass_f00314_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00314_q01_b2    set -0.01142169 ; FE89BC
iir2_H_BandPass_f00314_q01_a1    set 0.97617282 ; 7CF33B
iir2_H_BandPass_f00314_q01_a2    set -0.47715663 ; C2EC88

; IIR2: mode=BandPass fc=396.85 Q=1 h=< 0.01430274 0.00000000 -0.01430274 0.96984218 -0.47139451 >,< 01D4AC 000000 FE2B54 7C23CA C3A959 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandPass_f00396_q01_b0    set 0.01430274 ; 01D4AC
iir2_H_BandPass_f00396_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00396_q01_b2    set -0.01430274 ; FE2B54
iir2_H_BandPass_f00396_q01_a1    set 0.96984218 ; 7C23CA
iir2_H_BandPass_f00396_q01_a2    set -0.47139451 ; C3A959

; IIR2: mode=BandPass fc=500 Q=1 h=< 0.01788193 0.00000000 -0.01788193 0.96179050 -0.46423613 >,< 0249F4 000000 FDB60C 7B1BF3 C493E9 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandPass_f00500_q01_b0    set 0.01788193 ; 0249F4
iir2_H_BandPass_f00500_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00500_q01_b2    set -0.01788193 ; FDB60C
iir2_H_BandPass_f00500_q01_a1    set 0.96179050 ; 7B1BF3
iir2_H_BandPass_f00500_q01_a2    set -0.46423613 ; C493E9

; IIR2: mode=BandPass fc=629.961 Q=1 h=< 0.02231172 0.00000000 -0.02231172 0.95153097 -0.45537655 >,< 02DB1C 000000 FD24E4 79CBC4 C5B639 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandPass_f00629_q01_b0    set 0.02231172 ; 02DB1C
iir2_H_BandPass_f00629_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00629_q01_b2    set -0.02231172 ; FD24E4
iir2_H_BandPass_f00629_q01_a1    set 0.95153097 ; 79CBC4
iir2_H_BandPass_f00629_q01_a2    set -0.45537655 ; C5B639

; IIR2: mode=BandPass fc=793.701 Q=1 h=< 0.02776799 0.00000000 -0.02776799 0.93843163 -0.44446401 >,< 038DE6 000000 FC721A 781E87 C71BCE >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandPass_f00793_q01_b0    set 0.02776799 ; 038DE6
iir2_H_BandPass_f00793_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00793_q01_b2    set -0.02776799 ; FC721A
iir2_H_BandPass_f00793_q01_a1    set 0.93843163 ; 781E87
iir2_H_BandPass_f00793_q01_a2    set -0.44446401 ; C71BCE

; IIR2: mode=BandPass fc=1000 Q=1 h=< 0.03444743 0.00000000 -0.03444743 0.92167069 -0.43110514 >,< 0468C6 000000 FB973A 75F94E C8D18C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandPass_f01000_q01_b0    set 0.03444743 ; 0468C6
iir2_H_BandPass_f01000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01000_q01_b2    set -0.03444743 ; FB973A
iir2_H_BandPass_f01000_q01_a1    set 0.92167069 ; 75F94E
iir2_H_BandPass_f01000_q01_a2    set -0.43110514 ; C8D18C

; IIR2: mode=BandPass fc=1259.92 Q=1 h=< 0.04255994 0.00000000 -0.04255994 0.90017945 -0.41488011 >,< 05729A 000000 FA8D66 733914 CAE536 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandPass_f01259_q01_b0    set 0.04255994 ; 05729A
iir2_H_BandPass_f01259_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01259_q01_b2    set -0.04255994 ; FA8D66
iir2_H_BandPass_f01259_q01_a1    set 0.90017945 ; 733914
iir2_H_BandPass_f01259_q01_a2    set -0.41488011 ; CAE536

; IIR2: mode=BandPass fc=1587.4 Q=1 h=< 0.05231313 0.00000000 -0.05231313 0.87257147 -0.39537375 >,< 06B232 000000 F94DCE 6FB06C CD6465 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandPass_f01587_q01_b0    set 0.05231313 ; 06B232
iir2_H_BandPass_f01587_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01587_q01_b2    set -0.05231313 ; F94DCE
iir2_H_BandPass_f01587_q01_a1    set 0.87257147 ; 6FB06C
iir2_H_BandPass_f01587_q01_a2    set -0.39537375 ; CD6465

; IIR2: mode=BandPass fc=2000 Q=1 h=< 0.06388465 0.00000000 -0.06388465 0.83705819 -0.37223069 >,< 082D5F 000000 F7D2A1 6B24B9 D05ABF >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandPass_f02000_q01_b0    set 0.06388465 ; 082D5F
iir2_H_BandPass_f02000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02000_q01_b2    set -0.06388465 ; F7D2A1
iir2_H_BandPass_f02000_q01_a1    set 0.83705819 ; 6B24B9
iir2_H_BandPass_f02000_q01_a2    set -0.37223069 ; D05ABF

; IIR2: mode=BandPass fc=2519.84 Q=1 h=< 0.07737745 0.00000000 -0.07737745 0.79135461 -0.34524509 >,< 09E781 000000 F6187F 654B1B D3CF03 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandPass_f02519_q01_b0    set 0.07737745 ; 09E781
iir2_H_BandPass_f02519_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02519_q01_b2    set -0.07737745 ; F6187F
iir2_H_BandPass_f02519_q01_a1    set 0.79135461 ; 654B1B
iir2_H_BandPass_f02519_q01_a2    set -0.34524509 ; D3CF03

; IIR2: mode=BandPass fc=3174.8 Q=1 h=< 0.09275176 0.00000000 -0.09275176 0.73258259 -0.31449647 >,< 0BDF4A 000000 F420B6 5DC544 D7BE95 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandPass_f03174_q01_b0    set 0.09275176 ; 0BDF4A
iir2_H_BandPass_f03174_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f03174_q01_b2    set -0.09275176 ; F420B6
iir2_H_BandPass_f03174_q01_a1    set 0.73258259 ; 5DC544
iir2_H_BandPass_f03174_q01_a2    set -0.31449647 ; D7BE95

; IIR2: mode=BandPass fc=4000 Q=1 h=< 0.10972788 0.00000000 -0.10972788 0.65718163 -0.28054424 >,< 0E0B90 000000 F1F470 541E87 DC1721 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandPass_f04000_q01_b0    set 0.10972788 ; 0E0B90
iir2_H_BandPass_f04000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f04000_q01_b2    set -0.10972788 ; F1F470
iir2_H_BandPass_f04000_q01_a1    set 0.65718163 ; 541E87
iir2_H_BandPass_f04000_q01_a2    set -0.28054424 ; DC1721

; IIR2: mode=BandPass fc=5039.68 Q=1 h=< 0.12765236 0.00000000 -0.12765236 0.56083081 -0.24469528 >,< 1056E9 000000 EFA917 47C94E E0ADD4 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandPass_f05039_q01_b0    set 0.12765236 ; 1056E9
iir2_H_BandPass_f05039_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f05039_q01_b2    set -0.12765236 ; EFA917
iir2_H_BandPass_f05039_q01_a1    set 0.56083081 ; 47C94E
iir2_H_BandPass_f05039_q01_a2    set -0.24469528 ; E0ADD4

; IIR2: mode=BandPass fc=6349.6 Q=1 h=< 0.14531327 0.00000000 -0.14531327 0.43835645 -0.20937345 >,< 1299A0 000000 ED6660 381C10 E53341 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandPass_f06349_q01_b0    set 0.14531327 ; 1299A0
iir2_H_BandPass_f06349_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f06349_q01_b2    set -0.14531327 ; ED6660
iir2_H_BandPass_f06349_q01_a1    set 0.43835645 ; 381C10
iir2_H_BandPass_f06349_q01_a2    set -0.20937345 ; E53341

; IIR2: mode=BandPass fc=8000 Q=1 h=< 0.16065865 0.00000000 -0.16065865 0.28353326 -0.17868269 >,< 149076 000000 EB6F8A 244AD1 E920ED >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandPass_f08000_q01_b0    set 0.16065865 ; 149076
iir2_H_BandPass_f08000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f08000_q01_b2    set -0.16065865 ; EB6F8A
iir2_H_BandPass_f08000_q01_a1    set 0.28353326 ; 244AD1
iir2_H_BandPass_f08000_q01_a2    set -0.17868269 ; E920ED

; IIR2: mode=BandPass fc=10079.4 Q=1 h=< 0.17026582 0.00000000 -0.17026582 0.08858140 -0.15946836 >,< 15CB45 000000 EA34BB 0B56A2 EB968B >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandPass_f10079_q01_b0    set 0.17026582 ; 15CB45
iir2_H_BandPass_f10079_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f10079_q01_b2    set -0.17026582 ; EA34BB
iir2_H_BandPass_f10079_q01_a1    set 0.08858140 ; 0B56A2
iir2_H_BandPass_f10079_q01_a2    set -0.15946836 ; EB968B

; IIR2: mode=BandPass fc=12699.2 Q=1 h=< 0.16806977 0.00000000 -0.16806977 -0.15685606 -0.16386045 >,< 15834F 000000 EA7CB1 EBEC24 EB069F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandPass_f12699_q01_b0    set 0.16806977 ; 15834F
iir2_H_BandPass_f12699_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f12699_q01_b2    set -0.16806977 ; EA7CB1
iir2_H_BandPass_f12699_q01_a1    set -0.15685606 ; EBEC24
iir2_H_BandPass_f12699_q01_a2    set -0.16386045 ; EB069F

; IIR2: mode=BandPass fc=16000 Q=1 h=< 0.14172608 0.00000000 -0.14172608 -0.46642712 -0.21654784 >,< 122414 000000 EDDBEC C44C1E E44829 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandPass_f16000_q01_b0    set 0.14172608 ; 122414
iir2_H_BandPass_f16000_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f16000_q01_b2    set -0.14172608 ; EDDBEC
iir2_H_BandPass_f16000_q01_a1    set -0.46642712 ; C44C1E
iir2_H_BandPass_f16000_q01_a2    set -0.21654784 ; E44829

; IIR2: mode=BandPass fc=20158.7 Q=1 h=< 0.06091086 0.00000000 -0.06091086 -0.84648918 -0.37817827 >,< 07CBED 000000 F83413 93A63E CF97DB >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandPass_f20158_q01_b0    set 0.06091086 ; 07CBED
iir2_H_BandPass_f20158_q01_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f20158_q01_b2    set -0.06091086 ; F83413
iir2_H_BandPass_f20158_q01_a1    set -0.84648918 ; 93A63E
iir2_H_BandPass_f20158_q01_a2    set -0.37817827 ; CF97DB

; IIR2: mode=BandPass fc=62.5 Q=3 h=< 0.00074438 0.00000000 -0.00074438 0.99847165 -0.49851124 >,< 001864 000000 FFE79C 7FCDEB C030C9 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandPass_f00062_q03_b0    set 0.00074438 ; 001864
iir2_H_BandPass_f00062_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00062_q03_b2    set -0.00074438 ; FFE79C
iir2_H_BandPass_f00062_q03_a1    set 0.99847165 ; 7FCDEB
iir2_H_BandPass_f00062_q03_a2    set -0.49851124 ; C030C9

; IIR2: mode=BandPass fc=78.7451 Q=3 h=< 0.00093749 0.00000000 -0.00093749 0.99806220 -0.49812501 >,< 001EB8 000000 FFE148 7FC080 C03D71 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandPass_f00078_q03_b0    set 0.00093749 ; 001EB8
iir2_H_BandPass_f00078_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00078_q03_b2    set -0.00093749 ; FFE148
iir2_H_BandPass_f00078_q03_a1    set 0.99806220 ; 7FC080
iir2_H_BandPass_f00078_q03_a2    set -0.49812501 ; C03D71

; IIR2: mode=BandPass fc=99.2126 Q=3 h=< 0.00118058 0.00000000 -0.00118058 0.99753918 -0.49763885 >,< 0026AF 000000 FFD951 7FAF5D C04D5F >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandPass_f00099_q03_b0    set 0.00118058 ; 0026AF
iir2_H_BandPass_f00099_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00099_q03_b2    set -0.00118058 ; FFD951
iir2_H_BandPass_f00099_q03_a1    set 0.99753918 ; 7FAF5D
iir2_H_BandPass_f00099_q03_a2    set -0.49763885 ; C04D5F

; IIR2: mode=BandPass fc=125 Q=3 h=< 0.00148649 0.00000000 -0.00148649 0.99686890 -0.49702701 >,< 0030B5 000000 FFCF4B 7F9966 C0616C >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandPass_f00125_q03_b0    set 0.00148649 ; 0030B5
iir2_H_BandPass_f00125_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00125_q03_b2    set -0.00148649 ; FFCF4B
iir2_H_BandPass_f00125_q03_a1    set 0.99686890 ; 7F9966
iir2_H_BandPass_f00125_q03_a2    set -0.49702701 ; C0616C

; IIR2: mode=BandPass fc=157.49 Q=3 h=< 0.00187136 0.00000000 -0.00187136 0.99600649 -0.49625728 >,< 003D52 000000 FFC2AE 7F7D24 C07AA5 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandPass_f00157_q03_b0    set 0.00187136 ; 003D52
iir2_H_BandPass_f00157_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00157_q03_b2    set -0.00187136 ; FFC2AE
iir2_H_BandPass_f00157_q03_a1    set 0.99600649 ; 7F7D24
iir2_H_BandPass_f00157_q03_a2    set -0.49625728 ; C07AA5

; IIR2: mode=BandPass fc=198.425 Q=3 h=< 0.00235536 0.00000000 -0.00235536 0.99489157 -0.49528928 >,< 004D2E 000000 FFB2D2 7F589B C09A5D >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandPass_f00198_q03_b0    set 0.00235536 ; 004D2E
iir2_H_BandPass_f00198_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00198_q03_b2    set -0.00235536 ; FFB2D2
iir2_H_BandPass_f00198_q03_a1    set 0.99489157 ; 7F589B
iir2_H_BandPass_f00198_q03_a2    set -0.49528928 ; C09A5D

; IIR2: mode=BandPass fc=250 Q=3 h=< 0.00296371 0.00000000 -0.00296371 0.99344206 -0.49407259 >,< 00611D 000000 FF9EE3 7F291C C0C23B >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandPass_f00250_q03_b0    set 0.00296371 ; 00611D
iir2_H_BandPass_f00250_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00250_q03_b2    set -0.00296371 ; FF9EE3
iir2_H_BandPass_f00250_q03_a1    set 0.99344206 ; 7F291C
iir2_H_BandPass_f00250_q03_a2    set -0.49407259 ; C0C23B

; IIR2: mode=BandPass fc=314.98 Q=3 h=< 0.00372783 0.00000000 -0.00372783 0.99154504 -0.49254434 >,< 007A27 000000 FF85D9 7EEAF2 C0F44F >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandPass_f00314_q03_b0    set 0.00372783 ; 007A27
iir2_H_BandPass_f00314_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00314_q03_b2    set -0.00372783 ; FF85D9
iir2_H_BandPass_f00314_q03_a1    set 0.99154504 ; 7EEAF2
iir2_H_BandPass_f00314_q03_a2    set -0.49254434 ; C0F44F

; IIR2: mode=BandPass fc=396.85 Q=3 h=< 0.00468677 0.00000000 -0.00468677 0.98904338 -0.49062645 >,< 009993 000000 FF666D 7E98F9 C13327 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandPass_f00396_q03_b0    set 0.00468677 ; 009993
iir2_H_BandPass_f00396_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00396_q03_b2    set -0.00468677 ; FF666D
iir2_H_BandPass_f00396_q03_a1    set 0.98904338 ; 7E98F9
iir2_H_BandPass_f00396_q03_a2    set -0.49062645 ; C13327

; IIR2: mode=BandPass fc=500 Q=3 h=< 0.00588879 0.00000000 -0.00588879 0.98571594 -0.48822242 >,< 00C0F6 000000 FF3F0A 7E2BF0 C181EE >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandPass_f00500_q03_b0    set 0.00588879 ; 00C0F6
iir2_H_BandPass_f00500_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00500_q03_b2    set -0.00588879 ; FF3F0A
iir2_H_BandPass_f00500_q03_a1    set 0.98571594 ; 7E2BF0
iir2_H_BandPass_f00500_q03_a2    set -0.48822242 ; C181EE

; IIR2: mode=BandPass fc=629.961 Q=3 h=< 0.00739315 0.00000000 -0.00739315 0.98124802 -0.48521371 >,< 00F242 000000 FF0DBE 7D9989 C1E485 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandPass_f00629_q03_b0    set 0.00739315 ; 00F242
iir2_H_BandPass_f00629_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00629_q03_b2    set -0.00739315 ; FF0DBE
iir2_H_BandPass_f00629_q03_a1    set 0.98124802 ; 7D9989
iir2_H_BandPass_f00629_q03_a2    set -0.48521371 ; C1E485

; IIR2: mode=BandPass fc=793.701 Q=3 h=< 0.00927193 0.00000000 -0.00927193 0.97518748 -0.48145613 >,< 012FD2 000000 FED02E 7CD2F1 C25FA6 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandPass_f00793_q03_b0    set 0.00927193 ; 012FD2
iir2_H_BandPass_f00793_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00793_q03_b2    set -0.00927193 ; FED02E
iir2_H_BandPass_f00793_q03_a1    set 0.97518748 ; 7CD2F1
iir2_H_BandPass_f00793_q03_a2    set -0.48145613 ; C25FA6

; IIR2: mode=BandPass fc=1000 Q=3 h=< 0.01161165 0.00000000 -0.01161165 0.96687949 -0.47677671 >,< 017C7D 000000 FE8383 7BC2B5 C2F8FB >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandPass_f01000_q03_b0    set 0.01161165 ; 017C7D
iir2_H_BandPass_f01000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01000_q03_b2    set -0.01161165 ; FE8383
iir2_H_BandPass_f01000_q03_a1    set 0.96687949 ; 7BC2B5
iir2_H_BandPass_f01000_q03_a2    set -0.47677671 ; C2F8FB

; IIR2: mode=BandPass fc=1259.92 Q=3 h=< 0.01451390 0.00000000 -0.01451390 0.95537023 -0.47097221 >,< 01DB97 000000 FE2469 7A4992 C3B72F >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandPass_f01259_q03_b0    set 0.01451390 ; 01DB97
iir2_H_BandPass_f01259_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01259_q03_b2    set -0.01451390 ; FE2469
iir2_H_BandPass_f01259_q03_a1    set 0.95537023 ; 7A4992
iir2_H_BandPass_f01259_q03_a2    set -0.47097221 ; C3B72F

; IIR2: mode=BandPass fc=1587.4 Q=3 h=< 0.01809418 0.00000000 -0.01809418 0.93926647 -0.46381164 >,< 0250E8 000000 FDAF18 7839E2 C4A1D2 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandPass_f01587_q03_b0    set 0.01809418 ; 0250E8
iir2_H_BandPass_f01587_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01587_q03_b2    set -0.01809418 ; FDAF18
iir2_H_BandPass_f01587_q03_a1    set 0.93926647 ; 7839E2
iir2_H_BandPass_f01587_q03_a2    set -0.46381164 ; C4A1D2

; IIR2: mode=BandPass fc=2000 Q=3 h=< 0.02247658 0.00000000 -0.02247658 0.91653480 -0.45504684 >,< 02E083 000000 FD1F7D 755103 C5C107 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandPass_f02000_q03_b0    set 0.02247658 ; 02E083
iir2_H_BandPass_f02000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02000_q03_b2    set -0.02247658 ; FD1F7D
iir2_H_BandPass_f02000_q03_a1    set 0.91653480 ; 755103
iir2_H_BandPass_f02000_q03_a2    set -0.45504684 ; C5C107

; IIR2: mode=BandPass fc=2519.84 Q=3 h=< 0.02778086 0.00000000 -0.02778086 0.88422351 -0.44443828 >,< 038E52 000000 FC71AE 712E3C C71CA6 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandPass_f02519_q03_b0    set 0.02778086 ; 038E52
iir2_H_BandPass_f02519_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02519_q03_b2    set -0.02778086 ; FC71AE
iir2_H_BandPass_f02519_q03_a1    set 0.88422351 ; 712E3C
iir2_H_BandPass_f02519_q03_a2    set -0.44443828 ; C71CA6

; IIR2: mode=BandPass fc=3174.8 Q=3 h=< 0.03409573 0.00000000 -0.03409573 0.83809658 -0.43180854 >,< 045D3F 000000 FBA2C1 6B46BF C8BA80 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandPass_f03174_q03_b0    set 0.03409573 ; 045D3F
iir2_H_BandPass_f03174_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f03174_q03_b2    set -0.03409573 ; FBA2C1
iir2_H_BandPass_f03174_q03_a1    set 0.83809658 ; 6B46BF
iir2_H_BandPass_f03174_q03_a2    set -0.43180854 ; C8BA80

; IIR2: mode=BandPass fc=4000 Q=3 h=< 0.04142830 0.00000000 -0.04142830 0.77219172 -0.41714341 >,< 054D85 000000 FAB27B 62D72D CA9B0C >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandPass_f04000_q03_b0    set 0.04142830 ; 054D85
iir2_H_BandPass_f04000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f04000_q03_b2    set -0.04142830 ; FAB27B
iir2_H_BandPass_f04000_q03_a1    set 0.77219172 ; 62D72D
iir2_H_BandPass_f04000_q03_a2    set -0.41714341 ; CA9B0C

; IIR2: mode=BandPass fc=5039.68 Q=3 h=< 0.04961413 0.00000000 -0.04961413 0.67837216 -0.40077175 >,< 0659C1 000000 F9A63F 56D4E6 CCB383 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandPass_f05039_q03_b0    set 0.04961413 ; 0659C1
iir2_H_BandPass_f05039_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f05039_q03_b2    set -0.04961413 ; F9A63F
iir2_H_BandPass_f05039_q03_a1    set 0.67837216 ; 56D4E6
iir2_H_BandPass_f05039_q03_a2    set -0.40077175 ; CCB383

; IIR2: mode=BandPass fc=6349.6 Q=3 h=< 0.05816489 0.00000000 -0.05816489 0.54606291 -0.38367022 >,< 0771F2 000000 F88E0E 45E563 CEE3E5 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandPass_f06349_q03_b0    set 0.05816489 ; 0771F2
iir2_H_BandPass_f06349_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f06349_q03_b2    set -0.05816489 ; F88E0E
iir2_H_BandPass_f06349_q03_a1    set 0.54606291 ; 45E563
iir2_H_BandPass_f06349_q03_a2    set -0.38367022 ; CEE3E5

; IIR2: mode=BandPass fc=8000 Q=3 h=< 0.06602025 0.00000000 -0.06602025 0.36260743 -0.36795950 >,< 08735A 000000 F78CA6 2E69EB D0E6B4 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandPass_f08000_q03_b0    set 0.06602025 ; 08735A
iir2_H_BandPass_f08000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f08000_q03_b2    set -0.06602025 ; F78CA6
iir2_H_BandPass_f08000_q03_a1    set 0.36260743 ; 2E69EB
iir2_H_BandPass_f08000_q03_a2    set -0.36795950 ; D0E6B4

; IIR2: mode=BandPass fc=10079.4 Q=3 h=< 0.07115483 0.00000000 -0.07115483 0.11520706 -0.35769034 >,< 091B99 000000 F6E467 0EBF1A D23734 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandPass_f10079_q03_b0    set 0.07115483 ; 091B99
iir2_H_BandPass_f10079_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f10079_q03_b2    set -0.07115483 ; F6E467
iir2_H_BandPass_f10079_q03_a1    set 0.11520706 ; 0EBF1A
iir2_H_BandPass_f10079_q03_a2    set -0.35769034 ; D23734

; IIR2: mode=BandPass fc=12699.2 Q=3 h=< 0.06996585 0.00000000 -0.06996585 -0.20321579 -0.36006830 >,< 08F4A4 000000 F70B5C E5FD07 D1E949 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandPass_f12699_q03_b0    set 0.06996585 ; 08F4A4
iir2_H_BandPass_f12699_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f12699_q03_b2    set -0.06996585 ; F70B5C
iir2_H_BandPass_f12699_q03_a1    set -0.20321579 ; E5FD07
iir2_H_BandPass_f12699_q03_a2    set -0.36006830 ; D1E949

; IIR2: mode=BandPass fc=16000 Q=3 h=< 0.05638702 0.00000000 -0.05638702 -0.57752773 -0.38722595 >,< 0737B0 000000 F8C850 B61393 CE6F62 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandPass_f16000_q03_b0    set 0.05638702 ; 0737B0
iir2_H_BandPass_f16000_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f16000_q03_b2    set -0.05638702 ; F8C850
iir2_H_BandPass_f16000_q03_a1    set -0.57752773 ; B61393
iir2_H_BandPass_f16000_q03_a2    set -0.38722595 ; CE6F62

; IIR2: mode=BandPass fc=20158.7 Q=3 h=< 0.02133601 0.00000000 -0.02133601 -0.92278277 -0.45732798 >,< 02BB23 000000 FD44DD 89E241 C57647 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandPass_f20158_q03_b0    set 0.02133601 ; 02BB23
iir2_H_BandPass_f20158_q03_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f20158_q03_b2    set -0.02133601 ; FD44DD
iir2_H_BandPass_f20158_q03_a1    set -0.92278277 ; 89E241
iir2_H_BandPass_f20158_q03_a2    set -0.45732798 ; C57647

; IIR2: mode=BandPass fc=62.5 Q=9 h=< 0.00024736 0.00000000 -0.00024736 0.99946566 -0.49950529 >,< 00081A 000000 FFF7E6 7FEE7D C01036 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandPass_f00062_q09_b0    set 0.00024736 ; 00081A
iir2_H_BandPass_f00062_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00062_q09_b2    set -0.00024736 ; FFF7E6
iir2_H_BandPass_f00062_q09_a1    set 0.99946566 ; 7FEE7D
iir2_H_BandPass_f00062_q09_a2    set -0.49950529 ; C01036

; IIR2: mode=BandPass fc=78.7451 Q=9 h=< 0.00031161 0.00000000 -0.00031161 0.99931389 -0.49937679 >,< 000A35 000000 FFF5CB 7FE984 C0146C >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandPass_f00078_q09_b0    set 0.00031161 ; 000A35
iir2_H_BandPass_f00078_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00078_q09_b2    set -0.00031161 ; FFF5CB
iir2_H_BandPass_f00078_q09_a1    set 0.99931389 ; 7FE984
iir2_H_BandPass_f00078_q09_a2    set -0.49937679 ; C0146C

; IIR2: mode=BandPass fc=99.2126 Q=9 h=< 0.00039253 0.00000000 -0.00039253 0.99911511 -0.49921494 >,< 000CDC 000000 FFF324 7FE301 C019BA >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandPass_f00099_q09_b0    set 0.00039253 ; 000CDC
iir2_H_BandPass_f00099_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00099_q09_b2    set -0.00039253 ; FFF324
iir2_H_BandPass_f00099_q09_a1    set 0.99911511 ; 7FE301
iir2_H_BandPass_f00099_q09_a2    set -0.49921494 ; C019BA

; IIR2: mode=BandPass fc=125 Q=9 h=< 0.00049445 0.00000000 -0.00049445 0.99885268 -0.49901111 >,< 001033 000000 FFEFCD 7FDA67 C02068 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandPass_f00125_q09_b0    set 0.00049445 ; 001033
iir2_H_BandPass_f00125_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00125_q09_b2    set -0.00049445 ; FFEFCD
iir2_H_BandPass_f00125_q09_a1    set 0.99885268 ; 7FDA67
iir2_H_BandPass_f00125_q09_a2    set -0.49901111 ; C02068

; IIR2: mode=BandPass fc=157.49 Q=9 h=< 0.00062278 0.00000000 -0.00062278 0.99850301 -0.49875443 >,< 001468 000000 FFEB98 7FCEF2 C028D1 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandPass_f00157_q09_b0    set 0.00062278 ; 001468
iir2_H_BandPass_f00157_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00157_q09_b2    set -0.00062278 ; FFEB98
iir2_H_BandPass_f00157_q09_a1    set 0.99850301 ; 7FCEF2
iir2_H_BandPass_f00157_q09_a2    set -0.49875443 ; C028D1

; IIR2: mode=BandPass fc=198.425 Q=9 h=< 0.00078437 0.00000000 -0.00078437 0.99803230 -0.49843127 >,< 0019B3 000000 FFE64D 7FBF85 C03368 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandPass_f00198_q09_b0    set 0.00078437 ; 0019B3
iir2_H_BandPass_f00198_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00198_q09_b2    set -0.00078437 ; FFE64D
iir2_H_BandPass_f00198_q09_a1    set 0.99803230 ; 7FBF85
iir2_H_BandPass_f00198_q09_a2    set -0.49843127 ; C03368

; IIR2: mode=BandPass fc=250 Q=9 h=< 0.00098776 0.00000000 -0.00098776 0.99739144 -0.49802448 >,< 00205D 000000 FFDFA3 7FAA86 C040BC >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandPass_f00250_q09_b0    set 0.00098776 ; 00205D
iir2_H_BandPass_f00250_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00250_q09_b2    set -0.00098776 ; FFDFA3
iir2_H_BandPass_f00250_q09_a1    set 0.99739144 ; 7FAA86
iir2_H_BandPass_f00250_q09_a2    set -0.49802448 ; C040BC

; IIR2: mode=BandPass fc=314.98 Q=9 h=< 0.00124371 0.00000000 -0.00124371 0.99650828 -0.49751259 >,< 0028C0 000000 FFD740 7F8D95 C05182 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandPass_f00314_q09_b0    set 0.00124371 ; 0028C0
iir2_H_BandPass_f00314_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00314_q09_b2    set -0.00124371 ; FFD740
iir2_H_BandPass_f00314_q09_a1    set 0.99650828 ; 7F8D95
iir2_H_BandPass_f00314_q09_a2    set -0.49751259 ; C05182

; IIR2: mode=BandPass fc=396.85 Q=9 h=< 0.00156565 0.00000000 -0.00156565 0.99527565 -0.49686870 >,< 00334D 000000 FFCCB3 7F6531 C0669C >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandPass_f00396_q09_b0    set 0.00156565 ; 00334D
iir2_H_BandPass_f00396_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00396_q09_b2    set -0.00156565 ; FFCCB3
iir2_H_BandPass_f00396_q09_a1    set 0.99527565 ; 7F6531
iir2_H_BandPass_f00396_q09_a2    set -0.49686870 ; C0669C

; IIR2: mode=BandPass fc=500 Q=9 h=< 0.00197038 0.00000000 -0.00197038 0.99353289 -0.49605924 >,< 004090 000000 FFBF70 7F2C16 C08122 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandPass_f00500_q09_b0    set 0.00197038 ; 004090
iir2_H_BandPass_f00500_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00500_q09_b2    set -0.00197038 ; FFBF70
iir2_H_BandPass_f00500_q09_a1    set 0.99353289 ; 7F2C16
iir2_H_BandPass_f00500_q09_a2    set -0.49605924 ; C08122

; IIR2: mode=BandPass fc=629.961 Q=9 h=< 0.00247876 0.00000000 -0.00247876 0.99103724 -0.49504249 >,< 005139 000000 FFAEC7 7EDA4F C0A273 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandPass_f00629_q09_b0    set 0.00247876 ; 005139
iir2_H_BandPass_f00629_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00629_q09_b2    set -0.00247876 ; FFAEC7
iir2_H_BandPass_f00629_q09_a1    set 0.99103724 ; 7EDA4F
iir2_H_BandPass_f00629_q09_a2    set -0.49504249 ; C0A273

; IIR2: mode=BandPass fc=793.701 Q=9 h=< 0.00311657 0.00000000 -0.00311657 0.98741958 -0.49376685 >,< 00661F 000000 FF99E1 7E63C3 C0CC40 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandPass_f00793_q09_b0    set 0.00311657 ; 00661F
iir2_H_BandPass_f00793_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f00793_q09_b2    set -0.00311657 ; FF99E1
iir2_H_BandPass_f00793_q09_a1    set 0.98741958 ; 7E63C3
iir2_H_BandPass_f00793_q09_a2    set -0.49376685 ; C0CC40

; IIR2: mode=BandPass fc=1000 Q=9 h=< 0.00391541 0.00000000 -0.00391541 0.98211599 -0.49216917 >,< 00804C 000000 FF7FB4 7DB5FA C1009A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandPass_f01000_q09_b0    set 0.00391541 ; 00804C
iir2_H_BandPass_f01000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01000_q09_b2    set -0.00391541 ; FF7FB4
iir2_H_BandPass_f01000_q09_a1    set 0.98211599 ; 7DB5FA
iir2_H_BandPass_f01000_q09_a2    set -0.49216917 ; C1009A

; IIR2: mode=BandPass fc=1259.92 Q=9 h=< 0.00491340 0.00000000 -0.00491340 0.97426271 -0.49017321 >,< 00A100 000000 FF5F00 7CB4A4 C14201 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandPass_f01259_q09_b0    set 0.00491340 ; 00A100
iir2_H_BandPass_f01259_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01259_q09_b2    set -0.00491340 ; FF5F00
iir2_H_BandPass_f01259_q09_a1    set 0.97426271 ; 7CB4A4
iir2_H_BandPass_f01259_q09_a2    set -0.49017321 ; C14201

; IIR2: mode=BandPass fc=1587.4 Q=9 h=< 0.00615546 0.00000000 -0.00615546 0.96253583 -0.48768909 >,< 00C9B3 000000 FF364D 7B3460 C19368 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandPass_f01587_q09_b0    set 0.00615546 ; 00C9B3
iir2_H_BandPass_f01587_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f01587_q09_b2    set -0.00615546 ; FF364D
iir2_H_BandPass_f01587_q09_a1    set 0.96253583 ; 7B3460
iir2_H_BandPass_f01587_q09_a2    set -0.48768909 ; C19368

; IIR2: mode=BandPass fc=2000 Q=9 h=< 0.00769246 0.00000000 -0.00769246 0.94491070 -0.48461508 >,< 00FC11 000000 FF03EF 78F2D5 C1F822 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandPass_f02000_q09_b0    set 0.00769246 ; 00FC11
iir2_H_BandPass_f02000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02000_q09_b2    set -0.00769246 ; FF03EF
iir2_H_BandPass_f02000_q09_a1    set 0.94491070 ; 78F2D5
iir2_H_BandPass_f02000_q09_a2    set -0.48461508 ; C1F822

; IIR2: mode=BandPass fc=2519.84 Q=9 h=< 0.00957780 0.00000000 -0.00957780 0.91830849 -0.48084441 >,< 0139D8 000000 FEC628 758B22 C273B1 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandPass_f02519_q09_b0    set 0.00957780 ; 0139D8
iir2_H_BandPass_f02519_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f02519_q09_b2    set -0.00957780 ; FEC628
iir2_H_BandPass_f02519_q09_a1    set 0.91830849 ; 758B22
iir2_H_BandPass_f02519_q09_a2    set -0.48084441 ; C273B1

; IIR2: mode=BandPass fc=3174.8 Q=9 h=< 0.01185884 0.00000000 -0.01185884 0.87809764 -0.47628233 >,< 018497 000000 FE7B69 706581 C3092F >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandPass_f03174_q09_b0    set 0.01185884 ; 018497
iir2_H_BandPass_f03174_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f03174_q09_b2    set -0.01185884 ; FE7B69
iir2_H_BandPass_f03174_q09_a1    set 0.87809764 ; 706581
iir2_H_BandPass_f03174_q09_a2    set -0.47628233 ; C3092F

; IIR2: mode=BandPass fc=4000 Q=9 h=< 0.01455861 0.00000000 -0.01455861 0.81743775 -0.47088278 >,< 01DD0E 000000 FE22F2 68A1CD C3BA1D >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandPass_f04000_q09_b0    set 0.01455861 ; 01DD0E
iir2_H_BandPass_f04000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f04000_q09_b2    set -0.01455861 ; FE22F2
iir2_H_BandPass_f04000_q09_a1    set 0.81743775 ; 68A1CD
iir2_H_BandPass_f04000_q09_a2    set -0.47088278 ; C3BA1D

; IIR2: mode=BandPass fc=5039.68 Q=9 h=< 0.01763948 0.00000000 -0.01763948 0.72653245 -0.46472105 >,< 024202 000000 FDBDFE 5CFF04 C48406 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandPass_f05039_q09_b0    set 0.01763948 ; 024202
iir2_H_BandPass_f05039_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f05039_q09_b2    set -0.01763948 ; FDBDFE
iir2_H_BandPass_f05039_q09_a1    set 0.72653245 ; 5CFF04
iir2_H_BandPass_f05039_q09_a2    set -0.46472105 ; C48406

; IIR2: mode=BandPass fc=6349.6 Q=9 h=< 0.02093572 0.00000000 -0.02093572 0.59207436 -0.45812856 >,< 02AE05 000000 FD51FB 4BC917 C55C0B >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandPass_f06349_q09_b0    set 0.02093572 ; 02AE05
iir2_H_BandPass_f06349_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f06349_q09_b2    set -0.02093572 ; FD51FB
iir2_H_BandPass_f06349_q09_a1    set 0.59207436 ; 4BC917
iir2_H_BandPass_f06349_q09_a2    set -0.45812856 ; C55C0B

; IIR2: mode=BandPass fc=8000 Q=9 h=< 0.02403668 0.00000000 -0.02403668 0.39768638 -0.45192663 >,< 0313A2 000000 FCEC5E 32E763 C62745 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandPass_f08000_q09_b0    set 0.02403668 ; 0313A2
iir2_H_BandPass_f08000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f08000_q09_b2    set -0.02403668 ; FCEC5E
iir2_H_BandPass_f08000_q09_a1    set 0.39768638 ; 32E763
iir2_H_BandPass_f08000_q09_a2    set -0.45192663 ; C62745

; IIR2: mode=BandPass fc=10079.4 Q=9 h=< 0.02610247 0.00000000 -0.02610247 0.12731014 -0.44779505 >,< 035753 000000 FCA8AD 104BB2 C6AEA7 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandPass_f10079_q09_b0    set 0.02610247 ; 035753
iir2_H_BandPass_f10079_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f10079_q09_b2    set -0.02610247 ; FCA8AD
iir2_H_BandPass_f10079_q09_a1    set 0.12731014 ; 104BB2
iir2_H_BandPass_f10079_q09_a2    set -0.44779505 ; C6AEA7

; IIR2: mode=BandPass fc=12699.2 Q=9 h=< 0.02562133 0.00000000 -0.02562133 -0.22417111 -0.44875734 >,< 03478F 000000 FCB871 E34E5D C68F1F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandPass_f12699_q09_b0    set 0.02562133 ; 03478F
iir2_H_BandPass_f12699_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f12699_q09_b2    set -0.02562133 ; FCB871
iir2_H_BandPass_f12699_q09_a1    set -0.22417111 ; E34E5D
iir2_H_BandPass_f12699_q09_a2    set -0.44875734 ; C68F1F

; IIR2: mode=BandPass fc=16000 Q=9 h=< 0.02024366 0.00000000 -0.02024366 -0.62458180 -0.45951268 >,< 029758 000000 FD68A8 B00DB4 C52EB1 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandPass_f16000_q09_b0    set 0.02024366 ; 029758
iir2_H_BandPass_f16000_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f16000_q09_b2    set -0.02024366 ; FD68A8
iir2_H_BandPass_f16000_q09_a1    set -0.62458180 ; B00DB4
iir2_H_BandPass_f16000_q09_a2    set -0.45951268 ; C52EB1

; IIR2: mode=BandPass fc=20158.7 Q=9 h=< 0.00729066 0.00000000 -0.00729066 -0.94985982 -0.48541869 >,< 00EEE6 000000 FF111A 866AFF C1DDCD >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandPass_f20158_q09_b0    set 0.00729066 ; 00EEE6
iir2_H_BandPass_f20158_q09_b1    set 0.00000000 ; 000000
iir2_H_BandPass_f20158_q09_b2    set -0.00729066 ; FF111A
iir2_H_BandPass_f20158_q09_a1    set -0.94985982 ; 866AFF
iir2_H_BandPass_f20158_q09_a2    set -0.48541869 ; C1DDCD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\IIr2.h ===
;**************************************************************************
;
; IIR2.h    2nd Order, IIR filter module
;       
;**************************************************************************        
    
FX_DELAY_BASE           equ FX_STATE_YMEM_BASE


IIR2_H_B0	equ	(DATASIZE_DSP_FX_STATE_MONO)
IIR2_H_B1	equ	(DATASIZE_DSP_FX_STATE_MONO+1)
IIR2_H_B2	equ	(DATASIZE_DSP_FX_STATE_MONO+2)
IIR2_H_A1	equ	(DATASIZE_DSP_FX_STATE_MONO+3)
IIR2_H_A2	equ	(DATASIZE_DSP_FX_STATE_MONO+4)

DATASIZE_IIR2	equ	(1+IIR2_H_A2)

;
; the following delay variables are kept in Y RAM
;

IIR2_Z_X1	equ	0
IIR2_Z_X2	equ	1
IIR2_Z_Y1	equ	2
IIR2_Z_Y2	equ	3



	include 'IIR2_LowPass.h'
	include 'IIR2_BandPass.h'
	include 'IIR2_BandStop.h'
	include 'IIR2_Equalizer.h'
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Iir2_BandStop.h ===
;**************************************************************************
;
;       IIR2_Bandstop.h    Coefficients for 2nd order band stop filter
;       
;		Written by Gints Klimanis
;
;**************************************************************************        
    
; IIR2: mode=BandStop fc=62.5 Q=1 h=< 0.49769064 -0.99534181 0.49769064 0.99534181 -0.49538127 >,< 3FB453 8098A4 3FB453 7F675C C09759 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandStop_f00062_q01_b0    set 0.49769064 ; 3FB453
iir2_H_BandStop_f00062_q01_b1    set -0.99534181 ; 8098A4
iir2_H_BandStop_f00062_q01_b2    set 0.49769064 ; 3FB453
iir2_H_BandStop_f00062_q01_a1    set 0.99534181 ; 7F675C
iir2_H_BandStop_f00062_q01_a2    set -0.49538127 ; C09759

; IIR2: mode=BandStop fc=78.7451 Q=1 h=< 0.49709390 -0.99412522 0.49709390 0.99412522 -0.49418779 >,< 3FA0C5 80C081 3FA0C5 7F3F7F C0BE75 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandStop_f00078_q01_b0    set 0.49709390 ; 3FA0C5
iir2_H_BandStop_f00078_q01_b1    set -0.99412522 ; 80C081
iir2_H_BandStop_f00078_q01_b2    set 0.49709390 ; 3FA0C5
iir2_H_BandStop_f00078_q01_a1    set 0.99412522 ; 7F3F7F
iir2_H_BandStop_f00078_q01_a2    set -0.49418779 ; C0BE75

; IIR2: mode=BandStop fc=99.2126 Q=1 h=< 0.49634411 -0.99258904 0.49634411 0.99258904 -0.49268821 >,< 3F8834 80F2D8 3F8834 7F0D28 C0EF98 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandStop_f00099_q01_b0    set 0.49634411 ; 3F8834
iir2_H_BandStop_f00099_q01_b1    set -0.99258904 ; 80F2D8
iir2_H_BandStop_f00099_q01_b2    set 0.49634411 ; 3F8834
iir2_H_BandStop_f00099_q01_a1    set 0.99258904 ; 7F0D28
iir2_H_BandStop_f00099_q01_a2    set -0.49268821 ; C0EF98

; IIR2: mode=BandStop fc=125 Q=1 h=< 0.49540269 -0.99064825 0.49540269 0.99064825 -0.49080538 >,< 3F695B 813270 3F695B 7ECD90 C12D4A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandStop_f00125_q01_b0    set 0.49540269 ; 3F695B
iir2_H_BandStop_f00125_q01_b1    set -0.99064825 ; 813270
iir2_H_BandStop_f00125_q01_b2    set 0.49540269 ; 3F695B
iir2_H_BandStop_f00125_q01_a1    set 0.99064825 ; 7ECD90
iir2_H_BandStop_f00125_q01_a2    set -0.49080538 ; C12D4A

; IIR2: mode=BandStop fc=157.49 Q=1 h=< 0.49422174 -0.98819465 0.49422174 0.98819465 -0.48844348 >,< 3F42A8 8182D7 3F42A8 7E7D29 C17AB0 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandStop_f00157_q01_b0    set 0.49422174 ; 3F42A8
iir2_H_BandStop_f00157_q01_b1    set -0.98819465 ; 8182D7
iir2_H_BandStop_f00157_q01_b2    set 0.49422174 ; 3F42A8
iir2_H_BandStop_f00157_q01_a1    set 0.98819465 ; 7E7D29
iir2_H_BandStop_f00157_q01_a2    set -0.48844348 ; C17AB0

; IIR2: mode=BandStop fc=198.425 Q=1 h=< 0.49274200 -0.98509021 0.49274200 0.98509021 -0.48548400 >,< 3F122B 81E891 3F122B 7E176F C1DBA9 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandStop_f00198_q01_b0    set 0.49274200 ; 3F122B
iir2_H_BandStop_f00198_q01_b1    set -0.98509021 ; 81E891
iir2_H_BandStop_f00198_q01_b2    set 0.49274200 ; 3F122B
iir2_H_BandStop_f00198_q01_a1    set 0.98509021 ; 7E176F
iir2_H_BandStop_f00198_q01_a2    set -0.48548400 ; C1DBA9

; IIR2: mode=BandStop fc=250 Q=1 h=< 0.49089057 -0.98115840 0.49089057 0.98115840 -0.48178114 >,< 3ED580 826967 3ED580 7D9699 C254FF >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandStop_f00250_q01_b0    set 0.49089057 ; 3ED580
iir2_H_BandStop_f00250_q01_b1    set -0.98115840 ; 826967
iir2_H_BandStop_f00250_q01_b2    set 0.49089057 ; 3ED580
iir2_H_BandStop_f00250_q01_a1    set 0.98115840 ; 7D9699
iir2_H_BandStop_f00250_q01_a2    set -0.48178114 ; C254FF

; IIR2: mode=BandStop fc=314.98 Q=1 h=< 0.48857831 -0.97617282 0.48857831 0.97617282 -0.47715663 >,< 3E89BC 830CC5 3E89BC 7CF33B C2EC88 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandStop_f00314_q01_b0    set 0.48857831 ; 3E89BC
iir2_H_BandStop_f00314_q01_b1    set -0.97617282 ; 830CC5
iir2_H_BandStop_f00314_q01_b2    set 0.48857831 ; 3E89BC
iir2_H_BandStop_f00314_q01_a1    set 0.97617282 ; 7CF33B
iir2_H_BandStop_f00314_q01_a2    set -0.47715663 ; C2EC88

; IIR2: mode=BandStop fc=396.85 Q=1 h=< 0.48569726 -0.96984218 0.48569726 0.96984218 -0.47139451 >,< 3E2B54 83DC36 3E2B54 7C23CA C3A959 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandStop_f00396_q01_b0    set 0.48569726 ; 3E2B54
iir2_H_BandStop_f00396_q01_b1    set -0.96984218 ; 83DC36
iir2_H_BandStop_f00396_q01_b2    set 0.48569726 ; 3E2B54
iir2_H_BandStop_f00396_q01_a1    set 0.96984218 ; 7C23CA
iir2_H_BandStop_f00396_q01_a2    set -0.47139451 ; C3A959

; IIR2: mode=BandStop fc=500 Q=1 h=< 0.48211807 -0.96179050 0.48211807 0.96179050 -0.46423613 >,< 3DB60B 84E40D 3DB60B 7B1BF3 C493E9 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandStop_f00500_q01_b0    set 0.48211807 ; 3DB60B
iir2_H_BandStop_f00500_q01_b1    set -0.96179050 ; 84E40D
iir2_H_BandStop_f00500_q01_b2    set 0.48211807 ; 3DB60B
iir2_H_BandStop_f00500_q01_a1    set 0.96179050 ; 7B1BF3
iir2_H_BandStop_f00500_q01_a2    set -0.46423613 ; C493E9

; IIR2: mode=BandStop fc=629.961 Q=1 h=< 0.47768828 -0.95153097 0.47768828 0.95153097 -0.45537655 >,< 3D24E3 86343C 3D24E3 79CBC4 C5B639 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandStop_f00629_q01_b0    set 0.47768828 ; 3D24E3
iir2_H_BandStop_f00629_q01_b1    set -0.95153097 ; 86343C
iir2_H_BandStop_f00629_q01_b2    set 0.47768828 ; 3D24E3
iir2_H_BandStop_f00629_q01_a1    set 0.95153097 ; 79CBC4
iir2_H_BandStop_f00629_q01_a2    set -0.45537655 ; C5B639

; IIR2: mode=BandStop fc=793.701 Q=1 h=< 0.47223201 -0.93843163 0.47223201 0.93843163 -0.44446401 >,< 3C7219 87E179 3C7219 781E87 C71BCE >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandStop_f00793_q01_b0    set 0.47223201 ; 3C7219
iir2_H_BandStop_f00793_q01_b1    set -0.93843163 ; 87E179
iir2_H_BandStop_f00793_q01_b2    set 0.47223201 ; 3C7219
iir2_H_BandStop_f00793_q01_a1    set 0.93843163 ; 781E87
iir2_H_BandStop_f00793_q01_a2    set -0.44446401 ; C71BCE

; IIR2: mode=BandStop fc=1000 Q=1 h=< 0.46555257 -0.92167069 0.46555257 0.92167069 -0.43110514 >,< 3B973A 8A06B2 3B973A 75F94E C8D18C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandStop_f01000_q01_b0    set 0.46555257 ; 3B973A
iir2_H_BandStop_f01000_q01_b1    set -0.92167069 ; 8A06B2
iir2_H_BandStop_f01000_q01_b2    set 0.46555257 ; 3B973A
iir2_H_BandStop_f01000_q01_a1    set 0.92167069 ; 75F94E
iir2_H_BandStop_f01000_q01_a2    set -0.43110514 ; C8D18C

; IIR2: mode=BandStop fc=1259.92 Q=1 h=< 0.45744006 -0.90017945 0.45744006 0.90017945 -0.41488011 >,< 3A8D65 8CC6EC 3A8D65 733914 CAE536 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandStop_f01259_q01_b0    set 0.45744006 ; 3A8D65
iir2_H_BandStop_f01259_q01_b1    set -0.90017945 ; 8CC6EC
iir2_H_BandStop_f01259_q01_b2    set 0.45744006 ; 3A8D65
iir2_H_BandStop_f01259_q01_a1    set 0.90017945 ; 733914
iir2_H_BandStop_f01259_q01_a2    set -0.41488011 ; CAE536

; IIR2: mode=BandStop fc=1587.4 Q=1 h=< 0.44768687 -0.87257147 0.44768687 0.87257147 -0.39537375 >,< 394DCD 904F94 394DCD 6FB06C CD6465 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandStop_f01587_q01_b0    set 0.44768687 ; 394DCD
iir2_H_BandStop_f01587_q01_b1    set -0.87257147 ; 904F94
iir2_H_BandStop_f01587_q01_b2    set 0.44768687 ; 394DCD
iir2_H_BandStop_f01587_q01_a1    set 0.87257147 ; 6FB06C
iir2_H_BandStop_f01587_q01_a2    set -0.39537375 ; CD6465

; IIR2: mode=BandStop fc=2000 Q=1 h=< 0.43611535 -0.83705819 0.43611535 0.83705819 -0.37223069 >,< 37D2A0 94DB47 37D2A0 6B24B9 D05ABF >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandStop_f02000_q01_b0    set 0.43611535 ; 37D2A0
iir2_H_BandStop_f02000_q01_b1    set -0.83705819 ; 94DB47
iir2_H_BandStop_f02000_q01_b2    set 0.43611535 ; 37D2A0
iir2_H_BandStop_f02000_q01_a1    set 0.83705819 ; 6B24B9
iir2_H_BandStop_f02000_q01_a2    set -0.37223069 ; D05ABF

; IIR2: mode=BandStop fc=2519.84 Q=1 h=< 0.42262255 -0.79135461 0.42262255 0.79135461 -0.34524509 >,< 36187F 9AB4E5 36187F 654B1B D3CF03 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandStop_f02519_q01_b0    set 0.42262255 ; 36187F
iir2_H_BandStop_f02519_q01_b1    set -0.79135461 ; 9AB4E5
iir2_H_BandStop_f02519_q01_b2    set 0.42262255 ; 36187F
iir2_H_BandStop_f02519_q01_a1    set 0.79135461 ; 654B1B
iir2_H_BandStop_f02519_q01_a2    set -0.34524509 ; D3CF03

; IIR2: mode=BandStop fc=3174.8 Q=1 h=< 0.40724824 -0.73258259 0.40724824 0.73258259 -0.31449647 >,< 3420B5 A23ABC 3420B5 5DC544 D7BE95 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandStop_f03174_q01_b0    set 0.40724824 ; 3420B5
iir2_H_BandStop_f03174_q01_b1    set -0.73258259 ; A23ABC
iir2_H_BandStop_f03174_q01_b2    set 0.40724824 ; 3420B5
iir2_H_BandStop_f03174_q01_a1    set 0.73258259 ; 5DC544
iir2_H_BandStop_f03174_q01_a2    set -0.31449647 ; D7BE95

; IIR2: mode=BandStop fc=4000 Q=1 h=< 0.39027212 -0.65718163 0.39027212 0.65718163 -0.28054424 >,< 31F46F ABE179 31F46F 541E87 DC1721 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandStop_f04000_q01_b0    set 0.39027212 ; 31F46F
iir2_H_BandStop_f04000_q01_b1    set -0.65718163 ; ABE179
iir2_H_BandStop_f04000_q01_b2    set 0.39027212 ; 31F46F
iir2_H_BandStop_f04000_q01_a1    set 0.65718163 ; 541E87
iir2_H_BandStop_f04000_q01_a2    set -0.28054424 ; DC1721

; IIR2: mode=BandStop fc=5039.68 Q=1 h=< 0.37234764 -0.56083081 0.37234764 0.56083081 -0.24469528 >,< 2FA916 B836B2 2FA916 47C94E E0ADD4 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandStop_f05039_q01_b0    set 0.37234764 ; 2FA916
iir2_H_BandStop_f05039_q01_b1    set -0.56083081 ; B836B2
iir2_H_BandStop_f05039_q01_b2    set 0.37234764 ; 2FA916
iir2_H_BandStop_f05039_q01_a1    set 0.56083081 ; 47C94E
iir2_H_BandStop_f05039_q01_a2    set -0.24469528 ; E0ADD4

; IIR2: mode=BandStop fc=6349.6 Q=1 h=< 0.35468673 -0.43835645 0.35468673 0.43835645 -0.20937345 >,< 2D6660 C7E3F0 2D6660 381C10 E53341 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandStop_f06349_q01_b0    set 0.35468673 ; 2D6660
iir2_H_BandStop_f06349_q01_b1    set -0.43835645 ; C7E3F0
iir2_H_BandStop_f06349_q01_b2    set 0.35468673 ; 2D6660
iir2_H_BandStop_f06349_q01_a1    set 0.43835645 ; 381C10
iir2_H_BandStop_f06349_q01_a2    set -0.20937345 ; E53341

; IIR2: mode=BandStop fc=8000 Q=1 h=< 0.33934135 -0.28353326 0.33934135 0.28353326 -0.17868269 >,< 2B6F89 DBB52F 2B6F89 244AD1 E920ED >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandStop_f08000_q01_b0    set 0.33934135 ; 2B6F89
iir2_H_BandStop_f08000_q01_b1    set -0.28353326 ; DBB52F
iir2_H_BandStop_f08000_q01_b2    set 0.33934135 ; 2B6F89
iir2_H_BandStop_f08000_q01_a1    set 0.28353326 ; 244AD1
iir2_H_BandStop_f08000_q01_a2    set -0.17868269 ; E920ED

; IIR2: mode=BandStop fc=10079.4 Q=1 h=< 0.32973418 -0.08858140 0.32973418 0.08858140 -0.15946836 >,< 2A34BA F4A95E 2A34BA 0B56A2 EB968B >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandStop_f10079_q01_b0    set 0.32973418 ; 2A34BA
iir2_H_BandStop_f10079_q01_b1    set -0.08858140 ; F4A95E
iir2_H_BandStop_f10079_q01_b2    set 0.32973418 ; 2A34BA
iir2_H_BandStop_f10079_q01_a1    set 0.08858140 ; 0B56A2
iir2_H_BandStop_f10079_q01_a2    set -0.15946836 ; EB968B

; IIR2: mode=BandStop fc=12699.2 Q=1 h=< 0.33193023 0.15685606 0.33193023 -0.15685606 -0.16386045 >,< 2A7CB0 1413DC 2A7CB0 EBEC24 EB069F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandStop_f12699_q01_b0    set 0.33193023 ; 2A7CB0
iir2_H_BandStop_f12699_q01_b1    set 0.15685606 ; 1413DC
iir2_H_BandStop_f12699_q01_b2    set 0.33193023 ; 2A7CB0
iir2_H_BandStop_f12699_q01_a1    set -0.15685606 ; EBEC24
iir2_H_BandStop_f12699_q01_a2    set -0.16386045 ; EB069F

; IIR2: mode=BandStop fc=16000 Q=1 h=< 0.35827392 0.46642712 0.35827392 -0.46642712 -0.21654784 >,< 2DDBEB 3BB3E2 2DDBEB C44C1E E44829 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandStop_f16000_q01_b0    set 0.35827392 ; 2DDBEB
iir2_H_BandStop_f16000_q01_b1    set 0.46642712 ; 3BB3E2
iir2_H_BandStop_f16000_q01_b2    set 0.35827392 ; 2DDBEB
iir2_H_BandStop_f16000_q01_a1    set -0.46642712 ; C44C1E
iir2_H_BandStop_f16000_q01_a2    set -0.21654784 ; E44829

; IIR2: mode=BandStop fc=20158.7 Q=1 h=< 0.43908914 0.84648918 0.43908914 -0.84648918 -0.37817827 >,< 383412 6C59C2 383412 93A63E CF97DB >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandStop_f20158_q01_b0    set 0.43908914 ; 383412
iir2_H_BandStop_f20158_q01_b1    set 0.84648918 ; 6C59C2
iir2_H_BandStop_f20158_q01_b2    set 0.43908914 ; 383412
iir2_H_BandStop_f20158_q01_a1    set -0.84648918 ; 93A63E
iir2_H_BandStop_f20158_q01_a2    set -0.37817827 ; CF97DB

; IIR2: mode=BandStop fc=62.5 Q=3 h=< 0.49925562 -0.99847165 0.49925562 0.99847165 -0.49851124 >,< 3FE79B 803215 3FE79B 7FCDEB C030C9 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandStop_f00062_q03_b0    set 0.49925562 ; 3FE79B
iir2_H_BandStop_f00062_q03_b1    set -0.99847165 ; 803215
iir2_H_BandStop_f00062_q03_b2    set 0.49925562 ; 3FE79B
iir2_H_BandStop_f00062_q03_a1    set 0.99847165 ; 7FCDEB
iir2_H_BandStop_f00062_q03_a2    set -0.49851124 ; C030C9

; IIR2: mode=BandStop fc=78.7451 Q=3 h=< 0.49906251 -0.99806220 0.49906251 0.99806220 -0.49812501 >,< 3FE147 803F80 3FE147 7FC080 C03D71 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandStop_f00078_q03_b0    set 0.49906251 ; 3FE147
iir2_H_BandStop_f00078_q03_b1    set -0.99806220 ; 803F80
iir2_H_BandStop_f00078_q03_b2    set 0.49906251 ; 3FE147
iir2_H_BandStop_f00078_q03_a1    set 0.99806220 ; 7FC080
iir2_H_BandStop_f00078_q03_a2    set -0.49812501 ; C03D71

; IIR2: mode=BandStop fc=99.2126 Q=3 h=< 0.49881942 -0.99753918 0.49881942 0.99753918 -0.49763885 >,< 3FD950 8050A3 3FD950 7FAF5D C04D5F >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandStop_f00099_q03_b0    set 0.49881942 ; 3FD950
iir2_H_BandStop_f00099_q03_b1    set -0.99753918 ; 8050A3
iir2_H_BandStop_f00099_q03_b2    set 0.49881942 ; 3FD950
iir2_H_BandStop_f00099_q03_a1    set 0.99753918 ; 7FAF5D
iir2_H_BandStop_f00099_q03_a2    set -0.49763885 ; C04D5F

; IIR2: mode=BandStop fc=125 Q=3 h=< 0.49851351 -0.99686890 0.49851351 0.99686890 -0.49702701 >,< 3FCF4A 80669A 3FCF4A 7F9966 C0616C >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandStop_f00125_q03_b0    set 0.49851351 ; 3FCF4A
iir2_H_BandStop_f00125_q03_b1    set -0.99686890 ; 80669A
iir2_H_BandStop_f00125_q03_b2    set 0.49851351 ; 3FCF4A
iir2_H_BandStop_f00125_q03_a1    set 0.99686890 ; 7F9966
iir2_H_BandStop_f00125_q03_a2    set -0.49702701 ; C0616C

; IIR2: mode=BandStop fc=157.49 Q=3 h=< 0.49812864 -0.99600649 0.49812864 0.99600649 -0.49625728 >,< 3FC2AE 8082DC 3FC2AE 7F7D24 C07AA5 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandStop_f00157_q03_b0    set 0.49812864 ; 3FC2AE
iir2_H_BandStop_f00157_q03_b1    set -0.99600649 ; 8082DC
iir2_H_BandStop_f00157_q03_b2    set 0.49812864 ; 3FC2AE
iir2_H_BandStop_f00157_q03_a1    set 0.99600649 ; 7F7D24
iir2_H_BandStop_f00157_q03_a2    set -0.49625728 ; C07AA5

; IIR2: mode=BandStop fc=198.425 Q=3 h=< 0.49764464 -0.99489157 0.49764464 0.99489157 -0.49528928 >,< 3FB2D1 80A765 3FB2D1 7F589B C09A5D >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandStop_f00198_q03_b0    set 0.49764464 ; 3FB2D1
iir2_H_BandStop_f00198_q03_b1    set -0.99489157 ; 80A765
iir2_H_BandStop_f00198_q03_b2    set 0.49764464 ; 3FB2D1
iir2_H_BandStop_f00198_q03_a1    set 0.99489157 ; 7F589B
iir2_H_BandStop_f00198_q03_a2    set -0.49528928 ; C09A5D

; IIR2: mode=BandStop fc=250 Q=3 h=< 0.49703629 -0.99344206 0.49703629 0.99344206 -0.49407259 >,< 3F9EE2 80D6E4 3F9EE2 7F291C C0C23B >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandStop_f00250_q03_b0    set 0.49703629 ; 3F9EE2
iir2_H_BandStop_f00250_q03_b1    set -0.99344206 ; 80D6E4
iir2_H_BandStop_f00250_q03_b2    set 0.49703629 ; 3F9EE2
iir2_H_BandStop_f00250_q03_a1    set 0.99344206 ; 7F291C
iir2_H_BandStop_f00250_q03_a2    set -0.49407259 ; C0C23B

; IIR2: mode=BandStop fc=314.98 Q=3 h=< 0.49627217 -0.99154504 0.49627217 0.99154504 -0.49254434 >,< 3F85D8 81150E 3F85D8 7EEAF2 C0F44F >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandStop_f00314_q03_b0    set 0.49627217 ; 3F85D8
iir2_H_BandStop_f00314_q03_b1    set -0.99154504 ; 81150E
iir2_H_BandStop_f00314_q03_b2    set 0.49627217 ; 3F85D8
iir2_H_BandStop_f00314_q03_a1    set 0.99154504 ; 7EEAF2
iir2_H_BandStop_f00314_q03_a2    set -0.49254434 ; C0F44F

; IIR2: mode=BandStop fc=396.85 Q=3 h=< 0.49531323 -0.98904338 0.49531323 0.98904338 -0.49062645 >,< 3F666C 816707 3F666C 7E98F9 C13327 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandStop_f00396_q03_b0    set 0.49531323 ; 3F666C
iir2_H_BandStop_f00396_q03_b1    set -0.98904338 ; 816707
iir2_H_BandStop_f00396_q03_b2    set 0.49531323 ; 3F666C
iir2_H_BandStop_f00396_q03_a1    set 0.98904338 ; 7E98F9
iir2_H_BandStop_f00396_q03_a2    set -0.49062645 ; C13327

; IIR2: mode=BandStop fc=500 Q=3 h=< 0.49411121 -0.98571594 0.49411121 0.98571594 -0.48822242 >,< 3F3F09 81D410 3F3F09 7E2BF0 C181EE >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandStop_f00500_q03_b0    set 0.49411121 ; 3F3F09
iir2_H_BandStop_f00500_q03_b1    set -0.98571594 ; 81D410
iir2_H_BandStop_f00500_q03_b2    set 0.49411121 ; 3F3F09
iir2_H_BandStop_f00500_q03_a1    set 0.98571594 ; 7E2BF0
iir2_H_BandStop_f00500_q03_a2    set -0.48822242 ; C181EE

; IIR2: mode=BandStop fc=629.961 Q=3 h=< 0.49260685 -0.98124802 0.49260685 0.98124802 -0.48521371 >,< 3F0DBD 826677 3F0DBD 7D9989 C1E485 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandStop_f00629_q03_b0    set 0.49260685 ; 3F0DBD
iir2_H_BandStop_f00629_q03_b1    set -0.98124802 ; 826677
iir2_H_BandStop_f00629_q03_b2    set 0.49260685 ; 3F0DBD
iir2_H_BandStop_f00629_q03_a1    set 0.98124802 ; 7D9989
iir2_H_BandStop_f00629_q03_a2    set -0.48521371 ; C1E485

; IIR2: mode=BandStop fc=793.701 Q=3 h=< 0.49072807 -0.97518748 0.49072807 0.97518748 -0.48145613 >,< 3ED02D 832D0F 3ED02D 7CD2F1 C25FA6 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandStop_f00793_q03_b0    set 0.49072807 ; 3ED02D
iir2_H_BandStop_f00793_q03_b1    set -0.97518748 ; 832D0F
iir2_H_BandStop_f00793_q03_b2    set 0.49072807 ; 3ED02D
iir2_H_BandStop_f00793_q03_a1    set 0.97518748 ; 7CD2F1
iir2_H_BandStop_f00793_q03_a2    set -0.48145613 ; C25FA6

; IIR2: mode=BandStop fc=1000 Q=3 h=< 0.48838835 -0.96687949 0.48838835 0.96687949 -0.47677671 >,< 3E8382 843D4B 3E8382 7BC2B5 C2F8FB >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandStop_f01000_q03_b0    set 0.48838835 ; 3E8382
iir2_H_BandStop_f01000_q03_b1    set -0.96687949 ; 843D4B
iir2_H_BandStop_f01000_q03_b2    set 0.48838835 ; 3E8382
iir2_H_BandStop_f01000_q03_a1    set 0.96687949 ; 7BC2B5
iir2_H_BandStop_f01000_q03_a2    set -0.47677671 ; C2F8FB

; IIR2: mode=BandStop fc=1259.92 Q=3 h=< 0.48548610 -0.95537023 0.48548610 0.95537023 -0.47097221 >,< 3E2468 85B66E 3E2468 7A4992 C3B72F >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandStop_f01259_q03_b0    set 0.48548610 ; 3E2468
iir2_H_BandStop_f01259_q03_b1    set -0.95537023 ; 85B66E
iir2_H_BandStop_f01259_q03_b2    set 0.48548610 ; 3E2468
iir2_H_BandStop_f01259_q03_a1    set 0.95537023 ; 7A4992
iir2_H_BandStop_f01259_q03_a2    set -0.47097221 ; C3B72F

; IIR2: mode=BandStop fc=1587.4 Q=3 h=< 0.48190582 -0.93926647 0.48190582 0.93926647 -0.46381164 >,< 3DAF17 87C61E 3DAF17 7839E2 C4A1D2 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandStop_f01587_q03_b0    set 0.48190582 ; 3DAF17
iir2_H_BandStop_f01587_q03_b1    set -0.93926647 ; 87C61E
iir2_H_BandStop_f01587_q03_b2    set 0.48190582 ; 3DAF17
iir2_H_BandStop_f01587_q03_a1    set 0.93926647 ; 7839E2
iir2_H_BandStop_f01587_q03_a2    set -0.46381164 ; C4A1D2

; IIR2: mode=BandStop fc=2000 Q=3 h=< 0.47752342 -0.91653480 0.47752342 0.91653480 -0.45504684 >,< 3D1F7C 8AAEFD 3D1F7C 755103 C5C107 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandStop_f02000_q03_b0    set 0.47752342 ; 3D1F7C
iir2_H_BandStop_f02000_q03_b1    set -0.91653480 ; 8AAEFD
iir2_H_BandStop_f02000_q03_b2    set 0.47752342 ; 3D1F7C
iir2_H_BandStop_f02000_q03_a1    set 0.91653480 ; 755103
iir2_H_BandStop_f02000_q03_a2    set -0.45504684 ; C5C107

; IIR2: mode=BandStop fc=2519.84 Q=3 h=< 0.47221914 -0.88422351 0.47221914 0.88422351 -0.44443828 >,< 3C71AD 8ED1C4 3C71AD 712E3C C71CA6 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandStop_f02519_q03_b0    set 0.47221914 ; 3C71AD
iir2_H_BandStop_f02519_q03_b1    set -0.88422351 ; 8ED1C4
iir2_H_BandStop_f02519_q03_b2    set 0.47221914 ; 3C71AD
iir2_H_BandStop_f02519_q03_a1    set 0.88422351 ; 712E3C
iir2_H_BandStop_f02519_q03_a2    set -0.44443828 ; C71CA6

; IIR2: mode=BandStop fc=3174.8 Q=3 h=< 0.46590427 -0.83809658 0.46590427 0.83809658 -0.43180854 >,< 3BA2C0 94B941 3BA2C0 6B46BF C8BA80 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandStop_f03174_q03_b0    set 0.46590427 ; 3BA2C0
iir2_H_BandStop_f03174_q03_b1    set -0.83809658 ; 94B941
iir2_H_BandStop_f03174_q03_b2    set 0.46590427 ; 3BA2C0
iir2_H_BandStop_f03174_q03_a1    set 0.83809658 ; 6B46BF
iir2_H_BandStop_f03174_q03_a2    set -0.43180854 ; C8BA80

; IIR2: mode=BandStop fc=4000 Q=3 h=< 0.45857170 -0.77219172 0.45857170 0.77219172 -0.41714341 >,< 3AB27A 9D28D3 3AB27A 62D72D CA9B0C >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandStop_f04000_q03_b0    set 0.45857170 ; 3AB27A
iir2_H_BandStop_f04000_q03_b1    set -0.77219172 ; 9D28D3
iir2_H_BandStop_f04000_q03_b2    set 0.45857170 ; 3AB27A
iir2_H_BandStop_f04000_q03_a1    set 0.77219172 ; 62D72D
iir2_H_BandStop_f04000_q03_a2    set -0.41714341 ; CA9B0C

; IIR2: mode=BandStop fc=5039.68 Q=3 h=< 0.45038587 -0.67837216 0.45038587 0.67837216 -0.40077175 >,< 39A63E A92B1A 39A63E 56D4E6 CCB383 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandStop_f05039_q03_b0    set 0.45038587 ; 39A63E
iir2_H_BandStop_f05039_q03_b1    set -0.67837216 ; A92B1A
iir2_H_BandStop_f05039_q03_b2    set 0.45038587 ; 39A63E
iir2_H_BandStop_f05039_q03_a1    set 0.67837216 ; 56D4E6
iir2_H_BandStop_f05039_q03_a2    set -0.40077175 ; CCB383

; IIR2: mode=BandStop fc=6349.6 Q=3 h=< 0.44183511 -0.54606291 0.44183511 0.54606291 -0.38367022 >,< 388E0D BA1A9D 388E0D 45E563 CEE3E5 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandStop_f06349_q03_b0    set 0.44183511 ; 388E0D
iir2_H_BandStop_f06349_q03_b1    set -0.54606291 ; BA1A9D
iir2_H_BandStop_f06349_q03_b2    set 0.44183511 ; 388E0D
iir2_H_BandStop_f06349_q03_a1    set 0.54606291 ; 45E563
iir2_H_BandStop_f06349_q03_a2    set -0.38367022 ; CEE3E5

; IIR2: mode=BandStop fc=8000 Q=3 h=< 0.43397975 -0.36260743 0.43397975 0.36260743 -0.36795950 >,< 378CA6 D19615 378CA6 2E69EB D0E6B4 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandStop_f08000_q03_b0    set 0.43397975 ; 378CA6
iir2_H_BandStop_f08000_q03_b1    set -0.36260743 ; D19615
iir2_H_BandStop_f08000_q03_b2    set 0.43397975 ; 378CA6
iir2_H_BandStop_f08000_q03_a1    set 0.36260743 ; 2E69EB
iir2_H_BandStop_f08000_q03_a2    set -0.36795950 ; D0E6B4

; IIR2: mode=BandStop fc=10079.4 Q=3 h=< 0.42884517 -0.11520706 0.42884517 0.11520706 -0.35769034 >,< 36E466 F140E6 36E466 0EBF1A D23734 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandStop_f10079_q03_b0    set 0.42884517 ; 36E466
iir2_H_BandStop_f10079_q03_b1    set -0.11520706 ; F140E6
iir2_H_BandStop_f10079_q03_b2    set 0.42884517 ; 36E466
iir2_H_BandStop_f10079_q03_a1    set 0.11520706 ; 0EBF1A
iir2_H_BandStop_f10079_q03_a2    set -0.35769034 ; D23734

; IIR2: mode=BandStop fc=12699.2 Q=3 h=< 0.43003415 0.20321579 0.43003415 -0.20321579 -0.36006830 >,< 370B5C 1A02F9 370B5C E5FD07 D1E949 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandStop_f12699_q03_b0    set 0.43003415 ; 370B5C
iir2_H_BandStop_f12699_q03_b1    set 0.20321579 ; 1A02F9
iir2_H_BandStop_f12699_q03_b2    set 0.43003415 ; 370B5C
iir2_H_BandStop_f12699_q03_a1    set -0.20321579 ; E5FD07
iir2_H_BandStop_f12699_q03_a2    set -0.36006830 ; D1E949

; IIR2: mode=BandStop fc=16000 Q=3 h=< 0.44361298 0.57752773 0.44361298 -0.57752773 -0.38722595 >,< 38C84F 49EC6D 38C84F B61393 CE6F62 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandStop_f16000_q03_b0    set 0.44361298 ; 38C84F
iir2_H_BandStop_f16000_q03_b1    set 0.57752773 ; 49EC6D
iir2_H_BandStop_f16000_q03_b2    set 0.44361298 ; 38C84F
iir2_H_BandStop_f16000_q03_a1    set -0.57752773 ; B61393
iir2_H_BandStop_f16000_q03_a2    set -0.38722595 ; CE6F62

; IIR2: mode=BandStop fc=20158.7 Q=3 h=< 0.47866399 0.92278277 0.47866399 -0.92278277 -0.45732798 >,< 3D44DC 761DBF 3D44DC 89E241 C57647 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandStop_f20158_q03_b0    set 0.47866399 ; 3D44DC
iir2_H_BandStop_f20158_q03_b1    set 0.92278277 ; 761DBF
iir2_H_BandStop_f20158_q03_b2    set 0.47866399 ; 3D44DC
iir2_H_BandStop_f20158_q03_a1    set -0.92278277 ; 89E241
iir2_H_BandStop_f20158_q03_a2    set -0.45732798 ; C57647

; IIR2: mode=BandStop fc=62.5 Q=9 h=< 0.49975264 -0.99946566 0.49975264 0.99946566 -0.49950529 >,< 3FF7E5 801183 3FF7E5 7FEE7D C01036 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandStop_f00062_q09_b0    set 0.49975264 ; 3FF7E5
iir2_H_BandStop_f00062_q09_b1    set -0.99946566 ; 801183
iir2_H_BandStop_f00062_q09_b2    set 0.49975264 ; 3FF7E5
iir2_H_BandStop_f00062_q09_a1    set 0.99946566 ; 7FEE7D
iir2_H_BandStop_f00062_q09_a2    set -0.49950529 ; C01036

; IIR2: mode=BandStop fc=78.7451 Q=9 h=< 0.49968839 -0.99931389 0.49968839 0.99931389 -0.49937679 >,< 3FF5CA 80167C 3FF5CA 7FE984 C0146C >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandStop_f00078_q09_b0    set 0.49968839 ; 3FF5CA
iir2_H_BandStop_f00078_q09_b1    set -0.99931389 ; 80167C
iir2_H_BandStop_f00078_q09_b2    set 0.49968839 ; 3FF5CA
iir2_H_BandStop_f00078_q09_a1    set 0.99931389 ; 7FE984
iir2_H_BandStop_f00078_q09_a2    set -0.49937679 ; C0146C

; IIR2: mode=BandStop fc=99.2126 Q=9 h=< 0.49960747 -0.99911511 0.49960747 0.99911511 -0.49921494 >,< 3FF323 801CFF 3FF323 7FE301 C019BA >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandStop_f00099_q09_b0    set 0.49960747 ; 3FF323
iir2_H_BandStop_f00099_q09_b1    set -0.99911511 ; 801CFF
iir2_H_BandStop_f00099_q09_b2    set 0.49960747 ; 3FF323
iir2_H_BandStop_f00099_q09_a1    set 0.99911511 ; 7FE301
iir2_H_BandStop_f00099_q09_a2    set -0.49921494 ; C019BA

; IIR2: mode=BandStop fc=125 Q=9 h=< 0.49950555 -0.99885268 0.49950555 0.99885268 -0.49901111 >,< 3FEFCC 802599 3FEFCC 7FDA67 C02068 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandStop_f00125_q09_b0    set 0.49950555 ; 3FEFCC
iir2_H_BandStop_f00125_q09_b1    set -0.99885268 ; 802599
iir2_H_BandStop_f00125_q09_b2    set 0.49950555 ; 3FEFCC
iir2_H_BandStop_f00125_q09_a1    set 0.99885268 ; 7FDA67
iir2_H_BandStop_f00125_q09_a2    set -0.49901111 ; C02068

; IIR2: mode=BandStop fc=157.49 Q=9 h=< 0.49937722 -0.99850301 0.49937722 0.99850301 -0.49875443 >,< 3FEB97 80310E 3FEB97 7FCEF2 C028D1 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandStop_f00157_q09_b0    set 0.49937722 ; 3FEB97
iir2_H_BandStop_f00157_q09_b1    set -0.99850301 ; 80310E
iir2_H_BandStop_f00157_q09_b2    set 0.49937722 ; 3FEB97
iir2_H_BandStop_f00157_q09_a1    set 0.99850301 ; 7FCEF2
iir2_H_BandStop_f00157_q09_a2    set -0.49875443 ; C028D1

; IIR2: mode=BandStop fc=198.425 Q=9 h=< 0.49921563 -0.99803230 0.49921563 0.99803230 -0.49843127 >,< 3FE64C 80407B 3FE64C 7FBF85 C03368 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandStop_f00198_q09_b0    set 0.49921563 ; 3FE64C
iir2_H_BandStop_f00198_q09_b1    set -0.99803230 ; 80407B
iir2_H_BandStop_f00198_q09_b2    set 0.49921563 ; 3FE64C
iir2_H_BandStop_f00198_q09_a1    set 0.99803230 ; 7FBF85
iir2_H_BandStop_f00198_q09_a2    set -0.49843127 ; C03368

; IIR2: mode=BandStop fc=250 Q=9 h=< 0.49901224 -0.99739144 0.49901224 0.99739144 -0.49802448 >,< 3FDFA2 80557A 3FDFA2 7FAA86 C040BC >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandStop_f00250_q09_b0    set 0.49901224 ; 3FDFA2
iir2_H_BandStop_f00250_q09_b1    set -0.99739144 ; 80557A
iir2_H_BandStop_f00250_q09_b2    set 0.49901224 ; 3FDFA2
iir2_H_BandStop_f00250_q09_a1    set 0.99739144 ; 7FAA86
iir2_H_BandStop_f00250_q09_a2    set -0.49802448 ; C040BC

; IIR2: mode=BandStop fc=314.98 Q=9 h=< 0.49875629 -0.99650828 0.49875629 0.99650828 -0.49751259 >,< 3FD73F 80726B 3FD73F 7F8D95 C05182 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandStop_f00314_q09_b0    set 0.49875629 ; 3FD73F
iir2_H_BandStop_f00314_q09_b1    set -0.99650828 ; 80726B
iir2_H_BandStop_f00314_q09_b2    set 0.49875629 ; 3FD73F
iir2_H_BandStop_f00314_q09_a1    set 0.99650828 ; 7F8D95
iir2_H_BandStop_f00314_q09_a2    set -0.49751259 ; C05182

; IIR2: mode=BandStop fc=396.85 Q=9 h=< 0.49843435 -0.99527565 0.49843435 0.99527565 -0.49686870 >,< 3FCCB2 809ACF 3FCCB2 7F6531 C0669C >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandStop_f00396_q09_b0    set 0.49843435 ; 3FCCB2
iir2_H_BandStop_f00396_q09_b1    set -0.99527565 ; 809ACF
iir2_H_BandStop_f00396_q09_b2    set 0.49843435 ; 3FCCB2
iir2_H_BandStop_f00396_q09_a1    set 0.99527565 ; 7F6531
iir2_H_BandStop_f00396_q09_a2    set -0.49686870 ; C0669C

; IIR2: mode=BandStop fc=500 Q=9 h=< 0.49802962 -0.99353289 0.49802962 0.99353289 -0.49605924 >,< 3FBF6F 80D3EA 3FBF6F 7F2C16 C08122 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandStop_f00500_q09_b0    set 0.49802962 ; 3FBF6F
iir2_H_BandStop_f00500_q09_b1    set -0.99353289 ; 80D3EA
iir2_H_BandStop_f00500_q09_b2    set 0.49802962 ; 3FBF6F
iir2_H_BandStop_f00500_q09_a1    set 0.99353289 ; 7F2C16
iir2_H_BandStop_f00500_q09_a2    set -0.49605924 ; C08122

; IIR2: mode=BandStop fc=629.961 Q=9 h=< 0.49752124 -0.99103724 0.49752124 0.99103724 -0.49504249 >,< 3FAEC6 8125B1 3FAEC6 7EDA4F C0A273 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandStop_f00629_q09_b0    set 0.49752124 ; 3FAEC6
iir2_H_BandStop_f00629_q09_b1    set -0.99103724 ; 8125B1
iir2_H_BandStop_f00629_q09_b2    set 0.49752124 ; 3FAEC6
iir2_H_BandStop_f00629_q09_a1    set 0.99103724 ; 7EDA4F
iir2_H_BandStop_f00629_q09_a2    set -0.49504249 ; C0A273

; IIR2: mode=BandStop fc=793.701 Q=9 h=< 0.49688343 -0.98741958 0.49688343 0.98741958 -0.49376685 >,< 3F99E0 819C3D 3F99E0 7E63C3 C0CC40 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandStop_f00793_q09_b0    set 0.49688343 ; 3F99E0
iir2_H_BandStop_f00793_q09_b1    set -0.98741958 ; 819C3D
iir2_H_BandStop_f00793_q09_b2    set 0.49688343 ; 3F99E0
iir2_H_BandStop_f00793_q09_a1    set 0.98741958 ; 7E63C3
iir2_H_BandStop_f00793_q09_a2    set -0.49376685 ; C0CC40

; IIR2: mode=BandStop fc=1000 Q=9 h=< 0.49608459 -0.98211599 0.49608459 0.98211599 -0.49216917 >,< 3F7FB3 824A06 3F7FB3 7DB5FA C1009A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandStop_f01000_q09_b0    set 0.49608459 ; 3F7FB3
iir2_H_BandStop_f01000_q09_b1    set -0.98211599 ; 824A06
iir2_H_BandStop_f01000_q09_b2    set 0.49608459 ; 3F7FB3
iir2_H_BandStop_f01000_q09_a1    set 0.98211599 ; 7DB5FA
iir2_H_BandStop_f01000_q09_a2    set -0.49216917 ; C1009A

; IIR2: mode=BandStop fc=1259.92 Q=9 h=< 0.49508660 -0.97426271 0.49508660 0.97426271 -0.49017321 >,< 3F5EFF 834B5C 3F5EFF 7CB4A4 C14201 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandStop_f01259_q09_b0    set 0.49508660 ; 3F5EFF
iir2_H_BandStop_f01259_q09_b1    set -0.97426271 ; 834B5C
iir2_H_BandStop_f01259_q09_b2    set 0.49508660 ; 3F5EFF
iir2_H_BandStop_f01259_q09_a1    set 0.97426271 ; 7CB4A4
iir2_H_BandStop_f01259_q09_a2    set -0.49017321 ; C14201

; IIR2: mode=BandStop fc=1587.4 Q=9 h=< 0.49384454 -0.96253583 0.49384454 0.96253583 -0.48768909 >,< 3F364C 84CBA0 3F364C 7B3460 C19368 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandStop_f01587_q09_b0    set 0.49384454 ; 3F364C
iir2_H_BandStop_f01587_q09_b1    set -0.96253583 ; 84CBA0
iir2_H_BandStop_f01587_q09_b2    set 0.49384454 ; 3F364C
iir2_H_BandStop_f01587_q09_a1    set 0.96253583 ; 7B3460
iir2_H_BandStop_f01587_q09_a2    set -0.48768909 ; C19368

; IIR2: mode=BandStop fc=2000 Q=9 h=< 0.49230754 -0.94491070 0.49230754 0.94491070 -0.48461508 >,< 3F03EF 870D2B 3F03EF 78F2D5 C1F822 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandStop_f02000_q09_b0    set 0.49230754 ; 3F03EF
iir2_H_BandStop_f02000_q09_b1    set -0.94491070 ; 870D2B
iir2_H_BandStop_f02000_q09_b2    set 0.49230754 ; 3F03EF
iir2_H_BandStop_f02000_q09_a1    set 0.94491070 ; 78F2D5
iir2_H_BandStop_f02000_q09_a2    set -0.48461508 ; C1F822

; IIR2: mode=BandStop fc=2519.84 Q=9 h=< 0.49042220 -0.91830849 0.49042220 0.91830849 -0.48084441 >,< 3EC627 8A74DE 3EC627 758B22 C273B1 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandStop_f02519_q09_b0    set 0.49042220 ; 3EC627
iir2_H_BandStop_f02519_q09_b1    set -0.91830849 ; 8A74DE
iir2_H_BandStop_f02519_q09_b2    set 0.49042220 ; 3EC627
iir2_H_BandStop_f02519_q09_a1    set 0.91830849 ; 758B22
iir2_H_BandStop_f02519_q09_a2    set -0.48084441 ; C273B1

; IIR2: mode=BandStop fc=3174.8 Q=9 h=< 0.48814116 -0.87809764 0.48814116 0.87809764 -0.47628233 >,< 3E7B68 8F9A7F 3E7B68 706581 C3092F >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandStop_f03174_q09_b0    set 0.48814116 ; 3E7B68
iir2_H_BandStop_f03174_q09_b1    set -0.87809764 ; 8F9A7F
iir2_H_BandStop_f03174_q09_b2    set 0.48814116 ; 3E7B68
iir2_H_BandStop_f03174_q09_a1    set 0.87809764 ; 706581
iir2_H_BandStop_f03174_q09_a2    set -0.47628233 ; C3092F

; IIR2: mode=BandStop fc=4000 Q=9 h=< 0.48544139 -0.81743775 0.48544139 0.81743775 -0.47088278 >,< 3E22F1 975E33 3E22F1 68A1CD C3BA1D >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandStop_f04000_q09_b0    set 0.48544139 ; 3E22F1
iir2_H_BandStop_f04000_q09_b1    set -0.81743775 ; 975E33
iir2_H_BandStop_f04000_q09_b2    set 0.48544139 ; 3E22F1
iir2_H_BandStop_f04000_q09_a1    set 0.81743775 ; 68A1CD
iir2_H_BandStop_f04000_q09_a2    set -0.47088278 ; C3BA1D

; IIR2: mode=BandStop fc=5039.68 Q=9 h=< 0.48236052 -0.72653245 0.48236052 0.72653245 -0.46472105 >,< 3DBDFD A300FC 3DBDFD 5CFF04 C48406 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandStop_f05039_q09_b0    set 0.48236052 ; 3DBDFD
iir2_H_BandStop_f05039_q09_b1    set -0.72653245 ; A300FC
iir2_H_BandStop_f05039_q09_b2    set 0.48236052 ; 3DBDFD
iir2_H_BandStop_f05039_q09_a1    set 0.72653245 ; 5CFF04
iir2_H_BandStop_f05039_q09_a2    set -0.46472105 ; C48406

; IIR2: mode=BandStop fc=6349.6 Q=9 h=< 0.47906428 -0.59207436 0.47906428 0.59207436 -0.45812856 >,< 3D51FA B436E9 3D51FA 4BC917 C55C0B >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandStop_f06349_q09_b0    set 0.47906428 ; 3D51FA
iir2_H_BandStop_f06349_q09_b1    set -0.59207436 ; B436E9
iir2_H_BandStop_f06349_q09_b2    set 0.47906428 ; 3D51FA
iir2_H_BandStop_f06349_q09_a1    set 0.59207436 ; 4BC917
iir2_H_BandStop_f06349_q09_a2    set -0.45812856 ; C55C0B

; IIR2: mode=BandStop fc=8000 Q=9 h=< 0.47596332 -0.39768638 0.47596332 0.39768638 -0.45192663 >,< 3CEC5D CD189D 3CEC5D 32E763 C62745 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandStop_f08000_q09_b0    set 0.47596332 ; 3CEC5D
iir2_H_BandStop_f08000_q09_b1    set -0.39768638 ; CD189D
iir2_H_BandStop_f08000_q09_b2    set 0.47596332 ; 3CEC5D
iir2_H_BandStop_f08000_q09_a1    set 0.39768638 ; 32E763
iir2_H_BandStop_f08000_q09_a2    set -0.45192663 ; C62745

; IIR2: mode=BandStop fc=10079.4 Q=9 h=< 0.47389753 -0.12731014 0.47389753 0.12731014 -0.44779505 >,< 3CA8AC EFB44E 3CA8AC 104BB2 C6AEA7 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandStop_f10079_q09_b0    set 0.47389753 ; 3CA8AC
iir2_H_BandStop_f10079_q09_b1    set -0.12731014 ; EFB44E
iir2_H_BandStop_f10079_q09_b2    set 0.47389753 ; 3CA8AC
iir2_H_BandStop_f10079_q09_a1    set 0.12731014 ; 104BB2
iir2_H_BandStop_f10079_q09_a2    set -0.44779505 ; C6AEA7

; IIR2: mode=BandStop fc=12699.2 Q=9 h=< 0.47437867 0.22417111 0.47437867 -0.22417111 -0.44875734 >,< 3CB870 1CB1A3 3CB870 E34E5D C68F1F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandStop_f12699_q09_b0    set 0.47437867 ; 3CB870
iir2_H_BandStop_f12699_q09_b1    set 0.22417111 ; 1CB1A3
iir2_H_BandStop_f12699_q09_b2    set 0.47437867 ; 3CB870
iir2_H_BandStop_f12699_q09_a1    set -0.22417111 ; E34E5D
iir2_H_BandStop_f12699_q09_a2    set -0.44875734 ; C68F1F

; IIR2: mode=BandStop fc=16000 Q=9 h=< 0.47975634 0.62458180 0.47975634 -0.62458180 -0.45951268 >,< 3D68A8 4FF24C 3D68A8 B00DB4 C52EB1 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandStop_f16000_q09_b0    set 0.47975634 ; 3D68A8
iir2_H_BandStop_f16000_q09_b1    set 0.62458180 ; 4FF24C
iir2_H_BandStop_f16000_q09_b2    set 0.47975634 ; 3D68A8
iir2_H_BandStop_f16000_q09_a1    set -0.62458180 ; B00DB4
iir2_H_BandStop_f16000_q09_a2    set -0.45951268 ; C52EB1

; IIR2: mode=BandStop fc=20158.7 Q=9 h=< 0.49270934 0.94985982 0.49270934 -0.94985982 -0.48541869 >,< 3F1119 799501 3F1119 866AFF C1DDCD >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandStop_f20158_q09_b0    set 0.49270934 ; 3F1119
iir2_H_BandStop_f20158_q09_b1    set 0.94985982 ; 799501
iir2_H_BandStop_f20158_q09_b2    set 0.49270934 ; 3F1119
iir2_H_BandStop_f20158_q09_a1    set -0.94985982 ; 866AFF
iir2_H_BandStop_f20158_q09_a2    set -0.48541869 ; C1DDCD

; IIR2: mode=BandStop fc=62.5 Q=1 h=< 0.49769064 -0.99534181 0.49769064 0.99534181 -0.49538127 >,< 3FB453 8098A4 3FB453 7F675C C09759 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandStop_f00062_q01_b0    set 0.49769064 ; 3FB453
iir2_H_BandStop_f00062_q01_b1    set -0.99534181 ; 8098A4
iir2_H_BandStop_f00062_q01_b2    set 0.49769064 ; 3FB453
iir2_H_BandStop_f00062_q01_a1    set 0.99534181 ; 7F675C
iir2_H_BandStop_f00062_q01_a2    set -0.49538127 ; C09759

; IIR2: mode=BandStop fc=78.7451 Q=1 h=< 0.49709390 -0.99412522 0.49709390 0.99412522 -0.49418779 >,< 3FA0C5 80C081 3FA0C5 7F3F7F C0BE75 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandStop_f00078_q01_b0    set 0.49709390 ; 3FA0C5
iir2_H_BandStop_f00078_q01_b1    set -0.99412522 ; 80C081
iir2_H_BandStop_f00078_q01_b2    set 0.49709390 ; 3FA0C5
iir2_H_BandStop_f00078_q01_a1    set 0.99412522 ; 7F3F7F
iir2_H_BandStop_f00078_q01_a2    set -0.49418779 ; C0BE75

; IIR2: mode=BandStop fc=99.2126 Q=1 h=< 0.49634411 -0.99258904 0.49634411 0.99258904 -0.49268821 >,< 3F8834 80F2D8 3F8834 7F0D28 C0EF98 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandStop_f00099_q01_b0    set 0.49634411 ; 3F8834
iir2_H_BandStop_f00099_q01_b1    set -0.99258904 ; 80F2D8
iir2_H_BandStop_f00099_q01_b2    set 0.49634411 ; 3F8834
iir2_H_BandStop_f00099_q01_a1    set 0.99258904 ; 7F0D28
iir2_H_BandStop_f00099_q01_a2    set -0.49268821 ; C0EF98

; IIR2: mode=BandStop fc=125 Q=1 h=< 0.49540269 -0.99064825 0.49540269 0.99064825 -0.49080538 >,< 3F695B 813270 3F695B 7ECD90 C12D4A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandStop_f00125_q01_b0    set 0.49540269 ; 3F695B
iir2_H_BandStop_f00125_q01_b1    set -0.99064825 ; 813270
iir2_H_BandStop_f00125_q01_b2    set 0.49540269 ; 3F695B
iir2_H_BandStop_f00125_q01_a1    set 0.99064825 ; 7ECD90
iir2_H_BandStop_f00125_q01_a2    set -0.49080538 ; C12D4A

; IIR2: mode=BandStop fc=157.49 Q=1 h=< 0.49422174 -0.98819465 0.49422174 0.98819465 -0.48844348 >,< 3F42A8 8182D7 3F42A8 7E7D29 C17AB0 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandStop_f00157_q01_b0    set 0.49422174 ; 3F42A8
iir2_H_BandStop_f00157_q01_b1    set -0.98819465 ; 8182D7
iir2_H_BandStop_f00157_q01_b2    set 0.49422174 ; 3F42A8
iir2_H_BandStop_f00157_q01_a1    set 0.98819465 ; 7E7D29
iir2_H_BandStop_f00157_q01_a2    set -0.48844348 ; C17AB0

; IIR2: mode=BandStop fc=198.425 Q=1 h=< 0.49274200 -0.98509021 0.49274200 0.98509021 -0.48548400 >,< 3F122B 81E891 3F122B 7E176F C1DBA9 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandStop_f00198_q01_b0    set 0.49274200 ; 3F122B
iir2_H_BandStop_f00198_q01_b1    set -0.98509021 ; 81E891
iir2_H_BandStop_f00198_q01_b2    set 0.49274200 ; 3F122B
iir2_H_BandStop_f00198_q01_a1    set 0.98509021 ; 7E176F
iir2_H_BandStop_f00198_q01_a2    set -0.48548400 ; C1DBA9

; IIR2: mode=BandStop fc=250 Q=1 h=< 0.49089057 -0.98115840 0.49089057 0.98115840 -0.48178114 >,< 3ED580 826967 3ED580 7D9699 C254FF >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandStop_f00250_q01_b0    set 0.49089057 ; 3ED580
iir2_H_BandStop_f00250_q01_b1    set -0.98115840 ; 826967
iir2_H_BandStop_f00250_q01_b2    set 0.49089057 ; 3ED580
iir2_H_BandStop_f00250_q01_a1    set 0.98115840 ; 7D9699
iir2_H_BandStop_f00250_q01_a2    set -0.48178114 ; C254FF

; IIR2: mode=BandStop fc=314.98 Q=1 h=< 0.48857831 -0.97617282 0.48857831 0.97617282 -0.47715663 >,< 3E89BC 830CC5 3E89BC 7CF33B C2EC88 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandStop_f00314_q01_b0    set 0.48857831 ; 3E89BC
iir2_H_BandStop_f00314_q01_b1    set -0.97617282 ; 830CC5
iir2_H_BandStop_f00314_q01_b2    set 0.48857831 ; 3E89BC
iir2_H_BandStop_f00314_q01_a1    set 0.97617282 ; 7CF33B
iir2_H_BandStop_f00314_q01_a2    set -0.47715663 ; C2EC88

; IIR2: mode=BandStop fc=396.85 Q=1 h=< 0.48569726 -0.96984218 0.48569726 0.96984218 -0.47139451 >,< 3E2B54 83DC36 3E2B54 7C23CA C3A959 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandStop_f00396_q01_b0    set 0.48569726 ; 3E2B54
iir2_H_BandStop_f00396_q01_b1    set -0.96984218 ; 83DC36
iir2_H_BandStop_f00396_q01_b2    set 0.48569726 ; 3E2B54
iir2_H_BandStop_f00396_q01_a1    set 0.96984218 ; 7C23CA
iir2_H_BandStop_f00396_q01_a2    set -0.47139451 ; C3A959

; IIR2: mode=BandStop fc=500 Q=1 h=< 0.48211807 -0.96179050 0.48211807 0.96179050 -0.46423613 >,< 3DB60B 84E40D 3DB60B 7B1BF3 C493E9 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandStop_f00500_q01_b0    set 0.48211807 ; 3DB60B
iir2_H_BandStop_f00500_q01_b1    set -0.96179050 ; 84E40D
iir2_H_BandStop_f00500_q01_b2    set 0.48211807 ; 3DB60B
iir2_H_BandStop_f00500_q01_a1    set 0.96179050 ; 7B1BF3
iir2_H_BandStop_f00500_q01_a2    set -0.46423613 ; C493E9

; IIR2: mode=BandStop fc=629.961 Q=1 h=< 0.47768828 -0.95153097 0.47768828 0.95153097 -0.45537655 >,< 3D24E3 86343C 3D24E3 79CBC4 C5B639 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandStop_f00629_q01_b0    set 0.47768828 ; 3D24E3
iir2_H_BandStop_f00629_q01_b1    set -0.95153097 ; 86343C
iir2_H_BandStop_f00629_q01_b2    set 0.47768828 ; 3D24E3
iir2_H_BandStop_f00629_q01_a1    set 0.95153097 ; 79CBC4
iir2_H_BandStop_f00629_q01_a2    set -0.45537655 ; C5B639

; IIR2: mode=BandStop fc=793.701 Q=1 h=< 0.47223201 -0.93843163 0.47223201 0.93843163 -0.44446401 >,< 3C7219 87E179 3C7219 781E87 C71BCE >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandStop_f00793_q01_b0    set 0.47223201 ; 3C7219
iir2_H_BandStop_f00793_q01_b1    set -0.93843163 ; 87E179
iir2_H_BandStop_f00793_q01_b2    set 0.47223201 ; 3C7219
iir2_H_BandStop_f00793_q01_a1    set 0.93843163 ; 781E87
iir2_H_BandStop_f00793_q01_a2    set -0.44446401 ; C71BCE

; IIR2: mode=BandStop fc=1000 Q=1 h=< 0.46555257 -0.92167069 0.46555257 0.92167069 -0.43110514 >,< 3B973A 8A06B2 3B973A 75F94E C8D18C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandStop_f01000_q01_b0    set 0.46555257 ; 3B973A
iir2_H_BandStop_f01000_q01_b1    set -0.92167069 ; 8A06B2
iir2_H_BandStop_f01000_q01_b2    set 0.46555257 ; 3B973A
iir2_H_BandStop_f01000_q01_a1    set 0.92167069 ; 75F94E
iir2_H_BandStop_f01000_q01_a2    set -0.43110514 ; C8D18C

; IIR2: mode=BandStop fc=1259.92 Q=1 h=< 0.45744006 -0.90017945 0.45744006 0.90017945 -0.41488011 >,< 3A8D65 8CC6EC 3A8D65 733914 CAE536 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandStop_f01259_q01_b0    set 0.45744006 ; 3A8D65
iir2_H_BandStop_f01259_q01_b1    set -0.90017945 ; 8CC6EC
iir2_H_BandStop_f01259_q01_b2    set 0.45744006 ; 3A8D65
iir2_H_BandStop_f01259_q01_a1    set 0.90017945 ; 733914
iir2_H_BandStop_f01259_q01_a2    set -0.41488011 ; CAE536

; IIR2: mode=BandStop fc=1587.4 Q=1 h=< 0.44768687 -0.87257147 0.44768687 0.87257147 -0.39537375 >,< 394DCD 904F94 394DCD 6FB06C CD6465 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandStop_f01587_q01_b0    set 0.44768687 ; 394DCD
iir2_H_BandStop_f01587_q01_b1    set -0.87257147 ; 904F94
iir2_H_BandStop_f01587_q01_b2    set 0.44768687 ; 394DCD
iir2_H_BandStop_f01587_q01_a1    set 0.87257147 ; 6FB06C
iir2_H_BandStop_f01587_q01_a2    set -0.39537375 ; CD6465

; IIR2: mode=BandStop fc=2000 Q=1 h=< 0.43611535 -0.83705819 0.43611535 0.83705819 -0.37223069 >,< 37D2A0 94DB47 37D2A0 6B24B9 D05ABF >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandStop_f02000_q01_b0    set 0.43611535 ; 37D2A0
iir2_H_BandStop_f02000_q01_b1    set -0.83705819 ; 94DB47
iir2_H_BandStop_f02000_q01_b2    set 0.43611535 ; 37D2A0
iir2_H_BandStop_f02000_q01_a1    set 0.83705819 ; 6B24B9
iir2_H_BandStop_f02000_q01_a2    set -0.37223069 ; D05ABF

; IIR2: mode=BandStop fc=2519.84 Q=1 h=< 0.42262255 -0.79135461 0.42262255 0.79135461 -0.34524509 >,< 36187F 9AB4E5 36187F 654B1B D3CF03 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandStop_f02519_q01_b0    set 0.42262255 ; 36187F
iir2_H_BandStop_f02519_q01_b1    set -0.79135461 ; 9AB4E5
iir2_H_BandStop_f02519_q01_b2    set 0.42262255 ; 36187F
iir2_H_BandStop_f02519_q01_a1    set 0.79135461 ; 654B1B
iir2_H_BandStop_f02519_q01_a2    set -0.34524509 ; D3CF03

; IIR2: mode=BandStop fc=3174.8 Q=1 h=< 0.40724824 -0.73258259 0.40724824 0.73258259 -0.31449647 >,< 3420B5 A23ABC 3420B5 5DC544 D7BE95 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandStop_f03174_q01_b0    set 0.40724824 ; 3420B5
iir2_H_BandStop_f03174_q01_b1    set -0.73258259 ; A23ABC
iir2_H_BandStop_f03174_q01_b2    set 0.40724824 ; 3420B5
iir2_H_BandStop_f03174_q01_a1    set 0.73258259 ; 5DC544
iir2_H_BandStop_f03174_q01_a2    set -0.31449647 ; D7BE95

; IIR2: mode=BandStop fc=4000 Q=1 h=< 0.39027212 -0.65718163 0.39027212 0.65718163 -0.28054424 >,< 31F46F ABE179 31F46F 541E87 DC1721 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandStop_f04000_q01_b0    set 0.39027212 ; 31F46F
iir2_H_BandStop_f04000_q01_b1    set -0.65718163 ; ABE179
iir2_H_BandStop_f04000_q01_b2    set 0.39027212 ; 31F46F
iir2_H_BandStop_f04000_q01_a1    set 0.65718163 ; 541E87
iir2_H_BandStop_f04000_q01_a2    set -0.28054424 ; DC1721

; IIR2: mode=BandStop fc=5039.68 Q=1 h=< 0.37234764 -0.56083081 0.37234764 0.56083081 -0.24469528 >,< 2FA916 B836B2 2FA916 47C94E E0ADD4 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandStop_f05039_q01_b0    set 0.37234764 ; 2FA916
iir2_H_BandStop_f05039_q01_b1    set -0.56083081 ; B836B2
iir2_H_BandStop_f05039_q01_b2    set 0.37234764 ; 2FA916
iir2_H_BandStop_f05039_q01_a1    set 0.56083081 ; 47C94E
iir2_H_BandStop_f05039_q01_a2    set -0.24469528 ; E0ADD4

; IIR2: mode=BandStop fc=6349.6 Q=1 h=< 0.35468673 -0.43835645 0.35468673 0.43835645 -0.20937345 >,< 2D6660 C7E3F0 2D6660 381C10 E53341 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandStop_f06349_q01_b0    set 0.35468673 ; 2D6660
iir2_H_BandStop_f06349_q01_b1    set -0.43835645 ; C7E3F0
iir2_H_BandStop_f06349_q01_b2    set 0.35468673 ; 2D6660
iir2_H_BandStop_f06349_q01_a1    set 0.43835645 ; 381C10
iir2_H_BandStop_f06349_q01_a2    set -0.20937345 ; E53341

; IIR2: mode=BandStop fc=8000 Q=1 h=< 0.33934135 -0.28353326 0.33934135 0.28353326 -0.17868269 >,< 2B6F89 DBB52F 2B6F89 244AD1 E920ED >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandStop_f08000_q01_b0    set 0.33934135 ; 2B6F89
iir2_H_BandStop_f08000_q01_b1    set -0.28353326 ; DBB52F
iir2_H_BandStop_f08000_q01_b2    set 0.33934135 ; 2B6F89
iir2_H_BandStop_f08000_q01_a1    set 0.28353326 ; 244AD1
iir2_H_BandStop_f08000_q01_a2    set -0.17868269 ; E920ED

; IIR2: mode=BandStop fc=10079.4 Q=1 h=< 0.32973418 -0.08858140 0.32973418 0.08858140 -0.15946836 >,< 2A34BA F4A95E 2A34BA 0B56A2 EB968B >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandStop_f10079_q01_b0    set 0.32973418 ; 2A34BA
iir2_H_BandStop_f10079_q01_b1    set -0.08858140 ; F4A95E
iir2_H_BandStop_f10079_q01_b2    set 0.32973418 ; 2A34BA
iir2_H_BandStop_f10079_q01_a1    set 0.08858140 ; 0B56A2
iir2_H_BandStop_f10079_q01_a2    set -0.15946836 ; EB968B

; IIR2: mode=BandStop fc=12699.2 Q=1 h=< 0.33193023 0.15685606 0.33193023 -0.15685606 -0.16386045 >,< 2A7CB0 1413DC 2A7CB0 EBEC24 EB069F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandStop_f12699_q01_b0    set 0.33193023 ; 2A7CB0
iir2_H_BandStop_f12699_q01_b1    set 0.15685606 ; 1413DC
iir2_H_BandStop_f12699_q01_b2    set 0.33193023 ; 2A7CB0
iir2_H_BandStop_f12699_q01_a1    set -0.15685606 ; EBEC24
iir2_H_BandStop_f12699_q01_a2    set -0.16386045 ; EB069F

; IIR2: mode=BandStop fc=16000 Q=1 h=< 0.35827392 0.46642712 0.35827392 -0.46642712 -0.21654784 >,< 2DDBEB 3BB3E2 2DDBEB C44C1E E44829 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandStop_f16000_q01_b0    set 0.35827392 ; 2DDBEB
iir2_H_BandStop_f16000_q01_b1    set 0.46642712 ; 3BB3E2
iir2_H_BandStop_f16000_q01_b2    set 0.35827392 ; 2DDBEB
iir2_H_BandStop_f16000_q01_a1    set -0.46642712 ; C44C1E
iir2_H_BandStop_f16000_q01_a2    set -0.21654784 ; E44829

; IIR2: mode=BandStop fc=20158.7 Q=1 h=< 0.43908914 0.84648918 0.43908914 -0.84648918 -0.37817827 >,< 383412 6C59C2 383412 93A63E CF97DB >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandStop_f20158_q01_b0    set 0.43908914 ; 383412
iir2_H_BandStop_f20158_q01_b1    set 0.84648918 ; 6C59C2
iir2_H_BandStop_f20158_q01_b2    set 0.43908914 ; 383412
iir2_H_BandStop_f20158_q01_a1    set -0.84648918 ; 93A63E
iir2_H_BandStop_f20158_q01_a2    set -0.37817827 ; CF97DB

; IIR2: mode=BandStop fc=62.5 Q=3 h=< 0.49925562 -0.99847165 0.49925562 0.99847165 -0.49851124 >,< 3FE79B 803215 3FE79B 7FCDEB C030C9 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandStop_f00062_q03_b0    set 0.49925562 ; 3FE79B
iir2_H_BandStop_f00062_q03_b1    set -0.99847165 ; 803215
iir2_H_BandStop_f00062_q03_b2    set 0.49925562 ; 3FE79B
iir2_H_BandStop_f00062_q03_a1    set 0.99847165 ; 7FCDEB
iir2_H_BandStop_f00062_q03_a2    set -0.49851124 ; C030C9

; IIR2: mode=BandStop fc=78.7451 Q=3 h=< 0.49906251 -0.99806220 0.49906251 0.99806220 -0.49812501 >,< 3FE147 803F80 3FE147 7FC080 C03D71 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandStop_f00078_q03_b0    set 0.49906251 ; 3FE147
iir2_H_BandStop_f00078_q03_b1    set -0.99806220 ; 803F80
iir2_H_BandStop_f00078_q03_b2    set 0.49906251 ; 3FE147
iir2_H_BandStop_f00078_q03_a1    set 0.99806220 ; 7FC080
iir2_H_BandStop_f00078_q03_a2    set -0.49812501 ; C03D71

; IIR2: mode=BandStop fc=99.2126 Q=3 h=< 0.49881942 -0.99753918 0.49881942 0.99753918 -0.49763885 >,< 3FD950 8050A3 3FD950 7FAF5D C04D5F >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandStop_f00099_q03_b0    set 0.49881942 ; 3FD950
iir2_H_BandStop_f00099_q03_b1    set -0.99753918 ; 8050A3
iir2_H_BandStop_f00099_q03_b2    set 0.49881942 ; 3FD950
iir2_H_BandStop_f00099_q03_a1    set 0.99753918 ; 7FAF5D
iir2_H_BandStop_f00099_q03_a2    set -0.49763885 ; C04D5F

; IIR2: mode=BandStop fc=125 Q=3 h=< 0.49851351 -0.99686890 0.49851351 0.99686890 -0.49702701 >,< 3FCF4A 80669A 3FCF4A 7F9966 C0616C >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandStop_f00125_q03_b0    set 0.49851351 ; 3FCF4A
iir2_H_BandStop_f00125_q03_b1    set -0.99686890 ; 80669A
iir2_H_BandStop_f00125_q03_b2    set 0.49851351 ; 3FCF4A
iir2_H_BandStop_f00125_q03_a1    set 0.99686890 ; 7F9966
iir2_H_BandStop_f00125_q03_a2    set -0.49702701 ; C0616C

; IIR2: mode=BandStop fc=157.49 Q=3 h=< 0.49812864 -0.99600649 0.49812864 0.99600649 -0.49625728 >,< 3FC2AE 8082DC 3FC2AE 7F7D24 C07AA5 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandStop_f00157_q03_b0    set 0.49812864 ; 3FC2AE
iir2_H_BandStop_f00157_q03_b1    set -0.99600649 ; 8082DC
iir2_H_BandStop_f00157_q03_b2    set 0.49812864 ; 3FC2AE
iir2_H_BandStop_f00157_q03_a1    set 0.99600649 ; 7F7D24
iir2_H_BandStop_f00157_q03_a2    set -0.49625728 ; C07AA5

; IIR2: mode=BandStop fc=198.425 Q=3 h=< 0.49764464 -0.99489157 0.49764464 0.99489157 -0.49528928 >,< 3FB2D1 80A765 3FB2D1 7F589B C09A5D >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandStop_f00198_q03_b0    set 0.49764464 ; 3FB2D1
iir2_H_BandStop_f00198_q03_b1    set -0.99489157 ; 80A765
iir2_H_BandStop_f00198_q03_b2    set 0.49764464 ; 3FB2D1
iir2_H_BandStop_f00198_q03_a1    set 0.99489157 ; 7F589B
iir2_H_BandStop_f00198_q03_a2    set -0.49528928 ; C09A5D

; IIR2: mode=BandStop fc=250 Q=3 h=< 0.49703629 -0.99344206 0.49703629 0.99344206 -0.49407259 >,< 3F9EE2 80D6E4 3F9EE2 7F291C C0C23B >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandStop_f00250_q03_b0    set 0.49703629 ; 3F9EE2
iir2_H_BandStop_f00250_q03_b1    set -0.99344206 ; 80D6E4
iir2_H_BandStop_f00250_q03_b2    set 0.49703629 ; 3F9EE2
iir2_H_BandStop_f00250_q03_a1    set 0.99344206 ; 7F291C
iir2_H_BandStop_f00250_q03_a2    set -0.49407259 ; C0C23B

; IIR2: mode=BandStop fc=314.98 Q=3 h=< 0.49627217 -0.99154504 0.49627217 0.99154504 -0.49254434 >,< 3F85D8 81150E 3F85D8 7EEAF2 C0F44F >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandStop_f00314_q03_b0    set 0.49627217 ; 3F85D8
iir2_H_BandStop_f00314_q03_b1    set -0.99154504 ; 81150E
iir2_H_BandStop_f00314_q03_b2    set 0.49627217 ; 3F85D8
iir2_H_BandStop_f00314_q03_a1    set 0.99154504 ; 7EEAF2
iir2_H_BandStop_f00314_q03_a2    set -0.49254434 ; C0F44F

; IIR2: mode=BandStop fc=396.85 Q=3 h=< 0.49531323 -0.98904338 0.49531323 0.98904338 -0.49062645 >,< 3F666C 816707 3F666C 7E98F9 C13327 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandStop_f00396_q03_b0    set 0.49531323 ; 3F666C
iir2_H_BandStop_f00396_q03_b1    set -0.98904338 ; 816707
iir2_H_BandStop_f00396_q03_b2    set 0.49531323 ; 3F666C
iir2_H_BandStop_f00396_q03_a1    set 0.98904338 ; 7E98F9
iir2_H_BandStop_f00396_q03_a2    set -0.49062645 ; C13327

; IIR2: mode=BandStop fc=500 Q=3 h=< 0.49411121 -0.98571594 0.49411121 0.98571594 -0.48822242 >,< 3F3F09 81D410 3F3F09 7E2BF0 C181EE >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandStop_f00500_q03_b0    set 0.49411121 ; 3F3F09
iir2_H_BandStop_f00500_q03_b1    set -0.98571594 ; 81D410
iir2_H_BandStop_f00500_q03_b2    set 0.49411121 ; 3F3F09
iir2_H_BandStop_f00500_q03_a1    set 0.98571594 ; 7E2BF0
iir2_H_BandStop_f00500_q03_a2    set -0.48822242 ; C181EE

; IIR2: mode=BandStop fc=629.961 Q=3 h=< 0.49260685 -0.98124802 0.49260685 0.98124802 -0.48521371 >,< 3F0DBD 826677 3F0DBD 7D9989 C1E485 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandStop_f00629_q03_b0    set 0.49260685 ; 3F0DBD
iir2_H_BandStop_f00629_q03_b1    set -0.98124802 ; 826677
iir2_H_BandStop_f00629_q03_b2    set 0.49260685 ; 3F0DBD
iir2_H_BandStop_f00629_q03_a1    set 0.98124802 ; 7D9989
iir2_H_BandStop_f00629_q03_a2    set -0.48521371 ; C1E485

; IIR2: mode=BandStop fc=793.701 Q=3 h=< 0.49072807 -0.97518748 0.49072807 0.97518748 -0.48145613 >,< 3ED02D 832D0F 3ED02D 7CD2F1 C25FA6 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandStop_f00793_q03_b0    set 0.49072807 ; 3ED02D
iir2_H_BandStop_f00793_q03_b1    set -0.97518748 ; 832D0F
iir2_H_BandStop_f00793_q03_b2    set 0.49072807 ; 3ED02D
iir2_H_BandStop_f00793_q03_a1    set 0.97518748 ; 7CD2F1
iir2_H_BandStop_f00793_q03_a2    set -0.48145613 ; C25FA6

; IIR2: mode=BandStop fc=1000 Q=3 h=< 0.48838835 -0.96687949 0.48838835 0.96687949 -0.47677671 >,< 3E8382 843D4B 3E8382 7BC2B5 C2F8FB >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandStop_f01000_q03_b0    set 0.48838835 ; 3E8382
iir2_H_BandStop_f01000_q03_b1    set -0.96687949 ; 843D4B
iir2_H_BandStop_f01000_q03_b2    set 0.48838835 ; 3E8382
iir2_H_BandStop_f01000_q03_a1    set 0.96687949 ; 7BC2B5
iir2_H_BandStop_f01000_q03_a2    set -0.47677671 ; C2F8FB

; IIR2: mode=BandStop fc=1259.92 Q=3 h=< 0.48548610 -0.95537023 0.48548610 0.95537023 -0.47097221 >,< 3E2468 85B66E 3E2468 7A4992 C3B72F >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandStop_f01259_q03_b0    set 0.48548610 ; 3E2468
iir2_H_BandStop_f01259_q03_b1    set -0.95537023 ; 85B66E
iir2_H_BandStop_f01259_q03_b2    set 0.48548610 ; 3E2468
iir2_H_BandStop_f01259_q03_a1    set 0.95537023 ; 7A4992
iir2_H_BandStop_f01259_q03_a2    set -0.47097221 ; C3B72F

; IIR2: mode=BandStop fc=1587.4 Q=3 h=< 0.48190582 -0.93926647 0.48190582 0.93926647 -0.46381164 >,< 3DAF17 87C61E 3DAF17 7839E2 C4A1D2 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandStop_f01587_q03_b0    set 0.48190582 ; 3DAF17
iir2_H_BandStop_f01587_q03_b1    set -0.93926647 ; 87C61E
iir2_H_BandStop_f01587_q03_b2    set 0.48190582 ; 3DAF17
iir2_H_BandStop_f01587_q03_a1    set 0.93926647 ; 7839E2
iir2_H_BandStop_f01587_q03_a2    set -0.46381164 ; C4A1D2

; IIR2: mode=BandStop fc=2000 Q=3 h=< 0.47752342 -0.91653480 0.47752342 0.91653480 -0.45504684 >,< 3D1F7C 8AAEFD 3D1F7C 755103 C5C107 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandStop_f02000_q03_b0    set 0.47752342 ; 3D1F7C
iir2_H_BandStop_f02000_q03_b1    set -0.91653480 ; 8AAEFD
iir2_H_BandStop_f02000_q03_b2    set 0.47752342 ; 3D1F7C
iir2_H_BandStop_f02000_q03_a1    set 0.91653480 ; 755103
iir2_H_BandStop_f02000_q03_a2    set -0.45504684 ; C5C107

; IIR2: mode=BandStop fc=2519.84 Q=3 h=< 0.47221914 -0.88422351 0.47221914 0.88422351 -0.44443828 >,< 3C71AD 8ED1C4 3C71AD 712E3C C71CA6 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandStop_f02519_q03_b0    set 0.47221914 ; 3C71AD
iir2_H_BandStop_f02519_q03_b1    set -0.88422351 ; 8ED1C4
iir2_H_BandStop_f02519_q03_b2    set 0.47221914 ; 3C71AD
iir2_H_BandStop_f02519_q03_a1    set 0.88422351 ; 712E3C
iir2_H_BandStop_f02519_q03_a2    set -0.44443828 ; C71CA6

; IIR2: mode=BandStop fc=3174.8 Q=3 h=< 0.46590427 -0.83809658 0.46590427 0.83809658 -0.43180854 >,< 3BA2C0 94B941 3BA2C0 6B46BF C8BA80 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandStop_f03174_q03_b0    set 0.46590427 ; 3BA2C0
iir2_H_BandStop_f03174_q03_b1    set -0.83809658 ; 94B941
iir2_H_BandStop_f03174_q03_b2    set 0.46590427 ; 3BA2C0
iir2_H_BandStop_f03174_q03_a1    set 0.83809658 ; 6B46BF
iir2_H_BandStop_f03174_q03_a2    set -0.43180854 ; C8BA80

; IIR2: mode=BandStop fc=4000 Q=3 h=< 0.45857170 -0.77219172 0.45857170 0.77219172 -0.41714341 >,< 3AB27A 9D28D3 3AB27A 62D72D CA9B0C >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandStop_f04000_q03_b0    set 0.45857170 ; 3AB27A
iir2_H_BandStop_f04000_q03_b1    set -0.77219172 ; 9D28D3
iir2_H_BandStop_f04000_q03_b2    set 0.45857170 ; 3AB27A
iir2_H_BandStop_f04000_q03_a1    set 0.77219172 ; 62D72D
iir2_H_BandStop_f04000_q03_a2    set -0.41714341 ; CA9B0C

; IIR2: mode=BandStop fc=5039.68 Q=3 h=< 0.45038587 -0.67837216 0.45038587 0.67837216 -0.40077175 >,< 39A63E A92B1A 39A63E 56D4E6 CCB383 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandStop_f05039_q03_b0    set 0.45038587 ; 39A63E
iir2_H_BandStop_f05039_q03_b1    set -0.67837216 ; A92B1A
iir2_H_BandStop_f05039_q03_b2    set 0.45038587 ; 39A63E
iir2_H_BandStop_f05039_q03_a1    set 0.67837216 ; 56D4E6
iir2_H_BandStop_f05039_q03_a2    set -0.40077175 ; CCB383

; IIR2: mode=BandStop fc=6349.6 Q=3 h=< 0.44183511 -0.54606291 0.44183511 0.54606291 -0.38367022 >,< 388E0D BA1A9D 388E0D 45E563 CEE3E5 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandStop_f06349_q03_b0    set 0.44183511 ; 388E0D
iir2_H_BandStop_f06349_q03_b1    set -0.54606291 ; BA1A9D
iir2_H_BandStop_f06349_q03_b2    set 0.44183511 ; 388E0D
iir2_H_BandStop_f06349_q03_a1    set 0.54606291 ; 45E563
iir2_H_BandStop_f06349_q03_a2    set -0.38367022 ; CEE3E5

; IIR2: mode=BandStop fc=8000 Q=3 h=< 0.43397975 -0.36260743 0.43397975 0.36260743 -0.36795950 >,< 378CA6 D19615 378CA6 2E69EB D0E6B4 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandStop_f08000_q03_b0    set 0.43397975 ; 378CA6
iir2_H_BandStop_f08000_q03_b1    set -0.36260743 ; D19615
iir2_H_BandStop_f08000_q03_b2    set 0.43397975 ; 378CA6
iir2_H_BandStop_f08000_q03_a1    set 0.36260743 ; 2E69EB
iir2_H_BandStop_f08000_q03_a2    set -0.36795950 ; D0E6B4

; IIR2: mode=BandStop fc=10079.4 Q=3 h=< 0.42884517 -0.11520706 0.42884517 0.11520706 -0.35769034 >,< 36E466 F140E6 36E466 0EBF1A D23734 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandStop_f10079_q03_b0    set 0.42884517 ; 36E466
iir2_H_BandStop_f10079_q03_b1    set -0.11520706 ; F140E6
iir2_H_BandStop_f10079_q03_b2    set 0.42884517 ; 36E466
iir2_H_BandStop_f10079_q03_a1    set 0.11520706 ; 0EBF1A
iir2_H_BandStop_f10079_q03_a2    set -0.35769034 ; D23734

; IIR2: mode=BandStop fc=12699.2 Q=3 h=< 0.43003415 0.20321579 0.43003415 -0.20321579 -0.36006830 >,< 370B5C 1A02F9 370B5C E5FD07 D1E949 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandStop_f12699_q03_b0    set 0.43003415 ; 370B5C
iir2_H_BandStop_f12699_q03_b1    set 0.20321579 ; 1A02F9
iir2_H_BandStop_f12699_q03_b2    set 0.43003415 ; 370B5C
iir2_H_BandStop_f12699_q03_a1    set -0.20321579 ; E5FD07
iir2_H_BandStop_f12699_q03_a2    set -0.36006830 ; D1E949

; IIR2: mode=BandStop fc=16000 Q=3 h=< 0.44361298 0.57752773 0.44361298 -0.57752773 -0.38722595 >,< 38C84F 49EC6D 38C84F B61393 CE6F62 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandStop_f16000_q03_b0    set 0.44361298 ; 38C84F
iir2_H_BandStop_f16000_q03_b1    set 0.57752773 ; 49EC6D
iir2_H_BandStop_f16000_q03_b2    set 0.44361298 ; 38C84F
iir2_H_BandStop_f16000_q03_a1    set -0.57752773 ; B61393
iir2_H_BandStop_f16000_q03_a2    set -0.38722595 ; CE6F62

; IIR2: mode=BandStop fc=20158.7 Q=3 h=< 0.47866399 0.92278277 0.47866399 -0.92278277 -0.45732798 >,< 3D44DC 761DBF 3D44DC 89E241 C57647 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandStop_f20158_q03_b0    set 0.47866399 ; 3D44DC
iir2_H_BandStop_f20158_q03_b1    set 0.92278277 ; 761DBF
iir2_H_BandStop_f20158_q03_b2    set 0.47866399 ; 3D44DC
iir2_H_BandStop_f20158_q03_a1    set -0.92278277 ; 89E241
iir2_H_BandStop_f20158_q03_a2    set -0.45732798 ; C57647

; IIR2: mode=BandStop fc=62.5 Q=9 h=< 0.49975264 -0.99946566 0.49975264 0.99946566 -0.49950529 >,< 3FF7E5 801183 3FF7E5 7FEE7D C01036 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_BandStop_f00062_q09_b0    set 0.49975264 ; 3FF7E5
iir2_H_BandStop_f00062_q09_b1    set -0.99946566 ; 801183
iir2_H_BandStop_f00062_q09_b2    set 0.49975264 ; 3FF7E5
iir2_H_BandStop_f00062_q09_a1    set 0.99946566 ; 7FEE7D
iir2_H_BandStop_f00062_q09_a2    set -0.49950529 ; C01036

; IIR2: mode=BandStop fc=78.7451 Q=9 h=< 0.49968839 -0.99931389 0.49968839 0.99931389 -0.49937679 >,< 3FF5CA 80167C 3FF5CA 7FE984 C0146C >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_BandStop_f00078_q09_b0    set 0.49968839 ; 3FF5CA
iir2_H_BandStop_f00078_q09_b1    set -0.99931389 ; 80167C
iir2_H_BandStop_f00078_q09_b2    set 0.49968839 ; 3FF5CA
iir2_H_BandStop_f00078_q09_a1    set 0.99931389 ; 7FE984
iir2_H_BandStop_f00078_q09_a2    set -0.49937679 ; C0146C

; IIR2: mode=BandStop fc=99.2126 Q=9 h=< 0.49960747 -0.99911511 0.49960747 0.99911511 -0.49921494 >,< 3FF323 801CFF 3FF323 7FE301 C019BA >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_BandStop_f00099_q09_b0    set 0.49960747 ; 3FF323
iir2_H_BandStop_f00099_q09_b1    set -0.99911511 ; 801CFF
iir2_H_BandStop_f00099_q09_b2    set 0.49960747 ; 3FF323
iir2_H_BandStop_f00099_q09_a1    set 0.99911511 ; 7FE301
iir2_H_BandStop_f00099_q09_a2    set -0.49921494 ; C019BA

; IIR2: mode=BandStop fc=125 Q=9 h=< 0.49950555 -0.99885268 0.49950555 0.99885268 -0.49901111 >,< 3FEFCC 802599 3FEFCC 7FDA67 C02068 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_BandStop_f00125_q09_b0    set 0.49950555 ; 3FEFCC
iir2_H_BandStop_f00125_q09_b1    set -0.99885268 ; 802599
iir2_H_BandStop_f00125_q09_b2    set 0.49950555 ; 3FEFCC
iir2_H_BandStop_f00125_q09_a1    set 0.99885268 ; 7FDA67
iir2_H_BandStop_f00125_q09_a2    set -0.49901111 ; C02068

; IIR2: mode=BandStop fc=157.49 Q=9 h=< 0.49937722 -0.99850301 0.49937722 0.99850301 -0.49875443 >,< 3FEB97 80310E 3FEB97 7FCEF2 C028D1 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_BandStop_f00157_q09_b0    set 0.49937722 ; 3FEB97
iir2_H_BandStop_f00157_q09_b1    set -0.99850301 ; 80310E
iir2_H_BandStop_f00157_q09_b2    set 0.49937722 ; 3FEB97
iir2_H_BandStop_f00157_q09_a1    set 0.99850301 ; 7FCEF2
iir2_H_BandStop_f00157_q09_a2    set -0.49875443 ; C028D1

; IIR2: mode=BandStop fc=198.425 Q=9 h=< 0.49921563 -0.99803230 0.49921563 0.99803230 -0.49843127 >,< 3FE64C 80407B 3FE64C 7FBF85 C03368 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_BandStop_f00198_q09_b0    set 0.49921563 ; 3FE64C
iir2_H_BandStop_f00198_q09_b1    set -0.99803230 ; 80407B
iir2_H_BandStop_f00198_q09_b2    set 0.49921563 ; 3FE64C
iir2_H_BandStop_f00198_q09_a1    set 0.99803230 ; 7FBF85
iir2_H_BandStop_f00198_q09_a2    set -0.49843127 ; C03368

; IIR2: mode=BandStop fc=250 Q=9 h=< 0.49901224 -0.99739144 0.49901224 0.99739144 -0.49802448 >,< 3FDFA2 80557A 3FDFA2 7FAA86 C040BC >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_BandStop_f00250_q09_b0    set 0.49901224 ; 3FDFA2
iir2_H_BandStop_f00250_q09_b1    set -0.99739144 ; 80557A
iir2_H_BandStop_f00250_q09_b2    set 0.49901224 ; 3FDFA2
iir2_H_BandStop_f00250_q09_a1    set 0.99739144 ; 7FAA86
iir2_H_BandStop_f00250_q09_a2    set -0.49802448 ; C040BC

; IIR2: mode=BandStop fc=314.98 Q=9 h=< 0.49875629 -0.99650828 0.49875629 0.99650828 -0.49751259 >,< 3FD73F 80726B 3FD73F 7F8D95 C05182 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_BandStop_f00314_q09_b0    set 0.49875629 ; 3FD73F
iir2_H_BandStop_f00314_q09_b1    set -0.99650828 ; 80726B
iir2_H_BandStop_f00314_q09_b2    set 0.49875629 ; 3FD73F
iir2_H_BandStop_f00314_q09_a1    set 0.99650828 ; 7F8D95
iir2_H_BandStop_f00314_q09_a2    set -0.49751259 ; C05182

; IIR2: mode=BandStop fc=396.85 Q=9 h=< 0.49843435 -0.99527565 0.49843435 0.99527565 -0.49686870 >,< 3FCCB2 809ACF 3FCCB2 7F6531 C0669C >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_BandStop_f00396_q09_b0    set 0.49843435 ; 3FCCB2
iir2_H_BandStop_f00396_q09_b1    set -0.99527565 ; 809ACF
iir2_H_BandStop_f00396_q09_b2    set 0.49843435 ; 3FCCB2
iir2_H_BandStop_f00396_q09_a1    set 0.99527565 ; 7F6531
iir2_H_BandStop_f00396_q09_a2    set -0.49686870 ; C0669C

; IIR2: mode=BandStop fc=500 Q=9 h=< 0.49802962 -0.99353289 0.49802962 0.99353289 -0.49605924 >,< 3FBF6F 80D3EA 3FBF6F 7F2C16 C08122 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_BandStop_f00500_q09_b0    set 0.49802962 ; 3FBF6F
iir2_H_BandStop_f00500_q09_b1    set -0.99353289 ; 80D3EA
iir2_H_BandStop_f00500_q09_b2    set 0.49802962 ; 3FBF6F
iir2_H_BandStop_f00500_q09_a1    set 0.99353289 ; 7F2C16
iir2_H_BandStop_f00500_q09_a2    set -0.49605924 ; C08122

; IIR2: mode=BandStop fc=629.961 Q=9 h=< 0.49752124 -0.99103724 0.49752124 0.99103724 -0.49504249 >,< 3FAEC6 8125B1 3FAEC6 7EDA4F C0A273 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_BandStop_f00629_q09_b0    set 0.49752124 ; 3FAEC6
iir2_H_BandStop_f00629_q09_b1    set -0.99103724 ; 8125B1
iir2_H_BandStop_f00629_q09_b2    set 0.49752124 ; 3FAEC6
iir2_H_BandStop_f00629_q09_a1    set 0.99103724 ; 7EDA4F
iir2_H_BandStop_f00629_q09_a2    set -0.49504249 ; C0A273

; IIR2: mode=BandStop fc=793.701 Q=9 h=< 0.49688343 -0.98741958 0.49688343 0.98741958 -0.49376685 >,< 3F99E0 819C3D 3F99E0 7E63C3 C0CC40 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_BandStop_f00793_q09_b0    set 0.49688343 ; 3F99E0
iir2_H_BandStop_f00793_q09_b1    set -0.98741958 ; 819C3D
iir2_H_BandStop_f00793_q09_b2    set 0.49688343 ; 3F99E0
iir2_H_BandStop_f00793_q09_a1    set 0.98741958 ; 7E63C3
iir2_H_BandStop_f00793_q09_a2    set -0.49376685 ; C0CC40

; IIR2: mode=BandStop fc=1000 Q=9 h=< 0.49608459 -0.98211599 0.49608459 0.98211599 -0.49216917 >,< 3F7FB3 824A06 3F7FB3 7DB5FA C1009A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_BandStop_f01000_q09_b0    set 0.49608459 ; 3F7FB3
iir2_H_BandStop_f01000_q09_b1    set -0.98211599 ; 824A06
iir2_H_BandStop_f01000_q09_b2    set 0.49608459 ; 3F7FB3
iir2_H_BandStop_f01000_q09_a1    set 0.98211599 ; 7DB5FA
iir2_H_BandStop_f01000_q09_a2    set -0.49216917 ; C1009A

; IIR2: mode=BandStop fc=1259.92 Q=9 h=< 0.49508660 -0.97426271 0.49508660 0.97426271 -0.49017321 >,< 3F5EFF 834B5C 3F5EFF 7CB4A4 C14201 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_BandStop_f01259_q09_b0    set 0.49508660 ; 3F5EFF
iir2_H_BandStop_f01259_q09_b1    set -0.97426271 ; 834B5C
iir2_H_BandStop_f01259_q09_b2    set 0.49508660 ; 3F5EFF
iir2_H_BandStop_f01259_q09_a1    set 0.97426271 ; 7CB4A4
iir2_H_BandStop_f01259_q09_a2    set -0.49017321 ; C14201

; IIR2: mode=BandStop fc=1587.4 Q=9 h=< 0.49384454 -0.96253583 0.49384454 0.96253583 -0.48768909 >,< 3F364C 84CBA0 3F364C 7B3460 C19368 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_BandStop_f01587_q09_b0    set 0.49384454 ; 3F364C
iir2_H_BandStop_f01587_q09_b1    set -0.96253583 ; 84CBA0
iir2_H_BandStop_f01587_q09_b2    set 0.49384454 ; 3F364C
iir2_H_BandStop_f01587_q09_a1    set 0.96253583 ; 7B3460
iir2_H_BandStop_f01587_q09_a2    set -0.48768909 ; C19368

; IIR2: mode=BandStop fc=2000 Q=9 h=< 0.49230754 -0.94491070 0.49230754 0.94491070 -0.48461508 >,< 3F03EF 870D2B 3F03EF 78F2D5 C1F822 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_BandStop_f02000_q09_b0    set 0.49230754 ; 3F03EF
iir2_H_BandStop_f02000_q09_b1    set -0.94491070 ; 870D2B
iir2_H_BandStop_f02000_q09_b2    set 0.49230754 ; 3F03EF
iir2_H_BandStop_f02000_q09_a1    set 0.94491070 ; 78F2D5
iir2_H_BandStop_f02000_q09_a2    set -0.48461508 ; C1F822

; IIR2: mode=BandStop fc=2519.84 Q=9 h=< 0.49042220 -0.91830849 0.49042220 0.91830849 -0.48084441 >,< 3EC627 8A74DE 3EC627 758B22 C273B1 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_BandStop_f02519_q09_b0    set 0.49042220 ; 3EC627
iir2_H_BandStop_f02519_q09_b1    set -0.91830849 ; 8A74DE
iir2_H_BandStop_f02519_q09_b2    set 0.49042220 ; 3EC627
iir2_H_BandStop_f02519_q09_a1    set 0.91830849 ; 758B22
iir2_H_BandStop_f02519_q09_a2    set -0.48084441 ; C273B1

; IIR2: mode=BandStop fc=3174.8 Q=9 h=< 0.48814116 -0.87809764 0.48814116 0.87809764 -0.47628233 >,< 3E7B68 8F9A7F 3E7B68 706581 C3092F >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_BandStop_f03174_q09_b0    set 0.48814116 ; 3E7B68
iir2_H_BandStop_f03174_q09_b1    set -0.87809764 ; 8F9A7F
iir2_H_BandStop_f03174_q09_b2    set 0.48814116 ; 3E7B68
iir2_H_BandStop_f03174_q09_a1    set 0.87809764 ; 706581
iir2_H_BandStop_f03174_q09_a2    set -0.47628233 ; C3092F

; IIR2: mode=BandStop fc=4000 Q=9 h=< 0.48544139 -0.81743775 0.48544139 0.81743775 -0.47088278 >,< 3E22F1 975E33 3E22F1 68A1CD C3BA1D >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_BandStop_f04000_q09_b0    set 0.48544139 ; 3E22F1
iir2_H_BandStop_f04000_q09_b1    set -0.81743775 ; 975E33
iir2_H_BandStop_f04000_q09_b2    set 0.48544139 ; 3E22F1
iir2_H_BandStop_f04000_q09_a1    set 0.81743775 ; 68A1CD
iir2_H_BandStop_f04000_q09_a2    set -0.47088278 ; C3BA1D

; IIR2: mode=BandStop fc=5039.68 Q=9 h=< 0.48236052 -0.72653245 0.48236052 0.72653245 -0.46472105 >,< 3DBDFD A300FC 3DBDFD 5CFF04 C48406 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_BandStop_f05039_q09_b0    set 0.48236052 ; 3DBDFD
iir2_H_BandStop_f05039_q09_b1    set -0.72653245 ; A300FC
iir2_H_BandStop_f05039_q09_b2    set 0.48236052 ; 3DBDFD
iir2_H_BandStop_f05039_q09_a1    set 0.72653245 ; 5CFF04
iir2_H_BandStop_f05039_q09_a2    set -0.46472105 ; C48406

; IIR2: mode=BandStop fc=6349.6 Q=9 h=< 0.47906428 -0.59207436 0.47906428 0.59207436 -0.45812856 >,< 3D51FA B436E9 3D51FA 4BC917 C55C0B >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_BandStop_f06349_q09_b0    set 0.47906428 ; 3D51FA
iir2_H_BandStop_f06349_q09_b1    set -0.59207436 ; B436E9
iir2_H_BandStop_f06349_q09_b2    set 0.47906428 ; 3D51FA
iir2_H_BandStop_f06349_q09_a1    set 0.59207436 ; 4BC917
iir2_H_BandStop_f06349_q09_a2    set -0.45812856 ; C55C0B

; IIR2: mode=BandStop fc=8000 Q=9 h=< 0.47596332 -0.39768638 0.47596332 0.39768638 -0.45192663 >,< 3CEC5D CD189D 3CEC5D 32E763 C62745 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_BandStop_f08000_q09_b0    set 0.47596332 ; 3CEC5D
iir2_H_BandStop_f08000_q09_b1    set -0.39768638 ; CD189D
iir2_H_BandStop_f08000_q09_b2    set 0.47596332 ; 3CEC5D
iir2_H_BandStop_f08000_q09_a1    set 0.39768638 ; 32E763
iir2_H_BandStop_f08000_q09_a2    set -0.45192663 ; C62745

; IIR2: mode=BandStop fc=10079.4 Q=9 h=< 0.47389753 -0.12731014 0.47389753 0.12731014 -0.44779505 >,< 3CA8AC EFB44E 3CA8AC 104BB2 C6AEA7 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_BandStop_f10079_q09_b0    set 0.47389753 ; 3CA8AC
iir2_H_BandStop_f10079_q09_b1    set -0.12731014 ; EFB44E
iir2_H_BandStop_f10079_q09_b2    set 0.47389753 ; 3CA8AC
iir2_H_BandStop_f10079_q09_a1    set 0.12731014 ; 104BB2
iir2_H_BandStop_f10079_q09_a2    set -0.44779505 ; C6AEA7

; IIR2: mode=BandStop fc=12699.2 Q=9 h=< 0.47437867 0.22417111 0.47437867 -0.22417111 -0.44875734 >,< 3CB870 1CB1A3 3CB870 E34E5D C68F1F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_BandStop_f12699_q09_b0    set 0.47437867 ; 3CB870
iir2_H_BandStop_f12699_q09_b1    set 0.22417111 ; 1CB1A3
iir2_H_BandStop_f12699_q09_b2    set 0.47437867 ; 3CB870
iir2_H_BandStop_f12699_q09_a1    set -0.22417111 ; E34E5D
iir2_H_BandStop_f12699_q09_a2    set -0.44875734 ; C68F1F

; IIR2: mode=BandStop fc=16000 Q=9 h=< 0.47975634 0.62458180 0.47975634 -0.62458180 -0.45951268 >,< 3D68A8 4FF24C 3D68A8 B00DB4 C52EB1 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_BandStop_f16000_q09_b0    set 0.47975634 ; 3D68A8
iir2_H_BandStop_f16000_q09_b1    set 0.62458180 ; 4FF24C
iir2_H_BandStop_f16000_q09_b2    set 0.47975634 ; 3D68A8
iir2_H_BandStop_f16000_q09_a1    set -0.62458180 ; B00DB4
iir2_H_BandStop_f16000_q09_a2    set -0.45951268 ; C52EB1

; IIR2: mode=BandStop fc=20158.7 Q=9 h=< 0.49270934 0.94985982 0.49270934 -0.94985982 -0.48541869 >,< 3F1119 799501 3F1119 866AFF C1DDCD >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_BandStop_f20158_q09_b0    set 0.49270934 ; 3F1119
iir2_H_BandStop_f20158_q09_b1    set 0.94985982 ; 799501
iir2_H_BandStop_f20158_q09_b2    set 0.49270934 ; 3F1119
iir2_H_BandStop_f20158_q09_a1    set -0.94985982 ; 866AFF
iir2_H_BandStop_f20158_q09_a2    set -0.48541869 ; C1DDCD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Iir2_Equalizer.h ===
;**************************************************************************
;
;       IIR2_Equalizer.h    Coefficients for 2nd order Parametric (equalizer) filter
;       
;		Written by Gints Klimanis
;
;**************************************************************************        
    

; IIR2: mode=Parametric fc=62.5 Q=1 gainDB=6 h=< 0.50162936 -0.99668626 0.49509642 0.99668626 -0.49672578 >,< 403564 806C96 3F5F51 7F936A C06B4B >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q01_Gain06_b0    set 0.50162936       ; 403564
iir2_H_Parametric_f00062_q01_Gain06_b1    set -0.99668626       ; 806C96
iir2_H_Parametric_f00062_q01_Gain06_b2    set 0.49509642       ; 3F5F51
iir2_H_Parametric_f00062_q01_Gain06_a1    set 0.99668626       ; 7F936A
iir2_H_Parametric_f00062_q01_Gain06_a2    set -0.49672578       ; C06B4B

; IIR2: mode=Parametric fc=78.7451 Q=1 gainDB=6 h=< 0.50205110 -0.99581560 0.49382718 0.99581560 -0.49587828 >,< 404336 80891E 3F35BA 7F76E2 C08710 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q01_Gain06_b0    set 0.50205110       ; 404336
iir2_H_Parametric_f00078_q01_Gain06_b1    set -0.99581560       ; 80891E
iir2_H_Parametric_f00078_q01_Gain06_b2    set 0.49382718       ; 3F35BA
iir2_H_Parametric_f00078_q01_Gain06_a1    set 0.99581560       ; 7F76E2
iir2_H_Parametric_f00078_q01_Gain06_a2    set -0.49587828       ; C08710

; IIR2: mode=Parametric fc=99.2126 Q=1 gainDB=6 h=< 0.50258142 -0.99471319 0.49223115 0.99471319 -0.49481257 >,< 405496 80AD3D 3F016E 7F52C3 C0A9FC >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q01_Gain06_b0    set 0.50258142       ; 405496
iir2_H_Parametric_f00099_q01_Gain06_b1    set -0.99471319       ; 80AD3D
iir2_H_Parametric_f00099_q01_Gain06_b2    set 0.49223115       ; 3F016E
iir2_H_Parametric_f00099_q01_Gain06_a1    set 0.99471319       ; 7F52C3
iir2_H_Parametric_f00099_q01_Gain06_a2    set -0.49481257       ; C0A9FC

; IIR2: mode=Parametric fc=125 Q=1 gainDB=6 h=< 0.50324795 -0.99331563 0.49022523 0.99331563 -0.49347318 >,< 406A6E 80DB09 3EBFB3 7F24F7 C0D5DF >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q01_Gain06_b0    set 0.50324795       ; 406A6E
iir2_H_Parametric_f00125_q01_Gain06_b1    set -0.99331563       ; 80DB09
iir2_H_Parametric_f00125_q01_Gain06_b2    set 0.49022523       ; 3EBFB3
iir2_H_Parametric_f00125_q01_Gain06_a1    set 0.99331563       ; 7F24F7
iir2_H_Parametric_f00125_q01_Gain06_a2    set -0.49347318       ; C0D5DF

; IIR2: mode=Parametric fc=157.49 Q=1 gainDB=6 h=< 0.50408510 -0.99154123 0.48770580 0.99154123 -0.49179090 >,< 4085DC 81152E 3E6D24 7EEAD2 C10CFF >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q01_Gain06_b0    set 0.50408510       ; 4085DC
iir2_H_Parametric_f00157_q01_Gain06_b1    set -0.99154123       ; 81152E
iir2_H_Parametric_f00157_q01_Gain06_b2    set 0.48770580       ; 3E6D24
iir2_H_Parametric_f00157_q01_Gain06_a1    set 0.99154123       ; 7EEAD2
iir2_H_Parametric_f00157_q01_Gain06_a2    set -0.49179090       ; C10CFF

; IIR2: mode=Parametric fc=198.425 Q=1 gainDB=6 h=< 0.50513570 -0.98928424 0.48454401 0.98928424 -0.48967971 >,< 40A849 815F23 3E0589 7EA0DD C1522D >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q01_Gain06_b0    set 0.50513570       ; 40A849
iir2_H_Parametric_f00198_q01_Gain06_b1    set -0.98928424       ; 815F23
iir2_H_Parametric_f00198_q01_Gain06_b2    set 0.48454401       ; 3E0589
iir2_H_Parametric_f00198_q01_Gain06_a1    set 0.98928424       ; 7EA0DD
iir2_H_Parametric_f00198_q01_Gain06_a2    set -0.48967971       ; C1522D

; IIR2: mode=Parametric fc=250 Q=1 gainDB=6 h=< 0.50645277 -0.98640697 0.48058027 0.98640697 -0.48703304 >,< 40D371 81BD6B 3D83A7 7E4295 C1A8E7 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q01_Gain06_b0    set 0.50645277       ; 40D371
iir2_H_Parametric_f00250_q01_Gain06_b1    set -0.98640697       ; 81BD6B
iir2_H_Parametric_f00250_q01_Gain06_b2    set 0.48058027       ; 3D83A7
iir2_H_Parametric_f00250_q01_Gain06_a1    set 0.98640697       ; 7E4295
iir2_H_Parametric_f00250_q01_Gain06_a2    set -0.48703304       ; C1A8E7

; IIR2: mode=Parametric fc=314.98 Q=1 gainDB=6 h=< 0.50810168 -0.98272910 0.47561784 0.98272910 -0.48371952 >,< 41097A 8235EF 3CE10B 7DCA11 C2157B >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q01_Gain06_b0    set 0.50810168       ; 41097A
iir2_H_Parametric_f00314_q01_Gain06_b1    set -0.98272910       ; 8235EF
iir2_H_Parametric_f00314_q01_Gain06_b2    set 0.47561784       ; 3CE10B
iir2_H_Parametric_f00314_q01_Gain06_a1    set 0.98272910       ; 7DCA11
iir2_H_Parametric_f00314_q01_Gain06_a2    set -0.48371952       ; C2157B

; IIR2: mode=Parametric fc=396.85 Q=1 gainDB=6 h=< 0.51016250 -0.97801284 0.46941576 0.97801284 -0.47957826 >,< 414D01 82D07A 3C15D0 7D2F86 C29D2E >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q01_Gain06_b0    set 0.51016250       ; 414D01
iir2_H_Parametric_f00396_q01_Gain06_b1    set -0.97801284       ; 82D07A
iir2_H_Parametric_f00396_q01_Gain06_b2    set 0.46941576       ; 3C15D0
iir2_H_Parametric_f00396_q01_Gain06_a1    set 0.97801284       ; 7D2F86
iir2_H_Parametric_f00396_q01_Gain06_a2    set -0.47957826       ; C29D2E

; IIR2: mode=Parametric fc=500 Q=1 gainDB=6 h=< 0.51273245 -0.97194242 0.46168142 0.97194242 -0.47441388 >,< 41A137 839764 3B1860 7C689C C34668 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q01_Gain06_b0    set 0.51273245       ; 41A137
iir2_H_Parametric_f00500_q01_Gain06_b1    set -0.97194242       ; 839764
iir2_H_Parametric_f00500_q01_Gain06_b2    set 0.46168142       ; 3B1860
iir2_H_Parametric_f00500_q01_Gain06_a1    set 0.97194242       ; 7C689C
iir2_H_Parametric_f00500_q01_Gain06_a2    set -0.47441388       ; C34668

; IIR2: mode=Parametric fc=629.961 Q=1 gainDB=6 h=< 0.51592824 -0.96409551 0.45206363 0.96409551 -0.46799188 >,< 4209F0 849885 39DD38 7B677B C418D8 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q01_Gain06_b0    set 0.51592824       ; 4209F0
iir2_H_Parametric_f00629_q01_Gain06_b1    set -0.96409551       ; 849885
iir2_H_Parametric_f00629_q01_Gain06_b2    set 0.45206363       ; 39DD38
iir2_H_Parametric_f00629_q01_Gain06_a1    set 0.96409551       ; 7B677B
iir2_H_Parametric_f00629_q01_Gain06_a2    set -0.46799188       ; C418D8

; IIR2: mode=Parametric fc=793.701 Q=1 gainDB=6 h=< 0.51988767 -0.95390349 0.44014765 0.95390349 -0.46003532 >,< 428BAE 85E67E 3856C2 7A1982 C51D90 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q01_Gain06_b0    set 0.51988767       ; 428BAE
iir2_H_Parametric_f00793_q01_Gain06_b1    set -0.95390349       ; 85E67E
iir2_H_Parametric_f00793_q01_Gain06_b2    set 0.44014765       ; 3856C2
iir2_H_Parametric_f00793_q01_Gain06_a1    set 0.95390349       ; 7A1982
iir2_H_Parametric_f00793_q01_Gain06_a2    set -0.46003532       ; C51D90

; IIR2: mode=Parametric fc=1000 Q=1 gainDB=6 h=< 0.52476977 -0.94059646 0.42545487 0.94059646 -0.45022464 >,< 432BA8 879A89 36754E 786577 C65F0A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q01_Gain06_b0    set 0.52476977       ; 432BA8
iir2_H_Parametric_f01000_q01_Gain06_b1    set -0.94059646       ; 879A89
iir2_H_Parametric_f01000_q01_Gain06_b2    set 0.42545487       ; 36754E
iir2_H_Parametric_f01000_q01_Gain06_a1    set 0.94059646       ; 786577
iir2_H_Parametric_f01000_q01_Gain06_a2    set -0.45022464       ; C65F0A

; IIR2: mode=Parametric fc=1259.92 Q=1 gainDB=6 h=< 0.53075187 -0.92312806 0.40745163 0.92312806 -0.43820350 >,< 43EFAD 89D6F1 342760 76290F C7E8F3 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q01_Gain06_b0    set 0.53075187       ; 43EFAD
iir2_H_Parametric_f01259_q01_Gain06_b1    set -0.92312806       ; 89D6F1
iir2_H_Parametric_f01259_q01_Gain06_b2    set 0.40745163       ; 342760
iir2_H_Parametric_f01259_q01_Gain06_a1    set 0.92312806       ; 76290F
iir2_H_Parametric_f01259_q01_Gain06_a2    set -0.43820350       ; C7E8F3

; IIR2: mode=Parametric fc=1587.4 Q=1 gainDB=6 h=< 0.53802119 -0.90007463 0.38557444 0.90007463 -0.42359563 >,< 44DDE1 8CCA5B 315A80 7335A5 C9C79F >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q01_Gain06_b0    set 0.53802119       ; 44DDE1
iir2_H_Parametric_f01587_q01_Gain06_b1    set -0.90007463       ; 8CCA5B
iir2_H_Parametric_f01587_q01_Gain06_b2    set 0.38557444       ; 315A80
iir2_H_Parametric_f01587_q01_Gain06_a1    set 0.90007463       ; 7335A5
iir2_H_Parametric_f01587_q01_Gain06_a2    set -0.42359563       ; C9C79F

; IIR2: mode=Parametric fc=2000 Q=1 gainDB=6 h=< 0.54675738 -0.86950423 0.35928271 0.86950423 -0.40604009 >,< 45FC25 90B416 2DFCF9 6F4BEA CC06E1 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q01_Gain06_b0    set 0.54675738       ; 45FC25
iir2_H_Parametric_f02000_q01_Gain06_b1    set -0.86950423       ; 90B416
iir2_H_Parametric_f02000_q01_Gain06_b2    set 0.35928271       ; 2DFCF9
iir2_H_Parametric_f02000_q01_Gain06_a1    set 0.86950423       ; 6F4BEA
iir2_H_Parametric_f02000_q01_Gain06_a2    set -0.40604009       ; CC06E1

; IIR2: mode=Parametric fc=2519.84 Q=1 gainDB=6 h=< 0.55710027 -0.82881439 0.32815558 0.82881439 -0.38525585 >,< 474F10 95E969 2A0100 6A1697 CEAFF0 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q01_Gain06_b0    set 0.55710027       ; 474F10
iir2_H_Parametric_f02519_q01_Gain06_b1    set -0.82881439       ; 95E969
iir2_H_Parametric_f02519_q01_Gain06_b2    set 0.32815558       ; 2A0100
iir2_H_Parametric_f02519_q01_Gain06_a1    set 0.82881439       ; 6A1697
iir2_H_Parametric_f02519_q01_Gain06_a2    set -0.38525585       ; CEAFF0

; IIR2: mode=Parametric fc=3174.8 Q=1 gainDB=6 h=< 0.56909552 -0.77454519 0.29205561 0.77454519 -0.36115113 >,< 48D81F 9CDBB4 256214 63244C D1C5CD >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q01_Gain06_b0    set 0.56909552       ; 48D81F
iir2_H_Parametric_f03174_q01_Gain06_b1    set -0.77454519       ; 9CDBB4
iir2_H_Parametric_f03174_q01_Gain06_b2    set 0.29205561       ; 256214
iir2_H_Parametric_f03174_q01_Gain06_a1    set 0.77454519       ; 63244C
iir2_H_Parametric_f03174_q01_Gain06_a2    set -0.36115113       ; D1C5CD

; IIR2: mode=Parametric fc=4000 Q=1 gainDB=6 h=< 0.58260795 -0.70218688 0.25138969 0.70218688 -0.33399764 >,< 4A92E5 A61EBE 202D89 59E142 D53F91 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q01_Gain06_b0    set 0.58260795       ; 4A92E5
iir2_H_Parametric_f04000_q01_Gain06_b1    set -0.70218688       ; A61EBE
iir2_H_Parametric_f04000_q01_Gain06_b2    set 0.25138969       ; 202D89
iir2_H_Parametric_f04000_q01_Gain06_a1    set 0.70218688       ; 59E142
iir2_H_Parametric_f04000_q01_Gain06_a2    set -0.33399764       ; D53F91

; IIR2: mode=Parametric fc=5039.68 Q=1 gainDB=6 h=< 0.59718953 -0.60601716 0.20750613 0.60601716 -0.30469566 >,< 4C70B5 B26E08 1A8F8F 4D91F8 D8FFBC >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q01_Gain06_b0    set 0.59718953       ; 4C70B5
iir2_H_Parametric_f05039_q01_Gain06_b1    set -0.60601716       ; B26E08
iir2_H_Parametric_f05039_q01_Gain06_b2    set 0.20750613       ; 1A8F8F
iir2_H_Parametric_f05039_q01_Gain06_a1    set 0.60601716       ; 4D91F8
iir2_H_Parametric_f05039_q01_Gain06_a2    set -0.30469566       ; D8FFBC

; IIR2: mode=Parametric fc=6349.6 Q=1 gainDB=6 h=< 0.61188302 -0.47901458 0.16328576 0.47901458 -0.27516878 >,< 4E522F C2AFA7 14E68C 3D5059 DCC745 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q01_Gain06_b0    set 0.61188302       ; 4E522F
iir2_H_Parametric_f06349_q01_Gain06_b1    set -0.47901458       ; C2AFA7
iir2_H_Parametric_f06349_q01_Gain06_b2    set 0.16328576       ; 14E68C
iir2_H_Parametric_f06349_q01_Gain06_a1    set 0.47901458       ; 3D5059
iir2_H_Parametric_f06349_q01_Gain06_a2    set -0.27516878       ; DCC745

; IIR2: mode=Parametric fc=8000 Q=1 gainDB=6 h=< 0.62492167 -0.31289608 0.12404567 0.31289608 -0.24896734 >,< 4FFD6F D7F306 0FE0BA 280CFA E021D7 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q01_Gain06_b0    set 0.62492167       ; 4FFD6F
iir2_H_Parametric_f08000_q01_Gain06_b1    set -0.31289608       ; D7F306
iir2_H_Parametric_f08000_q01_Gain06_b2    set 0.12404567       ; 0FE0BA
iir2_H_Parametric_f08000_q01_Gain06_a1    set 0.31289608       ; 280CFA
iir2_H_Parametric_f08000_q01_Gain06_a2    set -0.24896734       ; E021D7

; IIR2: mode=Parametric fc=10079.4 Q=1 gainDB=6 h=< 0.63321680 -0.09836407 0.09908132 0.09836407 -0.23229812 >,< 510D3F F368CF 0CAEB2 0C9731 E2440F >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q01_Gain06_b0    set 0.63321680       ; 510D3F
iir2_H_Parametric_f10079_q01_Gain06_b1    set -0.09836407       ; F368CF
iir2_H_Parametric_f10079_q01_Gain06_b2    set 0.09908132       ; 0CAEB2
iir2_H_Parametric_f10079_q01_Gain06_a1    set 0.09836407       ; 0C9731
iir2_H_Parametric_f10079_q01_Gain06_a2    set -0.23229812       ; E2440F

; IIR2: mode=Parametric fc=12699.2 Q=1 gainDB=6 h=< 0.63131156 0.17393104 0.10481517 -0.17393104 -0.23612673 >,< 50CED1 16435F 0D6A95 E9BCA1 E1C69A >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q01_Gain06_b0    set 0.63131156       ; 50CED1
iir2_H_Parametric_f12699_q01_Gain06_b1    set 0.17393104       ; 16435F
iir2_H_Parametric_f12699_q01_Gain06_b2    set 0.10481517       ; 0D6A95
iir2_H_Parametric_f12699_q01_Gain06_a1    set -0.17393104       ; E9BCA1
iir2_H_Parametric_f12699_q01_Gain06_a2    set -0.23612673       ; E1C69A

; IIR2: mode=Parametric fc=16000 Q=1 gainDB=6 h=< 0.60887181 0.50852451 0.17234807 -0.50852451 -0.28121988 >,< 4DEF83 411755 160F80 BEE8AB DC00FD >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q01_Gain06_b0    set 0.60887181       ; 4DEF83
iir2_H_Parametric_f16000_q01_Gain06_b1    set 0.50852451       ; 411755
iir2_H_Parametric_f16000_q01_Gain06_b2    set 0.17234807       ; 160F80
iir2_H_Parametric_f16000_q01_Gain06_a1    set -0.50852451       ; BEE8AB
iir2_H_Parametric_f16000_q01_Gain06_a2    set -0.28121988       ; DC00FD

; IIR2: mode=Parametric fc=20158.7 Q=1 gainDB=6 h=< 0.54450056 0.87771708 0.36607466 -0.87771708 -0.41057522 >,< 45B231 705908 2EDB88 8FA6F8 CB7246 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q01_Gain06_b0    set 0.54450056       ; 45B231
iir2_H_Parametric_f20158_q01_Gain06_b1    set 0.87771708       ; 705908
iir2_H_Parametric_f20158_q01_Gain06_b2    set 0.36607466       ; 2EDB88
iir2_H_Parametric_f20158_q01_Gain06_a1    set -0.87771708       ; 8FA6F8
iir2_H_Parametric_f20158_q01_Gain06_a2    set -0.41057522       ; CB7246

; IIR2: mode=Parametric fc=62.5 Q=6 gainDB=6 h=< 0.50026159 -0.99943471 0.49921275 0.99943471 -0.49947434 >,< 400892 801286 3FE634 7FED7A C0113A >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q06_Gain06_b0    set 0.50026159       ; 400892
iir2_H_Parametric_f00062_q06_Gain06_b1    set -0.99943471       ; 801286
iir2_H_Parametric_f00062_q06_Gain06_b2    set 0.49921275       ; 3FE634
iir2_H_Parametric_f00062_q06_Gain06_a1    set 0.99943471       ; 7FED7A
iir2_H_Parametric_f00062_q06_Gain06_a2    set -0.49947434       ; C0113A

; IIR2: mode=Parametric fc=78.7451 Q=6 gainDB=6 h=< 0.50032953 -0.99927491 0.49900827 0.99927491 -0.49933780 >,< 400ACC 8017C3 3FDF80 7FE83D C015B3 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q06_Gain06_b0    set 0.50032953       ; 400ACC
iir2_H_Parametric_f00078_q06_Gain06_b1    set -0.99927491       ; 8017C3
iir2_H_Parametric_f00078_q06_Gain06_b2    set 0.49900827       ; 3FDF80
iir2_H_Parametric_f00078_q06_Gain06_a1    set 0.99927491       ; 7FE83D
iir2_H_Parametric_f00078_q06_Gain06_a2    set -0.49933780       ; C015B3

; IIR2: mode=Parametric fc=99.2126 Q=6 gainDB=6 h=< 0.50041511 -0.99906601 0.49875073 0.99906601 -0.49916583 >,< 400D9A 801E9B 3FD710 7FE165 C01B56 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q06_Gain06_b0    set 0.50041511       ; 400D9A
iir2_H_Parametric_f00099_q06_Gain06_b1    set -0.99906601       ; 801E9B
iir2_H_Parametric_f00099_q06_Gain06_b2    set 0.49875073       ; 3FD710
iir2_H_Parametric_f00099_q06_Gain06_a1    set 0.99906601       ; 7FE165
iir2_H_Parametric_f00099_q06_Gain06_a2    set -0.49916583       ; C01B56

; IIR2: mode=Parametric fc=125 Q=6 gainDB=6 h=< 0.50052288 -0.99879085 0.49842639 0.99879085 -0.49894927 >,< 401122 80279F 3FCC6F 7FD861 C0226F >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q06_Gain06_b0    set 0.50052288       ; 401122
iir2_H_Parametric_f00125_q06_Gain06_b1    set -0.99879085       ; 80279F
iir2_H_Parametric_f00125_q06_Gain06_b2    set 0.49842639       ; 3FCC6F
iir2_H_Parametric_f00125_q06_Gain06_a1    set 0.99879085       ; 7FD861
iir2_H_Parametric_f00125_q06_Gain06_a2    set -0.49894927       ; C0226F

; IIR2: mode=Parametric fc=157.49 Q=6 gainDB=6 h=< 0.50065859 -0.99842516 0.49801797 0.99842516 -0.49867656 >,< 401594 80339B 3FBF0D 7FCC65 C02B5E >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q06_Gain06_b0    set 0.50065859       ; 401594
iir2_H_Parametric_f00157_q06_Gain06_b1    set -0.99842516       ; 80339B
iir2_H_Parametric_f00157_q06_Gain06_b2    set 0.49801797       ; 3FBF0D
iir2_H_Parametric_f00157_q06_Gain06_a1    set 0.99842516       ; 7FCC65
iir2_H_Parametric_f00157_q06_Gain06_a2    set -0.49867656       ; C02B5E

; IIR2: mode=Parametric fc=198.425 Q=6 gainDB=6 h=< 0.50082944 -0.99793430 0.49750379 0.99793430 -0.49833323 >,< 401B2E 8043B1 3FAE34 7FBC4F C0369E >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q06_Gain06_b0    set 0.50082944       ; 401B2E
iir2_H_Parametric_f00198_q06_Gain06_b1    set -0.99793430       ; 8043B1
iir2_H_Parametric_f00198_q06_Gain06_b2    set 0.49750379       ; 3FAE34
iir2_H_Parametric_f00198_q06_Gain06_a1    set 0.99793430       ; 7FBC4F
iir2_H_Parametric_f00198_q06_Gain06_a2    set -0.49833323       ; C0369E

; IIR2: mode=Parametric fc=250 Q=6 gainDB=6 h=< 0.50104449 -0.99726811 0.49685658 0.99726811 -0.49790107 >,< 40223A 805985 3F98FF 7FA67B C044C7 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q06_Gain06_b0    set 0.50104449       ; 40223A
iir2_H_Parametric_f00250_q06_Gain06_b1    set -0.99726811       ; 805985
iir2_H_Parametric_f00250_q06_Gain06_b2    set 0.49685658       ; 3F98FF
iir2_H_Parametric_f00250_q06_Gain06_a1    set 0.99726811       ; 7FA67B
iir2_H_Parametric_f00250_q06_Gain06_a2    set -0.49790107       ; C044C7

; IIR2: mode=Parametric fc=314.98 Q=6 gainDB=6 h=< 0.50131510 -0.99635313 0.49604218 0.99635313 -0.49735728 >,< 402B18 807780 3F7E4F 7F8880 C05699 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q06_Gain06_b0    set 0.50131510       ; 402B18
iir2_H_Parametric_f00314_q06_Gain06_b1    set -0.99635313       ; 807780
iir2_H_Parametric_f00314_q06_Gain06_b2    set 0.49604218       ; 3F7E4F
iir2_H_Parametric_f00314_q06_Gain06_a1    set 0.99635313       ; 7F8880
iir2_H_Parametric_f00314_q06_Gain06_a2    set -0.49735728       ; C05699

; IIR2: mode=Parametric fc=396.85 Q=6 gainDB=6 h=< 0.50165546 -0.99508059 0.49501786 0.99508059 -0.49667332 >,< 40363F 80A133 3F5CBE 7F5ECD C06D03 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q06_Gain06_b0    set 0.50165546       ; 40363F
iir2_H_Parametric_f00396_q06_Gain06_b1    set -0.99508059       ; 80A133
iir2_H_Parametric_f00396_q06_Gain06_b2    set 0.49501786       ; 3F5CBE
iir2_H_Parametric_f00396_q06_Gain06_a1    set 0.99508059       ; 7F5ECD
iir2_H_Parametric_f00396_q06_Gain06_a2    set -0.49667332       ; C06D03

; IIR2: mode=Parametric fc=500 Q=6 gainDB=6 h=< 0.50208330 -0.99328785 0.49373028 0.99328785 -0.49581358 >,< 404444 80DBF2 3F328D 7F240E C0892F >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q06_Gain06_b0    set 0.50208330       ; 404444
iir2_H_Parametric_f00500_q06_Gain06_b1    set -0.99328785       ; 80DBF2
iir2_H_Parametric_f00500_q06_Gain06_b2    set 0.49373028       ; 3F328D
iir2_H_Parametric_f00500_q06_Gain06_a1    set 0.99328785       ; 7F240E
iir2_H_Parametric_f00500_q06_Gain06_a2    set -0.49581358       ; C0892F

; IIR2: mode=Parametric fc=629.961 Q=6 gainDB=6 h=< 0.50262064 -0.99072977 0.49211314 0.99072977 -0.49473377 >,< 4055DF 812FC5 3EFD90 7ED03B C0AC91 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q06_Gain06_b0    set 0.50262064       ; 4055DF
iir2_H_Parametric_f00629_q06_Gain06_b1    set -0.99072977       ; 812FC5
iir2_H_Parametric_f00629_q06_Gain06_b2    set 0.49211314       ; 3EFD90
iir2_H_Parametric_f00629_q06_Gain06_a1    set 0.99072977       ; 7ED03B
iir2_H_Parametric_f00629_q06_Gain06_a2    set -0.49473377       ; C0AC91

; IIR2: mode=Parametric fc=793.701 Q=6 gainDB=6 h=< 0.50329470 -0.98703443 0.49008453 0.98703443 -0.49337923 >,< 406BF6 81A8DB 3EBB17 7E5725 C0D8F3 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q06_Gain06_b0    set 0.50329470       ; 406BF6
iir2_H_Parametric_f00793_q06_Gain06_b1    set -0.98703443       ; 81A8DB
iir2_H_Parametric_f00793_q06_Gain06_b2    set 0.49008453       ; 3EBB17
iir2_H_Parametric_f00793_q06_Gain06_a1    set 0.98703443       ; 7E5725
iir2_H_Parametric_f00793_q06_Gain06_a2    set -0.49337923       ; C0D8F3

; IIR2: mode=Parametric fc=1000 Q=6 gainDB=6 h=< 0.50413878 -0.98163477 0.48754425 0.98163477 -0.49168303 >,< 40879E 8259CB 3E67D9 7DA635 C11088 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q06_Gain06_b0    set 0.50413878       ; 40879E
iir2_H_Parametric_f01000_q06_Gain06_b1    set -0.98163477       ; 8259CB
iir2_H_Parametric_f01000_q06_Gain06_b2    set 0.48754425       ; 3E67D9
iir2_H_Parametric_f01000_q06_Gain06_a1    set 0.98163477       ; 7DA635
iir2_H_Parametric_f01000_q06_Gain06_a2    set -0.49168303       ; C11088

; IIR2: mode=Parametric fc=1259.92 Q=6 gainDB=6 h=< 0.50519305 -0.97366374 0.48437140 0.97366374 -0.48956446 >,< 40AA2A 835EFD 3DFFE1 7CA103 C155F4 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q06_Gain06_b0    set 0.50519305       ; 40AA2A
iir2_H_Parametric_f01259_q06_Gain06_b1    set -0.97366374       ; 835EFD
iir2_H_Parametric_f01259_q06_Gain06_b2    set 0.48437140       ; 3DFFE1
iir2_H_Parametric_f01259_q06_Gain06_a1    set 0.97366374       ; 7CA103
iir2_H_Parametric_f01259_q06_Gain06_a2    set -0.48956446       ; C155F4

; IIR2: mode=Parametric fc=1587.4 Q=6 gainDB=6 h=< 0.50650480 -0.96179460 0.48042368 0.96179460 -0.48692848 >,< 40D526 84E3EA 3D7E86 7B1C16 C1AC54 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q06_Gain06_b0    set 0.50650480       ; 40D526
iir2_H_Parametric_f01587_q06_Gain06_b1    set -0.96179460       ; 84E3EA
iir2_H_Parametric_f01587_q06_Gain06_b2    set 0.48042368       ; 3D7E86
iir2_H_Parametric_f01587_q06_Gain06_a1    set 0.96179460       ; 7B1C16
iir2_H_Parametric_f01587_q06_Gain06_a2    set -0.48692848       ; C1AC54

; IIR2: mode=Parametric fc=2000 Q=6 gainDB=6 h=< 0.50812747 -0.94400151 0.47554022 0.94400151 -0.48366769 >,< 410A52 872AF6 3CDE80 78D50A C2172E >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q06_Gain06_b0    set 0.50812747       ; 410A52
iir2_H_Parametric_f02000_q06_Gain06_b1    set -0.94400151       ; 872AF6
iir2_H_Parametric_f02000_q06_Gain06_b2    set 0.47554022       ; 3CDE80
iir2_H_Parametric_f02000_q06_Gain06_a1    set 0.94400151       ; 78D50A
iir2_H_Parametric_f02000_q06_Gain06_a2    set -0.48366769       ; C2172E

; IIR2: mode=Parametric fc=2519.84 Q=6 gainDB=6 h=< 0.51011703 -0.91720860 0.46955259 0.91720860 -0.47966962 >,< 414B84 8A98E9 3C1A4C 756717 C29A30 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q06_Gain06_b0    set 0.51011703       ; 414B84
iir2_H_Parametric_f02519_q06_Gain06_b1    set -0.91720860       ; 8A98E9
iir2_H_Parametric_f02519_q06_Gain06_b2    set 0.46955259       ; 3C1A4C
iir2_H_Parametric_f02519_q06_Gain06_a1    set 0.91720860       ; 756717
iir2_H_Parametric_f02519_q06_Gain06_a2    set -0.47966962       ; C29A30

; IIR2: mode=Parametric fc=3174.8 Q=6 gainDB=6 h=< 0.51252292 -0.87679581 0.46231200 0.87679581 -0.47483493 >,< 419A5A 8FC528 3B2D0A 703AD8 C3389C >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q06_Gain06_b0    set 0.51252292       ; 419A5A
iir2_H_Parametric_f03174_q06_Gain06_b1    set -0.87679581       ; 8FC528
iir2_H_Parametric_f03174_q06_Gain06_b2    set 0.46231200       ; 3B2D0A
iir2_H_Parametric_f03174_q06_Gain06_a1    set 0.87679581       ; 703AD8
iir2_H_Parametric_f03174_q06_Gain06_a2    set -0.47483493       ; C3389C

; IIR2: mode=Parametric fc=4000 Q=6 gainDB=6 h=< 0.51536870 -0.81595045 0.45374759 0.81595045 -0.46911629 >,< 41F79A 978EF0 3A1466 687110 C3F400 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q06_Gain06_b0    set 0.51536870       ; 41F79A
iir2_H_Parametric_f04000_q06_Gain06_b1    set -0.81595045       ; 978EF0
iir2_H_Parametric_f04000_q06_Gain06_b2    set 0.45374759       ; 3A1466
iir2_H_Parametric_f04000_q06_Gain06_a1    set 0.81595045       ; 687110
iir2_H_Parametric_f04000_q06_Gain06_a2    set -0.46911629       ; C3F400

; IIR2: mode=Parametric fc=5039.68 Q=6 gainDB=6 h=< 0.51861382 -0.72493143 0.44398132 0.72493143 -0.46259514 >,< 4261F0 A33573 38D461 5CCA8D C4C9AF >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q06_Gain06_b0    set 0.51861382       ; 4261F0
iir2_H_Parametric_f05039_q06_Gain06_b1    set -0.72493143       ; A33573
iir2_H_Parametric_f05039_q06_Gain06_b2    set 0.44398132       ; 38D461
iir2_H_Parametric_f05039_q06_Gain06_a1    set 0.72493143       ; 5CCA8D
iir2_H_Parametric_f05039_q06_Gain06_a2    set -0.46259514       ; C4C9AF

; IIR2: mode=Parametric fc=6349.6 Q=6 gainDB=6 h=< 0.52208304 -0.59052646 0.43354063 0.59052646 -0.45562367 >,< 42D39E B469A1 377E42 4B965F C5AE20 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q06_Gain06_b0    set 0.52208304       ; 42D39E
iir2_H_Parametric_f06349_q06_Gain06_b1    set -0.59052646       ; B469A1
iir2_H_Parametric_f06349_q06_Gain06_b2    set 0.43354063       ; 377E42
iir2_H_Parametric_f06349_q06_Gain06_a1    set 0.59052646       ; 4B965F
iir2_H_Parametric_f06349_q06_Gain06_a2    set -0.45562367       ; C5AE20

; IIR2: mode=Parametric fc=8000 Q=6 gainDB=6 h=< 0.52534414 -0.39649315 0.42372630 0.39649315 -0.44907044 >,< 433E7A CD3FB7 363CA9 32C049 C684DC >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q06_Gain06_b0    set 0.52534414       ; 433E7A
iir2_H_Parametric_f08000_q06_Gain06_b1    set -0.39649315       ; CD3FB7
iir2_H_Parametric_f08000_q06_Gain06_b2    set 0.42372630       ; 363CA9
iir2_H_Parametric_f08000_q06_Gain06_a1    set 0.39649315       ; 32C049
iir2_H_Parametric_f08000_q06_Gain06_a2    set -0.44907044       ; C684DC

; IIR2: mode=Parametric fc=10079.4 Q=6 gainDB=6 h=< 0.52751520 -0.12689544 0.41719245 0.12689544 -0.44470765 >,< 43859E EFC1E4 356690 103E1C C713D2 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q06_Gain06_b0    set 0.52751520       ; 43859E
iir2_H_Parametric_f10079_q06_Gain06_b1    set -0.12689544       ; EFC1E4
iir2_H_Parametric_f10079_q06_Gain06_b2    set 0.41719245       ; 356690
iir2_H_Parametric_f10079_q06_Gain06_a1    set 0.12689544       ; 103E1C
iir2_H_Parametric_f10079_q06_Gain06_a2    set -0.44470765       ; C713D2

; IIR2: mode=Parametric fc=12699.2 Q=6 gainDB=6 h=< 0.52700964 0.22345430 0.41871395 -0.22345430 -0.44572358 >,< 43750D 1C9A26 35986B E365DA C6F288 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q06_Gain06_b0    set 0.52700964       ; 43750D
iir2_H_Parametric_f12699_q06_Gain06_b1    set 0.22345430       ; 1C9A26
iir2_H_Parametric_f12699_q06_Gain06_b2    set 0.41871395       ; 35986B
iir2_H_Parametric_f12699_q06_Gain06_a1    set -0.22345430       ; E365DA
iir2_H_Parametric_f12699_q06_Gain06_a2    set -0.44572358       ; C6F288

; IIR2: mode=Parametric fc=16000 Q=6 gainDB=6 h=< 0.52135490 0.62300276 0.43573198 -0.62300276 -0.45708688 >,< 42BBC2 4FBE8E 37C610 B04172 C57E2E >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q06_Gain06_b0    set 0.52135490       ; 42BBC2
iir2_H_Parametric_f16000_q06_Gain06_b1    set 0.62300276       ; 4FBE8E
iir2_H_Parametric_f16000_q06_Gain06_b2    set 0.43573198       ; 37C610
iir2_H_Parametric_f16000_q06_Gain06_a1    set -0.62300276       ; B04172
iir2_H_Parametric_f16000_q06_Gain06_a2    set -0.45708688       ; C57E2E

; IIR2: mode=Parametric fc=20158.7 Q=6 gainDB=6 h=< 0.50770333 0.94899357 0.47681668 -0.94899357 -0.48452001 >,< 40FC6C 79789F 3D0854 868761 C1FB40 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q06_Gain06_b0    set 0.50770333       ; 40FC6C
iir2_H_Parametric_f20158_q06_Gain06_b1    set 0.94899357       ; 79789F
iir2_H_Parametric_f20158_q06_Gain06_b2    set 0.47681668       ; 3D0854
iir2_H_Parametric_f20158_q06_Gain06_a1    set -0.94899357       ; 868761
iir2_H_Parametric_f20158_q06_Gain06_a2    set -0.48452001       ; C1FB40

; IIR2: mode=Parametric fc=62.5 Q=15 gainDB=6 h=< 0.50010457 -0.99975023 0.49968531 0.99975023 -0.49978987 >,< 40036D 80082F 3FF5B0 7FF7D1 C006E3 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q15_Gain06_b0    set 0.50010457       ; 40036D
iir2_H_Parametric_f00062_q15_Gain06_b1    set -0.99975023       ; 80082F
iir2_H_Parametric_f00062_q15_Gain06_b2    set 0.49968531       ; 3FF5B0
iir2_H_Parametric_f00062_q15_Gain06_a1    set 0.99975023       ; 7FF7D1
iir2_H_Parametric_f00062_q15_Gain06_a2    set -0.49978987       ; C006E3

; IIR2: mode=Parametric fc=78.7451 Q=15 gainDB=6 h=< 0.50013174 -0.99967235 0.49960354 0.99967235 -0.49973527 >,< 400451 800ABD 3FF302 7FF543 C008AD >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q15_Gain06_b0    set 0.50013174       ; 400451
iir2_H_Parametric_f00078_q15_Gain06_b1    set -0.99967235       ; 800ABD
iir2_H_Parametric_f00078_q15_Gain06_b2    set 0.49960354       ; 3FF302
iir2_H_Parametric_f00078_q15_Gain06_a1    set 0.99967235       ; 7FF543
iir2_H_Parametric_f00078_q15_Gain06_a2    set -0.49973527       ; C008AD

; IIR2: mode=Parametric fc=99.2126 Q=15 gainDB=6 h=< 0.50016596 -0.99956662 0.49950053 0.99956662 -0.49966649 >,< 400570 800E34 3FEFA2 7FF1CC C00AEE >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q15_Gain06_b0    set 0.50016596       ; 400570
iir2_H_Parametric_f00099_q15_Gain06_b1    set -0.99956662       ; 800E34
iir2_H_Parametric_f00099_q15_Gain06_b2    set 0.49950053       ; 3FEFA2
iir2_H_Parametric_f00099_q15_Gain06_a1    set 0.99956662       ; 7FF1CC
iir2_H_Parametric_f00099_q15_Gain06_a2    set -0.49966649       ; C00AEE

; IIR2: mode=Parametric fc=125 Q=15 gainDB=6 h=< 0.50020908 -0.99942133 0.49937077 0.99942133 -0.49957985 >,< 4006DA 8012F6 3FEB61 7FED0A C00DC5 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q15_Gain06_b0    set 0.50020908       ; 4006DA
iir2_H_Parametric_f00125_q15_Gain06_b1    set -0.99942133       ; 8012F6
iir2_H_Parametric_f00125_q15_Gain06_b2    set 0.49937077       ; 3FEB61
iir2_H_Parametric_f00125_q15_Gain06_a1    set 0.99942133       ; 7FED0A
iir2_H_Parametric_f00125_q15_Gain06_a2    set -0.49957985       ; C00DC5

; IIR2: mode=Parametric fc=157.49 Q=15 gainDB=6 h=< 0.50026339 -0.99921912 0.49920733 0.99921912 -0.49947072 >,< 4008A1 801997 3FE606 7FE669 C01158 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q15_Gain06_b0    set 0.50026339       ; 4008A1
iir2_H_Parametric_f00157_q15_Gain06_b1    set -0.99921912       ; 801997
iir2_H_Parametric_f00157_q15_Gain06_b2    set 0.49920733       ; 3FE606
iir2_H_Parametric_f00157_q15_Gain06_a1    set 0.99921912       ; 7FE669
iir2_H_Parametric_f00157_q15_Gain06_a2    set -0.49947072       ; C01158

; IIR2: mode=Parametric fc=198.425 Q=15 gainDB=6 h=< 0.50033179 -0.99893394 0.49900149 0.99893394 -0.49933327 >,< 400ADF 8022EF 3FDF47 7FDD11 C015D9 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q15_Gain06_b0    set 0.50033179       ; 400ADF
iir2_H_Parametric_f00198_q15_Gain06_b1    set -0.99893394       ; 8022EF
iir2_H_Parametric_f00198_q15_Gain06_b2    set 0.49900149       ; 3FDF47
iir2_H_Parametric_f00198_q15_Gain06_a1    set 0.99893394       ; 7FDD11
iir2_H_Parametric_f00198_q15_Gain06_a2    set -0.49933327       ; C015D9

; IIR2: mode=Parametric fc=250 Q=15 gainDB=6 h=< 0.50041792 -0.99852643 0.49874227 0.99852643 -0.49916018 >,< 400DB2 803049 3FD6C9 7FCFB7 C01B85 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q15_Gain06_b0    set 0.50041792       ; 400DB2
iir2_H_Parametric_f00250_q15_Gain06_b1    set -0.99852643       ; 803049
iir2_H_Parametric_f00250_q15_Gain06_b2    set 0.49874227       ; 3FD6C9
iir2_H_Parametric_f00250_q15_Gain06_a1    set 0.99852643       ; 7FCFB7
iir2_H_Parametric_f00250_q15_Gain06_a2    set -0.49916018       ; C01B85

; IIR2: mode=Parametric fc=314.98 Q=15 gainDB=6 h=< 0.50052636 -0.99793652 0.49841590 0.99793652 -0.49894226 >,< 40113F 80439E 3FCC17 7FBC62 C022A9 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q15_Gain06_b0    set 0.50052636       ; 40113F
iir2_H_Parametric_f00314_q15_Gain06_b1    set -0.99793652       ; 80439E
iir2_H_Parametric_f00314_q15_Gain06_b2    set 0.49841590       ; 3FCC17
iir2_H_Parametric_f00314_q15_Gain06_a1    set 0.99793652       