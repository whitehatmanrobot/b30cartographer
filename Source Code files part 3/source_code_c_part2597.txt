
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndPrepareVariants )( 
            ICrmCompensatorVariants __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbOkToPrepare);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginCommitVariants )( 
            ICrmCompensatorVariants __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bRecovery);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitRecordVariants )( 
            ICrmCompensatorVariants __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pLogRecord,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbForget);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndCommitVariants )( 
            ICrmCompensatorVariants __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginAbortVariants )( 
            ICrmCompensatorVariants __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bRecovery);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AbortRecordVariants )( 
            ICrmCompensatorVariants __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pLogRecord,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbForget);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndAbortVariants )( 
            ICrmCompensatorVariants __RPC_FAR * This);
        
        END_INTERFACE
    } ICrmCompensatorVariantsVtbl;

    interface ICrmCompensatorVariants
    {
        CONST_VTBL struct ICrmCompensatorVariantsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmCompensatorVariants_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrmCompensatorVariants_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrmCompensatorVariants_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrmCompensatorVariants_SetLogControlVariants(This,pLogControl)	\
    (This)->lpVtbl -> SetLogControlVariants(This,pLogControl)

#define ICrmCompensatorVariants_BeginPrepareVariants(This)	\
    (This)->lpVtbl -> BeginPrepareVariants(This)

#define ICrmCompensatorVariants_PrepareRecordVariants(This,pLogRecord,pbForget)	\
    (This)->lpVtbl -> PrepareRecordVariants(This,pLogRecord,pbForget)

#define ICrmCompensatorVariants_EndPrepareVariants(This,pbOkToPrepare)	\
    (This)->lpVtbl -> EndPrepareVariants(This,pbOkToPrepare)

#define ICrmCompensatorVariants_BeginCommitVariants(This,bRecovery)	\
    (This)->lpVtbl -> BeginCommitVariants(This,bRecovery)

#define ICrmCompensatorVariants_CommitRecordVariants(This,pLogRecord,pbForget)	\
    (This)->lpVtbl -> CommitRecordVariants(This,pLogRecord,pbForget)

#define ICrmCompensatorVariants_EndCommitVariants(This)	\
    (This)->lpVtbl -> EndCommitVariants(This)

#define ICrmCompensatorVariants_BeginAbortVariants(This,bRecovery)	\
    (This)->lpVtbl -> BeginAbortVariants(This,bRecovery)

#define ICrmCompensatorVariants_AbortRecordVariants(This,pLogRecord,pbForget)	\
    (This)->lpVtbl -> AbortRecordVariants(This,pLogRecord,pbForget)

#define ICrmCompensatorVariants_EndAbortVariants(This)	\
    (This)->lpVtbl -> EndAbortVariants(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_SetLogControlVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This,
    /* [in] */ ICrmLogControl __RPC_FAR *pLogControl);


void __RPC_STUB ICrmCompensatorVariants_SetLogControlVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_BeginPrepareVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This);


void __RPC_STUB ICrmCompensatorVariants_BeginPrepareVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_PrepareRecordVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pLogRecord,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbForget);


void __RPC_STUB ICrmCompensatorVariants_PrepareRecordVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_EndPrepareVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbOkToPrepare);


void __RPC_STUB ICrmCompensatorVariants_EndPrepareVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_BeginCommitVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bRecovery);


void __RPC_STUB ICrmCompensatorVariants_BeginCommitVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_CommitRecordVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pLogRecord,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbForget);


void __RPC_STUB ICrmCompensatorVariants_CommitRecordVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_EndCommitVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This);


void __RPC_STUB ICrmCompensatorVariants_EndCommitVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_BeginAbortVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bRecovery);


void __RPC_STUB ICrmCompensatorVariants_BeginAbortVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_AbortRecordVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pLogRecord,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbForget);


void __RPC_STUB ICrmCompensatorVariants_AbortRecordVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmCompensatorVariants_EndAbortVariants_Proxy( 
    ICrmCompensatorVariants __RPC_FAR * This);


void __RPC_STUB ICrmCompensatorVariants_EndAbortVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrmCompensatorVariants_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0327 */
/* [local] */ 

#ifndef _tagCrmLogRecordRead_
#define _tagCrmLogRecordRead_
typedef struct tagCrmLogRecordRead
    {
    DWORD dwCrmFlags;
    DWORD dwSequenceNumber;
    BLOB blobUserData;
    }	CrmLogRecordRead;

#endif _tagCrmLogRecordRead_


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0327_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0327_v0_0_s_ifspec;

#ifndef __ICrmCompensator_INTERFACE_DEFINED__
#define __ICrmCompensator_INTERFACE_DEFINED__

/* interface ICrmCompensator */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmCompensator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BBC01830-8D3B-11d1-82EC-00A0C91EEDE9")
    ICrmCompensator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLogControl( 
            /* [in] */ ICrmLogControl __RPC_FAR *pLogControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginPrepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrepareRecord( 
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ BOOL __RPC_FAR *pfForget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndPrepare( 
            /* [retval][out] */ BOOL __RPC_FAR *pfOkToPrepare) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCommit( 
            /* [in] */ BOOL fRecovery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitRecord( 
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ BOOL __RPC_FAR *pfForget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndCommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginAbort( 
            /* [in] */ BOOL fRecovery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortRecord( 
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ BOOL __RPC_FAR *pfForget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmCompensatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrmCompensator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrmCompensator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrmCompensator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogControl )( 
            ICrmCompensator __RPC_FAR * This,
            /* [in] */ ICrmLogControl __RPC_FAR *pLogControl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginPrepare )( 
            ICrmCompensator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrepareRecord )( 
            ICrmCompensator __RPC_FAR * This,
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ BOOL __RPC_FAR *pfForget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndPrepare )( 
            ICrmCompensator __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfOkToPrepare);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginCommit )( 
            ICrmCompensator __RPC_FAR * This,
            /* [in] */ BOOL fRecovery);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitRecord )( 
            ICrmCompensator __RPC_FAR * This,
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ BOOL __RPC_FAR *pfForget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndCommit )( 
            ICrmCompensator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginAbort )( 
            ICrmCompensator __RPC_FAR * This,
            /* [in] */ BOOL fRecovery);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AbortRecord )( 
            ICrmCompensator __RPC_FAR * This,
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ BOOL __RPC_FAR *pfForget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndAbort )( 
            ICrmCompensator __RPC_FAR * This);
        
        END_INTERFACE
    } ICrmCompensatorVtbl;

    interface ICrmCompensator
    {
        CONST_VTBL struct ICrmCompensatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmCompensator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrmCompensator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrmCompensator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrmCompensator_SetLogControl(This,pLogControl)	\
    (This)->lpVtbl -> SetLogControl(This,pLogControl)

#define ICrmCompensator_BeginPrepare(This)	\
    (This)->lpVtbl -> BeginPrepare(This)

#define ICrmCompensator_PrepareRecord(This,crmLogRec,pfForget)	\
    (This)->lpVtbl -> PrepareRecord(This,crmLogRec,pfForget)

#define ICrmCompensator_EndPrepare(This,pfOkToPrepare)	\
    (This)->lpVtbl -> EndPrepare(This,pfOkToPrepare)

#define ICrmCompensator_BeginCommit(This,fRecovery)	\
    (This)->lpVtbl -> BeginCommit(This,fRecovery)

#define ICrmCompensator_CommitRecord(This,crmLogRec,pfForget)	\
    (This)->lpVtbl -> CommitRecord(This,crmLogRec,pfForget)

#define ICrmCompensator_EndCommit(This)	\
    (This)->lpVtbl -> EndCommit(This)

#define ICrmCompensator_BeginAbort(This,fRecovery)	\
    (This)->lpVtbl -> BeginAbort(This,fRecovery)

#define ICrmCompensator_AbortRecord(This,crmLogRec,pfForget)	\
    (This)->lpVtbl -> AbortRecord(This,crmLogRec,pfForget)

#define ICrmCompensator_EndAbort(This)	\
    (This)->lpVtbl -> EndAbort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICrmCompensator_SetLogControl_Proxy( 
    ICrmCompensator __RPC_FAR * This,
    /* [in] */ ICrmLogControl __RPC_FAR *pLogControl);


void __RPC_STUB ICrmCompensator_SetLogControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_BeginPrepare_Proxy( 
    ICrmCompensator __RPC_FAR * This);


void __RPC_STUB ICrmCompensator_BeginPrepare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_PrepareRecord_Proxy( 
    ICrmCompensator __RPC_FAR * This,
    /* [in] */ CrmLogRecordRead crmLogRec,
    /* [retval][out] */ BOOL __RPC_FAR *pfForget);


void __RPC_STUB ICrmCompensator_PrepareRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_EndPrepare_Proxy( 
    ICrmCompensator __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfOkToPrepare);


void __RPC_STUB ICrmCompensator_EndPrepare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_BeginCommit_Proxy( 
    ICrmCompensator __RPC_FAR * This,
    /* [in] */ BOOL fRecovery);


void __RPC_STUB ICrmCompensator_BeginCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_CommitRecord_Proxy( 
    ICrmCompensator __RPC_FAR * This,
    /* [in] */ CrmLogRecordRead crmLogRec,
    /* [retval][out] */ BOOL __RPC_FAR *pfForget);


void __RPC_STUB ICrmCompensator_CommitRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_EndCommit_Proxy( 
    ICrmCompensator __RPC_FAR * This);


void __RPC_STUB ICrmCompensator_EndCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_BeginAbort_Proxy( 
    ICrmCompensator __RPC_FAR * This,
    /* [in] */ BOOL fRecovery);


void __RPC_STUB ICrmCompensator_BeginAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_AbortRecord_Proxy( 
    ICrmCompensator __RPC_FAR * This,
    /* [in] */ CrmLogRecordRead crmLogRec,
    /* [retval][out] */ BOOL __RPC_FAR *pfForget);


void __RPC_STUB ICrmCompensator_AbortRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICrmCompensator_EndAbort_Proxy( 
    ICrmCompensator __RPC_FAR * This);


void __RPC_STUB ICrmCompensator_EndAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrmCompensator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0328 */
/* [local] */ 

#ifndef _tagCrmTransactionState_
#define _tagCrmTransactionState_
typedef 
enum tagCrmTransactionState
    {	TxState_Active	= 0,
	TxState_Committed	= TxState_Active + 1,
	TxState_Aborted	= TxState_Committed + 1,
	TxState_Indoubt	= TxState_Aborted + 1
    }	CrmTransactionState;

#endif _tagCrmTransactionState_


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0328_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0328_v0_0_s_ifspec;

#ifndef __ICrmMonitorLogRecords_INTERFACE_DEFINED__
#define __ICrmMonitorLogRecords_INTERFACE_DEFINED__

/* interface ICrmMonitorLogRecords */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmMonitorLogRecords;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70C8E441-C7ED-11d1-82FB-00A0C91EEDE9")
    ICrmMonitorLogRecords : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransactionState( 
            /* [retval][out] */ CrmTransactionState __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StructuredRecords( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLogRecord( 
            /* [in] */ DWORD dwIndex,
            /* [out][in] */ CrmLogRecordRead __RPC_FAR *pCrmLogRec) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLogRecordVariants( 
            /* [in] */ VARIANT IndexNumber,
            /* [retval][out] */ LPVARIANT pLogRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmMonitorLogRecordsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrmMonitorLogRecords __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrmMonitorLogRecords __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrmMonitorLogRecords __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ICrmMonitorLogRecords __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TransactionState )( 
            ICrmMonitorLogRecords __RPC_FAR * This,
            /* [retval][out] */ CrmTransactionState __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StructuredRecords )( 
            ICrmMonitorLogRecords __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogRecord )( 
            ICrmMonitorLogRecords __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out][in] */ CrmLogRecordRead __RPC_FAR *pCrmLogRec);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogRecordVariants )( 
            ICrmMonitorLogRecords __RPC_FAR * This,
            /* [in] */ VARIANT IndexNumber,
            /* [retval][out] */ LPVARIANT pLogRecord);
        
        END_INTERFACE
    } ICrmMonitorLogRecordsVtbl;

    interface ICrmMonitorLogRecords
    {
        CONST_VTBL struct ICrmMonitorLogRecordsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmMonitorLogRecords_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrmMonitorLogRecords_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrmMonitorLogRecords_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrmMonitorLogRecords_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define ICrmMonitorLogRecords_get_TransactionState(This,pVal)	\
    (This)->lpVtbl -> get_TransactionState(This,pVal)

#define ICrmMonitorLogRecords_get_StructuredRecords(This,pVal)	\
    (This)->lpVtbl -> get_StructuredRecords(This,pVal)

#define ICrmMonitorLogRecords_GetLogRecord(This,dwIndex,pCrmLogRec)	\
    (This)->lpVtbl -> GetLogRecord(This,dwIndex,pCrmLogRec)

#define ICrmMonitorLogRecords_GetLogRecordVariants(This,IndexNumber,pLogRecord)	\
    (This)->lpVtbl -> GetLogRecordVariants(This,IndexNumber,pLogRecord)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICrmMonitorLogRecords_get_Count_Proxy( 
    ICrmMonitorLogRecords __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ICrmMonitorLogRecords_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICrmMonitorLogRecords_get_TransactionState_Proxy( 
    ICrmMonitorLogRecords __RPC_FAR * This,
    /* [retval][out] */ CrmTransactionState __RPC_FAR *pVal);


void __RPC_STUB ICrmMonitorLogRecords_get_TransactionState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICrmMonitorLogRecords_get_StructuredRecords_Proxy( 
    ICrmMonitorLogRecords __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB ICrmMonitorLogRecords_get_StructuredRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitorLogRecords_GetLogRecord_Proxy( 
    ICrmMonitorLogRecords __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out][in] */ CrmLogRecordRead __RPC_FAR *pCrmLogRec);


void __RPC_STUB ICrmMonitorLogRecords_GetLogRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitorLogRecords_GetLogRecordVariants_Proxy( 
    ICrmMonitorLogRecords __RPC_FAR * This,
    /* [in] */ VARIANT IndexNumber,
    /* [retval][out] */ LPVARIANT pLogRecord);


void __RPC_STUB ICrmMonitorLogRecords_GetLogRecordVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrmMonitorLogRecords_INTERFACE_DEFINED__ */


#ifndef __ICrmMonitorClerks_INTERFACE_DEFINED__
#define __ICrmMonitorClerks_INTERFACE_DEFINED__

/* interface ICrmMonitorClerks */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrmMonitorClerks;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70C8E442-C7ED-11d1-82FB-00A0C91EEDE9")
    ICrmMonitorClerks : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem) = 0;
        
        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProgIdCompensator( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Description( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TransactionUOW( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ActivityId( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmMonitorClerksVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrmMonitorClerks __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrmMonitorClerks __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProgIdCompensator )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Description )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransactionUOW )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ActivityId )( 
            ICrmMonitorClerks __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem);
        
        END_INTERFACE
    } ICrmMonitorClerksVtbl;

    interface ICrmMonitorClerks
    {
        CONST_VTBL struct ICrmMonitorClerksVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmMonitorClerks_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrmMonitorClerks_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrmMonitorClerks_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrmMonitorClerks_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrmMonitorClerks_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrmMonitorClerks_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrmMonitorClerks_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrmMonitorClerks_Item(This,Index,pItem)	\
    (This)->lpVtbl -> Item(This,Index,pItem)

#define ICrmMonitorClerks_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define ICrmMonitorClerks_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define ICrmMonitorClerks_ProgIdCompensator(This,Index,pItem)	\
    (This)->lpVtbl -> ProgIdCompensator(This,Index,pItem)

#define ICrmMonitorClerks_Description(This,Index,pItem)	\
    (This)->lpVtbl -> Description(This,Index,pItem)

#define ICrmMonitorClerks_TransactionUOW(This,Index,pItem)	\
    (This)->lpVtbl -> TransactionUOW(This,Index,pItem)

#define ICrmMonitorClerks_ActivityId(This,Index,pItem)	\
    (This)->lpVtbl -> ActivityId(This,Index,pItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitorClerks_Item_Proxy( 
    ICrmMonitorClerks __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPVARIANT pItem);


void __RPC_STUB ICrmMonitorClerks_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICrmMonitorClerks_get__NewEnum_Proxy( 
    ICrmMonitorClerks __RPC_FAR * This,
    /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal);


void __RPC_STUB ICrmMonitorClerks_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICrmMonitorClerks_get_Count_Proxy( 
    ICrmMonitorClerks __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ICrmMonitorClerks_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitorClerks_ProgIdCompensator_Proxy( 
    ICrmMonitorClerks __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPVARIANT pItem);


void __RPC_STUB ICrmMonitorClerks_ProgIdCompensator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitorClerks_Description_Proxy( 
    ICrmMonitorClerks __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPVARIANT pItem);


void __RPC_STUB ICrmMonitorClerks_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitorClerks_TransactionUOW_Proxy( 
    ICrmMonitorClerks __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPVARIANT pItem);


void __RPC_STUB ICrmMonitorClerks_TransactionUOW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitorClerks_ActivityId_Proxy( 
    ICrmMonitorClerks __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPVARIANT pItem);


void __RPC_STUB ICrmMonitorClerks_ActivityId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrmMonitorClerks_INTERFACE_DEFINED__ */


#ifndef __ICrmMonitor_INTERFACE_DEFINED__
#define __ICrmMonitor_INTERFACE_DEFINED__

/* interface ICrmMonitor */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmMonitor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70C8E443-C7ED-11d1-82FB-00A0C91EEDE9")
    ICrmMonitor : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClerks( 
            /* [retval][out] */ ICrmMonitorClerks __RPC_FAR *__RPC_FAR *pClerks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HoldClerk( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmMonitorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrmMonitor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrmMonitor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrmMonitor __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClerks )( 
            ICrmMonitor __RPC_FAR * This,
            /* [retval][out] */ ICrmMonitorClerks __RPC_FAR *__RPC_FAR *pClerks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HoldClerk )( 
            ICrmMonitor __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPVARIANT pItem);
        
        END_INTERFACE
    } ICrmMonitorVtbl;

    interface ICrmMonitor
    {
        CONST_VTBL struct ICrmMonitorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmMonitor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrmMonitor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrmMonitor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrmMonitor_GetClerks(This,pClerks)	\
    (This)->lpVtbl -> GetClerks(This,pClerks)

#define ICrmMonitor_HoldClerk(This,Index,pItem)	\
    (This)->lpVtbl -> HoldClerk(This,Index,pItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitor_GetClerks_Proxy( 
    ICrmMonitor __RPC_FAR * This,
    /* [retval][out] */ ICrmMonitorClerks __RPC_FAR *__RPC_FAR *pClerks);


void __RPC_STUB ICrmMonitor_GetClerks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmMonitor_HoldClerk_Proxy( 
    ICrmMonitor __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPVARIANT pItem);


void __RPC_STUB ICrmMonitor_HoldClerk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrmMonitor_INTERFACE_DEFINED__ */


#ifndef __ICrmFormatLogRecords_INTERFACE_DEFINED__
#define __ICrmFormatLogRecords_INTERFACE_DEFINED__

/* interface ICrmFormatLogRecords */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmFormatLogRecords;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C51D821-C98B-11d1-82FB-00A0C91EEDE9")
    ICrmFormatLogRecords : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetColumnCount( 
            /* [out] */ long __RPC_FAR *plColumnCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetColumnHeaders( 
            /* [out] */ LPVARIANT pHeaders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetColumn( 
            /* [in] */ CrmLogRecordRead CrmLogRec,
            /* [out] */ LPVARIANT pFormattedLogRecord) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetColumnVariants( 
            /* [in] */ VARIANT LogRecord,
            /* [out] */ LPVARIANT pFormattedLogRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmFormatLogRecordsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrmFormatLogRecords __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrmFormatLogRecords __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrmFormatLogRecords __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnCount )( 
            ICrmFormatLogRecords __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *plColumnCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnHeaders )( 
            ICrmFormatLogRecords __RPC_FAR * This,
            /* [out] */ LPVARIANT pHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumn )( 
            ICrmFormatLogRecords __RPC_FAR * This,
            /* [in] */ CrmLogRecordRead CrmLogRec,
            /* [out] */ LPVARIANT pFormattedLogRecord);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnVariants )( 
            ICrmFormatLogRecords __RPC_FAR * This,
            /* [in] */ VARIANT LogRecord,
            /* [out] */ LPVARIANT pFormattedLogRecord);
        
        END_INTERFACE
    } ICrmFormatLogRecordsVtbl;

    interface ICrmFormatLogRecords
    {
        CONST_VTBL struct ICrmFormatLogRecordsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmFormatLogRecords_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrmFormatLogRecords_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrmFormatLogRecords_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrmFormatLogRecords_GetColumnCount(This,plColumnCount)	\
    (This)->lpVtbl -> GetColumnCount(This,plColumnCount)

#define ICrmFormatLogRecords_GetColumnHeaders(This,pHeaders)	\
    (This)->lpVtbl -> GetColumnHeaders(This,pHeaders)

#define ICrmFormatLogRecords_GetColumn(This,CrmLogRec,pFormattedLogRecord)	\
    (This)->lpVtbl -> GetColumn(This,CrmLogRec,pFormattedLogRecord)

#define ICrmFormatLogRecords_GetColumnVariants(This,LogRecord,pFormattedLogRecord)	\
    (This)->lpVtbl -> GetColumnVariants(This,LogRecord,pFormattedLogRecord)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmFormatLogRecords_GetColumnCount_Proxy( 
    ICrmFormatLogRecords __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *plColumnCount);


void __RPC_STUB ICrmFormatLogRecords_GetColumnCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmFormatLogRecords_GetColumnHeaders_Proxy( 
    ICrmFormatLogRecords __RPC_FAR * This,
    /* [out] */ LPVARIANT pHeaders);


void __RPC_STUB ICrmFormatLogRecords_GetColumnHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmFormatLogRecords_GetColumn_Proxy( 
    ICrmFormatLogRecords __RPC_FAR * This,
    /* [in] */ CrmLogRecordRead CrmLogRec,
    /* [out] */ LPVARIANT pFormattedLogRecord);


void __RPC_STUB ICrmFormatLogRecords_GetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICrmFormatLogRecords_GetColumnVariants_Proxy( 
    ICrmFormatLogRecords __RPC_FAR * This,
    /* [in] */ VARIANT LogRecord,
    /* [out] */ LPVARIANT pFormattedLogRecord);


void __RPC_STUB ICrmFormatLogRecords_GetColumnVariants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrmFormatLogRecords_INTERFACE_DEFINED__ */



#ifndef __COMSVCSLib_LIBRARY_DEFINED__
#define __COMSVCSLib_LIBRARY_DEFINED__

/* library COMSVCSLib */
/* [helpfile][helpstring][version][uuid] */ 


typedef /* [public][helpcontext][helpstring] */ 
enum __MIDL___MIDL_itf_autosvcs_0332_0001
    {	mtsErrCtxAborted	= 0x8004e002,
	mtsErrCtxAborting	= 0x8004e003,
	mtsErrCtxNoContext	= 0x8004e004,
	mtsErrCtxNotRegistered	= 0x8004e005,
	mtsErrCtxSynchTimeout	= 0x8004e006,
	mtsErrCtxOldReference	= 0x8004e007,
	mtsErrCtxRoleNotFound	= 0x8004e00c,
	mtsErrCtxNoSecurity	= 0x8004e00d,
	mtsErrCtxWrongThread	= 0x8004e00e,
	mtsErrCtxTMNotAvailable	= 0x8004e00f,
	comQCErrApplicationNotQueued	= 0x80110600,
	comQCErrNoQueueableInterfaces	= 0x80110601,
	comQCErrQueuingServiceNotAvailable	= 0x80110602,
	comQCErrQueueTransactMismatch	= 0x80110603,
	comqcErrRecorderMarshalled	= 0x80110604,
	comqcErrOutParam	= 0x80110605,
	comqcErrRecorderNotTrusted	= 0x80110606,
	comqcErrPSLoad	= 0x80110607,
	comqcErrMarshaledObjSameTxn	= 0x80110608,
	comqcErrInvalidMessage	= 0x80110650,
	comqcErrMsmqSidUnavailable	= 0x80110651,
	comqcErrWrongMsgExtension	= 0x80110652,
	comqcErrMsmqServiceUnavailable	= 0x80110653,
	comqcErrMsgNotAuthenticated	= 0x80110654,
	comqcErrMsmqConnectorUsed	= 0x80110655,
	comqcErrBadMarshaledObject	= 0x80110656
    }	Error_Constants;


typedef /* [public] */ 
enum __MIDL___MIDL_itf_autosvcs_0332_0002
    {	LockSetGet	= 0,
	LockMethod	= LockSetGet + 1
    }	LockModes;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_autosvcs_0332_0003
    {	Standard	= 0,
	Process	= Standard + 1
    }	ReleaseModes;

#ifndef _tagCrmFlags_
#define _tagCrmFlags_
typedef 
enum tagCRMFLAGS
    {	CRMFLAG_FORGETTARGET	= 0x1,
	CRMFLAG_WRITTENDURINGPREPARE	= 0x2,
	CRMFLAG_WRITTENDURINGCOMMIT	= 0x4,
	CRMFLAG_WRITTENDURINGABORT	= 0x8,
	CRMFLAG_WRITTENDURINGRECOVERY	= 0x10,
	CRMFLAG_WRITTENDURINGREPLAY	= 0x20,
	CRMFLAG_REPLAYINPROGRESS	= 0x40
    }	CRMFLAGS;

#endif _tagCrmFlags_
#ifndef _tagCrmRegFlags_
#define _tagCrmRegFlags_
typedef 
enum tagCRMREGFLAGS
    {	CRMREGFLAG_PREPAREPHASE	= 0x1,
	CRMREGFLAG_COMMITPHASE	= 0x2,
	CRMREGFLAG_ABORTPHASE	= 0x4,
	CRMREGFLAG_ALLPHASES	= 0x7,
	CRMREGFLAG_FAILIFINDOUBTSREMAIN	= 0x10
    }	CRMREGFLAGS;

#endif _tagCrmRegFlags_

EXTERN_C const IID LIBID_COMSVCSLib;

EXTERN_C const CLSID CLSID_SecurityIdentity;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a5-7f19-11d2-978e-0000f8757e2a")
SecurityIdentity;
#endif

EXTERN_C const CLSID CLSID_SecurityCallers;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a6-7f19-11d2-978e-0000f8757e2a")
SecurityCallers;
#endif

EXTERN_C const CLSID CLSID_SecurityCallContext;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a7-7f19-11d2-978e-0000f8757e2a")
SecurityCallContext;
#endif

EXTERN_C const CLSID CLSID_GetSecurityCallContextAppObject;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a8-7f19-11d2-978e-0000f8757e2a")
GetSecurityCallContextAppObject;
#endif

EXTERN_C const CLSID CLSID_Dummy30040732;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a9-7f19-11d2-978e-0000f8757e2a")
Dummy30040732;
#endif

EXTERN_C const CLSID CLSID_TransactionContext;

#ifdef __cplusplus

class DECLSPEC_UUID("7999FC25-D3C6-11CF-ACAB-00A024A55AEF")
TransactionContext;
#endif

EXTERN_C const CLSID CLSID_TransactionContextEx;

#ifdef __cplusplus

class DECLSPEC_UUID("5cb66670-d3d4-11cf-acab-00a024a55aef")
TransactionContextEx;
#endif

EXTERN_C const CLSID CLSID_SharedProperty;

#ifdef __cplusplus

class DECLSPEC_UUID("2A005C05-A5DE-11CF-9E66-00AA00A3F464")
SharedProperty;
#endif

EXTERN_C const CLSID CLSID_SharedPropertyGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("2A005C0B-A5DE-11CF-9E66-00AA00A3F464")
SharedPropertyGroup;
#endif

EXTERN_C const CLSID CLSID_SharedPropertyGroupManager;

#ifdef __cplusplus

class DECLSPEC_UUID("2A005C11-A5DE-11CF-9E66-00AA00A3F464")
SharedPropertyGroupManager;
#endif

EXTERN_C const CLSID CLSID_COMEvents;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0ab-7f19-11d2-978e-0000f8757e2a")
COMEvents;
#endif

EXTERN_C const CLSID CLSID_CoMTSLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0ac-7f19-11d2-978e-0000f8757e2a")
CoMTSLocator;
#endif

EXTERN_C const CLSID CLSID_MtsGrp;

#ifdef __cplusplus

class DECLSPEC_UUID("4B2E958D-0393-11D1-B1AB-00AA00BA3258")
MtsGrp;
#endif

EXTERN_C const CLSID CLSID_ComServiceEvents;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0c3-7f19-11d2-978e-0000f8757e2a")
ComServiceEvents;
#endif

EXTERN_C const CLSID CLSID_CRMClerk;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0bd-7f19-11d2-978e-0000f8757e2a")
CRMClerk;
#endif

EXTERN_C const CLSID CLSID_CRMRecoveryClerk;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0be-7f19-11d2-978e-0000f8757e2a")
CRMRecoveryClerk;
#endif

EXTERN_C const CLSID CLSID_LBEvents;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0c1-7f19-11d2-978e-0000f8757e2a")
LBEvents;
#endif

EXTERN_C const CLSID CLSID_MessageMover;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0bf-7f19-11d2-978e-0000f8757e2a")
MessageMover;
#endif

EXTERN_C const CLSID CLSID_DispenserManager;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0c0-7f19-11d2-978e-0000f8757e2a")
DispenserManager;
#endif
#endif /* __COMSVCSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ConfPriv.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for confpriv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __confpriv_h__
#define __confpriv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDummy_FWD_DEFINED__
#define __IDummy_FWD_DEFINED__
typedef interface IDummy IDummy;
#endif 	/* __IDummy_FWD_DEFINED__ */


#ifndef __ITLocalParticipant_FWD_DEFINED__
#define __ITLocalParticipant_FWD_DEFINED__
typedef interface ITLocalParticipant ITLocalParticipant;
#endif 	/* __ITLocalParticipant_FWD_DEFINED__ */


#ifndef __IEnumParticipant_FWD_DEFINED__
#define __IEnumParticipant_FWD_DEFINED__
typedef interface IEnumParticipant IEnumParticipant;
#endif 	/* __IEnumParticipant_FWD_DEFINED__ */


#ifndef __ITParticipantControl_FWD_DEFINED__
#define __ITParticipantControl_FWD_DEFINED__
typedef interface ITParticipantControl ITParticipantControl;
#endif 	/* __ITParticipantControl_FWD_DEFINED__ */


#ifndef __ITParticipantSubStreamControl_FWD_DEFINED__
#define __ITParticipantSubStreamControl_FWD_DEFINED__
typedef interface ITParticipantSubStreamControl ITParticipantSubStreamControl;
#endif 	/* __ITParticipantSubStreamControl_FWD_DEFINED__ */


#ifndef __ITParticipantEvent_FWD_DEFINED__
#define __ITParticipantEvent_FWD_DEFINED__
typedef interface ITParticipantEvent ITParticipantEvent;
#endif 	/* __ITParticipantEvent_FWD_DEFINED__ */


#ifndef __IMulticastControl_FWD_DEFINED__
#define __IMulticastControl_FWD_DEFINED__
typedef interface IMulticastControl IMulticastControl;
#endif 	/* __IMulticastControl_FWD_DEFINED__ */


/* header files for imported files */
#include "ipmsp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_confpriv_0000 */
/* [local] */ 

/* Copyright (c) 1998-1999  Microsoft Corporation  */
typedef 
enum MULTICAST_LOOPBACK_MODE
    {	MM_NO_LOOPBACK	= 0,
	MM_FULL_LOOPBACK	= MM_NO_LOOPBACK + 1,
	MM_SELECTIVE_LOOPBACK	= MM_FULL_LOOPBACK + 1
    } 	MULTICAST_LOOPBACK_MODE;



extern RPC_IF_HANDLE __MIDL_itf_confpriv_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_confpriv_0000_v0_0_s_ifspec;

#ifndef __IDummy_INTERFACE_DEFINED__
#define __IDummy_INTERFACE_DEFINED__

/* interface IDummy */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDummy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d7ca54a-d252-4fcb-9104-f6ddd310b3f9")
    IDummy : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDummyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDummy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDummy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDummy * This);
        
        END_INTERFACE
    } IDummyVtbl;

    interface IDummy
    {
        CONST_VTBL struct IDummyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDummy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDummy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDummy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDummy_INTERFACE_DEFINED__ */


#ifndef __ITLocalParticipant_INTERFACE_DEFINED__
#define __ITLocalParticipant_INTERFACE_DEFINED__

/* interface ITLocalParticipant */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLocalParticipant;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39cbf055-f77a-11d2-a824-00c04f8ef6e3")
    ITLocalParticipant : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalParticipantTypedInfo( 
            /* [in] */ PARTICIPANT_TYPED_INFO InfoType,
            /* [retval][out] */ BSTR *ppInfo) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LocalParticipantTypedInfo( 
            /* [in] */ PARTICIPANT_TYPED_INFO InfoType,
            /* [in] */ BSTR pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLocalParticipantVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITLocalParticipant * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITLocalParticipant * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITLocalParticipant * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITLocalParticipant * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITLocalParticipant * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITLocalParticipant * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITLocalParticipant * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalParticipantTypedInfo )( 
            ITLocalParticipant * This,
            /* [in] */ PARTICIPANT_TYPED_INFO InfoType,
            /* [retval][out] */ BSTR *ppInfo);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalParticipantTypedInfo )( 
            ITLocalParticipant * This,
            /* [in] */ PARTICIPANT_TYPED_INFO InfoType,
            /* [in] */ BSTR pInfo);
        
        END_INTERFACE
    } ITLocalParticipantVtbl;

    interface ITLocalParticipant
    {
        CONST_VTBL struct ITLocalParticipantVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLocalParticipant_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITLocalParticipant_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITLocalParticipant_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITLocalParticipant_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITLocalParticipant_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITLocalParticipant_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITLocalParticipant_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITLocalParticipant_get_LocalParticipantTypedInfo(This,InfoType,ppInfo)	\
    (This)->lpVtbl -> get_LocalParticipantTypedInfo(This,InfoType,ppInfo)

#define ITLocalParticipant_put_LocalParticipantTypedInfo(This,InfoType,pInfo)	\
    (This)->lpVtbl -> put_LocalParticipantTypedInfo(This,InfoType,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocalParticipant_get_LocalParticipantTypedInfo_Proxy( 
    ITLocalParticipant * This,
    /* [in] */ PARTICIPANT_TYPED_INFO InfoType,
    /* [retval][out] */ BSTR *ppInfo);


void __RPC_STUB ITLocalParticipant_get_LocalParticipantTypedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITLocalParticipant_put_LocalParticipantTypedInfo_Proxy( 
    ITLocalParticipant * This,
    /* [in] */ PARTICIPANT_TYPED_INFO InfoType,
    /* [in] */ BSTR pInfo);


void __RPC_STUB ITLocalParticipant_put_LocalParticipantTypedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITLocalParticipant_INTERFACE_DEFINED__ */


#ifndef __IEnumParticipant_INTERFACE_DEFINED__
#define __IEnumParticipant_INTERFACE_DEFINED__

/* interface IEnumParticipant */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumParticipant;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0a91b56c-5a35-11d2-95a0-00a0244d2298")
    IEnumParticipant : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITParticipant **ppElements,
            /* [full][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumParticipant **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumParticipantVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumParticipant * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumParticipant * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumParticipant * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumParticipant * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITParticipant **ppElements,
            /* [full][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumParticipant * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumParticipant * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumParticipant * This,
            /* [retval][out] */ IEnumParticipant **ppEnum);
        
        END_INTERFACE
    } IEnumParticipantVtbl;

    interface IEnumParticipant
    {
        CONST_VTBL struct IEnumParticipantVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumParticipant_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumParticipant_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumParticipant_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumParticipant_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumParticipant_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumParticipant_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumParticipant_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumParticipant_Next_Proxy( 
    IEnumParticipant * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITParticipant **ppElements,
    /* [full][out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumParticipant_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumParticipant_Reset_Proxy( 
    IEnumParticipant * This);


void __RPC_STUB IEnumParticipant_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumParticipant_Skip_Proxy( 
    IEnumParticipant * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumParticipant_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumParticipant_Clone_Proxy( 
    IEnumParticipant * This,
    /* [retval][out] */ IEnumParticipant **ppEnum);


void __RPC_STUB IEnumParticipant_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumParticipant_INTERFACE_DEFINED__ */


#ifndef __ITParticipantControl_INTERFACE_DEFINED__
#define __ITParticipantControl_INTERFACE_DEFINED__

/* interface ITParticipantControl */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITParticipantControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d2ee6684-5a34-11d2-95a0-00a0244d2298")
    ITParticipantControl : public IDispatch
    {
    public:
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateParticipants( 
            /* [retval][out] */ IEnumParticipant **ppEnumParticipants) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Participants( 
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITParticipantControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITParticipantControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITParticipantControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITParticipantControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITParticipantControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITParticipantControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITParticipantControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITParticipantControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateParticipants )( 
            ITParticipantControl * This,
            /* [retval][out] */ IEnumParticipant **ppEnumParticipants);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Participants )( 
            ITParticipantControl * This,
            /* [retval][out] */ VARIANT *pVariant);
        
        END_INTERFACE
    } ITParticipantControlVtbl;

    interface ITParticipantControl
    {
        CONST_VTBL struct ITParticipantControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITParticipantControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITParticipantControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITParticipantControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITParticipantControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITParticipantControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITParticipantControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITParticipantControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITParticipantControl_EnumerateParticipants(This,ppEnumParticipants)	\
    (This)->lpVtbl -> EnumerateParticipants(This,ppEnumParticipants)

#define ITParticipantControl_get_Participants(This,pVariant)	\
    (This)->lpVtbl -> get_Participants(This,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITParticipantControl_EnumerateParticipants_Proxy( 
    ITParticipantControl * This,
    /* [retval][out] */ IEnumParticipant **ppEnumParticipants);


void __RPC_STUB ITParticipantControl_EnumerateParticipants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITParticipantControl_get_Participants_Proxy( 
    ITParticipantControl * This,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB ITParticipantControl_get_Participants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITParticipantControl_INTERFACE_DEFINED__ */


#ifndef __ITParticipantSubStreamControl_INTERFACE_DEFINED__
#define __ITParticipantSubStreamControl_INTERFACE_DEFINED__

/* interface ITParticipantSubStreamControl */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITParticipantSubStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2c679108-5a35-11d2-95a0-00a0244d2298")
    ITParticipantSubStreamControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubStreamFromParticipant( 
            /* [in] */ ITParticipant *pParticipant,
            /* [retval][out] */ ITSubStream **ppITSubStream) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ParticipantFromSubStream( 
            /* [in] */ ITSubStream *pITSubStream,
            /* [retval][out] */ ITParticipant **ppParticipant) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SwitchTerminalToSubStream( 
            /* [in] */ ITTerminal *pITTerminal,
            /* [in] */ ITSubStream *pITSubStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITParticipantSubStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITParticipantSubStreamControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITParticipantSubStreamControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITParticipantSubStreamControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITParticipantSubStreamControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITParticipantSubStreamControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITParticipantSubStreamControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITParticipantSubStreamControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubStreamFromParticipant )( 
            ITParticipantSubStreamControl * This,
            /* [in] */ ITParticipant *pParticipant,
            /* [retval][out] */ ITSubStream **ppITSubStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParticipantFromSubStream )( 
            ITParticipantSubStreamControl * This,
            /* [in] */ ITSubStream *pITSubStream,
            /* [retval][out] */ ITParticipant **ppParticipant);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SwitchTerminalToSubStream )( 
            ITParticipantSubStreamControl * This,
            /* [in] */ ITTerminal *pITTerminal,
            /* [in] */ ITSubStream *pITSubStream);
        
        END_INTERFACE
    } ITParticipantSubStreamControlVtbl;

    interface ITParticipantSubStreamControl
    {
        CONST_VTBL struct ITParticipantSubStreamControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITParticipantSubStreamControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITParticipantSubStreamControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITParticipantSubStreamControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITParticipantSubStreamControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITParticipantSubStreamControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITParticipantSubStreamControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITParticipantSubStreamControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITParticipantSubStreamControl_get_SubStreamFromParticipant(This,pParticipant,ppITSubStream)	\
    (This)->lpVtbl -> get_SubStreamFromParticipant(This,pParticipant,ppITSubStream)

#define ITParticipantSubStreamControl_get_ParticipantFromSubStream(This,pITSubStream,ppParticipant)	\
    (This)->lpVtbl -> get_ParticipantFromSubStream(This,pITSubStream,ppParticipant)

#define ITParticipantSubStreamControl_SwitchTerminalToSubStream(This,pITTerminal,pITSubStream)	\
    (This)->lpVtbl -> SwitchTerminalToSubStream(This,pITTerminal,pITSubStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITParticipantSubStreamControl_get_SubStreamFromParticipant_Proxy( 
    ITParticipantSubStreamControl * This,
    /* [in] */ ITParticipant *pParticipant,
    /* [retval][out] */ ITSubStream **ppITSubStream);


void __RPC_STUB ITParticipantSubStreamControl_get_SubStreamFromParticipant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITParticipantSubStreamControl_get_ParticipantFromSubStream_Proxy( 
    ITParticipantSubStreamControl * This,
    /* [in] */ ITSubStream *pITSubStream,
    /* [retval][out] */ ITParticipant **ppParticipant);


void __RPC_STUB ITParticipantSubStreamControl_get_ParticipantFromSubStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITParticipantSubStreamControl_SwitchTerminalToSubStream_Proxy( 
    ITParticipantSubStreamControl * This,
    /* [in] */ ITTerminal *pITTerminal,
    /* [in] */ ITSubStream *pITSubStream);


void __RPC_STUB ITParticipantSubStreamControl_SwitchTerminalToSubStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITParticipantSubStreamControl_INTERFACE_DEFINED__ */


#ifndef __ITParticipantEvent_INTERFACE_DEFINED__
#define __ITParticipantEvent_INTERFACE_DEFINED__

/* interface ITParticipantEvent */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITParticipantEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8bb35070-2dad-11d3-a580-00c04f8ef6e3")
    ITParticipantEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ PARTICIPANT_EVENT *pParticipantEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Participant( 
            /* [retval][out] */ ITParticipant **ppParticipant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubStream( 
            /* [retval][out] */ ITSubStream **ppSubStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITParticipantEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITParticipantEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITParticipantEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITParticipantEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITParticipantEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITParticipantEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITParticipantEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITParticipantEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITParticipantEvent * This,
            /* [retval][out] */ PARTICIPANT_EVENT *pParticipantEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Participant )( 
            ITParticipantEvent * This,
            /* [retval][out] */ ITParticipant **ppParticipant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubStream )( 
            ITParticipantEvent * This,
            /* [retval][out] */ ITSubStream **ppSubStream);
        
        END_INTERFACE
    } ITParticipantEventVtbl;

    interface ITParticipantEvent
    {
        CONST_VTBL struct ITParticipantEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITParticipantEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITParticipantEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITParticipantEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITParticipantEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITParticipantEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITParticipantEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITParticipantEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITParticipantEvent_get_Event(This,pParticipantEvent)	\
    (This)->lpVtbl -> get_Event(This,pParticipantEvent)

#define ITParticipantEvent_get_Participant(This,ppParticipant)	\
    (This)->lpVtbl -> get_Participant(This,ppParticipant)

#define ITParticipantEvent_get_SubStream(This,ppSubStream)	\
    (This)->lpVtbl -> get_SubStream(This,ppSubStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITParticipantEvent_get_Event_Proxy( 
    ITParticipantEvent * This,
    /* [retval][out] */ PARTICIPANT_EVENT *pParticipantEvent);


void __RPC_STUB ITParticipantEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITParticipantEvent_get_Participant_Proxy( 
    ITParticipantEvent * This,
    /* [retval][out] */ ITParticipant **ppParticipant);


void __RPC_STUB ITParticipantEvent_get_Participant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITParticipantEvent_get_SubStream_Proxy( 
    ITParticipantEvent * This,
    /* [retval][out] */ ITSubStream **ppSubStream);


void __RPC_STUB ITParticipantEvent_get_SubStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITParticipantEvent_INTERFACE_DEFINED__ */


#ifndef __IMulticastControl_INTERFACE_DEFINED__
#define __IMulticastControl_INTERFACE_DEFINED__

/* interface IMulticastControl */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IMulticastControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("410fa507-4dc6-415a-9014-633875d5406e")
    IMulticastControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoopbackMode( 
            /* [retval][out] */ MULTICAST_LOOPBACK_MODE *pMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoopbackMode( 
            /* [in] */ MULTICAST_LOOPBACK_MODE mode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMulticastControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMulticastControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMulticastControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMulticastControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMulticastControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMulticastControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMulticastControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMulticastControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoopbackMode )( 
            IMulticastControl * This,
            /* [retval][out] */ MULTICAST_LOOPBACK_MODE *pMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoopbackMode )( 
            IMulticastControl * This,
            /* [in] */ MULTICAST_LOOPBACK_MODE mode);
        
        END_INTERFACE
    } IMulticastControlVtbl;

    interface IMulticastControl
    {
        CONST_VTBL struct IMulticastControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMulticastControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMulticastControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMulticastControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMulticastControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMulticastControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMulticastControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMulticastControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMulticastControl_get_LoopbackMode(This,pMode)	\
    (This)->lpVtbl -> get_LoopbackMode(This,pMode)

#define IMulticastControl_put_LoopbackMode(This,mode)	\
    (This)->lpVtbl -> put_LoopbackMode(This,mode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMulticastControl_get_LoopbackMode_Proxy( 
    IMulticastControl * This,
    /* [retval][out] */ MULTICAST_LOOPBACK_MODE *pMode);


void __RPC_STUB IMulticastControl_get_LoopbackMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMulticastControl_put_LoopbackMode_Proxy( 
    IMulticastControl * This,
    /* [in] */ MULTICAST_LOOPBACK_MODE mode);


void __RPC_STUB IMulticastControl_put_LoopbackMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMulticastControl_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _MAC

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _MAC */

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convdll.h ===
// --convdll.h------------------------------------------------------------------
// 
// Defines the DLL access class
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#if !defined(_CONVDLL_H)
#define _CONVDLL_H

//$$--CEDKConvDll---------------------------------------------------------------
//
//  DESCRIPTION: class that manages loading DLLs.
//
// ---------------------------------------------------------------------------
class CEDKConvDll
{
public:
    CEDKConvDll(
        IN CDllEntryPoint * pep, 
        IN HANDLE hEventSource) ;
    ~CEDKConvDll() ;

    HRESULT HrEDKLoad() ;
    HRESULT HrEDKUnLoad() ;

    HRESULT HrEDKQueryCapability(
        IN PEDKCNVENV pEnv,
        IN LPCWSTR pszContentClass,
        IN PVOID pContent,
        OUT BOOL &bAmCandidate) ;

    HRESULT HrEDKConvert(
        IN PEDKCNVENV pEnv,
        IN LPCWSTR pszContentClass,
        IN PVOID pContentIn,
        OUT PVOID pContentOut,
        OUT EDKCNVRES & crResult) ;

protected:
    CDllEntryPoint * m_pepEntry ;       // DLL and entry pont.
    
	HINSTANCE m_hDll ;                     // DLL handle.

    PCONVDLLVECT m_pDllVector ;         // Vector.
	HANDLE m_hEventSource ;
} ; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\comutil.h ===
/***
* comutil.h - Native C++ compiler COM support - BSTR, VARIANT wrappers header
*
*	Copyright (C) 1996-1997 Microsoft Corporation
*	All rights reserved.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_COMUTIL)
#define _INC_COMUTIL

#include <ole2.h>

#pragma warning(push)
#pragma warning(disable:4290)
#pragma warning(disable:4310)

class _com_error;

void __stdcall _com_issue_error(HRESULT);

//////////////////////////////////////////////////////////////////////////////
//
// Forward class declarations
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t;
class _variant_t;

//////////////////////////////////////////////////////////////////////////////
//
// Error checking routines
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
	inline void CheckError(HRESULT hr) throw(_com_error)
	{
		if (FAILED(hr)) {
			_com_issue_error(hr);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Routines for handling conversions between BSTR and char*
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
	// Convert char * to BSTR
	//
	BSTR __stdcall ConvertStringToBSTR(const char* pSrc) throw(_com_error);

	// Convert BSTR to char *
	//
	char* __stdcall ConvertBSTRToString(BSTR pSrc) throw(_com_error);
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for BSTR
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t {
public:
	// Constructors
	//
	_bstr_t() throw();
	_bstr_t(const _bstr_t& s) throw();
	_bstr_t(const char* s) throw(_com_error);
	_bstr_t(const wchar_t* s) throw(_com_error);
	_bstr_t(const _variant_t& var) throw(_com_error);
	_bstr_t(BSTR bstr, bool fCopy) throw(_com_error);

	// Destructor
	//
	~_bstr_t() throw();

	// Assignment operators
	//
	_bstr_t& operator=(const _bstr_t& s) throw();
	_bstr_t& operator=(const char* s) throw(_com_error);
	_bstr_t& operator=(const wchar_t* s) throw(_com_error);
	_bstr_t& operator=(const _variant_t& var) throw(_com_error);

	// Operators
	//
	_bstr_t& operator+=(const _bstr_t& s) throw(_com_error);
	_bstr_t operator+(const _bstr_t& s) const throw(_com_error);

	// Friend operators
	//
	friend _bstr_t operator+(const char* s1, const _bstr_t& s2) throw(_com_error);
	friend _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) throw(_com_error);

	// Extractors
	//
	operator const wchar_t*() const throw();
	operator wchar_t*() const throw();
	operator const char*() const throw(_com_error);
	operator char*() const throw(_com_error);

	// Comparison operators
	//
	bool operator!() const throw();
	bool operator==(const _bstr_t& str) const throw();
	bool operator!=(const _bstr_t& str) const throw();
	bool operator<(const _bstr_t& str) const throw();
	bool operator>(const _bstr_t& str) const throw();
	bool operator<=(const _bstr_t& str) const throw();
	bool operator>=(const _bstr_t& str) const throw();

	// Low-level helper functions
	//
	BSTR copy() const throw(_com_error);
	unsigned int length() const throw();

	// Binary string assign
	//
	void Assign(BSTR s) throw(_com_error);

private:
	// Referenced counted wrapper
	//
	class Data_t {
	public:
		// Constructors
		//
		Data_t(const char* s) throw(_com_error);
		Data_t(const wchar_t* s) throw(_com_error);
		Data_t(BSTR bstr, bool fCopy) throw(_com_error);
		Data_t(const _bstr_t& s1, const _bstr_t& s2) throw(_com_error);

		// Reference counting routines
		//
		unsigned long AddRef() throw();
		unsigned long Release() throw();

		// Extractors
		//
		operator const wchar_t*() const throw();
		operator const char*() const throw(_com_error);

		// Low-level helper functions
		//
		const wchar_t* GetWString() const throw();
		const char* GetString() const throw(_com_error);

		BSTR Copy() const throw(_com_error);
		void Assign(BSTR s) throw(_com_error);
		unsigned int Length() const throw();
		int Compare(const Data_t& str) const throw();

	private:
		wchar_t*		m_wstr;
		mutable char*	m_str;
		unsigned long	m_RefCount;

		// Never allow default construction
		//
		Data_t() throw();

		// Never allow copy
		//
		Data_t(const Data_t& s) throw();

		// Prevent deletes from outside. Release() must be used.
		//
		~Data_t() throw();

		void _Free() throw();
	};

private:
	// Reference counted representation
	//
	Data_t* m_Data;

private:
	// Low-level utilities
	//
	void _AddRef() throw();
	void _Free() throw();
	int _Compare(const _bstr_t& str) const throw();
};

//////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _bstr_t::_bstr_t() throw()
	: m_Data(NULL)
{
}

// Copy constructor
//
inline _bstr_t::_bstr_t(const _bstr_t& s) throw()
	: m_Data(s.m_Data)
{
	_AddRef();
}

// Construct a _bstr_t from a const char*
//
inline _bstr_t::_bstr_t(const char* s) throw(_com_error)
	: m_Data(new Data_t(s))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a _bstr_t from a const whar_t*
//
inline _bstr_t::_bstr_t(const wchar_t* s) throw(_com_error)
	: m_Data(new Data_t(s))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a _bstr_t from a BSTR.  If fCopy is FALSE, give control of
// data to the _bstr_t without making a new copy.
//
inline _bstr_t::_bstr_t(BSTR bstr, bool fCopy) throw(_com_error)
	: m_Data(new Data_t(bstr, fCopy))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Destructor
//
inline _bstr_t::~_bstr_t() throw()
{
	_Free();
}

//////////////////////////////////////////////////////////////////////////////
//
// Assignment operators
//
//////////////////////////////////////////////////////////////////////////////

// Default assign operator
//
inline _bstr_t& _bstr_t::operator=(const _bstr_t& s) throw()
{
	const_cast<_bstr_t*>(&s)->_AddRef();
	_Free();
	m_Data = s.m_Data;

	return *this;
}

// Assign a const char* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const char* s) throw(_com_error)
{
	_Free();
	m_Data = new Data_t(s);

	return *this;
}

// Assign a const wchar_t* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const wchar_t* s) throw(_com_error)
{
	_Free();
	m_Data = new Data_t(s);

	return *this;
}

//////////////////////////////////////////////////////////////////////////////
//
// Operators
//
//////////////////////////////////////////////////////////////////////////////

// Concatenate a _bstr_t onto this _bstr_t
//
inline _bstr_t& _bstr_t::operator+=(const _bstr_t& s) throw(_com_error)
{
	Data_t* newData = new Data_t(*this, s);

	_Free();
	m_Data = newData;

	return *this;
}

// Return the concatenation of this _bstr_t with another _bstr_t
//
inline _bstr_t _bstr_t::operator+(const _bstr_t& s) const throw(_com_error)
{
	_bstr_t b = *this;
	b += s;

	return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Friend Operators
//
//////////////////////////////////////////////////////////////////////////////

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const char* s1, const _bstr_t& s2) throw(_com_error)
{
	_bstr_t b = s1; 
	b += s2;

	return b;
}

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) throw(_com_error)
{
	_bstr_t b = s1; 
	b += s2;

	return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::operator const wchar_t*() const throw()
{
	return (m_Data != NULL) ? m_Data->GetWString() : NULL;
}

// Extract a wchar_t*
//
inline _bstr_t::operator wchar_t*() const throw()
{
	return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);
}

// Extract a const char_t*
//
inline _bstr_t::operator const char*() const throw(_com_error)
{
	return (m_Data != NULL) ? m_Data->GetString() : NULL;
}

// Extract a char_t*
//
inline _bstr_t::operator char*() const throw(_com_error)
{
	return const_cast<char*>((m_Data != NULL) ? m_Data->GetString() : NULL);
}

//////////////////////////////////////////////////////////////////////////////
//
// Comparison operators
//
//////////////////////////////////////////////////////////////////////////////

inline bool _bstr_t::operator!() const throw()
{
	return (m_Data != NULL) ? !m_Data->GetWString() : true;
}

inline bool _bstr_t::operator==(const _bstr_t& str) const throw()
{
	return _Compare(str) == 0;
}

inline bool _bstr_t::operator!=(const _bstr_t& str) const throw()
{
	return _Compare(str) != 0;
}

inline bool _bstr_t::operator<(const _bstr_t& str) const throw()
{
	return _Compare(str) < 0;
}

inline bool _bstr_t::operator>(const _bstr_t& str) const throw()
{
	return _Compare(str) > 0;
}

inline bool _bstr_t::operator<=(const _bstr_t& str) const throw()
{
	return _Compare(str) <= 0;
}

inline bool _bstr_t::operator>=(const _bstr_t& str) const throw()
{
	return _Compare(str) >= 0;
}

//////////////////////////////////////////////////////////////////////////////
//
// Low-level help functions
//
//////////////////////////////////////////////////////////////////////////////

// Extract a copy of the wrapped BSTR
//
inline BSTR _bstr_t::copy() const throw(_com_error)
{
	return (m_Data != NULL) ? m_Data->Copy() : NULL;
}

// Return the length of the wrapped BSTR
//
inline unsigned int _bstr_t::length() const throw()
{
	return (m_Data != NULL) ? m_Data->Length() : 0;
}

// Binary string assign
//
inline void _bstr_t::Assign(BSTR s) throw(_com_error)
{
	if (m_Data != NULL) {
		m_Data->Assign(s); 
	} 
	else {
		m_Data = new Data_t(s, TRUE);
		if (m_Data == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}
}

// AddRef the BSTR
//
inline void _bstr_t::_AddRef() throw()
{
	if (m_Data != NULL) {
		m_Data->AddRef();
	}
}

// Free the BSTR
//
inline void _bstr_t::_Free() throw()
{
	if (m_Data != NULL) {
		m_Data->Release();
		m_Data = NULL;
	}
}

// Compare two _bstr_t objects
//
inline int _bstr_t::_Compare(const _bstr_t& str) const throw()
{
	if (m_Data == str.m_Data) {
		return 0;
	}

	if (m_Data == NULL) {
		return -1;
	}

	if (str.m_Data == NULL) {
		return 1;
	}

	return m_Data->Compare(*str.m_Data);
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Construct a Data_t from a const char*
//
inline _bstr_t::Data_t::Data_t(const char* s) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	m_wstr = _com_util::ConvertStringToBSTR(s);

	if (m_wstr == NULL && s != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a Data_t from a const wchar_t*
//
inline _bstr_t::Data_t::Data_t(const wchar_t* s) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	m_wstr = ::SysAllocString(s);

	if (m_wstr == NULL && s != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a Data_t from a BSTR.  If fCopy is FALSE, give control of
// data to the Data_t without doing a SysAllocStringByteLen.
//
inline _bstr_t::Data_t::Data_t(BSTR bstr, bool fCopy) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	if (fCopy && bstr != NULL) {
		m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
										 ::SysStringByteLen(bstr));

		if (m_wstr == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}
	else {
		m_wstr = bstr;
	}
}

// Construct a Data_t from the concatenation of two _bstr_t objects
//
inline _bstr_t::Data_t::Data_t(const _bstr_t& s1, const _bstr_t& s2) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	const unsigned int l1 = s1.length();
	const unsigned int l2 = s2.length();

	m_wstr = ::SysAllocStringByteLen(NULL, (l1 + l2) * sizeof(wchar_t));

	if (m_wstr == NULL) {
		if (l1 + l2 == 0) {
			return;
		}
		_com_issue_error(E_OUTOFMEMORY);
	}

	const wchar_t* wstr1 = static_cast<const wchar_t*>(s1);

	if (wstr1 != NULL) {
		memcpy(m_wstr, wstr1, (l1 + 1) * sizeof(wchar_t));
	}

	const wchar_t* wstr2 = static_cast<const wchar_t*>(s2);

	if (wstr2 != NULL) {
		memcpy(m_wstr + l1, wstr2, (l2 + 1) * sizeof(wchar_t));
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - reference counting routines
//
//////////////////////////////////////////////////////////////////////////////

inline unsigned long _bstr_t::Data_t::AddRef() throw()
{
	InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));
	return m_RefCount;
}

inline unsigned long _bstr_t::Data_t::Release() throw()
{
	if (!InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount))) {
		delete this;
		return 0;
	}

	return m_RefCount;
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::Data_t::operator const wchar_t*() const throw()
{
	return m_wstr;
}

// Extract a const char_t*
//
inline _bstr_t::Data_t::operator const char*() const throw(_com_error)
{
	return GetString();
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - helper functions
//
//////////////////////////////////////////////////////////////////////////////

inline const wchar_t* _bstr_t::Data_t::GetWString() const throw()
{
	return m_wstr;
}

inline const char* _bstr_t::Data_t::GetString() const throw(_com_error)
{
	if (m_str == NULL) {
		m_str = _com_util::ConvertBSTRToString(m_wstr);

		if (m_str == NULL && m_wstr != NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return m_str;
}

// Return a copy of the wrapped BSTR
//
inline BSTR _bstr_t::Data_t::Copy() const throw(_com_error)
{
	if (m_wstr != NULL) {
		BSTR bstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(m_wstr),
											::SysStringByteLen(m_wstr));

		if (bstr == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}

		return bstr;
	}

	return NULL;
}

inline void _bstr_t::Data_t::Assign(BSTR s) throw(_com_error)
{
	_Free();
	if (s != NULL) {
		m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(s), 
											::SysStringByteLen(s));
	}
}

// Return the length of the wrapper BSTR
//
inline unsigned int _bstr_t::Data_t::Length() const throw()
{
	return m_wstr ? ::SysStringLen(m_wstr) : 0;
}

// Compare two wrapped BSTRs
//
inline int _bstr_t::Data_t::Compare(const _bstr_t::Data_t& str) const throw()
{
	if (m_wstr == NULL) {
		return str.m_wstr ? -1 : 0;
	}

	if (str.m_wstr == NULL) {
		return 1;
	}

	const unsigned int l1 = ::SysStringLen(m_wstr);
	const unsigned int l2 = ::SysStringLen(str.m_wstr);

	unsigned int len = l1;
	if (len > l2) {
		len = l2;
	}

	BSTR bstr1 = m_wstr;
	BSTR bstr2 = str.m_wstr;

	while (len-- > 0) {
		if (*bstr1++ != *bstr2++) {
			return bstr1[-1] - bstr2[-1];
		}
	}

	return (l1 < l2) ? -1 : (l1 == l2) ? 0 : 1;
}

// Destruct this object
//
inline _bstr_t::Data_t::~Data_t() throw()
{
	_Free();
}

// Free up this object
//
inline void _bstr_t::Data_t::_Free() throw()
{
	if (m_wstr != NULL) {
		::SysFreeString(m_wstr);
	}

	if (m_str != NULL) {
		delete [] m_str;
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for VARIANT
//
//////////////////////////////////////////////////////////////////////////////

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 * * [C] - supported by class _variant_t
 *
 *
 *  VT_EMPTY            [V]   [P]        nothing
 *  VT_NULL             [V]   [P]        SQL style Null
 *  VT_I2               [V][T][P][S][C]  2 byte signed int
 *  VT_I4               [V][T][P][S][C]  4 byte signed int
 *  VT_R4               [V][T][P][S][C]  4 byte real
 *  VT_R8               [V][T][P][S][C]  8 byte real
 *  VT_CY               [V][T][P][S][C]  currency
 *  VT_DATE             [V][T][P][S][C]  date
 *  VT_BSTR             [V][T][P][S][C]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S][C]  IDispatch *
 *  VT_ERROR            [V][T]   [S][C]  SCODE
 *  VT_BOOL             [V][T][P][S][C]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]     VARIANT *
 *  VT_UNKNOWN          [V][T]   [S][C]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S][C]  16 byte fixed point
 *  VT_I1                  [T]           signed char
 *  VT_UI1              [V][T][P][S][C]  unsigned char
 *  VT_UI2                 [T][P]        unsigned short
 *  VT_UI4                 [T][P]        unsigned short
 *  VT_I8                  [T][P]        signed 64-bit int
 *  VT_UI8                 [T][P]        unsigned 64-bit int
 *  VT_INT                 [T]           signed machine int
 *  VT_UINT                [T]           unsigned machine int
 *  VT_VOID                [T]           C style void
 *  VT_HRESULT             [T]           Standard return type
 *  VT_PTR                 [T]           pointer type
 *  VT_SAFEARRAY           [T]          (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]           C style array
 *  VT_USERDEFINED         [T]           user defined type
 *  VT_LPSTR               [T][P]        null terminated string
 *  VT_LPWSTR              [T][P]        wide null terminated string
 *  VT_FILETIME               [P]        FILETIME
 *  VT_BLOB                   [P]        Length prefixed bytes
 *  VT_STREAM                 [P]        Name of the stream follows
 *  VT_STORAGE                [P]        Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]        Stream contains an object
 *  VT_STORED_OBJECT          [P]        Storage contains an object
 *  VT_BLOB_OBJECT            [P]        Blob contains an object
 *  VT_CF                     [P]        Clipboard format
 *  VT_CLSID                  [P]        A Class ID
 *  VT_VECTOR                 [P]        simple counted array
 *  VT_ARRAY            [V]              SAFEARRAY*
 *  VT_BYREF            [V]              void* for local use
 */

class _variant_t : public ::tagVARIANT {
public:
	// Constructors
	//
	_variant_t() throw();

	_variant_t(const VARIANT& varSrc) throw(_com_error);
	_variant_t(const VARIANT* pSrc) throw(_com_error);
	_variant_t(const _variant_t& varSrc) throw(_com_error);

	_variant_t(VARIANT& varSrc, bool fCopy) throw(_com_error);			// Attach VARIANT if !fCopy

	_variant_t(short sSrc, VARTYPE vtSrc = VT_I2) throw(_com_error);	// Creates a VT_I2, or a VT_BOOL
	_variant_t(long lSrc, VARTYPE vtSrc = VT_I4) throw(_com_error);		// Creates a VT_I4, a VT_ERROR, or a VT_BOOL
	_variant_t(float fltSrc) throw();									// Creates a VT_R4
	_variant_t(double dblSrc, VARTYPE vtSrc = VT_R8) throw(_com_error);	// Creates a VT_R8, or a VT_DATE
	_variant_t(const CY& cySrc) throw();								// Creates a VT_CY
	_variant_t(const _bstr_t& bstrSrc) throw(_com_error);				// Creates a VT_BSTR
	_variant_t(const wchar_t *pSrc) throw(_com_error);					// Creates a VT_BSTR
	_variant_t(const char* pSrc) throw(_com_error);						// Creates a VT_BSTR
	_variant_t(IDispatch* pSrc, bool fAddRef = true) throw();			// Creates a VT_DISPATCH
	_variant_t(bool bSrc) throw();										// Creates a VT_BOOL
	_variant_t(IUnknown* pSrc, bool fAddRef = true) throw();			// Creates a VT_UNKNOWN
	_variant_t(const DECIMAL& decSrc) throw();							// Creates a VT_DECIMAL
	_variant_t(BYTE bSrc) throw();										// Creates a VT_UI1

	// Destructor
	//
	~_variant_t() throw(_com_error);

	// Extractors
	//
	operator short() const throw(_com_error);			// Extracts a short from a VT_I2
	operator long() const throw(_com_error);			// Extracts a long from a VT_I4
	operator float() const throw(_com_error);			// Extracts a float from a VT_R4
	operator double() const throw(_com_error);			// Extracts a double from a VT_R8
	operator CY() const throw(_com_error);				// Extracts a CY from a VT_CY
	operator _bstr_t() const throw(_com_error);			// Extracts a _bstr_t from a VT_BSTR
	operator IDispatch*() const throw(_com_error);		// Extracts a IDispatch* from a VT_DISPATCH
	operator bool() const throw(_com_error);			// Extracts a bool from a VT_BOOL
	operator IUnknown*() const throw(_com_error);		// Extracts a IUnknown* from a VT_UNKNOWN
	operator DECIMAL() const throw(_com_error);			// Extracts a DECIMAL from a VT_DECIMAL
	operator BYTE() const throw(_com_error);			// Extracts a BTYE (unsigned char) from a VT_UI1
	
	// Assignment operations
	//
	_variant_t& operator=(const VARIANT& varSrc) throw(_com_error);
	_variant_t& operator=(const VARIANT* pSrc) throw(_com_error);
	_variant_t& operator=(const _variant_t& varSrc) throw(_com_error);

	_variant_t& operator=(short sSrc) throw(_com_error);				// Assign a VT_I2, or a VT_BOOL
	_variant_t& operator=(long lSrc) throw(_com_error);					// Assign a VT_I4, a VT_ERROR or a VT_BOOL
	_variant_t& operator=(float fltSrc) throw(_com_error);				// Assign a VT_R4
	_variant_t& operator=(double dblSrc) throw(_com_error);				// Assign a VT_R8, or a VT_DATE
	_variant_t& operator=(const CY& cySrc) throw(_com_error);			// Assign a VT_CY
	_variant_t& operator=(const _bstr_t& bstrSrc) throw(_com_error);	// Assign a VT_BSTR
	_variant_t& operator=(const wchar_t* pSrc) throw(_com_error);		// Assign a VT_BSTR
	_variant_t& operator=(const char* pSrc) throw(_com_error);			// Assign a VT_BSTR
	_variant_t& operator=(IDispatch* pSrc) throw(_com_error);			// Assign a VT_DISPATCH
 	_variant_t& operator=(bool bSrc) throw(_com_error);					// Assign a VT_BOOL
	_variant_t& operator=(IUnknown* pSrc) throw(_com_error);			// Assign a VT_UNKNOWN
	_variant_t& operator=(const DECIMAL& decSrc) throw(_com_error);		// Assign a VT_DECIMAL
	_variant_t& operator=(BYTE bSrc) throw(_com_error);					// Assign a VT_UI1

	// Comparison operations
	//
	bool operator==(const VARIANT& varSrc) const throw(_com_error);
	bool operator==(const VARIANT* pSrc) const throw(_com_error);

	bool operator!=(const VARIANT& varSrc) const throw(_com_error);
	bool operator!=(const VARIANT* pSrc) const throw(_com_error);

	// Low-level operations
	//
	void Clear() throw(_com_error);

	void Attach(VARIANT& varSrc) throw(_com_error);
	VARIANT Detach() throw(_com_error);

	void ChangeType(VARTYPE vartype, const _variant_t* pSrc = NULL) throw(_com_error);

	void SetString(const char* pSrc) throw(_com_error); // used to set ANSI string
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _variant_t::_variant_t() throw()
{
	::VariantInit(this);
}

// Construct a _variant_t from a const VARIANT&
//
inline _variant_t::_variant_t(const VARIANT& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));
}

// Construct a _variant_t from a const VARIANT*
//
inline _variant_t::_variant_t(const VARIANT* pSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));
}

// Construct a _variant_t from a const _variant_t&
//
inline _variant_t::_variant_t(const _variant_t& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));
}

// Construct a _variant_t from a VARIANT&.  If fCopy is FALSE, give control of
// data to the _variant_t without doing a VariantCopy.
//
inline _variant_t::_variant_t(VARIANT& varSrc, bool fCopy) throw(_com_error)
{
	if (fCopy) {
		::VariantInit(this);
		_com_util::CheckError(::VariantCopy(this, &varSrc));
	} else {
		memcpy(this, &varSrc, sizeof(varSrc));
		V_VT(&varSrc) = VT_EMPTY;
	}
}

// Construct either a VT_I2 VARIANT or a VT_BOOL VARIANT from
// a short (the default is VT_I2)
//
inline _variant_t::_variant_t(short sSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I2) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}
}

// Construct either a VT_I4 VARIANT, a VT_BOOL VARIANT, or a
// VT_ERROR VARIANT from a long (the default is VT_I4)
//
inline _variant_t::_variant_t(long lSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I4) && (vtSrc != VT_ERROR) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_ERROR) {
		V_VT(this) = VT_ERROR;
		V_ERROR(this) = lSrc;
	}
	else if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}
}

// Construct a VT_R4 VARIANT from a float
//
inline _variant_t::_variant_t(float fltSrc) throw()
{
	V_VT(this) = VT_R4;
	V_R4(this) = fltSrc;
}

// Construct either a VT_R8 VARIANT, or a VT_DATE VARIANT from
// a double (the default is VT_R8)
//
inline _variant_t::_variant_t(double dblSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_R8) && (vtSrc != VT_DATE)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_DATE) {
		V_VT(this) = VT_DATE;
		V_DATE(this) = dblSrc;
	}
	else {
		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}
}

// Construct a VT_CY from a CY
//
inline _variant_t::_variant_t(const CY& cySrc) throw()
{
	V_VT(this) = VT_CY;
	V_CY(this) = cySrc;
}

// Construct a VT_BSTR VARIANT from a const _bstr_t&
//
inline _variant_t::_variant_t(const _bstr_t& bstrSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;

	BSTR bstr = static_cast<wchar_t*>(bstrSrc);
	V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
										   ::SysStringByteLen(bstr));

	if (V_BSTR(this) == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_BSTR VARIANT from a const wchar_t*
//
inline _variant_t::_variant_t(const wchar_t* pSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;
	V_BSTR(this) = ::SysAllocString(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_BSTR VARIANT from a const char*
//
inline _variant_t::_variant_t(const char* pSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_DISPATCH VARIANT from an IDispatch*
//
inline _variant_t::_variant_t(IDispatch* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_DISPATCH(this)->AddRef();
	}
}

// Construct a VT_BOOL VARIANT from a bool
//
inline _variant_t::_variant_t(bool bSrc) throw()
{
	V_VT(this) = VT_BOOL;
	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);
}

// Construct a VT_UNKNOWN VARIANT from an IUnknown*
//
inline _variant_t::_variant_t(IUnknown* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_UNKNOWN(this)->AddRef();
	}
}

// Construct a VT_DECIMAL VARIANT from a DECIMAL
//
inline _variant_t::_variant_t(const DECIMAL& decSrc) throw()
{
	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	//
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;
}

// Construct a VT_UI1 VARIANT from a BYTE (unsigned char)
//
inline _variant_t::_variant_t(BYTE bSrc) throw()
{
	V_VT(this) = VT_UI1;
	V_UI1(this) = bSrc;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Extracts a VT_I2 into a short
//
inline _variant_t::operator short() const throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		return V_I2(this); 
	}

	_variant_t varDest;

	varDest.ChangeType(VT_I2, this);

	return V_I2(&varDest);
}

// Extracts a VT_I4 into a long
//
inline _variant_t::operator long() const throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		return V_I4(this); 
	}

	_variant_t varDest;

	varDest.ChangeType(VT_I4, this);

	return V_I4(&varDest);
}

// Extracts a VT_R4 into a float
//
inline _variant_t::operator float() const throw(_com_error)
{
	if (V_VT(this) == VT_R4) {
		return V_R4(this); 
	}

	_variant_t varDest;

	varDest.ChangeType(VT_R4, this);

	return V_R4(&varDest);
}

// Extracts a VT_R8 into a double
//
inline _variant_t::operator double() const throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		return V_R8(this); 
	}

	_variant_t varDest;

	varDest.ChangeType(VT_R8, this);

	return V_R8(&varDest);
}

// Extracts a VT_CY into a CY
//
inline _variant_t::operator CY() const throw(_com_error)
{
	if (V_VT(this) == VT_CY) {
		return V_CY(this); 
	}

	_variant_t varDest;

	varDest.ChangeType(VT_CY, this);

	return V_CY(&varDest);
}

// Extracts a VT_BSTR into a _bstr_t
//
inline _variant_t::operator _bstr_t() const throw(_com_error)
{
	if (V_VT(this) == VT_BSTR) {
		return V_BSTR(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, this);

	return V_BSTR(&varDest);
}

// Extracts a VT_DISPATCH into an IDispatch*
//
inline _variant_t::operator IDispatch*() const throw(_com_error)
{
	if (V_VT(this) == VT_DISPATCH) {
		V_DISPATCH(this)->AddRef();
		return V_DISPATCH(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_DISPATCH, this);

	V_DISPATCH(&varDest)->AddRef();
	return V_DISPATCH(&varDest);
}

// Extract a VT_BOOL into a bool
//
inline _variant_t::operator bool() const throw(_com_error)
{
	if (V_VT(this) == VT_BOOL) {
		return V_BOOL(this) ? true : false;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BOOL, this);

	return V_BOOL(&varDest) ? true : false;
}

// Extracts a VT_UNKNOWN into an IUnknown*
//
inline _variant_t::operator IUnknown*() const throw(_com_error)
{
	if (V_VT(this) == VT_UNKNOWN) {
		V_UNKNOWN(this)->AddRef();
		return V_UNKNOWN(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_UNKNOWN, this);

	V_UNKNOWN(&varDest)->AddRef();
	return V_UNKNOWN(&varDest);
}

// Extracts a VT_DECIMAL into a DECIMAL
//
inline _variant_t::operator DECIMAL() const throw(_com_error)
{
	if (V_VT(this) == VT_DECIMAL) {
		return V_DECIMAL(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_DECIMAL, this);

	return V_DECIMAL(&varDest);
}

// Extracts a VT_UI1 into a BYTE (unsigned char)
//
inline _variant_t::operator BYTE() const throw(_com_error)
{
	if (V_VT(this) == VT_UI1) {
		return V_UI1(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_UI1, this);

	return V_UI1(&varDest);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Assignment operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Assign a const VARIANT& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT& varSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));

	return *this;
}

// Assign a const VARIANT* (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT* pSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));

	return *this;
}

// Assign a const _variant_t& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const _variant_t& varSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));

	return *this;
}

// Assign a short creating either VT_I2 VARIANT or a 
// VT_BOOL VARIANT (VT_I2 is the default)
//
inline _variant_t& _variant_t::operator=(short sSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		V_I2(this) = sSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I2
		//
		Clear();

		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}

	return *this;
}

// Assign a long creating either VT_I4 VARIANT, a VT_ERROR VARIANT
// or a VT_BOOL VARIANT (VT_I4 is the default)
//
inline _variant_t& _variant_t::operator=(long lSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		V_I4(this) = lSrc;
	}
	else if (V_VT(this) == VT_ERROR) {
		V_ERROR(this) = lSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I4
		//
		Clear();

		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}

	return *this;
}

// Assign a float creating a VT_R4 VARIANT 
//
inline _variant_t& _variant_t::operator=(float fltSrc) throw(_com_error)
{
	if (V_VT(this) != VT_R4) {
		// Clear the VARIANT and create a VT_R4
		//
		Clear();

		V_VT(this) = VT_R4;
	}

	V_R4(this) = fltSrc;

	return *this;
}

// Assign a double creating either a VT_R8 VARIANT, or a VT_DATE
// VARIANT (VT_R8 is the default)
//
inline _variant_t& _variant_t::operator=(double dblSrc) throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		V_R8(this) = dblSrc;
	}
	else if(V_VT(this) == VT_DATE) {
		V_DATE(this) = dblSrc;
	}
	else {
		// Clear the VARIANT and create a VT_R8
		//
		Clear();

		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}

	return *this;
}

// Assign a CY creating a VT_CY VARIANT 
//
inline _variant_t& _variant_t::operator=(const CY& cySrc) throw(_com_error)
{
	if (V_VT(this) != VT_CY) {
		// Clear the VARIANT and create a VT_CY
		//
		Clear();

		V_VT(this) = VT_CY;
	}

	V_CY(this) = cySrc;

	return *this;
}

// Assign a const _bstr_t& creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const _bstr_t& bstrSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;

	if (!bstrSrc) {
		V_BSTR(this) = NULL;
	}
	else {
		BSTR bstr = static_cast<wchar_t*>(bstrSrc);
		V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
											   ::SysStringByteLen(bstr));

		if (V_BSTR(this) == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return *this;
}

// Assign a const wchar_t* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const wchar_t* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;

	if (pSrc == NULL) {
		V_BSTR(this) = NULL;
	}
	else {
		V_BSTR(this) = ::SysAllocString(pSrc);

		if (V_BSTR(this) == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return *this;
}

// Assign a const char* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const char* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}

	return *this;
}

// Assign an IDispatch* creating a VT_DISPATCH VARIANT 
//
inline _variant_t& _variant_t::operator=(IDispatch* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_DISPATCH(this)->AddRef();

	return *this;
}

// Assign a bool creating a VT_BOOL VARIANT 
//
inline _variant_t& _variant_t::operator=(bool bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_BOOL) {
		// Clear the VARIANT and create a VT_BOOL
		//
		Clear();

		V_VT(this) = VT_BOOL;
	}

	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);

	return *this;
}

// Assign an IUnknown* creating a VT_UNKNOWN VARIANT 
//
inline _variant_t& _variant_t::operator=(IUnknown* pSrc) throw(_com_error)
{
	// Clear VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_UNKNOWN(this)->AddRef();

	return *this;
}

// Assign a DECIMAL creating a VT_DECIMAL VARIANT
//
inline _variant_t& _variant_t::operator=(const DECIMAL& decSrc) throw(_com_error)
{
	if (V_VT(this) != VT_DECIMAL) {
		// Clear the VARIANT
		//
		Clear();
	}

	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;

	return *this;
}

// Assign a BTYE (unsigned char) creating a VT_UI1 VARIANT
//
inline _variant_t& _variant_t::operator=(BYTE bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_UI1) {
		// Clear the VARIANT and create a VT_UI1
		//
		Clear();

		V_VT(this) = VT_UI1;
	}

	V_UI1(this) = bSrc;

	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Comparison operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Compare a _variant_t against a const VARIANT& for equality
//
inline bool _variant_t::operator==(const VARIANT& varSrc) const throw()
{
	return *this == &varSrc;
}

// Compare a _variant_t against a const VARIANT* for equality
//
inline bool _variant_t::operator==(const VARIANT* pSrc) const throw()
{
	if (this == pSrc) {
		return true;
	}

	//
	// Variants not equal if types don't match
	//
	if (V_VT(this) != V_VT(pSrc)) {
		return false;
	}

	//
	// Check type specific values
	//
	switch (V_VT(this)) {
		case VT_EMPTY:
		case VT_NULL:
			return true;

		case VT_I2:
			return V_I2(this) == V_I2(pSrc);

		case VT_I4:
			return V_I4(this) == V_I4(pSrc);

		case VT_R4:
			return V_R4(this) == V_R4(pSrc);

		case VT_R8:
			return V_R8(this) == V_R8(pSrc);

		case VT_CY:
			return memcmp(&(V_CY(this)), &(V_CY(pSrc)), sizeof(CY)) == 0;

		case VT_DATE:
			return V_DATE(this) == V_DATE(pSrc);

		case VT_BSTR:
			return (::SysStringByteLen(V_BSTR(this)) == ::SysStringByteLen(V_BSTR(pSrc))) &&
					(memcmp(V_BSTR(this), V_BSTR(pSrc), ::SysStringByteLen(V_BSTR(this))) == 0);

		case VT_DISPATCH:
			return V_DISPATCH(this) == V_DISPATCH(pSrc);

		case VT_ERROR:
			return V_ERROR(this) == V_ERROR(pSrc);

		case VT_BOOL:
			return V_BOOL(this) == V_BOOL(pSrc);

		case VT_UNKNOWN:
			return V_UNKNOWN(this) == V_UNKNOWN(pSrc);

		case VT_DECIMAL:
			return memcmp(&(V_DECIMAL(this)), &(V_DECIMAL(pSrc)), sizeof(DECIMAL)) == 0;

		case VT_UI1:
			return V_UI1(this) == V_UI1(pSrc);

		default:
			_com_issue_error(E_INVALIDARG);
			// fall through
	}

	return false;
}

// Compare a _variant_t against a const VARIANT& for in-equality
//
inline bool _variant_t::operator!=(const VARIANT& varSrc) const throw()
{
	return !(*this == &varSrc);
}

// Compare a _variant_t against a const VARIANT* for in-equality
//
inline bool _variant_t::operator!=(const VARIANT* pSrc) const throw()
{
	return !(*this == pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Low-level operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Clear the _variant_t
//
inline void _variant_t::Clear() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}

inline void _variant_t::Attach(VARIANT& varSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	//
	// Give control of data to _variant_t
	//
	memcpy(this, &varSrc, sizeof(varSrc));
	V_VT(&varSrc) = VT_EMPTY;
}

inline VARIANT _variant_t::Detach() throw(_com_error)
{
	VARIANT varResult = *this;
	V_VT(this) = VT_EMPTY;

	return varResult;
}

// Change the type and contents of this _variant_t to the type vartype and
// contents of pSrc
//
inline void _variant_t::ChangeType(VARTYPE vartype, const _variant_t* pSrc) throw(_com_error)
{
	//
	// If pDest is NULL, convert type in place
	//
	if (pSrc == NULL) {
		pSrc = this;
	}

	if ((this != pSrc) || (vartype != V_VT(this))) {
		_com_util::CheckError(::VariantChangeType(static_cast<VARIANT*>(this),
												  const_cast<VARIANT*>(static_cast<const VARIANT*>(pSrc)),
												  0, vartype));
	}
}

inline void _variant_t::SetString(const char* pSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////////////////

inline _variant_t::~_variant_t() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Mutually-dependent definitions
//
//////////////////////////////////////////////////////////////////////////////////////////

// Construct a _bstr_t from a const _variant_t&
//
inline _bstr_t::_bstr_t(const _variant_t &var) throw(_com_error)
	: m_Data(NULL)
{
	if (V_VT(&var) == VT_BSTR) {
		*this = V_BSTR(&var);
		return;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, &var);

	*this = V_BSTR(&varDest);
}

// Assign a const _variant_t& to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const _variant_t &var) throw(_com_error)
{
	if (V_VT(&var) == VT_BSTR) {
		*this = V_BSTR(&var);
		return *this;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, &var);

	*this = V_BSTR(&varDest);

	return *this;
}

extern _variant_t vtMissing;

#ifndef _USE_RAW
#define bstr_t _bstr_t
#define variant_t _variant_t
#endif

#pragma warning(pop)

#endif	// _INC_COMUTIL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convdlle.h ===
// --convdlle.h-----------------------------------------------------------------
// 
// Defines an entry point to a conversion DLL.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#if !defined(_CONVDLLE_H)
#define _CONVDLLE_H

//$$--CDllEntryPoint-----------------------------------------------------------
//
//  DESCRIIPTION: class that represetns entry point info.  Manages reference couting.
//
// ---------------------------------------------------------------------------
class CDllEntryPoint
{
protected:
    LPWSTR m_pszDllName ;
    LPSTR  m_pszEntryPoint ;
    LPWSTR m_pszGwPoint ;
    LPWSTR m_pszOptions ;

    WORD m_nRefs ;                // reference count.

public:
    CDllEntryPoint() ;
    ~CDllEntryPoint() ;

    void AddRef() { DEBUGPRIVATE("CDLLEntryPoint::AddRef()\n"); m_nRefs++; }
    void Release() ;
    void EDKFree() ;

    void EDKDump() ;

    HRESULT HrEDKSet(LPCWSTR pszDllName, LPCWSTR pszEntryPoint, LPCWSTR pszGwPoint, LPCWSTR pszOptions) ;

    // standard get member functions
    LPWSTR const pszDllName()    { return (m_pszDllName) ; }
    LPSTR  const pszEntryPoint() { return (m_pszEntryPoint) ; }
    LPWSTR const pszGwPoint()    { return (m_pszGwPoint); }
    LPWSTR const pszOptions()    { return (m_pszOptions); }
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convreg.h ===
// --convreg.h------------------------------------------------------------------
// 
//  Conversion registry class.
//  Locates converters that are stored in DLLs from info stored in the 
//  registry.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#if !defined(_CONVREG_H)
#define _CONVREG_H

//$$--CEDKConvReg--------------------------------------------------------------
//
//  DESCRIPTION: the conversion registry keeps track of conversion configuration.
//
// ---------------------------------------------------------------------------
class CEDKConvReg
{
public:

    CEDKConvReg() ;
    ~CEDKConvReg() ;

    HRESULT HrEDKInitialize() ;

    HRESULT HrEDKSearchOpen(
        IN LPCWSTR pszConversionPoint,
        IN LPCWSTR pszContentClass,
        OUT CDllEntryPoint * &pep) ;

    HRESULT HrEDKSearchNext() ;

    void EDKSearchClose() ;

    void EDKDumpMappings() ;

    // Deletes common member data (static class names list & DLL cache)
    void EDKFree() ;

    // function to retrieve a cached DLL handle
    static inline HRESULT CEDKConvReg::HrGetDllHandle(
        IN LPWSTR pszDllName,       // name of DLL to get instance handle for
        OUT HINSTANCE * phInst)     // instance handle pointer
    {
        ASSERTERROR(ms_pDllCache != NULL, "Bad ms_pDllCache");

        RETURN(((CDllCache *) CEDKConvReg::ms_pDllCache)->HrFind(pszDllName, phInst));
    }

protected:   
    // helper functions
    HRESULT HrEDKParseConfiguration() ;
    HRESULT HrEDKRecordValues(
        IN HKEY const hkEntryPoint, 
        IN LPCWSTR pszDll, 
        IN LPCWSTR pszEntryPoint) ;
    VOID EDKSyntaxError(
        IN LPWSTR pszDll,
        IN LPWSTR pszEntryPoint,
        IN LPWSTR pszClass,
        IN LPWSTR pszOptions,
        IN LPWSTR pszPoint) ;

    // common values
    BOOL m_bSyntaxError ;                           // true when a syntax error has occurred.

    // common storage
    static HKEY ms_hkConversions ;                  // handle to conversion data in registry
    static CClassName * ms_pcnClasses ;             // in memory cache of conversion data
    static CDllCache * ms_pDllCache;                // DLL instance handle cache

    // cursor information
    CDllEntryPoint ** m_ppep ;                      // where to store the entry point pointer
    CClassName * m_pcnCurrentClass ;                // current class.
    LPCWSTR m_pszConversionPoint ;                  // name of conversion point.
    LPCWSTR m_pszContentClass ;                     // name of class
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convclss.h ===
// --convclss.h-----------------------------------------------------------------
//
//  Defines CClassName - a C++ class that keeps track of conversion classes
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#if !defined(_CONVCLSS_H)
#define _CONVCLSS_H

//$$--CClassName---------------------------------------------------------------
//
//  DESCRIPTION: This class manages entry point name information.
//
// ---------------------------------------------------------------------------
class CClassName
{
protected:
    LPWSTR m_pszClassName ;                 // name of the class supported.
    CDllEntryPoint * m_pEntryPoint ;        // entry point details.

public:
    CClassName * m_pcnNext ;                // next pointer.
    CClassName();
    ~CClassName();

    void EDKDump() ;
     
    HRESULT HrEDKSet(LPCWSTR pszClassName, CDllEntryPoint * pEntryPoint) ;

    LPWSTR const pszClassName()  { return  m_pszClassName; } 
    int const cNameLength()      { ASSERTERROR(m_pszClassName != NULL, "NULL m_pszClassName"); 
                                   return lstrlenW(m_pszClassName); } 
    CDllEntryPoint * pEntryPoint() 
                                 { return (m_pEntryPoint); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convdllc.h ===
// --convdllc.h----------------------------------------------------------------
//
// Conversion DLL cache object header file.
//
// Copyright (C) Microsoft Corp., 1986-1996.  All rights reserved.
//
// ----------------------------------------------------------------------------

#ifndef _CONVDLLC_H
#define _CONVDLLC_H

//$--CDllCache-----------------------------------------------------------------
//
// Object to maintain cache of most frequently used conversion
// DLLs
//
//-----------------------------------------------------------------------------

// Constants

// maximum number of cached DLLs maintained
const UINT nCachedDlls  =   1024;

class CDllCache
{
public:

    CDllCache();        // constructor
    ~CDllCache();       // destructor

    // Loads the DLL and saves in the cache
    HRESULT HrAdd(
        IN LPWSTR lpwszDllName);    // name of DLL to load and add

    // Finds handle of DLL in the cache
    HRESULT HrFind(
        IN LPWSTR lpwszDllName,     // name of DLL to find
        OUT HINSTANCE * phInst);    // pointer to DLL instance handle

private:

    // structure for cached DLL entries
    struct SDllCache
    {
        WCHAR lpwszName[MAX_PATH + 1];  // DLL name
        HINSTANCE   hInst;      // DLL instance handle
    };

    // array of pointers to cached DLLs
    SDllCache * m_rgSDllCache[nCachedDlls];

};

#endif  // _CONVDLLC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convcwrp.h ===
// --convcwrp.h-----------------------------------------------------------------
// 
//  C callable code that wraps the conversion engine class.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#if !defined(_CONVCWRP_H)
#define _CONVCWRP_H

#ifdef __cplusplus
extern "C" {
#endif

//$--HrConvInitGlobals-------------------------------------------------
//
// DESCRIPTION: Called once by the gateway to initalize common data areas.
//
// INPUT:   none
//
// RETURNS: HRESULT --  NOERROR if successfull,
//                      E_NOTENOUGHMEMORY if memory problems
//
//---------------------------------------------------------------------
HRESULT HrConvInitGlobals();

//$--ConvUninitGlobals-------------------------------------------------
//
// DESCRIPTION: Called once by the gateway to de-initalize common data areas.
//
// INPUT:   none
//
// RETURNS: VOID
//
//---------------------------------------------------------------------
VOID ConvUninitGlobals();

//$--HrConvInitInstance-----------------------------------------------
//
//  DESCRIPTION: Called to create a new instance of the conversion engine.  Each
//  instance of the conversion engine is single-threaded.  Multiple
//  instances can be used in separate threads.
//
//  INPUT:   hEventSource   --  event source handle
//
//  OUTPUT:  ppvConvInst --  conversion engine instance
//
//  RETURNS:    HRESULT --  NOERROR if no error,
//                          E_INVALIDARG if bad input,
//                          E_FAIL if failure
//
//---------------------------------------------------------------------
HRESULT HrConvInitInstance(      // RETURNS: HRESULT
    IN HANDLE hEventSource,         // filled in with instance handle.
    OUT PVOID * ppvConvInst);       // new conversion engine instance

//$--HrConvUninitInstance----------------------------------------------
//
// DESCRIPTION: Called to dispose of a previously allocated conversion engine.
//
// INPUT:   pvConvInst  --  conversion engine instance to free.
//
// RETURNS: HRESULT --  NOERROR if successful,
//                      E_INVALIDARG if bad input
//                      E_FAIL otherwise.
//
//---------------------------------------------------------------------
HRESULT HrConvUninitInstance(     // RETURNS: HRESULT
    IN PVOID pvConvInst);                    // handle to instance to free.

//$--HrConvConvert----------------------------------------------------
//
// DESCRIPTION: called to initiate a conversion.
//
// INPUT:   pvConvInst  --  conversion engine instance
//          pEnv    --  conversion environment
//          pszContentClass --  class of source
//          pContentIn  --  source to be converted
//          pContentOut --  converted object
// 
// OUTPUT:  
//          pcrResult   --  result
//
// RETURNS: HRESULT --  NOERROR if no error,
//                      E_INVALIDARG if bad input,
//                      E_FAIL otherwise.
//
//---------------------------------------------------------------------
HRESULT HrConvConvert(           // RETURNS: HRESULT
    IN PVOID pvConvInst,            // handle to instance of engine.
    IN PEDKCNVENV pEnv,             // environment of the convrsion
    IN LPCWSTR pszContentClass,     // class of source to be converted.
    IN PVOID pContentIn,            // source to be converted.
    IN PVOID pContentOut,           // converted object
    OUT EDKCNVRES *pcrResult);      // result.

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\corReg.h ===
//*****************************************************************************
// File: CorReg.H
//
// Copyright (c) 1996-1998 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential.	Public header file for COM+ 1.0 release.
//*****************************************************************************
#ifndef _CORREG_H_
#define _CORREG_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//*****************************************************************************
// Required includes
#include <ole2.h>						// Definitions of OLE types.
//*****************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

// Force 1 byte alignment for structures which must match.
#include <pshpack1.h>

#ifndef NODLLIMPORT
#define DLLIMPORT __declspec(dllimport)
#else
#define DLLIMPORT
#endif


//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C	 E N T R Y	  P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************
#if !defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)
//@todo: take out for RTM
STDAPI			CoGetCor(REFIID riid, void** ppv);
#endif

STDAPI			CoInitializeCor(DWORD fFlags);
STDAPI_(void)	CoUninitializeCor(void);



//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A	D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************
// Token  definitions
typedef __int32 mdScope;	 // scope token
#define mdScopeNil ((mdScope)0)

typedef __int32 mdToken;				// Generic token
typedef __int32 mdModule;				// Module token (roughly, a scope)
typedef __int32 mdTypeDef;				// TypeDef in this scope
typedef __int32 mdInterfaceImpl;		// interface implementation token
typedef __int32 mdTypeRef;				// TypeRef reference (this or other scope)
typedef __int32 mdNamespace;			// namespace token
typedef __int32 mdCustomValue;			// attribute token

typedef __int32 mdResource; 			// CompReg.Resource
typedef __int32 mdCocatdef; 			// CompReg.Cocat
typedef __int32 mdCocatImpl;			// CompReg.CoclassCat
typedef __int32 mdMimeTypeImpl; 		// CompReg.CoclassMIME
typedef __int32 mdFormatImpl;			// CompReg.CoclassFormats
typedef __int32 mdProgID;				// CompReg.RedirectProgID
typedef __int32 mdRoleCheck;			// CompReg.RoleCheck

typedef unsigned long RID;

enum CorRegTokenType
{
	mdtTypeDef			= 0x00000000,
	mdtInterfaceImpl	= 0x01000000,
	mdtTypeRef			= 0x03000000,
	mdtNamespace		= 0x06000000,
	mdtCustomValue		= 0x07000000,

	mdtResource 		= 0x0B000000,
	mdtCocatImpl		= 0x0D000000,
	mdtMimeTypeImpl 	= 0x0E000000,
	mdtFormatImpl		= 0x0F000000,
	mdtProgID			= 0x10000000,
	mdtRoleCheck		= 0x11000000,

	mdtModule			= 0x14000000,
};

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((tk) & 0xff000000)

#define mdTokenNil			((mdToken)0)
#define mdModuleNil 		((mdModule)mdtModule)
#define mdTypeDefNil		((mdTypeDef)mdtTypeDef)
#define mdInterfaceImplNil	((mdInterfaceImpl)mdtInterfaceImpl)
#define mdTypeRefNil		((mdTypeRef)mdtTypeRef)
#define mdNamespaceNil		((mdNamespace)mdtNamespace)
#define mdCustomValueNil	((mdCustomValue)mdtCustomValue)

#define mdResourceNil		((mdResource)mdtResource)
#define mdCocatImplNil		((mdCocatImpl)mdtCocatImpl)
#define mdMimeTypeImplNil	((mdMimeTypeImpl)mdtMimeTypeImpl)
#define mdFormatImplNil 	((mdFormatImpl)mdtFormatImpl)
#define mdProgIDNil 		((mdProgID)mdtProgID)
#define mdRoleCheckNil		((mdRoleCheck)mdtRoleCheck)

enum CorRegTypeAttr 	// Used by emit_defineclass
{
	tdPublic			=	0x0001, 	// Class is public scope

	// Use this mask to retrieve class layout informaiton
	// 0 is AutoLayout, 0x2 is LayoutSequential, 4 is ExplicitLayout
	tdLayoutMask		=	0x0006, 	
	tdAutoLayout		=	0x0000, 	// Class fields are auto-laid out
	tdLayoutSequential	=	0x0002, 	// Class fields are laid out sequentially
	tdExplicitLayout	=	0x0004, 	// Layout is supplied explicitly

	tdWrapperClass		=	0x0008, 	// This is a wrapper class

	tdFinal 			=	0x0010, 	// Class is final
	tdISSCompat 		=	0x0020, 	// InvokeSpecial backwards compatibility

	// Use tdStringFormatMask to retrieve string information
	tdStringFormatMask	=	0x00c0, 	
	tdAnsiClass 		=	0x0000, 	// LPTSTR is interpreted as ANSI in this class
	tdUnicodeClass		=	0x0040, 	// LPTSTR is interpreted as UNICODE
	tdAutoClass 		=	0x0080, 	// LPTSTR is interpreted automatically

	tdValueClass		=	0x0100, 	// Class has value based semantics
	tdInterface 		=	0x0200, 	// Class is an interface
	tdAbstract			=	0x0400, 	// Class is abstract
	tdImport			=	0x1000, 	// Class / interface is imported
	tdRecord			=	0x2000, 	// Class is a record (no methods or props)
	tdEnum				=	0x4000, 	// Class is an enum; static final values only

	tdReserved1 		=	0x0800, 	// reserve bit for internal use
	// tdReserved2			=	0x8000, 	// reserve bit for internal use
};

enum CorImplementType					// Used internally for implements table
{
	itImplements		=	0x0000, 	// Interfaces implemented or parent ifaces
	itEvents			=	0x0001, 	// Interfaces raised
	itRequires			=	0x0002, 
	itInherits			=	0x0004,
};

//-------------------------------------
//--- Registration support types
//-------------------------------------
enum CorClassActivateAttr 
{ 
	caaDeferCreate		=	0x0001, 			// supports deferred create 
	caaAppObject		=	0x0002, 			// class is AppObject 
	caaFixedIfaceSet	=	0x0004, 			// interface set is open (use QI) 
	caaIndependentlyCreateable	=	0x0100, 
	caaPredefined		=	0x0200,

	// mask for caaLB*
	caaLoadBalancing	=	0x0c00,
	caaLBNotSupported	=	0x0400,
	caaLBSupported		=	0x0800,
	caaLBNotSpecified	=	0x0000,

	// mask for caaOP*
	caaObjectPooling	=	0x3000,
	caaOPNotSupported	=	0x1000,
	caaOPSupported		=	0x2000,
	caaOPNotSpecified	=	0x0000,

	// mask for caaJA*
	caaJITActivation	=	0xc000,
	caaJANotSupported	=	0x4000,
	caaJASupported		=	0x8000,
	caaJANotSpecified	=	0x0000,
}; 

enum CorIfaceSvcAttr 
{
	mlNone				=	0x0001, 			// Not marshalled 
	mlAutomation		=	0x0002, 			// Standard marshalling 
	mlProxyStub 		=	0x0004, 			// Custom marshalling 

	// mask for mlDefer*
	mlDeferrable		=	0x0018, 			// Methods on this interface are queuable
	mlDeferNotSupported =	0x0008,
	mlDeferSupported	=	0x0010,
	mlDeferNotSpecified =	0x0000,
}; 

enum CocatImplAttr 
{ 
	catiaImplements 	=	0x0001, 			// coclass implements this category 
	catiaRequires		=	0x0002				// coclass requires this category 
}; 

enum  CorModuleExportAttr 
{ 
	moUsesGetLastError	=	0x0001				// Module uses GetLastError
}; 

enum CorModuleRegAttr 
{ 
	rmaCustomReg		=	0x0001
}; 

enum CorRegFormatAttr 
{ 
	rfaSupportsFormat	=	0x0001, 
	rfaConvertsFromFormat = 0x0002, 
	rfaConvertsToFormat =	0x0003, 
	rfaDefaultFormat	=	0x0004, 
	rfaIsFileExt		=	0x0005,
	rfaIsFileType		=	0x0006,
	rfaIsDataFormat 	=	0x0007
}; 

enum CorSynchAttr 
{ 
	sySupported 		=	0x0001, 
	syRequired			=	0x0002, 
	syRequiresNew		=	0x0004, 
	syNotSupported		=	0x0008, 
	syThreadAffinity	=	0x0010 
}; 

enum CorThreadingAttr 
{ 
	taMain				=	0x0001, 
	taSTA				=	0x0002, 
	taMTA				=	0x0004, 
	taNeutral			=	0x0008,
	taBoth				=	0x0010	
}; 

enum CorXactionAttr 
{ 
	xaSupported 		=	0x0001, 
	xaRequired			=	0x0002, 
	xaRequiresNew		=	0x0004, 
	xaNotSupported		=	0x0008,
	xaNoVote			=	0x0010
}; 

enum CorRoleCheckAttr
{
	rcChecksFor 		=	0x0001
};


//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
enum CorSaveSize
{
	cssAccurate = 0x0000,			// Find exact save size, accurate but slower.
	cssQuick = 0x0001				// Estimate save size, may pad estimate, but faster.
};
#endif
#define 	MAX_CLASS_NAME		255
#define 	MAX_PACKAGE_NAME	255

typedef unsigned __int64 CLASSVERSION;

// %%Prototypes: -------------------------------------------------------------

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// CLSID_Cor: {bee00000-ee77-11d0-a015-00c04fbbb884}
extern const GUID DECLSPEC_SELECT_ANY CLSID_Cor = 
{ 0xbee00010, 0xee77, 0x11d0, {0xa0, 0x15, 0x00, 0xc0, 0x4f, 0xbb, 0xb8, 0x84 } };

// CLSID_CorMetaDataDispenser: {E5CB7A31-7512-11d2-89CE-0080C792E5D8}
//	This is the "Master Dispenser", always guaranteed to be the most recent
//	dispenser on the machine.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenser = 
{ 0xe5cb7a31, 0x7512, 0x11d2, { 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


// CLSID_CorMetaDataDispenserReg: {435755FF-7397-11d2-9771-00A0C9B4D50C}
//	Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//	to CLSID_CorMetaDataDispenser.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserReg = 
{ 0x435755ff, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataReg: {87F3A1F5-7397-11d2-9771-00A0C9B4D50C}
// For COM+ 1.0 Meta Data, Data Driven Registration
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataReg = 
{ 0x87f3a1f5, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// IID_IMetaDataInternal {02D601BB-C5B9-11d1-93F9-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataInternal = 
{ 0x2d601bb, 0xc5b9, 0x11d1, {0x93, 0xf9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


// {AD93D71D-E1F2-11d1-9409-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmitTemp =
{ 0xad93d71d, 0xe1f2, 0x11d1, {0x94, 0x9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


interface IMetaDataRegEmit;
interface IMetaDataRegImport;
interface IMetaDataDispenser;


// %%Interfaces: -------------------------------------------------------------
//-------------------------------------
//--- IMemory
//-------------------------------------
//---
// IID_IMemory: {06A3EA8A-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMemory = 
{ 0x6a3ea8a, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef	INTERFACE
#define INTERFACE IMemory
DECLARE_INTERFACE_(IMemory, IUnknown)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface)	(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// *** IMemory methods ***
	STDMETHOD(GetMemory)(void **pMem, ULONG *iSize) PURE;
	STDMETHOD(SetMemory)(void *pMem, ULONG iSize) PURE;
};

//-------------------------------------
//--- IMetaDataError
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataError =
{ 0xb81ff171, 0x20f3, 0x11d2, { 0x8d, 0xcc, 0x0, 0xa0, 0xc9, 0xb0, 0x9c, 0x19 } };

//---
#undef	INTERFACE
#define INTERFACE IMetaDataError
DECLARE_INTERFACE_(IMetaDataError, IUnknown)
{
	STDMETHOD(OnError)(HRESULT hrError, mdToken token) PURE;
};

//-------------------------------------
//--- IMapToken
//-------------------------------------
//---
// IID_IMapToken: {06A3EA8B-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMapToken = 
{ 0x6a3ea8b, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef	INTERFACE
#define INTERFACE IMapToken
DECLARE_INTERFACE_(IMapToken, IUnknown)
{
	STDMETHOD(Map)(ULONG tkImp, ULONG tkEmit) PURE;
};



//-------------------------------------
//--- IMetaDataDispenser
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenser =
{ 0x809c652e, 0x7396, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
#undef	INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
	STDMETHOD(DefineScope)( 				// Return code.
		REFCLSID	rclsid, 				// [in] What version to create.
		DWORD		dwCreateFlags,			// [in] Flags on the create.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

	STDMETHOD(OpenScope)(					// Return code.
		LPCWSTR 	szScope,				// [in] The scope to open.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

	STDMETHOD(OpenScopeOnStream)(			// Return code.
		IStream 	*pIStream,				// [in] The scope to open.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

	STDMETHOD(OpenScopeOnMemory)(			// Return code.
		LPCVOID 	pData,					// [in] Location of scope data.
		ULONG		cbData, 				// [in] Size of the data pointed to by pData.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

};





//-------------------------------------
//--- IMetaDataRegEmit
//-------------------------------------
//---
#if defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)

// {601C95B9-7398-11d2-9771-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegEmit = 
{ 0x601c95b9, 0x7398, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegEmitOld = 
{ 0xf28f419b, 0x62ca, 0x11d2, { 0x8f, 0x2c, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };


//---
#undef	INTERFACE
#define INTERFACE IMetaDataRegEmit
DECLARE_INTERFACE_(IMetaDataRegEmit, IUnknown)
{
	STDMETHOD(SetModuleProps)(				// S_OK or error.
		LPCWSTR 	szName, 				// [IN] If not NULL, the name to set.
		const GUID	*ppid,					// [IN] If not NULL, the GUID to set.
		LCID		lcid) PURE; 			// [IN] If not -1, the lcid to set.

	STDMETHOD(Save)(						// S_OK or error.
		LPCWSTR 	szFile, 				// [IN] The filename to save to.
		DWORD		dwSaveFlags) PURE;		// [IN] Flags for the save.

	STDMETHOD(SaveToStream)(				// S_OK or error.
		IStream 	*pIStream,				// [IN] A writable stream to save to.
		DWORD		dwSaveFlags) PURE;		// [IN] Flags for the save.

	STDMETHOD(GetSaveSize)( 				// S_OK or error.
		CorSaveSize fSave,					// [IN] cssAccurate or cssQuick.
		DWORD		*pdwSaveSize) PURE; 	// [OUT] Put the size here.

	STDMETHOD(Merge)(						// S_OK or error.
		IMetaDataRegImport *pImport,		// [IN] The scope to be merged.
		IMapToken	*pIMap) PURE;			// [IN] An object to receive token remap notices.

	STDMETHOD(DefineCustomValueAsBlob)(
		mdToken 	tkObj, 
		LPCWSTR 	szName, 
		void const	*pCustomValue, 
		ULONG		cbCustomValue, 
		mdCustomValue *pcv) PURE;

	STDMETHOD(DefineTypeDef)(				// S_OK or error.
		LPCWSTR 	szNamespace,			// [IN] Namespace that the TypeDef is in. Must be 0 in '98
		LPCWSTR 	szTypeDef,				// [IN] Name of TypeDef
		const GUID	*pguid, 				// [IN] Optional clsid
		CLASSVERSION *pVer, 				// [IN] Optional version
		DWORD		dwTypeDefFlags, 		// [IN] CustomValue flags
		mdToken 	tkExtends,				// [IN] extends this TypeDef or typeref 
		DWORD		dwExtendsFlags, 		// [IN] Extends flags
		mdToken 	rtkImplements[],		// [IN] Implements interfaces
		mdToken 	rtkEvents[],			// [IN] Events interfaces
		mdTypeDef	*ptd) PURE; 			// [OUT] Put TypeDef token here

	STDMETHOD(SetTypeDefProps)( 			// S_OK or error.
		mdTypeDef	td, 					// [IN] The TypeDef.
		CLASSVERSION *pVer, 				// [IN] Optional version.
		DWORD		dwTypeDefFlags, 		// [IN] TypeDef flags.
		mdToken 	tkExtends,				// [IN] Base TypeDef or TypeRef.
		DWORD		dwExtendsFlags, 		// [IN] Extends flags.
		mdToken 	rtkImplements[],		// [IN] Implemented interfaces.
		mdToken 	rtkEvents[]) PURE;		// [IN] Event interfaces.

	STDMETHOD(SetClassSvcsContext)(mdTypeDef td, DWORD dwClassActivateAttr, DWORD dwClassThreadAttr,
							DWORD dwXactionAttr, DWORD dwSynchAttr) PURE;

	STDMETHOD(DefineTypeRefByGUID)( 			// S_OK or error.			   
		GUID		*pguid, 				// [IN] The Type's GUID.		   
		mdTypeRef	*ptr) PURE; 			// [OUT] Put TypeRef token here.

	STDMETHOD(SetModuleReg)(DWORD dwModuleRegAttr, const GUID *pguid) PURE;
	STDMETHOD(SetClassReg)(mdTypeDef td, LPCWSTR szProgID,
							LPCWSTR szVIProgID, LPCWSTR szIconURL, ULONG ulIconResource, LPCWSTR szSmallIconURL,
							ULONG ulSmallIconResource, LPCWSTR szDefaultDispName) PURE;
	STDMETHOD(SetIfaceReg)(mdTypeDef td, DWORD dwIfaceSvcs, const GUID *proxyStub) PURE;
	STDMETHOD(SetCategoryImpl)(mdTypeDef td, GUID rGuidCoCatImpl[], GUID rGuidCoCatReqd[]) PURE;
	STDMETHOD(SetRedirectProgID)(mdTypeDef td, LPCWSTR rszRedirectProgID[]) PURE;
	STDMETHOD(SetMimeTypeImpl)(mdTypeDef td, LPCWSTR rszMimeType[]) PURE;

	STDMETHOD(SetFormatImpl)(				// S_OK or error.
		mdTypeDef	td, 					// [IN] The TypeDef.
		LPCWSTR 	rszFormatSupported[],	// [IN] If not 0, array of supported formats. 0 for EOL.
		LPCWSTR 	rszFormatConvertsFrom[],// [IN] If not 0, array of ConvertsFrom values.  "
		LPCWSTR 	rszFormatConvertsTo[],	// [IN] If not 0, array of ConvertsTo values.	 "
		LPCWSTR 	rszFormatDefault[], 	// [IN] If not 0, array of Default format.	Only one item.
		LPCWSTR 	rszFileExt[],			// [IN] If not 0, array of file extensions.   0 for EOL.
		LPCWSTR 	rszFileType[]) PURE;	// [IN] If not 0, array of file types.			 "

	STDMETHOD(SetRoleCheck)(				// S_OK or error.
		mdToken 	tk, 					// [IN] Object to place role on.
		LPCWSTR 	rszName[],				// [IN] Name for the role.
		DWORD		rdwRoleFlags[]) PURE;	// [IN] Flags for new role.

	STDMETHOD(SetHandler)(					// S_OK.
		IUnknown	*pUnk) PURE;			// [IN] The new error handler.
	
};

#endif // #if defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)

#if !defined(_META_DATA_NO_SCOPE_)

//@TODO:  $#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
// The following interface definition is being deprecated for COM+ 1.0
// and beyond.	Please convert to the new definition by defining _META_DATA_NO_SCOPE_
// in your build.
//@TODO:  $#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#

#if !defined(_META_DATA_SCOPE_WRAPPER_)
// {F28F419B-62CA-11d2-8F2C-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegEmit = 
{ 0xf28f419b, 0x62ca, 0x11d2, { 0x8f, 0x2c, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
#endif

#undef	INTERFACE
#if defined(_META_DATA_SCOPE_WRAPPER_)
#define INTERFACE IMetaDataRegEmitOld
#else
#define INTERFACE IMetaDataRegEmit
#endif
DECLARE_INTERFACE_(INTERFACE, IUnknown)
{
	STDMETHOD(DefineScope)( 				// S_OK or error.
		DWORD	dwCreateFlags,				// [IN] Flags on the create.
		mdScope *pscope) PURE;				// [OUT] return scope here.

	STDMETHOD(SetModuleProps)(				// S_OK or error.
		mdScope 	scope,					// [IN] scope for which to set props.
		LPCWSTR 	szName, 				// [IN] If not NULL, the name to set.
		const GUID	*ppid,					// [IN] If not NULL, the GUID to set.
		LCID		lcid) PURE; 			// [IN] If not -1, the lcid to set.

	STDMETHOD(Save)(						// S_OK or error.
		mdScope 	es, 					// [IN] The scope to save.
		LPCWSTR 	szFile, 				// [IN] The filename to save to.
		DWORD		dwSaveFlags) PURE;		// [IN] Flags for the save.

	STDMETHOD(SaveToStream)(				// S_OK or error.
		mdScope 	es, 					// [IN] The scope to save.
		IStream 	*pIStream,				// [IN] A writable stream to save to.
		DWORD		dwSaveFlags) PURE;		// [IN] Flags for the save.

	STDMETHOD(GetSaveSize)( 				// S_OK or error.
		mdScope 	es, 					// [IN] The scope to query.
		CorSaveSize fSave,					// [IN] cssAccurate or cssQuick.
		DWORD		*pdwSaveSize) PURE; 	// [OUT] Put the size here.

	STDMETHOD_(void,Close)( 				// S_OK or error.
		mdScope 	scope) PURE;			// [IN] The scope to close.

	STDMETHOD(Merge)(						// S_OK or error.
		mdScope 	scEmit, 				// [IN] The scope to merge into.
		mdScope 	scImport,				// [IN] The scope to be merged.
		IMapToken	*pIMap) PURE;			// [IN] An object to receive token remap notices.

	STDMETHOD(DefineCustomValueAsBlob)(mdScope es, mdToken tkObj, LPCWSTR szName, 
							void const *pCustomValue, ULONG cbCustomValue, mdCustomValue *pcv) PURE;

	STDMETHOD(DefineTypeDef)(				// S_OK or error.
		mdScope 	es, 					// [IN] Emit scope
		LPCWSTR 	szNamespace,			// [IN] Namespace that the TypeDef is in. Must be 0 in '98
		LPCWSTR 	szTypeDef,				// [IN] Name of TypeDef
		const GUID	*pguid, 				// [IN] Optional clsid
		CLASSVERSION *pVer, 				// [IN] Optional version
		DWORD		dwTypeDefFlags, 		// [IN] CustomValue flags
		mdToken 	tkExtends,				// [IN] extends this TypeDef or typeref 
		DWORD		dwExtendsFlags, 		// [IN] Extends flags
		mdToken 	rtkImplements[],		// [IN] Implements interfaces
		mdToken 	rtkEvents[],			// [IN] Events interfaces
		mdTypeDef	*ptd) PURE; 			// [OUT] Put TypeDef token here

	STDMETHOD(SetTypeDefProps)( 			// S_OK or error.
		mdScope 	es, 					// [IN] The emit scope.
		mdTypeDef	td, 					// [IN] The TypeDef.
		CLASSVERSION *pVer, 				// [IN] Optional version.
		DWORD		dwTypeDefFlags, 		// [IN] TypeDef flags.
		mdToken 	tkExtends,				// [IN] Base TypeDef or TypeRef.
		DWORD		dwExtendsFlags, 		// [IN] Extends flags.
		mdToken 	rtkImplements[],		// [IN] Implemented interfaces.
		mdToken 	rtkEvents[]) PURE;		// [IN] Event interfaces.

	STDMETHOD(SetClassSvcsContext)(mdScope es, mdTypeDef td, DWORD dwClassActivateAttr, DWORD dwClassThreadAttr,
							DWORD dwXactionAttr, DWORD dwSynchAttr) PURE;

	STDMETHOD(DefineTypeRefByGUID)( 			// S_OK or error.			   
		mdScope 	sc, 					// [IN] The emit scope. 	   
		GUID		*pguid, 				// [IN] The Type's GUID.		   
		mdTypeRef	*ptr) PURE; 			// [OUT] Put TypeRef token here.

	STDMETHOD(SetModuleReg)(mdScope es, DWORD dwModuleRegAttr, const GUID *pguid) PURE;
	STDMETHOD(SetClassReg)(mdScope es, mdTypeDef td, LPCWSTR szProgID,
							LPCWSTR szVIProgID, LPCWSTR szIconURL, ULONG ulIconResource, LPCWSTR szSmallIconURL,
							ULONG ulSmallIconResource, LPCWSTR szDefaultDispName) PURE;
	STDMETHOD(SetIfaceReg)(mdScope es, mdTypeDef td, DWORD dwIfaceSvcs, const GUID *proxyStub) PURE;
	STDMETHOD(SetCategoryImpl)(mdScope es, mdTypeDef td, GUID rGuidCoCatImpl[], GUID rGuidCoCatReqd[]) PURE;
	STDMETHOD(SetRedirectProgID)(mdScope es, mdTypeDef td, LPCWSTR rszRedirectProgID[]) PURE;
	STDMETHOD(SetMimeTypeImpl)(mdScope es, mdTypeDef td, LPCWSTR rszMimeType[]) PURE;

	STDMETHOD(SetFormatImpl)(				// S_OK or error.
		mdScope 	es, 					// [IN] The emit scope.
		mdTypeDef	td, 					// [IN] The TypeDef.
		LPCWSTR 	rszFormatSupported[],	// [IN] If not 0, array of supported formats. 0 for EOL.
		LPCWSTR 	rszFormatConvertsFrom[],// [IN] If not 0, array of ConvertsFrom values.  "
		LPCWSTR 	rszFormatConvertsTo[],	// [IN] If not 0, array of ConvertsTo values.	 "
		LPCWSTR 	rszFormatDefault[], 	// [IN] If not 0, array of Default format.	Only one item.
		LPCWSTR 	rszFileExt[],			// [IN] If not 0, array of file extensions.   0 for EOL.
		LPCWSTR 	rszFileType[]) PURE;	// [IN] If not 0, array of file types.			 "

	STDMETHOD(SetRoleCheck)(				// S_OK or error.
		mdScope 	es, 					// [IN] Emit scope.
		mdToken 	tk, 					// [IN] Object to place role on.
		LPCWSTR 	rszName[],				// [IN] Name for the role.
		DWORD		rdwRoleFlags[]) PURE;	// [IN] Flags for new role.

	STDMETHOD(SetHandler)(					// S_OK.
		mdScope 	sc, 					// [IN] The scope.
		IUnknown	*pUnk) PURE;			// [IN] The new error handler.
	
};

#endif // !defined(_META_DATA_NO_SCOPE_)


//-------------------------------------
//--- IMetaDataRegImport
//-------------------------------------

#if defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)

// {4398B4FD-7399-11d2-9771-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegImport = 
{ 0x4398b4fd, 0x7399, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// {F28F419A-62CA-11d2-8F2C-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegImportOld = 
{ 0xf28f419a, 0x62ca, 0x11d2, { 0x8f, 0x2c, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

#undef	INTERFACE
#define INTERFACE IMetaDataRegImport
DECLARE_INTERFACE_(IMetaDataRegImport, IUnknown)
{
	STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
	STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
	STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
	STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
							ULONG cMax, ULONG *pcTypeDefs) PURE;
	STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
							mdInterfaceImpl rImpls[], ULONG cMax,
							ULONG* pcImpls) PURE;
	STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
							ULONG cMax, ULONG* pcTypeRefs) PURE;
	STDMETHOD(EnumCustomValues)(HCORENUM *phEnum, mdToken tk,
							mdCustomValue rCustomValues[], ULONG cMax,
							ULONG* pcCustomValues) PURE;
	STDMETHOD(EnumResources)(HCORENUM *phEnum, mdResource rResources[],
							ULONG cMax, ULONG* pcResources) PURE;
	STDMETHOD(EnumCategoryImpls)(HCORENUM *phEnum, mdTypeDef td, mdCocatImpl rCocatImpls[],
							ULONG cMax, ULONG* pcCocatImpls) PURE;
	STDMETHOD(EnumRedirectProgIDs)(HCORENUM *phEnum, mdTypeDef td, mdProgID rRedirectProgIDs[],
							ULONG cMax, ULONG* pcRedirectProgIDs) PURE;
	STDMETHOD(EnumMimeTypeImpls)(HCORENUM *phEnum, mdTypeDef td, mdMimeTypeImpl rMimeTypeImpls[],
							ULONG cMax, ULONG* pcMimeTypeImpls) PURE;
	STDMETHOD(EnumFormatImpls)(HCORENUM *phEnum, mdTypeDef td, mdFormatImpl rFormatImpls[],
							ULONG cMax, ULONG* pcFormatImpls) PURE;

	STDMETHOD(EnumRoleChecks)(				// S_OK or error.
		HCORENUM	*phEnum,				// [OUT] Return enumerator.
		mdToken 	tk, 					// [IN] Object to enumerate roles for.
		mdRoleCheck rRoleChecks[],			// [OUT] Place cMax tokens here.
		ULONG		cMax,					// [IN] Max size of rRoleChecks.
		ULONG		*pcRoleChecks) PURE;	// [Out] Place count of returned role checks here.

	STDMETHOD(FindTypeDefByName)(			// S_OK or error.
		LPCWSTR 	szNamespace,			// [IN] Namespace with the Type.
		LPCWSTR 	szTypeDef,				// [IN] Name of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindTypeDefByGUID)(			// S_OK or error.				
		const GUID	*pguid, 				// [IN] The GUID of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindCustomValue)(mdToken tk, LPCWSTR szName, mdCustomValue *pcv, 
							DWORD *pdwValueType) PURE;

	STDMETHOD(GetScopeProps)(LPWSTR szName, ULONG cchName, ULONG *pchName,
							GUID *ppid, GUID *pmvid, LCID *pLcid) PURE;

	STDMETHOD(GetModuleFromScope)(			// S_OK.
		mdModule	*pmd) PURE; 			// [OUT] Put mdModule token here.

	STDMETHOD(GetTypeDefProps)( 			// S_OK or error.
		mdTypeDef	td, 					// [IN] TypeDef token for inquiry.
		LPWSTR		szNamespace,			// [OUT] Put Namespace here.
		ULONG		cchNamespace,			// [IN] size of Namespace buffer in wide chars.
		ULONG		*pchNamespace,			// [OUT] put size of Namespace (wide chars) here.
		LPWSTR		szTypeDef,				// [OUT] Put name here.
		ULONG		cchTypeDef, 			// [IN] size of name buffer in wide chars.
		ULONG		*pchTypeDef,			// [OUT] put size of name (wide chars) here.
		GUID		*pguid, 				// [OUT] Put clsid here.
		CLASSVERSION *pver, 				// [OUT] Put version here.
		DWORD		*pdwTypeDefFlags,		// [OUT] Put flags here.
		mdToken 	*ptkExtends,			// [OUT] Put base class TypeDef/TypeRef here.
		DWORD		*pdwExtendsFlags) PURE; // [OUT] Put extends flags here.

	STDMETHOD(GetClassSvcsContext)(mdTypeDef td, DWORD *pdwClassActivateAttr, DWORD *pdwThreadAttr,
							DWORD *pdwXactonAttr, DWORD *pdwSynchAttr) PURE;

	STDMETHOD(GetInterfaceImplProps)(		// S_OK or error.
		mdInterfaceImpl iiImpl, 			// [IN] InterfaceImpl token.
		mdTypeDef	*pClass,				// [OUT] Put implementing class token here.
		mdToken 	*ptkIface,				// [OUT] Put implemented interface token here.
		DWORD		*pdwFlags) PURE;		// [OUT] Put implementation flags here.

	STDMETHOD(GetCustomValueProps)(mdCustomValue cv, LPWSTR szName, ULONG cchName,
							ULONG *pchName, DWORD *pdwValueType) PURE;
	STDMETHOD(GetCustomValueAsBlob)(mdCustomValue cv, void const **ppBlob, ULONG *pcbSize) PURE;

	STDMETHOD(GetTypeRefProps)(mdTypeRef tr, LPWSTR szTypeRef,
							ULONG cchTypeRef, ULONG *pchTypeRef, GUID *pGuid, DWORD *pdwBind) PURE;

	STDMETHOD(GetModuleRegProps)(DWORD *pModuleRegAttr, GUID *pguid) PURE;	
	STDMETHOD(GetClassRegProps)(mdTypeDef td, 
							LPWSTR szProgid, ULONG cchProgid, ULONG *pchProgid, 
							LPWSTR szVIProgid, ULONG cchVIProgid, ULONG *pchVIProgid, 
							LPWSTR szIconURL, ULONG cchIconURL, ULONG *pchIconURL, ULONG *pIconResource, 
							LPWSTR szSmallIconURL, ULONG cchSmallIconURL, ULONG *pchSmallIconURL, ULONG *pSmallIconResource, 
							LPWSTR szDefaultDispname, ULONG cchDefaultDispname, ULONG *pchDefaultDispname) PURE;
	STDMETHOD(GetIfaceRegProps)(mdTypeDef td, DWORD *pdwIfaceSvcs, GUID *pProxyStub) PURE;
	STDMETHOD(GetResourceProps)(mdResource rs, LPWSTR szURL, ULONG cchURL, ULONG *pchURL) PURE;
	STDMETHOD(GetCategoryImplProps)(mdCocatImpl cocat, GUID *pguid, DWORD *pdwCocatImplAttr) PURE;
	STDMETHOD(GetRedirectProgIDProps)(mdProgID progid, 
							LPWSTR szProgID, ULONG cchProgID, ULONG *pchProgID) PURE;
	STDMETHOD(GetMimeTypeImplProps)(mdMimeTypeImpl mime, 
							LPWSTR szMime, ULONG cchMime, ULONG *pchMime) PURE;
	STDMETHOD(GetFormatImplProps)( mdFormatImpl format, 
							LPWSTR szFormat, ULONG cchFormat, ULONG *pchFormat, 
							DWORD *pdwRegFormatAttr) PURE;

	STDMETHOD(GetRoleCheckProps)(			// S_OK or error.
		mdRoleCheck rc, 					// [IN] The role check to get props for.
		LPWSTR		szName, 				// [OUT] Buffer for name.
		ULONG		cchName,				// [IN] Max characters for szName.
		ULONG		*pchName,				// [OUT] Available string chars for szName.
		DWORD		*pdwRoleFlags) PURE;	// [OUT] Role flags go here.

	STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;
};

#endif // defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)

#if !defined(_META_DATA_NO_SCOPE_)

//@TODO:  $#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
// The following interface definition is being deprecated for COM+ 1.0
// and beyond.	It still exists to make porting to the new api easier.	If
// you need to, define _META_DATA_NO_SCOPE_ to get the old behavior.
//@TODO:  $#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#


#if !defined(_META_DATA_SCOPE_WRAPPER_)
// {F28F419A-62CA-11d2-8F2C-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegImport = 
{ 0xf28f419a, 0x62ca, 0x11d2, { 0x8f, 0x2c, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
#endif

#undef	INTERFACE
#if defined(_META_DATA_SCOPE_WRAPPER_)
#define INTERFACE IMetaDataRegImportOld
#else
#define INTERFACE IMetaDataRegImport
#endif
DECLARE_INTERFACE_(INTERFACE, IUnknown)
{
	STDMETHOD(OpenScope)(LPCWSTR szScope, DWORD dwOpenFlags, mdScope *pscope) PURE;
	STDMETHOD(OpenScopeOnStream)(IStream *pIStream, DWORD dwOpenFlags, mdScope *psc) PURE;
	STDMETHOD(OpenScopeOnMemory)(LPCVOID pData, ULONG cbData, mdScope *psc) PURE;
	STDMETHOD_(void,Close)(mdScope scope) PURE;

	STDMETHOD_(void, CloseEnum)(mdScope scope, HCORENUM hEnum) PURE;
	STDMETHOD(CountEnum)(mdScope scope, HCORENUM hEnum, ULONG *pulCount) PURE;
	STDMETHOD(ResetEnum)(mdScope scope, HCORENUM hEnum, ULONG ulPos) PURE;
	STDMETHOD(EnumTypeDefs)(mdScope scope, HCORENUM *phEnum, mdTypeDef rTypeDefs[],
							ULONG cMax, ULONG *pcTypeDefs) PURE;
	STDMETHOD(EnumInterfaceImpls)(mdScope scope, HCORENUM *phEnum, mdTypeDef td,
							mdInterfaceImpl rImpls[], ULONG cMax,
							ULONG* pcImpls) PURE;
	STDMETHOD(EnumTypeRefs)(mdScope scope, HCORENUM *phEnum, mdTypeRef rTypeRefs[],
							ULONG cMax, ULONG* pcTypeRefs) PURE;
	STDMETHOD(EnumCustomValues)(mdScope scope, HCORENUM *phEnum, mdToken tk,
							mdCustomValue rCustomValues[], ULONG cMax,
							ULONG* pcCustomValues) PURE;
	STDMETHOD(EnumResources)(mdScope scope, HCORENUM *phEnum, mdResource rResources[],
							ULONG cMax, ULONG* pcResources) PURE;
	STDMETHOD(EnumCategoryImpls)(mdScope scope, HCORENUM *phEnum, mdTypeDef td, mdCocatImpl rCocatImpls[],
							ULONG cMax, ULONG* pcCocatImpls) PURE;
	STDMETHOD(EnumRedirectProgIDs)(mdScope scope, HCORENUM *phEnum, mdTypeDef td, mdProgID rRedirectProgIDs[],
							ULONG cMax, ULONG* pcRedirectProgIDs) PURE;
	STDMETHOD(EnumMimeTypeImpls)(mdScope scope, HCORENUM *phEnum, mdTypeDef td, mdMimeTypeImpl rMimeTypeImpls[],
							ULONG cMax, ULONG* pcMimeTypeImpls) PURE;
	STDMETHOD(EnumFormatImpls)(mdScope scope, HCORENUM *phEnum, mdTypeDef td, mdFormatImpl rFormatImpls[],
							ULONG cMax, ULONG* pcFormatImpls) PURE;

	STDMETHOD(EnumRoleChecks)(				// S_OK or error.
		mdScope 	scope,					// [IN] Import scope.
		HCORENUM	*phEnum,				// [OUT] Return enumerator.
		mdToken 	tk, 					// [IN] Object to enumerate roles for.
		mdRoleCheck rRoleChecks[],			// [OUT] Place cMax tokens here.
		ULONG		cMax,					// [IN] Max size of rRoleChecks.
		ULONG		*pcRoleChecks) PURE;	// [Out] Place count of returned role checks here.

	STDMETHOD(FindTypeDefByName)(			// S_OK or error.
		mdScope 	scope,					// [IN] The scope to search.
		LPCWSTR 	szNamespace,			// [IN] Namespace with the Type.
		LPCWSTR 	szTypeDef,				// [IN] Name of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindTypeDefByGUID)(			// S_OK or error.				
		mdScope 	scope,					// [IN] The scope to search.	
		const GUID	*pguid, 				// [IN] The GUID of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindCustomValue)(mdScope scope, mdToken tk, LPCWSTR szName, mdCustomValue *pcv, 
							DWORD *pdwValueType) PURE;

	STDMETHOD(GetScopeProps)(mdScope scope, LPWSTR szName, ULONG cchName, ULONG *pchName,
							GUID *ppid, GUID *pmvid, LCID *pLcid) PURE;

	STDMETHOD(GetModuleFromScope)(			// S_OK.
		mdScope 	scope,					// [IN] The scope.
		mdModule	*pmd) PURE; 			// [OUT] Put mdModule token here.

	STDMETHOD(GetTypeDefProps)( 			// S_OK or error.
		mdScope 	scope,					// [IN] The import scope.
		mdTypeDef	td, 					// [IN] TypeDef token for inquiry.
		LPWSTR		szNamespace,			// [OUT] Put Namespace here.
		ULONG		cchNamespace,			// [IN] size of Namespace buffer in wide chars.
		ULONG		*pchNamespace,			// [OUT] put size of Namespace (wide chars) here.
		LPWSTR		szTypeDef,				// [OUT] Put name here.
		ULONG		cchTypeDef, 			// [IN] size of name buffer in wide chars.
		ULONG		*pchTypeDef,			// [OUT] put size of name (wide chars) here.
		GUID		*pguid, 				// [OUT] Put clsid here.
		CLASSVERSION *pver, 				// [OUT] Put version here.
		DWORD		*pdwTypeDefFlags,		// [OUT] Put flags here.
		mdToken 	*ptkExtends,			// [OUT] Put base class TypeDef/TypeRef here.
		DWORD		*pdwExtendsFlags) PURE; // [OUT] Put extends flags here.

	STDMETHOD(GetClassSvcsContext)(mdScope es, mdTypeDef td, DWORD *pdwClassActivateAttr, DWORD *pdwThreadAttr,
							DWORD *pdwXactonAttr, DWORD *pdwSynchAttr) PURE;

	STDMETHOD(GetInterfaceImplProps)(		// S_OK or error.
		mdScope 	scope,					// [IN] The scope.
		mdInterfaceImpl iiImpl, 			// [IN] InterfaceImpl token.
		mdTypeDef	*pClass,				// [OUT] Put implementing class token here.
		mdToken 	*ptkIface,				// [OUT] Put implemented interface token here.
		DWORD		*pdwFlags) PURE;		// [OUT] Put implementation flags here.

	STDMETHOD(GetCustomValueProps)(mdScope scope, mdCustomValue cv, LPWSTR szName, ULONG cchName,
							ULONG *pchName, DWORD *pdwValueType) PURE;
	STDMETHOD(GetCustomValueAsBlob)(mdScope scope, mdCustomValue cv, void const **ppBlob, ULONG *pcbSize) PURE;

	STDMETHOD(GetTypeRefProps)(mdScope scope, mdTypeRef tr, LPWSTR szTypeRef,
							ULONG cchTypeRef, ULONG *pchTypeRef, GUID *pGuid, DWORD *pdwBind) PURE;

	STDMETHOD(GetModuleRegProps)(mdScope scope, DWORD *pModuleRegAttr, GUID *pguid) PURE;	
	STDMETHOD(GetClassRegProps)(mdScope scope, mdTypeDef td, 
							LPWSTR szProgid, ULONG cchProgid, ULONG *pchProgid, 
							LPWSTR szVIProgid, ULONG cchVIProgid, ULONG *pchVIProgid, 
							LPWSTR szIconURL, ULONG cchIconURL, ULONG *pchIconURL, ULONG *pIconResource, 
							LPWSTR szSmallIconURL, ULONG cchSmallIconURL, ULONG *pchSmallIconURL, ULONG *pSmallIconResource, 
							LPWSTR szDefaultDispname, ULONG cchDefaultDispname, ULONG *pchDefaultDispname) PURE;
	STDMETHOD(GetIfaceRegProps)(mdScope scope, mdTypeDef td, DWORD *pdwIfaceSvcs, GUID *pProxyStub) PURE;
	STDMETHOD(GetResourceProps)(mdScope scope, mdResource rs, LPWSTR szURL, ULONG cchURL, ULONG *pchURL) PURE;
	STDMETHOD(GetCategoryImplProps)(mdScope scope, mdCocatImpl cocat, GUID *pguid, DWORD *pdwCocatImplAttr) PURE;
	STDMETHOD(GetRedirectProgIDProps)(mdScope scope, mdProgID progid, 
							LPWSTR szProgID, ULONG cchProgID, ULONG *pchProgID) PURE;
	STDMETHOD(GetMimeTypeImplProps)(mdScope scope, mdMimeTypeImpl mime, 
							LPWSTR szMime, ULONG cchMime, ULONG *pchMime) PURE;
	STDMETHOD(GetFormatImplProps)(mdScope scope, mdFormatImpl format, 
							LPWSTR szFormat, ULONG cchFormat, ULONG *pchFormat, 
							DWORD *pdwRegFormatAttr) PURE;

	STDMETHOD(GetRoleCheckProps)(			// S_OK or error.
		mdScope 	scope,					// [IN] Import scope.
		mdRoleCheck rc, 					// [IN] The role check to get props for.
		LPWSTR		szName, 				// [OUT] Buffer for name.
		ULONG		cchName,				// [IN] Max characters for szName.
		ULONG		*pchName,				// [OUT] Available string chars for szName.
		DWORD		*pdwRoleFlags) PURE;	// [OUT] Role flags go here.

	STDMETHOD(ResolveTypeRef)(mdScope is, mdTypeRef tr, mdScope *pes, mdTypeDef *ptd) PURE;
};

#endif // _META_DATA_NO_SCOPE_



// Return to default padding.
#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // _CORREG_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convstrc.h ===
// --convstrc.h-----------------------------------------------------------------
//
//  Defines common public conversion structures.
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#if !defined(_CONVSTRC_H)
#define _CONVSTRC_H

#ifdef __cplusplus
extern "C" {
#endif

//$$--EDKCNVENV---------------------------------------------------------
//
//  DESCRIPTION: Structure that represents the environment of a conversion.
//
//---------------------------------------------------------------------
typedef struct _EDKCNVENV
{
    INT nVersionEDKCNVENV ;
    LPCWSTR pszConversionPoint ;

    // connection to MAPI system
    LHANDLE lphSession ;
    LPMDB lpMDB ;
    LPADRBOOK lpAB ;
    
    // connection to foreign system
    LPVOID pGatewayDefined ;
} EDKCNVENV ;

typedef EDKCNVENV * PEDKCNVENV ;

//$$--EDKCNVRES---------------------------------------------------------
//  Enumerated type indicating the result of a conversion.
//---------------------------------------------------------------------
typedef enum _EDKCNVRES
{
    GCR_OK = 0,
    GCR_CANNOT_CONVERT,
    GCR_CANNOT_LOAD,
    GCR_NO_CANDIDATE,
    GCR_CONVERSION_FAILED
} EDKCNVRES ;


//---------------------------------------------------------------------
//  Types representing methods of a conversion DLL.
//---------------------------------------------------------------------

typedef HRESULT (*PCONVDLLQUERY)(
    IN LPCWSTR pszOptions,      // options pointer
    IN LPCWSTR pszClass,        // class name pointer
    IN PVOID pContent,          // object to convert pointer
    IN PEDKCNVENV pEnv,         // environment pointer
    OUT BOOL * pfAmCandidate);  // pointer to candidate status

typedef HRESULT (*PCONVDLLCONV)(
    IN LPCWSTR pszOptions,      // options pointer
    IN LPCWSTR pszClass,        // class name pointer
    IN PVOID pContent,          // pointer to object to convert
    IN PVOID pContentOut,       // pointer to converted object
    IN PEDKCNVENV pEnv,         // environment pointer
    OUT EDKCNVRES * pcr) ;      // pointer to conversion result

//$$--CONVDLLVECT-------------------------------------------------------
//
//  DESCRIPTION: Vector representing the entry points to a conversion.
//
//---------------------------------------------------------------------
typedef struct _CONVDLLVECT
{
    short nVectorVersion ;
    PCONVDLLQUERY pfnCnvQueryCapability ;
    PCONVDLLCONV pfnCnvConvert ;
} CONVDLLVECT ;
typedef CONVDLLVECT * PCONVDLLVECT ;

typedef HRESULT (*PCONVDLLENTRYFN)(
    IN DWORD,                   // version number desired
    OUT PCONVDLLVECT FAR *) ;   // entry point function declaration

#define nDesiredConvDllVersion ((DWORD)1)           // current conversion vector version number.

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convincl.h ===
// --convincl.h-----------------------------------------------------------------
// 
// Conversion inclues.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#if !defined(_CONVINCL_H)
#define _CONVINCL_H

#define _MEMLOG_H

#include "edk.h"

#ifdef __cplusplus
#include "convdllc.h"
#include "convdlle.h"
#include "convdll.h"
#include "convregh.h"
#include "convclss.h"
#include "convreg.h"
#include "convengn.h"
#endif
#include "convcwrp.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convengn.h ===
// --convengn.h-----------------------------------------------------------------
// 
// Defines main conversion engine class.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#if !defined(_CONVENGN_H)
#define _CONVENGN_H

//$$--CEDKConvEng---------------------------------------------------------------
//
//  DESCRIPTION: Conversion engine class.  Performs all convresions.
//
// ---------------------------------------------------------------------------
class CEDKConvEng
{
public:
    CEDKConvEng() ;

    HRESULT HrEDKInitialize(    // RETURNS: HRESULT
        IN HANDLE hEventSource) ;    // event source handle

    HRESULT HrEDKConvert(       // RETURNS: HRESULT
        IN PEDKCNVENV pEnv,     
        IN LPCWSTR pszContentClass,
        IN PVOID pContentIn,
        OUT PVOID pContentOut,
        OUT EDKCNVRES & crResult) ;

    HRESULT HrEDKUninitialize(  // RETURNS: HRESULT
        ) ;

protected:
    // helper
    HRESULT HrEDKAttemptConversion( //  RETURNS: HRESULT
        IN PEDKCNVENV pEnv,            
        IN LPCWSTR pszContentClass,   
        IN LPCWSTR pszConversionPoint,   
        IN PVOID pContentIn,           
        OUT PVOID pContentOut,        
        OUT EDKCNVRES & crResult) ;   


    CDllEntryPoint * m_pepConverter ;       // current converter.
    CEDKConvReg m_crRegistry ;              // conversion registry.
	HANDLE m_hEventSource ;

	BOOL m_bFoundAtLeastOneAccept ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\control.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for control.odl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __control_h__
#define __control_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMCollection_FWD_DEFINED__
#define __IAMCollection_FWD_DEFINED__
typedef interface IAMCollection IAMCollection;
#endif 	/* __IAMCollection_FWD_DEFINED__ */


#ifndef __IMediaControl_FWD_DEFINED__
#define __IMediaControl_FWD_DEFINED__
typedef interface IMediaControl IMediaControl;
#endif 	/* __IMediaControl_FWD_DEFINED__ */


#ifndef __IMediaEvent_FWD_DEFINED__
#define __IMediaEvent_FWD_DEFINED__
typedef interface IMediaEvent IMediaEvent;
#endif 	/* __IMediaEvent_FWD_DEFINED__ */


#ifndef __IMediaEventEx_FWD_DEFINED__
#define __IMediaEventEx_FWD_DEFINED__
typedef interface IMediaEventEx IMediaEventEx;
#endif 	/* __IMediaEventEx_FWD_DEFINED__ */


#ifndef __IMediaPosition_FWD_DEFINED__
#define __IMediaPosition_FWD_DEFINED__
typedef interface IMediaPosition IMediaPosition;
#endif 	/* __IMediaPosition_FWD_DEFINED__ */


#ifndef __IBasicAudio_FWD_DEFINED__
#define __IBasicAudio_FWD_DEFINED__
typedef interface IBasicAudio IBasicAudio;
#endif 	/* __IBasicAudio_FWD_DEFINED__ */


#ifndef __IVideoWindow_FWD_DEFINED__
#define __IVideoWindow_FWD_DEFINED__
typedef interface IVideoWindow IVideoWindow;
#endif 	/* __IVideoWindow_FWD_DEFINED__ */


#ifndef __IBasicVideo_FWD_DEFINED__
#define __IBasicVideo_FWD_DEFINED__
typedef interface IBasicVideo IBasicVideo;
#endif 	/* __IBasicVideo_FWD_DEFINED__ */


#ifndef __IBasicVideo2_FWD_DEFINED__
#define __IBasicVideo2_FWD_DEFINED__
typedef interface IBasicVideo2 IBasicVideo2;
#endif 	/* __IBasicVideo2_FWD_DEFINED__ */


#ifndef __IDeferredCommand_FWD_DEFINED__
#define __IDeferredCommand_FWD_DEFINED__
typedef interface IDeferredCommand IDeferredCommand;
#endif 	/* __IDeferredCommand_FWD_DEFINED__ */


#ifndef __IQueueCommand_FWD_DEFINED__
#define __IQueueCommand_FWD_DEFINED__
typedef interface IQueueCommand IQueueCommand;
#endif 	/* __IQueueCommand_FWD_DEFINED__ */


#ifndef __FilgraphManager_FWD_DEFINED__
#define __FilgraphManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class FilgraphManager FilgraphManager;
#else
typedef struct FilgraphManager FilgraphManager;
#endif /* __cplusplus */

#endif 	/* __FilgraphManager_FWD_DEFINED__ */


#ifndef __IFilterInfo_FWD_DEFINED__
#define __IFilterInfo_FWD_DEFINED__
typedef interface IFilterInfo IFilterInfo;
#endif 	/* __IFilterInfo_FWD_DEFINED__ */


#ifndef __IRegFilterInfo_FWD_DEFINED__
#define __IRegFilterInfo_FWD_DEFINED__
typedef interface IRegFilterInfo IRegFilterInfo;
#endif 	/* __IRegFilterInfo_FWD_DEFINED__ */


#ifndef __IMediaTypeInfo_FWD_DEFINED__
#define __IMediaTypeInfo_FWD_DEFINED__
typedef interface IMediaTypeInfo IMediaTypeInfo;
#endif 	/* __IMediaTypeInfo_FWD_DEFINED__ */


#ifndef __IPinInfo_FWD_DEFINED__
#define __IPinInfo_FWD_DEFINED__
typedef interface IPinInfo IPinInfo;
#endif 	/* __IPinInfo_FWD_DEFINED__ */


#ifndef __IAMStats_FWD_DEFINED__
#define __IAMStats_FWD_DEFINED__
typedef interface IAMStats IAMStats;
#endif 	/* __IAMStats_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __QuartzTypeLib_LIBRARY_DEFINED__
#define __QuartzTypeLib_LIBRARY_DEFINED__

/* library QuartzTypeLib */
/* [version][lcid][helpstring][uuid] */ 

typedef double REFTIME;

typedef LONG_PTR OAEVENT;

typedef LONG_PTR OAHWND;

typedef long OAFilterState;


DEFINE_GUID(LIBID_QuartzTypeLib,0x56a868b0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifndef __IAMCollection_INTERFACE_DEFINED__
#define __IAMCollection_INTERFACE_DEFINED__

/* interface IAMCollection */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMCollection,0x56a868b9,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b9-0ad4-11ce-b03a-0020af0ba770")
    IAMCollection : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long lItem,
            /* [out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAMCollection * This,
            /* [retval][out] */ LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IAMCollection * This,
            /* [in] */ long lItem,
            /* [out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IAMCollection * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IAMCollectionVtbl;

    interface IAMCollection
    {
        CONST_VTBL struct IAMCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAMCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAMCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAMCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAMCollection_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IAMCollection_Item(This,lItem,ppUnk)	\
    (This)->lpVtbl -> Item(This,lItem,ppUnk)

#define IAMCollection_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IAMCollection_get_Count_Proxy( 
    IAMCollection * This,
    /* [retval][out] */ LONG *plCount);


void __RPC_STUB IAMCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMCollection_Item_Proxy( 
    IAMCollection * This,
    /* [in] */ long lItem,
    /* [out] */ IUnknown **ppUnk);


void __RPC_STUB IAMCollection_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IAMCollection_get__NewEnum_Proxy( 
    IAMCollection * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IAMCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMCollection_INTERFACE_DEFINED__ */


#ifndef __IMediaControl_INTERFACE_DEFINED__
#define __IMediaControl_INTERFACE_DEFINED__

/* interface IMediaControl */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaControl,0x56a868b1,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b1-0ad4-11ce-b03a-0020af0ba770")
    IMediaControl : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ LONG msTimeout,
            /* [out] */ OAFilterState *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderFile( 
            /* [in] */ BSTR strFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilter( 
            /* [in] */ BSTR strFilename,
            /* [out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterCollection( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegFilterCollection( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopWhenReady( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaControl * This,
            /* [in] */ LONG msTimeout,
            /* [out] */ OAFilterState *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IMediaControl * This,
            /* [in] */ BSTR strFilename);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IMediaControl * This,
            /* [in] */ BSTR strFilename,
            /* [out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegFilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *StopWhenReady )( 
            IMediaControl * This);
        
        END_INTERFACE
    } IMediaControlVtbl;

    interface IMediaControl
    {
        CONST_VTBL struct IMediaControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaControl_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IMediaControl_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMediaControl_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMediaControl_GetState(This,msTimeout,pfs)	\
    (This)->lpVtbl -> GetState(This,msTimeout,pfs)

#define IMediaControl_RenderFile(This,strFilename)	\
    (This)->lpVtbl -> RenderFile(This,strFilename)

#define IMediaControl_AddSourceFilter(This,strFilename,ppUnk)	\
    (This)->lpVtbl -> AddSourceFilter(This,strFilename,ppUnk)

#define IMediaControl_get_FilterCollection(This,ppUnk)	\
    (This)->lpVtbl -> get_FilterCollection(This,ppUnk)

#define IMediaControl_get_RegFilterCollection(This,ppUnk)	\
    (This)->lpVtbl -> get_RegFilterCollection(This,ppUnk)

#define IMediaControl_StopWhenReady(This)	\
    (This)->lpVtbl -> StopWhenReady(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaControl_Run_Proxy( 
    IMediaControl * This);


void __RPC_STUB IMediaControl_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_Pause_Proxy( 
    IMediaControl * This);


void __RPC_STUB IMediaControl_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_Stop_Proxy( 
    IMediaControl * This);


void __RPC_STUB IMediaControl_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_GetState_Proxy( 
    IMediaControl * This,
    /* [in] */ LONG msTimeout,
    /* [out] */ OAFilterState *pfs);


void __RPC_STUB IMediaControl_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_RenderFile_Proxy( 
    IMediaControl * This,
    /* [in] */ BSTR strFilename);


void __RPC_STUB IMediaControl_RenderFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_AddSourceFilter_Proxy( 
    IMediaControl * This,
    /* [in] */ BSTR strFilename,
    /* [out] */ IDispatch **ppUnk);


void __RPC_STUB IMediaControl_AddSourceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaControl_get_FilterCollection_Proxy( 
    IMediaControl * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IMediaControl_get_FilterCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaControl_get_RegFilterCollection_Proxy( 
    IMediaControl * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IMediaControl_get_RegFilterCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaControl_StopWhenReady_Proxy( 
    IMediaControl * This);


void __RPC_STUB IMediaControl_StopWhenReady_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaControl_INTERFACE_DEFINED__ */


#ifndef __IMediaEvent_INTERFACE_DEFINED__
#define __IMediaEvent_INTERFACE_DEFINED__

/* interface IMediaEvent */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEvent,0x56a868b6,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b6-0ad4-11ce-b03a-0020af0ba770")
    IMediaEvent : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventHandle( 
            /* [out] */ OAEVENT *hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [out] */ long *lEventCode,
            /* [out] */ LONG_PTR *lParam1,
            /* [out] */ LONG_PTR *lParam2,
            /* [in] */ long msTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForCompletion( 
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeEventParams( 
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEvent * This,
            /* [out] */ OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEvent * This,
            /* [out] */ long *lEventCode,
            /* [out] */ LONG_PTR *lParam1,
            /* [out] */ LONG_PTR *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEvent * This,
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        END_INTERFACE
    } IMediaEventVtbl;

    interface IMediaEvent
    {
        CONST_VTBL struct IMediaEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaEvent_GetEventHandle(This,hEvent)	\
    (This)->lpVtbl -> GetEventHandle(This,hEvent)

#define IMediaEvent_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)

#define IMediaEvent_WaitForCompletion(This,msTimeout,pEvCode)	\
    (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode)

#define IMediaEvent_CancelDefaultHandling(This,lEvCode)	\
    (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode)

#define IMediaEvent_RestoreDefaultHandling(This,lEvCode)	\
    (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode)

#define IMediaEvent_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaEvent_GetEventHandle_Proxy( 
    IMediaEvent * This,
    /* [out] */ OAEVENT *hEvent);


void __RPC_STUB IMediaEvent_GetEventHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_GetEvent_Proxy( 
    IMediaEvent * This,
    /* [out] */ long *lEventCode,
    /* [out] */ LONG_PTR *lParam1,
    /* [out] */ LONG_PTR *lParam2,
    /* [in] */ long msTimeout);


void __RPC_STUB IMediaEvent_GetEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_WaitForCompletion_Proxy( 
    IMediaEvent * This,
    /* [in] */ long msTimeout,
    /* [out] */ long *pEvCode);


void __RPC_STUB IMediaEvent_WaitForCompletion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_CancelDefaultHandling_Proxy( 
    IMediaEvent * This,
    /* [in] */ long lEvCode);


void __RPC_STUB IMediaEvent_CancelDefaultHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_RestoreDefaultHandling_Proxy( 
    IMediaEvent * This,
    /* [in] */ long lEvCode);


void __RPC_STUB IMediaEvent_RestoreDefaultHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEvent_FreeEventParams_Proxy( 
    IMediaEvent * This,
    /* [in] */ long lEvCode,
    /* [in] */ LONG_PTR lParam1,
    /* [in] */ LONG_PTR lParam2);


void __RPC_STUB IMediaEvent_FreeEventParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaEvent_INTERFACE_DEFINED__ */


#ifndef __IMediaEventEx_INTERFACE_DEFINED__
#define __IMediaEventEx_INTERFACE_DEFINED__

/* interface IMediaEventEx */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEventEx,0x56a868c0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868c0-0ad4-11ce-b03a-0020af0ba770")
    IMediaEventEx : public IMediaEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotifyWindow( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ LONG_PTR lInstanceData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifyFlags( 
            /* [in] */ long lNoNotifyFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifyFlags( 
            /* [out] */ long *lplNoNotifyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEventEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEventEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEventEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEventEx * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEventEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEventEx * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEventEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEventEx * This,
            /* [out] */ OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEventEx * This,
            /* [out] */ long *lEventCode,
            /* [out] */ LONG_PTR *lParam1,
            /* [out] */ LONG_PTR *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEventEx * This,
            /* [in] */ long msTimeout,
            /* [out] */ long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyWindow )( 
            IMediaEventEx * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ LONG_PTR lInstanceData);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyFlags )( 
            IMediaEventEx * This,
            /* [in] */ long lNoNotifyFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetNotifyFlags )( 
            IMediaEventEx * This,
            /* [out] */ long *lplNoNotifyFlags);
        
        END_INTERFACE
    } IMediaEventExVtbl;

    interface IMediaEventEx
    {
        CONST_VTBL struct IMediaEventExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEventEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaEventEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaEventEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaEventEx_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaEventEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaEventEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaEventEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaEventEx_GetEventHandle(This,hEvent)	\
    (This)->lpVtbl -> GetEventHandle(This,hEvent)

#define IMediaEventEx_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)

#define IMediaEventEx_WaitForCompletion(This,msTimeout,pEvCode)	\
    (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode)

#define IMediaEventEx_CancelDefaultHandling(This,lEvCode)	\
    (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode)

#define IMediaEventEx_RestoreDefaultHandling(This,lEvCode)	\
    (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode)

#define IMediaEventEx_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2)


#define IMediaEventEx_SetNotifyWindow(This,hwnd,lMsg,lInstanceData)	\
    (This)->lpVtbl -> SetNotifyWindow(This,hwnd,lMsg,lInstanceData)

#define IMediaEventEx_SetNotifyFlags(This,lNoNotifyFlags)	\
    (This)->lpVtbl -> SetNotifyFlags(This,lNoNotifyFlags)

#define IMediaEventEx_GetNotifyFlags(This,lplNoNotifyFlags)	\
    (This)->lpVtbl -> GetNotifyFlags(This,lplNoNotifyFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaEventEx_SetNotifyWindow_Proxy( 
    IMediaEventEx * This,
    /* [in] */ OAHWND hwnd,
    /* [in] */ long lMsg,
    /* [in] */ LONG_PTR lInstanceData);


void __RPC_STUB IMediaEventEx_SetNotifyWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEventEx_SetNotifyFlags_Proxy( 
    IMediaEventEx * This,
    /* [in] */ long lNoNotifyFlags);


void __RPC_STUB IMediaEventEx_SetNotifyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaEventEx_GetNotifyFlags_Proxy( 
    IMediaEventEx * This,
    /* [out] */ long *lplNoNotifyFlags);


void __RPC_STUB IMediaEventEx_GetNotifyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaEventEx_INTERFACE_DEFINED__ */


#ifndef __IMediaPosition_INTERFACE_DEFINED__
#define __IMediaPosition_INTERFACE_DEFINED__

/* interface IMediaPosition */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaPosition,0x56a868b2,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b2-0ad4-11ce-b03a-0020af0ba770")
    IMediaPosition : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ REFTIME *plength) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrerollTime( 
            /* [retval][out] */ REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrerollTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double dRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekForward( 
            /* [retval][out] */ LONG *pCanSeekForward) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekBackward( 
            /* [retval][out] */ LONG *pCanSeekBackward) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPosition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPosition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPosition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaPosition * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaPosition * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaPosition * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaPosition * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *plength);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrerollTime )( 
            IMediaPosition * This,
            /* [retval][out] */ REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrerollTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMediaPosition * This,
            /* [in] */ double dRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMediaPosition * This,
            /* [retval][out] */ double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekForward )( 
            IMediaPosition * This,
            /* [retval][out] */ LONG *pCanSeekForward);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekBackward )( 
            IMediaPosition * This,
            /* [retval][out] */ LONG *pCanSeekBackward);
        
        END_INTERFACE
    } IMediaPositionVtbl;

    interface IMediaPosition
    {
        CONST_VTBL struct IMediaPositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaPosition_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaPosition_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaPosition_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaPosition_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaPosition_get_Duration(This,plength)	\
    (This)->lpVtbl -> get_Duration(This,plength)

#define IMediaPosition_put_CurrentPosition(This,llTime)	\
    (This)->lpVtbl -> put_CurrentPosition(This,llTime)

#define IMediaPosition_get_CurrentPosition(This,pllTime)	\
    (This)->lpVtbl -> get_CurrentPosition(This,pllTime)

#define IMediaPosition_get_StopTime(This,pllTime)	\
    (This)->lpVtbl -> get_StopTime(This,pllTime)

#define IMediaPosition_put_StopTime(This,llTime)	\
    (This)->lpVtbl -> put_StopTime(This,llTime)

#define IMediaPosition_get_PrerollTime(This,pllTime)	\
    (This)->lpVtbl -> get_PrerollTime(This,pllTime)

#define IMediaPosition_put_PrerollTime(This,llTime)	\
    (This)->lpVtbl -> put_PrerollTime(This,llTime)

#define IMediaPosition_put_Rate(This,dRate)	\
    (This)->lpVtbl -> put_Rate(This,dRate)

#define IMediaPosition_get_Rate(This,pdRate)	\
    (This)->lpVtbl -> get_Rate(This,pdRate)

#define IMediaPosition_CanSeekForward(This,pCanSeekForward)	\
    (This)->lpVtbl -> CanSeekForward(This,pCanSeekForward)

#define IMediaPosition_CanSeekBackward(This,pCanSeekBackward)	\
    (This)->lpVtbl -> CanSeekBackward(This,pCanSeekBackward)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_Duration_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ REFTIME *plength);


void __RPC_STUB IMediaPosition_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMediaPosition_put_CurrentPosition_Proxy( 
    IMediaPosition * This,
    /* [in] */ REFTIME llTime);


void __RPC_STUB IMediaPosition_put_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_CurrentPosition_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ REFTIME *pllTime);


void __RPC_STUB IMediaPosition_get_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_StopTime_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ REFTIME *pllTime);


void __RPC_STUB IMediaPosition_get_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMediaPosition_put_StopTime_Proxy( 
    IMediaPosition * This,
    /* [in] */ REFTIME llTime);


void __RPC_STUB IMediaPosition_put_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_PrerollTime_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ REFTIME *pllTime);


void __RPC_STUB IMediaPosition_get_PrerollTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMediaPosition_put_PrerollTime_Proxy( 
    IMediaPosition * This,
    /* [in] */ REFTIME llTime);


void __RPC_STUB IMediaPosition_put_PrerollTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMediaPosition_put_Rate_Proxy( 
    IMediaPosition * This,
    /* [in] */ double dRate);


void __RPC_STUB IMediaPosition_put_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaPosition_get_Rate_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ double *pdRate);


void __RPC_STUB IMediaPosition_get_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaPosition_CanSeekForward_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ LONG *pCanSeekForward);


void __RPC_STUB IMediaPosition_CanSeekForward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaPosition_CanSeekBackward_Proxy( 
    IMediaPosition * This,
    /* [retval][out] */ LONG *pCanSeekBackward);


void __RPC_STUB IMediaPosition_CanSeekBackward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaPosition_INTERFACE_DEFINED__ */


#ifndef __IBasicAudio_INTERFACE_DEFINED__
#define __IBasicAudio_INTERFACE_DEFINED__

/* interface IBasicAudio */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicAudio,0x56a868b3,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b3-0ad4-11ce-b03a-0020af0ba770")
    IBasicAudio : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ long *plVolume) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ long *plBalance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicAudio * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicAudio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicAudio * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicAudio * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicAudio * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicAudio * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IBasicAudio * This,
            /* [in] */ long lVolume);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IBasicAudio * This,
            /* [retval][out] */ long *plVolume);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IBasicAudio * This,
            /* [in] */ long lBalance);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IBasicAudio * This,
            /* [retval][out] */ long *plBalance);
        
        END_INTERFACE
    } IBasicAudioVtbl;

    interface IBasicAudio
    {
        CONST_VTBL struct IBasicAudioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicAudio_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBasicAudio_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBasicAudio_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBasicAudio_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBasicAudio_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBasicAudio_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBasicAudio_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBasicAudio_put_Volume(This,lVolume)	\
    (This)->lpVtbl -> put_Volume(This,lVolume)

#define IBasicAudio_get_Volume(This,plVolume)	\
    (This)->lpVtbl -> get_Volume(This,plVolume)

#define IBasicAudio_put_Balance(This,lBalance)	\
    (This)->lpVtbl -> put_Balance(This,lBalance)

#define IBasicAudio_get_Balance(This,plBalance)	\
    (This)->lpVtbl -> get_Balance(This,plBalance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicAudio_put_Volume_Proxy( 
    IBasicAudio * This,
    /* [in] */ long lVolume);


void __RPC_STUB IBasicAudio_put_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicAudio_get_Volume_Proxy( 
    IBasicAudio * This,
    /* [retval][out] */ long *plVolume);


void __RPC_STUB IBasicAudio_get_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicAudio_put_Balance_Proxy( 
    IBasicAudio * This,
    /* [in] */ long lBalance);


void __RPC_STUB IBasicAudio_put_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicAudio_get_Balance_Proxy( 
    IBasicAudio * This,
    /* [retval][out] */ long *plBalance);


void __RPC_STUB IBasicAudio_get_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBasicAudio_INTERFACE_DEFINED__ */


#ifndef __IVideoWindow_INTERFACE_DEFINED__
#define __IVideoWindow_INTERFACE_DEFINED__

/* interface IVideoWindow */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IVideoWindow,0x56a868b4,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b4-0ad4-11ce-b03a-0020af0ba770")
    IVideoWindow : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ BSTR strCaption) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR *strCaption) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyle( 
            /* [in] */ long WindowStyle) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyle( 
            /* [retval][out] */ long *WindowStyle) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyleEx( 
            /* [in] */ long WindowStyleEx) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyleEx( 
            /* [retval][out] */ long *WindowStyleEx) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AutoShow( 
            /* [in] */ long AutoShow) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AutoShow( 
            /* [retval][out] */ long *AutoShow) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ long WindowState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ long *WindowState) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BackgroundPalette( 
            /* [in] */ long BackgroundPalette) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BackgroundPalette( 
            /* [retval][out] */ long *pBackgroundPalette) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ long Visible) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ long *pVisible) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long Left) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long *pLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long Width) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long *pWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long Top) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long *pTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long Height) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long *pHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Owner( 
            /* [in] */ OAHWND Owner) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Owner( 
            /* [retval][out] */ OAHWND *Owner) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MessageDrain( 
            /* [in] */ OAHWND Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MessageDrain( 
            /* [retval][out] */ OAHWND *Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
            /* [retval][out] */ long *Color) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
            /* [in] */ long Color) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FullScreenMode( 
            /* [retval][out] */ long *FullScreenMode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FullScreenMode( 
            /* [in] */ long FullScreenMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowForeground( 
            /* [in] */ long Focus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOwnerMessage( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ LONG_PTR wParam,
            /* [in] */ LONG_PTR lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowPosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealImageSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealImageSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRestorePosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideCursor( 
            /* [in] */ long HideCursor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCursorHidden( 
            /* [out] */ long *CursorHidden) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVideoWindow * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVideoWindow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVideoWindow * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVideoWindow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            IVideoWindow * This,
            /* [in] */ BSTR strCaption);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            IVideoWindow * This,
            /* [retval][out] */ BSTR *strCaption);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyle )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyle);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyle )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowStyle);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyleEx )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyleEx);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyleEx )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowStyleEx);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoShow )( 
            IVideoWindow * This,
            /* [in] */ long AutoShow);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoShow )( 
            IVideoWindow * This,
            /* [retval][out] */ long *AutoShow);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowState )( 
            IVideoWindow * This,
            /* [in] */ long WindowState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowState )( 
            IVideoWindow * This,
            /* [retval][out] */ long *WindowState);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackgroundPalette )( 
            IVideoWindow * This,
            /* [in] */ long BackgroundPalette);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackgroundPalette )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pBackgroundPalette);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IVideoWindow * This,
            /* [in] */ long Visible);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IVideoWindow * This,
            /* [in] */ long Left);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IVideoWindow * This,
            /* [in] */ long Width);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            IVideoWindow * This,
            /* [in] */ long Top);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IVideoWindow * This,
            /* [in] */ long Height);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IVideoWindow * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Owner )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Owner);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Owner )( 
            IVideoWindow * This,
            /* [retval][out] */ OAHWND *Owner);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageDrain )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageDrain )( 
            IVideoWindow * This,
            /* [retval][out] */ OAHWND *Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderColor )( 
            IVideoWindow * This,
            /* [retval][out] */ long *Color);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderColor )( 
            IVideoWindow * This,
            /* [in] */ long Color);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullScreenMode )( 
            IVideoWindow * This,
            /* [retval][out] */ long *FullScreenMode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FullScreenMode )( 
            IVideoWindow * This,
            /* [in] */ long FullScreenMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowForeground )( 
            IVideoWindow * This,
            /* [in] */ long Focus);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOwnerMessage )( 
            IVideoWindow * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ LONG_PTR wParam,
            /* [in] */ LONG_PTR lParam);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowPosition )( 
            IVideoWindow * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowPosition )( 
            IVideoWindow * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestorePosition )( 
            IVideoWindow * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *HideCursor )( 
            IVideoWindow * This,
            /* [in] */ long HideCursor);
        
        HRESULT ( STDMETHODCALLTYPE *IsCursorHidden )( 
            IVideoWindow * This,
            /* [out] */ long *CursorHidden);
        
        END_INTERFACE
    } IVideoWindowVtbl;

    interface IVideoWindow
    {
        CONST_VTBL struct IVideoWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVideoWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVideoWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVideoWindow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVideoWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVideoWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVideoWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVideoWindow_put_Caption(This,strCaption)	\
    (This)->lpVtbl -> put_Caption(This,strCaption)

#define IVideoWindow_get_Caption(This,strCaption)	\
    (This)->lpVtbl -> get_Caption(This,strCaption)

#define IVideoWindow_put_WindowStyle(This,WindowStyle)	\
    (This)->lpVtbl -> put_WindowStyle(This,WindowStyle)

#define IVideoWindow_get_WindowStyle(This,WindowStyle)	\
    (This)->lpVtbl -> get_WindowStyle(This,WindowStyle)

#define IVideoWindow_put_WindowStyleEx(This,WindowStyleEx)	\
    (This)->lpVtbl -> put_WindowStyleEx(This,WindowStyleEx)

#define IVideoWindow_get_WindowStyleEx(This,WindowStyleEx)	\
    (This)->lpVtbl -> get_WindowStyleEx(This,WindowStyleEx)

#define IVideoWindow_put_AutoShow(This,AutoShow)	\
    (This)->lpVtbl -> put_AutoShow(This,AutoShow)

#define IVideoWindow_get_AutoShow(This,AutoShow)	\
    (This)->lpVtbl -> get_AutoShow(This,AutoShow)

#define IVideoWindow_put_WindowState(This,WindowState)	\
    (This)->lpVtbl -> put_WindowState(This,WindowState)

#define IVideoWindow_get_WindowState(This,WindowState)	\
    (This)->lpVtbl -> get_WindowState(This,WindowState)

#define IVideoWindow_put_BackgroundPalette(This,BackgroundPalette)	\
    (This)->lpVtbl -> put_BackgroundPalette(This,BackgroundPalette)

#define IVideoWindow_get_BackgroundPalette(This,pBackgroundPalette)	\
    (This)->lpVtbl -> get_BackgroundPalette(This,pBackgroundPalette)

#define IVideoWindow_put_Visible(This,Visible)	\
    (This)->lpVtbl -> put_Visible(This,Visible)

#define IVideoWindow_get_Visible(This,pVisible)	\
    (This)->lpVtbl -> get_Visible(This,pVisible)

#define IVideoWindow_put_Left(This,Left)	\
    (This)->lpVtbl -> put_Left(This,Left)

#define IVideoWindow_get_Left(This,pLeft)	\
    (This)->lpVtbl -> get_Left(This,pLeft)

#define IVideoWindow_put_Width(This,Width)	\
    (This)->lpVtbl -> put_Width(This,Width)

#define IVideoWindow_get_Width(This,pWidth)	\
    (This)->lpVtbl -> get_Width(This,pWidth)

#define IVideoWindow_put_Top(This,Top)	\
    (This)->lpVtbl -> put_Top(This,Top)

#define IVideoWindow_get_Top(This,pTop)	\
    (This)->lpVtbl -> get_Top(This,pTop)

#define IVideoWindow_put_Height(This,Height)	\
    (This)->lpVtbl -> put_Height(This,Height)

#define IVideoWindow_get_Height(This,pHeight)	\
    (This)->lpVtbl -> get_Height(This,pHeight)

#define IVideoWindow_put_Owner(This,Owner)	\
    (This)->lpVtbl -> put_Owner(This,Owner)

#define IVideoWindow_get_Owner(This,Owner)	\
    (This)->lpVtbl -> get_Owner(This,Owner)

#define IVideoWindow_put_MessageDrain(This,Drain)	\
    (This)->lpVtbl -> put_MessageDrain(This,Drain)

#define IVideoWindow_get_MessageDrain(This,Drain)	\
    (This)->lpVtbl -> get_MessageDrain(This,Drain)

#define IVideoWindow_get_BorderColor(This,Color)	\
    (This)->lpVtbl -> get_BorderColor(This,Color)

#define IVideoWindow_put_BorderColor(This,Color)	\
    (This)->lpVtbl -> put_BorderColor(This,Color)

#define IVideoWindow_get_FullScreenMode(This,FullScreenMode)	\
    (This)->lpVtbl -> get_FullScreenMode(This,FullScreenMode)

#define IVideoWindow_put_FullScreenMode(This,FullScreenMode)	\
    (This)->lpVtbl -> put_FullScreenMode(This,FullScreenMode)

#define IVideoWindow_SetWindowForeground(This,Focus)	\
    (This)->lpVtbl -> SetWindowForeground(This,Focus)

#define IVideoWindow_NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam)

#define IVideoWindow_SetWindowPosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetWindowPosition(This,Left,Top,Width,Height)

#define IVideoWindow_GetWindowPosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetWindowPosition(This,pLeft,pTop,pWidth,pHeight)

#define IVideoWindow_GetMinIdealImageSize(This,pWidth,pHeight)	\
    (This)->lpVtbl -> GetMinIdealImageSize(This,pWidth,pHeight)

#define IVideoWindow_GetMaxIdealImageSize(This,pWidth,pHeight)	\
    (This)->lpVtbl -> GetMaxIdealImageSize(This,pWidth,pHeight)

#define IVideoWindow_GetRestorePosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetRestorePosition(This,pLeft,pTop,pWidth,pHeight)

#define IVideoWindow_HideCursor(This,HideCursor)	\
    (This)->lpVtbl -> HideCursor(This,HideCursor)

#define IVideoWindow_IsCursorHidden(This,CursorHidden)	\
    (This)->lpVtbl -> IsCursorHidden(This,CursorHidden)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Caption_Proxy( 
    IVideoWindow * This,
    /* [in] */ BSTR strCaption);


void __RPC_STUB IVideoWindow_put_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Caption_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ BSTR *strCaption);


void __RPC_STUB IVideoWindow_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_WindowStyle_Proxy( 
    IVideoWindow * This,
    /* [in] */ long WindowStyle);


void __RPC_STUB IVideoWindow_put_WindowStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_WindowStyle_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *WindowStyle);


void __RPC_STUB IVideoWindow_get_WindowStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_WindowStyleEx_Proxy( 
    IVideoWindow * This,
    /* [in] */ long WindowStyleEx);


void __RPC_STUB IVideoWindow_put_WindowStyleEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_WindowStyleEx_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *WindowStyleEx);


void __RPC_STUB IVideoWindow_get_WindowStyleEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_AutoShow_Proxy( 
    IVideoWindow * This,
    /* [in] */ long AutoShow);


void __RPC_STUB IVideoWindow_put_AutoShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_AutoShow_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *AutoShow);


void __RPC_STUB IVideoWindow_get_AutoShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_WindowState_Proxy( 
    IVideoWindow * This,
    /* [in] */ long WindowState);


void __RPC_STUB IVideoWindow_put_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_WindowState_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *WindowState);


void __RPC_STUB IVideoWindow_get_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_BackgroundPalette_Proxy( 
    IVideoWindow * This,
    /* [in] */ long BackgroundPalette);


void __RPC_STUB IVideoWindow_put_BackgroundPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_BackgroundPalette_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pBackgroundPalette);


void __RPC_STUB IVideoWindow_get_BackgroundPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Visible_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Visible);


void __RPC_STUB IVideoWindow_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Visible_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pVisible);


void __RPC_STUB IVideoWindow_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Left_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Left);


void __RPC_STUB IVideoWindow_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Left_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pLeft);


void __RPC_STUB IVideoWindow_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Width_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Width);


void __RPC_STUB IVideoWindow_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Width_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pWidth);


void __RPC_STUB IVideoWindow_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Top_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Top);


void __RPC_STUB IVideoWindow_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Top_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pTop);


void __RPC_STUB IVideoWindow_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Height_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Height);


void __RPC_STUB IVideoWindow_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Height_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *pHeight);


void __RPC_STUB IVideoWindow_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_Owner_Proxy( 
    IVideoWindow * This,
    /* [in] */ OAHWND Owner);


void __RPC_STUB IVideoWindow_put_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_Owner_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ OAHWND *Owner);


void __RPC_STUB IVideoWindow_get_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_MessageDrain_Proxy( 
    IVideoWindow * This,
    /* [in] */ OAHWND Drain);


void __RPC_STUB IVideoWindow_put_MessageDrain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_MessageDrain_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ OAHWND *Drain);


void __RPC_STUB IVideoWindow_get_MessageDrain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_BorderColor_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *Color);


void __RPC_STUB IVideoWindow_get_BorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_BorderColor_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Color);


void __RPC_STUB IVideoWindow_put_BorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVideoWindow_get_FullScreenMode_Proxy( 
    IVideoWindow * This,
    /* [retval][out] */ long *FullScreenMode);


void __RPC_STUB IVideoWindow_get_FullScreenMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IVideoWindow_put_FullScreenMode_Proxy( 
    IVideoWindow * This,
    /* [in] */ long FullScreenMode);


void __RPC_STUB IVideoWindow_put_FullScreenMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_SetWindowForeground_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Focus);


void __RPC_STUB IVideoWindow_SetWindowForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_NotifyOwnerMessage_Proxy( 
    IVideoWindow * This,
    /* [in] */ OAHWND hwnd,
    /* [in] */ long uMsg,
    /* [in] */ LONG_PTR wParam,
    /* [in] */ LONG_PTR lParam);


void __RPC_STUB IVideoWindow_NotifyOwnerMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_SetWindowPosition_Proxy( 
    IVideoWindow * This,
    /* [in] */ long Left,
    /* [in] */ long Top,
    /* [in] */ long Width,
    /* [in] */ long Height);


void __RPC_STUB IVideoWindow_SetWindowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_GetWindowPosition_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *pLeft,
    /* [out] */ long *pTop,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IVideoWindow_GetWindowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_GetMinIdealImageSize_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IVideoWindow_GetMinIdealImageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_GetMaxIdealImageSize_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IVideoWindow_GetMaxIdealImageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_GetRestorePosition_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *pLeft,
    /* [out] */ long *pTop,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IVideoWindow_GetRestorePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_HideCursor_Proxy( 
    IVideoWindow * This,
    /* [in] */ long HideCursor);


void __RPC_STUB IVideoWindow_HideCursor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoWindow_IsCursorHidden_Proxy( 
    IVideoWindow * This,
    /* [out] */ long *CursorHidden);


void __RPC_STUB IVideoWindow_IsCursorHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVideoWindow_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo_INTERFACE_DEFINED__
#define __IBasicVideo_INTERFACE_DEFINED__

/* interface IBasicVideo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo,0x56a868b5,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b5-0ad4-11ce-b03a-0020af0ba770")
    IBasicVideo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AvgTimePerFrame( 
            /* [retval][out] */ REFTIME *pAvgTimePerFrame) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitRate( 
            /* [retval][out] */ long *pBitRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitErrorRate( 
            /* [retval][out] */ long *pBitErrorRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoWidth( 
            /* [retval][out] */ long *pVideoWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoHeight( 
            /* [retval][out] */ long *pVideoHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceLeft( 
            /* [in] */ long SourceLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceLeft( 
            /* [retval][out] */ long *pSourceLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceWidth( 
            /* [in] */ long SourceWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceWidth( 
            /* [retval][out] */ long *pSourceWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceTop( 
            /* [in] */ long SourceTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceTop( 
            /* [retval][out] */ long *pSourceTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceHeight( 
            /* [in] */ long SourceHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceHeight( 
            /* [retval][out] */ long *pSourceHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationLeft( 
            /* [in] */ long DestinationLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationLeft( 
            /* [retval][out] */ long *pDestinationLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationWidth( 
            /* [in] */ long DestinationWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationWidth( 
            /* [retval][out] */ long *pDestinationWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationTop( 
            /* [in] */ long DestinationTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationTop( 
            /* [retval][out] */ long *pDestinationTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationHeight( 
            /* [in] */ long DestinationHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationHeight( 
            /* [retval][out] */ long *pDestinationHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourcePosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSourcePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDestinationPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationPosition( 
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultDestinationPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoSize( 
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPaletteEntries( 
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultSource( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultDestination( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo * This,
            /* [retval][out] */ REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo * This);
        
        END_INTERFACE
    } IBasicVideoVtbl;

    interface IBasicVideo
    {
        CONST_VTBL struct IBasicVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBasicVideo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBasicVideo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBasicVideo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBasicVideo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBasicVideo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBasicVideo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBasicVideo_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame)

#define IBasicVideo_get_BitRate(This,pBitRate)	\
    (This)->lpVtbl -> get_BitRate(This,pBitRate)

#define IBasicVideo_get_BitErrorRate(This,pBitErrorRate)	\
    (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate)

#define IBasicVideo_get_VideoWidth(This,pVideoWidth)	\
    (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth)

#define IBasicVideo_get_VideoHeight(This,pVideoHeight)	\
    (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight)

#define IBasicVideo_put_SourceLeft(This,SourceLeft)	\
    (This)->lpVtbl -> put_SourceLeft(This,SourceLeft)

#define IBasicVideo_get_SourceLeft(This,pSourceLeft)	\
    (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft)

#define IBasicVideo_put_SourceWidth(This,SourceWidth)	\
    (This)->lpVtbl -> put_SourceWidth(This,SourceWidth)

#define IBasicVideo_get_SourceWidth(This,pSourceWidth)	\
    (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth)

#define IBasicVideo_put_SourceTop(This,SourceTop)	\
    (This)->lpVtbl -> put_SourceTop(This,SourceTop)

#define IBasicVideo_get_SourceTop(This,pSourceTop)	\
    (This)->lpVtbl -> get_SourceTop(This,pSourceTop)

#define IBasicVideo_put_SourceHeight(This,SourceHeight)	\
    (This)->lpVtbl -> put_SourceHeight(This,SourceHeight)

#define IBasicVideo_get_SourceHeight(This,pSourceHeight)	\
    (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight)

#define IBasicVideo_put_DestinationLeft(This,DestinationLeft)	\
    (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft)

#define IBasicVideo_get_DestinationLeft(This,pDestinationLeft)	\
    (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft)

#define IBasicVideo_put_DestinationWidth(This,DestinationWidth)	\
    (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth)

#define IBasicVideo_get_DestinationWidth(This,pDestinationWidth)	\
    (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth)

#define IBasicVideo_put_DestinationTop(This,DestinationTop)	\
    (This)->lpVtbl -> put_DestinationTop(This,DestinationTop)

#define IBasicVideo_get_DestinationTop(This,pDestinationTop)	\
    (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop)

#define IBasicVideo_put_DestinationHeight(This,DestinationHeight)	\
    (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight)

#define IBasicVideo_get_DestinationHeight(This,pDestinationHeight)	\
    (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight)

#define IBasicVideo_SetSourcePosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height)

#define IBasicVideo_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)

#define IBasicVideo_SetDefaultSourcePosition(This)	\
    (This)->lpVtbl -> SetDefaultSourcePosition(This)

#define IBasicVideo_SetDestinationPosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height)

#define IBasicVideo_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)

#define IBasicVideo_SetDefaultDestinationPosition(This)	\
    (This)->lpVtbl -> SetDefaultDestinationPosition(This)

#define IBasicVideo_GetVideoSize(This,pWidth,pHeight)	\
    (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight)

#define IBasicVideo_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)

#define IBasicVideo_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage)

#define IBasicVideo_IsUsingDefaultSource(This)	\
    (This)->lpVtbl -> IsUsingDefaultSource(This)

#define IBasicVideo_IsUsingDefaultDestination(This)	\
    (This)->lpVtbl -> IsUsingDefaultDestination(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_AvgTimePerFrame_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ REFTIME *pAvgTimePerFrame);


void __RPC_STUB IBasicVideo_get_AvgTimePerFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_BitRate_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pBitRate);


void __RPC_STUB IBasicVideo_get_BitRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_BitErrorRate_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pBitErrorRate);


void __RPC_STUB IBasicVideo_get_BitErrorRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_VideoWidth_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pVideoWidth);


void __RPC_STUB IBasicVideo_get_VideoWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_VideoHeight_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pVideoHeight);


void __RPC_STUB IBasicVideo_get_VideoHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_SourceLeft_Proxy( 
    IBasicVideo * This,
    /* [in] */ long SourceLeft);


void __RPC_STUB IBasicVideo_put_SourceLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_SourceLeft_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pSourceLeft);


void __RPC_STUB IBasicVideo_get_SourceLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_SourceWidth_Proxy( 
    IBasicVideo * This,
    /* [in] */ long SourceWidth);


void __RPC_STUB IBasicVideo_put_SourceWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_SourceWidth_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pSourceWidth);


void __RPC_STUB IBasicVideo_get_SourceWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_SourceTop_Proxy( 
    IBasicVideo * This,
    /* [in] */ long SourceTop);


void __RPC_STUB IBasicVideo_put_SourceTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_SourceTop_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pSourceTop);


void __RPC_STUB IBasicVideo_get_SourceTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_SourceHeight_Proxy( 
    IBasicVideo * This,
    /* [in] */ long SourceHeight);


void __RPC_STUB IBasicVideo_put_SourceHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_SourceHeight_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pSourceHeight);


void __RPC_STUB IBasicVideo_get_SourceHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_DestinationLeft_Proxy( 
    IBasicVideo * This,
    /* [in] */ long DestinationLeft);


void __RPC_STUB IBasicVideo_put_DestinationLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_DestinationLeft_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pDestinationLeft);


void __RPC_STUB IBasicVideo_get_DestinationLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_DestinationWidth_Proxy( 
    IBasicVideo * This,
    /* [in] */ long DestinationWidth);


void __RPC_STUB IBasicVideo_put_DestinationWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_DestinationWidth_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pDestinationWidth);


void __RPC_STUB IBasicVideo_get_DestinationWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_DestinationTop_Proxy( 
    IBasicVideo * This,
    /* [in] */ long DestinationTop);


void __RPC_STUB IBasicVideo_put_DestinationTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_DestinationTop_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pDestinationTop);


void __RPC_STUB IBasicVideo_get_DestinationTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBasicVideo_put_DestinationHeight_Proxy( 
    IBasicVideo * This,
    /* [in] */ long DestinationHeight);


void __RPC_STUB IBasicVideo_put_DestinationHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IBasicVideo_get_DestinationHeight_Proxy( 
    IBasicVideo * This,
    /* [retval][out] */ long *pDestinationHeight);


void __RPC_STUB IBasicVideo_get_DestinationHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_SetSourcePosition_Proxy( 
    IBasicVideo * This,
    /* [in] */ long Left,
    /* [in] */ long Top,
    /* [in] */ long Width,
    /* [in] */ long Height);


void __RPC_STUB IBasicVideo_SetSourcePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetSourcePosition_Proxy( 
    IBasicVideo * This,
    /* [out] */ long *pLeft,
    /* [out] */ long *pTop,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IBasicVideo_GetSourcePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_SetDefaultSourcePosition_Proxy( 
    IBasicVideo * This);


void __RPC_STUB IBasicVideo_SetDefaultSourcePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_SetDestinationPosition_Proxy( 
    IBasicVideo * This,
    /* [in] */ long Left,
    /* [in] */ long Top,
    /* [in] */ long Width,
    /* [in] */ long Height);


void __RPC_STUB IBasicVideo_SetDestinationPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetDestinationPosition_Proxy( 
    IBasicVideo * This,
    /* [out] */ long *pLeft,
    /* [out] */ long *pTop,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IBasicVideo_GetDestinationPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_SetDefaultDestinationPosition_Proxy( 
    IBasicVideo * This);


void __RPC_STUB IBasicVideo_SetDefaultDestinationPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetVideoSize_Proxy( 
    IBasicVideo * This,
    /* [out] */ long *pWidth,
    /* [out] */ long *pHeight);


void __RPC_STUB IBasicVideo_GetVideoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetVideoPaletteEntries_Proxy( 
    IBasicVideo * This,
    /* [in] */ long StartIndex,
    /* [in] */ long Entries,
    /* [out] */ long *pRetrieved,
    /* [out] */ long *pPalette);


void __RPC_STUB IBasicVideo_GetVideoPaletteEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_GetCurrentImage_Proxy( 
    IBasicVideo * This,
    /* [out][in] */ long *pBufferSize,
    /* [out] */ long *pDIBImage);


void __RPC_STUB IBasicVideo_GetCurrentImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_IsUsingDefaultSource_Proxy( 
    IBasicVideo * This);


void __RPC_STUB IBasicVideo_IsUsingDefaultSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasicVideo_IsUsingDefaultDestination_Proxy( 
    IBasicVideo * This);


void __RPC_STUB IBasicVideo_IsUsingDefaultDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBasicVideo_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo2_INTERFACE_DEFINED__
#define __IBasicVideo2_INTERFACE_DEFINED__

/* interface IBasicVideo2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo2,0x329bb360,0xf6ea,0x11d1,0x90,0x38,0x00,0xa0,0xc9,0x69,0x72,0x98);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("329bb360-f6ea-11d1-9038-00a0c9697298")
    IBasicVideo2 : public IBasicVideo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPreferredAspectRatio( 
            /* [out] */ long *plAspectX,
            /* [out] */ long *plAspectY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo2 * This,
            /* [retval][out] */ REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo2 * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [out] */ long *pLeft,
            /* [out] */ long *pTop,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo2 * This,
            /* [out] */ long *pWidth,
            /* [out] */ long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo2 * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ long *pRetrieved,
            /* [out] */ long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo2 * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferredAspectRatio )( 
            IBasicVideo2 * This,
            /* [out] */ long *plAspectX,
            /* [out] */ long *plAspectY);
        
        END_INTERFACE
    } IBasicVideo2Vtbl;

    interface IBasicVideo2
    {
        CONST_VTBL struct IBasicVideo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBasicVideo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBasicVideo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBasicVideo2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBasicVideo2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBasicVideo2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBasicVideo2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBasicVideo2_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame)

#define IBasicVideo2_get_BitRate(This,pBitRate)	\
    (This)->lpVtbl -> get_BitRate(This,pBitRate)

#define IBasicVideo2_get_BitErrorRate(This,pBitErrorRate)	\
    (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate)

#define IBasicVideo2_get_VideoWidth(This,pVideoWidth)	\
    (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth)

#define IBasicVideo2_get_VideoHeight(This,pVideoHeight)	\
    (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight)

#define IBasicVideo2_put_SourceLeft(This,SourceLeft)	\
    (This)->lpVtbl -> put_SourceLeft(This,SourceLeft)

#define IBasicVideo2_get_SourceLeft(This,pSourceLeft)	\
    (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft)

#define IBasicVideo2_put_SourceWidth(This,SourceWidth)	\
    (This)->lpVtbl -> put_SourceWidth(This,SourceWidth)

#define IBasicVideo2_get_SourceWidth(This,pSourceWidth)	\
    (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth)

#define IBasicVideo2_put_SourceTop(This,SourceTop)	\
    (This)->lpVtbl -> put_SourceTop(This,SourceTop)

#define IBasicVideo2_get_SourceTop(This,pSourceTop)	\
    (This)->lpVtbl -> get_SourceTop(This,pSourceTop)

#define IBasicVideo2_put_SourceHeight(This,SourceHeight)	\
    (This)->lpVtbl -> put_SourceHeight(This,SourceHeight)

#define IBasicVideo2_get_SourceHeight(This,pSourceHeight)	\
    (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight)

#define IBasicVideo2_put_DestinationLeft(This,DestinationLeft)	\
    (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft)

#define IBasicVideo2_get_DestinationLeft(This,pDestinationLeft)	\
    (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft)

#define IBasicVideo2_put_DestinationWidth(This,DestinationWidth)	\
    (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth)

#define IBasicVideo2_get_DestinationWidth(This,pDestinationWidth)	\
    (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth)

#define IBasicVideo2_put_DestinationTop(This,DestinationTop)	\
    (This)->lpVtbl -> put_DestinationTop(This,DestinationTop)

#define IBasicVideo2_get_DestinationTop(This,pDestinationTop)	\
    (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop)

#define IBasicVideo2_put_DestinationHeight(This,DestinationHeight)	\
    (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight)

#define IBasicVideo2_get_DestinationHeight(This,pDestinationHeight)	\
    (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight)

#define IBasicVideo2_SetSourcePosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height)

#define IBasicVideo2_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)

#define IBasicVideo2_SetDefaultSourcePosition(This)	\
    (This)->lpVtbl -> SetDefaultSourcePosition(This)

#define IBasicVideo2_SetDestinationPosition(This,Left,Top,Width,Height)	\
    (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height)

#define IBasicVideo2_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)

#define IBasicVideo2_SetDefaultDestinationPosition(This)	\
    (This)->lpVtbl -> SetDefaultDestinationPosition(This)

#define IBasicVideo2_GetVideoSize(This,pWidth,pHeight)	\
    (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight)

#define IBasicVideo2_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)

#define IBasicVideo2_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage)

#define IBasicVideo2_IsUsingDefaultSource(This)	\
    (This)->lpVtbl -> IsUsingDefaultSource(This)

#define IBasicVideo2_IsUsingDefaultDestination(This)	\
    (This)->lpVtbl -> IsUsingDefaultDestination(This)


#define IBasicVideo2_GetPreferredAspectRatio(This,plAspectX,plAspectY)	\
    (This)->lpVtbl -> GetPreferredAspectRatio(This,plAspectX,plAspectY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBasicVideo2_GetPreferredAspectRatio_Proxy( 
    IBasicVideo2 * This,
    /* [out] */ long *plAspectX,
    /* [out] */ long *plAspectY);


void __RPC_STUB IBasicVideo2_GetPreferredAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBasicVideo2_INTERFACE_DEFINED__ */


#ifndef __IDeferredCommand_INTERFACE_DEFINED__
#define __IDeferredCommand_INTERFACE_DEFINED__

/* interface IDeferredCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IDeferredCommand,0x56a868b8,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b8-0ad4-11ce-b03a-0020af0ba770")
    IDeferredCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Confidence( 
            /* [out] */ LONG *pConfidence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Postpone( 
            /* [in] */ REFTIME newtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHResult( 
            /* [out] */ HRESULT *phrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeferredCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeferredCommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeferredCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Confidence )( 
            IDeferredCommand * This,
            /* [out] */ LONG *pConfidence);
        
        HRESULT ( STDMETHODCALLTYPE *Postpone )( 
            IDeferredCommand * This,
            /* [in] */ REFTIME newtime);
        
        HRESULT ( STDMETHODCALLTYPE *GetHResult )( 
            IDeferredCommand * This,
            /* [out] */ HRESULT *phrResult);
        
        END_INTERFACE
    } IDeferredCommandVtbl;

    interface IDeferredCommand
    {
        CONST_VTBL struct IDeferredCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeferredCommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDeferredCommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDeferredCommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDeferredCommand_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IDeferredCommand_Confidence(This,pConfidence)	\
    (This)->lpVtbl -> Confidence(This,pConfidence)

#define IDeferredCommand_Postpone(This,newtime)	\
    (This)->lpVtbl -> Postpone(This,newtime)

#define IDeferredCommand_GetHResult(This,phrResult)	\
    (This)->lpVtbl -> GetHResult(This,phrResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDeferredCommand_Cancel_Proxy( 
    IDeferredCommand * This);


void __RPC_STUB IDeferredCommand_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeferredCommand_Confidence_Proxy( 
    IDeferredCommand * This,
    /* [out] */ LONG *pConfidence);


void __RPC_STUB IDeferredCommand_Confidence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeferredCommand_Postpone_Proxy( 
    IDeferredCommand * This,
    /* [in] */ REFTIME newtime);


void __RPC_STUB IDeferredCommand_Postpone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeferredCommand_GetHResult_Proxy( 
    IDeferredCommand * This,
    /* [out] */ HRESULT *phrResult);


void __RPC_STUB IDeferredCommand_GetHResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDeferredCommand_INTERFACE_DEFINED__ */


#ifndef __IQueueCommand_INTERFACE_DEFINED__
#define __IQueueCommand_INTERFACE_DEFINED__

/* interface IQueueCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IQueueCommand,0x56a868b7,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b7-0ad4-11ce-b03a-0020af0ba770")
    IQueueCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvokeAtStreamTime( 
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeAtPresentationTime( 
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueueCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueueCommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueueCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueueCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtStreamTime )( 
            IQueueCommand * This,
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtPresentationTime )( 
            IQueueCommand * This,
            /* [out] */ IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ VARIANT *pDispParams,
            /* [out][in] */ VARIANT *pvarResult,
            /* [out] */ short *puArgErr);
        
        END_INTERFACE
    } IQueueCommandVtbl;

    interface IQueueCommand
    {
        CONST_VTBL struct IQueueCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueueCommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQueueCommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQueueCommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQueueCommand_InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    (This)->lpVtbl -> InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)

#define IQueueCommand_InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    (This)->lpVtbl -> InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQueueCommand_InvokeAtStreamTime_Proxy( 
    IQueueCommand * This,
    /* [out] */ IDeferredCommand **pCmd,
    /* [in] */ REFTIME time,
    /* [in] */ GUID *iid,
    /* [in] */ long dispidMethod,
    /* [in] */ short wFlags,
    /* [in] */ long cArgs,
    /* [in] */ VARIANT *pDispParams,
    /* [out][in] */ VARIANT *pvarResult,
    /* [out] */ short *puArgErr);


void __RPC_STUB IQueueCommand_InvokeAtStreamTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQueueCommand_InvokeAtPresentationTime_Proxy( 
    IQueueCommand * This,
    /* [out] */ IDeferredCommand **pCmd,
    /* [in] */ REFTIME time,
    /* [in] */ GUID *iid,
    /* [in] */ long dispidMethod,
    /* [in] */ short wFlags,
    /* [in] */ long cArgs,
    /* [in] */ VARIANT *pDispParams,
    /* [out][in] */ VARIANT *pvarResult,
    /* [out] */ short *puArgErr);


void __RPC_STUB IQueueCommand_InvokeAtPresentationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQueueCommand_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_FilgraphManager,0xe436ebb3,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifdef __cplusplus

class DECLSPEC_UUID("e436ebb3-524f-11ce-9f53-0020af0ba770")
FilgraphManager;
#endif

#ifndef __IFilterInfo_INTERFACE_DEFINED__
#define __IFilterInfo_INTERFACE_DEFINED__

/* interface IFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IFilterInfo,0x56a868ba,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ba-0ad4-11ce-b03a-0020af0ba770")
    IFilterInfo : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [in] */ BSTR strPinID,
            /* [out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *strName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VendorInfo( 
            /* [retval][out] */ BSTR *strVendorInfo) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pins( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSource( 
            /* [retval][out] */ LONG *pbIsSource) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            /* [retval][out] */ BSTR *pstrFilename) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Filename( 
            /* [in] */ BSTR strFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFilterInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IFilterInfo * This,
            /* [in] */ BSTR strPinID,
            /* [out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *strName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VendorInfo )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *strVendorInfo);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filter )( 
            IFilterInfo * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pins )( 
            IFilterInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFileSource )( 
            IFilterInfo * This,
            /* [retval][out] */ LONG *pbIsSource);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filename )( 
            IFilterInfo * This,
            /* [retval][out] */ BSTR *pstrFilename);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filename )( 
            IFilterInfo * This,
            /* [in] */ BSTR strFilename);
        
        END_INTERFACE
    } IFilterInfoVtbl;

    interface IFilterInfo
    {
        CONST_VTBL struct IFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFilterInfo_FindPin(This,strPinID,ppUnk)	\
    (This)->lpVtbl -> FindPin(This,strPinID,ppUnk)

#define IFilterInfo_get_Name(This,strName)	\
    (This)->lpVtbl -> get_Name(This,strName)

#define IFilterInfo_get_VendorInfo(This,strVendorInfo)	\
    (This)->lpVtbl -> get_VendorInfo(This,strVendorInfo)

#define IFilterInfo_get_Filter(This,ppUnk)	\
    (This)->lpVtbl -> get_Filter(This,ppUnk)

#define IFilterInfo_get_Pins(This,ppUnk)	\
    (This)->lpVtbl -> get_Pins(This,ppUnk)

#define IFilterInfo_get_IsFileSource(This,pbIsSource)	\
    (This)->lpVtbl -> get_IsFileSource(This,pbIsSource)

#define IFilterInfo_get_Filename(This,pstrFilename)	\
    (This)->lpVtbl -> get_Filename(This,pstrFilename)

#define IFilterInfo_put_Filename(This,strFilename)	\
    (This)->lpVtbl -> put_Filename(This,strFilename)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFilterInfo_FindPin_Proxy( 
    IFilterInfo * This,
    /* [in] */ BSTR strPinID,
    /* [out] */ IDispatch **ppUnk);


void __RPC_STUB IFilterInfo_FindPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_Name_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ BSTR *strName);


void __RPC_STUB IFilterInfo_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_VendorInfo_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ BSTR *strVendorInfo);


void __RPC_STUB IFilterInfo_get_VendorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_Filter_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFilterInfo_get_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_Pins_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IFilterInfo_get_Pins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_IsFileSource_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ LONG *pbIsSource);


void __RPC_STUB IFilterInfo_get_IsFileSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IFilterInfo_get_Filename_Proxy( 
    IFilterInfo * This,
    /* [retval][out] */ BSTR *pstrFilename);


void __RPC_STUB IFilterInfo_get_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IFilterInfo_put_Filename_Proxy( 
    IFilterInfo * This,
    /* [in] */ BSTR strFilename);


void __RPC_STUB IFilterInfo_put_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IRegFilterInfo_INTERFACE_DEFINED__
#define __IRegFilterInfo_INTERFACE_DEFINED__

/* interface IRegFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IRegFilterInfo,0x56a868bb,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bb-0ad4-11ce-b03a-0020af0ba770")
    IRegFilterInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *strName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Filter( 
            /* [out] */ IDispatch **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRegFilterInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRegFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRegFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRegFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IRegFilterInfo * This,
            /* [retval][out] */ BSTR *strName);
        
        HRESULT ( STDMETHODCALLTYPE *Filter )( 
            IRegFilterInfo * This,
            /* [out] */ IDispatch **ppUnk);
        
        END_INTERFACE
    } IRegFilterInfoVtbl;

    interface IRegFilterInfo
    {
        CONST_VTBL struct IRegFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegFilterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegFilterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegFilterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRegFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRegFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRegFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRegFilterInfo_get_Name(This,strName)	\
    (This)->lpVtbl -> get_Name(This,strName)

#define IRegFilterInfo_Filter(This,ppUnk)	\
    (This)->lpVtbl -> Filter(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IRegFilterInfo_get_Name_Proxy( 
    IRegFilterInfo * This,
    /* [retval][out] */ BSTR *strName);


void __RPC_STUB IRegFilterInfo_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegFilterInfo_Filter_Proxy( 
    IRegFilterInfo * This,
    /* [out] */ IDispatch **ppUnk);


void __RPC_STUB IRegFilterInfo_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IMediaTypeInfo_INTERFACE_DEFINED__
#define __IMediaTypeInfo_INTERFACE_DEFINED__

/* interface IMediaTypeInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaTypeInfo,0x56a868bc,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bc-0ad4-11ce-b03a-0020af0ba770")
    IMediaTypeInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Subtype( 
            /* [retval][out] */ BSTR *strType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaTypeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaTypeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaTypeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaTypeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaTypeInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaTypeInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaTypeInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaTypeInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IMediaTypeInfo * This,
            /* [retval][out] */ BSTR *strType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subtype )( 
            IMediaTypeInfo * This,
            /* [retval][out] */ BSTR *strType);
        
        END_INTERFACE
    } IMediaTypeInfoVtbl;

    interface IMediaTypeInfo
    {
        CONST_VTBL struct IMediaTypeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaTypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaTypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaTypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaTypeInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaTypeInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaTypeInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaTypeInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaTypeInfo_get_Type(This,strType)	\
    (This)->lpVtbl -> get_Type(This,strType)

#define IMediaTypeInfo_get_Subtype(This,strType)	\
    (This)->lpVtbl -> get_Subtype(This,strType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaTypeInfo_get_Type_Proxy( 
    IMediaTypeInfo * This,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IMediaTypeInfo_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMediaTypeInfo_get_Subtype_Proxy( 
    IMediaTypeInfo * This,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IMediaTypeInfo_get_Subtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaTypeInfo_INTERFACE_DEFINED__ */


#ifndef __IPinInfo_INTERFACE_DEFINED__
#define __IPinInfo_INTERFACE_DEFINED__

/* interface IPinInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IPinInfo,0x56a868bd,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bd-0ad4-11ce-b03a-0020af0ba770")
    IPinInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pin( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedTo( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionMediaType( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterInfo( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ LONG *ppDirection) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PinID( 
            /* [retval][out] */ BSTR *strPinID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MediaTypes( 
            /* [retval][out] */ IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IUnknown *pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDirect( 
            /* [in] */ IUnknown *pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectWithType( 
            /* [in] */ IUnknown *pPin,
            /* [in] */ IDispatch *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPinInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPinInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPinInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPinInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPinInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPinInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pin )( 
            IPinInfo * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedTo )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionMediaType )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterInfo )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IPinInfo * This,
            /* [retval][out] */ BSTR *ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            IPinInfo * This,
            /* [retval][out] */ LONG *ppDirection);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinID )( 
            IPinInfo * This,
            /* [retval][out] */ BSTR *strPinID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTypes )( 
            IPinInfo * This,
            /* [retval][out] */ IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectWithType )( 
            IPinInfo * This,
            /* [in] */ IUnknown *pPin,
            /* [in] */ IDispatch *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IPinInfo * This);
        
        END_INTERFACE
    } IPinInfoVtbl;

    interface IPinInfo
    {
        CONST_VTBL struct IPinInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPinInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPinInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPinInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPinInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPinInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPinInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPinInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPinInfo_get_Pin(This,ppUnk)	\
    (This)->lpVtbl -> get_Pin(This,ppUnk)

#define IPinInfo_get_ConnectedTo(This,ppUnk)	\
    (This)->lpVtbl -> get_ConnectedTo(This,ppUnk)

#define IPinInfo_get_ConnectionMediaType(This,ppUnk)	\
    (This)->lpVtbl -> get_ConnectionMediaType(This,ppUnk)

#define IPinInfo_get_FilterInfo(This,ppUnk)	\
    (This)->lpVtbl -> get_FilterInfo(This,ppUnk)

#define IPinInfo_get_Name(This,ppUnk)	\
    (This)->lpVtbl -> get_Name(This,ppUnk)

#define IPinInfo_get_Direction(This,ppDirection)	\
    (This)->lpVtbl -> get_Direction(This,ppDirection)

#define IPinInfo_get_PinID(This,strPinID)	\
    (This)->lpVtbl -> get_PinID(This,strPinID)

#define IPinInfo_get_MediaTypes(This,ppUnk)	\
    (This)->lpVtbl -> get_MediaTypes(This,ppUnk)

#define IPinInfo_Connect(This,pPin)	\
    (This)->lpVtbl -> Connect(This,pPin)

#define IPinInfo_ConnectDirect(This,pPin)	\
    (This)->lpVtbl -> ConnectDirect(This,pPin)

#define IPinInfo_ConnectWithType(This,pPin,pMediaType)	\
    (This)->lpVtbl -> ConnectWithType(This,pPin,pMediaType)

#define IPinInfo_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IPinInfo_Render(This)	\
    (This)->lpVtbl -> Render(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_Pin_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IPinInfo_get_Pin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_ConnectedTo_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IPinInfo_get_ConnectedTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_ConnectionMediaType_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IPinInfo_get_ConnectionMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_FilterInfo_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IPinInfo_get_FilterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_Name_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ BSTR *ppUnk);


void __RPC_STUB IPinInfo_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_Direction_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ LONG *ppDirection);


void __RPC_STUB IPinInfo_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_PinID_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ BSTR *strPinID);


void __RPC_STUB IPinInfo_get_PinID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPinInfo_get_MediaTypes_Proxy( 
    IPinInfo * This,
    /* [retval][out] */ IDispatch **ppUnk);


void __RPC_STUB IPinInfo_get_MediaTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_Connect_Proxy( 
    IPinInfo * This,
    /* [in] */ IUnknown *pPin);


void __RPC_STUB IPinInfo_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_ConnectDirect_Proxy( 
    IPinInfo * This,
    /* [in] */ IUnknown *pPin);


void __RPC_STUB IPinInfo_ConnectDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_ConnectWithType_Proxy( 
    IPinInfo * This,
    /* [in] */ IUnknown *pPin,
    /* [in] */ IDispatch *pMediaType);


void __RPC_STUB IPinInfo_ConnectWithType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_Disconnect_Proxy( 
    IPinInfo * This);


void __RPC_STUB IPinInfo_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinInfo_Render_Proxy( 
    IPinInfo * This);


void __RPC_STUB IPinInfo_Render_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPinInfo_INTERFACE_DEFINED__ */


#ifndef __IAMStats_INTERFACE_DEFINED__
#define __IAMStats_INTERFACE_DEFINED__

/* interface IAMStats */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMStats,0xbc9bcf80,0xdcd2,0x11d2,0xab,0xf6,0x00,0xa0,0xc9,0x05,0xf3,0x75);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc9bcf80-dcd2-11d2-abf6-00a0c905f375")
    IAMStats : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueByIndex( 
            /* [in] */ long lIndex,
            /* [out] */ BSTR *szName,
            /* [out] */ long *lCount,
            /* [out] */ double *dLast,
            /* [out] */ double *dAverage,
            /* [out] */ double *dStdDev,
            /* [out] */ double *dMin,
            /* [out] */ double *dMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueByName( 
            /* [in] */ BSTR szName,
            /* [out] */ long *lIndex,
            /* [out] */ long *lCount,
            /* [out] */ double *dLast,
            /* [out] */ double *dAverage,
            /* [out] */ double *dStdDev,
            /* [out] */ double *dMin,
            /* [out] */ double *dMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [in] */ BSTR szName,
            /* [in] */ long lCreate,
            /* [out] */ long *plIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddValue( 
            /* [in] */ long lIndex,
            /* [in] */ double dValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMStats * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMStats * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMStats * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMStats * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAMStats * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAMStats * This,
            /* [retval][out] */ LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueByIndex )( 
            IAMStats * This,
            /* [in] */ long lIndex,
            /* [out] */ BSTR *szName,
            /* [out] */ long *lCount,
            /* [out] */ double *dLast,
            /* [out] */ double *dAverage,
            /* [out] */ double *dStdDev,
            /* [out] */ double *dMin,
            /* [out] */ double *dMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueByName )( 
            IAMStats * This,
            /* [in] */ BSTR szName,
            /* [out] */ long *lIndex,
            /* [out] */ long *lCount,
            /* [out] */ double *dLast,
            /* [out] */ double *dAverage,
            /* [out] */ double *dStdDev,
            /* [out] */ double *dMin,
            /* [out] */ double *dMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            IAMStats * This,
            /* [in] */ BSTR szName,
            /* [in] */ long lCreate,
            /* [out] */ long *plIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AddValue )( 
            IAMStats * This,
            /* [in] */ long lIndex,
            /* [in] */ double dValue);
        
        END_INTERFACE
    } IAMStatsVtbl;

    interface IAMStats
    {
        CONST_VTBL struct IAMStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMStats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMStats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMStats_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAMStats_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAMStats_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAMStats_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAMStats_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAMStats_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IAMStats_GetValueByIndex(This,lIndex,szName,lCount,dLast,dAverage,dStdDev,dMin,dMax)	\
    (This)->lpVtbl -> GetValueByIndex(This,lIndex,szName,lCount,dLast,dAverage,dStdDev,dMin,dMax)

#define IAMStats_GetValueByName(This,szName,lIndex,lCount,dLast,dAverage,dStdDev,dMin,dMax)	\
    (This)->lpVtbl -> GetValueByName(This,szName,lIndex,lCount,dLast,dAverage,dStdDev,dMin,dMax)

#define IAMStats_GetIndex(This,szName,lCreate,plIndex)	\
    (This)->lpVtbl -> GetIndex(This,szName,lCreate,plIndex)

#define IAMStats_AddValue(This,lIndex,dValue)	\
    (This)->lpVtbl -> AddValue(This,lIndex,dValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMStats_Reset_Proxy( 
    IAMStats * This);


void __RPC_STUB IAMStats_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IAMStats_get_Count_Proxy( 
    IAMStats * This,
    /* [retval][out] */ LONG *plCount);


void __RPC_STUB IAMStats_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStats_GetValueByIndex_Proxy( 
    IAMStats * This,
    /* [in] */ long lIndex,
    /* [out] */ BSTR *szName,
    /* [out] */ long *lCount,
    /* [out] */ double *dLast,
    /* [out] */ double *dAverage,
    /* [out] */ double *dStdDev,
    /* [out] */ double *dMin,
    /* [out] */ double *dMax);


void __RPC_STUB IAMStats_GetValueByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStats_GetValueByName_Proxy( 
    IAMStats * This,
    /* [in] */ BSTR szName,
    /* [out] */ long *lIndex,
    /* [out] */ long *lCount,
    /* [out] */ double *dLast,
    /* [out] */ double *dAverage,
    /* [out] */ double *dStdDev,
    /* [out] */ double *dMin,
    /* [out] */ double *dMax);


void __RPC_STUB IAMStats_GetValueByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStats_GetIndex_Proxy( 
    IAMStats * This,
    /* [in] */ BSTR szName,
    /* [in] */ long lCreate,
    /* [out] */ long *plIndex);


void __RPC_STUB IAMStats_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStats_AddValue_Proxy( 
    IAMStats * This,
    /* [in] */ long lIndex,
    /* [in] */ double dValue);


void __RPC_STUB IAMStats_AddValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMStats_INTERFACE_DEFINED__ */

#endif /* __QuartzTypeLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\cpl.h ===
/*****************************************************************************\
*                                                                             *
* cpl.h -       Control panel extension DLL definitions                       *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992-1999, Microsoft Corp.  All rights reserved *
*                                                                             *
******************************************************************************/
/*
*  General rules for being installed in the Control Panel:
*
*      1) The DLL must export a function named CPlApplet which will handle
*         the messages discussed below.
*      2) If the applet needs to save information in CONTROL.INI minimize
*         clutter by using the application name [MMCPL.appletname].
*      2) If the applet is refrenced in CONTROL.INI under [MMCPL] use
*         the following form:
*              ...
*              [MMCPL]
*              uniqueName=c:\mydir\myapplet.dll
*              ...
*
*
*  The order applet DLL's are loaded by CONTROL.EXE is not guaranteed.
*  Control panels may be sorted for display, etc.
*
*/
#ifndef _INC_CPL
#define _INC_CPL


#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

/*
 * CONTROL.EXE will answer this message and launch an applet
 *
 * WM_CPL_LAUNCH
 *
 *      wParam      - window handle of calling app
 *      lParam      - LPTSTR of name of applet to launch
 *
 * WM_CPL_LAUNCHED
 *
 *      wParam      - TRUE/FALSE if applet was launched
 *      lParam      - NULL
 *
 * CONTROL.EXE will post this message to the caller when the applet returns
 * (ie., when wParam is a valid window handle)
 *
 */
#define WM_CPL_LAUNCH   (WM_USER+1000)
#define WM_CPL_LAUNCHED (WM_USER+1001)

/* A function prototype for CPlApplet() */

//typedef LRESULT (APIENTRY *APPLET_PROC)(HWND hwndCpl, UINT msg, LPARAM lParam1, LPARAM lParam2);
typedef LONG (APIENTRY *APPLET_PROC)(HWND hwndCpl, UINT msg, LPARAM lParam1, LPARAM lParam2);

/* The data structure CPlApplet() must fill in. */

typedef struct tagCPLINFO
{
    int         idIcon;     /* icon resource id, provided by CPlApplet() */
    int         idName;     /* name string res. id, provided by CPlApplet() */
    int         idInfo;     /* info string res. id, provided by CPlApplet() */
    LONG_PTR    lData;      /* user defined data */
} CPLINFO, *LPCPLINFO;

typedef struct tagNEWCPLINFOA
{
    DWORD   dwSize;         /* similar to the commdlg */
    DWORD   dwFlags;
    DWORD   dwHelpContext;  /* help context to use */
    LONG_PTR lData;         /* user defined data */
    HICON   hIcon;          /* icon to use, this is owned by CONTROL.EXE (may be deleted) */
    CHAR    szName[32];     /* short name */
    CHAR    szInfo[64];     /* long name (status line) */
    CHAR    szHelpFile[128];/* path to help file to use */
} NEWCPLINFOA, *LPNEWCPLINFOA;
typedef struct tagNEWCPLINFOW
{
    DWORD   dwSize;         /* similar to the commdlg */
    DWORD   dwFlags;
    DWORD   dwHelpContext;  /* help context to use */
    LONG_PTR lData;         /* user defined data */
    HICON   hIcon;          /* icon to use, this is owned by CONTROL.EXE (may be deleted) */
    WCHAR   szName[32];     /* short name */
    WCHAR   szInfo[64];     /* long name (status line) */
    WCHAR   szHelpFile[128];/* path to help file to use */
} NEWCPLINFOW, *LPNEWCPLINFOW;
#ifdef UNICODE
typedef NEWCPLINFOW NEWCPLINFO;
typedef LPNEWCPLINFOW LPNEWCPLINFO;
#else
typedef NEWCPLINFOA NEWCPLINFO;
typedef LPNEWCPLINFOA LPNEWCPLINFO;
#endif // UNICODE

#if(WINVER >= 0x0400)
#define CPL_DYNAMIC_RES 0
// This constant may be used in place of real resource IDs for the idIcon,
// idName or idInfo members of the CPLINFO structure.  Normally, the system
// uses these values to extract copies of the resources and store them in a
// cache.  Once the resource information is in the cache, the system does not
// need to load a CPL unless the user actually tries to use it.
// CPL_DYNAMIC_RES tells the system not to cache the resource, but instead to
// load the CPL every time it needs to display information about an item.  This
// allows a CPL to dynamically decide what information will be displayed, but
// is SIGNIFICANTLY SLOWER than displaying information from a cache.
// Typically, CPL_DYNAMIC_RES is used when a control panel must inspect the
// runtime status of some device in order to provide text or icons to display.

#endif /* WINVER >= 0x0400 */

/* The messages CPlApplet() must handle: */

#define CPL_INIT        1
/*  This message is sent to indicate CPlApplet() was found. */
/*  lParam1 and lParam2 are not defined. */
/*  Return TRUE or FALSE indicating whether the control panel should proceed. */

#define CPL_GETCOUNT    2
/*  This message is sent to determine the number of applets to be displayed. */
/*  lParam1 and lParam2 are not defined. */
/*  Return the number of applets you wish to display in the control */
/*  panel window. */


#define CPL_INQUIRE     3
/*  This message is sent for information about each applet. */

/*  A CPL SHOULD HANDLE BOTH THE CPL_INQUIRE AND CPL_NEWINQUIRE MESSAGES. */
/*  The developer must not make any assumptions about the order or dependance */
/*  of CPL inquiries. */

/*  lParam1 is the applet number to register, a value from 0 to */
/*  (CPL_GETCOUNT - 1).  lParam2 is a far ptr to a CPLINFO structure. */
/*  Fill in CPLINFO's idIcon, idName, idInfo and lData fields with */
/*  the resource id for an icon to display, name and description string ids, */
/*  and a long data item associated with applet #lParam1.  This information */
/*  may be cached by the caller at runtime and/or across sessions. */
/*  To prevent caching, see CPL_DYNAMIC_RES, above.  */


#define CPL_SELECT      4
/*  The CPL_SELECT message has been deleted. */


#define CPL_DBLCLK      5
/*  This message is sent when the applet's icon has been double-clicked */
/*  upon.  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */
/*  This message should initiate the applet's dialog box. */


#define CPL_STOP        6
/*  This message is sent for each applet when the control panel is exiting. */
/*  lParam1 is the applet number.  lParam2 is the applet's lData  value. */
/*  Do applet specific cleaning up here. */


#define CPL_EXIT        7
/*  This message is sent just before the control panel calls FreeLibrary. */
/*  lParam1 and lParam2 are not defined. */
/*  Do non-applet specific cleaning up here. */


#define CPL_NEWINQUIRE    8
/* Same as CPL_INQUIRE execpt lParam2 is a pointer to a NEWCPLINFO struct. */

/*  A CPL SHOULD HANDLE BOTH THE CPL_INQUIRE AND CPL_NEWINQUIRE MESSAGES. */
/*  The developer must not make any assumptions about the order or dependance */
/*  of CPL inquiries. */

#if(WINVER >= 0x0400)
#define CPL_STARTWPARMSA 9
#define CPL_STARTWPARMSW 10
#ifdef UNICODE
#define CPL_STARTWPARMS CPL_STARTWPARMSW
#else
#define CPL_STARTWPARMS CPL_STARTWPARMSA
#endif

/* this message parallels CPL_DBLCLK in that the applet should initiate
** its dialog box.  where it differs is that this invocation is coming
** out of RUNDLL, and there may be some extra directions for execution.
** lParam1: the applet number.
** lParam2: an LPSTR to any extra directions that might exist.
** returns: TRUE if the message was handled; FALSE if not.
*/
#endif /* WINVER >= 0x0400 */


/* This message is internal to the Control Panel and MAIN applets.  */
/* It is only sent when an applet is invoked from the Command line  */
/* during system installation.                                      */
#define CPL_SETUP               200

#ifdef __cplusplus
}
#endif    /* __cplusplus */

#include <poppack.h>

#endif  /* _INC_CPL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\convregh.h ===
// --convregh.h-----------------------------------------------------------------
//
//  Conversion registry helper routines.
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#ifndef _CONVREGH_H
#define _CONVREGH_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//$--HrGetArbSizeValue---------------------------------------------------------
//
//  DESCRIPTION: Allocate sufficient memory to read a value from the the registry 
//  and read it.  
//
//  INPUT:  hk  --  key that contains value
//          lpszValueName   --  name of value
//       
//  OUTPUT: pValue  --  pointer to key's value
//          cbSize  --  size of value (including null)
//          nType   --  type of value
//
//  RETURNS:    HRESULT -   NOERROR if successful,
//                          E_INVALIDARG if bad input,
//                          E_EOF if key not found,
//                          E_FAIL otherwise.
//
//------------------------------------------------------------------------------
HRESULT HrGetArbSizeValue(       // RETURNS: HRESULT
    IN HKEY hk,                 // key that contains the value
    IN LPWSTR lpszValueName,    // name of the value
    OUT PVOID & pValue,         // pointer to its value
    OUT DWORD & cbSize,         // how big is it (including trailing null(s)
    OUT DWORD & nType);         // what type

//$--HrStrstriW-------------------------------------------------------
//
// DESCRIPTION: determines whether one string is a prefix of another.
// case sensitive.
//
// INPUT:   pszSubString   --  the sub-string to check for
//          pszString   --  the string
//
// RETURNS: HRESULT --  NOERROR if sub-string exists in string,
//                      E_FAIL otherwise.
//
//---------------------------------------------------------------------
HRESULT HrStrstriW( 
    IN LPCWSTR pszSubString,    // the candidate sub-string
    IN LPCWSTR pszString);      // the string.

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\CrsSink.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Apr 23 13:48:22 1998
 */
/* Compiler settings for crssink.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __crssink_h__
#define __crssink_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IReplicationEventSink_FWD_DEFINED__
#define __IReplicationEventSink_FWD_DEFINED__
typedef interface IReplicationEventSink IReplicationEventSink;
#endif 	/* __IReplicationEventSink_FWD_DEFINED__ */


#ifndef __SiteServerEventSink_FWD_DEFINED__
#define __SiteServerEventSink_FWD_DEFINED__

#ifdef __cplusplus
typedef class SiteServerEventSink SiteServerEventSink;
#else
typedef struct SiteServerEventSink SiteServerEventSink;
#endif /* __cplusplus */

#endif 	/* __SiteServerEventSink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IReplicationEventSink_INTERFACE_DEFINED__
#define __IReplicationEventSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationEventSink
 * at Thu Apr 23 13:48:22 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8072C46F-C89A-11D0-BAF5-00C04FD7082F")
    IReplicationEventSink : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ BSTR szName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnEvent( 
            /* [in] */ VARIANT __RPC_FAR *pvEvent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationEventSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationEventSink __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationEventSink __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationEventSink __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReplicationEventSink __RPC_FAR * This,
            /* [string][in] */ BSTR szName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Shutdown )( 
            IReplicationEventSink __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEvent )( 
            IReplicationEventSink __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvEvent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IReplicationEventSink __RPC_FAR * This);
        
        END_INTERFACE
    } IReplicationEventSinkVtbl;

    interface IReplicationEventSink
    {
        CONST_VTBL struct IReplicationEventSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationEventSink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationEventSink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationEventSink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationEventSink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationEventSink_Initialize(This,szName)	\
    (This)->lpVtbl -> Initialize(This,szName)

#define IReplicationEventSink_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define IReplicationEventSink_OnEvent(This,pvEvent)	\
    (This)->lpVtbl -> OnEvent(This,pvEvent)

#define IReplicationEventSink_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSink_Initialize_Proxy( 
    IReplicationEventSink __RPC_FAR * This,
    /* [string][in] */ BSTR szName);


void __RPC_STUB IReplicationEventSink_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSink_Shutdown_Proxy( 
    IReplicationEventSink __RPC_FAR * This);


void __RPC_STUB IReplicationEventSink_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSink_OnEvent_Proxy( 
    IReplicationEventSink __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvEvent);


void __RPC_STUB IReplicationEventSink_OnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSink_Clear_Proxy( 
    IReplicationEventSink __RPC_FAR * This);


void __RPC_STUB IReplicationEventSink_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationEventSink_INTERFACE_DEFINED__ */



#ifndef __SiteServerEventSinkLib_LIBRARY_DEFINED__
#define __SiteServerEventSinkLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SiteServerEventSinkLib
 * at Thu Apr 23 13:48:22 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_SiteServerEventSinkLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SiteServerEventSink;

class DECLSPEC_UUID("F03E09B6-CCAC-11D0-BAF6-00C04FD7082F")
SiteServerEventSink;
#endif
#endif /* __SiteServerEventSinkLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\CrsTypes.h ===
//====================================================================
//                                                                     
//   Microsoft Site Server v3.00                                   
//                                                                     
//   Copyright (c) 1997 - 1999 Microsoft Corporation.  All rights reserved.   
//   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
//   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//   PARTICULAR PURPOSE.
//=====================================================================

// Module Name:
//
//    crstypes.h
//
// Abstract:
//
//    This module defines the common structures and prototypes for the   
//    Content Deployment Service API (ProgId = CrsApi)
//
// Revision History:
//

#ifndef CRSTYPES_INCLUDED
#define CRSTYPES_INCLUDED

typedef enum CRS_PROJECT_CREATION
{
   CREATE_NEW_PROJECT = 0x1,
   OPEN_EXISTING_PROJECT = 0x2
} CRS_PROJECT_CREATION;

typedef enum CRS_SERVER_TYPES
{
   STAGER = 0x1,
   ENDPOINT = 0x2
} CRS_SERVER_TYPES;

typedef enum CRS_SCHEDULE_ACTION
{
   CRS_SCHEDULE_APPLY = 0x1,
   CRS_SCHEDULE_REPLICATE = 0x2
} CRS_SCHEDULE_ACTION;

#define MAX_PATH    260
#define MAX_PROJECT 50
#define MAX_LOCATION 300
#define MAX_DESTINATION_BUFFER 0x1000
#define MAX_ROUTE_NAME 50
#define MAX_REPLID	40


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define NOREF(x) x=x

// @DOC 

#define RF_NO_DELETE			1		
#define RF_REPLICATE_ACLS		(1 << 1)	
#define RF_NO_DATA				(1 << 2)	
#define RF_FORCE_REPL			(1 << 3)	
#define RF_PERMIT_TREE			(1 << 4)
#define RF_IN_PROC				(1 << 5)	
#define RF_INCREMENTAL			(1 << 6)	
#define RF_FASTMODE				(1 << 7)
#define RF_ON_DIR_CHANGE		(1 << 8)
#define RF_AUTO_ROUTE			(1 << 9)
#define RF_ON_NOTIFY			(1 << 10)
#define RF_NO_CHAIN				(1 << 11)
#define RF_EXCLUDE_ALL			(1 << 12)
#define RF_UNINSTALL			(1 << 13)
#define RF_ACLS_ONLY			(1 << 14)

#define RF_DELETE				(1 << 16)
#define RF_NO_REPLICATE_ACLS    (1 << 17)
#define RF_DATA					(1 << 18)	
#define RF_NO_FORCE_REPL		(1 << 19)	
#define RF_NO_PERMIT_TREE		(1 << 20)
#define RF_NO_IN_PROC			(1 << 21)
#define RF_NO_INCREMENTAL		(1 << 22)	
#define RF_NO_FASTMODE			(1 << 23)
#define RF_NO_ON_DIR_CHANGE		(1 << 24)
#define RF_NO_AUTO_ROUTE		(1 << 25)
#define RF_NO_ON_NOTIFY         (1 << 26)
#define RF_CHAIN				(1 << 27)
#define RF_NO_ACLS_ONLY			(1 << 30)


#define REPL_STATE_EMPTY	 0  
#define REPL_STATE_STARTING  1
#define REPL_STATE_RUNNING   2
#define REPL_STATE_COMPLETE  3
#define REPL_STATE_ABORTED   4
#define REPL_STATE_CANCELED	 5
#define REPL_STATE_RECEIVING 6
#define REPL_STATE_PENDING   7
#define REPL_STATE_PARTIAL   8



#define CP_PROPOGATE_ALL		 1


#define	 MAX_PARM_STRING	300

// PARMSET flags
#define PARM_ADD_STRINGS	1 // valid only if dwType is REG_MULTI_SZ, adds strings to the value if they're not already there
#define PARM_DEL_STRINGS	2 // valid only if dwType is REG_MULTI_SZ, removes strings from the value if they're there
#define PARM_DEL_EMPTYPROJ	6 // deletes project if the REG_MULTI_SZ parm becomes empty, implies PARM_DEL_STRINGS
// SetProject flags
#define SET_PROJ_CHAIN             1 // chains the SetProject call via specified destination
#define SET_PROJ_CHAIN_ALL_ROUTES  3 // chains the SetProject call via all of project's destinations, implies SET_CHAIN


typedef DWORD REPL_INSTANCE; // @type REPLICATION_INSTANCE | Identifier of a particular replication instance. Needed to call any function which manipulates or queries and existing replication


// @struct REPLICATION_COUNTERS | Counters used to record replication information. Returned by QueryReplication.
typedef struct _REPL_COUNTERS
{
	DWORD dwStartStamp;		      //@field Start Time
	DWORD dwFilesSent; 		      //@field The Total files that have been sent across this connection.
	DWORD dwFilesReceived;	      //@field The total files that have been received across this connection.
	DWORD dwFilesMatched;         //@field The number of files that matched and did not need to be sent
	DWORD dwFilesErrored;         //@field The number of files which had errors
	DWORD dwBytesSent;            //@field The total bytes sent across this connection.
	DWORD dwBytesReceived;        //@field The total bytes received across this connection.
	DWORD dwBytesMatched;         //@field The total bytes which matched and did not need to be sent.
	DWORD dwBytesErrored;         //@field The total bytes errored

	DWORD dwDirectoriesProcessed; //@field The number of directories processed

} REPL_COUNTERS;


//@struct REPLICATION_INFO_W | Contains information about a particular replication instance. 
// Is returned by <f QueryReplication> and <f EnumReplications>.
typedef struct _REPL_INFO
{
	REPL_INSTANCE hInstance; //@field The instance id for this replication.
	WCHAR cProject[MAX_PROJECT];    //@field The project associated with this replication.
	DWORD dwState;                  //@field The Current State of this replication
	// @flag REPL_STATE_EMPTY	  | This Replication Info structure is empty.
	// @flag REPL_STATE_STARTING  | The replication is a startup state.
	// @flag REPL_STATE_RUNNING   | The replication is currently running.
	// @flag REPL_STATE_COMPLETE  | The replication is complete.
	// @flag REPL_STATE_ABORTED   | The replication aborted due to an error.
	// @flag REPL_STATE_CANCLED	  | The replication was canceled.
	// @flag REPL_STATE_RECEIVING | The replication is receiving data.										
	// @flag REPL_STATE_PENDING   | The replication is pending start. 										
	DWORD dwError;	                // @field An error code if the replication aborted
	DWORD dwFlags;		            //@field Flags this replication was started with.
// @flag RF_NO_DELETE         | Turns of Delete Processing
// @flag RF_REPLICATE_ACLS    | Replicates ACL's
// @flag RF_NO_DATA           | Skips Replicating Data, will only replicate directories.
// @flag RF_FORCE_REPL        | Forces data to be replicated without checking first
// @flag RF_IN_PROC	          | Causes the StartReplication API to run in process (note: This blocks!)
// @flag RF_INCREMENTAL       | Runs replication in "Incremental" mode, meaning that only files which have been locally detected to have been modified since the last replication are checked and sent.
// @flag RF_FASTMODE          | Uses Unframed Protocol for enhanced performance over faster/secure links.
// @flag RF_ON_DIR_CHANGE     | Turns on monitor mode.  This will monitor a directory for changes and then replicate them to the destination.
// @flag RF_AUTO_ROUTE		  | Uses information in the routing table to determine destinations servers.
// @flag RF_NOTIFY            | Turns on notify mode.  Replications occur based on notifications from the IAcceptNotify COM interface.
// @flag RF_PERMIT_TREE       | Applies ACLs on the directory structure to the files beneath it.
	
} REPL_INFO;


//@struct ROUTE_LIST_W | Returns the list of routes defined for a server.
// Is returned by <f ListRoutes>.
typedef struct _ROUTE_INFO
{
	WCHAR cRouteName[MAX_PROJECT];		//@field Name of the route.
	WCHAR cDestinations[MAX_LOCATION];  //@field Multi-string list of destinations (format "dest1\0dest2\0\0")
	WCHAR cBaseDirectory[MAX_LOCATION]; //@field Base directory for projects using this route.

} ROUTE_INFO;

//@struct PARMSET_W | Defines a Parameter for <f CreateNewProject>, <f SetProject>, and <f QueryProject>.
typedef struct _PARAM
{
	DWORD dwType;					   //@field Parameter Type (Registry type values, REG_SZ, etc).
	DWORD dwFlags;                     //@field Parameter flags
	DWORD dwSize;                      //@field Size of value parameter
	WCHAR cParmName[MAX_PARM_STRING];  //@field Parameter Name
	WCHAR cParmValue[MAX_PARM_STRING]; //@field Parameter Value
}PARAM;


//@struct PARM_LIST | Contains a list of parameters to pass with <f CreateNewProject>, <f SetProject>, <f QueryProject>.
typedef struct _PARAM_LIST
{
	DWORD dwNumParms; // @field The number of Parameters in this list
	PARAM Params[1]; // @field An array of Parameters
} PARAM_LIST;


#define CRS_STOP_SERVICE    (1<<1)
#define CRS_PAUSE_SERVICE   (1<<2)
#define CRS_RESUME_SERVICE  (1<<3)
#define CRS_START_SERVICE   (1<<4)

#define CRS_USER_ACCESS   ( KEY_READ )
#define CRS_ADMIN_ACCESS  ( KEY_ALL_ACCESS | READ_CONTROL )

#define CRS_SZ          ( REG_SZ )
#define CRS_MULTI_SZ    ( REG_MULTI_SZ )
#define CRS_DWORD       ( REG_DWORD )
#define CRS_DATE        ( REG_BINARY )


#define CRS_END_OF_LIST (0xffffffff)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\cplext.h ===
///////////////////////////////////////////////////////////////////////////////
//
// CPLEXT.H  --  defines for property sheet extensions to system control panels
//
// Version 4.00
//
// Copyright (c) 1992-1999, Microsoft Corp. All rights reserved
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _INC_CPLEXT
#define _INC_CPLEXT


///////////////////////////////////////////////////////////////////////////////
//  Below are constants for pages which can be replaced in the standard control
// panel applets.  To extend an applet, you must define an object which
// supports the IShellPropSheetExt interface and register it's in-process
// server in a subkey under the applet's registry key.  Registry paths for the
// applets are defined in the header file REGSTR.H
//  Generally, when an IShellPropSheetExt is loaded, it's AddPages method
// will be called once, while it's ReplacePage method may be called zero or
// more times.  ReplacePage is only called in context.
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Mouse Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Mouse" )
//-----------------------------------------------------------------------------

#define CPLPAGE_MOUSE_BUTTONS       1
#define CPLPAGE_MOUSE_PTRMOTION     2


//-----------------------------------------------------------------------------
// Keyboard Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Keyboard" )
//-----------------------------------------------------------------------------

#define CPLPAGE_KEYBOARD_SPEED      1


//-----------------------------------------------------------------------------
// Display Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Display" )
//-----------------------------------------------------------------------------

#define CPLPAGE_DISPLAY_BACKGROUND  1


///////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\CrsMsg.h ===
//====================================================================
//                                                                     
//   Microsoft Site Server v3.00                                   
//                                                                     
//   Copyright (c) 1997 - 1999 Microsoft Corporation.  All rights reserved.   
//   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
//   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//   PARTICULAR PURPOSE.
//=====================================================================

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: CRS_ERROR_FIRST
//
// MessageText:
//
//  Site Server Content Deployment service first error message.
//
#define CRS_ERROR_FIRST                  0x40003A98L

//
// MessageId: CRS_NET_SOURCE
//
// MessageText:
//
//  Source directory %2 for the project %1 is on a network drive.  Cannot deploy from network drives.
//
#define CRS_NET_SOURCE                   0xC0003A9CL

//
// MessageId: CRS_ERROR_ACCESS_DENIED
//
// MessageText:
//
//  Access denied.
//
#define CRS_ERROR_ACCESS_DENIED          0xC0003A9DL

//
// MessageId: CRS_FILE_CREATE_ERROR
//
// MessageText:
//
//  Unable to open the file %1.
//
#define CRS_FILE_CREATE_ERROR            0xC0003A9EL

//
// MessageId: CRS_SENDINET_ERROR
//
// MessageText:
//
//  Project was unable to send file %1.
//
#define CRS_SENDINET_ERROR               0xC0003A9FL

//
// MessageId: CRS_SAMEBOX_NET_TARGET
//
// MessageText:
//
//  Destination directory %2 for the project %1 is on a network drive.  Cannot deploy to network drives.
//
#define CRS_SAMEBOX_NET_TARGET           0xC0003AA0L

//
// MessageId: CRS_BAD_SOURCE
//
// MessageText:
//
//  Unable to access the project source %1.
//
#define CRS_BAD_SOURCE                   0xC0003AA1L

//
// MessageId: CRS_SENDINET_CONNECT
//
// MessageText:
//
//  Unable to connect to the remote server %1.
//
#define CRS_SENDINET_CONNECT             0xC0003AA2L

//
// MessageId: CRS_HASH_MISMATCH
//
// MessageText:
//
//  MD5 Hash did not match during a transmission.  This could indicate transmission failure or that the files transmitted at the source have been modified in transit.
//
#define CRS_HASH_MISMATCH                0xC0003AA3L

//
// MessageId: CRS_SERVER_ABORTED
//
// MessageText:
//
//  Remote server was restarted.  The project %1 is being restarted.
//
#define CRS_SERVER_ABORTED               0xC0003AA4L

//
// MessageId: CRS_REPLICATION_ABORTED
//
// MessageText:
//
//  Project %1 was aborted.
//
#define CRS_REPLICATION_ABORTED          0xC0003AA5L

//
// MessageId: CRS_SEQUENCE_ERROR
//
// MessageText:
//
//  An internal messaging sequence error occurred.
//
#define CRS_SEQUENCE_ERROR               0xC0003AA6L

//
// MessageId: CRS_SERVICE_STARTED
//
// MessageText:
//
//  Site Server Content Deployment service started successfully.
//
#define CRS_SERVICE_STARTED              0x40003AA7L

//
// MessageId: CRS_SERVICE_SHUTDOWN
//
// MessageText:
//
//  Site Server Content Deployment service shut down successfully.
//
#define CRS_SERVICE_SHUTDOWN             0x40003AA8L

//
// MessageId: CRS_ERROR_METABASE_ACCESS
//
// MessageText:
//
//  Could not open storage/stream %1.  Ensure the authentication account has access to this storage/stream.
//
#define CRS_ERROR_METABASE_ACCESS        0xC0003AAAL

//
// MessageId: CRS_AUTH_FAILURE
//
// MessageText:
//
//  Authorization failure against server %1.  Ensure the service has access to this server.
//
#define CRS_AUTH_FAILURE                 0xC0003AABL

//
// MessageId: CRS_REMOTE_AUTH_FAILURE
//
// MessageText:
//
//  Remote authorization failed to server %1.  Ensure the service has access to this server.
//
#define CRS_REMOTE_AUTH_FAILURE          0xC0003AACL

//
// MessageId: CRS_ERROR_NOT_IN_ORDER
//
// MessageText:
//
//  Message was received out of order.  Closing connection.
//
#define CRS_ERROR_NOT_IN_ORDER           0xC0003AADL

//
// MessageId: CRS_CONNECTION_RETRY_FAILED
//
// MessageText:
//
//  Connection to server %1 failed and could not be re-established.
//
#define CRS_CONNECTION_RETRY_FAILED      0xC0003AAEL

//
// MessageId: CRS_ERROR_REPLICATION_CANCELED
//
// MessageText:
//
//  Project %1 canceled at the request of the user.
//
#define CRS_ERROR_REPLICATION_CANCELED   0xC0003AAFL

//
// MessageId: CRS_ERROR_DEST_TOOBIG
//
// MessageText:
//
//  Could not add the specified destination(s).  The maximum number of destinations has been reached.
//
#define CRS_ERROR_DEST_TOOBIG            0xC0003AB0L

//
// MessageId: CRS_ERROR_NO_IP_MAPPING
//
// MessageText:
//
//  Cannot resolve IP address for server %1.  No virtual root created.
//
#define CRS_ERROR_NO_IP_MAPPING          0xC0003AB1L

//
// MessageId: CRS_ERROR_DISK_FULL
//
// MessageText:
//
//  Not enough space on the disk.
//
#define CRS_ERROR_DISK_FULL              0xC0003AB2L

//
// MessageId: CRS_ERROR_TOO_MANY_RUNNING
//
// MessageText:
//
//  Too many active projects. No more can be started until others complete.
//
#define CRS_ERROR_TOO_MANY_RUNNING       0xC0003AB3L

//
// MessageId: CRS_ERROR_WOULDBLOCK
//
// MessageText:
//
//  The network operation would block.
//
#define CRS_ERROR_WOULDBLOCK             0x00003ABBL

//
// MessageId: CRS_ERROR_NETDOWN
//
// MessageText:
//
//  The remote network is down.
//
#define CRS_ERROR_NETDOWN                0xC0003ACAL

//
// MessageId: CRS_ERROR_NETUNREACH
//
// MessageText:
//
//  The remote network is unreachable.
//
#define CRS_ERROR_NETUNREACH             0xC0003ACBL

//
// MessageId: CRS_ERROR_CONNABORTED
//
// MessageText:
//
//  The network connection was aborted at the network layer.
//
#define CRS_ERROR_CONNABORTED            0xC0003ACDL

//
// MessageId: CRS_ERROR_TIMEOUT
//
// MessageText:
//
//  The network session timed out on a send or receive operation.
//
#define CRS_ERROR_TIMEOUT                0xC0003AD4L

//
// MessageId: WINSOCK_WSAEWOULDBLOCK
//
// MessageText:
//
//  The network operation would block.
//
#define WINSOCK_WSAEWOULDBLOCK           0x00002733L

//
// MessageId: WINSOCK_WSAENETDOWN
//
// MessageText:
//
//  The remote network is down.
//
#define WINSOCK_WSAENETDOWN              0x00002742L

//
// MessageId: WINSOCK_WSAENETUNREACH
//
// MessageText:
//
//  The remote network is unreachable.
//
#define WINSOCK_WSAENETUNREACH           0x00002743L

//
// MessageId: WINSOCK_WSAECONNABORTED
//
// MessageText:
//
//  The network connection was aborted at the network layer.
//
#define WINSOCK_WSAECONNABORTED          0x00002745L

//
// MessageId: WINSOCK_WSAECONNRESET
//
// MessageText:
//
//  The network session was aborted.
//
#define WINSOCK_WSAECONNRESET            0x00002746L

//
// MessageId: WINSOCK_WSAETIMEDOUT
//
// MessageText:
//
//  The network session timed out on a send or receive operation.
//
#define WINSOCK_WSAETIMEDOUT             0x0000274CL

//
// MessageId: WINSOCK_WSAECONNREFUSED
//
// MessageText:
//
//  The remote server was not listening on the appropriate port. This generally indicates that the service was not running but the server is up.
//
#define WINSOCK_WSAECONNREFUSED          0x0000274DL

//
// MessageId: CRS_ERROR_NO_PROJECTS
//
// MessageText:
//
//  No projects defined.
//
#define CRS_ERROR_NO_PROJECTS            0xC0003AFCL

//
// MessageId: CRS_ERROR_PROJECT_NOT_FOUND
//
// MessageText:
//
//  Could not find project %1.
//
#define CRS_ERROR_PROJECT_NOT_FOUND      0xC0003AFDL

//
// MessageId: CRS_ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  Invalid parameter.
//
#define CRS_ERROR_INVALID_PARAMETER      0xC0003AFEL

//
// MessageId: CRS_PROJECT_CREATED
//
// MessageText:
//
//  Created project %1.
//
#define CRS_PROJECT_CREATED              0xC0003AFFL

//
// MessageId: CRS_ERROR_AUTHENTICATION_FAILURE
//
// MessageText:
//
//  Authentication failure.  Ensure the account has proper access on local and remote servers.
//
#define CRS_ERROR_AUTHENTICATION_FAILURE 0xC0003B00L

//
// MessageId: CRS_ERROR_DELETE_PROJECT_DOWN_ROUTE
//
// MessageText:
//
//  Could not delete the route from the project on at least one server down the defined routes.  The project will have to be edited manually there.
//
#define CRS_ERROR_DELETE_PROJECT_DOWN_ROUTE 0x80003B01L

//
// MessageId: CRS_ERROR_SERVICE_NOT_RUNNING
//
// MessageText:
//
//  Server %1 is available, but the Site Server Content Deployment service is not running.
//
#define CRS_ERROR_SERVICE_NOT_RUNNING    0xC0003B02L

//
// MessageId: CRS_ERROR_HOST_DOWN
//
// MessageText:
//
//  Server %1 is unavailable.
//
#define CRS_ERROR_HOST_DOWN              0xC0003B03L

//
// MessageId: CRS_ERROR_BAD_NET_NAME
//
// MessageText:
//
//  Server %1 cannot be found.
//
#define CRS_ERROR_BAD_NET_NAME           0xC0003B04L

//
// MessageId: CRS_ERROR_ROUTE_NOT_FOUND
//
// MessageText:
//
//  Could not find route %1.  Ensure the route name is correct and that it exists on the target servers.
//
#define CRS_ERROR_ROUTE_NOT_FOUND        0xC0003B05L

//
// MessageId: CRS_ERROR_NO_ROUTES
//
// MessageText:
//
//  No routes defined.
//
#define CRS_ERROR_NO_ROUTES              0xC0003B06L

//
// MessageId: CRS_ERROR_CREATE_PROJECT_DOWN_ROUTE
//
// MessageText:
//
//  Could not create the project on at least one server down the defined routes.  The project will have to be created manually there.
//
#define CRS_ERROR_CREATE_PROJECT_DOWN_ROUTE 0x80003B07L

//
// MessageId: CRS_ERROR_SERVICE_PAUSED
//
// MessageText:
//
//  Site Server Content Deployment service on server %1 is paused and is not accepting new requests.  Retry project %2 later.
//
#define CRS_ERROR_SERVICE_PAUSED         0xC0003B08L

//
// MessageId: CRS_ERROR_SERVICE_NOT_PAUSED
//
// MessageText:
//
//  Could not restart service. Service is not paused.
//
#define CRS_ERROR_SERVICE_NOT_PAUSED     0xC0003B09L

//
// MessageId: CRS_ERROR_NAME_NOT_RESOLVED
//
// MessageText:
//
//  Could not resolve URL %2 for project %1.  Ensure URL and/or proxy settings are correct.
//
#define CRS_ERROR_NAME_NOT_RESOLVED      0xC0003B0AL

//
// MessageId: CRS_ERROR_CONNECTION_RESET
//
// MessageText:
//
//  Connection to server %1 has been reset.  This indicates problems with the remote service or network.
//
#define CRS_ERROR_CONNECTION_RESET       0xC0003B0BL

//
// MessageId: CRS_ERROR_REPLICATION_NOT_FOUND
//
// MessageText:
//
//  No entries.
//
#define CRS_ERROR_REPLICATION_NOT_FOUND  0xC0003B0CL

//
// MessageId: CRS_ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
//  Could not start service.  The service has already been started.
//
#define CRS_ERROR_SERVICE_ALREADY_RUNNING 0xC0003B0DL

//
// MessageId: CRS_ERROR_PROJECT_ALREADY_RUNNING
//
// MessageText:
//
//  Failed to start project %1.  It is already running.
//
#define CRS_ERROR_PROJECT_ALREADY_RUNNING 0xC0003B0EL

//
// MessageId: CRS_ERROR_FILE_MOVE_ERROR
//
// MessageText:
//
//  Failed to move file %1 to %2.
//
#define CRS_ERROR_FILE_MOVE_ERROR        0xC0003B0FL

//
// MessageId: CRS_ERROR_PRODUCT_EXPIRED
//
// MessageText:
//
//  Thank you for your interest in Site Server Content Deployment.  This software has expired.  Please acquire the final retail version of this software.
//
#define CRS_ERROR_PRODUCT_EXPIRED        0xC0003B10L

//
// MessageId: CRS_ERROR_PROJECT_INCOMPLETE
//
// MessageText:
//
//  Project information for %1 is incomplete.
//
#define CRS_ERROR_PROJECT_INCOMPLETE     0xC0003B11L

//
// MessageId: CRS_ERROR_PARAMETER_NOT_FOUND
//
// MessageText:
//
//  Parameter %1 not found.
//
#define CRS_ERROR_PARAMETER_NOT_FOUND    0xC0003B12L

//
// MessageId: CRS_ERROR_REPLICATION_RUNNING
//
// MessageText:
//
//  Project %1 is running.  The operation could not be completed.
//
#define CRS_ERROR_REPLICATION_RUNNING    0xC0003B13L

//
// MessageId: CRS_ERROR_INVALID_PROJECT_NAME
//
// MessageText:
//
//  Project name %1 is invalid.  Project names cannot contain backslashes and cannot be empty.
//
#define CRS_ERROR_INVALID_PROJECT_NAME   0xC0003B14L

//
// MessageId: CRS_ERROR_INVALID_ROUTE_NAME
//
// MessageText:
//
//  Route name %1 is invalid.  Route names cannot contain backslashes or DBCS characters and cannot be empty.
//
#define CRS_ERROR_INVALID_ROUTE_NAME     0xC0003B15L

//
// MessageId: CRS_ERROR_INVALID_DWORD
//
// MessageText:
//
//  Parameter %1 must be a positive integer.
//
#define CRS_ERROR_INVALID_DWORD          0xC0003B16L

//
// MessageId: CRS_ERROR_NO_MORE_ITEMS
//
// MessageText:
//
//  No more items in the list.
//
#define CRS_ERROR_NO_MORE_ITEMS          0x80003B17L

//
// MessageId: CRS_ERROR_TOO_MANY_ARGS
//
// MessageText:
//
//  Too many arguments specified.
//
#define CRS_ERROR_TOO_MANY_ARGS          0xC0003B18L

//
// MessageId: CRS_MBS_INIT_ERROR
//
// MessageText:
//
//  Internal error trying to initialize for ACL replication.
//
#define CRS_MBS_INIT_ERROR               0xC0003B19L

//
// MessageId: CRS_ERROR_OPENING_FILE
//
// MessageText:
//
//  Error opening file %1 or file not found.
//
#define CRS_ERROR_OPENING_FILE           0xC0003B1BL

//
// MessageId: CRS_ERROR_FILE_FORMAT
//
// MessageText:
//
//  Invalid file format.
//
#define CRS_ERROR_FILE_FORMAT            0xC0003B1CL

//
// MessageId: CRS_ERROR_FILE_WRITE
//
// MessageText:
//
//  Error writing to file %1.
//
#define CRS_ERROR_FILE_WRITE             0xC0003B1DL

//
// MessageId: WINSOCK_WSAHOSTNAME
//
// MessageText:
//
//  Gethostname failed.
//
#define WINSOCK_WSAHOSTNAME              0xC0003B1EL

//
// MessageId: CRS_ERROR_NODE_EXISTS
//
// MessageText:
//
//  Node already exists in the topology map.
//
#define CRS_ERROR_NODE_EXISTS            0xC0003B1FL

//
// MessageId: CRS_ERROR_NODE_NOT_FOUND
//
// MessageText:
//
//  Node not found in topology map.
//
#define CRS_ERROR_NODE_NOT_FOUND         0xC0003B20L

//
// MessageId: CRS_ERROR_EDGE_EXISTS
//
// MessageText:
//
//  Edge already exists in topology map.
//
#define CRS_ERROR_EDGE_EXISTS            0x80003B21L

//
// MessageId: CRS_ERROR_ROOTNODE_NOT_FOUND
//
// MessageText:
//
//  Root node does not exist in topology map.
//
#define CRS_ERROR_ROOTNODE_NOT_FOUND     0xC0003B22L

//
// MessageId: CRS_ERROR_PATH_NOT_FOUND
//
// MessageText:
//
//  No path to from root to node in topology map.
//
#define CRS_ERROR_PATH_NOT_FOUND         0xC0003B23L

//
// MessageId: CRS_ERROR_EDGE_NOT_FOUND
//
// MessageText:
//
//  Edge does not exist in topology map.
//
#define CRS_ERROR_EDGE_NOT_FOUND         0xC0003B24L

//
// MessageId: CRS_ERROR_INVALID_CONTEXT
//
// MessageText:
//
//  Current context is invalid.  Project being reset.
//
#define CRS_ERROR_INVALID_CONTEXT        0xC0003B25L

//
// MessageId: CRS_ERROR_DOWNLEVEL_SERVER
//
// MessageText:
//
//  Operation is not supported on a down-level server.
//
#define CRS_ERROR_DOWNLEVEL_SERVER       0xC0003B26L

//
// MessageId: CRS_ERROR_NO_MAPPING
//
// MessageText:
//
//  URL does not map to any project definitions.
//
#define CRS_ERROR_NO_MAPPING             0xC0003B27L

//
// MessageId: CRS_ERROR_START_PENDING
//
// MessageText:
//
//  Start pending completion of the active project.
//
#define CRS_ERROR_START_PENDING          0xC0003B28L

//
// MessageId: CRS_ERROR_NO_EVENTSINKS
//
// MessageText:
//
//  No event sinks defined.
//
#define CRS_ERROR_NO_EVENTSINKS          0xC0003B29L

//
// MessageId: CRS_ERROR_EVENTSINK_NOT_FOUND
//
// MessageText:
//
//  Could not find event sink %1.
//
#define CRS_ERROR_EVENTSINK_NOT_FOUND    0xC0003B2AL

//
// MessageId: CRS_ERROR_WSAHOSTNOTFOUND
//
// MessageText:
//
//  Host not found.
//
#define CRS_ERROR_WSAHOSTNOTFOUND        0xC0003B2BL

//
// MessageId: CRS_ERROR_WSATRYAGAIN
//
// MessageText:
//
//  Host not found, or SERVERFAIL.  Try again.
//
#define CRS_ERROR_WSATRYAGAIN            0xC0003B2CL

//
// MessageId: CRS_ERROR_WSANORECOVERY
//
// MessageText:
//
//  Non-recoverable winsock error.
//
#define CRS_ERROR_WSANORECOVERY          0xC0003B2DL

//
// MessageId: CRS_ERROR_WSANODATA
//
// MessageText:
//
//  Invalid address.
//
#define CRS_ERROR_WSANODATA              0xC0003B2EL

//
// MessageId: CRS_EVENTSINK_INITIALIZED
//
// MessageText:
//
//  Event sink %1 was successfully initialized.
//
#define CRS_EVENTSINK_INITIALIZED        0x00003B2FL

//
// MessageId: CRS_ERROR_EVENTSINK_NOT_INITIALIZED
//
// MessageText:
//
//  Event sink %1 failed to initialize.
//
#define CRS_ERROR_EVENTSINK_NOT_INITIALIZED 0xC0003B30L

//
// MessageId: CRS_ERROR_NOTHING_TO_ROLLBACK
//
// MessageText:
//
//  Could not roll back project.  No rollback information found.
//
#define CRS_ERROR_NOTHING_TO_ROLLBACK    0xC0003B31L

//
// MessageId: CRS_ERROR_NO_DESTINATIONS
//
// MessageText:
//
//  Project could not be started because no destinations are defined.
//
#define CRS_ERROR_NO_DESTINATIONS        0xC0003B32L

//
// MessageId: CRS_ERROR_REAUTHENTICATE
//
// MessageText:
//
//  Re-authenticate using an acceptable protocol.
//
#define CRS_ERROR_REAUTHENTICATE         0xC0003B33L

//
// MessageId: CRS_ERROR_UNSUPPORTED
//
// MessageText:
//
//  Function not supported in this version to this server.
//
#define CRS_ERROR_UNSUPPORTED            0xC0003B34L

//
// MessageId: CRS_ERROR_USER_NOT_FOUND
//
// MessageText:
//
//  Specified user %1 could not be found.
//
#define CRS_ERROR_USER_NOT_FOUND         0xC0003B35L

//
// MessageId: CRS_ERROR_NO_TRANSACTIONS
//
// MessageText:
//
//  No transactions for the specified project.
//
#define CRS_ERROR_NO_TRANSACTIONS        0xC0003B36L

//
// MessageId: CRS_ERROR_NO_SERVERS
//
// MessageText:
//
//  No destination servers defined.
//
#define CRS_ERROR_NO_SERVERS             0xC0003B37L

//
// MessageId: CRS_ERROR_NO_SCHEDULES
//
// MessageText:
//
//  No schedules defined for this project.
//
#define CRS_ERROR_NO_SCHEDULES           0xC0003B38L

//
// MessageId: CRS_ERROR_NO_EMAIL
//
// MessageText:
//
//  Could not contact SMTP server %1 to send e-mail report for project %2.
//
#define CRS_ERROR_NO_EMAIL               0xC0003B39L

//
// MessageId: CRS_ERROR_WAIT_ABORT
//
// MessageText:
//
//  Waiting abort on project %1 after losing connection with source server.
//
#define CRS_ERROR_WAIT_ABORT             0xC0003B3AL

//
// MessageId: CRS_RESUME_REPLICATION
//
// MessageText:
//
//  Resuming project %1 to server %2.
//
#define CRS_RESUME_REPLICATION           0x40003B3BL

//
// MessageId: CRS_METABASE_NOT_FOUND
//
// MessageText:
//
//  Metabase is not responding.
//
#define CRS_METABASE_NOT_FOUND           0xC0003B3CL

//
// MessageId: CRS_SSE_VROOT_NOT_FOUND
//
// MessageText:
//
//  Site Server virtual directory not found.
//
#define CRS_SSE_VROOT_NOT_FOUND          0xC0003B3DL

//
// MessageId: CRS_WARNING_CONNECTION_FAILED
//
// MessageText:
//
//  Connection to server %1 for project %2 failed.  Will attempt to re-establish session.
//
#define CRS_WARNING_CONNECTION_FAILED    0x80003B3EL

//
// MessageId: CRS_ERROR_DROPPED_EMAIL_REPORT
//
// MessageText:
//
//  Dropped e-mail report for project %1.
//
#define CRS_ERROR_DROPPED_EMAIL_REPORT   0xC0003B3FL

//
// MessageId: CRS_ERROR_EMAIL_HOST_NOT_DEFINED
//
// MessageText:
//
//  No SMTP server defined.
//
#define CRS_ERROR_EMAIL_HOST_NOT_DEFINED 0xC0003B40L

//
// MessageId: CRS_ERROR_VROOT_CREATION
//
// MessageText:
//
//  Could not create the specified virtual directory.
//
#define CRS_ERROR_VROOT_CREATION         0x80003B41L

//
// MessageId: CRS_ERROR_UPLPAGE_CREATION
//
// MessageText:
//
//  Could not create the upload page.
//
#define CRS_ERROR_UPLPAGE_CREATION       0xC0003B42L

//
// MessageId: CRS_ERROR_CIRCULAR_ROUTE
//
// MessageText:
//
//  System has detected a circular route.  Project not created.
//
#define CRS_ERROR_CIRCULAR_ROUTE         0xC0003B43L

//
// MessageId: CRS_ERROR_TRANSACTION_APPLY_FAILED
//
// MessageText:
//
//  Transaction application for project %1 failed.  Check permissions on the destination directory and files and ensure that no files are locked open.
//
#define CRS_ERROR_TRANSACTION_APPLY_FAILED 0xC0003B44L

//
// MessageId: CRS_ERROR_DATABASE
//
// MessageText:
//
//  Error occurred with the database %1.  Error is: %2.
//
#define CRS_ERROR_DATABASE               0xC0003B45L

//
// MessageId: CRS_ERROR_SINK_CONNECT_FAILED
//
// MessageText:
//
//  Unable to connect to remote server %1 to forward events.
//
#define CRS_ERROR_SINK_CONNECT_FAILED    0xC0003B46L

//
// MessageId: CRS_ERROR_CANT_SEND_EVENTS_TO_DOWNLEVEL_SERVER
//
// MessageText:
//
//  Unable to send events to server %1.  This operation is not supported.
//
#define CRS_ERROR_CANT_SEND_EVENTS_TO_DOWNLEVEL_SERVER 0xC0003B47L

//
// MessageId: CRS_ERROR_FILE_CORRUPT
//
// MessageText:
//
//  File %1 is corrupt or unreadable.
//
#define CRS_ERROR_FILE_CORRUPT           0xC0003B48L

//
// MessageId: CRS_ERROR_FILE_BUSY
//
// MessageText:
//
//  File %1 is busy.
//
#define CRS_ERROR_FILE_BUSY              0xC0003B49L

//
// MessageId: CRS_ACL_ERROR_INVALID_ACE
//
// MessageText:
//
//  Could not set the ACE %1 on file %2.
//
#define CRS_ACL_ERROR_INVALID_ACE        0x80003B4AL

//
// MessageId: CRS_ACL_ERROR_ACL_FAILED
//
// MessageText:
//
//  Could not set the ACLS appropriately on file %1, setting default ACLs on this file.
//
#define CRS_ACL_ERROR_ACL_FAILED         0xC0003B4BL

//
// MessageId: CRS_ERROR_PROJECT_NOT_FOUND_ON_DESTINATION
//
// MessageText:
//
//  Could not find project %1 on server %2.
//
#define CRS_ERROR_PROJECT_NOT_FOUND_ON_DESTINATION 0xC0003B4CL

//
// MessageId: CRS_ERROR_PROJECT_INCOMPLETE_ON_DESTINATION
//
// MessageText:
//
//  Project information for project %1 is incomplete on server %2.
//
#define CRS_ERROR_PROJECT_INCOMPLETE_ON_DESTINATION 0xC0003B4DL

//
// MessageId: CRS_ERROR_SERVICE_DOWN_ON_REMOTE_SERVER
//
// MessageText:
//
//  Remote server available, but the Site Server Content Deployment service is not running.
//
#define CRS_ERROR_SERVICE_DOWN_ON_REMOTE_SERVER 0xC0003B4EL

//
// MessageId: CRS_ERROR_DISK_FULL_ON_DESTINATION
//
// MessageText:
//
//  Disk is full on the destination server %1.
//
#define CRS_ERROR_DISK_FULL_ON_DESTINATION 0xC0003B4FL

//
// MessageId: CRS_FILE_CREATE_ERROR_ON_DESTINATION
//
// MessageText:
//
//  Unable to open a file on the destination server %1.  Check permissions on the project directory and files.
//
#define CRS_FILE_CREATE_ERROR_ON_DESTINATION 0xC0003B50L

//
// MessageId: CRS_ERROR_REMOTE_SERVER_NOT_FOUND
//
// MessageText:
//
//  Remote server could not be found.
//
#define CRS_ERROR_REMOTE_SERVER_NOT_FOUND 0xC0003B51L

//
// MessageId: CRS_ERROR_REMOTE_APPLY_FAILED
//
// MessageText:
//
//  Unable to apply transactions for project %1 on server %2.
//
#define CRS_ERROR_REMOTE_APPLY_FAILED    0xC0003B52L

//
// MessageId: CRS_ERROR_INVALID_FLAG_COMBINATION
//
// MessageText:
//
//  Invalid flag combination.
//
#define CRS_ERROR_INVALID_FLAG_COMBINATION 0xC0003B53L

//
// MessageId: CRS_ERROR_RUNNING_SCRIPT
//
// MessageText:
//
//  Error running the script %1.  Ensure that the script exists and can be located in the path.
//
#define CRS_ERROR_RUNNING_SCRIPT         0xC0003B54L

//
// MessageId: CRS_ERROR_CANT_FORWARD_TO_LOCAL_SERVER
//
// MessageText:
//
//  Cannot forward events to the local server.
//
#define CRS_ERROR_CANT_FORWARD_TO_LOCAL_SERVER 0xC0003B55L

//
// MessageId: CRS_ERROR_SCHEDULE_NOT_FOUND
//
// MessageText:
//
//  Specified project schedule could not be found.
//
#define CRS_ERROR_SCHEDULE_NOT_FOUND     0xC0003B56L

//
// MessageId: CRS_ERROR_METABASE
//
// MessageText:
//
//  An error occurred accessing the metabase for the project %1.  Ensure that the web site exists and that the account has access to it.
//
#define CRS_ERROR_METABASE               0xC0003B57L

//
// MessageId: CRS_ERROR_SCHEDULER_FAILURE
//
// MessageText:
//
//  An error occurred with the task scheduler.
//
#define CRS_ERROR_SCHEDULER_FAILURE      0xC0003B58L

//
// MessageId: CRS_SAMEBOX_META_TARGET
//
// MessageText:
//
//  The destination %1 for metabase replication is invalid.
//
#define CRS_SAMEBOX_META_TARGET          0xC0003B59L

//
// MessageId: CRS_ERROR_DROPPED_EVENTS
//
// MessageText:
//
//  The event sink %1 has started dropping events.
//
#define CRS_ERROR_DROPPED_EVENTS         0xC0003B5AL

//
// MessageId: CRS_MSG_REPLICATION_FIRST
//
// MessageText:
//
//  Site Server Content Deployment first replication event message.
//
#define CRS_MSG_REPLICATION_FIRST        0x40003BC4L

//
// MessageId: CRS_MSG_STARTING_REPLICATION
//
// MessageText:
//
//  Project %1 starting to server %2.
//
#define CRS_MSG_STARTING_REPLICATION     0x40003BC5L

//
// MessageId: CRS_MSG_REPLICATION_COMPLETE
//
// MessageText:
//
//  Project %1 complete to server %2.
//
#define CRS_MSG_REPLICATION_COMPLETE     0x40003BC6L

//
// MessageId: CRS_MSG_STARTING_PULL_REPLICATION
//
// MessageText:
//
//  Retrieval project %1 starting from URL %2.
//
#define CRS_MSG_STARTING_PULL_REPLICATION 0x40003BC7L

//
// MessageId: CRS_MSG_PULL_REPLICATION_COMPLETE
//
// MessageText:
//
//  Retrieval project %1 complete from URL %2.
//
#define CRS_MSG_PULL_REPLICATION_COMPLETE 0x40003BC8L

//
// MessageId: CRS_MSG_STARTING_RECEIVE_REPLICATION
//
// MessageText:
//
//  Starting to receive project %1 from server %2.
//
#define CRS_MSG_STARTING_RECEIVE_REPLICATION 0x40003BC9L

//
// MessageId: CRS_MSG_REPLICATION_RECEIVE_COMPLETE
//
// MessageText:
//
//  Finished receiving project %1 from server %2.
//
#define CRS_MSG_REPLICATION_RECEIVE_COMPLETE 0x40003BCAL

//
// MessageId: CRS_MSG_STARTING_REPLICATION_SCAN
//
// MessageText:
//
//  Project %1 starting.
//
#define CRS_MSG_STARTING_REPLICATION_SCAN 0x40003BCBL

//
// MessageId: CRS_MSG_REPLICATION_LAST
//
// MessageText:
//
//  Site Server Content Deployment last replication event message.
//
#define CRS_MSG_REPLICATION_LAST         0x40003BF5L

//
// MessageId: CRS_MSG_FILE_FIRST
//
// MessageText:
//
//  Site Server Content Deployment first file event message.
//
#define CRS_MSG_FILE_FIRST               0x40003BF6L

//
// MessageId: CRS_MSG_SENDING_FILE
//
// MessageText:
//
//  Sending file %1.
//
#define CRS_MSG_SENDING_FILE             0x40003BF7L

//
// MessageId: CRS_MSG_SENT_FILE
//
// MessageText:
//
//  File %1 sent.
//
#define CRS_MSG_SENT_FILE                0x40003BF8L

//
// MessageId: CRS_MSG_RECEIVING_FILE
//
// MessageText:
//
//  Receiving file %1.
//
#define CRS_MSG_RECEIVING_FILE           0x40003BF9L

//
// MessageId: CRS_MSG_RECEIVED_FILE
//
// MessageText:
//
//  File %1 received.
//
#define CRS_MSG_RECEIVED_FILE            0x40003BFAL

//
// MessageId: CRS_MSG_SENT_DELETE_FILE
//
// MessageText:
//
//  Sent delete file request for file %1.
//
#define CRS_MSG_SENT_DELETE_FILE         0x40003BFBL

//
// MessageId: CRS_MSG_RECEIVED_DELETE_FILE
//
// MessageText:
//
//  File delete request received for file %1.
//
#define CRS_MSG_RECEIVED_DELETE_FILE     0x40003BFCL

//
// MessageId: CRS_MSG_RETRYING_SENDING_FILE
//
// MessageText:
//
//  Trying to resend file %1.
//
#define CRS_MSG_RETRYING_SENDING_FILE    0x40003C00L

//
// MessageId: CRS_MSG_FILE_BUSY
//
// MessageText:
//
//  File %1 is busy.  The service is waiting for the file to become available.
//
#define CRS_MSG_FILE_BUSY                0x40003C01L

//
// MessageId: CRS_MSG_SENDING_ACL
//
// MessageText:
//
//  Sending the ACL for the file %1.
//
#define CRS_MSG_SENDING_ACL              0x40003C02L

//
// MessageId: CRS_MSG_SENT_ACL
//
// MessageText:
//
//  Sent the ACL for the file %1.
//
#define CRS_MSG_SENT_ACL                 0x40003C03L

//
// MessageId: CRS_MSG_RECEIVING_ACL
//
// MessageText:
//
//  Receiving the ACL for the file %1.
//
#define CRS_MSG_RECEIVING_ACL            0x40003C04L

//
// MessageId: CRS_MSG_RECEIVED_ACL
//
// MessageText:
//
//  Received the ACL for the file %1.
//
#define CRS_MSG_RECEIVED_ACL             0x40003C05L

//
// MessageId: CRS_MSG_PULLED_FILE_HTTP
//
// MessageText:
//
//  File %1 retrieved over HTTP.
//
#define CRS_MSG_PULLED_FILE_HTTP         0x40003C06L

//
// MessageId: CRS_MSG_PULLED_FILE_FTP
//
// MessageText:
//
//  File %1 retrieved over FTP.
//
#define CRS_MSG_PULLED_FILE_FTP          0x40003C07L

//
// MessageId: CRS_MSG_FILE_COMMITTED
//
// MessageText:
//
//  File %1 committed to disk.
//
#define CRS_MSG_FILE_COMMITTED           0x40003C08L

//
// MessageId: CRS_MSG_FILE_DELETED
//
// MessageText:
//
//  File %1 deleted.
//
#define CRS_MSG_FILE_DELETED             0x40003C09L

//
// MessageId: CRS_MSG_SKIPPING_LOCKED_FILE
//
// MessageText:
//
//  File %1 skipped because it could not be opened.
//
#define CRS_MSG_SKIPPING_LOCKED_FILE     0x80003C0AL

//
// MessageId: CRS_FILE_MATCHED
//
// MessageText:
//
//  File %1 matched.
//
#define CRS_FILE_MATCHED                 0x40003C0BL

//
// MessageId: CRS_MSG_FILE_LAST
//
// MessageText:
//
//  Site Server Content Deployment last file event message.
//
#define CRS_MSG_FILE_LAST                0x40003C27L

//
// MessageId: CRS_MSG_ADMIN_FIRST
//
// MessageText:
//
//  Site Server Content Deployment first administration event message.
//
#define CRS_MSG_ADMIN_FIRST              0x40003C28L

//
// MessageId: CRS_MSG_PROJECT_CREATED
//
// MessageText:
//
//  Project %1 created.
//
#define CRS_MSG_PROJECT_CREATED          0x40003C29L

//
// MessageId: CRS_MSG_PROJECT_DELETED
//
// MessageText:
//
//  Project %1 deleted.
//
#define CRS_MSG_PROJECT_DELETED          0x40003C2AL

//
// MessageId: CRS_MSG_PROJECT_EDITED
//
// MessageText:
//
//  Project %1 edited.
//
#define CRS_MSG_PROJECT_EDITED           0x40003C2BL

//
// MessageId: CRS_MSG_ROUTE_CREATED
//
// MessageText:
//
//  Route %1 created.
//
#define CRS_MSG_ROUTE_CREATED            0x40003C2CL

//
// MessageId: CRS_MSG_ROUTE_DELETED
//
// MessageText:
//
//  Route %1 deleted.
//
#define CRS_MSG_ROUTE_DELETED            0x40003C2DL

//
// MessageId: CRS_MSG_ROUTE_EDITED
//
// MessageText:
//
//  Route %1 edited.
//
#define CRS_MSG_ROUTE_EDITED             0x40003C2EL

//
// MessageId: CRS_MSG_SERVER_EDITED
//
// MessageText:
//
//  Server settings modified.
//
#define CRS_MSG_SERVER_EDITED            0x40003C2FL

//
// MessageId: CRS_MSG_EVENTSINK_CREATED
//
// MessageText:
//
//  Event sink %1 was added.
//
#define CRS_MSG_EVENTSINK_CREATED        0x40003C30L

//
// MessageId: CRS_MSG_EVENTSINK_DELETED
//
// MessageText:
//
//  Event sink %1 was deleted.
//
#define CRS_MSG_EVENTSINK_DELETED        0x40003C31L

//
// MessageId: CRS_MSG_CLEARED_EVENTS
//
// MessageText:
//
//  Event store %1 was cleared.
//
#define CRS_MSG_CLEARED_EVENTS           0x40003C32L

//
// MessageId: CRS_MSG_CLEARED_ALL_EVENTS
//
// MessageText:
//
//  Each database event store on this server was cleared.
//
#define CRS_MSG_CLEARED_ALL_EVENTS       0x40003C33L

//
// MessageId: CRS_MSG_ADMIN_LAST
//
// MessageText:
//
//  Site Server Content Deployment last administration event message.
//
#define CRS_MSG_ADMIN_LAST               0x40003C5AL

//
// MessageId: CRS_MSG_SUMMARY_FIRST
//
// MessageText:
//
//  Site Server Content Deployment first summary event message.
//
#define CRS_MSG_SUMMARY_FIRST            0x40003C8CL

//
// MessageId: CRS_MSG_SUMMARY_RECEIVE
//
// MessageText:
//
//  Project summary information (files received).
//
#define CRS_MSG_SUMMARY_RECEIVE          0x40003C8DL

//
// MessageId: CRS_MSG_SUMMARY_SEND
//
// MessageText:
//
//  Project summary information (files sent).
//
#define CRS_MSG_SUMMARY_SEND             0x40003C8EL

//
// MessageId: CRS_MSG_SUMMARY_PULL
//
// MessageText:
//
//  Project summary information (files pulled).
//
#define CRS_MSG_SUMMARY_PULL             0x40003C8FL

//
// MessageId: CRS_MSG_SUMMARY_AUTOMATIC_RECEIVE
//
// MessageText:
//
//  Automatic project (receive) checkpoint summary information.
//
#define CRS_MSG_SUMMARY_AUTOMATIC_RECEIVE 0x40003C90L

//
// MessageId: CRS_MSG_SUMMARY_AUTOMATIC_SEND
//
// MessageText:
//
//  Automatic project (send) checkpoint summary information.
//
#define CRS_MSG_SUMMARY_AUTOMATIC_SEND   0x40003C91L

//
// MessageId: CRS_MSG_SUMMARY_RECEIVE_MATCHED
//
// MessageText:
//
//  Project summary information (files matched during receive).
//
#define CRS_MSG_SUMMARY_RECEIVE_MATCHED  0x40003C92L

//
// MessageId: CRS_MSG_SUMMARY_SEND_MATCHED
//
// MessageText:
//
//  Project summary information (files matched during send).
//
#define CRS_MSG_SUMMARY_SEND_MATCHED     0x40003C93L

//
// MessageId: CRS_MSG_SUMMARY_PULL_MATCHED
//
// MessageText:
//
//  Project summary information (files matched during pull).
//
#define CRS_MSG_SUMMARY_PULL_MATCHED     0x40003C94L

//
// MessageId: CRS_MSG_SUMMARY_RECEIVE_ERRORED
//
// MessageText:
//
//  Project summary information (files errored during receive).
//
#define CRS_MSG_SUMMARY_RECEIVE_ERRORED  0x40003C95L

//
// MessageId: CRS_MSG_SUMMARY_SEND_ERRORED
//
// MessageText:
//
//  Project summary information (files errored during send).
//
#define CRS_MSG_SUMMARY_SEND_ERRORED     0x40003C96L

//
// MessageId: CRS_MSG_SUMMARY_PULL_ERRORED
//
// MessageText:
//
//  Project summary information (files errored during pull).
//
#define CRS_MSG_SUMMARY_PULL_ERRORED     0x40003C97L

//
// MessageId: CRS_MSG_SUMMARY_LAST
//
// MessageText:
//
//  Site Server Content Deployment last summary event message.
//
#define CRS_MSG_SUMMARY_LAST             0x40003CBEL

//
// MessageId: CRS_CAB_ERROR_FIRST
//
// MessageText:
//
//  Remote installer first error message.
//
#define CRS_CAB_ERROR_FIRST              0xC0003CF0L

//
// MessageId: CRS_CAB_ERROR_CABINET_NOT_FOUND
//
// MessageText:
//
//  Cannot find the specified cabinet file.
//
#define CRS_CAB_ERROR_CABINET_NOT_FOUND  0xC0003CF1L

//
// MessageId: CRS_CAB_ERROR_NOT_A_CABINET
//
// MessageText:
//
//  Specified file is not a valid cabinet file.
//
#define CRS_CAB_ERROR_NOT_A_CABINET      0xC0003CF2L

//
// MessageId: CRS_CAB_ERROR_UNKNOWN_CABINET_VERSION
//
// MessageText:
//
//  Specified file is an unknown version of a cabinet file.
//
#define CRS_CAB_ERROR_UNKNOWN_CABINET_VERSION 0xC0003CF3L

//
// MessageId: CRS_CAB_ERROR_CORRUPT_CABINET
//
// MessageText:
//
//  Specified cabinet file is corrupt.
//
#define CRS_CAB_ERROR_CORRUPT_CABINET    0xC0003CF4L

//
// MessageId: CRS_CAB_ERROR_ALLOC_FAIL
//
// MessageText:
//
//  Out of memory.
//
#define CRS_CAB_ERROR_ALLOC_FAIL         0xC0003CF5L

//
// MessageId: CRS_CAB_ERROR_BAD_COMPR_TYPE
//
// MessageText:
//
//  Specified cabinet file uses an unknown compression type.
//
#define CRS_CAB_ERROR_BAD_COMPR_TYPE     0xC0003CF6L

//
// MessageId: CRS_CAB_ERROR_MDI_FAIL
//
// MessageText:
//
//  Compressed data in the specified cabinet file is corrupt.
//
#define CRS_CAB_ERROR_MDI_FAIL           0xC0003CF7L

//
// MessageId: CRS_CAB_ERROR_TARGET_FILE
//
// MessageText:
//
//  Could not save extracted files from the specified cabinet file.
//
#define CRS_CAB_ERROR_TARGET_FILE        0xC0003CF8L

//
// MessageId: CRS_CAB_ERROR_RESERVE_MISMATCH
//
// MessageText:
//
//  Specified cabinet file has a non-valid RESERVE size.
//
#define CRS_CAB_ERROR_RESERVE_MISMATCH   0xC0003CF9L

//
// MessageId: CRS_CAB_ERROR_WRONG_CABINET
//
// MessageText:
//
//  Specified cabinet file is not the right cabinet in the set.
//
#define CRS_CAB_ERROR_WRONG_CABINET      0xC0003CFAL

//
// MessageId: CRS_CAB_ERROR_USER_ABORT
//
// MessageText:
//
//  Could not extract the specified cabinet file - user aborted the operation.
//
#define CRS_CAB_ERROR_USER_ABORT         0xC0003CFBL

//
// MessageId: CRS_CAB_WARNING_CAB_NOT_SIGNED
//
// MessageText:
//
//  Specified cabinet file is not a signed cabinet file.
//
#define CRS_CAB_WARNING_CAB_NOT_SIGNED   0x80003CFCL

//
// MessageId: CRS_CAB_WARNING_SIGNATURE_NOT_VERIFIED
//
// MessageText:
//
//  Signature on the specified cabinet could not be verified.
//
#define CRS_CAB_WARNING_SIGNATURE_NOT_VERIFIED 0x80003CFDL

//
// MessageId: CRS_CAB_ERROR_INFFILE_NOT_FOUND
//
// MessageText:
//
//  INF file was not found inside the specified cabinet file.
//
#define CRS_CAB_ERROR_INFFILE_NOT_FOUND  0xC0003CFEL

//
// MessageId: CRS_INF_ERROR_ADVPACK_NOT_LOADED
//
// MessageText:
//
//  Could not load ADVPACK.DLL.
//
#define CRS_INF_ERROR_ADVPACK_NOT_LOADED 0xC0003CFFL

//
// MessageId: CRS_INF_ERROR_ADVPACK_WRONG_VERSION
//
// MessageText:
//
//  This version of ADVPACK.DLL is not supported.
//
#define CRS_INF_ERROR_ADVPACK_WRONG_VERSION 0xC0003D00L

//
// MessageId: CRS_INF_ERROR_INVALID_INF
//
// MessageText:
//
//  INF file found inside the specified cabinet file is not a valid INF file.
//
#define CRS_INF_ERROR_INVALID_INF        0xC0003D01L

//
// MessageId: CRS_INF_ERROR_NOTHING_TO_INSTALL
//
// MessageText:
//
//  Could not find any of the remote install sections inside the INF file.
//
#define CRS_INF_ERROR_NOTHING_TO_INSTALL 0xC0003D02L

//
// MessageId: CRS_INF_ERROR_NOTHING_TO_UNINSTALL
//
// MessageText:
//
//  Could not find any of the remote uninstall sections inside the INF file.
//
#define CRS_INF_ERROR_NOTHING_TO_UNINSTALL 0xC0003D03L

//
// MessageId: CRS_INF_ERROR_BUSY_FILES
//
// MessageText:
//
//  Files are busy.  Cannot install them unless allowed to do a REBOOT.
//
#define CRS_INF_ERROR_BUSY_FILES         0xC0003D04L

//
// MessageId: CRS_CAB_WARNING_MANUAL_REBOOT
//
// MessageText:
//
//  Setup completed successfully, but the server could not be rebooted automatically. Manual reboot is necessary.
//
#define CRS_CAB_WARNING_MANUAL_REBOOT    0x80003D05L

//
// MessageId: CRS_CAB_WARNING_REBOOT_NEEDED
//
// MessageText:
//
//  Setup completed successfully, but the files became busy during setup.  Manual reboot is necessary.
//
#define CRS_CAB_WARNING_REBOOT_NEEDED    0x80003D06L

//
// MessageId: CRS_INF_SUCCESS_REBOOT_IN_PROGRESS
//
// MessageText:
//
//  Setup completed successfully. The server is being rebooted.
//
#define CRS_INF_SUCCESS_REBOOT_IN_PROGRESS 0x00003D07L

//
// MessageId: CRS_INF_SUCCESS
//
// MessageText:
//
//  Setup completed successfully.
//
#define CRS_INF_SUCCESS                  0x00003D09L

//
// MessageId: CRS_INF_ERROR_BUSY_FILES_UNINSTALL
//
// MessageText:
//
//  Files are busy.  Cannot uninstall files unless allowed to reboot.
//
#define CRS_INF_ERROR_BUSY_FILES_UNINSTALL 0xC0003D0AL

//
// MessageId: CRS_CAB_WARNING_MANUAL_REBOOT_UNINSTALL
//
// MessageText:
//
//  Uninstall completed successfully, but the server could not be rebooted automatically. Manual reboot is necessary.
//
#define CRS_CAB_WARNING_MANUAL_REBOOT_UNINSTALL 0x80003D0BL

//
// MessageId: CRS_CAB_WARNING_REBOOT_NEEDED_UNINSTALL
//
// MessageText:
//
//  Uninstall completed successfully, but the files became busy during setup.  Manual reboot is necessary.
//
#define CRS_CAB_WARNING_REBOOT_NEEDED_UNINSTALL 0x80003D0CL

//
// MessageId: CRS_INF_SUCCESS_REBOOT_IN_PROGRESS_UNINSTALL
//
// MessageText:
//
//  Uninstall completed successfully. The server is being rebooted.
//
#define CRS_INF_SUCCESS_REBOOT_IN_PROGRESS_UNINSTALL 0x00003D0DL

//
// MessageId: CRS_INF_SUCCESS_UNINSTALL
//
// MessageText:
//
//  Uninstall completed successfully.
//
#define CRS_INF_SUCCESS_UNINSTALL        0x00003D0EL

//
// MessageId: CRS_CAB_ERROR_ADVPACK_FAILED
//
// MessageText:
//
//  Problem installing the CAB. Check CAB and INF files for validity. 
//
#define CRS_CAB_ERROR_ADVPACK_FAILED     0xC0003D0FL

//
// MessageId: CRS_CAB_ERROR_LOCKED_FILES
//
// MessageText:
//
//  At least one of the files inside the CAB is open for exclusive write/delete access.
//
#define CRS_CAB_ERROR_LOCKED_FILES       0xC0003D10L

//
// MessageId: CRS_CAB_ERROR_UNKNOWN
//
// MessageText:
//
//  An unknown error occurred while processing the specified cabinet file.
//
#define CRS_CAB_ERROR_UNKNOWN            0xC0003DEEL

//
// MessageId: CRS_CAB_ERROR_LAST
//
// MessageText:
//
//  Remote installer last error message.
//
#define CRS_CAB_ERROR_LAST               0x40003DEFL

//
// MessageId: CRS_ERROR_LAST
//
// MessageText:
//
//  Site Server Content Deployment service last error message.
//
#define CRS_ERROR_LAST                   0x40003E7FL

//
// MessageId: CRS_EVENT_FIRST
//
// MessageText:
//
//  Site Server Content Deployment Service first event message.
//
#define CRS_EVENT_FIRST                  0x400036B0L

//
// MessageId: CRS_EVENT_NET_SOURCE
//
// MessageText:
//
//  Source directory is on a network drive.  Cannot deploy from network drives.
//
#define CRS_EVENT_NET_SOURCE             0xC00036B4L

//
// MessageId: CRS_EVENT_ERROR_ACCESS_DENIED
//
// MessageText:
//
//  Access denied.
//
#define CRS_EVENT_ERROR_ACCESS_DENIED    0xC00036B5L

//
// MessageId: CRS_EVENT_FILE_CREATE_ERROR
//
// MessageText:
//
//  Unable to open the file.
//
#define CRS_EVENT_FILE_CREATE_ERROR      0xC00036B6L

//
// MessageId: CRS_EVENT_SENDINET_ERROR
//
// MessageText:
//
//  Project was unable to send the file.
//
#define CRS_EVENT_SENDINET_ERROR         0xC00036B7L

//
// MessageId: CRS_EVENT_SAMEBOX_NET_TARGET
//
// MessageText:
//
//  Destination directory is on a network drive.  Cannot deploy to network drives.
//
#define CRS_EVENT_SAMEBOX_NET_TARGET     0xC00036B8L

//
// MessageId: CRS_EVENT_BAD_SOURCE
//
// MessageText:
//
//  Unable to access the project source.
//
#define CRS_EVENT_BAD_SOURCE             0xC00036B9L

//
// MessageId: CRS_EVENT_SENDINET_CONNECT
//
// MessageText:
//
//  Unable to connect to the remote server.
//
#define CRS_EVENT_SENDINET_CONNECT       0xC00036BAL

//
// MessageId: CRS_EVENT_HASH_MISMATCH
//
// MessageText:
//
//  MD5 Hash did not match during a transmission.  This could indicate transmission failure or that the files transmitted at the source have been modified in transit.
//
#define CRS_EVENT_HASH_MISMATCH          0xC00036BBL

//
// MessageId: CRS_EVENT_SERVER_ABORTED
//
// MessageText:
//
//  Remote server was restarted.  The project is being restarted.
//
#define CRS_EVENT_SERVER_ABORTED         0xC00036BCL

//
// MessageId: CRS_EVENT_REPLICATION_ABORTED
//
// MessageText:
//
//  Project was aborted.
//
#define CRS_EVENT_REPLICATION_ABORTED    0xC00036BDL

//
// MessageId: CRS_EVENT_SEQUENCE_ERROR
//
// MessageText:
//
//  Internal messaging sequence error occurred.
//
#define CRS_EVENT_SEQUENCE_ERROR         0xC00036BEL

//
// MessageId: CRS_EVENT_SERVICE_STARTED
//
// MessageText:
//
//  Site Server Content Deployment service started successfully.
//
#define CRS_EVENT_SERVICE_STARTED        0x400036BFL

//
// MessageId: CRS_EVENT_SERVICE_SHUTDOWN
//
// MessageText:
//
//  Site Server Content Deployment service shut down successfully.
//
#define CRS_EVENT_SERVICE_SHUTDOWN       0x400036C0L

//
// MessageId: CRS_EVENT_METABASE_ACCESS
//
// MessageText:
//
//  Could not open given storage/stream.  Ensure the authentication account has access to this storage/stream.
//
#define CRS_EVENT_METABASE_ACCESS        0xC00036C2L

//
// MessageId: CRS_EVENT_AUTH_FAILURE
//
// MessageText:
//
//  Authorization failure against the destination server.  Ensure the service has access to this server.
//
#define CRS_EVENT_AUTH_FAILURE           0xC00036C3L

//
// MessageId: CRS_EVENT_REMOTE_AUTH_FAILURE
//
// MessageText:
//
//  Remote authorization failed to the destination server.  Ensure the service has access to this server.
//
#define CRS_EVENT_REMOTE_AUTH_FAILURE    0xC00036C4L

//
// MessageId: CRS_EVENT_ERROR_NOT_IN_ORDER
//
// MessageText:
//
//  Message was received out of order.  Closing connection.
//
#define CRS_EVENT_ERROR_NOT_IN_ORDER     0xC00036C5L

//
// MessageId: CRS_EVENT_CONNECTION_RETRY_FAILED
//
// MessageText:
//
//  Connection failed and could not be re-established.
//
#define CRS_EVENT_CONNECTION_RETRY_FAILED 0xC00036C6L

//
// MessageId: CRS_EVENT_REPLICATION_CANCELED
//
// MessageText:
//
//  Project canceled at the request of the user.
//
#define CRS_EVENT_REPLICATION_CANCELED   0xC00036C7L

//
// MessageId: CRS_EVENT_ERROR_DEST_TOOBIG
//
// MessageText:
//
//  Could not add the specified destination(s).  The maximum number of destinations has been reached.
//
#define CRS_EVENT_ERROR_DEST_TOOBIG      0xC00036C8L

//
// MessageId: CRS_EVENT_ERROR_NO_IP_MAPPING
//
// MessageText:
//
//  Cannot resolve IP address for the destination server.  No virtual directory created.
//
#define CRS_EVENT_ERROR_NO_IP_MAPPING    0xC00036C9L

//
// MessageId: CRS_EVENT_ERROR_DISK_FULL
//
// MessageText:
//
//  Not enough space on the disk.
//
#define CRS_EVENT_ERROR_DISK_FULL        0xC00036CAL

//
// MessageId: CRS_EVENT_ERROR_TOO_MANY_RUNNING
//
// MessageText:
//
//  Too many active projects. No more can be started until others complete.
//
#define CRS_EVENT_ERROR_TOO_MANY_RUNNING 0xC00036CBL

//
// MessageId: CRS_EVENT_ERROR_WOULDBLOCK
//
// MessageText:
//
//  The network operation would block.
//
#define CRS_EVENT_ERROR_WOULDBLOCK       0x000036D3L

//
// MessageId: CRS_EVENT_ERROR_NETDOWN
//
// MessageText:
//
//  The remote network is down.
//
#define CRS_EVENT_ERROR_NETDOWN          0xC00036E2L

//
// MessageId: CRS_EVENT_ERROR_NETUNREACH
//
// MessageText:
//
//  The remote network is unreachable.
//
#define CRS_EVENT_ERROR_NETUNREACH       0xC00036E3L

//
// MessageId: CRS_EVENT_ERROR_CONNABORTED
//
// MessageText:
//
//  The network connection was aborted at the network layer.
//
#define CRS_EVENT_ERROR_CONNABORTED      0xC00036E5L

//
// MessageId: CRS_EVENT_ERROR_TIMEOUT
//
// MessageText:
//
//  The network session timed out on a send or receive operation.
//
#define CRS_EVENT_ERROR_TIMEOUT          0xC00036ECL

//
// MessageId: CRS_EVENT_ERROR_NO_PROJECTS
//
// MessageText:
//
//  No projects defined.
//
#define CRS_EVENT_ERROR_NO_PROJECTS      0xC0003714L

//
// MessageId: CRS_EVENT_ERROR_PROJECT_NOT_FOUND
//
// MessageText:
//
//  Could not find the project.
//
#define CRS_EVENT_ERROR_PROJECT_NOT_FOUND 0xC0003715L

//
// MessageId: CRS_EVENT_ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  Invalid parameter.
//
#define CRS_EVENT_ERROR_INVALID_PARAMETER 0xC0003716L

//
// MessageId: CRS_EVENT_ERROR_AUTHENTICATION_FAILURE
//
// MessageText:
//
//  Authentication failure. Ensure the account has proper access on local and remote servers.
//
#define CRS_EVENT_ERROR_AUTHENTICATION_FAILURE 0xC0003718L

//
// MessageId: CRS_EVENT_ERROR_DELETE_PROJECT_DOWN_ROUTE
//
// MessageText:
//
//  Could not delete the route from the project on at least one machine down the defined routes.  The project will have to be edited manually there.
//
#define CRS_EVENT_ERROR_DELETE_PROJECT_DOWN_ROUTE 0x80003719L

//
// MessageId: CRS_EVENT_ERROR_SERVICE_NOT_RUNNING
//
// MessageText:
//
//  Server is available, but the Site Server Content Deployment service is not running.
//
#define CRS_EVENT_ERROR_SERVICE_NOT_RUNNING 0xC000371AL

//
// MessageId: CRS_EVENT_ERROR_HOST_DOWN
//
// MessageText:
//
//  Server is unavailable.
//
#define CRS_EVENT_ERROR_HOST_DOWN        0xC000371BL

//
// MessageId: CRS_EVENT_ERROR_BAD_NET_NAME
//
// MessageText:
//
//  Server cannot be found.
//
#define CRS_EVENT_ERROR_BAD_NET_NAME     0xC000371CL

//
// MessageId: CRS_EVENT_ERROR_ROUTE_NOT_FOUND
//
// MessageText:
//
//  Could not find route.  Ensure the route name is correct and that it exists on the target servers.
//
#define CRS_EVENT_ERROR_ROUTE_NOT_FOUND  0xC000371DL

//
// MessageId: CRS_EVENT_ERROR_NO_ROUTES
//
// MessageText:
//
//  No routes defined.
//
#define CRS_EVENT_ERROR_NO_ROUTES        0xC000371EL

//
// MessageId: CRS_EVENT_ERROR_CREATE_PROJECT_DOWN_ROUTE
//
// MessageText:
//
//  Could not create the project on at least one server down the defined routes.  The project will have to be created manually there.
//
#define CRS_EVENT_ERROR_CREATE_PROJECT_DOWN_ROUTE 0x8000371FL

//
// MessageId: CRS_EVENT_ERROR_SERVICE_PAUSED
//
// MessageText:
//
//  Site Server Content Deployment service on the destination server is paused and is not accepting new requests.  Retry the project later.
//
#define CRS_EVENT_ERROR_SERVICE_PAUSED   0xC0003720L

//
// MessageId: CRS_EVENT_ERROR_SERVICE_NOT_PAUSED
//
// MessageText:
//
//  Could not restart service. Service is not paused.
//
#define CRS_EVENT_ERROR_SERVICE_NOT_PAUSED 0xC0003721L

//
// MessageId: CRS_EVENT_ERROR_NAME_NOT_RESOLVED
//
// MessageText:
//
//  Could not resolve the URL.  Ensure URL and/or proxy settings are correct.
//
#define CRS_EVENT_ERROR_NAME_NOT_RESOLVED 0xC0003722L

//
// MessageId: CRS_EVENT_ERROR_CONNECTION_RESET
//
// MessageText:
//
//  Connection to the destination server has been reset.  This indicates problems with the remote service or network.
//
#define CRS_EVENT_ERROR_CONNECTION_RESET 0xC0003723L

//
// MessageId: CRS_EVENT_ERROR_REPLICATION_NOT_FOUND
//
// MessageText:
//
//  No entries.
//
#define CRS_EVENT_ERROR_REPLICATION_NOT_FOUND 0xC0003724L

//
// MessageId: CRS_EVENT_ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
//  Could not start service.  The service has already been started.
//
#define CRS_EVENT_ERROR_SERVICE_ALREADY_RUNNING 0xC0003725L

//
// MessageId: CRS_EVENT_ERROR_PROJECT_ALREADY_RUNNING
//
// MessageText:
//
//  Failed to start project.  It is already running.
//
#define CRS_EVENT_ERROR_PROJECT_ALREADY_RUNNING 0xC0003726L

//
// MessageId: CRS_EVENT_FILE_MOVE_ERROR
//
// MessageText:
//
//  Failed to move file.
//
#define CRS_EVENT_FILE_MOVE_ERROR        0xC0003727L

//
// MessageId: CRS_EVENT_PRODUCT_EXPIRED
//
// MessageText:
//
//  Thank you for your interest in Site Server Content Deployment.  This software has expired.  Please acquire the final retail version of this software.
//
#define CRS_EVENT_PRODUCT_EXPIRED        0xC0003728L

//
// MessageId: CRS_EVENT_ERROR_PROJECT_INCOMPLETE
//
// MessageText:
//
//  Project information is incomplete.
//
#define CRS_EVENT_ERROR_PROJECT_INCOMPLETE 0xC0003729L

//
// MessageId: CRS_EVENT_ERROR_PARAMETER_NOT_FOUND
//
// MessageText:
//
//  Parameter not found.
//
#define CRS_EVENT_ERROR_PARAMETER_NOT_FOUND 0xC000372AL

//
// MessageId: CRS_EVENT_ERROR_REPLICATION_RUNNING
//
// MessageText:
//
//  Project is running.  The operation could not be completed.
//
#define CRS_EVENT_ERROR_REPLICATION_RUNNING 0xC000372BL

//
// MessageId: CRS_EVENT_ERROR_INVALID_PROJECT_NAME
//
// MessageText:
//
//  Project name is invalid.  Project names cannot contain backslashes and cannot be empty.
//
#define CRS_EVENT_ERROR_INVALID_PROJECT_NAME 0xC000372CL

//
// MessageId: CRS_EVENT_ERROR_INVALID_ROUTE_NAME
//
// MessageText:
//
//  Route name is invalid.  Route names cannot contain backslashes or DBCS characters and cannot be empty.
//
#define CRS_EVENT_ERROR_INVALID_ROUTE_NAME 0xC000372DL

//
// MessageId: CRS_EVENT_ERROR_INVALID_DWORD
//
// MessageText:
//
//  Parameter must be a positive integer.
//
#define CRS_EVENT_ERROR_INVALID_DWORD    0xC000372EL

//
// MessageId: CRS_EVENT_ERROR_NO_MORE_ITEMS
//
// MessageText:
//
//  No more items are in the list.
//
#define CRS_EVENT_ERROR_NO_MORE_ITEMS    0x8000372FL

//
// MessageId: CRS_EVENT_ERROR_TOO_MANY_ARGS
//
// MessageText:
//
//  Too many arguments specified.
//
#define CRS_EVENT_ERROR_TOO_MANY_ARGS    0xC0003730L

//
// MessageId: CRS_EVENT_MBS_INIT_ERROR
//
// MessageText:
//
//  Internal error trying to initialize for ACL replication.
//
#define CRS_EVENT_MBS_INIT_ERROR         0xC0003731L

//
// MessageId: CRS_EVENT_ERROR_OPENING_FILE
//
// MessageText:
//
//  Error opening file or file not found.
//
#define CRS_EVENT_ERROR_OPENING_FILE     0xC0003733L

//
// MessageId: CRS_EVENT_ERROR_FILE_FORMAT
//
// MessageText:
//
//  Invalid file format.
//
#define CRS_EVENT_ERROR_FILE_FORMAT      0xC0003734L

//
// MessageId: CRS_EVENT_ERROR_FILE_WRITE
//
// MessageText:
//
//  Error writing to file.
//
#define CRS_EVENT_ERROR_FILE_WRITE       0xC0003735L

//
// MessageId: CRS_EVENT_WINSOCK_WSAHOSTNAME
//
// MessageText:
//
//  Gethostname failed.
//
#define CRS_EVENT_WINSOCK_WSAHOSTNAME    0xC0003736L

//
// MessageId: CRS_EVENT_ERROR_INVALID_CONTEXT
//
// MessageText:
//
//  Current context is invalid.  Project being reset.
//
#define CRS_EVENT_ERROR_INVALID_CONTEXT  0xC000373DL

//
// MessageId: CRS_EVENT_ERROR_DOWNLEVEL_SERVER
//
// MessageText:
//
//  Operation is not supported on a down-level server.
//
#define CRS_EVENT_ERROR_DOWNLEVEL_SERVER 0xC000373EL

//
// MessageId: CRS_EVENT_ERROR_NO_MAPPING
//
// MessageText:
//
//  URL does not map to any project definitions.
//
#define CRS_EVENT_ERROR_NO_MAPPING       0xC000373FL

//
// MessageId: CRS_EVENT_ERROR_START_PENDING
//
// MessageText:
//
//  Start pending completion of the active project.
//
#define CRS_EVENT_ERROR_START_PENDING    0xC0003740L

//
// MessageId: CRS_EVENT_ERROR_NO_EVENTSINKS
//
// MessageText:
//
//  No event sinks defined.
//
#define CRS_EVENT_ERROR_NO_EVENTSINKS    0xC0003741L

//
// MessageId: CRS_EVENT_ERROR_EVENTSINK_NOT_FOUND
//
// MessageText:
//
//  Could not find event sink.
//
#define CRS_EVENT_ERROR_EVENTSINK_NOT_FOUND 0xC0003742L

//
// MessageId: CRS_EVENT_ERROR_WSAHOSTNOTFOUND
//
// MessageText:
//
//  Host not found.
//
#define CRS_EVENT_ERROR_WSAHOSTNOTFOUND  0xC0003743L

//
// MessageId: CRS_EVENT_ERROR_WSATRYAGAIN
//
// MessageText:
//
//  Host not found, or SERVERFAIL.  Try again.
//
#define CRS_EVENT_ERROR_WSATRYAGAIN      0xC0003744L

//
// MessageId: CRS_EVENT_ERROR_WSANORECOVERY
//
// MessageText:
//
//  Non-recoverable winsock error.
//
#define CRS_EVENT_ERROR_WSANORECOVERY    0xC0003745L

//
// MessageId: CRS_EVENT_ERROR_WSANODATA
//
// MessageText:
//
//  Invalid address.
//
#define CRS_EVENT_ERROR_WSANODATA        0xC0003746L

//
// MessageId: CRS_EVENT_EVENTSINK_INITIALIZED
//
// MessageText:
//
//  Event sink specified by the data field was successfully initialized.
//
#define CRS_EVENT_EVENTSINK_INITIALIZED  0x00003747L

//
// MessageId: CRS_EVENT_ERROR_EVENTSINK_NOT_INITIALIZED
//
// MessageText:
//
//  Event sink specified by the data field failed to initialize.
//
#define CRS_EVENT_ERROR_EVENTSINK_NOT_INITIALIZED 0xC0003748L

//
// MessageId: CRS_EVENT_ERROR_NOTHING_TO_ROLLBACK
//
// MessageText:
//
//  Could not roll back project.  No rollback information found.
//
#define CRS_EVENT_ERROR_NOTHING_TO_ROLLBACK 0xC0003749L

//
// MessageId: CRS_EVENT_ERROR_NO_DESTINATIONS
//
// MessageText:
//
//  Project could not be started because no destinations are defined.
//
#define CRS_EVENT_ERROR_NO_DESTINATIONS  0xC000374AL

//
// MessageId: CRS_EVENT_ERROR_REAUTHENTICATE
//
// MessageText:
//
//  Re-authenticate using an acceptable protocol.
//
#define CRS_EVENT_ERROR_REAUTHENTICATE   0xC000374BL

//
// MessageId: CRS_EVENT_ERROR_UNSUPPORTED
//
// MessageText:
//
//  Function not supported in this version to this server.
//
#define CRS_EVENT_ERROR_UNSUPPORTED      0xC000374CL

//
// MessageId: CRS_EVENT_ERROR_USER_NOT_FOUND
//
// MessageText:
//
//  Specified user could not be found.
//
#define CRS_EVENT_ERROR_USER_NOT_FOUND   0xC000374DL

//
// MessageId: CRS_EVENT_ERROR_NO_TRANSACTIONS
//
// MessageText:
//
//  No transactions for the specified project.
//
#define CRS_EVENT_ERROR_NO_TRANSACTIONS  0xC000374EL

//
// MessageId: CRS_EVENT_ERROR_NO_SERVERS
//
// MessageText:
//
//  No destination servers defined.
//
#define CRS_EVENT_ERROR_NO_SERVERS       0xC000374FL

//
// MessageId: CRS_EVENT_ERROR_NO_SCHEDULES
//
// MessageText:
//
//  No schedules are defined for this project.
//
#define CRS_EVENT_ERROR_NO_SCHEDULES     0xC0003750L

//
// MessageId: CRS_EVENT_ERROR_NO_EMAIL
//
// MessageText:
//
//  Could not contact SMTP server to send e-mail report.
//
#define CRS_EVENT_ERROR_NO_EMAIL         0xC0003751L

//
// MessageId: CRS_EVENT_ERROR_WAIT_ABORT
//
// MessageText:
//
//  Waiting to abort after losing connection with source server.
//
#define CRS_EVENT_ERROR_WAIT_ABORT       0xC0003752L

//
// MessageId: CRS_EVENT_RESUME_REPLICATION
//
// MessageText:
//
//  Resuming project.
//
#define CRS_EVENT_RESUME_REPLICATION     0x40003753L

//
// MessageId: CRS_EVENT_METABASE_NOT_FOUND
//
// MessageText:
//
//  Metabase is not responding.
//
#define CRS_EVENT_METABASE_NOT_FOUND     0xC0003754L

//
// MessageId: CRS_EVENT_SSE_VROOT_NOT_FOUND
//
// MessageText:
//
//  Site Server virtual directory not found.
//
#define CRS_EVENT_SSE_VROOT_NOT_FOUND    0xC0003755L

//
// MessageId: CRS_EVENT_WARNING_CONNECTION_FAILED
//
// MessageText:
//
//  Connection failed.  Will attempt to re-establish session.
//
#define CRS_EVENT_WARNING_CONNECTION_FAILED 0x80003756L

//
// MessageId: CRS_EVENT_ERROR_DROPPED_EMAIL_REPORT
//
// MessageText:
//
//  Dropped e-mail report.
//
#define CRS_EVENT_ERROR_DROPPED_EMAIL_REPORT 0xC0003757L

//
// MessageId: CRS_EVENT_ERROR_EMAIL_HOST_NOT_DEFINED
//
// MessageText:
//
//  No SMTP server defined.
//
#define CRS_EVENT_ERROR_EMAIL_HOST_NOT_DEFINED 0xC0003758L

//
// MessageId: CRS_EVENT_VROOT_CREATION
//
// MessageText:
//
//  Could not create the specified virtual directory.
//
#define CRS_EVENT_VROOT_CREATION         0x80003759L

//
// MessageId: CRS_EVENT_UPLPAGE_CREATION
//
// MessageText:
//
//  Could not create the upload page.
//
#define CRS_EVENT_UPLPAGE_CREATION       0xC000375AL

//
// MessageId: CRS_EVENT_ERROR_CIRCULAR_ROUTE
//
// MessageText:
//
//  System has detected a circular route.  Project not created.
//
#define CRS_EVENT_ERROR_CIRCULAR_ROUTE   0xC000375BL

//
// MessageId: CRS_EVENT_ERROR_TRANSACTION_APPLY_FAILED
//
// MessageText:
//
//  Transaction application failed.  Check permissions on the destination directory and files and ensure that no files are locked open.
//
#define CRS_EVENT_ERROR_TRANSACTION_APPLY_FAILED 0xC000375CL

//
// MessageId: CRS_EVENT_ERROR_DATABASE
//
// MessageText:
//
//  Database error occurred.
//
#define CRS_EVENT_ERROR_DATABASE         0xC000375DL

//
// MessageId: CRS_EVENT_ERROR_SINK_CONNECT_FAILED
//
// MessageText:
//
//  Unable to connect to remote server to forward events.
//
#define CRS_EVENT_ERROR_SINK_CONNECT_FAILED 0xC000375EL

//
// MessageId: CRS_EVENT_ERROR_CANT_SEND_EVENTS_TO_DOWNLEVEL_SERVER
//
// MessageText:
//
//  Unable to send events to the destination server.  This operation is not supported.
//
#define CRS_EVENT_ERROR_CANT_SEND_EVENTS_TO_DOWNLEVEL_SERVER 0xC000375FL

//
// MessageId: CRS_EVENT_ERROR_FILE_CORRUPT
//
// MessageText:
//
//  File is corrupt or unreadable.
//
#define CRS_EVENT_ERROR_FILE_CORRUPT     0xC0003760L

//
// MessageId: CRS_EVENT_ERROR_FILE_BUSY
//
// MessageText:
//
//  File is busy.
//
#define CRS_EVENT_ERROR_FILE_BUSY        0xC0003761L

//
// MessageId: CRS_EVENT_ACL_ERROR_INVALID_ACE
//
// MessageText:
//
//  Could not set the ACE on this file.
//
#define CRS_EVENT_ACL_ERROR_INVALID_ACE  0x80003762L

//
// MessageId: CRS_EVENT_ACL_ERROR_ACL_FAILED
//
// MessageText:
//
//  Could not set the ACLs appropriately on this file, setting default ACLs on this file.
//
#define CRS_EVENT_ACL_ERROR_ACL_FAILED   0xC0003763L

//
// MessageId: CRS_EVENT_ERROR_PROJECT_NOT_FOUND_ON_DESTINATION
//
// MessageText:
//
//  Could not find project on the destination server.
//
#define CRS_EVENT_ERROR_PROJECT_NOT_FOUND_ON_DESTINATION 0xC0003764L

//
// MessageId: CRS_EVENT_ERROR_PROJECT_INCOMPLETE_ON_DESTINATION
//
// MessageText:
//
//  Project information is incomplete on the destination server.
//
#define CRS_EVENT_ERROR_PROJECT_INCOMPLETE_ON_DESTINATION 0xC0003765L

//
// MessageId: CRS_EVENT_ERROR_SERVICE_DOWN_ON_REMOTE_SERVER
//
// MessageText:
//
//  Remote server is available, but the Site Server Content Deployment service is not running.
//
#define CRS_EVENT_ERROR_SERVICE_DOWN_ON_REMOTE_SERVER 0xC0003766L

//
// MessageId: CRS_EVENT_ERROR_DISK_FULL_ON_DESTINATION
//
// MessageText:
//
//  Disk is full on the destination server.
//
#define CRS_EVENT_ERROR_DISK_FULL_ON_DESTINATION 0xC0003767L

//
// MessageId: CRS_EVENT_FILE_CREATE_ERROR_ON_DESTINATION
//
// MessageText:
//
//  Unable to open a file on the destination server.  Check permissions on the project directory and files.
//
#define CRS_EVENT_FILE_CREATE_ERROR_ON_DESTINATION 0xC0003768L

//
// MessageId: CRS_EVENT_ERROR_REMOTE_SERVER_NOT_FOUND
//
// MessageText:
//
//  Remote server could not be found.
//
#define CRS_EVENT_ERROR_REMOTE_SERVER_NOT_FOUND 0xC0003769L

//
// MessageId: CRS_EVENT_ERROR_REMOTE_APPLY_FAILED
//
// MessageText:
//
//  Unable to apply transactions on the destination server.
//
#define CRS_EVENT_ERROR_REMOTE_APPLY_FAILED 0xC000376AL

//
// MessageId: CRS_EVENT_ERROR_INVALID_FLAG_COMBINATION
//
// MessageText:
//
//  Invalid flag combination.
//
#define CRS_EVENT_ERROR_INVALID_FLAG_COMBINATION 0xC000376BL

//
// MessageId: CRS_EVENT_ERROR_RUNNING_SCRIPT
//
// MessageText:
//
//  There was an error running the script.  Ensure that the script exists and can be located in the path.
//
#define CRS_EVENT_ERROR_RUNNING_SCRIPT   0xC000376CL

//
// MessageId: CRS_EVENT_ERROR_CANT_FORWARD_TO_LOCAL_SERVER
//
// MessageText:
//
//  Cannot forward events to the local server.
//
#define CRS_EVENT_ERROR_CANT_FORWARD_TO_LOCAL_SERVER 0xC000376DL

//
// MessageId: CRS_EVENT_ERROR_SCHEDULE_NOT_FOUND
//
// MessageText:
//
//  Specified project schedule could not be found.
//
#define CRS_EVENT_ERROR_SCHEDULE_NOT_FOUND 0xC000376EL

//
// MessageId: CRS_EVENT_ERROR_METABASE
//
// MessageText:
//
//  An error occurred accessing the metabase.  Ensure that the web site exists and that the account has access to it.
//
#define CRS_EVENT_ERROR_METABASE         0xC000376FL

//
// MessageId: CRS_EVENT_ERROR_SCHEDULER_FAILURE
//
// MessageText:
//
//  An error occurred with the task scheduler.
//
#define CRS_EVENT_ERROR_SCHEDULER_FAILURE 0xC0003770L

//
// MessageId: CRS_EVENT_SAMEBOX_META_TARGET
//
// MessageText:
//
//  A destination for metabase replication is invalid.
//
#define CRS_EVENT_SAMEBOX_META_TARGET    0xC0003771L

//
// MessageId: CRS_EVENT_ERROR_DROPPED_EVENTS
//
// MessageText:
//
//  The event sink specified by the data field has started dropping events.
//
#define CRS_EVENT_ERROR_DROPPED_EVENTS   0xC0003772L

//
// MessageId: CRS_EVENT_REPLICATION_FIRST
//
// MessageText:
//
//  Site Server Content Deployment first replication event message.
//
#define CRS_EVENT_REPLICATION_FIRST      0x400037DCL

//
// MessageId: CRS_EVENT_STARTING_REPLICATION
//
// MessageText:
//
//  Project starting to the destination server.
//
#define CRS_EVENT_STARTING_REPLICATION   0x400037DDL

//
// MessageId: CRS_EVENT_REPLICATION_COMPLETE
//
// MessageText:
//
//  Project complete to the destination server.
//
#define CRS_EVENT_REPLICATION_COMPLETE   0x400037DEL

//
// MessageId: CRS_EVENT_STARTING_PULL_REPLICATION
//
// MessageText:
//
//  Retrieval project starting.
//
#define CRS_EVENT_STARTING_PULL_REPLICATION 0x400037DFL

//
// MessageId: CRS_EVENT_PULL_REPLICATION_COMPLETE
//
// MessageText:
//
//  Retrieval project complete.
//
#define CRS_EVENT_PULL_REPLICATION_COMPLETE 0x400037E0L

//
// MessageId: CRS_EVENT_STARTING_RECEIVE_REPLICATION
//
// MessageText:
//
//  Starting to receive project.
//
#define CRS_EVENT_STARTING_RECEIVE_REPLICATION 0x400037E1L

//
// MessageId: CRS_EVENT_REPLICATION_RECEIVE_COMPLETE
//
// MessageText:
//
//  Finished receiving project.
//
#define CRS_EVENT_REPLICATION_RECEIVE_COMPLETE 0x400037E2L

//
// MessageId: CRS_EVENT_STARTING_REPLICATION_SCAN
//
// MessageText:
//
//  Project starting.
//
#define CRS_EVENT_STARTING_REPLICATION_SCAN 0x400037E3L

//
// MessageId: CRS_EVENT_REPLICATION_LAST
//
// MessageText:
//
//  Site Server Content Deployment last replication event message.
//
#define CRS_EVENT_REPLICATION_LAST       0x4000380DL

//
// MessageId: CRS_EVENT_FILE_FIRST
//
// MessageText:
//
//  Site Server Content Deployment first file event message.
//
#define CRS_EVENT_FILE_FIRST             0x4000380EL

//
// MessageId: CRS_EVENT_SENDING_FILE
//
// MessageText:
//
//  Sending file.
//
#define CRS_EVENT_SENDING_FILE           0x4000380FL

//
// MessageId: CRS_EVENT_SENT_FILE
//
// MessageText:
//
//  File sent.
//
#define CRS_EVENT_SENT_FILE              0x40003810L

//
// MessageId: CRS_EVENT_RECEIVING_FILE
//
// MessageText:
//
//  Receiving file.
//
#define CRS_EVENT_RECEIVING_FILE         0x40003811L

//
// MessageId: CRS_EVENT_RECEIVED_FILE
//
// MessageText:
//
//  File received.
//
#define CRS_EVENT_RECEIVED_FILE          0x40003812L

//
// MessageId: CRS_EVENT_SENT_DELETE_FILE
//
// MessageText:
//
//  Sent delete file request.
//
#define CRS_EVENT_SENT_DELETE_FILE       0x40003813L

//
// MessageId: CRS_EVENT_RECEIVED_DELETE_FILE
//
// MessageText:
//
//  File delete request received.
//
#define CRS_EVENT_RECEIVED_DELETE_FILE   0x40003814L

//
// MessageId: CRS_EVENT_RETRYING_SENDING_FILE
//
// MessageText:
//
//  Retrying to send file.
//
#define CRS_EVENT_RETRYING_SENDING_FILE  0x40003818L

//
// MessageId: CRS_EVENT_FILE_BUSY
//
// MessageText:
//
//  File is busy.  The service is waiting for the file to become available.
//
#define CRS_EVENT_FILE_BUSY              0x40003819L

//
// MessageId: CRS_EVENT_SENDING_ACL
//
// MessageText:
//
//  Sending the ACL for this file.
//
#define CRS_EVENT_SENDING_ACL            0x4000381AL

//
// MessageId: CRS_EVENT_SENT_ACL
//
// MessageText:
//
//  Sent the ACL for this file.
//
#define CRS_EVENT_SENT_ACL               0x4000381BL

//
// MessageId: CRS_EVENT_RECEIVING_ACL
//
// MessageText:
//
//  Receiving the ACL for this file.
//
#define CRS_EVENT_RECEIVING_ACL          0x4000381CL

//
// MessageId: CRS_EVENT_RECEIVED_ACL
//
// MessageText:
//
//  Received the ACL for this file.
//
#define CRS_EVENT_RECEIVED_ACL           0x4000381DL

//
// MessageId: CRS_EVENT_PULLED_FILE_HTTP
//
// MessageText:
//
//  File retrieved over HTTP.
//
#define CRS_EVENT_PULLED_FILE_HTTP       0x4000381EL

//
// MessageId: CRS_EVENT_PULLED_FILE_FTP
//
// MessageText:
//
//  File retrieved over FTP.
//
#define CRS_EVENT_PULLED_FILE_FTP        0x4000381FL

//
// MessageId: CRS_EVENT_FILE_COMMITTED
//
// MessageText:
//
//  File committed to disk.
//
#define CRS_EVENT_FILE_COMMITTED         0x40003820L

//
// MessageId: CRS_EVENT_FILE_DELETED
//
// MessageText:
//
//  File deleted.
//
#define CRS_EVENT_FILE_DELETED           0x40003821L

//
// MessageId: CRS_EVENT_SKIPPING_LOCKED_FILE
//
// MessageText:
//
//  File skipped because it could not be opened.
//
#define CRS_EVENT_SKIPPING_LOCKED_FILE   0x80003822L

//
// MessageId: CRS_EVENT_FILE_MATCHED
//
// MessageText:
//
//  File matched.
//
#define CRS_EVENT_FILE_MATCHED           0x40003823L

//
// MessageId: CRS_EVENT_FILE_LAST
//
// MessageText:
//
//  Site Server Content Deployment last file event message.
//
#define CRS_EVENT_FILE_LAST              0x4000383FL

//
// MessageId: CRS_EVENT_ADMIN_FIRST
//
// MessageText:
//
//  Site Server Content Deployment first administration event message.
//
#define CRS_EVENT_ADMIN_FIRST            0x40003840L

//
// MessageId: CRS_EVENT_PROJECT_CREATED
//
// MessageText:
//
//  Project created.
//
#define CRS_EVENT_PROJECT_CREATED        0x40003841L

//
// MessageId: CRS_EVENT_PROJECT_DELETED
//
// MessageText:
//
//  Project deleted.
//
#define CRS_EVENT_PROJECT_DELETED        0x40003842L

//
// MessageId: CRS_EVENT_PROJECT_EDITED
//
// MessageText:
//
//  Project edited.
//
#define CRS_EVENT_PROJECT_EDITED         0x40003843L

//
// MessageId: CRS_EVENT_ROUTE_CREATED
//
// MessageText:
//
//  Route created.
//
#define CRS_EVENT_ROUTE_CREATED          0x40003844L

//
// MessageId: CRS_EVENT_ROUTE_DELETED
//
// MessageText:
//
//  Route deleted.
//
#define CRS_EVENT_ROUTE_DELETED          0x40003845L

//
// MessageId: CRS_EVENT_ROUTE_EDITED
//
// MessageText:
//
//  Route edited.
//
#define CRS_EVENT_ROUTE_EDITED           0x40003846L

//
// MessageId: CRS_EVENT_SERVER_EDITED
//
// MessageText:
//
//  Server settings modified.
//
#define CRS_EVENT_SERVER_EDITED          0x40003847L

//
// MessageId: CRS_EVENT_EVENTSINK_CREATED
//
// MessageText:
//
//  Event sink specified by the data field was added.
//
#define CRS_EVENT_EVENTSINK_CREATED      0x40003848L

//
// MessageId: CRS_EVENT_EVENTSINK_DELETED
//
// MessageText:
//
//  Event sink specified by the data field was deleted.
//
#define CRS_EVENT_EVENTSINK_DELETED      0x40003849L

//
// MessageId: CRS_EVENT_CLEARED_EVENTS
//
// MessageText:
//
//  Event store specified by the data field was cleared.
//
#define CRS_EVENT_CLEARED_EVENTS         0x4000384AL

//
// MessageId: CRS_EVENT_CLEARED_ALL_EVENTS
//
// MessageText:
//
//  Each database event store on this server was cleared.
//
#define CRS_EVENT_CLEARED_ALL_EVENTS     0x4000384BL

//
// MessageId: CRS_EVENT_ADMIN_LAST
//
// MessageText:
//
//  Site Server Content Deployment last administration event message.
//
#define CRS_EVENT_ADMIN_LAST             0x40003872L

//
// MessageId: CRS_EVENT_SUMMARY_FIRST
//
// MessageText:
//
//  Site Server Content Deployment first summary event message.
//
#define CRS_EVENT_SUMMARY_FIRST          0x400038A4L

//
// MessageId: CRS_EVENT_SUMMARY_RECEIVE
//
// MessageText:
//
//  Project summary information (files received).
//
#define CRS_EVENT_SUMMARY_RECEIVE        0x400038A5L

//
// MessageId: CRS_EVENT_SUMMARY_SEND
//
// MessageText:
//
//  Project summary information (files sent).
//
#define CRS_EVENT_SUMMARY_SEND           0x400038A6L

//
// MessageId: CRS_EVENT_SUMMARY_PULL
//
// MessageText:
//
//  Project summary information (files pulled).
//
#define CRS_EVENT_SUMMARY_PULL           0x400038A7L

//
// MessageId: CRS_EVENT_SUMMARY_AUTOMATIC_RECEIVE
//
// MessageText:
//
//  Automatic project (receive) checkpoint summary information.
//
#define CRS_EVENT_SUMMARY_AUTOMATIC_RECEIVE 0x400038A8L

//
// MessageId: CRS_EVENT_SUMMARY_AUTOMATIC_SEND
//
// MessageText:
//
//  Automatic project (send) checkpoint summary information.
//
#define CRS_EVENT_SUMMARY_AUTOMATIC_SEND 0x400038A9L

//
// MessageId: CRS_EVENT_SUMMARY_RECEIVE_MATCHED
//
// MessageText:
//
//  Project summary information (files matched during receive).
//
#define CRS_EVENT_SUMMARY_RECEIVE_MATCHED 0x400038AAL

//
// MessageId: CRS_EVENT_SUMMARY_SEND_MATCHED
//
// MessageText:
//
//  Project summary information (files matched during send).
//
#define CRS_EVENT_SUMMARY_SEND_MATCHED   0x400038ABL

//
// MessageId: CRS_EVENT_SUMMARY_PULL_MATCHED
//
// MessageText:
//
//  Project summary information (files matched during pull).
//
#define CRS_EVENT_SUMMARY_PULL_MATCHED   0x400038ACL

//
// MessageId: CRS_EVENT_SUMMARY_RECEIVE_ERRORED
//
// MessageText:
//
//  Project summary information (files errored during receive).
//
#define CRS_EVENT_SUMMARY_RECEIVE_ERRORED 0x400038ADL

//
// MessageId: CRS_EVENT_SUMMARY_SEND_ERRORED
//
// MessageText:
//
//  Project summary information (files errored during send).
//
#define CRS_EVENT_SUMMARY_SEND_ERRORED   0x400038AEL

//
// MessageId: CRS_EVENT_SUMMARY_PULL_ERRORED
//
// MessageText:
//
//  Project summary information (files errored during pull).
//
#define CRS_EVENT_SUMMARY_PULL_ERRORED   0x400038AFL

//
// MessageId: CRS_EVENT_SUMMARY_LAST
//
// MessageText:
//
//  Site Server Content Deployment last summary event message.
//
#define CRS_EVENT_SUMMARY_LAST           0x400038D6L

//
// MessageId: CRS_EVENT_CAB_ERROR_FIRST
//
// MessageText:
//
//  Remote installer first error message.
//
#define CRS_EVENT_CAB_ERROR_FIRST        0xC0003908L

//
// MessageId: CRS_EVENT_CAB_ERROR_CABINET_NOT_FOUND
//
// MessageText:
//
//  Cannot find the specified cabinet file.
//
#define CRS_EVENT_CAB_ERROR_CABINET_NOT_FOUND 0xC0003909L

//
// MessageId: CRS_EVENT_CAB_ERROR_NOT_A_CABINET
//
// MessageText:
//
//  Specified file is not a valid cabinet file.
//
#define CRS_EVENT_CAB_ERROR_NOT_A_CABINET 0xC000390AL

//
// MessageId: CRS_EVENT_CAB_ERROR_UNKNOWN_CABINET_VERSION
//
// MessageText:
//
//  Specified file is an unknown version of a cabinet file.
//
#define CRS_EVENT_CAB_ERROR_UNKNOWN_CABINET_VERSION 0xC000390BL

//
// MessageId: CRS_EVENT_CAB_ERROR_CORRUPT_CABINET
//
// MessageText:
//
//  Specified cabinet file is corrupt.
//
#define CRS_EVENT_CAB_ERROR_CORRUPT_CABINET 0xC000390CL

//
// MessageId: CRS_EVENT_CAB_ERROR_ALLOC_FAIL
//
// MessageText:
//
//  Out of memory.
//
#define CRS_EVENT_CAB_ERROR_ALLOC_FAIL   0xC000390DL

//
// MessageId: CRS_EVENT_CAB_ERROR_BAD_COMPR_TYPE
//
// MessageText:
//
//  Specified cabinet file uses an unknown compression type.
//
#define CRS_EVENT_CAB_ERROR_BAD_COMPR_TYPE 0xC000390EL

//
// MessageId: CRS_EVENT_CAB_ERROR_MDI_FAIL
//
// MessageText:
//
//  Compressed data in the specified cabinet file is corrupt.
//
#define CRS_EVENT_CAB_ERROR_MDI_FAIL     0xC000390FL

//
// MessageId: CRS_EVENT_CAB_ERROR_TARGET_FILE
//
// MessageText:
//
//  Could not save extracted files from the specified cabinet file.
//
#define CRS_EVENT_CAB_ERROR_TARGET_FILE  0xC0003910L

//
// MessageId: CRS_EVENT_CAB_ERROR_RESERVE_MISMATCH
//
// MessageText:
//
//  Specified cabinet file has a non-valid RESERVE size.
//
#define CRS_EVENT_CAB_ERROR_RESERVE_MISMATCH 0xC0003911L

//
// MessageId: CRS_EVENT_CAB_ERROR_WRONG_CABINET
//
// MessageText:
//
//  Specified cabinet file is not the right cabinet in the set.
//
#define CRS_EVENT_CAB_ERROR_WRONG_CABINET 0xC0003912L

//
// MessageId: CRS_EVENT_CAB_ERROR_USER_ABORT
//
// MessageText:
//
//  Could not extract the specified cabinet file. User aborted the operation.
//
#define CRS_EVENT_CAB_ERROR_USER_ABORT   0xC0003913L

//
// MessageId: CRS_EVENT_CAB_WARNING_CAB_NOT_SIGNED
//
// MessageText:
//
//  Specified cabinet file is not a signed cabinet file.
//
#define CRS_EVENT_CAB_WARNING_CAB_NOT_SIGNED 0x80003914L

//
// MessageId: CRS_EVENT_CAB_WARNING_SIGNATURE_NOT_VERIFIED
//
// MessageText:
//
//  Signature on the specified cabinet could not be verified.
//
#define CRS_EVENT_CAB_WARNING_SIGNATURE_NOT_VERIFIED 0x80003915L

//
// MessageId: CRS_EVENT_CAB_ERROR_INFFILE_NOT_FOUND
//
// MessageText:
//
//  INF file was not found inside the specified cabinet file.
//
#define CRS_EVENT_CAB_ERROR_INFFILE_NOT_FOUND 0xC0003916L

//
// MessageId: CRS_EVENT_INF_ERROR_ADVPACK_NOT_LOADED
//
// MessageText:
//
//  Could not load ADVPACK.DLL.
//
#define CRS_EVENT_INF_ERROR_ADVPACK_NOT_LOADED 0xC0003917L

//
// MessageId: CRS_EVENT_INF_ERROR_ADVPACK_WRONG_VERSION
//
// MessageText:
//
//  This version of ADVPACK.DLL is not supported.
//
#define CRS_EVENT_INF_ERROR_ADVPACK_WRONG_VERSION 0xC0003918L

//
// MessageId: CRS_EVENT_INF_ERROR_INVALID_INF
//
// MessageText:
//
//  INF file found inside the specified cabinet file is not a valid INF file.
//
#define CRS_EVENT_INF_ERROR_INVALID_INF  0xC0003919L

//
// MessageId: CRS_EVENT_INF_ERROR_NOTHING_TO_INSTALL
//
// MessageText:
//
//  Could not find any of the remote install sections inside the INF file.
//
#define CRS_EVENT_INF_ERROR_NOTHING_TO_INSTALL 0xC000391AL

//
// MessageId: CRS_EVENT_INF_ERROR_NOTHING_TO_UNINSTALL
//
// MessageText:
//
//  Could not find any of the remote uninstall sections inside the INF file.
//
#define CRS_EVENT_INF_ERROR_NOTHING_TO_UNINSTALL 0xC000391BL

//
// MessageId: CRS_EVENT_INF_ERROR_BUSY_FILES
//
// MessageText:
//
//  Files are busy.  Cannot install them unless allowed to reboot.
//
#define CRS_EVENT_INF_ERROR_BUSY_FILES   0xC000391CL

//
// MessageId: CRS_EVENT_CAB_WARNING_MANUAL_REBOOT
//
// MessageText:
//
//  Setup completed successfully. The server could not be rebooted automatically. Manual reboot is necessary.
//
#define CRS_EVENT_CAB_WARNING_MANUAL_REBOOT 0x8000391DL

//
// MessageId: CRS_EVENT_CAB_WARNING_REBOOT_NEEDED
//
// MessageText:
//
//  Setup completed successfully. The files became busy during setup.  Manual reboot is necessary.
//
#define CRS_EVENT_CAB_WARNING_REBOOT_NEEDED 0x8000391EL

//
// MessageId: CRS_EVENT_INF_SUCCESS_REBOOT_IN_PROGRESS
//
// MessageText:
//
//  Setup completed successfully. The server is being rebooted.
//
#define CRS_EVENT_INF_SUCCESS_REBOOT_IN_PROGRESS 0x0000391FL

//
// MessageId: CRS_EVENT_INF_SUCCESS
//
// MessageText:
//
//  Setup completed successfully.
//
#define CRS_EVENT_INF_SUCCESS            0x00003921L

//
// MessageId: CRS_EVENT_INF_ERROR_BUSY_FILES_UNINSTALL
//
// MessageText:
//
//  Files are busy.  Cannot uninstall them unless allowed to reboot.
//
#define CRS_EVENT_INF_ERROR_BUSY_FILES_UNINSTALL 0xC0003922L

//
// MessageId: CRS_EVENT_CAB_WARNING_MANUAL_REBOOT_UNINSTALL
//
// MessageText:
//
//  Uninstall completed successfully. The server could not be rebooted automatically. Manual reboot is necessary.
//
#define CRS_EVENT_CAB_WARNING_MANUAL_REBOOT_UNINSTALL 0x80003923L

//
// MessageId: CRS_EVENT_CAB_WARNING_REBOOT_NEEDED_UNINSTALL
//
// MessageText:
//
//  Uninstall completed successfully. The files became busy during setup.  Manual reboot is necessary.
//
#define CRS_EVENT_CAB_WARNING_REBOOT_NEEDED_UNINSTALL 0x80003924L

//
// MessageId: CRS_EVENT_INF_SUCCESS_REBOOT_IN_PROGRESS_UNINSTALL
//
// MessageText:
//
//  Uninstall completed successfully. The server is being rebooted.
//
#define CRS_EVENT_INF_SUCCESS_REBOOT_IN_PROGRESS_UNINSTALL 0x00003925L

//
// MessageId: CRS_EVENT_INF_SUCCESS_UNINSTALL
//
// MessageText:
//
//  Uninstall completed successfully.
//
#define CRS_EVENT_INF_SUCCESS_UNINSTALL  0x00003926L

//
// MessageId: CRS_EVENT_CAB_ERROR_ADVPACK_FAILED
//
// MessageText:
//
//  Problem installing the CAB. Check CAB and INF files for validity. 
//
#define CRS_EVENT_CAB_ERROR_ADVPACK_FAILED 0xC0003927L

//
// MessageId: CRS_EVENT_CAB_ERROR_LOCKED_FILES
//
// MessageText:
//
//  At least one of the files inside the CAB is open for exclusive write/delete access.
//
#define CRS_EVENT_CAB_ERROR_LOCKED_FILES 0xC0003928L

//
// MessageId: CRS_EVENT_CAB_ERROR_UNKNOWN
//
// MessageText:
//
//  Unknown error occurred while processing the specified cabinet file.
//
#define CRS_EVENT_CAB_ERROR_UNKNOWN      0xC0003A06L

//
// MessageId: CRS_EVENT_CAB_ERROR_LAST
//
// MessageText:
//
//  Remote installer last event message.
//
#define CRS_EVENT_CAB_ERROR_LAST         0x40003A07L

//
// MessageId: CRS_EVENT_LAST
//
// MessageText:
//
//  Site Server Content Deployment last event message.
//
#define CRS_EVENT_LAST                   0x40003A97L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\CrsIntf.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Apr 23 13:37:19 1998
 */
/* Compiler settings for crsintf.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __crsintf_h__
#define __crsintf_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IReplicationServer_FWD_DEFINED__
#define __IReplicationServer_FWD_DEFINED__
typedef interface IReplicationServer IReplicationServer;
#endif 	/* __IReplicationServer_FWD_DEFINED__ */


#ifndef __IReplicationProject_FWD_DEFINED__
#define __IReplicationProject_FWD_DEFINED__
typedef interface IReplicationProject IReplicationProject;
#endif 	/* __IReplicationProject_FWD_DEFINED__ */


#ifndef __IReplicationItem_FWD_DEFINED__
#define __IReplicationItem_FWD_DEFINED__
typedef interface IReplicationItem IReplicationItem;
#endif 	/* __IReplicationItem_FWD_DEFINED__ */


#ifndef __IReplicationSchedule_FWD_DEFINED__
#define __IReplicationSchedule_FWD_DEFINED__
typedef interface IReplicationSchedule IReplicationSchedule;
#endif 	/* __IReplicationSchedule_FWD_DEFINED__ */


#ifndef __IReplicationEventSinkConfig_FWD_DEFINED__
#define __IReplicationEventSinkConfig_FWD_DEFINED__
typedef interface IReplicationEventSinkConfig IReplicationEventSinkConfig;
#endif 	/* __IReplicationEventSinkConfig_FWD_DEFINED__ */


#ifndef __IReplicationInstance_FWD_DEFINED__
#define __IReplicationInstance_FWD_DEFINED__
typedef interface IReplicationInstance IReplicationInstance;
#endif 	/* __IReplicationInstance_FWD_DEFINED__ */


#ifndef __IReplicationRoute_FWD_DEFINED__
#define __IReplicationRoute_FWD_DEFINED__
typedef interface IReplicationRoute IReplicationRoute;
#endif 	/* __IReplicationRoute_FWD_DEFINED__ */


#ifndef __IReplicationClient_FWD_DEFINED__
#define __IReplicationClient_FWD_DEFINED__
typedef interface IReplicationClient IReplicationClient;
#endif 	/* __IReplicationClient_FWD_DEFINED__ */


#ifndef __IReplicationClientError_FWD_DEFINED__
#define __IReplicationClientError_FWD_DEFINED__
typedef interface IReplicationClientError IReplicationClientError;
#endif 	/* __IReplicationClientError_FWD_DEFINED__ */


#ifndef __IReplicationPostingAcceptor_FWD_DEFINED__
#define __IReplicationPostingAcceptor_FWD_DEFINED__
typedef interface IReplicationPostingAcceptor IReplicationPostingAcceptor;
#endif 	/* __IReplicationPostingAcceptor_FWD_DEFINED__ */


#ifndef __CReplicationServer_FWD_DEFINED__
#define __CReplicationServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationServer CReplicationServer;
#else
typedef struct CReplicationServer CReplicationServer;
#endif /* __cplusplus */

#endif 	/* __CReplicationServer_FWD_DEFINED__ */


#ifndef __CReplicationProject_FWD_DEFINED__
#define __CReplicationProject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationProject CReplicationProject;
#else
typedef struct CReplicationProject CReplicationProject;
#endif /* __cplusplus */

#endif 	/* __CReplicationProject_FWD_DEFINED__ */


#ifndef __CReplicationInstance_FWD_DEFINED__
#define __CReplicationInstance_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationInstance CReplicationInstance;
#else
typedef struct CReplicationInstance CReplicationInstance;
#endif /* __cplusplus */

#endif 	/* __CReplicationInstance_FWD_DEFINED__ */


#ifndef __CReplicationRoute_FWD_DEFINED__
#define __CReplicationRoute_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationRoute CReplicationRoute;
#else
typedef struct CReplicationRoute CReplicationRoute;
#endif /* __cplusplus */

#endif 	/* __CReplicationRoute_FWD_DEFINED__ */


#ifndef __CReplicationClient_FWD_DEFINED__
#define __CReplicationClient_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationClient CReplicationClient;
#else
typedef struct CReplicationClient CReplicationClient;
#endif /* __cplusplus */

#endif 	/* __CReplicationClient_FWD_DEFINED__ */


#ifndef __CReplicationClientError_FWD_DEFINED__
#define __CReplicationClientError_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationClientError CReplicationClientError;
#else
typedef struct CReplicationClientError CReplicationClientError;
#endif /* __cplusplus */

#endif 	/* __CReplicationClientError_FWD_DEFINED__ */


#ifndef __CReplicationEventSinkConfig_FWD_DEFINED__
#define __CReplicationEventSinkConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationEventSinkConfig CReplicationEventSinkConfig;
#else
typedef struct CReplicationEventSinkConfig CReplicationEventSinkConfig;
#endif /* __cplusplus */

#endif 	/* __CReplicationEventSinkConfig_FWD_DEFINED__ */


#ifndef __CReplicationItem_FWD_DEFINED__
#define __CReplicationItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationItem CReplicationItem;
#else
typedef struct CReplicationItem CReplicationItem;
#endif /* __cplusplus */

#endif 	/* __CReplicationItem_FWD_DEFINED__ */


#ifndef __CReplicationSchedule_FWD_DEFINED__
#define __CReplicationSchedule_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationSchedule CReplicationSchedule;
#else
typedef struct CReplicationSchedule CReplicationSchedule;
#endif /* __cplusplus */

#endif 	/* __CReplicationSchedule_FWD_DEFINED__ */


#ifndef __CReplicationPostingAcceptor_FWD_DEFINED__
#define __CReplicationPostingAcceptor_FWD_DEFINED__

#ifdef __cplusplus
typedef class CReplicationPostingAcceptor CReplicationPostingAcceptor;
#else
typedef struct CReplicationPostingAcceptor CReplicationPostingAcceptor;
#endif /* __cplusplus */

#endif 	/* __CReplicationPostingAcceptor_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "crstypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_crsintf_0000
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#define	CRSEVENT_SEVERITY_SUCCESS	( 0 )

#define	CRSEVENT_SEVERITY_INFORMATIONAL	( 1 )

#define	CRSEVENT_SEVERITY_WARNING	( 2 )

#define	CRSEVENT_SEVERITY_ERROR	( 3 )

#define	CRSEVENT_CATEGORY_GENERAL	( 0 )

#define	CRSEVENT_CATEGORY_FILE	( 1 )

#define	CRSEVENT_CATEGORY_REPLICATION	( 2 )

#define	CRSEVENT_CATEGORY_ADMIN	( 3 )

#define	CRSEVENT_CATEGORY_SUMMARY	( 4 )

#define	EVFLAG_FILE_EVENTS	( 0x1 )

#define	EVFLAG_ADMIN_EVENTS	( 0x2 )

#define	EVFLAG_SUMMARY_EVENTS	( 0x4 )

#define	EVFLAG_REPLICATION_EVENTS	( 0x8 )

#define	EVFLAG_ALL	( 0xff )

#define	CRS_SCHEDULE_DAY_MONDAY	( 0x1 )

#define	CRS_SCHEDULE_DAY_TUESDAY	( 0x2 )

#define	CRS_SCHEDULE_DAY_WEDNESDAY	( 0x4 )

#define	CRS_SCHEDULE_DAY_THURSDAY	( 0x8 )

#define	CRS_SCHEDULE_DAY_FRIDAY	( 0x10 )

#define	CRS_SCHEDULE_DAY_SATURDAY	( 0x20 )

#define	CRS_SCHEDULE_DAY_SUNDAY	( 0x40 )

#define	CRS_SCHEDULE_DAILY	( 0xff )











extern RPC_IF_HANDLE __MIDL_itf_crsintf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_crsintf_0000_v0_0_s_ifspec;

#ifndef __IReplicationServer_INTERFACE_DEFINED__
#define __IReplicationServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationServer
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 


#ifndef _LPREPLICATIONROUTESDEFINED
#define _LPREPLICATIONROUTESDEFINED
typedef /* [unique] */ IReplicationRoute __RPC_FAR *LPREPLICATION_ROUTE;

#endif 
#ifndef _LPREPLICATIONSERVERDEFINED
#define _LPREPLICATIONSERVERDEFINED
typedef IReplicationServer __RPC_FAR *LPREPLICATION_SERVER;

#endif 
#ifndef _LPREPLICATIONPROJECTDEFINED
#define _LPREPLICATIONPROJECTDEFINED
typedef IReplicationProject __RPC_FAR *LPREPLICATION_PROJECT;

#endif 
#ifndef _LPREPLICATIONINSTANCEDEFINED
#define _LPREPLICATIONINSTANCEDEFINED
typedef IReplicationInstance __RPC_FAR *LPREPLICATION_INSTANCE;

#endif 

EXTERN_C const IID IID_IReplicationServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("ABEB9802-DB7A-11d0-A800-00C04FC9DAA5")
    IReplicationServer : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR pszServer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [in] */ BSTR pszServer,
            /* [in] */ BSTR pszUserName,
            /* [in] */ BSTR pszPassword,
            /* [in] */ LONG lTimeout) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OpenProject( 
            /* [string][in] */ BSTR pszProject,
            /* [in] */ CRS_PROJECT_CREATION cpcCreationFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvInfProject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteProject( 
            /* [string][in] */ BSTR pszProject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumProjects( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvInfProject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumServers( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [in] */ CRS_SERVER_TYPES Flags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrServer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OpenPostingAcceptor( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvIDispPA) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Continue( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ BSTR pszParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ BSTR pszParmName,
            /* [in] */ VARIANT vParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Enum( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out] */ VARIANT __RPC_FAR *pvParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddRoute( 
            /* [string][in] */ BSTR pszRoute,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRoute) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteRoute( 
            /* [string][in] */ BSTR pszRoute) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumRoutes( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRoute) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddEventSink( 
            /* [string][in] */ BSTR bstrSink,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdispSink) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteEventSink( 
            /* [string][in] */ BSTR bstrSink) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumEventSinks( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdispSink) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumReplications( 
            /* [string][in] */ BSTR pszMatchProject,
            /* [in] */ LONG lMatchState,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvReplInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CheckAccess( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvlAccessMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapUrl( 
            /* [string][in] */ BSTR bstrUrl,
            /* [out] */ VARIANT __RPC_FAR *vbstrSuffix,
            /* [retval][out] */ VARIANT __RPC_FAR *vdispProject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TranslateEventCode( 
            /* [in] */ LONG lEventCode,
            /* [out] */ VARIANT __RPC_FAR *vbstrDescription,
            /* [out] */ VARIANT __RPC_FAR *vlSeverity,
            /* [out] */ VARIANT __RPC_FAR *vlCategory) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearEvents( 
            /* [string][in] */ BSTR bstrEventSink) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_UseTransactions( 
            /* [string][in] */ BSTR pszTrans) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_UseTransactions( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvTrans) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvServer) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvVersion) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EventTimeToLocalTime( 
            /* [in] */ VARIANT vdateEventTime,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdateLocalTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReplicationServer __RPC_FAR * This,
            /* [in] */ BSTR pszServer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeEx )( 
            IReplicationServer __RPC_FAR * This,
            /* [in] */ BSTR pszServer,
            /* [in] */ BSTR pszUserName,
            /* [in] */ BSTR pszPassword,
            /* [in] */ LONG lTimeout);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenProject )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR pszProject,
            /* [in] */ CRS_PROJECT_CREATION cpcCreationFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvInfProject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProject )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR pszProject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumProjects )( 
            IReplicationServer __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvInfProject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumServers )( 
            IReplicationServer __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [in] */ CRS_SERVER_TYPES Flags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrServer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenPostingAcceptor )( 
            IReplicationServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvIDispPA);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IReplicationServer __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IReplicationServer __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IReplicationServer __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Continue )( 
            IReplicationServer __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR pszParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR pszParmName,
            /* [in] */ VARIANT vParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enum )( 
            IReplicationServer __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out] */ VARIANT __RPC_FAR *pvParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IReplicationServer __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRoute )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR pszRoute,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRoute);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteRoute )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR pszRoute);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRoutes )( 
            IReplicationServer __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRoute);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddEventSink )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR bstrSink,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdispSink);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteEventSink )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR bstrSink);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumEventSinks )( 
            IReplicationServer __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdispSink);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumReplications )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR pszMatchProject,
            /* [in] */ LONG lMatchState,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvReplInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckAccess )( 
            IReplicationServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvlAccessMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapUrl )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR bstrUrl,
            /* [out] */ VARIANT __RPC_FAR *vbstrSuffix,
            /* [retval][out] */ VARIANT __RPC_FAR *vdispProject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateEventCode )( 
            IReplicationServer __RPC_FAR * This,
            /* [in] */ LONG lEventCode,
            /* [out] */ VARIANT __RPC_FAR *vbstrDescription,
            /* [out] */ VARIANT __RPC_FAR *vlSeverity,
            /* [out] */ VARIANT __RPC_FAR *vlCategory);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearEvents )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR bstrEventSink);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UseTransactions )( 
            IReplicationServer __RPC_FAR * This,
            /* [string][in] */ BSTR pszTrans);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UseTransactions )( 
            IReplicationServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvTrans);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerName )( 
            IReplicationServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvServer);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            IReplicationServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvVersion);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EventTimeToLocalTime )( 
            IReplicationServer __RPC_FAR * This,
            /* [in] */ VARIANT vdateEventTime,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdateLocalTime);
        
        END_INTERFACE
    } IReplicationServerVtbl;

    interface IReplicationServer
    {
        CONST_VTBL struct IReplicationServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationServer_Initialize(This,pszServer)	\
    (This)->lpVtbl -> Initialize(This,pszServer)

#define IReplicationServer_InitializeEx(This,pszServer,pszUserName,pszPassword,lTimeout)	\
    (This)->lpVtbl -> InitializeEx(This,pszServer,pszUserName,pszPassword,lTimeout)

#define IReplicationServer_OpenProject(This,pszProject,cpcCreationFlags,pvInfProject)	\
    (This)->lpVtbl -> OpenProject(This,pszProject,cpcCreationFlags,pvInfProject)

#define IReplicationServer_DeleteProject(This,pszProject)	\
    (This)->lpVtbl -> DeleteProject(This,pszProject)

#define IReplicationServer_EnumProjects(This,pvIterator,pvInfProject)	\
    (This)->lpVtbl -> EnumProjects(This,pvIterator,pvInfProject)

#define IReplicationServer_EnumServers(This,pvIterator,Flags,pvbstrServer)	\
    (This)->lpVtbl -> EnumServers(This,pvIterator,Flags,pvbstrServer)

#define IReplicationServer_OpenPostingAcceptor(This,pvIDispPA)	\
    (This)->lpVtbl -> OpenPostingAcceptor(This,pvIDispPA)

#define IReplicationServer_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IReplicationServer_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IReplicationServer_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IReplicationServer_Continue(This)	\
    (This)->lpVtbl -> Continue(This)

#define IReplicationServer_Get(This,pszParmName,pvParmValue)	\
    (This)->lpVtbl -> Get(This,pszParmName,pvParmValue)

#define IReplicationServer_Put(This,pszParmName,vParmValue)	\
    (This)->lpVtbl -> Put(This,pszParmName,vParmValue)

#define IReplicationServer_Enum(This,pvIterator,pvParmName,pvParmValue)	\
    (This)->lpVtbl -> Enum(This,pvIterator,pvParmName,pvParmValue)

#define IReplicationServer_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IReplicationServer_AddRoute(This,pszRoute,pvRoute)	\
    (This)->lpVtbl -> AddRoute(This,pszRoute,pvRoute)

#define IReplicationServer_DeleteRoute(This,pszRoute)	\
    (This)->lpVtbl -> DeleteRoute(This,pszRoute)

#define IReplicationServer_EnumRoutes(This,pvIterator,pvRoute)	\
    (This)->lpVtbl -> EnumRoutes(This,pvIterator,pvRoute)

#define IReplicationServer_AddEventSink(This,bstrSink,pvdispSink)	\
    (This)->lpVtbl -> AddEventSink(This,bstrSink,pvdispSink)

#define IReplicationServer_DeleteEventSink(This,bstrSink)	\
    (This)->lpVtbl -> DeleteEventSink(This,bstrSink)

#define IReplicationServer_EnumEventSinks(This,pvIterator,pvdispSink)	\
    (This)->lpVtbl -> EnumEventSinks(This,pvIterator,pvdispSink)

#define IReplicationServer_EnumReplications(This,pszMatchProject,lMatchState,pvIterator,pvReplInfo)	\
    (This)->lpVtbl -> EnumReplications(This,pszMatchProject,lMatchState,pvIterator,pvReplInfo)

#define IReplicationServer_CheckAccess(This,pvlAccessMask)	\
    (This)->lpVtbl -> CheckAccess(This,pvlAccessMask)

#define IReplicationServer_MapUrl(This,bstrUrl,vbstrSuffix,vdispProject)	\
    (This)->lpVtbl -> MapUrl(This,bstrUrl,vbstrSuffix,vdispProject)

#define IReplicationServer_TranslateEventCode(This,lEventCode,vbstrDescription,vlSeverity,vlCategory)	\
    (This)->lpVtbl -> TranslateEventCode(This,lEventCode,vbstrDescription,vlSeverity,vlCategory)

#define IReplicationServer_ClearEvents(This,bstrEventSink)	\
    (This)->lpVtbl -> ClearEvents(This,bstrEventSink)

#define IReplicationServer_put_UseTransactions(This,pszTrans)	\
    (This)->lpVtbl -> put_UseTransactions(This,pszTrans)

#define IReplicationServer_get_UseTransactions(This,pvTrans)	\
    (This)->lpVtbl -> get_UseTransactions(This,pvTrans)

#define IReplicationServer_get_ServerName(This,pvServer)	\
    (This)->lpVtbl -> get_ServerName(This,pvServer)

#define IReplicationServer_get_Version(This,pvVersion)	\
    (This)->lpVtbl -> get_Version(This,pvVersion)

#define IReplicationServer_EventTimeToLocalTime(This,vdateEventTime,pvdateLocalTime)	\
    (This)->lpVtbl -> EventTimeToLocalTime(This,vdateEventTime,pvdateLocalTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Initialize_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [in] */ BSTR pszServer);


void __RPC_STUB IReplicationServer_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_InitializeEx_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [in] */ BSTR pszServer,
    /* [in] */ BSTR pszUserName,
    /* [in] */ BSTR pszPassword,
    /* [in] */ LONG lTimeout);


void __RPC_STUB IReplicationServer_InitializeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_OpenProject_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR pszProject,
    /* [in] */ CRS_PROJECT_CREATION cpcCreationFlags,
    /* [retval][out] */ VARIANT __RPC_FAR *pvInfProject);


void __RPC_STUB IReplicationServer_OpenProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_DeleteProject_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR pszProject);


void __RPC_STUB IReplicationServer_DeleteProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_EnumProjects_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvInfProject);


void __RPC_STUB IReplicationServer_EnumProjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReplicationServer_EnumServers_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [in] */ CRS_SERVER_TYPES Flags,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrServer);


void __RPC_STUB IReplicationServer_EnumServers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_OpenPostingAcceptor_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvIDispPA);


void __RPC_STUB IReplicationServer_OpenPostingAcceptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Start_Proxy( 
    IReplicationServer __RPC_FAR * This);


void __RPC_STUB IReplicationServer_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Stop_Proxy( 
    IReplicationServer __RPC_FAR * This);


void __RPC_STUB IReplicationServer_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Pause_Proxy( 
    IReplicationServer __RPC_FAR * This);


void __RPC_STUB IReplicationServer_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Continue_Proxy( 
    IReplicationServer __RPC_FAR * This);


void __RPC_STUB IReplicationServer_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Get_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR pszParmName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);


void __RPC_STUB IReplicationServer_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Put_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR pszParmName,
    /* [in] */ VARIANT vParmValue);


void __RPC_STUB IReplicationServer_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Enum_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [out] */ VARIANT __RPC_FAR *pvParmName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);


void __RPC_STUB IReplicationServer_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_Commit_Proxy( 
    IReplicationServer __RPC_FAR * This);


void __RPC_STUB IReplicationServer_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_AddRoute_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR pszRoute,
    /* [retval][out] */ VARIANT __RPC_FAR *pvRoute);


void __RPC_STUB IReplicationServer_AddRoute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_DeleteRoute_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR pszRoute);


void __RPC_STUB IReplicationServer_DeleteRoute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_EnumRoutes_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvRoute);


void __RPC_STUB IReplicationServer_EnumRoutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_AddEventSink_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR bstrSink,
    /* [retval][out] */ VARIANT __RPC_FAR *pvdispSink);


void __RPC_STUB IReplicationServer_AddEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_DeleteEventSink_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR bstrSink);


void __RPC_STUB IReplicationServer_DeleteEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_EnumEventSinks_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvdispSink);


void __RPC_STUB IReplicationServer_EnumEventSinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_EnumReplications_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR pszMatchProject,
    /* [in] */ LONG lMatchState,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvReplInfo);


void __RPC_STUB IReplicationServer_EnumReplications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_CheckAccess_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvlAccessMask);


void __RPC_STUB IReplicationServer_CheckAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_MapUrl_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR bstrUrl,
    /* [out] */ VARIANT __RPC_FAR *vbstrSuffix,
    /* [retval][out] */ VARIANT __RPC_FAR *vdispProject);


void __RPC_STUB IReplicationServer_MapUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_TranslateEventCode_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [in] */ LONG lEventCode,
    /* [out] */ VARIANT __RPC_FAR *vbstrDescription,
    /* [out] */ VARIANT __RPC_FAR *vlSeverity,
    /* [out] */ VARIANT __RPC_FAR *vlCategory);


void __RPC_STUB IReplicationServer_TranslateEventCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_ClearEvents_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR bstrEventSink);


void __RPC_STUB IReplicationServer_ClearEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_put_UseTransactions_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [string][in] */ BSTR pszTrans);


void __RPC_STUB IReplicationServer_put_UseTransactions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_get_UseTransactions_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvTrans);


void __RPC_STUB IReplicationServer_get_UseTransactions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_get_ServerName_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvServer);


void __RPC_STUB IReplicationServer_get_ServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_get_Version_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvVersion);


void __RPC_STUB IReplicationServer_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationServer_EventTimeToLocalTime_Proxy( 
    IReplicationServer __RPC_FAR * This,
    /* [in] */ VARIANT vdateEventTime,
    /* [retval][out] */ VARIANT __RPC_FAR *pvdateLocalTime);


void __RPC_STUB IReplicationServer_EventTimeToLocalTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationServer_INTERFACE_DEFINED__ */


#ifndef __IReplicationProject_INTERFACE_DEFINED__
#define __IReplicationProject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationProject
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("ABEB9803-DB7A-11d0-A800-00C04FC9DAA5")
    IReplicationProject : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ BSTR pszParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ BSTR pszParmName,
            /* [in] */ VARIANT vParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Enum( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out][in] */ VARIANT __RPC_FAR *pvParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ LONG lFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvReplInst) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Rollback( 
            /* [in] */ LONG lNumRollbacks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumReplications( 
            /* [in] */ LONG lState,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvReplInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [in] */ BSTR bstrSubdir,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvItemInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddSchedule( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvdispSchedule) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumSchedules( 
            /* [out][in] */ VARIANT __RPC_FAR *pvlIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdispSchedule) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyTransaction( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CheckAccess( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvlAccessMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GrantAccess( 
            /* [string][in] */ BSTR pszUser,
            /* [in] */ LONG lAccessMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAccess( 
            /* [string][in] */ BSTR pszUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAccess( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out] */ VARIANT __RPC_FAR *pvAccess,
            /* [retval][out] */ VARIANT __RPC_FAR *pvUserName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDestination( 
            /* [string][in] */ BSTR pszDestination) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDestination( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvDest) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveDestination( 
            /* [string][in] */ BSTR pszDestination) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [string][in] */ BSTR pszName) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvName) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_ReplicationMethod( 
            /* [string][in] */ BSTR pszMethod) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_ReplicationMethod( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvMethod) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_LocalDirectory( 
            /* [string][in] */ BSTR pszLocalDir) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_LocalDirectory( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvLocalDir) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Flags( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartReplicationClient( 
            /* [in] */ LONG lReserved,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRetVar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszParmName,
            /* [in] */ VARIANT vParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enum )( 
            IReplicationProject __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out][in] */ VARIANT __RPC_FAR *pvParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IReplicationProject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvReplInst);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IReplicationProject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rollback )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ LONG lNumRollbacks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumReplications )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ LONG lState,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvReplInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ BSTR bstrSubdir,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvItemInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSchedule )( 
            IReplicationProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdispSchedule);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSchedules )( 
            IReplicationProject __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvlIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdispSchedule);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ApplyTransaction )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckAccess )( 
            IReplicationProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvlAccessMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GrantAccess )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszUser,
            /* [in] */ LONG lAccessMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAccess )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszUser);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumAccess )( 
            IReplicationProject __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out] */ VARIANT __RPC_FAR *pvAccess,
            /* [retval][out] */ VARIANT __RPC_FAR *pvUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDestination )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszDestination);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDestination )( 
            IReplicationProject __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvDest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveDestination )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszDestination);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszName);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IReplicationProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvName);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReplicationMethod )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszMethod);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReplicationMethod )( 
            IReplicationProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvMethod);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalDirectory )( 
            IReplicationProject __RPC_FAR * This,
            /* [string][in] */ BSTR pszLocalDir);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalDirectory )( 
            IReplicationProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvLocalDir);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Flags )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ LONG lFlags);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Flags )( 
            IReplicationProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartReplicationClient )( 
            IReplicationProject __RPC_FAR * This,
            /* [in] */ LONG lReserved,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRetVar);
        
        END_INTERFACE
    } IReplicationProjectVtbl;

    interface IReplicationProject
    {
        CONST_VTBL struct IReplicationProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationProject_Get(This,pszParmName,pvParmValue)	\
    (This)->lpVtbl -> Get(This,pszParmName,pvParmValue)

#define IReplicationProject_Put(This,pszParmName,vParmValue)	\
    (This)->lpVtbl -> Put(This,pszParmName,vParmValue)

#define IReplicationProject_Enum(This,pvIterator,pvParmName,pvParmValue)	\
    (This)->lpVtbl -> Enum(This,pvIterator,pvParmName,pvParmValue)

#define IReplicationProject_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IReplicationProject_Start(This,lFlags,pvReplInst)	\
    (This)->lpVtbl -> Start(This,lFlags,pvReplInst)

#define IReplicationProject_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IReplicationProject_Rollback(This,lNumRollbacks)	\
    (This)->lpVtbl -> Rollback(This,lNumRollbacks)

#define IReplicationProject_EnumReplications(This,lState,pvIterator,pvReplInfo)	\
    (This)->lpVtbl -> EnumReplications(This,lState,pvIterator,pvReplInfo)

#define IReplicationProject_EnumItems(This,bstrSubdir,pvIterator,pvItemInfo)	\
    (This)->lpVtbl -> EnumItems(This,bstrSubdir,pvIterator,pvItemInfo)

#define IReplicationProject_AddSchedule(This,pvdispSchedule)	\
    (This)->lpVtbl -> AddSchedule(This,pvdispSchedule)

#define IReplicationProject_EnumSchedules(This,pvlIterator,pvdispSchedule)	\
    (This)->lpVtbl -> EnumSchedules(This,pvlIterator,pvdispSchedule)

#define IReplicationProject_ApplyTransaction(This,lFlags)	\
    (This)->lpVtbl -> ApplyTransaction(This,lFlags)

#define IReplicationProject_CheckAccess(This,pvlAccessMask)	\
    (This)->lpVtbl -> CheckAccess(This,pvlAccessMask)

#define IReplicationProject_GrantAccess(This,pszUser,lAccessMask)	\
    (This)->lpVtbl -> GrantAccess(This,pszUser,lAccessMask)

#define IReplicationProject_RemoveAccess(This,pszUser)	\
    (This)->lpVtbl -> RemoveAccess(This,pszUser)

#define IReplicationProject_EnumAccess(This,pvIterator,pvAccess,pvUserName)	\
    (This)->lpVtbl -> EnumAccess(This,pvIterator,pvAccess,pvUserName)

#define IReplicationProject_AddDestination(This,pszDestination)	\
    (This)->lpVtbl -> AddDestination(This,pszDestination)

#define IReplicationProject_EnumDestination(This,pvIterator,pvDest)	\
    (This)->lpVtbl -> EnumDestination(This,pvIterator,pvDest)

#define IReplicationProject_RemoveDestination(This,pszDestination)	\
    (This)->lpVtbl -> RemoveDestination(This,pszDestination)

#define IReplicationProject_put_Name(This,pszName)	\
    (This)->lpVtbl -> put_Name(This,pszName)

#define IReplicationProject_get_Name(This,pvName)	\
    (This)->lpVtbl -> get_Name(This,pvName)

#define IReplicationProject_put_ReplicationMethod(This,pszMethod)	\
    (This)->lpVtbl -> put_ReplicationMethod(This,pszMethod)

#define IReplicationProject_get_ReplicationMethod(This,pvMethod)	\
    (This)->lpVtbl -> get_ReplicationMethod(This,pvMethod)

#define IReplicationProject_put_LocalDirectory(This,pszLocalDir)	\
    (This)->lpVtbl -> put_LocalDirectory(This,pszLocalDir)

#define IReplicationProject_get_LocalDirectory(This,pvLocalDir)	\
    (This)->lpVtbl -> get_LocalDirectory(This,pvLocalDir)

#define IReplicationProject_put_Flags(This,lFlags)	\
    (This)->lpVtbl -> put_Flags(This,lFlags)

#define IReplicationProject_get_Flags(This,pvFlags)	\
    (This)->lpVtbl -> get_Flags(This,pvFlags)

#define IReplicationProject_StartReplicationClient(This,lReserved,pvRetVar)	\
    (This)->lpVtbl -> StartReplicationClient(This,lReserved,pvRetVar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_Get_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszParmName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);


void __RPC_STUB IReplicationProject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_Put_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszParmName,
    /* [in] */ VARIANT vParmValue);


void __RPC_STUB IReplicationProject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_Enum_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [out][in] */ VARIANT __RPC_FAR *pvParmName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);


void __RPC_STUB IReplicationProject_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_Commit_Proxy( 
    IReplicationProject __RPC_FAR * This);


void __RPC_STUB IReplicationProject_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_Start_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ VARIANT __RPC_FAR *pvReplInst);


void __RPC_STUB IReplicationProject_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_Cancel_Proxy( 
    IReplicationProject __RPC_FAR * This);


void __RPC_STUB IReplicationProject_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_Rollback_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [in] */ LONG lNumRollbacks);


void __RPC_STUB IReplicationProject_Rollback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_EnumReplications_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [in] */ LONG lState,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvReplInfo);


void __RPC_STUB IReplicationProject_EnumReplications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_EnumItems_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [in] */ BSTR bstrSubdir,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvItemInfo);


void __RPC_STUB IReplicationProject_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_AddSchedule_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvdispSchedule);


void __RPC_STUB IReplicationProject_AddSchedule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_EnumSchedules_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvlIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvdispSchedule);


void __RPC_STUB IReplicationProject_EnumSchedules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_ApplyTransaction_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [in] */ LONG lFlags);


void __RPC_STUB IReplicationProject_ApplyTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_CheckAccess_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvlAccessMask);


void __RPC_STUB IReplicationProject_CheckAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_GrantAccess_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszUser,
    /* [in] */ LONG lAccessMask);


void __RPC_STUB IReplicationProject_GrantAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_RemoveAccess_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszUser);


void __RPC_STUB IReplicationProject_RemoveAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReplicationProject_EnumAccess_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [out] */ VARIANT __RPC_FAR *pvAccess,
    /* [retval][out] */ VARIANT __RPC_FAR *pvUserName);


void __RPC_STUB IReplicationProject_EnumAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_AddDestination_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszDestination);


void __RPC_STUB IReplicationProject_AddDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_EnumDestination_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvDest);


void __RPC_STUB IReplicationProject_EnumDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_RemoveDestination_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszDestination);


void __RPC_STUB IReplicationProject_RemoveDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_put_Name_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszName);


void __RPC_STUB IReplicationProject_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_get_Name_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvName);


void __RPC_STUB IReplicationProject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_put_ReplicationMethod_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszMethod);


void __RPC_STUB IReplicationProject_put_ReplicationMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_get_ReplicationMethod_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvMethod);


void __RPC_STUB IReplicationProject_get_ReplicationMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_put_LocalDirectory_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [string][in] */ BSTR pszLocalDir);


void __RPC_STUB IReplicationProject_put_LocalDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_get_LocalDirectory_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvLocalDir);


void __RPC_STUB IReplicationProject_get_LocalDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_put_Flags_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [in] */ LONG lFlags);


void __RPC_STUB IReplicationProject_put_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_get_Flags_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFlags);


void __RPC_STUB IReplicationProject_get_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationProject_StartReplicationClient_Proxy( 
    IReplicationProject __RPC_FAR * This,
    /* [in] */ LONG lReserved,
    /* [retval][out] */ VARIANT __RPC_FAR *pvRetVar);


void __RPC_STUB IReplicationProject_StartReplicationClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationProject_INTERFACE_DEFINED__ */


#ifndef __IReplicationItem_INTERFACE_DEFINED__
#define __IReplicationItem_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationItem
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("ABEB9808-DB7A-11d0-A800-00C04FC9DAA5")
    IReplicationItem : public IDispatch
    {
    public:
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvName) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvAttrs) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_CreationTime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvCreationTime) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_LastAccessTime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvLastAccessTime) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_LastModifiedTime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvLastModified) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_SizeLow( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvSizeLow) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_SizeHigh( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvSizeHigh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationItem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationItem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationItem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IReplicationItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvName);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            IReplicationItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvAttrs);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CreationTime )( 
            IReplicationItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvCreationTime);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LastAccessTime )( 
            IReplicationItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvLastAccessTime);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LastModifiedTime )( 
            IReplicationItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvLastModified);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SizeLow )( 
            IReplicationItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSizeLow);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SizeHigh )( 
            IReplicationItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSizeHigh);
        
        END_INTERFACE
    } IReplicationItemVtbl;

    interface IReplicationItem
    {
        CONST_VTBL struct IReplicationItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationItem_get_Name(This,pvName)	\
    (This)->lpVtbl -> get_Name(This,pvName)

#define IReplicationItem_get_Attributes(This,pvAttrs)	\
    (This)->lpVtbl -> get_Attributes(This,pvAttrs)

#define IReplicationItem_get_CreationTime(This,pvCreationTime)	\
    (This)->lpVtbl -> get_CreationTime(This,pvCreationTime)

#define IReplicationItem_get_LastAccessTime(This,pvLastAccessTime)	\
    (This)->lpVtbl -> get_LastAccessTime(This,pvLastAccessTime)

#define IReplicationItem_get_LastModifiedTime(This,pvLastModified)	\
    (This)->lpVtbl -> get_LastModifiedTime(This,pvLastModified)

#define IReplicationItem_get_SizeLow(This,pvSizeLow)	\
    (This)->lpVtbl -> get_SizeLow(This,pvSizeLow)

#define IReplicationItem_get_SizeHigh(This,pvSizeHigh)	\
    (This)->lpVtbl -> get_SizeHigh(This,pvSizeHigh)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationItem_get_Name_Proxy( 
    IReplicationItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvName);


void __RPC_STUB IReplicationItem_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationItem_get_Attributes_Proxy( 
    IReplicationItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvAttrs);


void __RPC_STUB IReplicationItem_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationItem_get_CreationTime_Proxy( 
    IReplicationItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvCreationTime);


void __RPC_STUB IReplicationItem_get_CreationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationItem_get_LastAccessTime_Proxy( 
    IReplicationItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvLastAccessTime);


void __RPC_STUB IReplicationItem_get_LastAccessTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationItem_get_LastModifiedTime_Proxy( 
    IReplicationItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvLastModified);


void __RPC_STUB IReplicationItem_get_LastModifiedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationItem_get_SizeLow_Proxy( 
    IReplicationItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvSizeLow);


void __RPC_STUB IReplicationItem_get_SizeLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationItem_get_SizeHigh_Proxy( 
    IReplicationItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvSizeHigh);


void __RPC_STUB IReplicationItem_get_SizeHigh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationItem_INTERFACE_DEFINED__ */


#ifndef __IReplicationSchedule_INTERFACE_DEFINED__
#define __IReplicationSchedule_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationSchedule
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationSchedule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("82D36BA0-1B37-11d1-8C8C-00C04FC2D3B9")
    IReplicationSchedule : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Project( 
            /* [in] */ BSTR bstrProject) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Project( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrProject) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_RunOnce( 
            /* [in] */ VARIANT vdateRunOnce) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_RunOnce( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvdate) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_ScheduledAction( 
            /* [in] */ CRS_SCHEDULE_ACTION Action) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_ScheduledAction( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvAction) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Hour( 
            /* [in] */ LONG lHour) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Hour( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvlHour) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Minute( 
            /* [in] */ LONG lMinute) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Minute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvlMinute) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Days( 
            /* [in] */ LONG lDays) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Days( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvlDays) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrDescription) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_IsRunOnce( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationScheduleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationSchedule __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationSchedule __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IReplicationSchedule __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IReplicationSchedule __RPC_FAR * This);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Project )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ BSTR bstrProject);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Project )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrProject);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RunOnce )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ VARIANT vdateRunOnce);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RunOnce )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvdate);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScheduledAction )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ CRS_SCHEDULE_ACTION Action);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScheduledAction )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvAction);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Hour )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ LONG lHour);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Hour )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvlHour);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Minute )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ LONG lMinute);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Minute )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvlMinute);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Days )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [in] */ LONG lDays);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Days )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvlDays);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrDescription);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsRunOnce )( 
            IReplicationSchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IReplicationScheduleVtbl;

    interface IReplicationSchedule
    {
        CONST_VTBL struct IReplicationScheduleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationSchedule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationSchedule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationSchedule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationSchedule_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationSchedule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationSchedule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationSchedule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationSchedule_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IReplicationSchedule_Remove(This)	\
    (This)->lpVtbl -> Remove(This)

#define IReplicationSchedule_put_Project(This,bstrProject)	\
    (This)->lpVtbl -> put_Project(This,bstrProject)

#define IReplicationSchedule_get_Project(This,pvbstrProject)	\
    (This)->lpVtbl -> get_Project(This,pvbstrProject)

#define IReplicationSchedule_put_RunOnce(This,vdateRunOnce)	\
    (This)->lpVtbl -> put_RunOnce(This,vdateRunOnce)

#define IReplicationSchedule_get_RunOnce(This,pvdate)	\
    (This)->lpVtbl -> get_RunOnce(This,pvdate)

#define IReplicationSchedule_put_ScheduledAction(This,Action)	\
    (This)->lpVtbl -> put_ScheduledAction(This,Action)

#define IReplicationSchedule_get_ScheduledAction(This,pvAction)	\
    (This)->lpVtbl -> get_ScheduledAction(This,pvAction)

#define IReplicationSchedule_put_Hour(This,lHour)	\
    (This)->lpVtbl -> put_Hour(This,lHour)

#define IReplicationSchedule_get_Hour(This,pvlHour)	\
    (This)->lpVtbl -> get_Hour(This,pvlHour)

#define IReplicationSchedule_put_Minute(This,lMinute)	\
    (This)->lpVtbl -> put_Minute(This,lMinute)

#define IReplicationSchedule_get_Minute(This,pvlMinute)	\
    (This)->lpVtbl -> get_Minute(This,pvlMinute)

#define IReplicationSchedule_put_Days(This,lDays)	\
    (This)->lpVtbl -> put_Days(This,lDays)

#define IReplicationSchedule_get_Days(This,pvlDays)	\
    (This)->lpVtbl -> get_Days(This,pvlDays)

#define IReplicationSchedule_get_Description(This,pvbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pvbstrDescription)

#define IReplicationSchedule_get_IsRunOnce(This,pVal)	\
    (This)->lpVtbl -> get_IsRunOnce(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_Commit_Proxy( 
    IReplicationSchedule __RPC_FAR * This);


void __RPC_STUB IReplicationSchedule_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_Remove_Proxy( 
    IReplicationSchedule __RPC_FAR * This);


void __RPC_STUB IReplicationSchedule_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_put_Project_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [in] */ BSTR bstrProject);


void __RPC_STUB IReplicationSchedule_put_Project_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_get_Project_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrProject);


void __RPC_STUB IReplicationSchedule_get_Project_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_put_RunOnce_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [in] */ VARIANT vdateRunOnce);


void __RPC_STUB IReplicationSchedule_put_RunOnce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_get_RunOnce_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvdate);


void __RPC_STUB IReplicationSchedule_get_RunOnce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_put_ScheduledAction_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [in] */ CRS_SCHEDULE_ACTION Action);


void __RPC_STUB IReplicationSchedule_put_ScheduledAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_get_ScheduledAction_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvAction);


void __RPC_STUB IReplicationSchedule_get_ScheduledAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_put_Hour_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [in] */ LONG lHour);


void __RPC_STUB IReplicationSchedule_put_Hour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_get_Hour_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvlHour);


void __RPC_STUB IReplicationSchedule_get_Hour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_put_Minute_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [in] */ LONG lMinute);


void __RPC_STUB IReplicationSchedule_put_Minute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_get_Minute_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvlMinute);


void __RPC_STUB IReplicationSchedule_get_Minute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_put_Days_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [in] */ LONG lDays);


void __RPC_STUB IReplicationSchedule_put_Days_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_get_Days_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvlDays);


void __RPC_STUB IReplicationSchedule_get_Days_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_get_Description_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrDescription);


void __RPC_STUB IReplicationSchedule_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationSchedule_get_IsRunOnce_Proxy( 
    IReplicationSchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationSchedule_get_IsRunOnce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationSchedule_INTERFACE_DEFINED__ */


#ifndef __IReplicationEventSinkConfig_INTERFACE_DEFINED__
#define __IReplicationEventSinkConfig_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationEventSinkConfig
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationEventSinkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("ABEB980A-DB7A-11d0-A800-00C04FC9DAA5")
    IReplicationEventSinkConfig : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterForEvent( 
            /* [in] */ LONG lCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnRegisterForEvent( 
            /* [in] */ LONG lCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsRegisteredForEvent( 
            /* [in] */ LONG lCode,
            /* [retval][out] */ VARIANT __RPC_FAR *pvboolReg) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrName) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_CLSID( 
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_CLSID( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrCLSID) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_ProjectFilter( 
            /* [string][in] */ BSTR bstrProject) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_ProjectFilter( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrProject) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_DataSource( 
            /* [in] */ BSTR bstrDSN) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrDSN) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_UserName( 
            /* [in] */ BSTR bstrUser) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrUser) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Password( 
            /* [in] */ BSTR bstrPassword) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Password( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrPassword) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Server( 
            /* [in] */ BSTR bstrServer) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrServer) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Disabled( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Disabled( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Synchronous( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Synchronous( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_ProviderCLSID( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_ProviderCLSID( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_EventLifetime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvlEventLifetime) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_EventLifetime( 
            /* [in] */ LONG lEventLifetime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationEventSinkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationEventSinkConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationEventSinkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IReplicationEventSinkConfig __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterForEvent )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ LONG lCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterForEvent )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ LONG lCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRegisteredForEvent )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ LONG lCode,
            /* [retval][out] */ VARIANT __RPC_FAR *pvboolReg);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrName);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CLSID )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrCLSID);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CLSID )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrCLSID);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProjectFilter )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [string][in] */ BSTR bstrProject);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProjectFilter )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrProject);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DataSource )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrDSN);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrDSN);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserName )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrUser);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserName )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrUser);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Password )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrPassword);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Password )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrPassword);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Server )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrServer);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvbstrServer);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Disabled )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Disabled )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Synchronous )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Synchronous )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProviderCLSID )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProviderCLSID )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventLifetime )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvlEventLifetime);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventLifetime )( 
            IReplicationEventSinkConfig __RPC_FAR * This,
            /* [in] */ LONG lEventLifetime);
        
        END_INTERFACE
    } IReplicationEventSinkConfigVtbl;

    interface IReplicationEventSinkConfig
    {
        CONST_VTBL struct IReplicationEventSinkConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationEventSinkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationEventSinkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationEventSinkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationEventSinkConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationEventSinkConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationEventSinkConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationEventSinkConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationEventSinkConfig_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IReplicationEventSinkConfig_RegisterForEvent(This,lCode)	\
    (This)->lpVtbl -> RegisterForEvent(This,lCode)

#define IReplicationEventSinkConfig_UnRegisterForEvent(This,lCode)	\
    (This)->lpVtbl -> UnRegisterForEvent(This,lCode)

#define IReplicationEventSinkConfig_IsRegisteredForEvent(This,lCode,pvboolReg)	\
    (This)->lpVtbl -> IsRegisteredForEvent(This,lCode,pvboolReg)

#define IReplicationEventSinkConfig_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#define IReplicationEventSinkConfig_get_Name(This,pvbstrName)	\
    (This)->lpVtbl -> get_Name(This,pvbstrName)

#define IReplicationEventSinkConfig_put_CLSID(This,bstrCLSID)	\
    (This)->lpVtbl -> put_CLSID(This,bstrCLSID)

#define IReplicationEventSinkConfig_get_CLSID(This,pvbstrCLSID)	\
    (This)->lpVtbl -> get_CLSID(This,pvbstrCLSID)

#define IReplicationEventSinkConfig_put_ProjectFilter(This,bstrProject)	\
    (This)->lpVtbl -> put_ProjectFilter(This,bstrProject)

#define IReplicationEventSinkConfig_get_ProjectFilter(This,pvbstrProject)	\
    (This)->lpVtbl -> get_ProjectFilter(This,pvbstrProject)

#define IReplicationEventSinkConfig_put_DataSource(This,bstrDSN)	\
    (This)->lpVtbl -> put_DataSource(This,bstrDSN)

#define IReplicationEventSinkConfig_get_DataSource(This,pvbstrDSN)	\
    (This)->lpVtbl -> get_DataSource(This,pvbstrDSN)

#define IReplicationEventSinkConfig_put_UserName(This,bstrUser)	\
    (This)->lpVtbl -> put_UserName(This,bstrUser)

#define IReplicationEventSinkConfig_get_UserName(This,pvbstrUser)	\
    (This)->lpVtbl -> get_UserName(This,pvbstrUser)

#define IReplicationEventSinkConfig_put_Password(This,bstrPassword)	\
    (This)->lpVtbl -> put_Password(This,bstrPassword)

#define IReplicationEventSinkConfig_get_Password(This,pvbstrPassword)	\
    (This)->lpVtbl -> get_Password(This,pvbstrPassword)

#define IReplicationEventSinkConfig_put_Server(This,bstrServer)	\
    (This)->lpVtbl -> put_Server(This,bstrServer)

#define IReplicationEventSinkConfig_get_Server(This,pvbstrServer)	\
    (This)->lpVtbl -> get_Server(This,pvbstrServer)

#define IReplicationEventSinkConfig_get_Disabled(This,pVal)	\
    (This)->lpVtbl -> get_Disabled(This,pVal)

#define IReplicationEventSinkConfig_put_Disabled(This,newVal)	\
    (This)->lpVtbl -> put_Disabled(This,newVal)

#define IReplicationEventSinkConfig_get_Synchronous(This,pVal)	\
    (This)->lpVtbl -> get_Synchronous(This,pVal)

#define IReplicationEventSinkConfig_put_Synchronous(This,newVal)	\
    (This)->lpVtbl -> put_Synchronous(This,newVal)

#define IReplicationEventSinkConfig_get_ProviderCLSID(This,pVal)	\
    (This)->lpVtbl -> get_ProviderCLSID(This,pVal)

#define IReplicationEventSinkConfig_put_ProviderCLSID(This,newVal)	\
    (This)->lpVtbl -> put_ProviderCLSID(This,newVal)

#define IReplicationEventSinkConfig_get_EventLifetime(This,pvlEventLifetime)	\
    (This)->lpVtbl -> get_EventLifetime(This,pvlEventLifetime)

#define IReplicationEventSinkConfig_put_EventLifetime(This,lEventLifetime)	\
    (This)->lpVtbl -> put_EventLifetime(This,lEventLifetime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_Commit_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This);


void __RPC_STUB IReplicationEventSinkConfig_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_RegisterForEvent_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ LONG lCode);


void __RPC_STUB IReplicationEventSinkConfig_RegisterForEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_UnRegisterForEvent_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ LONG lCode);


void __RPC_STUB IReplicationEventSinkConfig_UnRegisterForEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_IsRegisteredForEvent_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ LONG lCode,
    /* [retval][out] */ VARIANT __RPC_FAR *pvboolReg);


void __RPC_STUB IReplicationEventSinkConfig_IsRegisteredForEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_Name_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IReplicationEventSinkConfig_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_Name_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrName);


void __RPC_STUB IReplicationEventSinkConfig_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_CLSID_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IReplicationEventSinkConfig_put_CLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_CLSID_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrCLSID);


void __RPC_STUB IReplicationEventSinkConfig_get_CLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_ProjectFilter_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [string][in] */ BSTR bstrProject);


void __RPC_STUB IReplicationEventSinkConfig_put_ProjectFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_ProjectFilter_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrProject);


void __RPC_STUB IReplicationEventSinkConfig_get_ProjectFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_DataSource_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrDSN);


void __RPC_STUB IReplicationEventSinkConfig_put_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_DataSource_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrDSN);


void __RPC_STUB IReplicationEventSinkConfig_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_UserName_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrUser);


void __RPC_STUB IReplicationEventSinkConfig_put_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_UserName_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrUser);


void __RPC_STUB IReplicationEventSinkConfig_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_Password_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB IReplicationEventSinkConfig_put_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_Password_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrPassword);


void __RPC_STUB IReplicationEventSinkConfig_get_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_Server_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrServer);


void __RPC_STUB IReplicationEventSinkConfig_put_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_Server_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvbstrServer);


void __RPC_STUB IReplicationEventSinkConfig_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_Disabled_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationEventSinkConfig_get_Disabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_Disabled_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IReplicationEventSinkConfig_put_Disabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_Synchronous_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationEventSinkConfig_get_Synchronous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_Synchronous_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IReplicationEventSinkConfig_put_Synchronous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_ProviderCLSID_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationEventSinkConfig_get_ProviderCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_ProviderCLSID_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IReplicationEventSinkConfig_put_ProviderCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_get_EventLifetime_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvlEventLifetime);


void __RPC_STUB IReplicationEventSinkConfig_get_EventLifetime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationEventSinkConfig_put_EventLifetime_Proxy( 
    IReplicationEventSinkConfig __RPC_FAR * This,
    /* [in] */ LONG lEventLifetime);


void __RPC_STUB IReplicationEventSinkConfig_put_EventLifetime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationEventSinkConfig_INTERFACE_DEFINED__ */


#ifndef __IReplicationInstance_INTERFACE_DEFINED__
#define __IReplicationInstance_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationInstance
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationInstance;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("ABEB9807-DB7A-11d0-A800-00C04FC9DAA5")
    IReplicationInstance : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Query( void) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvID) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvName) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvFlags) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvState) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvState) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvStartTime) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_EndTime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvEndTime) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_FilesSent( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesSent) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_BytesSent( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvBytesSent) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_FilesReceived( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesReceived) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_BytesReceived( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvBytesReceived) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_FilesErrored( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesErrored) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_FilesErroredBytes( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesErroredBytes) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_FilesMatched( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesMatched) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_FilesMatchedBytes( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesMatchedBytes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationInstanceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationInstance __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationInstance __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationInstance __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationInstance __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationInstance __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationInstance __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationInstance __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IReplicationInstance __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Query )( 
            IReplicationInstance __RPC_FAR * This);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ID )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvID);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvName);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Flags )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFlags);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvState);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvState);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartTime )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvStartTime);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EndTime )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvEndTime);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilesSent )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesSent);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BytesSent )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvBytesSent);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilesReceived )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesReceived);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BytesReceived )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvBytesReceived);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilesErrored )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesErrored);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilesErroredBytes )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesErroredBytes);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilesMatched )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesMatched);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilesMatchedBytes )( 
            IReplicationInstance __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFilesMatchedBytes);
        
        END_INTERFACE
    } IReplicationInstanceVtbl;

    interface IReplicationInstance
    {
        CONST_VTBL struct IReplicationInstanceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationInstance_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationInstance_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationInstance_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationInstance_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationInstance_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationInstance_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationInstance_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationInstance_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IReplicationInstance_Query(This)	\
    (This)->lpVtbl -> Query(This)

#define IReplicationInstance_get_ID(This,pvID)	\
    (This)->lpVtbl -> get_ID(This,pvID)

#define IReplicationInstance_get_Name(This,pvName)	\
    (This)->lpVtbl -> get_Name(This,pvName)

#define IReplicationInstance_get_Flags(This,pvFlags)	\
    (This)->lpVtbl -> get_Flags(This,pvFlags)

#define IReplicationInstance_get_State(This,pvState)	\
    (This)->lpVtbl -> get_State(This,pvState)

#define IReplicationInstance_get_Status(This,pvState)	\
    (This)->lpVtbl -> get_Status(This,pvState)

#define IReplicationInstance_get_StartTime(This,pvStartTime)	\
    (This)->lpVtbl -> get_StartTime(This,pvStartTime)

#define IReplicationInstance_get_EndTime(This,pvEndTime)	\
    (This)->lpVtbl -> get_EndTime(This,pvEndTime)

#define IReplicationInstance_get_FilesSent(This,pvFilesSent)	\
    (This)->lpVtbl -> get_FilesSent(This,pvFilesSent)

#define IReplicationInstance_get_BytesSent(This,pvBytesSent)	\
    (This)->lpVtbl -> get_BytesSent(This,pvBytesSent)

#define IReplicationInstance_get_FilesReceived(This,pvFilesReceived)	\
    (This)->lpVtbl -> get_FilesReceived(This,pvFilesReceived)

#define IReplicationInstance_get_BytesReceived(This,pvBytesReceived)	\
    (This)->lpVtbl -> get_BytesReceived(This,pvBytesReceived)

#define IReplicationInstance_get_FilesErrored(This,pvFilesErrored)	\
    (This)->lpVtbl -> get_FilesErrored(This,pvFilesErrored)

#define IReplicationInstance_get_FilesErroredBytes(This,pvFilesErroredBytes)	\
    (This)->lpVtbl -> get_FilesErroredBytes(This,pvFilesErroredBytes)

#define IReplicationInstance_get_FilesMatched(This,pvFilesMatched)	\
    (This)->lpVtbl -> get_FilesMatched(This,pvFilesMatched)

#define IReplicationInstance_get_FilesMatchedBytes(This,pvFilesMatchedBytes)	\
    (This)->lpVtbl -> get_FilesMatchedBytes(This,pvFilesMatchedBytes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_Cancel_Proxy( 
    IReplicationInstance __RPC_FAR * This);


void __RPC_STUB IReplicationInstance_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_Query_Proxy( 
    IReplicationInstance __RPC_FAR * This);


void __RPC_STUB IReplicationInstance_Query_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_ID_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvID);


void __RPC_STUB IReplicationInstance_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_Name_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvName);


void __RPC_STUB IReplicationInstance_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_Flags_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFlags);


void __RPC_STUB IReplicationInstance_get_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_State_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvState);


void __RPC_STUB IReplicationInstance_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_Status_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvState);


void __RPC_STUB IReplicationInstance_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_StartTime_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvStartTime);


void __RPC_STUB IReplicationInstance_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_EndTime_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvEndTime);


void __RPC_STUB IReplicationInstance_get_EndTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_FilesSent_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFilesSent);


void __RPC_STUB IReplicationInstance_get_FilesSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_BytesSent_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvBytesSent);


void __RPC_STUB IReplicationInstance_get_BytesSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_FilesReceived_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFilesReceived);


void __RPC_STUB IReplicationInstance_get_FilesReceived_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_BytesReceived_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvBytesReceived);


void __RPC_STUB IReplicationInstance_get_BytesReceived_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_FilesErrored_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFilesErrored);


void __RPC_STUB IReplicationInstance_get_FilesErrored_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_FilesErroredBytes_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFilesErroredBytes);


void __RPC_STUB IReplicationInstance_get_FilesErroredBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_FilesMatched_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFilesMatched);


void __RPC_STUB IReplicationInstance_get_FilesMatched_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationInstance_get_FilesMatchedBytes_Proxy( 
    IReplicationInstance __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFilesMatchedBytes);


void __RPC_STUB IReplicationInstance_get_FilesMatchedBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationInstance_INTERFACE_DEFINED__ */


#ifndef __IReplicationRoute_INTERFACE_DEFINED__
#define __IReplicationRoute_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationRoute
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationRoute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("ABEB9804-DB7A-11d0-A800-00C04FC9DAA5")
    IReplicationRoute : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ BSTR pszParm,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ BSTR pszParm,
            /* [in] */ VARIANT vParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Enum( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out][in] */ VARIANT __RPC_FAR *pvParm,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDestination( 
            /* [string][in] */ BSTR pszDestination) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDestination( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvDest) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveDestination( 
            /* [string][in] */ BSTR pszDestination) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvName) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [string][in] */ BSTR pszName) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_BaseDirectory( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvName) = 0;
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_BaseDirectory( 
            /* [string][in] */ BSTR pszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationRouteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationRoute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationRoute __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationRoute __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationRoute __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationRoute __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationRoute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationRoute __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IReplicationRoute __RPC_FAR * This,
            /* [string][in] */ BSTR pszParm,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IReplicationRoute __RPC_FAR * This,
            /* [string][in] */ BSTR pszParm,
            /* [in] */ VARIANT vParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enum )( 
            IReplicationRoute __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out][in] */ VARIANT __RPC_FAR *pvParm,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IReplicationRoute __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDestination )( 
            IReplicationRoute __RPC_FAR * This,
            /* [string][in] */ BSTR pszDestination);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDestination )( 
            IReplicationRoute __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [retval][out] */ VARIANT __RPC_FAR *pvDest);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveDestination )( 
            IReplicationRoute __RPC_FAR * This,
            /* [string][in] */ BSTR pszDestination);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IReplicationRoute __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvName);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IReplicationRoute __RPC_FAR * This,
            /* [string][in] */ BSTR pszName);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BaseDirectory )( 
            IReplicationRoute __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvName);
        
        /* [propput][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BaseDirectory )( 
            IReplicationRoute __RPC_FAR * This,
            /* [string][in] */ BSTR pszName);
        
        END_INTERFACE
    } IReplicationRouteVtbl;

    interface IReplicationRoute
    {
        CONST_VTBL struct IReplicationRouteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationRoute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationRoute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationRoute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationRoute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationRoute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationRoute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationRoute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationRoute_Get(This,pszParm,pvParmValue)	\
    (This)->lpVtbl -> Get(This,pszParm,pvParmValue)

#define IReplicationRoute_Put(This,pszParm,vParmValue)	\
    (This)->lpVtbl -> Put(This,pszParm,vParmValue)

#define IReplicationRoute_Enum(This,pvIterator,pvParm,pvParmValue)	\
    (This)->lpVtbl -> Enum(This,pvIterator,pvParm,pvParmValue)

#define IReplicationRoute_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IReplicationRoute_AddDestination(This,pszDestination)	\
    (This)->lpVtbl -> AddDestination(This,pszDestination)

#define IReplicationRoute_EnumDestination(This,pvIterator,pvDest)	\
    (This)->lpVtbl -> EnumDestination(This,pvIterator,pvDest)

#define IReplicationRoute_RemoveDestination(This,pszDestination)	\
    (This)->lpVtbl -> RemoveDestination(This,pszDestination)

#define IReplicationRoute_get_Name(This,pvName)	\
    (This)->lpVtbl -> get_Name(This,pvName)

#define IReplicationRoute_put_Name(This,pszName)	\
    (This)->lpVtbl -> put_Name(This,pszName)

#define IReplicationRoute_get_BaseDirectory(This,pvName)	\
    (This)->lpVtbl -> get_BaseDirectory(This,pvName)

#define IReplicationRoute_put_BaseDirectory(This,pszName)	\
    (This)->lpVtbl -> put_BaseDirectory(This,pszName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_Get_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [string][in] */ BSTR pszParm,
    /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);


void __RPC_STUB IReplicationRoute_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_Put_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [string][in] */ BSTR pszParm,
    /* [in] */ VARIANT vParmValue);


void __RPC_STUB IReplicationRoute_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_Enum_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [out][in] */ VARIANT __RPC_FAR *pvParm,
    /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);


void __RPC_STUB IReplicationRoute_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_Commit_Proxy( 
    IReplicationRoute __RPC_FAR * This);


void __RPC_STUB IReplicationRoute_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_AddDestination_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [string][in] */ BSTR pszDestination);


void __RPC_STUB IReplicationRoute_AddDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_EnumDestination_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [retval][out] */ VARIANT __RPC_FAR *pvDest);


void __RPC_STUB IReplicationRoute_EnumDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_RemoveDestination_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [string][in] */ BSTR pszDestination);


void __RPC_STUB IReplicationRoute_RemoveDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_get_Name_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvName);


void __RPC_STUB IReplicationRoute_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_put_Name_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [string][in] */ BSTR pszName);


void __RPC_STUB IReplicationRoute_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_get_BaseDirectory_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvName);


void __RPC_STUB IReplicationRoute_get_BaseDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationRoute_put_BaseDirectory_Proxy( 
    IReplicationRoute __RPC_FAR * This,
    /* [string][in] */ BSTR pszName);


void __RPC_STUB IReplicationRoute_put_BaseDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationRoute_INTERFACE_DEFINED__ */


#ifndef __IReplicationClient_INTERFACE_DEFINED__
#define __IReplicationClient_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationClient
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("B24F0372-9692-11D0-BAD5-00C04FD7082F")
    IReplicationClient : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ BSTR pszProject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendFile( 
            /* [string][in] */ BSTR pszFile) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendFiles( 
            /* [in] */ VARIANT __RPC_FAR *pvFileArray) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteFile( 
            /* [string][in] */ BSTR pszFile) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedErrorInfo( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvErrorArray) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FastMode( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_FastMode( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Force( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Force( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ACLs( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ACLs( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NumDestinations( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SkipLockedFiles( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_SkipLockedFiles( 
            /* [in] */ BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationClient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationClient __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationClient __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReplicationClient __RPC_FAR * This,
            /* [string][in] */ BSTR pszProject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IReplicationClient __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendFile )( 
            IReplicationClient __RPC_FAR * This,
            /* [string][in] */ BSTR pszFile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendFiles )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvFileArray);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteFile )( 
            IReplicationClient __RPC_FAR * This,
            /* [string][in] */ BSTR pszFile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IReplicationClient __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IReplicationClient __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IReplicationClient __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedErrorInfo )( 
            IReplicationClient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvErrorArray);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FastMode )( 
            IReplicationClient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FastMode )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Force )( 
            IReplicationClient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Force )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ACLs )( 
            IReplicationClient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ACLs )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumDestinations )( 
            IReplicationClient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SkipLockedFiles )( 
            IReplicationClient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SkipLockedFiles )( 
            IReplicationClient __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        END_INTERFACE
    } IReplicationClientVtbl;

    interface IReplicationClient
    {
        CONST_VTBL struct IReplicationClientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationClient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationClient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationClient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationClient_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationClient_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationClient_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationClient_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationClient_Initialize(This,pszProject)	\
    (This)->lpVtbl -> Initialize(This,pszProject)

#define IReplicationClient_Connect(This)	\
    (This)->lpVtbl -> Connect(This)

#define IReplicationClient_SendFile(This,pszFile)	\
    (This)->lpVtbl -> SendFile(This,pszFile)

#define IReplicationClient_SendFiles(This,pvFileArray)	\
    (This)->lpVtbl -> SendFiles(This,pvFileArray)

#define IReplicationClient_DeleteFile(This,pszFile)	\
    (This)->lpVtbl -> DeleteFile(This,pszFile)

#define IReplicationClient_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IReplicationClient_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IReplicationClient_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IReplicationClient_GetExtendedErrorInfo(This,pvErrorArray)	\
    (This)->lpVtbl -> GetExtendedErrorInfo(This,pvErrorArray)

#define IReplicationClient_get_FastMode(This,pVal)	\
    (This)->lpVtbl -> get_FastMode(This,pVal)

#define IReplicationClient_put_FastMode(This,newVal)	\
    (This)->lpVtbl -> put_FastMode(This,newVal)

#define IReplicationClient_get_Force(This,pVal)	\
    (This)->lpVtbl -> get_Force(This,pVal)

#define IReplicationClient_put_Force(This,newVal)	\
    (This)->lpVtbl -> put_Force(This,newVal)

#define IReplicationClient_get_ACLs(This,pVal)	\
    (This)->lpVtbl -> get_ACLs(This,pVal)

#define IReplicationClient_put_ACLs(This,newVal)	\
    (This)->lpVtbl -> put_ACLs(This,newVal)

#define IReplicationClient_get_NumDestinations(This,pVal)	\
    (This)->lpVtbl -> get_NumDestinations(This,pVal)

#define IReplicationClient_get_SkipLockedFiles(This,pVal)	\
    (This)->lpVtbl -> get_SkipLockedFiles(This,pVal)

#define IReplicationClient_put_SkipLockedFiles(This,newVal)	\
    (This)->lpVtbl -> put_SkipLockedFiles(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_Initialize_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [string][in] */ BSTR pszProject);


void __RPC_STUB IReplicationClient_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_Connect_Proxy( 
    IReplicationClient __RPC_FAR * This);


void __RPC_STUB IReplicationClient_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_SendFile_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [string][in] */ BSTR pszFile);


void __RPC_STUB IReplicationClient_SendFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_SendFiles_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvFileArray);


void __RPC_STUB IReplicationClient_SendFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_DeleteFile_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [string][in] */ BSTR pszFile);


void __RPC_STUB IReplicationClient_DeleteFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_Commit_Proxy( 
    IReplicationClient __RPC_FAR * This);


void __RPC_STUB IReplicationClient_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_Abort_Proxy( 
    IReplicationClient __RPC_FAR * This);


void __RPC_STUB IReplicationClient_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_Disconnect_Proxy( 
    IReplicationClient __RPC_FAR * This);


void __RPC_STUB IReplicationClient_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationClient_GetExtendedErrorInfo_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvErrorArray);


void __RPC_STUB IReplicationClient_GetExtendedErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClient_get_FastMode_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClient_get_FastMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClient_put_FastMode_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IReplicationClient_put_FastMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClient_get_Force_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClient_get_Force_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClient_put_Force_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IReplicationClient_put_Force_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClient_get_ACLs_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClient_get_ACLs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClient_put_ACLs_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IReplicationClient_put_ACLs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClient_get_NumDestinations_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClient_get_NumDestinations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClient_get_SkipLockedFiles_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClient_get_SkipLockedFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClient_put_SkipLockedFiles_Proxy( 
    IReplicationClient __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IReplicationClient_put_SkipLockedFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationClient_INTERFACE_DEFINED__ */


#ifndef __IReplicationClientError_INTERFACE_DEFINED__
#define __IReplicationClientError_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationClientError
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationClientError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("414CC9F0-9F37-11d0-BADA-00C04FD7082F")
    IReplicationClientError : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorCode( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Destination( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Destination( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Project( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Project( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Source( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationClientErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationClientError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationClientError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationClientError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorCode )( 
            IReplicationClientError __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ErrorCode )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IReplicationClientError __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Destination )( 
            IReplicationClientError __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Destination )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FileName )( 
            IReplicationClientError __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FileName )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Project )( 
            IReplicationClientError __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Project )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            IReplicationClientError __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Source )( 
            IReplicationClientError __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IReplicationClientErrorVtbl;

    interface IReplicationClientError
    {
        CONST_VTBL struct IReplicationClientErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationClientError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationClientError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationClientError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationClientError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationClientError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationClientError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationClientError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationClientError_get_ErrorCode(This,pVal)	\
    (This)->lpVtbl -> get_ErrorCode(This,pVal)

#define IReplicationClientError_put_ErrorCode(This,newVal)	\
    (This)->lpVtbl -> put_ErrorCode(This,newVal)

#define IReplicationClientError_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IReplicationClientError_put_Description(This,newVal)	\
    (This)->lpVtbl -> put_Description(This,newVal)

#define IReplicationClientError_get_Destination(This,pVal)	\
    (This)->lpVtbl -> get_Destination(This,pVal)

#define IReplicationClientError_put_Destination(This,newVal)	\
    (This)->lpVtbl -> put_Destination(This,newVal)

#define IReplicationClientError_get_FileName(This,pVal)	\
    (This)->lpVtbl -> get_FileName(This,pVal)

#define IReplicationClientError_put_FileName(This,newVal)	\
    (This)->lpVtbl -> put_FileName(This,newVal)

#define IReplicationClientError_get_Project(This,pVal)	\
    (This)->lpVtbl -> get_Project(This,pVal)

#define IReplicationClientError_put_Project(This,newVal)	\
    (This)->lpVtbl -> put_Project(This,newVal)

#define IReplicationClientError_get_Source(This,pVal)	\
    (This)->lpVtbl -> get_Source(This,pVal)

#define IReplicationClientError_put_Source(This,newVal)	\
    (This)->lpVtbl -> put_Source(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_get_ErrorCode_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClientError_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_put_ErrorCode_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IReplicationClientError_put_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_get_Description_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClientError_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_put_Description_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IReplicationClientError_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_get_Destination_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClientError_get_Destination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_put_Destination_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IReplicationClientError_put_Destination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_get_FileName_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClientError_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_put_FileName_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IReplicationClientError_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_get_Project_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClientError_get_Project_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_put_Project_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IReplicationClientError_put_Project_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_get_Source_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IReplicationClientError_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IReplicationClientError_put_Source_Proxy( 
    IReplicationClientError __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IReplicationClientError_put_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationClientError_INTERFACE_DEFINED__ */


#ifndef __IReplicationPostingAcceptor_INTERFACE_DEFINED__
#define __IReplicationPostingAcceptor_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReplicationPostingAcceptor
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IReplicationPostingAcceptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("5163ce6b-1d76-11d1-a32b-0000f8014963")
    IReplicationPostingAcceptor : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ BSTR pszParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ BSTR pszParmName,
            /* [in] */ VARIANT vParmValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Enum( 
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out][in] */ VARIANT __RPC_FAR *pvParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicationPostingAcceptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReplicationPostingAcceptor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReplicationPostingAcceptor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReplicationPostingAcceptor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReplicationPostingAcceptor __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReplicationPostingAcceptor __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReplicationPostingAcceptor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReplicationPostingAcceptor __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IReplicationPostingAcceptor __RPC_FAR * This,
            /* [string][in] */ BSTR pszParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IReplicationPostingAcceptor __RPC_FAR * This,
            /* [string][in] */ BSTR pszParmName,
            /* [in] */ VARIANT vParmValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enum )( 
            IReplicationPostingAcceptor __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
            /* [out][in] */ VARIANT __RPC_FAR *pvParmName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);
        
        END_INTERFACE
    } IReplicationPostingAcceptorVtbl;

    interface IReplicationPostingAcceptor
    {
        CONST_VTBL struct IReplicationPostingAcceptorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicationPostingAcceptor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplicationPostingAcceptor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplicationPostingAcceptor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplicationPostingAcceptor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReplicationPostingAcceptor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReplicationPostingAcceptor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReplicationPostingAcceptor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReplicationPostingAcceptor_Get(This,pszParmName,pvParmValue)	\
    (This)->lpVtbl -> Get(This,pszParmName,pvParmValue)

#define IReplicationPostingAcceptor_Put(This,pszParmName,vParmValue)	\
    (This)->lpVtbl -> Put(This,pszParmName,vParmValue)

#define IReplicationPostingAcceptor_Enum(This,pvIterator,pvParmName,pvParmValue)	\
    (This)->lpVtbl -> Enum(This,pvIterator,pvParmName,pvParmValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationPostingAcceptor_Get_Proxy( 
    IReplicationPostingAcceptor __RPC_FAR * This,
    /* [string][in] */ BSTR pszParmName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);


void __RPC_STUB IReplicationPostingAcceptor_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationPostingAcceptor_Put_Proxy( 
    IReplicationPostingAcceptor __RPC_FAR * This,
    /* [string][in] */ BSTR pszParmName,
    /* [in] */ VARIANT vParmValue);


void __RPC_STUB IReplicationPostingAcceptor_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IReplicationPostingAcceptor_Enum_Proxy( 
    IReplicationPostingAcceptor __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvIterator,
    /* [out][in] */ VARIANT __RPC_FAR *pvParmName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvParmValue);


void __RPC_STUB IReplicationPostingAcceptor_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplicationPostingAcceptor_INTERFACE_DEFINED__ */



#ifndef __CRSAPILib_LIBRARY_DEFINED__
#define __CRSAPILib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: CRSAPILib
 * at Thu Apr 23 13:37:19 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_CRSAPILib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationServer;

class DECLSPEC_UUID("66D6D7ED-22D2-11D0-9B98-00C04FD5CD09")
CReplicationServer;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationProject;

class DECLSPEC_UUID("66D6D7F2-22D2-11D0-9B98-00C04FD5CD09")
CReplicationProject;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationInstance;

class DECLSPEC_UUID("66D6D7F7-22D2-11D0-9B98-00C04FD5CD09")
CReplicationInstance;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationRoute;

class DECLSPEC_UUID("66D6D7FC-22D2-11D0-9B98-00C04FD5CD09")
CReplicationRoute;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationClient;

class DECLSPEC_UUID("B24F0373-9692-11D0-BAD5-00C04FD7082F")
CReplicationClient;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationClientError;

class DECLSPEC_UUID("6AF9D110-9F37-11d0-BADA-00C04FD7082F")
CReplicationClientError;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationEventSinkConfig;

class DECLSPEC_UUID("66D6D7FD-22D2-11D0-9B98-00C04FD5CD09")
CReplicationEventSinkConfig;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationItem;

class DECLSPEC_UUID("66D6D7FE-22D2-11D0-9B98-00C04FD5CD09")
CReplicationItem;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationSchedule;

class DECLSPEC_UUID("4E28F5F0-1B3C-11d1-8C8C-00C04FC2D3B9")
CReplicationSchedule;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CReplicationPostingAcceptor;

class DECLSPEC_UUID("055f638a-1d77-11d1-a32b-0000f8014963")
CReplicationPostingAcceptor;
#endif
#endif /* __CRSAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\CrsClsId.h ===
#ifndef __CRSCLSID_H__
#define __CRSCLSID_H__

//====================================================================
//                                                                     
//   Microsoft Site Server v3.00                                   
//                                                                     
//   Copyright (c) 1997 - 1999 Microsoft Corporation.  All rights reserved.   
//   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
//   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//   PARTICULAR PURPOSE.
//=====================================================================

//
// CLSIDs for the Content Deployment (aka CRS) COM Objects (ProgId = CrsApi)
//

// {66D6D7ED-22D2-11D0-9B98-00C04FD5CD09}
DEFINE_GUID(CLSID_ReplicationServer, 
0x66D6D7ED, 0x22D2, 0x11D0, 0x9B, 0x98, 0x00, 0xC0, 0x4F, 0xD5, 0xCD, 0x09);

// {66D6D7F2-22D2-11D0-9B98-00C04FD5CD09}
DEFINE_GUID(CLSID_ReplicationProject, 
0x66D6D7F2, 0x22D2, 0x11D0, 0x9B, 0x98, 0x00, 0xC0, 0x4F, 0xD5, 0xCD, 0x09);

// {66D6D7F7-22D2-11D0-9B98-00C04FD5CD09}};
DEFINE_GUID(CLSID_ReplicationInstance, 
0x66D6D7F7, 0x22D2, 0x11D0, 0x9B, 0x98, 0x00, 0xC0, 0x4F, 0xD5, 0xCD, 0x09);

// {66D6D7FC-22D2-11D0-9B98-00C04FD5CD09}
DEFINE_GUID(CLSID_ReplicationRoute,
0x66D6D7FC, 0x22D2, 0x11D0, 0x9B, 0x98, 0x00, 0xC0, 0x4F, 0xD5, 0xCD, 0x09);

// {66D6D7FE-22D2-11D0-9B98-00C04FD5CD09}
DEFINE_GUID( CLSID_ReplicationItem,
0x66D6D7FE, 0x22D2, 0x11D0, 0x9B, 0x98, 0x00, 0xC0, 0x4F, 0xD5, 0xCD, 0x09);

// {66D6D7FD-22D2-11D0-9B98-00C04FD5CD09}
DEFINE_GUID( CLSID_ReplicationEventSinkConfig,
0x66D6D7FD, 0x22D2, 0x11D0, 0x9B, 0x98, 0x00, 0xC0, 0x4F, 0xD5, 0xCD, 0x09);


// {B24F0373-9692-11D0-BAD5-00C04FD7082F}
DEFINE_GUID(CLSID_ReplicationClient,
0xB24F0373, 0x9692, 0x11D0, 0xBA, 0xD5, 0x00, 0xC0, 0x4F, 0xD7, 0x08, 0x2F);

// {6AF9D110-9F37-11d0-BADA-00C04FD7082F}
DEFINE_GUID(CLSID_ReplicationClientError, 
0x6AF9D110, 0x9F37, 0x11d0, 0xBA, 0xDA, 0x00, 0xC0, 0x4F, 0xD7, 0x08, 0x2F);

// {055f638a-1d77-11d1-a32b-0000f8014963}
DEFINE_GUID(CLSID_ReplicationPostingAcceptor, 
0x055f638A, 0x1D77, 0x11D1, 0xA3, 0x2B, 0x00, 0x00, 0xF8, 0x01, 0x49, 0x63);

//{4E28F5F0-1B3C-11d1-8C8C-00C04FC2D3B9}
DEFINE_GUID(CLSID_ReplicationSchedule, 
0x4E28F5F0, 0x1B3C, 0x11d1, 0x8C, 0x8C, 0x00, 0xC0, 0x4F, 0xC2, 0xD3, 0xB9);



//
// Interface IDs
//

// {ABEB9802-DB7A-11d0-A800-00C04FC9DAA5}
DEFINE_GUID(IID_IReplicationServer, 
0xABEB9802,0xDB7A,0x11d0,0xA8,0x00,0x00,0xC0,0x4F,0xC9,0xDA,0xA5);

// {ABEB9803-DB7A-11d0-A800-00C04FC9DAA5}
DEFINE_GUID(IID_IReplicationProject, 
0xABEB9803,0xDB7A,0x11d0,0xA8,0x00,0x00,0xC0,0x4F,0xC9,0xDA,0xA5);

// {ABEB9807-DB7A-11d0-A800-00C04FC9DAA5}
DEFINE_GUID(IID_IReplicationInstance, 
0xABEB9807,0xDB7A,0x11d0,0xA8,0x00,0x00,0xC0,0x4F,0xC9,0xDA,0xA5);

// {ABEB9804-DB7A-11d0-A800-00C04FC9DAA5}
DEFINE_GUID(IID_IReplicationRoute,
0xABEB9804,0xDB7A,0x11d0,0xA8,0x00,0x00,0xC0,0x4F,0xC9,0xDA,0xA5);

// {B24F0372-9692-11D0-BAD5-00C04FD7082F}
DEFINE_GUID(IID_IReplicationClient,
0xB24F0372,0x9692,0x11D0,0xBA,0xD5,0x00,0xC0,0x4F,0xD7,0x08,0x2F);

// {414CC9F0-9F37-11d0-BADA-00C04FD7082F}
DEFINE_GUID(IID_IReplicationClientError, 
0x414CC9F0, 0x9F37, 0x11d0, 0xBA, 0xDA, 0x00, 0xC0, 0x4F, 0xD7, 0x08, 0x2F);

// {ABEB9808-DB7A-11d0-A800-00C04FC9DAA5}
DEFINE_GUID(IID_IReplicationItem,
0xABEB9808,0xDB7A,0x11d0,0xA8,0x00,0x00,0xC0,0x4F,0xC9,0xDA,0xA5);

// {ABEB980A-DB7A-11d0-A800-00C04FC9DAA5}
DEFINE_GUID(IID_IReplicationEventSinkConfig,
0xABEB980A,0xDB7A,0x11d0,0xA8,0x00,0x00,0xC0,0x4F,0xC9,0xDA,0xA5);

// {541eaaf0-717b-11cf-86cb-00aa00b4e1b8}
DEFINE_GUID(IID_IAcceptNotify,
0x541eaaf0, 0x717b, 0x11cf, 0x86, 0xcb, 0x00, 0xaa, 0x00, 0xb4, 0xe1, 0xb8);

// {5163ce6b-1d76-11d1-a32b-0000f8014963}
DEFINE_GUID(IID_IReplicationPostingAcceptor, 
0x5163ce6b, 0x1D76, 0x11D1, 0xA3, 0x2B, 0x00, 0x00, 0xF8, 0x01, 0x49, 0x63);

// {82D36BA0-1B37-11d1-8C8C-00C04FC2D3B9}
DEFINE_GUID(IID_IReplicationSchedule, 
0x82d36ba0, 0x1B37, 0x11d1, 0x8C, 0x8C, 0x00, 0xC0, 0x4F, 0xC2, 0xD3, 0xB9);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\CrsMsg.Inc ===
'====================================================================
'                                                                     
'   Microsoft Site Server v3.00                                   
'                                                                     
'   Copyright (c) 1997 - 1999 Microsoft Corporation.  All rights reserved.   
'   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
'   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
'   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
'   PARTICULAR PURPOSE.
'=====================================================================

'
'  Values are 32 bit values layed out as follows:
'
'   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
'   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
'  +---+-+-+-----------------------+-------------------------------+
'  |Sev|C|R|     Facility          |               Code            |
'  +---+-+-+-----------------------+-------------------------------+
'
'  where
'
'      Sev - is the severity code
'
'          00 - Success
'          01 - Informational
'          10 - Warning
'          11 - Error
'
'      C - is the Customer code flag
'
'      R - is a reserved bit
'
'      Facility - is the facility code
'
'      Code - is the facility's status code
'
'
' Define the facility codes
'


'
' Define the severity codes
'


'
' MessageId: CRS_ERROR_FIRST
'
' MessageText:
'
'  Site Server Content Deployment service first error message.
'
Const CRS_ERROR_FIRST                  = &H40003A98

'
' MessageId: CRS_NET_SOURCE
'
' MessageText:
'
'  Source directory %2 for the project %1 is on a network drive.  Cannot deploy from network drives.
'
Const CRS_NET_SOURCE                   = &HC0003A9C

'
' MessageId: CRS_ERROR_ACCESS_DENIED
'
' MessageText:
'
'  Access denied.
'
Const CRS_ERROR_ACCESS_DENIED          = &HC0003A9D

'
' MessageId: CRS_FILE_CREATE_ERROR
'
' MessageText:
'
'  Unable to open the file %1.
'
Const CRS_FILE_CREATE_ERROR            = &HC0003A9E

'
' MessageId: CRS_SENDINET_ERROR
'
' MessageText:
'
'  Project was unable to send file %1.
'
Const CRS_SENDINET_ERROR               = &HC0003A9F

'
' MessageId: CRS_SAMEBOX_NET_TARGET
'
' MessageText:
'
'  Destination directory %2 for the project %1 is on a network drive.  Cannot deploy to network drives.
'
Const CRS_SAMEBOX_NET_TARGET           = &HC0003AA0

'
' MessageId: CRS_BAD_SOURCE
'
' MessageText:
'
'  Unable to access the project source %1.
'
Const CRS_BAD_SOURCE                   = &HC0003AA1

'
' MessageId: CRS_SENDINET_CONNECT
'
' MessageText:
'
'  Unable to connect to the remote server %1.
'
Const CRS_SENDINET_CONNECT             = &HC0003AA2

'
' MessageId: CRS_HASH_MISMATCH
'
' MessageText:
'
'  MD5 Hash did not match during a transmission.  This could indicate transmission failure or that the files transmitted at the source have been modified in transit.
'
Const CRS_HASH_MISMATCH                = &HC0003AA3

'
' MessageId: CRS_SERVER_ABORTED
'
' MessageText:
'
'  Remote server was restarted.  The project %1 is being restarted.
'
Const CRS_SERVER_ABORTED               = &HC0003AA4

'
' MessageId: CRS_REPLICATION_ABORTED
'
' MessageText:
'
'  Project %1 was aborted.
'
Const CRS_REPLICATION_ABORTED          = &HC0003AA5

'
' MessageId: CRS_SEQUENCE_ERROR
'
' MessageText:
'
'  An internal messaging sequence error occurred.
'
Const CRS_SEQUENCE_ERROR               = &HC0003AA6

'
' MessageId: CRS_SERVICE_STARTED
'
' MessageText:
'
'  Site Server Content Deployment service started successfully.
'
Const CRS_SERVICE_STARTED              = &H40003AA7

'
' MessageId: CRS_SERVICE_SHUTDOWN
'
' MessageText:
'
'  Site Server Content Deployment service shut down successfully.
'
Const CRS_SERVICE_SHUTDOWN             = &H40003AA8

'
' MessageId: CRS_ERROR_METABASE_ACCESS
'
' MessageText:
'
'  Could not open storage/stream %1.  Ensure the authentication account has access to this storage/stream.
'
Const CRS_ERROR_METABASE_ACCESS        = &HC0003AAA

'
' MessageId: CRS_AUTH_FAILURE
'
' MessageText:
'
'  Authorization failure against server %1.  Ensure the service has access to this server.
'
Const CRS_AUTH_FAILURE                 = &HC0003AAB

'
' MessageId: CRS_REMOTE_AUTH_FAILURE
'
' MessageText:
'
'  Remote authorization failed to server %1.  Ensure the service has access to this server.
'
Const CRS_REMOTE_AUTH_FAILURE          = &HC0003AAC

'
' MessageId: CRS_ERROR_NOT_IN_ORDER
'
' MessageText:
'
'  Message was received out of order.  Closing connection.
'
Const CRS_ERROR_NOT_IN_ORDER           = &HC0003AAD

'
' MessageId: CRS_CONNECTION_RETRY_FAILED
'
' MessageText:
'
'  Connection to server %1 failed and could not be re-established.
'
Const CRS_CONNECTION_RETRY_FAILED      = &HC0003AAE

'
' MessageId: CRS_ERROR_REPLICATION_CANCELED
'
' MessageText:
'
'  Project %1 canceled at the request of the user.
'
Const CRS_ERROR_REPLICATION_CANCELED   = &HC0003AAF

'
' MessageId: CRS_ERROR_DEST_TOOBIG
'
' MessageText:
'
'  Could not add the specified destination(s).  The maximum number of destinations has been reached.
'
Const CRS_ERROR_DEST_TOOBIG            = &HC0003AB0

'
' MessageId: CRS_ERROR_NO_IP_MAPPING
'
' MessageText:
'
'  Cannot resolve IP address for server %1.  No virtual root created.
'
Const CRS_ERROR_NO_IP_MAPPING          = &HC0003AB1

'
' MessageId: CRS_ERROR_DISK_FULL
'
' MessageText:
'
'  Not enough space on the disk.
'
Const CRS_ERROR_DISK_FULL              = &HC0003AB2

'
' MessageId: CRS_ERROR_TOO_MANY_RUNNING
'
' MessageText:
'
'  Too many active projects. No more can be started until others complete.
'
Const CRS_ERROR_TOO_MANY_RUNNING       = &HC0003AB3

'
' MessageId: CRS_ERROR_WOULDBLOCK
'
' MessageText:
'
'  The network operation would block.
'
Const CRS_ERROR_WOULDBLOCK             = &H00003ABB

'
' MessageId: CRS_ERROR_NETDOWN
'
' MessageText:
'
'  The remote network is down.
'
Const CRS_ERROR_NETDOWN                = &HC0003ACA

'
' MessageId: CRS_ERROR_NETUNREACH
'
' MessageText:
'
'  The remote network is unreachable.
'
Const CRS_ERROR_NETUNREACH             = &HC0003ACB

'
' MessageId: CRS_ERROR_CONNABORTED
'
' MessageText:
'
'  The network connection was aborted at the network layer.
'
Const CRS_ERROR_CONNABORTED            = &HC0003ACD

'
' MessageId: CRS_ERROR_TIMEOUT
'
' MessageText:
'
'  The network session timed out on a send or receive operation.
'
Const CRS_ERROR_TIMEOUT                = &HC0003AD4

'
' MessageId: WINSOCK_WSAEWOULDBLOCK
'
' MessageText:
'
'  The network operation would block.
'
Const WINSOCK_WSAEWOULDBLOCK           = &H00002733

'
' MessageId: WINSOCK_WSAENETDOWN
'
' MessageText:
'
'  The remote network is down.
'
Const WINSOCK_WSAENETDOWN              = &H00002742

'
' MessageId: WINSOCK_WSAENETUNREACH
'
' MessageText:
'
'  The remote network is unreachable.
'
Const WINSOCK_WSAENETUNREACH           = &H00002743

'
' MessageId: WINSOCK_WSAECONNABORTED
'
' MessageText:
'
'  The network connection was aborted at the network layer.
'
Const WINSOCK_WSAECONNABORTED          = &H00002745

'
' MessageId: WINSOCK_WSAECONNRESET
'
' MessageText:
'
'  The network session was aborted.
'
Const WINSOCK_WSAECONNRESET            = &H00002746

'
' MessageId: WINSOCK_WSAETIMEDOUT
'
' MessageText:
'
'  The network session timed out on a send or receive operation.
'
Const WINSOCK_WSAETIMEDOUT             = &H0000274C

'
' MessageId: WINSOCK_WSAECONNREFUSED
'
' MessageText:
'
'  The remote server was not listening on the appropriate port. This generally indicates that the service was not running but the server is up.
'
Const WINSOCK_WSAECONNREFUSED          = &H0000274D

'
' MessageId: CRS_ERROR_NO_PROJECTS
'
' MessageText:
'
'  No projects defined.
'
Const CRS_ERROR_NO_PROJECTS            = &HC0003AFC

'
' MessageId: CRS_ERROR_PROJECT_NOT_FOUND
'
' MessageText:
'
'  Could not find project %1.
'
Const CRS_ERROR_PROJECT_NOT_FOUND      = &HC0003AFD

'
' MessageId: CRS_ERROR_INVALID_PARAMETER
'
' MessageText:
'
'  Invalid parameter.
'
Const CRS_ERROR_INVALID_PARAMETER      = &HC0003AFE

'
' MessageId: CRS_PROJECT_CREATED
'
' MessageText:
'
'  Created project %1.
'
Const CRS_PROJECT_CREATED              = &HC0003AFF

'
' MessageId: CRS_ERROR_AUTHENTICATION_FAILURE
'
' MessageText:
'
'  Authentication failure.  Ensure the account has proper access on local and remote servers.
'
Const CRS_ERROR_AUTHENTICATION_FAILURE = &HC0003B00

'
' MessageId: CRS_ERROR_DELETE_PROJECT_DOWN_ROUTE
'
' MessageText:
'
'  Could not delete the route from the project on at least one server down the defined routes.  The project will have to be edited manually there.
'
Const CRS_ERROR_DELETE_PROJECT_DOWN_ROUTE = &H80003B01

'
' MessageId: CRS_ERROR_SERVICE_NOT_RUNNING
'
' MessageText:
'
'  Server %1 is available, but the Site Server Content Deployment service is not running.
'
Const CRS_ERROR_SERVICE_NOT_RUNNING    = &HC0003B02

'
' MessageId: CRS_ERROR_HOST_DOWN
'
' MessageText:
'
'  Server %1 is unavailable.
'
Const CRS_ERROR_HOST_DOWN              = &HC0003B03

'
' MessageId: CRS_ERROR_BAD_NET_NAME
'
' MessageText:
'
'  Server %1 cannot be found.
'
Const CRS_ERROR_BAD_NET_NAME           = &HC0003B04

'
' MessageId: CRS_ERROR_ROUTE_NOT_FOUND
'
' MessageText:
'
'  Could not find route %1.  Ensure the route name is correct and that it exists on the target servers.
'
Const CRS_ERROR_ROUTE_NOT_FOUND        = &HC0003B05

'
' MessageId: CRS_ERROR_NO_ROUTES
'
' MessageText:
'
'  No routes defined.
'
Const CRS_ERROR_NO_ROUTES              = &HC0003B06

'
' MessageId: CRS_ERROR_CREATE_PROJECT_DOWN_ROUTE
'
' MessageText:
'
'  Could not create the project on at least one server down the defined routes.  The project will have to be created manually there.
'
Const CRS_ERROR_CREATE_PROJECT_DOWN_ROUTE = &H80003B07

'
' MessageId: CRS_ERROR_SERVICE_PAUSED
'
' MessageText:
'
'  Site Server Content Deployment service on server %1 is paused and is not accepting new requests.  Retry project %2 later.
'
Const CRS_ERROR_SERVICE_PAUSED         = &HC0003B08

'
' MessageId: CRS_ERROR_SERVICE_NOT_PAUSED
'
' MessageText:
'
'  Could not restart service. Service is not paused.
'
Const CRS_ERROR_SERVICE_NOT_PAUSED     = &HC0003B09

'
' MessageId: CRS_ERROR_NAME_NOT_RESOLVED
'
' MessageText:
'
'  Could not resolve URL %2 for project %1.  Ensure URL and/or proxy settings are correct.
'
Const CRS_ERROR_NAME_NOT_RESOLVED      = &HC0003B0A

'
' MessageId: CRS_ERROR_CONNECTION_RESET
'
' MessageText:
'
'  Connection to server %1 has been reset.  This indicates problems with the remote service or network.
'
Const CRS_ERROR_CONNECTION_RESET       = &HC0003B0B

'
' MessageId: CRS_ERROR_REPLICATION_NOT_FOUND
'
' MessageText:
'
'  No entries.
'
Const CRS_ERROR_REPLICATION_NOT_FOUND  = &HC0003B0C

'
' MessageId: CRS_ERROR_SERVICE_ALREADY_RUNNING
'
' MessageText:
'
'  Could not start service.  The service has already been started.
'
Const CRS_ERROR_SERVICE_ALREADY_RUNNING = &HC0003B0D

'
' MessageId: CRS_ERROR_PROJECT_ALREADY_RUNNING
'
' MessageText:
'
'  Failed to start project %1.  It is already running.
'
Const CRS_ERROR_PROJECT_ALREADY_RUNNING = &HC0003B0E

'
' MessageId: CRS_ERROR_FILE_MOVE_ERROR
'
' MessageText:
'
'  Failed to move file %1 to %2.
'
Const CRS_ERROR_FILE_MOVE_ERROR        = &HC0003B0F

'
' MessageId: CRS_ERROR_PRODUCT_EXPIRED
'
' MessageText:
'
'  Thank you for your interest in Site Server Content Deployment.  This software has expired.  Please acquire the final retail version of this software.
'
Const CRS_ERROR_PRODUCT_EXPIRED        = &HC0003B10

'
' MessageId: CRS_ERROR_PROJECT_INCOMPLETE
'
' MessageText:
'
'  Project information for %1 is incomplete.
'
Const CRS_ERROR_PROJECT_INCOMPLETE     = &HC0003B11

'
' MessageId: CRS_ERROR_PARAMETER_NOT_FOUND
'
' MessageText:
'
'  Parameter %1 not found.
'
Const CRS_ERROR_PARAMETER_NOT_FOUND    = &HC0003B12

'
' MessageId: CRS_ERROR_REPLICATION_RUNNING
'
' MessageText:
'
'  Project %1 is running.  The operation could not be completed.
'
Const CRS_ERROR_REPLICATION_RUNNING    = &HC0003B13

'
' MessageId: CRS_ERROR_INVALID_PROJECT_NAME
'
' MessageText:
'
'  Project name %1 is invalid.  Project names cannot contain backslashes and cannot be empty.
'
Const CRS_ERROR_INVALID_PROJECT_NAME   = &HC0003B14

'
' MessageId: CRS_ERROR_INVALID_ROUTE_NAME
'
' MessageText:
'
'  Route name %1 is invalid.  Route names cannot contain backslashes or DBCS characters and cannot be empty.
'
Const CRS_ERROR_INVALID_ROUTE_NAME     = &HC0003B15

'
' MessageId: CRS_ERROR_INVALID_DWORD
'
' MessageText:
'
'  Parameter %1 must be a positive integer.
'
Const CRS_ERROR_INVALID_DWORD          = &HC0003B16

'
' MessageId: CRS_ERROR_NO_MORE_ITEMS
'
' MessageText:
'
'  No more items in the list.
'
Const CRS_ERROR_NO_MORE_ITEMS          = &H80003B17

'
' MessageId: CRS_ERROR_TOO_MANY_ARGS
'
' MessageText:
'
'  Too many arguments specified.
'
Const CRS_ERROR_TOO_MANY_ARGS          = &HC0003B18

'
' MessageId: CRS_MBS_INIT_ERROR
'
' MessageText:
'
'  Internal error trying to initialize for ACL replication.
'
Const CRS_MBS_INIT_ERROR               = &HC0003B19

'
' MessageId: CRS_ERROR_OPENING_FILE
'
' MessageText:
'
'  Error opening file %1 or file not found.
'
Const CRS_ERROR_OPENING_FILE           = &HC0003B1B

'
' MessageId: CRS_ERROR_FILE_FORMAT
'
' MessageText:
'
'  Invalid file format.
'
Const CRS_ERROR_FILE_FORMAT            = &HC0003B1C

'
' MessageId: CRS_ERROR_FILE_WRITE
'
' MessageText:
'
'  Error writing to file %1.
'
Const CRS_ERROR_FILE_WRITE             = &HC0003B1D

'
' MessageId: WINSOCK_WSAHOSTNAME
'
' MessageText:
'
'  Gethostname failed.
'
Const WINSOCK_WSAHOSTNAME              = &HC0003B1E

'
' MessageId: CRS_ERROR_NODE_EXISTS
'
' MessageText:
'
'  Node already exists in the topology map.
'
Const CRS_ERROR_NODE_EXISTS            = &HC0003B1F

'
' MessageId: CRS_ERROR_NODE_NOT_FOUND
'
' MessageText:
'
'  Node not found in topology map.
'
Const CRS_ERROR_NODE_NOT_FOUND         = &HC0003B20

'
' MessageId: CRS_ERROR_EDGE_EXISTS
'
' MessageText:
'
'  Edge already exists in topology map.
'
Const CRS_ERROR_EDGE_EXISTS            = &H80003B21

'
' MessageId: CRS_ERROR_ROOTNODE_NOT_FOUND
'
' MessageText:
'
'  Root node does not exist in topology map.
'
Const CRS_ERROR_ROOTNODE_NOT_FOUND     = &HC0003B22

'
' MessageId: CRS_ERROR_PATH_NOT_FOUND
'
' MessageText:
'
'  No path to from root to node in topology map.
'
Const CRS_ERROR_PATH_NOT_FOUND         = &HC0003B23

'
' MessageId: CRS_ERROR_EDGE_NOT_FOUND
'
' MessageText:
'
'  Edge does not exist in topology map.
'
Const CRS_ERROR_EDGE_NOT_FOUND         = &HC0003B24

'
' MessageId: CRS_ERROR_INVALID_CONTEXT
'
' MessageText:
'
'  Current context is invalid.  Project being reset.
'
Const CRS_ERROR_INVALID_CONTEXT        = &HC0003B25

'
' MessageId: CRS_ERROR_DOWNLEVEL_SERVER
'
' MessageText:
'
'  Operation is not supported on a down-level server.
'
Const CRS_ERROR_DOWNLEVEL_SERVER       = &HC0003B26

'
' MessageId: CRS_ERROR_NO_MAPPING
'
' MessageText:
'
'  URL does not map to any project definitions.
'
Const CRS_ERROR_NO_MAPPING             = &HC0003B27

'
' MessageId: CRS_ERROR_START_PENDING
'
' MessageText:
'
'  Start pending completion of the active project.
'
Const CRS_ERROR_START_PENDING          = &HC0003B28

'
' MessageId: CRS_ERROR_NO_EVENTSINKS
'
' MessageText:
'
'  No event sinks defined.
'
Const CRS_ERROR_NO_EVENTSINKS          = &HC0003B29

'
' MessageId: CRS_ERROR_EVENTSINK_NOT_FOUND
'
' MessageText:
'
'  Could not find event sink %1.
'
Const CRS_ERROR_EVENTSINK_NOT_FOUND    = &HC0003B2A

'
' MessageId: CRS_ERROR_WSAHOSTNOTFOUND
'
' MessageText:
'
'  Host not found.
'
Const CRS_ERROR_WSAHOSTNOTFOUND        = &HC0003B2B

'
' MessageId: CRS_ERROR_WSATRYAGAIN
'
' MessageText:
'
'  Host not found, or SERVERFAIL.  Try again.
'
Const CRS_ERROR_WSATRYAGAIN            = &HC0003B2C

'
' MessageId: CRS_ERROR_WSANORECOVERY
'
' MessageText:
'
'  Non-recoverable winsock error.
'
Const CRS_ERROR_WSANORECOVERY          = &HC0003B2D

'
' MessageId: CRS_ERROR_WSANODATA
'
' MessageText:
'
'  Invalid address.
'
Const CRS_ERROR_WSANODATA              = &HC0003B2E

'
' MessageId: CRS_EVENTSINK_INITIALIZED
'
' MessageText:
'
'  Event sink %1 was successfully initialized.
'
Const CRS_EVENTSINK_INITIALIZED        = &H00003B2F

'
' MessageId: CRS_ERROR_EVENTSINK_NOT_INITIALIZED
'
' MessageText:
'
'  Event sink %1 failed to initialize.
'
Const CRS_ERROR_EVENTSINK_NOT_INITIALIZED = &HC0003B30

'
' MessageId: CRS_ERROR_NOTHING_TO_ROLLBACK
'
' MessageText:
'
'  Could not roll back project.  No rollback information found.
'
Const CRS_ERROR_NOTHING_TO_ROLLBACK    = &HC0003B31

'
' MessageId: CRS_ERROR_NO_DESTINATIONS
'
' MessageText:
'
'  Project could not be started because no destinations are defined.
'
Const CRS_ERROR_NO_DESTINATIONS        = &HC0003B32

'
' MessageId: CRS_ERROR_REAUTHENTICATE
'
' MessageText:
'
'  Re-authenticate using an acceptable protocol.
'
Const CRS_ERROR_REAUTHENTICATE         = &HC0003B33

'
' MessageId: CRS_ERROR_UNSUPPORTED
'
' MessageText:
'
'  Function not supported in this version to this server.
'
Const CRS_ERROR_UNSUPPORTED            = &HC0003B34

'
' MessageId: CRS_ERROR_USER_NOT_FOUND
'
' MessageText:
'
'  Specified user %1 could not be found.
'
Const CRS_ERROR_USER_NOT_FOUND         = &HC0003B35

'
' MessageId: CRS_ERROR_NO_TRANSACTIONS
'
' MessageText:
'
'  No transactions for the specified project.
'
Const CRS_ERROR_NO_TRANSACTIONS        = &HC0003B36

'
' MessageId: CRS_ERROR_NO_SERVERS
'
' MessageText:
'
'  No destination servers defined.
'
Const CRS_ERROR_NO_SERVERS             = &HC0003B37

'
' MessageId: CRS_ERROR_NO_SCHEDULES
'
' MessageText:
'
'  No schedules defined for this project.
'
Const CRS_ERROR_NO_SCHEDULES           = &HC0003B38

'
' MessageId: CRS_ERROR_NO_EMAIL
'
' MessageText:
'
'  Could not contact SMTP server %1 to send e-mail report for project %2.
'
Const CRS_ERROR_NO_EMAIL               = &HC0003B39

'
' MessageId: CRS_ERROR_WAIT_ABORT
'
' MessageText:
'
'  Waiting abort on project %1 after losing connection with source server.
'
Const CRS_ERROR_WAIT_ABORT             = &HC0003B3A

'
' MessageId: CRS_RESUME_REPLICATION
'
' MessageText:
'
'  Resuming project %1 to server %2.
'
Const CRS_RESUME_REPLICATION           = &H40003B3B

'
' MessageId: CRS_METABASE_NOT_FOUND
'
' MessageText:
'
'  Metabase is not responding.
'
Const CRS_METABASE_NOT_FOUND           = &HC0003B3C

'
' MessageId: CRS_SSE_VROOT_NOT_FOUND
'
' MessageText:
'
'  Site Server virtual directory not found.
'
Const CRS_SSE_VROOT_NOT_FOUND          = &HC0003B3D

'
' MessageId: CRS_WARNING_CONNECTION_FAILED
'
' MessageText:
'
'  Connection to server %1 for project %2 failed.  Will attempt to re-establish session.
'
Const CRS_WARNING_CONNECTION_FAILED    = &H80003B3E

'
' MessageId: CRS_ERROR_DROPPED_EMAIL_REPORT
'
' MessageText:
'
'  Dropped e-mail report for project %1.
'
Const CRS_ERROR_DROPPED_EMAIL_REPORT   = &HC0003B3F

'
' MessageId: CRS_ERROR_EMAIL_HOST_NOT_DEFINED
'
' MessageText:
'
'  No SMTP server defined.
'
Const CRS_ERROR_EMAIL_HOST_NOT_DEFINED = &HC0003B40

'
' MessageId: CRS_ERROR_VROOT_CREATION
'
' MessageText:
'
'  Could not create the specified virtual directory.
'
Const CRS_ERROR_VROOT_CREATION         = &H80003B41

'
' MessageId: CRS_ERROR_UPLPAGE_CREATION
'
' MessageText:
'
'  Could not create the upload page.
'
Const CRS_ERROR_UPLPAGE_CREATION       = &HC0003B42

'
' MessageId: CRS_ERROR_CIRCULAR_ROUTE
'
' MessageText:
'
'  System has detected a circular route.  Project not created.
'
Const CRS_ERROR_CIRCULAR_ROUTE         = &HC0003B43

'
' MessageId: CRS_ERROR_TRANSACTION_APPLY_FAILED
'
' MessageText:
'
'  Transaction application for project %1 failed.  Check permissions on the destination directory and files and ensure that no files are locked open.
'
Const CRS_ERROR_TRANSACTION_APPLY_FAILED = &HC0003B44

'
' MessageId: CRS_ERROR_DATABASE
'
' MessageText:
'
'  Error occurred with the database %1.  Error is: %2.
'
Const CRS_ERROR_DATABASE               = &HC0003B45

'
' MessageId: CRS_ERROR_SINK_CONNECT_FAILED
'
' MessageText:
'
'  Unable to connect to remote server %1 to forward events.
'
Const CRS_ERROR_SINK_CONNECT_FAILED    = &HC0003B46

'
' MessageId: CRS_ERROR_CANT_SEND_EVENTS_TO_DOWNLEVEL_SERVER
'
' MessageText:
'
'  Unable to send events to server %1.  This operation is not supported.
'
Const CRS_ERROR_CANT_SEND_EVENTS_TO_DOWNLEVEL_SERVER = &HC0003B47

'
' MessageId: CRS_ERROR_FILE_CORRUPT
'
' MessageText:
'
'  File %1 is corrupt or unreadable.
'
Const CRS_ERROR_FILE_CORRUPT           = &HC0003B48

'
' MessageId: CRS_ERROR_FILE_BUSY
'
' MessageText:
'
'  File %1 is busy.
'
Const CRS_ERROR_FILE_BUSY              = &HC0003B49

'
' MessageId: CRS_ACL_ERROR_INVALID_ACE
'
' MessageText:
'
'  Could not set the ACE %1 on file %2.
'
Const CRS_ACL_ERROR_INVALID_ACE        = &H80003B4A

'
' MessageId: CRS_ACL_ERROR_ACL_FAILED
'
' MessageText:
'
'  Could not set the ACLS appropriately on file %1, setting default ACLs on this file.
'
Const CRS_ACL_ERROR_ACL_FAILED         = &HC0003B4B

'
' MessageId: CRS_ERROR_PROJECT_NOT_FOUND_ON_DESTINATION
'
' MessageText:
'
'  Could not find project %1 on server %2.
'
Const CRS_ERROR_PROJECT_NOT_FOUND_ON_DESTINATION = &HC0003B4C

'
' MessageId: CRS_ERROR_PROJECT_INCOMPLETE_ON_DESTINATION
'
' MessageText:
'
'  Project information for project %1 is incomplete on server %2.
'
Const CRS_ERROR_PROJECT_INCOMPLETE_ON_DESTINATION = &HC0003B4D

'
' MessageId: CRS_ERROR_SERVICE_DOWN_ON_REMOTE_SERVER
'
' MessageText:
'
'  Remote server available, but the Site Server Content Deployment service is not running.
'
Const CRS_ERROR_SERVICE_DOWN_ON_REMOTE_SERVER = &HC0003B4E

'
' MessageId: CRS_ERROR_DISK_FULL_ON_DESTINATION
'
' MessageText:
'
'  Disk is full on the destination server %1.
'
Const CRS_ERROR_DISK_FULL_ON_DESTINATION = &HC0003B4F

'
' MessageId: CRS_FILE_CREATE_ERROR_ON_DESTINATION
'
' MessageText:
'
'  Unable to open a file on the destination server %1.  Check permissions on the project directory and files.
'
Const CRS_FILE_CREATE_ERROR_ON_DESTINATION = &HC0003B50

'
' MessageId: CRS_ERROR_REMOTE_SERVER_NOT_FOUND
'
' MessageText:
'
'  Remote server could not be found.
'
Const CRS_ERROR_REMOTE_SERVER_NOT_FOUND = &HC0003B51

'
' MessageId: CRS_ERROR_REMOTE_APPLY_FAILED
'
' MessageText:
'
'  Unable to apply transactions for project %1 on server %2.
'
Const CRS_ERROR_REMOTE_APPLY_FAILED    = &HC0003B52

'
' MessageId: CRS_ERROR_INVALID_FLAG_COMBINATION
'
' MessageText:
'
'  Invalid flag combination.
'
Const CRS_ERROR_INVALID_FLAG_COMBINATION = &HC0003B53

'
' MessageId: CRS_ERROR_RUNNING_SCRIPT
'
' MessageText:
'
'  Error running the script %1.  Ensure that the script exists and can be located in the path.
'
Const CRS_ERROR_RUNNING_SCRIPT         = &HC0003B54

'
' MessageId: CRS_ERROR_CANT_FORWARD_TO_LOCAL_SERVER
'
' MessageText:
'
'  Cannot forward events to the local server.
'
Const CRS_ERROR_CANT_FORWARD_TO_LOCAL_SERVER = &HC0003B55

'
' MessageId: CRS_ERROR_SCHEDULE_NOT_FOUND
'
' MessageText:
'
'  Specified project schedule could not be found.
'
Const CRS_ERROR_SCHEDULE_NOT_FOUND     = &HC0003B56

'
' MessageId: CRS_ERROR_METABASE
'
' MessageText:
'
'  An error occurred accessing the metabase for the project %1.  Ensure that the web site exists and that the account has access to it.
'
Const CRS_ERROR_METABASE               = &HC0003B57

'
' MessageId: CRS_ERROR_SCHEDULER_FAILURE
'
' MessageText:
'
'  An error occurred with the task scheduler.
'
Const CRS_ERROR_SCHEDULER_FAILURE      = &HC0003B58

'
' MessageId: CRS_SAMEBOX_META_TARGET
'
' MessageText:
'
'  The destination %1 for metabase replication is invalid.
'
Const CRS_SAMEBOX_META_TARGET          = &HC0003B59

'
' MessageId: CRS_ERROR_DROPPED_EVENTS
'
' MessageText:
'
'  The event sink %1 has started dropping events.
'
Const CRS_ERROR_DROPPED_EVENTS         = &HC0003B5A

'
' MessageId: CRS_MSG_REPLICATION_FIRST
'
' MessageText:
'
'  Site Server Content Deployment first replication event message.
'
Const CRS_MSG_REPLICATION_FIRST        = &H40003BC4

'
' MessageId: CRS_MSG_STARTING_REPLICATION
'
' MessageText:
'
'  Project %1 starting to server %2.
'
Const CRS_MSG_STARTING_REPLICATION     = &H40003BC5

'
' MessageId: CRS_MSG_REPLICATION_COMPLETE
'
' MessageText:
'
'  Project %1 complete to server %2.
'
Const CRS_MSG_REPLICATION_COMPLETE     = &H40003BC6

'
' MessageId: CRS_MSG_STARTING_PULL_REPLICATION
'
' MessageText:
'
'  Retrieval project %1 starting from URL %2.
'
Const CRS_MSG_STARTING_PULL_REPLICATION = &H40003BC7

'
' MessageId: CRS_MSG_PULL_REPLICATION_COMPLETE
'
' MessageText:
'
'  Retrieval project %1 complete from URL %2.
'
Const CRS_MSG_PULL_REPLICATION_COMPLETE = &H40003BC8

'
' MessageId: CRS_MSG_STARTING_RECEIVE_REPLICATION
'
' MessageText:
'
'  Starting to receive project %1 from server %2.
'
Const CRS_MSG_STARTING_RECEIVE_REPLICATION = &H40003BC9

'
' MessageId: CRS_MSG_REPLICATION_RECEIVE_COMPLETE
'
' MessageText:
'
'  Finished receiving project %1 from server %2.
'
Const CRS_MSG_REPLICATION_RECEIVE_COMPLETE = &H40003BCA

'
' MessageId: CRS_MSG_STARTING_REPLICATION_SCAN
'
' MessageText:
'
'  Project %1 starting.
'
Const CRS_MSG_STARTING_REPLICATION_SCAN = &H40003BCB

'
' MessageId: CRS_MSG_REPLICATION_LAST
'
' MessageText:
'
'  Site Server Content Deployment last replication event message.
'
Const CRS_MSG_REPLICATION_LAST         = &H40003BF5

'
' MessageId: CRS_MSG_FILE_FIRST
'
' MessageText:
'
'  Site Server Content Deployment first file event message.
'
Const CRS_MSG_FILE_FIRST               = &H40003BF6

'
' MessageId: CRS_MSG_SENDING_FILE
'
' MessageText:
'
'  Sending file %1.
'
Const CRS_MSG_SENDING_FILE             = &H40003BF7

'
' MessageId: CRS_MSG_SENT_FILE
'
' MessageText:
'
'  File %1 sent.
'
Const CRS_MSG_SENT_FILE                = &H40003BF8

'
' MessageId: CRS_MSG_RECEIVING_FILE
'
' MessageText:
'
'  Receiving file %1.
'
Const CRS_MSG_RECEIVING_FILE           = &H40003BF9

'
' MessageId: CRS_MSG_RECEIVED_FILE
'
' MessageText:
'
'  File %1 received.
'
Const CRS_MSG_RECEIVED_FILE            = &H40003BFA

'
' MessageId: CRS_MSG_SENT_DELETE_FILE
'
' MessageText:
'
'  Sent delete file request for file %1.
'
Const CRS_MSG_SENT_DELETE_FILE         = &H40003BFB

'
' MessageId: CRS_MSG_RECEIVED_DELETE_FILE
'
' MessageText:
'
'  File delete request received for file %1.
'
Const CRS_MSG_RECEIVED_DELETE_FILE     = &H40003BFC

'
' MessageId: CRS_MSG_RETRYING_SENDING_FILE
'
' MessageText:
'
'  Trying to resend file %1.
'
Const CRS_MSG_RETRYING_SENDING_FILE    = &H40003C00

'
' MessageId: CRS_MSG_FILE_BUSY
'
' MessageText:
'
'  File %1 is busy.  The service is waiting for the file to become available.
'
Const CRS_MSG_FILE_BUSY                = &H40003C01

'
' MessageId: CRS_MSG_SENDING_ACL
'
' MessageText:
'
'  Sending the ACL for the file %1.
'
Const CRS_MSG_SENDING_ACL              = &H40003C02

'
' MessageId: CRS_MSG_SENT_ACL
'
' MessageText:
'
'  Sent the ACL for the file %1.
'
Const CRS_MSG_SENT_ACL                 = &H40003C03

'
' MessageId: CRS_MSG_RECEIVING_ACL
'
' MessageText:
'
'  Receiving the ACL for the file %1.
'
Const CRS_MSG_RECEIVING_ACL            = &H40003C04

'
' MessageId: CRS_MSG_RECEIVED_ACL
'
' MessageText:
'
'  Received the ACL for the file %1.
'
Const CRS_MSG_RECEIVED_ACL             = &H40003C05

'
' MessageId: CRS_MSG_PULLED_FILE_HTTP
'
' MessageText:
'
'  File %1 retrieved over HTTP.
'
Const CRS_MSG_PULLED_FILE_HTTP         = &H40003C06

'
' MessageId: CRS_MSG_PULLED_FILE_FTP
'
' MessageText:
'
'  File %1 retrieved over FTP.
'
Const CRS_MSG_PULLED_FILE_FTP          = &H40003C07

'
' MessageId: CRS_MSG_FILE_COMMITTED
'
' MessageText:
'
'  File %1 committed to disk.
'
Const CRS_MSG_FILE_COMMITTED           = &H40003C08

'
' MessageId: CRS_MSG_FILE_DELETED
'
' MessageText:
'
'  File %1 deleted.
'
Const CRS_MSG_FILE_DELETED             = &H40003C09

'
' MessageId: CRS_MSG_SKIPPING_LOCKED_FILE
'
' MessageText:
'
'  File %1 skipped because it could not be opened.
'
Const CRS_MSG_SKIPPING_LOCKED_FILE     = &H80003C0A

'
' MessageId: CRS_FILE_MATCHED
'
' MessageText:
'
'  File %1 matched.
'
Const CRS_FILE_MATCHED                 = &H40003C0B

'
' MessageId: CRS_MSG_FILE_LAST
'
' MessageText:
'
'  Site Server Content Deployment last file event message.
'
Const CRS_MSG_FILE_LAST                = &H40003C27

'
' MessageId: CRS_MSG_ADMIN_FIRST
'
' MessageText:
'
'  Site Server Content Deployment first administration event message.
'
Const CRS_MSG_ADMIN_FIRST              = &H40003C28

'
' MessageId: CRS_MSG_PROJECT_CREATED
'
' MessageText:
'
'  Project %1 created.
'
Const CRS_MSG_PROJECT_CREATED          = &H40003C29

'
' MessageId: CRS_MSG_PROJECT_DELETED
'
' MessageText:
'
'  Project %1 deleted.
'
Const CRS_MSG_PROJECT_DELETED          = &H40003C2A

'
' MessageId: CRS_MSG_PROJECT_EDITED
'
' MessageText:
'
'  Project %1 edited.
'
Const CRS_MSG_PROJECT_EDITED           = &H40003C2B

'
' MessageId: CRS_MSG_ROUTE_CREATED
'
' MessageText:
'
'  Route %1 created.
'
Const CRS_MSG_ROUTE_CREATED            = &H40003C2C

'
' MessageId: CRS_MSG_ROUTE_DELETED
'
' MessageText:
'
'  Route %1 deleted.
'
Const CRS_MSG_ROUTE_DELETED            = &H40003C2D

'
' MessageId: CRS_MSG_ROUTE_EDITED
'
' MessageText:
'
'  Route %1 edited.
'
Const CRS_MSG_ROUTE_EDITED             = &H40003C2E

'
' MessageId: CRS_MSG_SERVER_EDITED
'
' MessageText:
'
'  Server settings modified.
'
Const CRS_MSG_SERVER_EDITED            = &H40003C2F

'
' MessageId: CRS_MSG_EVENTSINK_CREATED
'
' MessageText:
'
'  Event sink %1 was added.
'
Const CRS_MSG_EVENTSINK_CREATED        = &H40003C30

'
' MessageId: CRS_MSG_EVENTSINK_DELETED
'
' MessageText:
'
'  Event sink %1 was deleted.
'
Const CRS_MSG_EVENTSINK_DELETED        = &H40003C31

'
' MessageId: CRS_MSG_CLEARED_EVENTS
'
' MessageText:
'
'  Event store %1 was cleared.
'
Const CRS_MSG_CLEARED_EVENTS           = &H40003C32

'
' MessageId: CRS_MSG_CLEARED_ALL_EVENTS
'
' MessageText:
'
'  Each database event store on this server was cleared.
'
Const CRS_MSG_CLEARED_ALL_EVENTS       = &H40003C33

'
' MessageId: CRS_MSG_ADMIN_LAST
'
' MessageText:
'
'  Site Server Content Deployment last administration event message.
'
Const CRS_MSG_ADMIN_LAST               = &H40003C5A

'
' MessageId: CRS_MSG_SUMMARY_FIRST
'
' MessageText:
'
'  Site Server Content Deployment first summary event message.
'
Const CRS_MSG_SUMMARY_FIRST            = &H40003C8C

'
' MessageId: CRS_MSG_SUMMARY_RECEIVE
'
' MessageText:
'
'  Project summary information (files received).
'
Const CRS_MSG_SUMMARY_RECEIVE          = &H40003C8D

'
' MessageId: CRS_MSG_SUMMARY_SEND
'
' MessageText:
'
'  Project summary information (files sent).
'
Const CRS_MSG_SUMMARY_SEND             = &H40003C8E

'
' MessageId: CRS_MSG_SUMMARY_PULL
'
' MessageText:
'
'  Project summary information (files pulled).
'
Const CRS_MSG_SUMMARY_PULL             = &H40003C8F

'
' MessageId: CRS_MSG_SUMMARY_AUTOMATIC_RECEIVE
'
' MessageText:
'
'  Automatic project (receive) checkpoint summary information.
'
Const CRS_MSG_SUMMARY_AUTOMATIC_RECEIVE = &H40003C90

'
' MessageId: CRS_MSG_SUMMARY_AUTOMATIC_SEND
'
' MessageText:
'
'  Automatic project (send) checkpoint summary information.
'
Const CRS_MSG_SUMMARY_AUTOMATIC_SEND   = &H40003C91

'
' MessageId: CRS_MSG_SUMMARY_RECEIVE_MATCHED
'
' MessageText:
'
'  Project summary information (files matched during receive).
'
Const CRS_MSG_SUMMARY_RECEIVE_MATCHED  = &H40003C92

'
' MessageId: CRS_MSG_SUMMARY_SEND_MATCHED
'
' MessageText:
'
'  Project summary information (files matched during send).
'
Const CRS_MSG_SUMMARY_SEND_MATCHED     = &H40003C93

'
' MessageId: CRS_MSG_SUMMARY_PULL_MATCHED
'
' MessageText:
'
'  Project summary information (files matched during pull).
'
Const CRS_MSG_SUMMARY_PULL_MATCHED     = &H40003C94

'
' MessageId: CRS_MSG_SUMMARY_RECEIVE_ERRORED
'
' MessageText:
'
'  Project summary information (files errored during receive).
'
Const CRS_MSG_SUMMARY_RECEIVE_ERRORED  = &H40003C95

'
' MessageId: CRS_MSG_SUMMARY_SEND_ERRORED
'
' MessageText:
'
'  Project summary information (files errored during send).
'
Const CRS_MSG_SUMMARY_SEND_ERRORED     = &H40003C96

'
' MessageId: CRS_MSG_SUMMARY_PULL_ERRORED
'
' MessageText:
'
'  Project summary information (files errored during pull).
'
Const CRS_MSG_SUMMARY_PULL_ERRORED     = &H40003C97

'
' MessageId: CRS_MSG_SUMMARY_LAST
'
' MessageText:
'
'  Site Server Content Deployment last summary event message.
'
Const CRS_MSG_SUMMARY_LAST             = &H40003CBE

'
' MessageId: CRS_CAB_ERROR_FIRST
'
' MessageText:
'
'  Remote installer first error message.
'
Const CRS_CAB_ERROR_FIRST              = &HC0003CF0

'
' MessageId: CRS_CAB_ERROR_CABINET_NOT_FOUND
'
' MessageText:
'
'  Cannot find the specified cabinet file.
'
Const CRS_CAB_ERROR_CABINET_NOT_FOUND  = &HC0003CF1

'
' MessageId: CRS_CAB_ERROR_NOT_A_CABINET
'
' MessageText:
'
'  Specified file is not a valid cabinet file.
'
Const CRS_CAB_ERROR_NOT_A_CABINET      = &HC0003CF2

'
' MessageId: CRS_CAB_ERROR_UNKNOWN_CABINET_VERSION
'
' MessageText:
'
'  Specified file is an unknown version of a cabinet file.
'
Const CRS_CAB_ERROR_UNKNOWN_CABINET_VERSION = &HC0003CF3

'
' MessageId: CRS_CAB_ERROR_CORRUPT_CABINET
'
' MessageText:
'
'  Specified cabinet file is corrupt.
'
Const CRS_CAB_ERROR_CORRUPT_CABINET    = &HC0003CF4

'
' MessageId: CRS_CAB_ERROR_ALLOC_FAIL
'
' MessageText:
'
'  Out of memory.
'
Const CRS_CAB_ERROR_ALLOC_FAIL         = &HC0003CF5

'
' MessageId: CRS_CAB_ERROR_BAD_COMPR_TYPE
'
' MessageText:
'
'  Specified cabinet file uses an unknown compression type.
'
Const CRS_CAB_ERROR_BAD_COMPR_TYPE     = &HC0003CF6

'
' MessageId: CRS_CAB_ERROR_MDI_FAIL
'
' MessageText:
'
'  Compressed data in the specified cabinet file is corrupt.
'
Const CRS_CAB_ERROR_MDI_FAIL           = &HC0003CF7

'
' MessageId: CRS_CAB_ERROR_TARGET_FILE
'
' MessageText:
'
'  Could not save extracted files from the specified cabinet file.
'
Const CRS_CAB_ERROR_TARGET_FILE        = &HC0003CF8

'
' MessageId: CRS_CAB_ERROR_RESERVE_MISMATCH
'
' MessageText:
'
'  Specified cabinet file has a non-valid RESERVE size.
'
Const CRS_CAB_ERROR_RESERVE_MISMATCH   = &HC0003CF9

'
' MessageId: CRS_CAB_ERROR_WRONG_CABINET
'
' MessageText:
'
'  Specified cabinet file is not the right cabinet in the set.
'
Const CRS_CAB_ERROR_WRONG_CABINET      = &HC0003CFA

'
' MessageId: CRS_CAB_ERROR_USER_ABORT
'
' MessageText:
'
'  Could not extract the specified cabinet file - user aborted the operation.
'
Const CRS_CAB_ERROR_USER_ABORT         = &HC0003CFB

'
' MessageId: CRS_CAB_WARNING_CAB_NOT_SIGNED
'
' MessageText:
'
'  Specified cabinet file is not a signed cabinet file.
'
Const CRS_CAB_WARNING_CAB_NOT_SIGNED   = &H80003CFC

'
' MessageId: CRS_CAB_WARNING_SIGNATURE_NOT_VERIFIED
'
' MessageText:
'
'  Signature on the specified cabinet could not be verified.
'
Const CRS_CAB_WARNING_SIGNATURE_NOT_VERIFIED = &H80003CFD

'
' MessageId: CRS_CAB_ERROR_INFFILE_NOT_FOUND
'
' MessageText:
'
'  INF file was not found inside the specified cabinet file.
'
Const CRS_CAB_ERROR_INFFILE_NOT_FOUND  = &HC0003CFE

'
' MessageId: CRS_INF_ERROR_ADVPACK_NOT_LOADED
'
' MessageText:
'
'  Could not load ADVPACK.DLL.
'
Const CRS_INF_ERROR_ADVPACK_NOT_LOADED = &HC0003CFF

'
' MessageId: CRS_INF_ERROR_ADVPACK_WRONG_VERSION
'
' MessageText:
'
'  This version of ADVPACK.DLL is not supported.
'
Const CRS_INF_ERROR_ADVPACK_WRONG_VERSION = &HC0003D00

'
' MessageId: CRS_INF_ERROR_INVALID_INF
'
' MessageText:
'
'  INF file found inside the specified cabinet file is not a valid INF file.
'
Const CRS_INF_ERROR_INVALID_INF        = &HC0003D01

'
' MessageId: CRS_INF_ERROR_NOTHING_TO_INSTALL
'
' MessageText:
'
'  Could not find any of the remote install sections inside the INF file.
'
Const CRS_INF_ERROR_NOTHING_TO_INSTALL = &HC0003D02

'
' MessageId: CRS_INF_ERROR_NOTHING_TO_UNINSTALL
'
' MessageText:
'
'  Could not find any of the remote uninstall sections inside the INF file.
'
Const CRS_INF_ERROR_NOTHING_TO_UNINSTALL = &HC0003D03

'
' MessageId: CRS_INF_ERROR_BUSY_FILES
'
' MessageText:
'
'  Files are busy.  Cannot install them unless allowed to do a REBOOT.
'
Const CRS_INF_ERROR_BUSY_FILES         = &HC0003D04

'
' MessageId: CRS_CAB_WARNING_MANUAL_REBOOT
'
' MessageText:
'
'  Setup completed successfully, but the server could not be rebooted automatically. Manual reboot is necessary.
'
Const CRS_CAB_WARNING_MANUAL_REBOOT    = &H80003D05

'
' MessageId: CRS_CAB_WARNING_REBOOT_NEEDED
'
' MessageText:
'
'  Setup completed successfully, but the files became busy during setup.  Manual reboot is necessary.
'
Const CRS_CAB_WARNING_REBOOT_NEEDED    = &H80003D06

'
' MessageId: CRS_INF_SUCCESS_REBOOT_IN_PROGRESS
'
' MessageText:
'
'  Setup completed successfully. The server is being rebooted.
'
Const CRS_INF_SUCCESS_REBOOT_IN_PROGRESS = &H00003D07

'
' MessageId: CRS_INF_SUCCESS
'
' MessageText:
'
'  Setup completed successfully.
'
Const CRS_INF_SUCCESS                  = &H00003D09

'
' MessageId: CRS_INF_ERROR_BUSY_FILES_UNINSTALL
'
' MessageText:
'
'  Files are busy.  Cannot uninstall files unless allowed to reboot.
'
Const CRS_INF_ERROR_BUSY_FILES_UNINSTALL = &HC0003D0A

'
' MessageId: CRS_CAB_WARNING_MANUAL_REBOOT_UNINSTALL
'
' MessageText:
'
'  Uninstall completed successfully, but the server could not be rebooted automatically. Manual reboot is necessary.
'
Const CRS_CAB_WARNING_MANUAL_REBOOT_UNINSTALL = &H80003D0B

'
' MessageId: CRS_CAB_WARNING_REBOOT_NEEDED_UNINSTALL
'
' MessageText:
'
'  Uninstall completed successfully, but the files became busy during setup.  Manual reboot is necessary.
'
Const CRS_CAB_WARNING_REBOOT_NEEDED_UNINSTALL = &H80003D0C

'
' MessageId: CRS_INF_SUCCESS_REBOOT_IN_PROGRESS_UNINSTALL
'
' MessageText:
'
'  Uninstall completed successfully. The server is being rebooted.
'
Const CRS_INF_SUCCESS_REBOOT_IN_PROGRESS_UNINSTALL = &H00003D0D

'
' MessageId: CRS_INF_SUCCESS_UNINSTALL
'
' MessageText:
'
'  Uninstall completed successfully.
'
Const CRS_INF_SUCCESS_UNINSTALL        = &H00003D0E

'
' MessageId: CRS_CAB_ERROR_ADVPACK_FAILED
'
' MessageText:
'
'  Problem installing the CAB. Check CAB and INF files for validity. 
'
Const CRS_CAB_ERROR_ADVPACK_FAILED     = &HC0003D0F

'
' MessageId: CRS_CAB_ERROR_LOCKED_FILES
'
' MessageText:
'
'  At least one of the files inside the CAB is open for exclusive write/delete access.
'
Const CRS_CAB_ERROR_LOCKED_FILES       = &HC0003D10

'
' MessageId: CRS_CAB_ERROR_UNKNOWN
'
' MessageText:
'
'  An unknown error occurred while processing the specified cabinet file.
'
Const CRS_CAB_ERROR_UNKNOWN            = &HC0003DEE

'
' MessageId: CRS_CAB_ERROR_LAST
'
' MessageText:
'
'  Remote installer last error message.
'
Const CRS_CAB_ERROR_LAST               = &H40003DEF

'
' MessageId: CRS_ERROR_LAST
'
' MessageText:
'
'  Site Server Content Deployment service last error message.
'
Const CRS_ERROR_LAST                   = &H40003E7F

'
' MessageId: CRS_EVENT_FIRST
'
' MessageText:
'
'  Site Server Content Deployment Service first event message.
'
Const CRS_EVENT_FIRST                  = &H400036B0

'
' MessageId: CRS_EVENT_NET_SOURCE
'
' MessageText:
'
'  Source directory is on a network drive.  Cannot deploy from network drives.
'
Const CRS_EVENT_NET_SOURCE             = &HC00036B4

'
' MessageId: CRS_EVENT_ERROR_ACCESS_DENIED
'
' MessageText:
'
'  Access denied.
'
Const CRS_EVENT_ERROR_ACCESS_DENIED    = &HC00036B5

'
' MessageId: CRS_EVENT_FILE_CREATE_ERROR
'
' MessageText:
'
'  Unable to open the file.
'
Const CRS_EVENT_FILE_CREATE_ERROR      = &HC00036B6

'
' MessageId: CRS_EVENT_SENDINET_ERROR
'
' MessageText:
'
'  Project was unable to send the file.
'
Const CRS_EVENT_SENDINET_ERROR         = &HC00036B7

'
' MessageId: CRS_EVENT_SAMEBOX_NET_TARGET
'
' MessageText:
'
'  Destination directory is on a network drive.  Cannot deploy to network drives.
'
Const CRS_EVENT_SAMEBOX_NET_TARGET     = &HC00036B8

'
' MessageId: CRS_EVENT_BAD_SOURCE
'
' MessageText:
'
'  Unable to access the project source.
'
Const CRS_EVENT_BAD_SOURCE             = &HC00036B9

'
' MessageId: CRS_EVENT_SENDINET_CONNECT
'
' MessageText:
'
'  Unable to connect to the remote server.
'
Const CRS_EVENT_SENDINET_CONNECT       = &HC00036BA

'
' MessageId: CRS_EVENT_HASH_MISMATCH
'
' MessageText:
'
'  MD5 Hash did not match during a transmission.  This could indicate transmission failure or that the files transmitted at the source have been modified in transit.
'
Const CRS_EVENT_HASH_MISMATCH          = &HC00036BB

'
' MessageId: CRS_EVENT_SERVER_ABORTED
'
' MessageText:
'
'  Remote server was restarted.  The project is being restarted.
'
Const CRS_EVENT_SERVER_ABORTED         = &HC00036BC

'
' MessageId: CRS_EVENT_REPLICATION_ABORTED
'
' MessageText:
'
'  Project was aborted.
'
Const CRS_EVENT_REPLICATION_ABORTED    = &HC00036BD

'
' MessageId: CRS_EVENT_SEQUENCE_ERROR
'
' MessageText:
'
'  Internal messaging sequence error occurred.
'
Const CRS_EVENT_SEQUENCE_ERROR         = &HC00036BE

'
' MessageId: CRS_EVENT_SERVICE_STARTED
'
' MessageText:
'
'  Site Server Content Deployment service started successfully.
'
Const CRS_EVENT_SERVICE_STARTED        = &H400036BF

'
' MessageId: CRS_EVENT_SERVICE_SHUTDOWN
'
' MessageText:
'
'  Site Server Content Deployment service shut down successfully.
'
Const CRS_EVENT_SERVICE_SHUTDOWN       = &H400036C0

'
' MessageId: CRS_EVENT_METABASE_ACCESS
'
' MessageText:
'
'  Could not open given storage/stream.  Ensure the authentication account has access to this storage/stream.
'
Const CRS_EVENT_METABASE_ACCESS        = &HC00036C2

'
' MessageId: CRS_EVENT_AUTH_FAILURE
'
' MessageText:
'
'  Authorization failure against the destination server.  Ensure the service has access to this server.
'
Const CRS_EVENT_AUTH_FAILURE           = &HC00036C3

'
' MessageId: CRS_EVENT_REMOTE_AUTH_FAILURE
'
' MessageText:
'
'  Remote authorization failed to the destination server.  Ensure the service has access to this server.
'
Const CRS_EVENT_REMOTE_AUTH_FAILURE    = &HC00036C4

'
' MessageId: CRS_EVENT_ERROR_NOT_IN_ORDER
'
' MessageText:
'
'  Message was received out of order.  Closing connection.
'
Const CRS_EVENT_ERROR_NOT_IN_ORDER     = &HC00036C5

'
' MessageId: CRS_EVENT_CONNECTION_RETRY_FAILED
'
' MessageText:
'
'  Connection failed and could not be re-established.
'
Const CRS_EVENT_CONNECTION_RETRY_FAILED = &HC00036C6

'
' MessageId: CRS_EVENT_REPLICATION_CANCELED
'
' MessageText:
'
'  Project canceled at the request of the user.
'
Const CRS_EVENT_REPLICATION_CANCELED   = &HC00036C7

'
' MessageId: CRS_EVENT_ERROR_DEST_TOOBIG
'
' MessageText:
'
'  Could not add the specified destination(s).  The maximum number of destinations has been reached.
'
Const CRS_EVENT_ERROR_DEST_TOOBIG      = &HC00036C8

'
' MessageId: CRS_EVENT_ERROR_NO_IP_MAPPING
'
' MessageText:
'
'  Cannot resolve IP address for the destination server.  No virtual directory created.
'
Const CRS_EVENT_ERROR_NO_IP_MAPPING    = &HC00036C9

'
' MessageId: CRS_EVENT_ERROR_DISK_FULL
'
' MessageText:
'
'  Not enough space on the disk.
'
Const CRS_EVENT_ERROR_DISK_FULL        = &HC00036CA

'
' MessageId: CRS_EVENT_ERROR_TOO_MANY_RUNNING
'
' MessageText:
'
'  Too many active projects. No more can be started until others complete.
'
Const CRS_EVENT_ERROR_TOO_MANY_RUNNING = &HC00036CB

'
' MessageId: CRS_EVENT_ERROR_WOULDBLOCK
'
' MessageText:
'
'  The network operation would block.
'
Const CRS_EVENT_ERROR_WOULDBLOCK       = &H000036D3

'
' MessageId: CRS_EVENT_ERROR_NETDOWN
'
' MessageText:
'
'  The remote network is down.
'
Const CRS_EVENT_ERROR_NETDOWN          = &HC00036E2

'
' MessageId: CRS_EVENT_ERROR_NETUNREACH
'
' MessageText:
'
'  The remote network is unreachable.
'
Const CRS_EVENT_ERROR_NETUNREACH       = &HC00036E3

'
' MessageId: CRS_EVENT_ERROR_CONNABORTED
'
' MessageText:
'
'  The network connection was aborted at the network layer.
'
Const CRS_EVENT_ERROR_CONNABORTED      = &HC00036E5

'
' MessageId: CRS_EVENT_ERROR_TIMEOUT
'
' MessageText:
'
'  The network session timed out on a send or receive operation.
'
Const CRS_EVENT_ERROR_TIMEOUT          = &HC00036EC

'
' MessageId: CRS_EVENT_ERROR_NO_PROJECTS
'
' MessageText:
'
'  No projects defined.
'
Const CRS_EVENT_ERROR_NO_PROJECTS      = &HC0003714

'
' MessageId: CRS_EVENT_ERROR_PROJECT_NOT_FOUND
'
' MessageText:
'
'  Could not find the project.
'
Const CRS_EVENT_ERROR_PROJECT_NOT_FOUND = &HC0003715

'
' MessageId: CRS_EVENT_ERROR_INVALID_PARAMETER
'
' MessageText:
'
'  Invalid parameter.
'
Const CRS_EVENT_ERROR_INVALID_PARAMETER = &HC0003716

'
' MessageId: CRS_EVENT_ERROR_AUTHENTICATION_FAILURE
'
' MessageText:
'
'  Authentication failure. Ensure the account has proper access on local and remote servers.
'
Const CRS_EVENT_ERROR_AUTHENTICATION_FAILURE = &HC0003718

'
' MessageId: CRS_EVENT_ERROR_DELETE_PROJECT_DOWN_ROUTE
'
' MessageText:
'
'  Could not delete the route from the project on at least one machine down the defined routes.  The project will have to be edited manually there.
'
Const CRS_EVENT_ERROR_DELETE_PROJECT_DOWN_ROUTE = &H80003719

'
' MessageId: CRS_EVENT_ERROR_SERVICE_NOT_RUNNING
'
' MessageText:
'
'  Server is available, but the Site Server Content Deployment service is not running.
'
Const CRS_EVENT_ERROR_SERVICE_NOT_RUNNING = &HC000371A

'
' MessageId: CRS_EVENT_ERROR_HOST_DOWN
'
' MessageText:
'
'  Server is unavailable.
'
Const CRS_EVENT_ERROR_HOST_DOWN        = &HC000371B

'
' MessageId: CRS_EVENT_ERROR_BAD_NET_NAME
'
' MessageText:
'
'  Server cannot be found.
'
Const CRS_EVENT_ERROR_BAD_NET_NAME     = &HC000371C

'
' MessageId: CRS_EVENT_ERROR_ROUTE_NOT_FOUND
'
' MessageText:
'
'  Could not find route.  Ensure the route name is correct and that it exists on the target servers.
'
Const CRS_EVENT_ERROR_ROUTE_NOT_FOUND  = &HC000371D

'
' MessageId: CRS_EVENT_ERROR_NO_ROUTES
'
' MessageText:
'
'  No routes defined.
'
Const CRS_EVENT_ERROR_NO_ROUTES        = &HC000371E

'
' MessageId: CRS_EVENT_ERROR_CREATE_PROJECT_DOWN_ROUTE
'
' MessageText:
'
'  Could not create the project on at least one server down the defined routes.  The project will have to be created manually there.
'
Const CRS_EVENT_ERROR_CREATE_PROJECT_DOWN_ROUTE = &H8000371F

'
' MessageId: CRS_EVENT_ERROR_SERVICE_PAUSED
'
' MessageText:
'
'  Site Server Content Deployment service on the destination server is paused and is not accepting new requests.  Retry the project later.
'
Const CRS_EVENT_ERROR_SERVICE_PAUSED   = &HC0003720

'
' MessageId: CRS_EVENT_ERROR_SERVICE_NOT_PAUSED
'
' MessageText:
'
'  Could not restart service. Service is not paused.
'
Const CRS_EVENT_ERROR_SERVICE_NOT_PAUSED = &HC0003721

'
' MessageId: CRS_EVENT_ERROR_NAME_NOT_RESOLVED
'
' MessageText:
'
'  Could not resolve the URL.  Ensure URL and/or proxy settings are correct.
'
Const CRS_EVENT_ERROR_NAME_NOT_RESOLVED = &HC0003722

'
' MessageId: CRS_EVENT_ERROR_CONNECTION_RESET
'
' MessageText:
'
'  Connection to the destination server has been reset.  This indicates problems with the remote service or network.
'
Const CRS_EVENT_ERROR_CONNECTION_RESET = &HC0003723

'
' MessageId: CRS_EVENT_ERROR_REPLICATION_NOT_FOUND
'
' MessageText:
'
'  No entries.
'
Const CRS_EVENT_ERROR_REPLICATION_NOT_FOUND = &HC0003724

'
' MessageId: CRS_EVENT_ERROR_SERVICE_ALREADY_RUNNING
'
' MessageText:
'
'  Could not start service.  The service has already been started.
'
Const CRS_EVENT_ERROR_SERVICE_ALREADY_RUNNING = &HC0003725

'
' MessageId: CRS_EVENT_ERROR_PROJECT_ALREADY_RUNNING
'
' MessageText:
'
'  Failed to start project.  It is already running.
'
Const CRS_EVENT_ERROR_PROJECT_ALREADY_RUNNING = &HC0003726

'
' MessageId: CRS_EVENT_FILE_MOVE_ERROR
'
' MessageText:
'
'  Failed to move file.
'
Const CRS_EVENT_FILE_MOVE_ERROR        = &HC0003727

'
' MessageId: CRS_EVENT_PRODUCT_EXPIRED
'
' MessageText:
'
'  Thank you for your interest in Site Server Content Deployment.  This software has expired.  Please acquire the final retail version of this software.
'
Const CRS_EVENT_PRODUCT_EXPIRED        = &HC0003728

'
' MessageId: CRS_EVENT_ERROR_PROJECT_INCOMPLETE
'
' MessageText:
'
'  Project information is incomplete.
'
Const CRS_EVENT_ERROR_PROJECT_INCOMPLETE = &HC0003729

'
' MessageId: CRS_EVENT_ERROR_PARAMETER_NOT_FOUND
'
' MessageText:
'
'  Parameter not found.
'
Const CRS_EVENT_ERROR_PARAMETER_NOT_FOUND = &HC000372A

'
' MessageId: CRS_EVENT_ERROR_REPLICATION_RUNNING
'
' MessageText:
'
'  Project is running.  The operation could not be completed.
'
Const CRS_EVENT_ERROR_REPLICATION_RUNNING = &HC000372B

'
' MessageId: CRS_EVENT_ERROR_INVALID_PROJECT_NAME
'
' MessageText:
'
'  Project name is invalid.  Project names cannot contain backslashes and cannot be empty.
'
Const CRS_EVENT_ERROR_INVALID_PROJECT_NAME = &HC000372C

'
' MessageId: CRS_EVENT_ERROR_INVALID_ROUTE_NAME
'
' MessageText:
'
'  Route name is invalid.  Route names cannot contain backslashes or DBCS characters and cannot be empty.
'
Const CRS_EVENT_ERROR_INVALID_ROUTE_NAME = &HC000372D

'
' MessageId: CRS_EVENT_ERROR_INVALID_DWORD
'
' MessageText:
'
'  Parameter must be a positive integer.
'
Const CRS_EVENT_ERROR_INVALID_DWORD    = &HC000372E

'
' MessageId: CRS_EVENT_ERROR_NO_MORE_ITEMS
'
' MessageText:
'
'  No more items are in the list.
'
Const CRS_EVENT_ERROR_NO_MORE_ITEMS    = &H8000372F

'
' MessageId: CRS_EVENT_ERROR_TOO_MANY_ARGS
'
' MessageText:
'
'  Too many arguments specified.
'
Const CRS_EVENT_ERROR_TOO_MANY_ARGS    = &HC0003730

'
' MessageId: CRS_EVENT_MBS_INIT_ERROR
'
' MessageText:
'
'  Internal error trying to initialize for ACL replication.
'
Const CRS_EVENT_MBS_INIT_ERROR         = &HC0003731

'
' MessageId: CRS_EVENT_ERROR_OPENING_FILE
'
' MessageText:
'
'  Error opening file or file not found.
'
Const CRS_EVENT_ERROR_OPENING_FILE     = &HC0003733

'
' MessageId: CRS_EVENT_ERROR_FILE_FORMAT
'
' MessageText:
'
'  Invalid file format.
'
Const CRS_EVENT_ERROR_FILE_FORMAT      = &HC0003734

'
' MessageId: CRS_EVENT_ERROR_FILE_WRITE
'
' MessageText:
'
'  Error writing to file.
'
Const CRS_EVENT_ERROR_FILE_WRITE       = &HC0003735

'
' MessageId: CRS_EVENT_WINSOCK_WSAHOSTNAME
'
' MessageText:
'
'  Gethostname failed.
'
Const CRS_EVENT_WINSOCK_WSAHOSTNAME    = &HC0003736

'
' MessageId: CRS_EVENT_ERROR_INVALID_CONTEXT
'
' MessageText:
'
'  Current context is invalid.  Project being reset.
'
Const CRS_EVENT_ERROR_INVALID_CONTEXT  = &HC000373D

'
' MessageId: CRS_EVENT_ERROR_DOWNLEVEL_SERVER
'
' MessageText:
'
'  Operation is not supported on a down-level server.
'
Const CRS_EVENT_ERROR_DOWNLEVEL_SERVER = &HC000373E

'
' MessageId: CRS_EVENT_ERROR_NO_MAPPING
'
' MessageText:
'
'  URL does not map to any project definitions.
'
Const CRS_EVENT_ERROR_NO_MAPPING       = &HC000373F

'
' MessageId: CRS_EVENT_ERROR_START_PENDING
'
' MessageText:
'
'  Start pending completion of the active project.
'
Const CRS_EVENT_ERROR_START_PENDING    = &HC0003740

'
' MessageId: CRS_EVENT_ERROR_NO_EVENTSINKS
'
' MessageText:
'
'  No event sinks defined.
'
Const CRS_EVENT_ERROR_NO_EVENTSINKS    = &HC0003741

'
' MessageId: CRS_EVENT_ERROR_EVENTSINK_NOT_FOUND
'
' MessageText:
'
'  Could not find event sink.
'
Const CRS_EVENT_ERROR_EVENTSINK_NOT_FOUND = &HC0003742

'
' MessageId: CRS_EVENT_ERROR_WSAHOSTNOTFOUND
'
' MessageText:
'
'  Host not found.
'
Const CRS_EVENT_ERROR_WSAHOSTNOTFOUND  = &HC0003743

'
' MessageId: CRS_EVENT_ERROR_WSATRYAGAIN
'
' MessageText:
'
'  Host not found, or SERVERFAIL.  Try again.
'
Const CRS_EVENT_ERROR_WSATRYAGAIN      = &HC0003744

'
' MessageId: CRS_EVENT_ERROR_WSANORECOVERY
'
' MessageText:
'
'  Non-recoverable winsock error.
'
Const CRS_EVENT_ERROR_WSANORECOVERY    = &HC0003745

'
' MessageId: CRS_EVENT_ERROR_WSANODATA
'
' MessageText:
'
'  Invalid address.
'
Const CRS_EVENT_ERROR_WSANODATA        = &HC0003746

'
' MessageId: CRS_EVENT_EVENTSINK_INITIALIZED
'
' MessageText:
'
'  Event sink specified by the data field was successfully initialized.
'
Const CRS_EVENT_EVENTSINK_INITIALIZED  = &H00003747

'
' MessageId: CRS_EVENT_ERROR_EVENTSINK_NOT_INITIALIZED
'
' MessageText:
'
'  Event sink specified by the data field failed to initialize.
'
Const CRS_EVENT_ERROR_EVENTSINK_NOT_INITIALIZED = &HC0003748

'
' MessageId: CRS_EVENT_ERROR_NOTHING_TO_ROLLBACK
'
' MessageText:
'
'  Could not roll back project.  No rollback information found.
'
Const CRS_EVENT_ERROR_NOTHING_TO_ROLLBACK = &HC0003749

'
' MessageId: CRS_EVENT_ERROR_NO_DESTINATIONS
'
' MessageText:
'
'  Project could not be started because no destinations are defined.
'
Const CRS_EVENT_ERROR_NO_DESTINATIONS  = &HC000374A

'
' MessageId: CRS_EVENT_ERROR_REAUTHENTICATE
'
' MessageText:
'
'  Re-authenticate using an acceptable protocol.
'
Const CRS_EVENT_ERROR_REAUTHENTICATE   = &HC000374B

'
' MessageId: CRS_EVENT_ERROR_UNSUPPORTED
'
' MessageText:
'
'  Function not supported in this version to this server.
'
Const CRS_EVENT_ERROR_UNSUPPORTED      = &HC000374C

'
' MessageId: CRS_EVENT_ERROR_USER_NOT_FOUND
'
' MessageText:
'
'  Specified user could not be found.
'
Const CRS_EVENT_ERROR_USER_NOT_FOUND   = &HC000374D

'
' MessageId: CRS_EVENT_ERROR_NO_TRANSACTIONS
'
' MessageText:
'
'  No transactions for the specified project.
'
Const CRS_EVENT_ERROR_NO_TRANSACTIONS  = &HC000374E

'
' MessageId: CRS_EVENT_ERROR_NO_SERVERS
'
' MessageText:
'
'  No destination servers defined.
'
Const CRS_EVENT_ERROR_NO_SERVERS       = &HC000374F

'
' MessageId: CRS_EVENT_ERROR_NO_SCHEDULES
'
' MessageText:
'
'  No schedules are defined for this project.
'
Const CRS_EVENT_ERROR_NO_SCHEDULES     = &HC0003750

'
' MessageId: CRS_EVENT_ERROR_NO_EMAIL
'
' MessageText:
'
'  Could not contact SMTP server to send e-mail report.
'
Const CRS_EVENT_ERROR_NO_EMAIL         = &HC0003751

'
' MessageId: CRS_EVENT_ERROR_WAIT_ABORT
'
' MessageText:
'
'  Waiting to abort after losing connection with source server.
'
Const CRS_EVENT_ERROR_WAIT_ABORT       = &HC0003752

'
' MessageId: CRS_EVENT_RESUME_REPLICATION
'
' MessageText:
'
'  Resuming project.
'
Const CRS_EVENT_RESUME_REPLICATION     = &H40003753

'
' MessageId: CRS_EVENT_METABASE_NOT_FOUND
'
' MessageText:
'
'  Metabase is not responding.
'
Const CRS_EVENT_METABASE_NOT_FOUND     = &HC0003754

'
' MessageId: CRS_EVENT_SSE_VROOT_NOT_FOUND
'
' MessageText:
'
'  Site Server virtual directory not found.
'
Const CRS_EVENT_SSE_VROOT_NOT_FOUND    = &HC0003755

'
' MessageId: CRS_EVENT_WARNING_CONNECTION_FAILED
'
' MessageText:
'
'  Connection failed.  Will attempt to re-establish session.
'
Const CRS_EVENT_WARNING_CONNECTION_FAILED = &H80003756

'
' MessageId: CRS_EVENT_ERROR_DROPPED_EMAIL_REPORT
'
' MessageText:
'
'  Dropped e-mail report.
'
Const CRS_EVENT_ERROR_DROPPED_EMAIL_REPORT = &HC0003757

'
' MessageId: CRS_EVENT_ERROR_EMAIL_HOST_NOT_DEFINED
'
' MessageText:
'
'  No SMTP server defined.
'
Const CRS_EVENT_ERROR_EMAIL_HOST_NOT_DEFINED = &HC0003758

'
' MessageId: CRS_EVENT_VROOT_CREATION
'
' MessageText:
'
'  Could not create the specified virtual directory.
'
Const CRS_EVENT_VROOT_CREATION         = &H80003759

'
' MessageId: CRS_EVENT_UPLPAGE_CREATION
'
' MessageText:
'
'  Could not create the upload page.
'
Const CRS_EVENT_UPLPAGE_CREATION       = &HC000375A

'
' MessageId: CRS_EVENT_ERROR_CIRCULAR_ROUTE
'
' MessageText:
'
'  System has detected a circular route.  Project not created.
'
Const CRS_EVENT_ERROR_CIRCULAR_ROUTE   = &HC000375B

'
' MessageId: CRS_EVENT_ERROR_TRANSACTION_APPLY_FAILED
'
' MessageText:
'
'  Transaction application failed.  Check permissions on the destination directory and files and ensure that no files are locked open.
'
Const CRS_EVENT_ERROR_TRANSACTION_APPLY_FAILED = &HC000375C

'
' MessageId: CRS_EVENT_ERROR_DATABASE
'
' MessageText:
'
'  Database error occurred.
'
Const CRS_EVENT_ERROR_DATABASE         = &HC000375D

'
' MessageId: CRS_EVENT_ERROR_SINK_CONNECT_FAILED
'
' MessageText:
'
'  Unable to connect to remote server to forward events.
'
Const CRS_EVENT_ERROR_SINK_CONNECT_FAILED = &HC000375E

'
' MessageId: CRS_EVENT_ERROR_CANT_SEND_EVENTS_TO_DOWNLEVEL_SERVER
'
' MessageText:
'
'  Unable to send events to the destination server.  This operation is not supported.
'
Const CRS_EVENT_ERROR_CANT_SEND_EVENTS_TO_DOWNLEVEL_SERVER = &HC000375F

'
' MessageId: CRS_EVENT_ERROR_FILE_CORRUPT
'
' MessageText:
'
'  File is corrupt or unreadable.
'
Const CRS_EVENT_ERROR_FILE_CORRUPT     = &HC0003760

'
' MessageId: CRS_EVENT_ERROR_FILE_BUSY
'
' MessageText:
'
'  File is busy.
'
Const CRS_EVENT_ERROR_FILE_BUSY        = &HC0003761

'
' MessageId: CRS_EVENT_ACL_ERROR_INVALID_ACE
'
' MessageText:
'
'  Could not set the ACE on this file.
'
Const CRS_EVENT_ACL_ERROR_INVALID_ACE  = &H80003762

'
' MessageId: CRS_EVENT_ACL_ERROR_ACL_FAILED
'
' MessageText:
'
'  Could not set the ACLs appropriately on this file, setting default ACLs on this file.
'
Const CRS_EVENT_ACL_ERROR_ACL_FAILED   = &HC0003763

'
' MessageId: CRS_EVENT_ERROR_PROJECT_NOT_FOUND_ON_DESTINATION
'
' MessageText:
'
'  Could not find project on the destination server.
'
Const CRS_EVENT_ERROR_PROJECT_NOT_FOUND_ON_DESTINATION = &HC0003764

'
' MessageId: CRS_EVENT_ERROR_PROJECT_INCOMPLETE_ON_DESTINATION
'
' MessageText:
'
'  Project information is incomplete on the destination server.
'
Const CRS_EVENT_ERROR_PROJECT_INCOMPLETE_ON_DESTINATION = &HC0003765

'
' MessageId: CRS_EVENT_ERROR_SERVICE_DOWN_ON_REMOTE_SERVER
'
' MessageText:
'
'  Remote server is available, but the Site Server Content Deployment service is not running.
'
Const CRS_EVENT_ERROR_SERVICE_DOWN_ON_REMOTE_SERVER = &HC0003766

'
' MessageId: CRS_EVENT_ERROR_DISK_FULL_ON_DESTINATION
'
' MessageText:
'
'  Disk is full on the destination server.
'
Const CRS_EVENT_ERROR_DISK_FULL_ON_DESTINATION = &HC0003767

'
' MessageId: CRS_EVENT_FILE_CREATE_ERROR_ON_DESTINATION
'
' MessageText:
'
'  Unable to open a file on the destination server.  Check permissions on the project directory and files.
'
Const CRS_EVENT_FILE_CREATE_ERROR_ON_DESTINATION = &HC0003768

'
' MessageId: CRS_EVENT_ERROR_REMOTE_SERVER_NOT_FOUND
'
' MessageText:
'
'  Remote server could not be found.
'
Const CRS_EVENT_ERROR_REMOTE_SERVER_NOT_FOUND = &HC0003769

'
' MessageId: CRS_EVENT_ERROR_REMOTE_APPLY_FAILED
'
' MessageText:
'
'  Unable to apply transactions on the destination server.
'
Const CRS_EVENT_ERROR_REMOTE_APPLY_FAILED = &HC000376A

'
' MessageId: CRS_EVENT_ERROR_INVALID_FLAG_COMBINATION
'
' MessageText:
'
'  Invalid flag combination.
'
Const CRS_EVENT_ERROR_INVALID_FLAG_COMBINATION = &HC000376B

'
' MessageId: CRS_EVENT_ERROR_RUNNING_SCRIPT
'
' MessageText:
'
'  There was an error running the script.  Ensure that the script exists and can be located in the path.
'
Const CRS_EVENT_ERROR_RUNNING_SCRIPT   = &HC000376C

'
' MessageId: CRS_EVENT_ERROR_CANT_FORWARD_TO_LOCAL_SERVER
'
' MessageText:
'
'  Cannot forward events to the local server.
'
Const CRS_EVENT_ERROR_CANT_FORWARD_TO_LOCAL_SERVER = &HC000376D

'
' MessageId: CRS_EVENT_ERROR_SCHEDULE_NOT_FOUND
'
' MessageText:
'
'  Specified project schedule could not be found.
'
Const CRS_EVENT_ERROR_SCHEDULE_NOT_FOUND = &HC000376E

'
' MessageId: CRS_EVENT_ERROR_METABASE
'
' MessageText:
'
'  An error occurred accessing the metabase.  Ensure that the web site exists and that the account has access to it.
'
Const CRS_EVENT_ERROR_METABASE         = &HC000376F

'
' MessageId: CRS_EVENT_ERROR_SCHEDULER_FAILURE
'
' MessageText:
'
'  An error occurred with the task scheduler.
'
Const CRS_EVENT_ERROR_SCHEDULER_FAILURE = &HC0003770

'
' MessageId: CRS_EVENT_SAMEBOX_META_TARGET
'
' MessageText:
'
'  A destination for metabase replication is invalid.
'
Const CRS_EVENT_SAMEBOX_META_TARGET    = &HC0003771

'
' MessageId: CRS_EVENT_ERROR_DROPPED_EVENTS
'
' MessageText:
'
'  The event sink specified by the data field has started dropping events.
'
Const CRS_EVENT_ERROR_DROPPED_EVENTS   = &HC0003772

'
' MessageId: CRS_EVENT_REPLICATION_FIRST
'
' MessageText:
'
'  Site Server Content Deployment first replication event message.
'
Const CRS_EVENT_REPLICATION_FIRST      = &H400037DC

'
' MessageId: CRS_EVENT_STARTING_REPLICATION
'
' MessageText:
'
'  Project starting to the destination server.
'
Const CRS_EVENT_STARTING_REPLICATION   = &H400037DD

'
' MessageId: CRS_EVENT_REPLICATION_COMPLETE
'
' MessageText:
'
'  Project complete to the destination server.
'
Const CRS_EVENT_REPLICATION_COMPLETE   = &H400037DE

'
' MessageId: CRS_EVENT_STARTING_PULL_REPLICATION
'
' MessageText:
'
'  Retrieval project starting.
'
Const CRS_EVENT_STARTING_PULL_REPLICATION = &H400037DF

'
' MessageId: CRS_EVENT_PULL_REPLICATION_COMPLETE
'
' MessageText:
'
'  Retrieval project complete.
'
Const CRS_EVENT_PULL_REPLICATION_COMPLETE = &H400037E0

'
' MessageId: CRS_EVENT_STARTING_RECEIVE_REPLICATION
'
' MessageText:
'
'  Starting to receive project.
'
Const CRS_EVENT_STARTING_RECEIVE_REPLICATION = &H400037E1

'
' MessageId: CRS_EVENT_REPLICATION_RECEIVE_COMPLETE
'
' MessageText:
'
'  Finished receiving project.
'
Const CRS_EVENT_REPLICATION_RECEIVE_COMPLETE = &H400037E2

'
' MessageId: CRS_EVENT_STARTING_REPLICATION_SCAN
'
' MessageText:
'
'  Project starting.
'
Const CRS_EVENT_STARTING_REPLICATION_SCAN = &H400037E3

'
' MessageId: CRS_EVENT_REPLICATION_LAST
'
' MessageText:
'
'  Site Server Content Deployment last replication event message.
'
Const CRS_EVENT_REPLICATION_LAST       = &H4000380D

'
' MessageId: CRS_EVENT_FILE_FIRST
'
' MessageText:
'
'  Site Server Content Deployment first file event message.
'
Const CRS_EVENT_FILE_FIRST             = &H4000380E

'
' MessageId: CRS_EVENT_SENDING_FILE
'
' MessageText:
'
'  Sending file.
'
Const CRS_EVENT_SENDING_FILE           = &H4000380F

'
' MessageId: CRS_EVENT_SENT_FILE
'
' MessageText:
'
'  File sent.
'
Const CRS_EVENT_SENT_FILE              = &H40003810

'
' MessageId: CRS_EVENT_RECEIVING_FILE
'
' MessageText:
'
'  Receiving file.
'
Const CRS_EVENT_RECEIVING_FILE         = &H40003811

'
' MessageId: CRS_EVENT_RECEIVED_FILE
'
' MessageText:
'
'  File received.
'
Const CRS_EVENT_RECEIVED_FILE          = &H40003812

'
' MessageId: CRS_EVENT_SENT_DELETE_FILE
'
' MessageText:
'
'  Sent delete file request.
'
Const CRS_EVENT_SENT_DELETE_FILE       = &H40003813

'
' MessageId: CRS_EVENT_RECEIVED_DELETE_FILE
'
' MessageText:
'
'  File delete request received.
'
Const CRS_EVENT_RECEIVED_DELETE_FILE   = &H40003814

'
' MessageId: CRS_EVENT_RETRYING_SENDING_FILE
'
' MessageText:
'
'  Retrying to send file.
'
Const CRS_EVENT_RETRYING_SENDING_FILE  = &H40003818

'
' MessageId: CRS_EVENT_FILE_BUSY
'
' MessageText:
'
'  File is busy.  The service is waiting for the file to become available.
'
Const CRS_EVENT_FILE_BUSY              = &H40003819

'
' MessageId: CRS_EVENT_SENDING_ACL
'
' MessageText:
'
'  Sending the ACL for this file.
'
Const CRS_EVENT_SENDING_ACL            = &H4000381A

'
' MessageId: CRS_EVENT_SENT_ACL
'
' MessageText:
'
'  Sent the ACL for this file.
'
Const CRS_EVENT_SENT_ACL               = &H4000381B

'
' MessageId: CRS_EVENT_RECEIVING_ACL
'
' MessageText:
'
'  Receiving the ACL for this file.
'
Const CRS_EVENT_RECEIVING_ACL          = &H4000381C

'
' MessageId: CRS_EVENT_RECEIVED_ACL
'
' MessageText:
'
'  Received the ACL for this file.
'
Const CRS_EVENT_RECEIVED_ACL           = &H4000381D

'
' MessageId: CRS_EVENT_PULLED_FILE_HTTP
'
' MessageText:
'
'  File retrieved over HTTP.
'
Const CRS_EVENT_PULLED_FILE_HTTP       = &H4000381E

'
' MessageId: CRS_EVENT_PULLED_FILE_FTP
'
' MessageText:
'
'  File retrieved over FTP.
'
Const CRS_EVENT_PULLED_FILE_FTP        = &H4000381F

'
' MessageId: CRS_EVENT_FILE_COMMITTED
'
' MessageText:
'
'  File committed to disk.
'
Const CRS_EVENT_FILE_COMMITTED         = &H40003820

'
' MessageId: CRS_EVENT_FILE_DELETED
'
' MessageText:
'
'  File deleted.
'
Const CRS_EVENT_FILE_DELETED           = &H40003821

'
' MessageId: CRS_EVENT_SKIPPING_LOCKED_FILE
'
' MessageText:
'
'  File skipped because it could not be opened.
'
Const CRS_EVENT_SKIPPING_LOCKED_FILE   = &H80003822

'
' MessageId: CRS_EVENT_FILE_MATCHED
'
' MessageText:
'
'  File matched.
'
Const CRS_EVENT_FILE_MATCHED           = &H40003823

'
' MessageId: CRS_EVENT_FILE_LAST
'
' MessageText:
'
'  Site Server Content Deployment last file event message.
'
Const CRS_EVENT_FILE_LAST              = &H4000383F

'
' MessageId: CRS_EVENT_ADMIN_FIRST
'
' MessageText:
'
'  Site Server Content Deployment first administration event message.
'
Const CRS_EVENT_ADMIN_FIRST            = &H40003840

'
' MessageId: CRS_EVENT_PROJECT_CREATED
'
' MessageText:
'
'  Project created.
'
Const CRS_EVENT_PROJECT_CREATED        = &H40003841

'
' MessageId: CRS_EVENT_PROJECT_DELETED
'
' MessageText:
'
'  Project deleted.
'
Const CRS_EVENT_PROJECT_DELETED        = &H40003842

'
' MessageId: CRS_EVENT_PROJECT_EDITED
'
' MessageText:
'
'  Project edited.
'
Const CRS_EVENT_PROJECT_EDITED         = &H40003843

'
' MessageId: CRS_EVENT_ROUTE_CREATED
'
' MessageText:
'
'  Route created.
'
Const CRS_EVENT_ROUTE_CREATED          = &H40003844

'
' MessageId: CRS_EVENT_ROUTE_DELETED
'
' MessageText:
'
'  Route deleted.
'
Const CRS_EVENT_ROUTE_DELETED          = &H40003845

'
' MessageId: CRS_EVENT_ROUTE_EDITED
'
' MessageText:
'
'  Route edited.
'
Const CRS_EVENT_ROUTE_EDITED           = &H40003846

'
' MessageId: CRS_EVENT_SERVER_EDITED
'
' MessageText:
'
'  Server settings modified.
'
Const CRS_EVENT_SERVER_EDITED          = &H40003847

'
' MessageId: CRS_EVENT_EVENTSINK_CREATED
'
' MessageText:
'
'  Event sink specified by the data field was added.
'
Const CRS_EVENT_EVENTSINK_CREATED      = &H40003848

'
' MessageId: CRS_EVENT_EVENTSINK_DELETED
'
' MessageText:
'
'  Event sink specified by the data field was deleted.
'
Const CRS_EVENT_EVENTSINK_DELETED      = &H40003849

'
' MessageId: CRS_EVENT_CLEARED_EVENTS
'
' MessageText:
'
'  Event store specified by the data field was cleared.
'
Const CRS_EVENT_CLEARED_EVENTS         = &H4000384A

'
' MessageId: CRS_EVENT_CLEARED_ALL_EVENTS
'
' MessageText:
'
'  Each database event store on this server was cleared.
'
Const CRS_EVENT_CLEARED_ALL_EVENTS     = &H4000384B

'
' MessageId: CRS_EVENT_ADMIN_LAST
'
' MessageText:
'
'  Site Server Content Deployment last administration event message.
'
Const CRS_EVENT_ADMIN_LAST             = &H40003872

'
' MessageId: CRS_EVENT_SUMMARY_FIRST
'
' MessageText:
'
'  Site Server Content Deployment first summary event message.
'
Const CRS_EVENT_SUMMARY_FIRST          = &H400038A4

'
' MessageId: CRS_EVENT_SUMMARY_RECEIVE
'
' MessageText:
'
'  Project summary information (files received).
'
Const CRS_EVENT_SUMMARY_RECEIVE        = &H400038A5

'
' MessageId: CRS_EVENT_SUMMARY_SEND
'
' MessageText:
'
'  Project summary information (files sent).
'
Const CRS_EVENT_SUMMARY_SEND           = &H400038A6

'
' MessageId: CRS_EVENT_SUMMARY_PULL
'
' MessageText:
'
'  Project summary information (files pulled).
'
Const CRS_EVENT_SUMMARY_PULL           = &H400038A7

'
' MessageId: CRS_EVENT_SUMMARY_AUTOMATIC_RECEIVE
'
' MessageText:
'
'  Automatic project (receive) checkpoint summary information.
'
Const CRS_EVENT_SUMMARY_AUTOMATIC_RECEIVE = &H400038A8

'
' MessageId: CRS_EVENT_SUMMARY_AUTOMATIC_SEND
'
' MessageText:
'
'  Automatic project (send) checkpoint summary information.
'
Const CRS_EVENT_SUMMARY_AUTOMATIC_SEND = &H400038A9

'
' MessageId: CRS_EVENT_SUMMARY_RECEIVE_MATCHED
'
' MessageText:
'
'  Project summary information (files matched during receive).
'
Const CRS_EVENT_SUMMARY_RECEIVE_MATCHED = &H400038AA

'
' MessageId: CRS_EVENT_SUMMARY_SEND_MATCHED
'
' MessageText:
'
'  Project summary information (files matched during send).
'
Const CRS_EVENT_SUMMARY_SEND_MATCHED   = &H400038AB

'
' MessageId: CRS_EVENT_SUMMARY_PULL_MATCHED
'
' MessageText:
'
'  Project summary information (files matched during pull).
'
Const CRS_EVENT_SUMMARY_PULL_MATCHED   = &H400038AC

'
' MessageId: CRS_EVENT_SUMMARY_RECEIVE_ERRORED
'
' MessageText:
'
'  Project summary information (files errored during receive).
'
Const CRS_EVENT_SUMMARY_RECEIVE_ERRORED = &H400038AD

'
' MessageId: CRS_EVENT_SUMMARY_SEND_ERRORED
'
' MessageText:
'
'  Project summary information (files errored during send).
'
Const CRS_EVENT_SUMMARY_SEND_ERRORED   = &H400038AE

'
' MessageId: CRS_EVENT_SUMMARY_PULL_ERRORED
'
' MessageText:
'
'  Project summary information (files errored during pull).
'
Const CRS_EVENT_SUMMARY_PULL_ERRORED   = &H400038AF

'
' MessageId: CRS_EVENT_SUMMARY_LAST
'
' MessageText:
'
'  Site Server Content Deployment last summary event message.
'
Const CRS_EVENT_SUMMARY_LAST           = &H400038D6

'
' MessageId: CRS_EVENT_CAB_ERROR_FIRST
'
' MessageText:
'
'  Remote installer first error message.
'
Const CRS_EVENT_CAB_ERROR_FIRST        = &HC0003908

'
' MessageId: CRS_EVENT_CAB_ERROR_CABINET_NOT_FOUND
'
' MessageText:
'
'  Cannot find the specified cabinet file.
'
Const CRS_EVENT_CAB_ERROR_CABINET_NOT_FOUND = &HC0003909

'
' MessageId: CRS_EVENT_CAB_ERROR_NOT_A_CABINET
'
' MessageText:
'
'  Specified file is not a valid cabinet file.
'
Const CRS_EVENT_CAB_ERROR_NOT_A_CABINET = &HC000390A

'
' MessageId: CRS_EVENT_CAB_ERROR_UNKNOWN_CABINET_VERSION
'
' MessageText:
'
'  Specified file is an unknown version of a cabinet file.
'
Const CRS_EVENT_CAB_ERROR_UNKNOWN_CABINET_VERSION = &HC000390B

'
' MessageId: CRS_EVENT_CAB_ERROR_CORRUPT_CABINET
'
' MessageText:
'
'  Specified cabinet file is corrupt.
'
Const CRS_EVENT_CAB_ERROR_CORRUPT_CABINET = &HC000390C

'
' MessageId: CRS_EVENT_CAB_ERROR_ALLOC_FAIL
'
' MessageText:
'
'  Out of memory.
'
Const CRS_EVENT_CAB_ERROR_ALLOC_FAIL   = &HC000390D

'
' MessageId: CRS_EVENT_CAB_ERROR_BAD_COMPR_TYPE
'
' MessageText:
'
'  Specified cabinet file uses an unknown compression type.
'
Const CRS_EVENT_CAB_ERROR_BAD_COMPR_TYPE = &HC000390E

'
' MessageId: CRS_EVENT_CAB_ERROR_MDI_FAIL
'
' MessageText:
'
'  Compressed data in the specified cabinet file is corrupt.
'
Const CRS_EVENT_CAB_ERROR_MDI_FAIL     = &HC000390F

'
' MessageId: CRS_EVENT_CAB_ERROR_TARGET_FILE
'
' MessageText:
'
'  Could not save extracted files from the specified cabinet file.
'
Const CRS_EVENT_CAB_ERROR_TARGET_FILE  = &HC0003910

'
' MessageId: CRS_EVENT_CAB_ERROR_RESERVE_MISMATCH
'
' MessageText:
'
'  Specified cabinet file has a non-valid RESERVE size.
'
Const CRS_EVENT_CAB_ERROR_RESERVE_MISMATCH = &HC0003911

'
' MessageId: CRS_EVENT_CAB_ERROR_WRONG_CABINET
'
' MessageText:
'
'  Specified cabinet file is not the right cabinet in the set.
'
Const CRS_EVENT_CAB_ERROR_WRONG_CABINET = &HC0003912

'
' MessageId: CRS_EVENT_CAB_ERROR_USER_ABORT
'
' MessageText:
'
'  Could not extract the specified cabinet file. User aborted the operation.
'
Const CRS_EVENT_CAB_ERROR_USER_ABORT   = &HC0003913

'
' MessageId: CRS_EVENT_CAB_WARNING_CAB_NOT_SIGNED
'
' MessageText:
'
'  Specified cabinet file is not a signed cabinet file.
'
Const CRS_EVENT_CAB_WARNING_CAB_NOT_SIGNED = &H80003914

'
' MessageId: CRS_EVENT_CAB_WARNING_SIGNATURE_NOT_VERIFIED
'
' MessageText:
'
'  Signature on the specified cabinet could not be verified.
'
Const CRS_EVENT_CAB_WARNING_SIGNATURE_NOT_VERIFIED = &H80003915

'
' MessageId: CRS_EVENT_CAB_ERROR_INFFILE_NOT_FOUND
'
' MessageText:
'
'  INF file was not found inside the specified cabinet file.
'
Const CRS_EVENT_CAB_ERROR_INFFILE_NOT_FOUND = &HC0003916

'
' MessageId: CRS_EVENT_INF_ERROR_ADVPACK_NOT_LOADED
'
' MessageText:
'
'  Could not load ADVPACK.DLL.
'
Const CRS_EVENT_INF_ERROR_ADVPACK_NOT_LOADED = &HC0003917

'
' MessageId: CRS_EVENT_INF_ERROR_ADVPACK_WRONG_VERSION
'
' MessageText:
'
'  This version of ADVPACK.DLL is not supported.
'
Const CRS_EVENT_INF_ERROR_ADVPACK_WRONG_VERSION = &HC0003918

'
' MessageId: CRS_EVENT_INF_ERROR_INVALID_INF
'
' MessageText:
'
'  INF file found inside the specified cabinet file is not a valid INF file.
'
Const CRS_EVENT_INF_ERROR_INVALID_INF  = &HC0003919

'
' MessageId: CRS_EVENT_INF_ERROR_NOTHING_TO_INSTALL
'
' MessageText:
'
'  Could not find any of the remote install sections inside the INF file.
'
Const CRS_EVENT_INF_ERROR_NOTHING_TO_INSTALL = &HC000391A

'
' MessageId: CRS_EVENT_INF_ERROR_NOTHING_TO_UNINSTALL
'
' MessageText:
'
'  Could not find any of the remote uninstall sections inside the INF file.
'
Const CRS_EVENT_INF_ERROR_NOTHING_TO_UNINSTALL = &HC000391B

'
' MessageId: CRS_EVENT_INF_ERROR_BUSY_FILES
'
' MessageText:
'
'  Files are busy.  Cannot install them unless allowed to reboot.
'
Const CRS_EVENT_INF_ERROR_BUSY_FILES   = &HC000391C

'
' MessageId: CRS_EVENT_CAB_WARNING_MANUAL_REBOOT
'
' MessageText:
'
'  Setup completed successfully. The server could not be rebooted automatically. Manual reboot is necessary.
'
Const CRS_EVENT_CAB_WARNING_MANUAL_REBOOT = &H8000391D

'
' MessageId: CRS_EVENT_CAB_WARNING_REBOOT_NEEDED
'
' MessageText:
'
'  Setup completed successfully. The files became busy during setup.  Manual reboot is necessary.
'
Const CRS_EVENT_CAB_WARNING_REBOOT_NEEDED = &H8000391E

'
' MessageId: CRS_EVENT_INF_SUCCESS_REBOOT_IN_PROGRESS
'
' MessageText:
'
'  Setup completed successfully. The server is being rebooted.
'
Const CRS_EVENT_INF_SUCCESS_REBOOT_IN_PROGRESS = &H0000391F

'
' MessageId: CRS_EVENT_INF_SUCCESS
'
' MessageText:
'
'  Setup completed successfully.
'
Const CRS_EVENT_INF_SUCCESS            = &H00003921

'
' MessageId: CRS_EVENT_INF_ERROR_BUSY_FILES_UNINSTALL
'
' MessageText:
'
'  Files are busy.  Cannot uninstall them unless allowed to reboot.
'
Const CRS_EVENT_INF_ERROR_BUSY_FILES_UNINSTALL = &HC0003922

'
' MessageId: CRS_EVENT_CAB_WARNING_MANUAL_REBOOT_UNINSTALL
'
' MessageText:
'
'  Uninstall completed successfully. The server could not be rebooted automatically. Manual reboot is necessary.
'
Const CRS_EVENT_CAB_WARNING_MANUAL_REBOOT_UNINSTALL = &H80003923

'
' MessageId: CRS_EVENT_CAB_WARNING_REBOOT_NEEDED_UNINSTALL
'
' MessageText:
'
'  Uninstall completed successfully. The files became busy during setup.  Manual reboot is necessary.
'
Const CRS_EVENT_CAB_WARNING_REBOOT_NEEDED_UNINSTALL = &H80003924

'
' MessageId: CRS_EVENT_INF_SUCCESS_REBOOT_IN_PROGRESS_UNINSTALL
'
' MessageText:
'
'  Uninstall completed successfully. The server is being rebooted.
'
Const CRS_EVENT_INF_SUCCESS_REBOOT_IN_PROGRESS_UNINSTALL = &H00003925

'
' MessageId: CRS_EVENT_INF_SUCCESS_UNINSTALL
'
' MessageText:
'
'  Uninstall completed successfully.
'
Const CRS_EVENT_INF_SUCCESS_UNINSTALL  = &H00003926

'
' MessageId: CRS_EVENT_CAB_ERROR_ADVPACK_FAILED
'
' MessageText:
'
'  Problem installing the CAB. Check CAB and INF files for validity. 
'
Const CRS_EVENT_CAB_ERROR_ADVPACK_FAILED = &HC0003927

'
' MessageId: CRS_EVENT_CAB_ERROR_LOCKED_FILES
'
' MessageText:
'
'  At least one of the files inside the CAB is open for exclusive write/delete access.
'
Const CRS_EVENT_CAB_ERROR_LOCKED_FILES = &HC0003928

'
' MessageId: CRS_EVENT_CAB_ERROR_UNKNOWN
'
' MessageText:
'
'  Unknown error occurred while processing the specified cabinet file.
'
Const CRS_EVENT_CAB_ERROR_UNKNOWN      = &HC0003A06

'
' MessageId: CRS_EVENT_CAB_ERROR_LAST
'
' MessageText:
'
'  Remote installer last event message.
'
Const CRS_EVENT_CAB_ERROR_LAST         = &H40003A07

'
' MessageId: CRS_EVENT_LAST
'
' MessageText:
'
'  Site Server Content Deployment last event message.
'
Const CRS_EVENT_LAST                   = &H40003A97
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ctl3d.h ===
/*-----------------------------------------------------------------------
|	CTL3D.DLL
|	
|	Adds 3d effects to Windows controls
|
|	See ctl3d.doc for info
|		
-----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {
#endif


BOOL WINAPI Ctl3dSubclassDlg(HWND, WORD);
BOOL WINAPI Ctl3dSubclassDlgEx(HWND, DWORD);

WORD WINAPI Ctl3dGetVer(void);
BOOL WINAPI Ctl3dEnabled(void);

HBRUSH WINAPI Ctl3dCtlColor(HDC, LONG);	// ARCHAIC, use Ctl3dCtlColorEx
HBRUSH WINAPI Ctl3dCtlColorEx(UINT wm, WPARAM wParam, LPARAM lParam);

BOOL WINAPI Ctl3dColorChange(void);

BOOL WINAPI Ctl3dSubclassCtl(HWND);
BOOL WINAPI Ctl3dSubclassCtlEx(HWND, int);
BOOL WINAPI Ctl3dUnsubclassCtl(HWND);

LONG WINAPI Ctl3dDlgFramePaint(HWND, UINT, WPARAM, LPARAM);

BOOL WINAPI Ctl3dAutoSubclass(HINSTANCE);
BOOL WINAPI Ctl3dAutoSubclassEx(HINSTANCE, DWORD);
BOOL WINAPI Ctl3dIsAutoSubclass(VOID);
BOOL WINAPI Ctl3dUnAutoSubclass(VOID);

BOOL WINAPI Ctl3dRegister(HINSTANCE);
BOOL WINAPI Ctl3dUnregister(HINSTANCE);

//begin DBCS: far east short cut key support
VOID WINAPI Ctl3dWinIniChange(void);
//end DBCS

/* Ctl3dAutoSubclassEx flags */
#define CTL3D_SUBCLASS_DYNCREATE	0x0001
#define CTL3D_NOSUBCLASS_DYNCREATE	0x0002

/* Ctl3d Control ID */
#define CTL3D_BUTTON_CTL	0
#define CTL3D_LISTBOX_CTL	1
#define CTL3D_EDIT_CTL		2
#define CTL3D_COMBO_CTL 	3
#define CTL3D_STATIC_CTL	4

/* Ctl3dSubclassDlg3d flags */
#define CTL3D_BUTTONS		0x0001
#define CTL3D_LISTBOXES		0x0002		
#define CTL3D_EDITS			0x0004	
#define CTL3D_COMBOS		0x0008
#define CTL3D_STATICTEXTS	0x0010		
#define CTL3D_STATICFRAMES	0x0020

#define CTL3D_NODLGWINDOW       0x00010000
#define CTL3D_ALL				0xffff

#define WM_DLGBORDER (WM_USER+3567)
/* WM_DLGBORDER *(int FAR *)lParam return codes */
#define CTL3D_NOBORDER		0
#define CTL3D_BORDER			1

#define WM_DLGSUBCLASS (WM_USER+3568)
/* WM_DLGSUBCLASS *(int FAR *)lParam return codes */
#define CTL3D_NOSUBCLASS	0
#define CTL3D_SUBCLASS		1

#define CTLMSGOFFSET 3569
#ifdef WIN32
#define CTL3D_CTLCOLORMSGBOX	(WM_USER+CTLMSGOFFSET)
#define CTL3D_CTLCOLOREDIT		(WM_USER+CTLMSGOFFSET+1)
#define CTL3D_CTLCOLORLISTBOX	(WM_USER+CTLMSGOFFSET+2)
#define CTL3D_CTLCOLORBTN		(WM_USER+CTLMSGOFFSET+3)
#define CTL3D_CTLCOLORSCROLLBAR (WM_USER+CTLMSGOFFSET+4)
#define CTL3D_CTLCOLORSTATIC	(WM_USER+CTLMSGOFFSET+5)
#define CTL3D_CTLCOLORDLG		(WM_USER+CTLMSGOFFSET+6)
#else
#define CTL3D_CTLCOLOR (WM_USER+CTLMSGOFFSET)
#endif


/* Resource ID for 3dcheck.bmp (for .lib version of ctl3d) */
#define CTL3D_3DCHECK 26567


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************.
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        unsigned long lCounts[_MAX_BLOCKS];
        unsigned long lSizes[_MAX_BLOCKS];
        unsigned long lHighWaterCount;
        unsigned long lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _CrtSetReportHook(f)                ((void)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((void)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((void)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)

#define _CrtSetDumpClient(f)                ((void)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#define _ASSERT(expr) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, NULL))) \
             _CrtDbgBreak(); } while (0)

#define _ASSERTE(expr) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr))) \
             _CrtDbgBreak(); } while (0)


/* Reports with no file/line info */

#define _RPT0(rptno, msg) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, "%s", msg))) \
                _CrtDbgBreak(); } while (0)

#define _RPT1(rptno, msg, arg1) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1))) \
                _CrtDbgBreak(); } while (0)

#define _RPT2(rptno, msg, arg1, arg2) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2))) \
                _CrtDbgBreak(); } while (0)

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))) \
                _CrtDbgBreak(); } while (0)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))) \
                _CrtDbgBreak(); } while (0)


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, "%s", msg))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF1(rptno, msg, arg1) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF2(rptno, msg, arg1, arg2) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))) \
                _CrtDbgBreak(); } while (0)

#if     defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

inline void* __cdecl operator new(unsigned int s, int, const char *, int)
        { return ::operator new(s); }

#if	_MSC_VER >= 1200
inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/

_CRTIMP void * __cdecl operator new(
        unsigned int,
        int,
        const char *,
        int
        );


#if	_MSC_VER >= 1200
inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void* __cdecl operator new(unsigned int s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

#endif _MFC_OVERRIDES_NEW

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\cwindow.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1997 Microsoft Corporation.
//
//  File:       cwindow.h
//
//  Contents:   definition of a virtual window class
//
//  Classes:    CHlprWindow
//
//  Functions:  WindowProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------


#ifndef __CWINDOW_H__
#define __CWINDOW_H__

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

LRESULT CALLBACK WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprWindow
//
//  Purpose:    virtual base class for wrapping a window
//
//  Interface:  Create     -- analagous to Windows' CreateWindow function
//              WindowProc -- pure virtual WindowProc for the window
//              ~CHlprWindow   -- destructor
//              CHlprWindow    -- constructor
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This class allows a window to be cleanly wrapped in a
//              c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a WindowProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprWindow
{
public:
    HWND Create(
        LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName,
        DWORD dwStyle,
        int x,
        int y,
        int nWidth,
        int nHeight,
        HWND hwndParent,
        HMENU hmenu,
        HINSTANCE hinst);
    virtual LRESULT WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprWindow(){};
    HWND GetHwnd(void)
    {
        return(_hwnd);
    }
    CHlprWindow()
    {
        _hwnd = NULL;
        _hInstance = NULL;
    };
protected:
friend LRESULT CALLBACK ::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
    HWND _hwnd;
    HINSTANCE _hInstance;
};

#endif

#endif //__CWINDOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\customaw.h ===
#ifndef __CUSTOMAW_H__
#define __CUSTOMAW_H__

#include <afxdisp.h>
#include <ObjModel\appauto.h>
#include <ObjModel\bldauto.h>

/////////////////////////////////////////////////////////////////////////////
// customaw.h -- Header file to be included by all custom AppWizards.


/////////////////////////////////////////////////////////////////////////////
// Defines for exporting from AppWizard & importing into extensions
// TODO: Delete this

#pragma warning(disable: 4275)
#pragma warning(disable: 4251)

#ifndef _APWZEXT
	#ifdef _DEBUG
		#pragma comment(lib, "mfcapwzd.lib")
	#else
		#pragma comment(lib, "mfcapwz.lib")
	#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// Class CAppWizStepDlg-- all custom AppWizard steps must derive from
//  this class

class CAppWizStepDlg : public CDialog
{
public:
	CAppWizStepDlg(UINT nIDTemplate);
	~CAppWizStepDlg();
	virtual BOOL OnDismiss();

	// You will probably not want to override or call this function.  It is
	//  overridden (for CAppWizStepDlg) in MFCAPWZ.DLL to handle tabbing from
	//  the dialog controls in CAppWizStepDlg to the outer AppWizard dialog's
	//  controls.
    virtual BOOL PreTranslateMessage(MSG* pMsg);

	// You will probably not want to override or call this function.  It is
	//  overridden (for CAppWizStepDlg) in MFCAPWZ.DLL to dynamically change
	//  the dialog template's font to match the rest of the IDE.
	virtual BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);

	UINT m_nIDTemplate;
};


/////////////////////////////////////////////////////////////////////////////
// class OutputStream-- this abstract class is used to funnel output while
//  parsing templates.

class OutputStream
{
public:
    virtual void WriteLine(LPCTSTR lpsz) = 0;
    virtual void WriteBlock(LPCTSTR pBlock, DWORD dwSize) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Class CCustomAppWiz-- all custom AppWizards must have a class derived from
//  this.  MFCAPWZ.DLL talks to the custom AppWizard by calling these virtual
//  functions.

class CCustomAppWiz : public CObject
{
public:
	CMapStringToString m_Dictionary;

	virtual void GetPlatforms(CStringList& rPlatforms) {}

	virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg) { return NULL; }
	virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg) { return NULL; }

	virtual void InitCustomAppWiz() { m_Dictionary.RemoveAll(); }
	virtual void ExitCustomAppWiz() {}

	virtual LPCTSTR LoadTemplate(LPCTSTR lpszTemplateName,
		DWORD& rdwSize, HINSTANCE hInstance = NULL);

	virtual void CopyTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput);
	virtual void ProcessTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput);
	virtual void PostProcessTemplate(LPCTSTR szTemplate) {}
	
	virtual void CustomizeProject(IBuildProject* pProject) {}
};


/////////////////////////////////////////////////////////////////////////////
// C API's exported by AppWizard.  The custom AppWizard talks to MFCAPWZ.DLL
//  by calling these functions.

// Values to be passed to GetDialog()
enum AppWizDlgID
{
	APWZDLG_APPTYPE = 1,
	APWZDLG_DATABASE,
	APWZDLG_OLE,
	APWZDLG_DOCAPPOPTIONS,
	APWZDLG_PROJOPTIONS,
	APWZDLG_CLASSES,
	APWZDLG_DLGAPPOPTIONS,
	APWZDLG_DLLPROJOPTIONS,
};

void SetCustomAppWizClass(CCustomAppWiz* pAW);
CAppWizStepDlg* GetDialog(AppWizDlgID nID);
void SetNumberOfSteps(int nSteps);
BOOL ScanForAvailableLanguages(CStringList& rLanguages);
void SetSupportedLanguages(LPCTSTR szSupportedLangs);
HRESULT FindInterface(REFIID riid, LPVOID FAR* ppvObj);


#endif //__CUSTOMAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\cutlist.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// CutList related definitions and interfaces for ActiveMovie

#ifndef __CUTLIST__
#define __CUTLIST__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define CL_DEFAULT_TIME			(-1L)

enum CL_ELEM_STATUS {
	CL_NOT_PLAYED = 0,
	CL_PLAYING = 1,
	CL_FINISHED = 2,
	CL_STATE_INVALID = 3,
	CL_STATE_MASK = CL_STATE_INVALID,
	CL_WAIT_FOR_STATE = 0xF0000000
};

enum CL_ELEM_FLAGS{
	CL_ELEM_FIRST = 1,
	CL_ELEM_LAST = 2,
	CL_ELEM_NULL = 4,
	CL_ELEM_ALL  = 0xFFFFFFFF,
	CL_ELEM_NONE = 0x0L
};


#ifndef __IAMCutListElement_INTERFACE_DEFINED__
#define __IAMCutListElement_INTERFACE_DEFINED__
#define __IAMFileCutListElement_INTERFACE_DEFINED__
#define __IAMVideoCutListElement_INTERFACE_DEFINED__
#define __IAMAudioCutListElement_INTERFACE_DEFINED__

interface IAMCutListElement : public IUnknown
{
public:
        virtual HRESULT __stdcall GetElementStartPosition( 
            /* [out] */ REFERENCE_TIME *pmtStart) = 0;
        
        virtual HRESULT __stdcall GetElementDuration( 
            /* [out] */ REFERENCE_TIME *pmtDuration) = 0;
        
        virtual HRESULT __stdcall IsFirstElement( void ) = 0;
        
        virtual HRESULT __stdcall IsLastElement( void ) = 0; 
        
        virtual HRESULT __stdcall IsNull( void ) = 0;
        
        virtual HRESULT __stdcall ElementStatus( 
            DWORD *pdwStatus,
            DWORD dwTimeoutMs) = 0;
        
};


interface IAMFileCutListElement : public IUnknown
{
public:
        virtual HRESULT __stdcall GetFileName( 
            /* [out] */ LPWSTR *ppwstrFileName) = 0;
        
        virtual HRESULT __stdcall GetTrimInPosition( 
            /* [out] */ REFERENCE_TIME *pmtTrimIn) = 0;
        
        virtual HRESULT __stdcall GetTrimOutPosition( 
            /* [out] */ REFERENCE_TIME *pmtTrimOut) = 0;
        
        virtual HRESULT __stdcall GetOriginPosition( 
            /* [out] */ REFERENCE_TIME *pmtOrigin) = 0;
        
        virtual HRESULT __stdcall GetTrimLength( 
            /* [out] */ REFERENCE_TIME *pmtLength) = 0;
        
        virtual HRESULT __stdcall GetElementSplitOffset( 
            /* [out] */ REFERENCE_TIME *pmtOffset) = 0;
        
};


interface IAMVideoCutListElement : public IUnknown
{
public:
        virtual HRESULT __stdcall IsSingleFrame( void) = 0;
        
        virtual HRESULT __stdcall GetStreamIndex( 
            /* [out] */ DWORD *piStream) = 0;
        
};
    

interface IAMAudioCutListElement : public IUnknown
{
public:
        virtual HRESULT __stdcall GetStreamIndex( 
            /* [out] */ DWORD *piStream) = 0;
        
        virtual HRESULT __stdcall HasFadeIn( void) = 0;
        
        virtual HRESULT __stdcall HasFadeOut( void) = 0;
        
};

#endif		// #ifndef IAMCutListElement


interface IStandardCutList : public IUnknown
{
	public:
		virtual HRESULT __stdcall AddElement(
			/* [in] */		IAMCutListElement	*pElement,
			/* [in] */		REFERENCE_TIME	mtStart,
			/* [in] */		REFERENCE_TIME	mtDuration)=0;

		virtual HRESULT __stdcall RemoveElement(
			/* [in] */		IAMCutListElement	*pElement) = 0;

		virtual HRESULT __stdcall GetFirstElement(
			/* [out] */		IAMCutListElement	**ppElement)=0;
		virtual HRESULT __stdcall GetLastElement(
			/* [out] */		IAMCutListElement	**ppElement)=0;
		virtual HRESULT __stdcall GetNextElement(
			/* [out] */		IAMCutListElement	**ppElement)=0;
		virtual HRESULT __stdcall GetPreviousElement(
			/* [out] */		IAMCutListElement	**ppElement)=0;
		
		virtual HRESULT __stdcall GetMediaType(
			/* [out] */		AM_MEDIA_TYPE *pmt)=0;
		virtual HRESULT __stdcall SetMediaType(
			/* [in] */		AM_MEDIA_TYPE *pmt)=0;
};


interface IFileClip : public IUnknown
{
	public:
		virtual HRESULT __stdcall SetFileAndStream(
			/* [in] */		LPWSTR	wstrFileName,
			/* [in] */		DWORD	streamNum) = 0;
		
		virtual HRESULT __stdcall CreateCut(
			/* [out] */		IAMCutListElement	**ppElement,
			/* [in] */		REFERENCE_TIME	mtTrimIn,
			/* [in] */		REFERENCE_TIME	mtTrimOut,
			/* [in] */		REFERENCE_TIME	mtOrigin,
			/* [in] */		REFERENCE_TIME	mtLength,
			/* [in] */		REFERENCE_TIME	mtOffset) = 0;

		virtual HRESULT __stdcall GetMediaType(
			/* [out] */		AM_MEDIA_TYPE	*pmt) = 0;
};

interface ICutListGraphBuilder : public IUnknown
{
public:
		virtual HRESULT __stdcall SetFilterGraph(
			/*[in]*/	IGraphBuilder	*pFilterGraph)=0;

		virtual HRESULT __stdcall GetFilterGraph(
			/*[out]*/	IGraphBuilder	**ppFilterGraph)=0;
		
		virtual HRESULT __stdcall AddCutList(
			/*[in]*/	IStandardCutList 	*pCutList,
			/*[out]*/	IPin			**ppPin)=0;
		
		virtual HRESULT __stdcall RemoveCutList(
			/*[in]*/	IStandardCutList 	*pCutList)=0;
		
		virtual HRESULT __stdcall SetOutputFileName(
			/*[in]*/	const GUID	*pType,
			/*[in]*/	LPCOLESTR	lpwstrFile,
			/*[in]*/	IBaseFilter	**ppf,
			/*[in]*/	IFileSinkFilter	**pSink) = 0;
		
		virtual HRESULT __stdcall Render(void) = 0;

		virtual HRESULT __stdcall GetElementFlags(
			/*[in]*/	IAMCutListElement *pElement,
			/*[out]*/	LPDWORD lpdwFlags) = 0;
		
};


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __CUTLIST__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\CrsTypes.Inc ===
'====================================================================
'                                                                     
'   Microsoft Site Server v3.00                                   
'                                                                     
'   Copyright (c) 1997 - 1999 Microsoft Corporation.  All rights reserved.   
'   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
'   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
'   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
'   PARTICULAR PURPOSE.
'=====================================================================

' Module Name:
'
'    crstypes.inc
'
' Abstract:
'
'    This module defines the common structures and prototypes for the   
'    Content Deployment Service API (ProgId = CrsApi)
'
' Revision History:
'


' CRS_PROJECT_CREATION
Const CREATE_NEW_PROJECT = &h1
Const OPEN_EXISTING_PROJECT = &h2

' CRS_SERVER_TYPES
Const STAGER = &h1
Const ENDPOINT = &h2

' CRS_SCHEDULE_ACTION
Const CRS_SCHEDULE_APPLY = &h1
Const CRS_SCHEDULE_REPLICATE = &h2

'
' Parameter maximums
'
Const MAX_PATH        = 260		' Max Directory Path Length
Const MAX_PROJECT     = 50		' Max Project Name Length
Const MAX_LOCATION    = 300
Const MAX_DESTINATION_BUFFER = &h1000	' Max Length of All Destinations
Const MAX_ROUTE_NAME  = 50		' Max Route Name Length
Const MAX_REPLID	     = 40		' Max Length of Replication ID GUID
Const MAX_PARM_STRING = 300		' Max Length of Parameter/Property Name


'
' Replication Flags
'
' Note: 'Or' the values together to use combinations, e.g. (RF_FASTMODE Or RF_FORCE_REPL)
'
Const RF_NO_DELETE	= &H1		' Turns off Delete Processing
Const RF_REPLICATE_ACLS	= &H2		' Replicates ACLs
Const RF_NO_DATA		= &H4		' Skips replicating Data, will only replicate directories.
Const RF_FORCE_REPL	= &H8		' Forces data to be replicated without checking first if files exist on destination
Const RF_PERMIT_TREE	= &H10		' Applies ACLs on the directory structure to the files beneath it
Const RF_IN_PROC		= &H20		' Causes the StartReplication API to run in process (note: This blocks!)
Const RF_INCREMENTAL	= &H40		' Runs replication in "Incremental" mode, meaning that only files which have been locally detected to have been modified since the last replication are checked and sent
Const RF_FASTMODE	= &H80		' Uses Unframed Protocol for enhanced performance over faster/secure links
Const RF_ON_DIR_CHANGE	= &H100		' Turns on monitor mode.  This will monitor a directory for changes and then replicate them to the destination
Const RF_AUTO_ROUTE	= &H200		' Uses information in the routing table to determine destination servers
Const RF_ON_NOTIFY	= &H400
Const RF_NO_CHAIN	= &H800
Const RF_EXCLUDE_ALL	= &H1000	' Exclude all subdirectories
Const RF_UNINSTALL	= &H2000		' Used for Component Deployment projects (project type = 'ACTIVE')
Const RF_ACLS_ONLY	= &H4000	' Only Replicate the ACLs

Const RF_DELETE		= &H10000	' Disables RF_NO_DELETE
Const RF_NO_REPLICATE_ACLS = &H20000	' Disables RF_REPLICATE_ACLS
Const RF_DATA		= &H40000	' Disables RF_NO_DATA
Const RF_NO_FORCE_REPL	= &H80000	' Disables RF_FORCE_REPL
Const RF_NO_PERMIT_TREE	= &H100000	' Disables RF_PERMIT_TREE
Const RF_NO_IN_PROC	= &H200000	' Disables RF_IN_PROC
Const RF_NO_INCREMENTAL	= &H400000	' Disables RF_INCREMENTAL
Const RF_NO_FASTMODE	= &H800000	' Disables RF_FASTMODE
Const RF_NO_ON_DIR_CHANGE = &H1000000	' Disables RF_ON_DIR_CHANGE
Const RF_NO_AUTO_ROUTE	= &H2000000	' Disables RF_AUTO_ROUTE
Const RF_NO_ON_NOTIFY	= &H4000000	' Disables RF_ON_NOTIFY
Const RF_CHAIN		= &H8000000	' Disables RF_ON_CHAIN
Const RF_NO_ACLS_ONLY	= &H40000000	' Disables RF_ACLS_ONLY


'
' Replication State Flags
'
Const REPL_STATE_EMPTY	    = 0		' This Replication Info structure is empty
Const REPL_STATE_STARTING   = 1		' The replication is a startup state
Const REPL_STATE_RUNNING    = 2		' The replication is currently running
Const REPL_STATE_COMPLETE   = 3		' The replication is complete
Const REPL_STATE_ABORTED    = 4		' The replication aborted due to an error
Const REPL_STATE_CANCELED   = 5		' The replication was canceled
Const REPL_STATE_RECEIVING  = 6		' The replication is receiving data
Const REPL_STATE_PENDING    = 7		' The replication is pending
Const REPL_STATE_PARTIAL    = 8		' The replication completed with errors


'
' AccessMask Flags
'
Const CRS_USER_ACCESS	= &H20019	' KEY_READ
Const CRS_ADMIN_ACCESS	= &HF003F	' KEY_ALL_ACCESS Or READ_CONTROL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _MAC
#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif
#endif  /* ndef _MAC */


#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern unsigned short _ctype[];
_CRTIMP extern unsigned short *_pctype;
#ifndef _MAC
_CRTIMP extern wctype_t *_pwctype;
#endif  /* ndef _MAC */
#endif  /* _CTYPE_DISABLE_MACROS */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif


#ifndef _MAC
#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif
#endif  /* ndef _MAC */


/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX

#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;

#endif  /* MB_CUR_MAX */

#ifdef  _MAC

#ifndef __cplusplus
#define isalpha(_c)     ( _pctype[_c] & (_UPPER|_LOWER) )
#define isupper(_c)     ( _pctype[_c] & _UPPER )
#define islower(_c)     ( _pctype[_c] & _LOWER )
#define isdigit(_c)     ( _pctype[_c] & _DIGIT )
#define isxdigit(_c)    ( _pctype[_c] & _HEX )
#define isspace(_c)     ( _pctype[_c] & _SPACE )
#define ispunct(_c)     ( _pctype[_c] & _PUNCT )
#define isalnum(_c)     ( _pctype[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c)     ( _pctype[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c)     ( _pctype[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c)     ( _pctype[_c] & _CONTROL )
#elif 0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)      {return (_pctype[_C] & (_UPPER|_LOWER)); }
inline int isupper(int _C)      {return (_pctype[_C] & _UPPER); }
inline int islower(int _C)      {return (_pctype[_C] & _LOWER); }
inline int isdigit(int _C)      {return (_pctype[_C] & _DIGIT); }
inline int isxdigit(int _C)     {return (_pctype[_C] & _HEX); }
inline int isspace(int _C)      {return (_pctype[_C] & _SPACE); }
inline int ispunct(int _C)      {return (_pctype[_C] & _PUNCT); }
inline int isalnum(int _C)      {return (_pctype[_C] & (_UPPER|_LOWER|_DIGIT)); }
inline int isprint(int _C)
        {return (_pctype[_C] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT)); }
inline int isgraph(int _C)
        {return (_pctype[_C] & (_PUNCT|_UPPER|_LOWER|_DIGIT)); }
inline int iscntrl(int _C)      {return (_pctype[_C] & _CONTROL); }
#endif  /* __cplusplus */

#else   /* ndef _MAC */

#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : _pctype[_c] & _ALPHA)
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : _pctype[_c] & _UPPER)
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : _pctype[_c] & _LOWER)
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : _pctype[_c] & _DIGIT)
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : _pctype[_c] & _HEX)
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : _pctype[_c] & _SPACE)
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : _pctype[_c] & _PUNCT)
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : _pctype[_c] & (_ALPHA|_DIGIT))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_PUNCT|_ALPHA|_DIGIT))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : _pctype[_c] & _CONTROL)
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : _pctype[_C] & _ALPHA); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : _pctype[_C] & _UPPER); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : _pctype[_C] & _LOWER); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : _pctype[_C] & _DIGIT); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : _pctype[_C] & _HEX); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : _pctype[_C] & _SPACE); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : _pctype[_C] & _PUNCT); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : _pctype[_C] & (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : _pctype[_C] & (_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : _pctype[_C] & (_PUNCT|_ALPHA|_DIGIT)); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : _pctype[_C] & _CONTROL); }
#endif  /* __cplusplus */

#endif  /* _MAC */

#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3d8-xbox.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8.h
 *  Content:    Xbox Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D8_H_
#define _D3D8_H_

#pragma warning( push )
#pragma warning( disable : 4100 ) // unreferenced formal parameter

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

#ifndef D3DINLINE
#define D3DINLINE static __forceinline
#endif

#ifndef D3DMINLINE
#define D3DMINLINE __forceinline
#endif

#define D3DFASTCALL __fastcall

#define D3D_SDK_VERSION 0

#include <stdlib.h>

typedef struct Direct3D                  Direct3D;
typedef struct D3DDevice                 D3DDevice;
typedef struct D3DResource               D3DResource;
typedef struct D3DBaseTexture            D3DBaseTexture;
typedef struct D3DTexture                D3DTexture;
typedef struct D3DVolumeTexture          D3DVolumeTexture;
typedef struct D3DCubeTexture            D3DCubeTexture;
typedef struct D3DVertexBuffer           D3DVertexBuffer;
typedef struct D3DIndexBuffer            D3DIndexBuffer;
typedef struct D3DPalette                D3DPalette;
typedef struct D3DSurface                D3DSurface;
typedef struct D3DVolume                 D3DVolume;
typedef struct D3DPushBuffer             D3DPushBuffer;
typedef struct D3DFixup                  D3DFixup;

// Compatibility typedefs.

#define IDirect3D8                       Direct3D
#define IDirect3DDevice8                 D3DDevice
#define IDirect3DResource8               D3DResource
#define IDirect3DBaseTexture8            D3DBaseTexture
#define IDirect3DTexture8                D3DTexture
#define IDirect3DVolumeTexture8          D3DVolumeTexture
#define IDirect3DCubeTexture8            D3DCubeTexture
#define IDirect3DVertexBuffer8           D3DVertexBuffer
#define IDirect3DIndexBuffer8            D3DIndexBuffer
#define IDirect3DPalette8                D3DPalette
#define IDirect3DSurface8                D3DSurface
#define IDirect3DVolume8                 D3DVolume
#define IDirect3DPushBuffer8             D3DPushBuffer
#define IDirect3DFixup8                  D3DFixup

// Pointer typedefs.

typedef struct Direct3D                  *LPDIRECT3D8,              *PDIRECT3D8;
typedef struct D3DDevice                 *LPDIRECT3DDEVICE8,        *PDIRECT3DDEVICE8;
typedef struct D3DResource               *LPDIRECT3DRESOURCE8,      *PDIRECT3DRESOURCE8;
typedef struct D3DBaseTexture            *LPDIRECT3DBASETEXTURE8,   *PDIRECT3DBASETEXTURE8;
typedef struct D3DTexture                *LPDIRECT3DTEXTURE8,       *PDIRECT3DTEXTURE8;
typedef struct D3DVolumeTexture          *LPDIRECT3DVOLUMETEXTURE8, *PDIRECT3DVOLUMETEXTURE8;
typedef struct D3DCubeTexture            *LPDIRECT3DCUBETEXTURE8,   *PDIRECT3DCUBETEXTURE8;
typedef struct D3DVertexBuffer           *LPDIRECT3DVERTEXBUFFER8,  *PDIRECT3DVERTEXBUFFER8;
typedef struct D3DIndexBuffer            *LPDIRECT3DINDEXBUFFER8,   *PDIRECT3DINDEXBUFFER8;
typedef struct D3DPalette                *LPDIRECT3DPALETTE8,       *PDIRECT3DPALETTE8;
typedef struct D3DSurface                *LPDIRECT3DSURFACE8,       *PDIRECT3DSURFACE8;
typedef struct D3DVolume                 *LPDIRECT3DVOLUME8,        *PDIRECT3DVOLUME8;
typedef struct D3DPushBuffer             *LPDIRECT3DPUSHBUFFER8,    *PDIRECT3DPUSHBUFFER8;
typedef struct D3DFixup                  *LPDIRECT3DFIXUP8,         *PDIRECT3DFIXUP8;


#include "d3d8types-xbox.h"
#include "d3d8caps.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The XBOX implementation of Direct3DCreate8 exists only for backwards
 * compatibility.
 *
 * There is no need to store the result of this function call.  You can
 * pass 'NULL' for the Direct3D 'this' pointer as it is completely
 * ignored.
 */

Direct3D * WINAPI Direct3DCreate8(UINT SDKVersion);

/****************************************************************************
 *
 * Parameter for Direct3D Enum and GetCaps8 functions to get the info for
 * the current mode only.
 *
 ****************************************************************************/

#define D3DCURRENT_DISPLAY_MODE                 0x00EFFFFFL

/****************************************************************************
 *
 * Flags for Direct3D::CreateDevice's BehaviorFlags
 *
 ****************************************************************************/

#define D3DCREATE_PUREDEVICE                    0x00000010L
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING     0x00000020L
#define D3DCREATE_HARDWARE_VERTEXPROCESSING     0x00000040L
#define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L

// D3DCREATE_FPU_PRESERVE is not supported on Xbox
// D3DCREATE_MULTITHREADED is not supported on Xbox

/****************************************************************************
 *
 * Parameter for Direct3D::CreateDevice's Adapter
 *
 ****************************************************************************/

#define D3DADAPTER_DEFAULT                     0

/****************************************************************************
 *
 * Flags for Direct3D::EnumAdapters
 *
 ****************************************************************************/

#define D3DENUM_NO_WHQL_LEVEL                   0x00000002L

/****************************************************************************
 *
 * Maximum number of back-buffers supported in DX8
 *
 ****************************************************************************/

#define D3DPRESENT_BACK_BUFFERS_MAX             2L

/****************************************************************************
 *
 * Flags for D3DDevice::SetGammaRamp
 *
 ****************************************************************************/

#define D3DSGR_NO_CALIBRATION                  0x00000000L
#define D3DSGR_CALIBRATE                       0x00000001L
#define D3DSGR_IMMEDIATE                       0x00000002L

/****************************************************************************
 * Flags for SetPrivateData method on all D3D8 interfaces
 *
 * The passed pointer is an IUnknown ptr. The SizeOfData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). Direct3D will call AddRef through this
 * pointer and Release when the private data is destroyed. The data will be
 * destroyed when another SetPrivateData with the same GUID is set, when
 * FreePrivateData is called, or when the D3D8 object is freed.
 ****************************************************************************/

#define D3DSPD_IUNKNOWN                         0x00000001L

/*
 *  DirectDraw error codes
 */

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

/*
 * Direct3D Errors
 */

#define D3D_OK                              S_OK

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)
#define D3DERR_TESTINCOMPLETE                   MAKE_D3DHRESULT(2088) // Xbox extension
#define D3DERR_BUFFERTOOSMALL                   MAKE_D3DHRESULT(2089) // Xbox extension

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)

/****************************************************************************
 *
 * BeginStateBlock/EndStateBlock semantics require that D3D have the ability
 * to record all API state-changing calls in a state block.  Rather than add 
 * a time-consuming are-we-recording-a-state-block check to every SetRenderState 
 * and SetTextureStageState call that would slow callers even if they never 
 * used BeginStateBlock/EndStateBlock, we've placed that logic inline so that 
 * it can be eliminated if not needed by the title.
 *
 * To enable BeginStateBlock/EndStateBlock, define the following before
 * including xtl.h.  This needs to be done for all modules that can change
 * state that should be recorded by BeginStateBlock.
 *
 *      #define D3DCOMPILE_BEGINSTATEBLOCK 1
 *
 ****************************************************************************/

typedef enum _D3DSTATEBLOCKDIRTYINDEX
{
    D3DSBD_TEXTURES              = 0, 
    D3DSBD_PIXELSHADER           = D3DSBD_TEXTURES + D3DTSS_MAXSTAGES,
    D3DSBD_VERTEXSHADER          = D3DSBD_PIXELSHADER + 1,
    D3DSBD_INDICES               = D3DSBD_VERTEXSHADER + 1,
    D3DSBD_STREAMS               = D3DSBD_INDICES + 1,
    D3DSBD_PIXELSHADERCONSTANTS  = D3DSBD_STREAMS + D3DVS_STREAMS_MAX_V1_0,
    D3DSBD_VERTEXSHADERCONSTANTS = D3DSBD_PIXELSHADERCONSTANTS + D3DPS_CONSTREG_MAX_DX8,
    D3DSBD_RENDERSTATES          = D3DSBD_VERTEXSHADERCONSTANTS + D3DVS_CONSTREG_COUNT_XBOX,
    D3DSBD_TEXTURESTATES         = D3DSBD_RENDERSTATES + D3DRS_MAX,
    D3DSBD_TRANSFORMS            = D3DSBD_TEXTURESTATES + (D3DTSS_MAXSTAGES * D3DTSS_MAX),
    D3DSBD_VIEWPORT              = D3DSBD_TRANSFORMS + D3DTS_MAX,
    D3DSBD_MATERIAL              = D3DSBD_VIEWPORT + 1,
    D3DSBD_BACKMATERIAL          = D3DSBD_MATERIAL + 1,
    D3DSBD_MAX                   = D3DSBD_BACKMATERIAL + 1,
    D3DSBD_FORCE_DWORD           = 0x7fffffff, // force 32-bit size enum
} D3DSTATEBLOCKDIRTYINDEX;

#ifdef D3DCOMPILE_BEGINSTATEBLOCK
        
    #define D3DDIRTY_TEXTURE(stage)                                         \
        { D3D__StateBlockDirty[D3DSBD_TEXTURES + (stage)] = TRUE; }
        
    #define D3DDIRTY_PIXELSHADER()                                          \
        { D3D__StateBlockDirty[D3DSBD_PIXELSHADER] = TRUE; }
        
    #define D3DDIRTY_VERTEXSHADER()                                         \
        { D3D__StateBlockDirty[D3DSBD_VERTEXSHADER] = TRUE; }
        
    #define D3DDIRTY_INDICES()                                              \
        { D3D__StateBlockDirty[D3DSBD_INDICES] = TRUE; }
        
    #define D3DDIRTY_STREAM(stream)                                         \
        { D3D__StateBlockDirty[D3DSBD_STREAMS + (stream)] = TRUE; }
        
    #define D3DDIRTY_PIXELSHADERCONSTANT(index, count)                      \
        { memset(&D3D__StateBlockDirty[D3DSBD_PIXELSHADERCONSTANTS + (index)], TRUE, (count)); }
        
    #define D3DDIRTY_VERTEXSHADERCONSTANT(index, count)                     \
        { memset(&D3D__StateBlockDirty[D3DSBD_VERTEXSHADERCONSTANTS + (index) + 96], TRUE, (count)); }
                          
    #define D3DDIRTY_RENDERSTATE(state)                                     \
        { D3D__StateBlockDirty[D3DSBD_RENDERSTATES + (state)] = TRUE; }
    
    #define D3DDIRTY_TEXTURESTATE(stage, state)                             \
        { D3D__StateBlockDirty[D3DSBD_TEXTURESTATES +                       \
                          ((state) * D3DTSS_MAXSTAGES) + (stage)] = TRUE; } 
        
    #define D3DDIRTY_TRANSFORM(transform)                                   \
        { D3D__StateBlockDirty[D3DSBD_TRANSFORMS + (transform)] = TRUE; }
        
    #define D3DDIRTY_VIEWPORT()                                             \
        { D3D__StateBlockDirty[D3DSBD_VIEWPORT] = TRUE; }
        
    #define D3DDIRTY_MATERIAL()                                             \
        { D3D__StateBlockDirty[D3DSBD_MATERIAL] = TRUE; }
        
    #define D3DDIRTY_BACKMATERIAL()                                         \
        { D3D__StateBlockDirty[D3DSBD_BACKMATERIAL] = TRUE; }
    
#else
        
    #define D3DDIRTY_TEXTURE(stage)
    #define D3DDIRTY_PIXELSHADER()                                         
    #define D3DDIRTY_VERTEXSHADER()                                        
    #define D3DDIRTY_INDICES()                                             
    #define D3DDIRTY_STREAM(stream)                                         
    #define D3DDIRTY_PIXELSHADERCONSTANT(index, count)                         
    #define D3DDIRTY_VERTEXSHADERCONSTANT(index, count)                        
    #define D3DDIRTY_RENDERSTATE(state)                                    
    #define D3DDIRTY_TEXTURESTATE(stage, state)                            
    #define D3DDIRTY_TRANSFORM(transform)                                  
    #define D3DDIRTY_VIEWPORT()
    #define D3DDIRTY_MATERIAL()                                            
    #define D3DDIRTY_BACKMATERIAL()                                            

#endif

/****************************************************************************
 *
 * __declspec(selectany) has the lovely attribute that it allows the linker
 * to remove duplicate instantiations of global declarations, and to remove
 * the instantiation entirely if unreferenced.
 *
 ****************************************************************************/

#define D3DCONST extern CONST DECLSPEC_SELECTANY

/****************************************************************************
 *
 * Private internal data - Please don't access these directly, as they're
 *                         subject to change.
 *
 ****************************************************************************/

D3DCONST UINT D3DPRIMITIVETOVERTEXCOUNT[11][2] =
{
    {0, 0},         // Illegal
    {1, 0},         // D3DPT_POINTLIST     = 1,
    {2, 0},         // D3DPT_LINELIST      = 2,
    {1, 1},         // D3DPT_LINELOOP      = 3,
    {1, 1},         // D3DPT_LINESTRIP     = 4,
    {3, 0},         // D3DPT_TRIANGLELIST  = 5,
    {1, 2},         // D3DPT_TRIANGLESTRIP = 6,
    {1, 2},         // D3DPT_TRIANGLEFAN   = 7,
    {4, 0},         // D3DPT_QUADLIST      = 8,
    {2, 2},         // D3DPT_QUADSTRIP     = 9,
    {0, 0},         // Illegal (D3DPT_POLYGON)
};

D3DCONST DWORD D3DSIMPLERENDERSTATEENCODE[] =
{                                          
    0x040260,    0x040264,    0x040268,    0x04026c,    // 0
    0x040270,    0x040274,    0x040278,    0x04027c,    // 4
    0x040288,    0x04028c,    0x040a60,    0x040a64,    // 8
    0x040a68,    0x040a6c,    0x040a70,    0x040a74,    // 12
    0x040a78,    0x040a7c,    0x040a80,    0x040a84,    // 16
    0x040a88,    0x040a8c,    0x040a90,    0x040a94,    // 20
    0x040a98,    0x040a9c,    0x040aa0,    0x040aa4,    // 24
    0x040aa8,    0x040aac,    0x040ab0,    0x040ab4,    // 28
    0x040ab8,    0x040abc,    0x040ac0,    0x040ac4,    // 32
    0x040ac8,    0x040acc,    0x040ad0,    0x040ad4,    // 36
    0x040ad8,    0x040adc,    0x0417f8,    0x041e20,    // 40
    0x041e24,    0x041e40,    0x041e44,    0x041e48,    // 44
    0x041e4c,    0x041e50,    0x041e54,    0x041e58,    // 48
    0x041e5c,    0x041e60,    0x041d90,    0x041e74,    // 52
    0x041e78,    0x040354,    0x04033c,    0x040304,    // 56
    0x040300,    0x040340,    0x040344,    0x040348,    // 60
    0x04035c,    0x040310,    0x04037c,    0x040358,    // 64
    0x040374,    0x040378,    0x040364,    0x040368,    // 68
    0x04036c,    0x040360,    0x040350,    0x04034c,    // 72
    0x0409f8,    0x040384,    0x040388,    0x040330,    // 76
    0x040334,    0x040338,    
};

D3DCONST DWORD D3DTEXTUREDIRECTENCODE[] =
{ 
    0x081b00,    0x081b40,    0x081b80,    0x081bc0,
};
     
#define D3DDIRTYFLAG_TEXTURE_STATE                0x0000000f
#define D3DDIRTYFLAG_TEXTURE_STATE_0              0x00000001
#define D3DDIRTYFLAG_TEXTURE_STATE_1              0x00000002
#define D3DDIRTYFLAG_TEXTURE_STATE_2              0x00000004
#define D3DDIRTYFLAG_TEXTURE_STATE_3              0x00000008
#define D3DDIRTYFLAG_VERTEXFORMAT                 0x00000070
#define D3DDIRTYFLAG_VERTEXFORMAT_VB              0x00000010
#define D3DDIRTYFLAG_VERTEXFORMAT_UP              0x00000020
#define D3DDIRTYFLAG_VERTEXFORMAT_OFFSETS         0x00000040
#define D3DDIRTYFLAG_POINTPARAMS                  0x00000100
#define D3DDIRTYFLAG_TRANSFORM                    0x00000200
#define D3DDIRTYFLAG_TEXTURE_TRANSFORM            0x00000400
#define D3DDIRTYFLAG_COMBINERS                    0x00000800
#define D3DDIRTYFLAG_LIGHTS                       0x00001000
#define D3DDIRTYFLAG_SPECFOG_COMBINER             0x00002000
#define D3DDIRTYFLAG_SHADER_STAGE_PROGRAM         0x00004000

D3DCONST DWORD D3DDIRTYFROMRENDERSTATE[] =
{
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGENABLE                 
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGTABLEMODE              
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGSTART                  
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGEND                    
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGDENSITY                
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_RANGEFOGENABLE            
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP0                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP1                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP2                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP3                     
    // D3DRS_LIGHTING dirties the transform because of the inverse-model-
    // view optimization:
    (D3DDIRTYFLAG_LIGHTS | D3DDIRTYFLAG_TRANSFORM),     // D3DRS_LIGHTING                   
    (D3DDIRTYFLAG_LIGHTS | D3DDIRTYFLAG_SPECFOG_COMBINER),// D3DRS_SPECULARENABLE             
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_LOCALVIEWER                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_COLORVERTEX                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKSPECULARMATERIALSOURCE 
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKDIFFUSEMATERIALSOURCE  
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKAMBIENTMATERIALSOURCE  
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKEMISSIVEMATERIALSOURCE 
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_SPECULARMATERIALSOURCE     
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_DIFFUSEMATERIALSOURCE      
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_AMBIENTMATERIALSOURCE      
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_EMISSIVEMATERIALSOURCE     
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKAMBIENT                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_AMBIENT                    
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE                 
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE_MIN             
    (D3DDIRTYFLAG_POINTPARAMS | D3DDIRTYFLAG_COMBINERS),// D3DRS_POINTSPRITEENABLE         
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALEENABLE          
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_A              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_B              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_C              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE_MAX             
    0,                                                  // D3DRS_PATCHEDGESTYLE            
    0,                                                  // D3DRS_PATCHSEGMENTS             
    0,                                                  // D3DRS_MULTISAMPLEFILTER
};

D3DCONST DWORD D3DDIRTYFROMTEXTURESTATE[] =
{
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSU
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSV
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSW
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAGFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MINFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MIPFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MIPMAPLODBIAS
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAXMIPLEVEL
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAXANISOTROPY
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_COLORKEYOP
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_COLORSIGN
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ALPHAKILL
    (D3DDIRTYFLAG_COMBINERS | D3DDIRTYFLAG_SHADER_STAGE_PROGRAM | D3DDIRTYFLAG_TEXTURE_STATE),
                                                        // D3DTSS_COLOROP (special cased)
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG0           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG1           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG2           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAOP             
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG0           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG1           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG2           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_RESULTARG           
    D3DDIRTYFLAG_TEXTURE_TRANSFORM,                     // D3DTSS_TEXTURETRANSFORMFLAGS
};

// Macro for converting from primitive count to number of vertices.
//
#define D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount) \
    ((PrimitiveCount) * D3DPRIMITIVETOVERTEXCOUNT[PrimitiveType][0] + \
     + D3DPRIMITIVETOVERTEXCOUNT[PrimitiveType][1])

/****************************************************************************
 *
 * Publicly accessible globals - Feel free to modify the values.
 *
 ****************************************************************************/

// 'Extern' declaration that is both C and C++ friendly.
//
#ifdef __cplusplus
    #define D3DEXTERN extern "C"
#else
    #define D3DEXTERN extern
#endif

// Set D3D__NullHardware to TRUE to enable infinitely fast hardware (so fast 
// you can't even see the results).  This is useful for determining how CPU-
// bound your program is.
//
D3DEXTERN BOOL D3D__NullHardware; 

// Set D3D__SingleStepPusher to TRUE to cause D3D to do an implicit 
// BlockUntilIdle after every D3D API call.  This is useful for tracking
// weird hardware crashes and hangs down to the problem API call.
// 
D3DEXTERN BOOL D3D__SingleStepPusher;

/****************************************************************************
 *
 * Private D3D globals - Please don't use these directly, as they're subject
 *                       subject to change.
 *
 ****************************************************************************/

// This array marks what APIs have been called when recording state blocks:
//
D3DEXTERN BYTE D3D__StateBlockDirty[];

// This array shadows the current render states:
//
D3DEXTERN DWORD D3D__RenderState[D3DRS_MAX];

// This array shadows the current texture stage states:
//
D3DEXTERN DWORD D3D__TextureState[D3DTSS_MAXSTAGES][D3DTSS_MAX];

// This array contains the dirty flags for deferred render and texture states:
//
D3DEXTERN DWORD D3D__DirtyFlags;

// This points to the data of the currently selected index buffer.  This is
// used for converting Draw[Indexed]Primitive calls to Draw[Indexed]Vertices
// calls inline.
//
D3DEXTERN WORD* D3D__IndexData;

/****************************************************************************
 *
 * Miscellaneous public defines
 *
 ****************************************************************************/

// The required alignment for any memory that is going to be
// rendered to from the hardware.
//
#define D3D_RENDER_MEMORY_ALIGNMENT           64

// The required alignment for any memory that is tiled, including the
// default frame buffers and depth buffer.
//
#define D3D_TILED_SURFACE_ALIGNMENT           0x4000

// Types of our DPC-level callback functions.
//
typedef void (__cdecl * D3DCALLBACK)(DWORD Context);
typedef void (__cdecl * D3DVBLANKCALLBACK)(D3DVBLANKDATA *pData);
typedef void (__cdecl * D3DSWAPCALLBACK)(D3DSWAPDATA *pData);

/*
 * NOTE: The C version of the methods for all of these interfaces
 *       are named "<interfacename>_<method name>" and have an 
 *       explicit pointer to the interface as the first parameter.
 *       The actual definition of these methods is at the end
 *       of this file.
 */

/*
 * Direct3D, IDirect3D8 interface
 *
 */

#ifdef __cplusplus

struct Direct3D
{
    static ULONG WINAPI AddRef();
    static ULONG WINAPI Release();

    static UINT WINAPI GetAdapterCount();

    static HRESULT WINAPI GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier);
    static UINT    WINAPI GetAdapterModeCount(UINT Adapter);
    static HRESULT WINAPI EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
    static HRESULT WINAPI CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
    static HRESULT WINAPI CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
    static HRESULT WINAPI CheckDepthStencilMatch(UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat);
    static HRESULT WINAPI GetDeviceCaps(UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps);
    static HRESULT WINAPI CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface);
    static HRESULT WINAPI SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize); // Xbox extension
};

#endif __cplusplus

/*
 * D3DDevice, IDirect3DDevice8 interface
 */

#ifdef __cplusplus

struct D3DDevice
{
    // Standard D3D APIs:

    static ULONG WINAPI AddRef();
    static ULONG WINAPI Release();
    static HRESULT WINAPI GetDirect3D(Direct3D **ppD3D8);
    static HRESULT WINAPI GetDeviceCaps(D3DCAPS8 *pCaps);
    static HRESULT WINAPI GetDisplayMode(D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters);
    static HRESULT WINAPI Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
    static HRESULT WINAPI Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2);
    static HRESULT WINAPI GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer);
    static HRESULT WINAPI GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);
    static void    WINAPI SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp);
    static void    WINAPI GetGammaRamp(D3DGAMMARAMP *pRamp);
    static HRESULT WINAPI CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture);
    static HRESULT WINAPI CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture);
    static HRESULT WINAPI CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture);
    static HRESULT WINAPI CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer);
    static HRESULT WINAPI CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer);
    static HRESULT WINAPI CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface);
    static HRESULT WINAPI CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface);
    static HRESULT WINAPI CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface);
    static HRESULT WINAPI CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray);
    static HRESULT WINAPI SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil);
    static HRESULT WINAPI GetRenderTarget(D3DSurface **ppRenderTarget);
    static HRESULT WINAPI GetDepthStencilSurface(D3DSurface **ppZStencilSurface);
    static HRESULT WINAPI BeginScene();
    static HRESULT WINAPI EndScene();
    static HRESULT WINAPI Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
    static HRESULT WINAPI SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    static HRESULT WINAPI GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
    static HRESULT WINAPI MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    static HRESULT WINAPI SetViewport(CONST D3DVIEWPORT8 *pViewport);
    static HRESULT WINAPI GetViewport(D3DVIEWPORT8 *pViewport);
    static HRESULT WINAPI SetMaterial(CONST D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI GetMaterial(D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
    static HRESULT WINAPI GetLight(DWORD Index, D3DLIGHT8 *pLight);
    static HRESULT WINAPI LightEnable(DWORD Index, BOOL Enable);
    static HRESULT WINAPI GetLightEnable(DWORD Index, BOOL *pEnable);
    static HRESULT WINAPI SetRenderState(D3DRENDERSTATETYPE State, DWORD Value);
    static HRESULT WINAPI GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue);
#if D3DCOMPILE_BEGINSTATEBLOCK
    static HRESULT WINAPI BeginStateBlock();
    static HRESULT WINAPI EndStateBlock(DWORD *pToken);
#endif
    static HRESULT WINAPI ApplyStateBlock(DWORD Token);
    static HRESULT WINAPI CaptureStateBlock(DWORD Token);
    static HRESULT WINAPI DeleteStateBlock(DWORD Token);
    static HRESULT WINAPI CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);
    static HRESULT WINAPI GetTexture(DWORD Stage, D3DBaseTexture **ppTexture);
    static HRESULT WINAPI SetTexture(DWORD Stage, D3DBaseTexture *pTexture);
    static HRESULT WINAPI GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue);
    static HRESULT WINAPI SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
    static HRESULT WINAPI DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount);
    static HRESULT WINAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount);
    static HRESULT WINAPI DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
    static HRESULT WINAPI SetVertexShader(DWORD Handle);
    static HRESULT WINAPI GetVertexShader(DWORD *pHandle);
    static HRESULT WINAPI DeleteVertexShader(DWORD Handle);
    static HRESULT WINAPI SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
    static HRESULT WINAPI GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
    static HRESULT WINAPI SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride);
    static HRESULT WINAPI GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride);
    static HRESULT WINAPI SetIndices(D3DIndexBuffer *pIndexData, UINT BaseVertexIndex);
    static HRESULT WINAPI GetIndices(D3DIndexBuffer **ppIndexData, UINT *pBaseVertexIndex);
    static HRESULT WINAPI CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle);
    static HRESULT WINAPI SetPixelShader(DWORD Handle);
    static HRESULT WINAPI SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef);
    static HRESULT WINAPI GetPixelShader(DWORD *pHandle);
    static HRESULT WINAPI DeletePixelShader(DWORD Handle);
    static HRESULT WINAPI SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData);
    static HRESULT WINAPI DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
    static HRESULT WINAPI DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
    static HRESULT WINAPI DeletePatch(UINT Handle);

    // The following APIs are all Xbox extensions:

    static HRESULT WINAPI SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode);
    static HRESULT WINAPI GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode);
    static HRESULT WINAPI LoadVertexShader(DWORD Handle, DWORD Address);
    static HRESULT WINAPI LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address);
    static HRESULT WINAPI SelectVertexShader(DWORD Handle, DWORD Address);
    static HRESULT WINAPI SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address);
    static HRESULT WINAPI RunVertexStateShader(DWORD Address, CONST float *pData);
    static HRESULT WINAPI GetVertexShaderSize(DWORD Handle, UINT *pSize);
    static HRESULT WINAPI GetVertexShaderType(DWORD Handle, DWORD *pType);
    static HRESULT WINAPI DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount);
    static HRESULT WINAPI DrawIndexedVertices(D3DPRIMITIVETYPE, UINT VertexCount, CONST WORD *pIndexData);
    static HRESULT WINAPI DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData);
    static HRESULT WINAPI CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette);
    static HRESULT WINAPI GetPalette(DWORD Stage, D3DPalette **ppPalette);
    static HRESULT WINAPI SetPalette(DWORD Stage, D3DPalette *pPalette);
    static HRESULT WINAPI SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
    static HRESULT WINAPI SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value);
    static HRESULT WINAPI SetBackMaterial(CONST D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI GetBackMaterial(D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey);
    static HRESULT WINAPI EnableOverlay(BOOL Enable);
    static HRESULT WINAPI BeginVisibilityTest();
    static HRESULT WINAPI EndVisibilityTest(DWORD Index);
    static HRESULT WINAPI GetVisibilityTestResult(DWORD Index, UINT* pResult, ULONGLONG* pTimeStamp);
    static BOOL    WINAPI GetOverlayUpdateStatus();
    static HRESULT WINAPI GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus);
    static HRESULT WINAPI SetVertexData2f(INT Register, float a, float b);
    static HRESULT WINAPI SetVertexData4f(INT Register, float a, float b, float c, float d);
    static HRESULT WINAPI SetVertexData2s(INT Register, SHORT a, SHORT b);
    static HRESULT WINAPI SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d);
    static HRESULT WINAPI SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d);
    static HRESULT WINAPI SetVertexDataColor(INT Register, D3DCOLOR Color);
    static HRESULT WINAPI Begin(D3DPRIMITIVETYPE PrimitiveType);
    static HRESULT WINAPI End();
    static HRESULT WINAPI CreateFixup(UINT Size, D3DFixup **ppFixup);
    static HRESULT WINAPI CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer);
    static HRESULT WINAPI BeginPushBuffer(D3DPushBuffer *pPushBuffer);
    static HRESULT WINAPI EndPushBuffer();
    static HRESULT WINAPI RunPushBuffer(D3DPushBuffer* pPushBuffer, D3DFixup *pFixup);
    static HRESULT WINAPI GetPushBufferOffset(DWORD* pOffset);
    static HRESULT WINAPI Nop();
    static HRESULT WINAPI GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
    static HRESULT WINAPI GetModelView(D3DMATRIX* pModelView);
    static HRESULT WINAPI SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI SwitchTexture(DWORD Stage, D3DBaseTexture *pTexture);
    static HRESULT WINAPI Suspend();
    static HRESULT WINAPI Resume(BOOL Reset);
    static HRESULT WINAPI SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects);
    static HRESULT WINAPI GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects);
    static HRESULT WINAPI SetTile(DWORD Index, CONST D3DTILE* pTile);
    static HRESULT WINAPI GetTile(DWORD Index, D3DTILE* pTile);
    static DWORD   WINAPI GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag);
    static void    WINAPI SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count);
    static void    WINAPI GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
    static HRESULT WINAPI BeginPush(DWORD Count, DWORD **ppPush);
    static HRESULT WINAPI EndPush(DWORD *pPush);
    static BOOL    WINAPI IsBusy();
    static void    WINAPI BlockUntilIdle();
    static void    WINAPI KickPushBuffer();
    static void    WINAPI SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback);
    static void    WINAPI SetSwapCallback(D3DSWAPCALLBACK pCallback);
    static void    WINAPI BlockUntilVerticalBlank();
    static DWORD   WINAPI InsertFence();
    static BOOL    WINAPI IsFencePending(DWORD Fence);
    static VOID    WINAPI BlockOnFence(DWORD Fence);
    static VOID    WINAPI InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context);
    static VOID    WINAPI FlushVertexCache();
    static void    WINAPI SetFlickerFilter(DWORD Filter);
    static void    WINAPI SetSoftDisplayFilter(BOOL Enable);
    static HRESULT WINAPI SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState);
    static HRESULT WINAPI GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState);
    static HRESULT WINAPI PersistDisplay();
    static HRESULT WINAPI GetPersistedSurface(IDirect3DSurface8 **ppSurface);
    static DWORD   WINAPI Swap(DWORD Flags);
    static HRESULT WINAPI SetBackBufferScale(float x, float y);
    static HRESULT WINAPI GetBackBufferScale(float *pX, float *pY);
    static HRESULT WINAPI SetScreenSpaceOffset(float x, float Y);
    static HRESULT WINAPI GetScreenSpaceOffset(float *pX, float *pY);
    static void    WINAPI SetOverscanColor(D3DCOLOR Color);
    static D3DCOLOR WINAPI GetOverscanColor();
    static DWORD   WINAPI SetDebugMarker(DWORD Marker);
    static DWORD   WINAPI GetDebugMarker();
};

#endif __cplusplus

/*
 * D3DResource, IDirect3DResource8 interface
 *
 * The root structure of all D3D 'resources' such as textures and vertex buffers.
 */

#define D3DCOMMON_REFCOUNT_MASK      0x0000FFFF

#define D3DCOMMON_TYPE_MASK          0x00070000
#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PUSHBUFFER    0x00020000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_TYPE_FIXUP         0x00060000

#define D3DCOMMON_INTREFCOUNT_MASK   0x00780000
#define D3DCOMMON_INTREFCOUNT_SHIFT  19

// This flag was used for UMA emulation on pre-Beta development kit
// machines, and is deprecated on the final hardware.
//
#define D3DCOMMON_VIDEOMEMORY        0

// Internal flag to indicate that this resource was created by Direct3D 
//
#define D3DCOMMON_D3DCREATED         0x01000000

// The rest of the bits may be used by derived classes.
#define D3DCOMMON_UNUSED_MASK        0xFE000000
#define D3DCOMMON_UNUSED_SHIFT       25

#ifdef __cplusplus

struct D3DResource
{
    ULONG WINAPI AddRef();

    // DOC:  If the GPU is currently using this object when the last call 
    //   to release is made then this call will block until the GPU is done 
    //   with this object.  The caller will have to manually check this if 
    //   they do not want this call to block.
    //
    ULONG WINAPI Release();

    HRESULT WINAPI GetDevice(D3DDevice **ppDevice);
    D3DRESOURCETYPE WINAPI GetType();

    HRESULT WINAPI SetPrivateData(REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags);
    HRESULT WINAPI GetPrivateData(REFGUID refguid, void *pData, DWORD *pSizeOfData);
    HRESULT WINAPI FreePrivateData(REFGUID refguid);

    // DOC: This additional method returns TRUE if the data for this
    //  : resource is currently being used by the GPU.  This can be used
    //  : to avoid blocking in Release and Lock.  This will always return
    //  : TRUE if the resource is currently set on the device.
    //
    BOOL WINAPI IsBusy();

    // DOC: A blocking form of 'IsBusy' that ensure that this resource is
    //  : no longer used by the GPU.  This will wait for the GPU to go
    //  : idle if this resource is set on the device.
    //
    void    WINAPI BlockUntilNotBusy();

    // DOC: On pre-beta development kits, this API set whether the we should 
    //  ; use video or AGP memory for the data of this resource.  
    //  ;
    //  ; This API has been deprecated on the final hardware.
    //
    void    WINAPI MoveResourceMemory(D3DMEMORY where);

    // DOC: Performs some debug checks and maps the resource's 
    //  : data field from a contiguous memory address to the physical memory
    //  : address.  It should be called for any resource that is not created
    //  : through an D3DDevice "Create" routine.
    //  :
    //  : This API does not modify any state in the resource besides the
    //  : Data field nor does the library keep track of what resources
    //  : have been registered.  
    //  :
    //  : This method takes a contiguous memory address, adds the current
    //  : contents of the Data field to it, converts it to a physical
    //  : address and sets that as the Data field of the resource.
    //
    void    WINAPI Register(void *pBase);

    // All resources need these fields.  Inherit them in C++.

    DWORD Common;           // Refcount and flags common to all resources
    DWORD Data;             // Offset to the data held by this resource
    DWORD Lock;             // Lock information, initialize to zero
};

#endif __cplusplus

/*
 * D3DPixelContainer interface
 *
 * A base structure that describes the shared layout between textures
 * and surfaces.
 */

// The layout of the Format field.

#define D3DFORMAT_RESERVED1_MASK        0x00000003      // Must be zero
                                        
#define D3DFORMAT_DMACHANNEL_MASK       0x00000003
#define D3DFORMAT_DMACHANNEL_A          0x00000001      // DMA channel A - the default for all system memory
#define D3DFORMAT_DMACHANNEL_B          0x00000002      // DMA channel B - unused
#define D3DFORMAT_CUBEMAP               0x00000004      // Set if the texture if a cube map
#define D3DFORMAT_BORDERSOURCE_COLOR    0x00000008
#define D3DFORMAT_DIMENSION_MASK        0x000000F0      // # of dimensions
#define D3DFORMAT_DIMENSION_SHIFT       4
#define D3DFORMAT_FORMAT_MASK           0x0000FF00
#define D3DFORMAT_FORMAT_SHIFT          8
#define D3DFORMAT_MIPMAP_MASK           0x000F0000 
#define D3DFORMAT_MIPMAP_SHIFT          16
#define D3DFORMAT_USIZE_MASK            0x00F00000      // Log 2 of the U size of the base texture
#define D3DFORMAT_USIZE_SHIFT           20
#define D3DFORMAT_VSIZE_MASK            0x0F000000      // Log 2 of the V size of the base texture
#define D3DFORMAT_VSIZE_SHIFT           24
#define D3DFORMAT_PSIZE_MASK            0xF0000000      // Log 2 of the P size of the base texture
#define D3DFORMAT_PSIZE_SHIFT           28

// The layout of the size field, used for non swizzled or compressed textures.
// 
// The Size field of a container will be zero if the texture is swizzled or compressed.
// It is guarenteed to be non-zero otherwise because either the height/width will be 
// greater than one or the pitch adjust will be nonzero because the minimum texture
// pitch is 8 bytes.

#define D3DSIZE_WIDTH_MASK              0x00000FFF   // Width of the texture - 1, in texels
#define D3DSIZE_HEIGHT_MASK             0x00FFF000   // Height of the texture - 1, in texels
#define D3DSIZE_HEIGHT_SHIFT            12
#define D3DSIZE_PITCH_MASK              0xFF000000   // Pitch / 64 - 1
#define D3DSIZE_PITCH_SHIFT             24

#define D3DTEXTURE_ALIGNMENT            128
#define D3DTEXTURE_CUBEFACE_ALIGNMENT   128

#define D3DTEXTURE_PITCH_ALIGNMENT 64
#define D3DTEXTURE_PITCH_MIN       64

#ifdef __cplusplus

struct D3DPixelContainer : public D3DResource
{
    DWORD Format;   // Format information about the texture.
    DWORD Size;     // Size of a non power-of-2 texture, must be zero otherwise
};

#endif __cplusplus

/*
 * D3DBaseTexture interface
 *
 * The root structure of all D3D textures.  Inherits all of the methods
 * from D3DResource.
 *
 * The data memory pointed to by the Data field must be aligned on a
 * D3DTEXTURE_ALIGNMENT byte multiple.
 */

struct D3DBaseTexture
    #ifdef __cplusplus
        : public D3DPixelContainer
    #endif
{

#ifdef __cplusplus
    DWORD WINAPI GetLevelCount();
#endif

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

    DWORD Format;   // Format information about the texture.
    DWORD Size;     // Size of a non power-of-2 texture, must be zero otherwise
#endif

};


/*
 * D3DTexture, IDirect3DTexture8 interface
 *
 * A normal texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI GetSurfaceLevel(UINT Level, D3DSurface **ppSurfaceLevel);
    HRESULT WINAPI LockRect(UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect(UINT Level);
};

#endif __cplusplus


/*
 * D3DVolumeTexture, IDirect3DVolumeTexture8 interface
 *
 * A volume texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DVolumeTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DVOLUME_DESC *pDesc);
    HRESULT WINAPI GetVolumeLevel(UINT Level, D3DVolume **ppVolumeLevel);
    HRESULT WINAPI LockBox(UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
    HRESULT WINAPI UnlockBox(UINT Level);
};

#endif __cplusplus


/*
 * D3DCubeTexture, IDirect3DCubeTexture8 interface
 *
 * A cube texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DCubeTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface);
    HRESULT WINAPI LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level);
};

#endif __cplusplus


/*
 * D3DVertexBuffer, IDirect3DVertexBuffer8 interface
 *
 * A vertex buffer.
 *
 * The data for the vertex buffer must be aligned on a 
 * D3DVERTEXBUFFER_ALIGNMENT byte multiple.
 */

#define D3DVERTEXBUFFER_ALIGNMENT     4    

struct D3DVertexBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
    HRESULT WINAPI Unlock();
    HRESULT WINAPI GetDesc(D3DVERTEXBUFFER_DESC *pDesc);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DIndexBuffer, IDirect3DIndexBuffer8 interface
 *
 * An index buffer.
 *
 * The data for the index buffer must be aligned on a D3DINDEXBUFFER_ALIGNMENT
 * byte multiple.
 */

#define D3DINDEXBUFFER_ALIGNMENT        4      

struct D3DIndexBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
    HRESULT WINAPI Unlock();
    HRESULT WINAPI GetDesc(D3DINDEXBUFFER_DESC *pDesc);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;                    
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DPalette, IDirect3DPalette8 interface
 *
 * A palette.
 */

#define D3DPALETTE_ALIGNMENT 64

#define D3DPALETTE_COMMON_VIDEOMEMORY            0
#define D3DPALETTE_COMMON_UNUSED                 0x20000000
#define D3DPALETTE_COMMON_PALETTESIZE_MASK       0xC0000000
#define D3DPALETTE_COMMON_PALETTESIZE_SHIFT      30

#define D3DPALETTE_COMMON_PALETTESET_SHIFT       28
#define D3DPALETTE_COMMON_PALETTESET_MASK        0xF

struct D3DPalette
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(D3DCOLOR **ppColors, DWORD Flags);
    HRESULT WINAPI Unlock();
    D3DPALETTESIZE WINAPI GetSize();

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DSurface, IDirect3DSurface8 interface
 *
 * Abstracts a chunk of data that can be drawn to.  The Common and Format
 * fields use the D3DCOMMON and D3DFORMAT constants defined for
 * textures.
 */

#define D3DSURFACE_ALIGNMENT    D3D_RENDER_MEMORY_ALIGNMENT
#define D3DSURFACE_OWNSMEMORY   0x80000000

struct D3DSurface
    #if defined(__cplusplus)
        : public D3DPixelContainer
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI GetContainer(D3DBaseTexture **ppBaseTexture);
    HRESULT WINAPI GetDesc(D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI LockRect(D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect();

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DPixelContainer
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format;
    DWORD Size;

#endif

    D3DBaseTexture *Parent; 
};


/*
 * D3DVolume, IDirect3DVolume8 interface
 */

#define D3DVOLUME_ALIGNMENT    D3D_RENDER_MEMORY_ALIGNMENT
#define D3DVOLUME_OWNSMEMORY   0x800000000

struct D3DVolume
    #if defined(__cplusplus)
        : public D3DPixelContainer
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI GetContainer(D3DBaseTexture **ppBaseTexture);
    HRESULT WINAPI GetDesc(D3DVOLUME_DESC *pDesc);
    HRESULT WINAPI LockBox(D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
    HRESULT WINAPI UnlockBox();

#endif

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format; 
    DWORD Size;

#endif

    D3DBaseTexture *Parent; 
};


/*
 * D3DPushBuffer, IDirect3DPushBuffer8 interface
 *
 * A push-buffer resource.
 */

#define D3DPUSHBUFFER_ALIGNMENT 4

// The following flag, when set in the Common field, dictates that when 
// RunPushBuffer is called, the push-buffer is copied using the CPU instead 
// of executed in-place by the GPU.  This should be used for small push-
// buffers to avoid the high latency cost of the GPU JUMP command.  In this
// case, the memory should be cacheable (not write-combined), and need not
// be physically contiguous.
#define D3DPUSHBUFFER_RUN_USING_CPU_COPY  0x80000000

struct D3DPushBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Verify(BOOL StampResources);
    HRESULT WINAPI BeginFixup(D3DFixup* pFixup, BOOL NoWait);
    HRESULT WINAPI EndFixup();
    HRESULT WINAPI RunPushBuffer(DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup);
    HRESULT WINAPI SetModelView(DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
    HRESULT WINAPI SetVertexBlendModelView(DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
    HRESULT WINAPI SetVertexShaderInput(DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
    HRESULT WINAPI SetVertexShaderInputDirect(DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
    HRESULT WINAPI SetRenderTarget(DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer);
    HRESULT WINAPI SetTexture(DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture);
    HRESULT WINAPI SetPalette(DWORD Offset, DWORD Stage,D3DPalette *pPalette);
    HRESULT WINAPI EndVisibilityTest(DWORD Offset, DWORD Index);
    HRESULT WINAPI SetVertexShaderConstant(DWORD Offset, INT Register, CONST VOID* pConstantData, DWORD ConstantCount);
    HRESULT WINAPI Jump(DWORD Offset, UINT DestinationOffset);
    HRESULT WINAPI GetSize(DWORD* pSize);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource.  
    //
    // Note (in an exception to all other resources) that 'Data' is a virtual 
    // address for the D3DPUSHBUFFER_RUN_USING_CPU_COPY case.
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

    // Size, in bytes, of the push-buffer program.
    DWORD Size;

    // Size, in bytes, of the allocation of the buffer pointed to by 'Data'.
    DWORD AllocationSize;
};


/*
 * D3DFixup, IFixup8 interface
 *
 * A fix-up resource for push-buffers.
 */

#define D3DFIXUP_ALIGNMENT 4

struct D3DFixup
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Reset(); 
    HRESULT WINAPI GetSize(DWORD* pSize);
    HRESULT WINAPI GetSpace(DWORD* pSpace);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource.  
    //
    // Note that 'Data' is always a virtual address.
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

    // Offset to the last completed fix-up.  RunPushBuffer uses this and 'Data'.
    DWORD Run;

    // Offset to where we'll append the next fix-up.
    DWORD Next;

    // Size of the whole allocation.
    DWORD Size;
};


/*
 * Helper methods.
 */


//----------------------------------------------------------------------------
// D3D_CopyContiguousMemory has been deprecated on the final hardware.
// Use CopyRects instead.  
//
// With the API as speced, this function was hideously expensive because 
// it had to flush the GPU's entire push-buffer, and then spin the CPU until 
// the copy was done.  CopyRects lets everything be nicely asynchronous,
// just as it is with all other GPU APIs.  
// 
// To get equivalent behavior with CopyRects, use XGSetSurfaceHeader to create
// wrapper surfaces around the memory (the pitches should equal the widths 
// times the pixel size and not be more than 8128).  Then surface.IsBusy(),
// LockRect(), and the other standard synchronization APIs may be used to
// determine when the copy is done.
//
// void WINAPI D3D_CopyContiguousMemory(
//     void *pSource,
//     void *pDest,
//     DWORD Size
//     ); 

//----------------------------------------------------------------------------
// On pre-beta development kits, this function was used to copy data
// from AGP memory to video memory.
//
// This function is deprecated on the final hardware.
//
D3DINLINE void WINAPI D3D_CopyContiguousMemoryToVideo(
    void *pMemory          // Contiguous memory block to move.
    )
{
}


/*
 * C exported method definitions for the class methods defined above and the C++
 * thunks that defer to them.
 */

/* Direct3D */

D3DINLINE ULONG   WINAPI Direct3D_AddRef() { return 1; }
D3DINLINE ULONG   WINAPI Direct3D_Release() { return 1; }
D3DINLINE UINT    WINAPI Direct3D_GetAdapterCount() { return 1; }
HRESULT WINAPI Direct3D_GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier);
UINT    WINAPI Direct3D_GetAdapterModeCount(UINT Adapter);
HRESULT WINAPI Direct3D_EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode);
HRESULT WINAPI Direct3D_GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode);
HRESULT WINAPI Direct3D_CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
HRESULT WINAPI Direct3D_CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
HRESULT WINAPI Direct3D_CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
HRESULT WINAPI Direct3D_CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat);
HRESULT WINAPI Direct3D_GetDeviceCaps(UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps);
HRESULT WINAPI Direct3D_CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface);
void    WINAPI Direct3D_SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize);

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3D8_AddRef(Direct3D *pThis) { return Direct3D_AddRef(); }
D3DINLINE ULONG   WINAPI IDirect3D8_Release(Direct3D *pThis) { return Direct3D_Release(); }
D3DINLINE UINT    WINAPI IDirect3D8_GetAdapterCount(Direct3D *pThis) { return Direct3D_GetAdapterCount(); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetAdapterIdentifier(Direct3D *pThis, UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier) { return Direct3D_GetAdapterIdentifier(Adapter, Flags, pIdentifier); }
D3DINLINE UINT    WINAPI IDirect3D8_GetAdapterModeCount(Direct3D *pThis, UINT Adapter) { return Direct3D_GetAdapterModeCount(Adapter); }
D3DINLINE HRESULT WINAPI IDirect3D8_EnumAdapterModes(Direct3D *pThis, UINT Adapter, UINT iMode, D3DDISPLAYMODE *pMode) { return Direct3D_EnumAdapterModes(Adapter, iMode, pMode); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetAdapterDisplayMode(Direct3D *pThis, UINT Adapter, D3DDISPLAYMODE *pMode) { return Direct3D_GetAdapterDisplayMode(Adapter, pMode); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceType(Direct3D *pThis, UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed) { return Direct3D_CheckDeviceType(Adapter, CheckType, DisplayFormat, BackBufferFormat, Windowed); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceFormat(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) { return Direct3D_CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceMultiSampleType(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType) { return Direct3D_CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDepthStencilMatch(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) { return Direct3D_CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetDeviceCaps(Direct3D *pThis, UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps) { return Direct3D_GetDeviceCaps(Adapter, DeviceType, pCaps); }
D3DINLINE HRESULT WINAPI IDirect3D8_CreateDevice(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface) { return Direct3D_CreateDevice(Adapter, DeviceType, pUnused, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface); }
D3DINLINE HRESULT WINAPI IDirect3D8_SetPushBufferSize(Direct3D *pThis, DWORD PushBufferSize, DWORD KickOffSize) { Direct3D_SetPushBufferSize(PushBufferSize, KickOffSize); return S_OK; }

#ifdef __cplusplus

D3DMINLINE ULONG   WINAPI Direct3D::AddRef() { return Direct3D_AddRef(); }
D3DMINLINE ULONG   WINAPI Direct3D::Release() { return Direct3D_Release(); }
D3DMINLINE UINT    WINAPI Direct3D::GetAdapterCount() { return Direct3D_GetAdapterCount(); }
D3DMINLINE HRESULT WINAPI Direct3D::GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier) { return Direct3D_GetAdapterIdentifier(Adapter, Flags, pIdentifier); }
D3DMINLINE UINT    WINAPI Direct3D::GetAdapterModeCount(UINT Adapter) { return Direct3D_GetAdapterModeCount(Adapter); }
D3DMINLINE HRESULT WINAPI Direct3D::EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode) { return Direct3D_EnumAdapterModes(Adapter, Mode, pMode); }
D3DMINLINE HRESULT WINAPI Direct3D::GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode) { return Direct3D_GetAdapterDisplayMode(Adapter, pMode); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed) { return Direct3D_CheckDeviceType(Adapter, CheckType, DisplayFormat, BackBufferFormat, Windowed); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) { return Direct3D_CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType) { return Direct3D_CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) { return Direct3D_CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat); }
D3DMINLINE HRESULT WINAPI Direct3D::GetDeviceCaps(UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS8 *pCaps) { return Direct3D_GetDeviceCaps(Adapter, DeviceType, pCaps); }
D3DMINLINE HRESULT WINAPI Direct3D::CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface) { return Direct3D_CreateDevice(Adapter, DeviceType, pUnused, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface); }
D3DMINLINE HRESULT WINAPI Direct3D::SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize) { Direct3D_SetPushBufferSize(PushBufferSize, KickOffSize); return S_OK; }

#endif __cplusplus

/* D3DDevice */

ULONG   WINAPI D3DDevice_AddRef();
ULONG   WINAPI D3DDevice_Release();
void    WINAPI D3DDevice_GetDirect3D(Direct3D **ppD3D8);
void    WINAPI D3DDevice_GetDeviceCaps(D3DCAPS8 *pCaps);
void    WINAPI D3DDevice_GetDisplayMode(D3DDISPLAYMODE *pMode);
void    WINAPI D3DDevice_GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters);
HRESULT WINAPI D3DDevice_Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
void    WINAPI D3DDevice_GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer);
void    WINAPI D3DDevice_GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);
void    WINAPI D3DDevice_SetFlickerFilter(DWORD Filter);
void    WINAPI D3DDevice_SetSoftDisplayFilter(BOOL Enable);
void    WINAPI D3DDevice_SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp);
void    WINAPI D3DDevice_GetGammaRamp(D3DGAMMARAMP *pRamp);
HRESULT WINAPI D3DDevice_CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture);
HRESULT WINAPI D3DDevice_CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture);
HRESULT WINAPI D3DDevice_CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture);
HRESULT WINAPI D3DDevice_CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer);
HRESULT WINAPI D3DDevice_CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer);
HRESULT WINAPI D3DDevice_CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette);
HRESULT WINAPI D3DDevice_CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface);
HRESULT WINAPI D3DDevice_CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface);
HRESULT WINAPI D3DDevice_CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface);
void    WINAPI D3DDevice_CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray);
void    WINAPI D3DDevice_SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState);
void    WINAPI D3DDevice_GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState);
void    WINAPI D3DDevice_SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil);
void    WINAPI D3DDevice_GetRenderTarget(D3DSurface **ppRenderTarget);
HRESULT WINAPI D3DDevice_GetDepthStencilSurface(D3DSurface **ppZStencilSurface);
D3DINLINE void    WINAPI D3DDevice_BeginScene() { }
D3DINLINE void    WINAPI D3DDevice_EndScene() { }
void    WINAPI D3DDevice_Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
void    WINAPI D3DDevice_SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_SetViewport(CONST D3DVIEWPORT8 *pViewport);
void    WINAPI D3DDevice_GetViewport(D3DVIEWPORT8 *pViewport);
void    WINAPI D3DDevice_SetMaterial(CONST D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_GetMaterial(D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_SetBackMaterial(CONST D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_GetBackMaterial(D3DMATERIAL8 *pMaterial);
HRESULT WINAPI D3DDevice_SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
void    WINAPI D3DDevice_GetLight(DWORD Index, D3DLIGHT8 *pLight);
HRESULT WINAPI D3DDevice_LightEnable(DWORD Index, BOOL Enable);
void    WINAPI D3DDevice_GetLightEnable(DWORD Index, BOOL *pEnable);
void    WINAPI D3DDevice_SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value);
HRESULT WINAPI D3DDevice_SetRenderState_ParameterCheck(D3DRENDERSTATETYPE State, DWORD Value);
void    D3DFASTCALL D3DDevice_SetRenderState_Simple(DWORD Method, DWORD Value);
void    WINAPI D3DDevice_SetRenderState_PSTextureModes(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_VertexBlend(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FogColor(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FillMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_BackFillMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_TwoSidedLighting(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_NormalizeNormals(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ZEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilFail(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_CullMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FrontFace(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_TextureFactor(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ZBias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_LogicOp(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_EdgeAntiAlias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleAntiAlias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleMask(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleRenderTargetMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ShadowFunc(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_LineWidth(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_Dxt1NoiseEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_YuvEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_OcclusionCullEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilCullEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_RopZCmpAlwaysRead(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_RopZRead(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_DoNotCullUncompressed(DWORD Value);
void    WINAPI D3DDevice_SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
HRESULT WINAPI D3DDevice_SetTextureState_ParameterCheck(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_BumpEnv(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_TexCoordIndex(DWORD Stage, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_BorderColor(DWORD Stage, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_ColorKeyColor(DWORD Stage, DWORD Value);
#if D3DCOMPILE_BEGINSTATEBLOCK
void    WINAPI D3DDevice_BeginStateBlock();
HRESULT WINAPI D3DDevice_EndStateBlock(DWORD *pToken);
#endif
void    WINAPI D3DDevice_ApplyStateBlock(DWORD Token);
void    WINAPI D3DDevice_CaptureStateBlock(DWORD Token);
void    WINAPI D3DDevice_DeleteStateBlock(DWORD Token);
HRESULT WINAPI D3DDevice_CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);
void    WINAPI D3DDevice_GetTexture(DWORD Stage, D3DBaseTexture **ppTexture);
void    WINAPI D3DDevice_SetTexture(DWORD Stage, D3DBaseTexture *pTexture);
void    WINAPI D3DDevice_GetPalette(DWORD Stage, D3DPalette **ppPalette);
void    WINAPI D3DDevice_SetPalette(DWORD Stage, D3DPalette *pPalette);
void    WINAPI D3DDevice_DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount);
void    WINAPI D3DDevice_DrawIndexedVertices(D3DPRIMITIVETYPE, UINT VertexCount, CONST WORD *pIndexData);
void    WINAPI D3DDevice_DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
void    WINAPI D3DDevice_DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
void    WINAPI D3DDevice_PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData);
HRESULT WINAPI D3DDevice_CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
void    WINAPI D3DDevice_SetVertexShader(DWORD Handle);
void    WINAPI D3DDevice_GetVertexShader(DWORD *pHandle);
void    WINAPI D3DDevice_DeleteVertexShader(DWORD Handle);
void    WINAPI D3DDevice_SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode);
void    WINAPI D3DDevice_GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode);
void    WINAPI D3DDevice_LoadVertexShader(DWORD Handle, DWORD Address);
void    WINAPI D3DDevice_LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address);
void    WINAPI D3DDevice_SelectVertexShader(DWORD Handle, DWORD Address);
void    WINAPI D3DDevice_SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address);
void    WINAPI D3DDevice_RunVertexStateShader(DWORD Address, CONST float *pData);
void    WINAPI D3DDevice_GetVertexShaderSize(DWORD Handle, UINT* pSize);
void    WINAPI D3DDevice_GetVertexShaderType(DWORD Handle, DWORD* pType);
HRESULT WINAPI D3DDevice_GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
HRESULT WINAPI D3DDevice_GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
void    WINAPI D3DDevice_SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride);
void    WINAPI D3DDevice_GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride);
void    WINAPI D3DDevice_SetIndices(D3DIndexBuffer* pIndexData, UINT BaseVertexIndex);
void    WINAPI D3DDevice_GetIndices(D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex);
void    WINAPI D3DDevice_CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle);
void    WINAPI D3DDevice_SetPixelShader(DWORD Handle);
void    WINAPI D3DDevice_SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef);
void    WINAPI D3DDevice_GetPixelShader(DWORD *pHandle);
void    WINAPI D3DDevice_DeletePixelShader(DWORD Handle);
void    WINAPI D3DDevice_SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData);
HRESULT WINAPI D3DDevice_DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
HRESULT WINAPI D3DDevice_DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
void    WINAPI D3DDevice_DeletePatch(UINT Handle);
void    WINAPI D3DDevice_UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey);
void    WINAPI D3DDevice_EnableOverlay(BOOL Enable);
void    WINAPI D3DDevice_BeginVisibilityTest();
HRESULT WINAPI D3DDevice_EndVisibilityTest(DWORD Index);
HRESULT WINAPI D3DDevice_GetVisibilityTestResult(DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp);
BOOL    WINAPI D3DDevice_IsBusy();
void    WINAPI D3DDevice_BlockUntilIdle();
void    WINAPI D3DDevice_KickPushBuffer();
void    WINAPI D3DDevice_SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback);
void    WINAPI D3DDevice_SetSwapCallback(D3DSWAPCALLBACK pCallback);
void    WINAPI D3DDevice_BlockUntilVerticalBlank();
DWORD   WINAPI D3DDevice_InsertFence();
BOOL    WINAPI D3DDevice_IsFencePending(DWORD Fence);
VOID    WINAPI D3DDevice_BlockOnFence(DWORD Fence);
void    WINAPI D3DDevice_InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context);
void    WINAPI D3DDevice_FlushVertexCache();
HRESULT WINAPI D3DDevice_PersistDisplay();
HRESULT WINAPI D3DDevice_GetPersistedSurface(IDirect3DSurface8 **ppSurface);
BOOL    WINAPI D3DDevice_GetOverlayUpdateStatus();
void    WINAPI D3DDevice_GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus);
void    WINAPI D3DDevice_SetVertexData2f(INT Register, float a, float b);
void    WINAPI D3DDevice_SetVertexData4f(INT Register, float a, float b, float c, float d);
void    WINAPI D3DDevice_SetVertexData2s(INT Register, SHORT a, SHORT b);
void    WINAPI D3DDevice_SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d);
void    WINAPI D3DDevice_SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d);
void    WINAPI D3DDevice_SetVertexDataColor(INT Register, D3DCOLOR Color);
void    WINAPI D3DDevice_Begin(D3DPRIMITIVETYPE PrimitiveType);
void    WINAPI D3DDevice_End();
HRESULT WINAPI D3DDevice_CreateFixup(UINT Size, D3DFixup **ppFixup);
HRESULT WINAPI D3DDevice_CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer);
void    WINAPI D3DDevice_BeginPushBuffer(D3DPushBuffer *pPushBuffer);
HRESULT WINAPI D3DDevice_EndPushBuffer();
void    WINAPI D3DDevice_RunPushBuffer(D3DPushBuffer *pPushBuffer, D3DFixup *pFixup);
void    WINAPI D3DDevice_GetPushBufferOffset(DWORD* pOffset);
void    WINAPI D3DDevice_Nop();
void    WINAPI D3DDevice_GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport);
void    WINAPI D3DDevice_SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
HRESULT WINAPI D3DDevice_GetModelView(D3DMATRIX* pModelView);
void    WINAPI D3DDevice_SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
HRESULT WINAPI D3DDevice_GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport);
void    WINAPI D3DDevice_SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
void    WINAPI D3DDevice_SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
HRESULT WINAPI D3DDevice_GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs);
void    D3DFASTCALL D3DDevice_SwitchTexture(DWORD Method, DWORD Data, DWORD Format);
void    WINAPI D3DDevice_Suspend();
void    WINAPI D3DDevice_Resume(BOOL Reset);
void    WINAPI D3DDevice_SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects);
void    WINAPI D3DDevice_GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects);
void    WINAPI D3DDevice_SetTile(DWORD Index, CONST D3DTILE* pTile);
void    WINAPI D3DDevice_GetTile(DWORD Index, D3DTILE* pTile);
DWORD   WINAPI D3DDevice_GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag);
void    WINAPI D3DDevice_SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count);
void    WINAPI D3DDevice_GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
void    WINAPI D3DDevice_BeginPush(DWORD Count, DWORD **ppPush);
void    WINAPI D3DDevice_EndPush(DWORD *pPush);
DWORD   WINAPI D3DDevice_Swap(DWORD Flags);
void    WINAPI D3DDevice_SetBackBufferScale(float x, float y);
void    WINAPI D3DDevice_GetBackBufferScale(float *pX, float *pY);
void    WINAPI D3DDevice_SetScreenSpaceOffset(float x, float y);
void    WINAPI D3DDevice_GetScreenSpaceOffset(float *pX, float *pY);
void    WINAPI D3DDevice_SetOverscanColor(D3DCOLOR Color);
D3DCOLOR WINAPI D3DDevice_GetOverscanColor();

#ifdef _DEBUG
DWORD   WINAPI D3DDevice_SetDebugMarker(DWORD Marker);
DWORD   WINAPI D3DDevice_GetDebugMarker();
#else
D3DINLINE DWORD   WINAPI D3DDevice_SetDebugMarker(DWORD Marker) { return 0; }
D3DINLINE DWORD   WINAPI D3DDevice_GetDebugMarker() { return 0; }
#endif

D3DINLINE void D3DDevice_GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue)
{
    *pValue = D3D__RenderState[State];
}
D3DINLINE void D3DDevice_GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue)
{
    *pValue = D3D__TextureState[Stage][Type];
}

#if D3DCOMPILE_NOTINLINE
    
    D3DINLINE void D3DDevice_SetRenderState(D3DRENDERSTATETYPE State, DWORD Value)
    {
        D3DDevice_SetRenderStateNotInline(State, Value);
    }
    D3DINLINE void D3DDevice_SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
    {
        D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value);
    }

#else
    
    // This D3DINLINE version of SetRenderState has the nice advantage that it
    // essentially moves to compile-time the big 'switch' statement for
    // handling all the render state types.  When given a constant value for 
    // 'State', all of these 'if's get nicely compiled away.  We can't use a 
    // static call-table because the compiler cannot remove the indirect.
    //
    // If you're calling SetRenderState with a non-constant value for 'State',
    // it's better to call SetRenderStateNotInline (it will reduce code bloat
    // and be a bit faster because the non-D3DINLINE version uses a call-table).
    //
    D3DINLINE void D3DDevice_SetRenderState(D3DRENDERSTATETYPE State, DWORD Value)
    {
        #ifdef _DEBUG
        if (D3DDevice_SetRenderState_ParameterCheck(State, Value) != S_OK)
            return;
        #endif

        if (State < D3DRS_SIMPLE_MAX)
        {
            D3DDevice_SetRenderState_Simple(D3DSIMPLERENDERSTATEENCODE[State], Value);
            #if !D3DCOMPILE_PUREDEVICE
            D3D__RenderState[State] = Value;
            #endif
        }
        else if (State < D3DRS_DEFERRED_MAX)
        {
            D3D__DirtyFlags |= D3DDIRTYFROMRENDERSTATE[State - D3DRS_SIMPLE_MAX];
            D3D__RenderState[State] = Value;
        }
        else if (State == D3DRS_PSTEXTUREMODES)
        {
            D3DDevice_SetRenderState_PSTextureModes(Value);
        }
        else if (State == D3DRS_VERTEXBLEND)
        {
            D3DDevice_SetRenderState_VertexBlend(Value);
        }
        else if (State == D3DRS_FOGCOLOR)
        {
            D3DDevice_SetRenderState_FogColor(Value);
        }
        else if (State == D3DRS_FILLMODE)
        {
            D3DDevice_SetRenderState_FillMode(Value);
        }
        else if (State == D3DRS_BACKFILLMODE)
        {
            D3DDevice_SetRenderState_BackFillMode(Value);
        }
        else if (State == D3DRS_TWOSIDEDLIGHTING)
        {
            D3DDevice_SetRenderState_TwoSidedLighting(Value);
        }
        else if (State == D3DRS_NORMALIZENORMALS)
        {
            D3DDevice_SetRenderState_NormalizeNormals(Value);
        }
        else if (State == D3DRS_ZENABLE)
        {
            D3DDevice_SetRenderState_ZEnable(Value);
        }
        else if (State == D3DRS_STENCILENABLE)
        {
            D3DDevice_SetRenderState_StencilEnable(Value);
        }
        else if (State == D3DRS_STENCILFAIL)
        {
            D3DDevice_SetRenderState_StencilFail(Value);
        }
        else if (State == D3DRS_CULLMODE)
        {
            D3DDevice_SetRenderState_CullMode(Value);
        }
        else if (State == D3DRS_FRONTFACE)
        {
            D3DDevice_SetRenderState_FrontFace(Value);
        }
        else if (State == D3DRS_TEXTUREFACTOR)
        {
            D3DDevice_SetRenderState_TextureFactor(Value);
        }
        else if (State == D3DRS_ZBIAS)
        {
            D3DDevice_SetRenderState_ZBias(Value);
        }
        else if (State == D3DRS_LOGICOP)
        {
            D3DDevice_SetRenderState_LogicOp(Value);
        }
        else if (State == D3DRS_EDGEANTIALIAS)
        {
            D3DDevice_SetRenderState_EdgeAntiAlias(Value);
        }
        else if (State == D3DRS_MULTISAMPLEANTIALIAS)
        {
            D3DDevice_SetRenderState_MultiSampleAntiAlias(Value);
        }
        else if (State == D3DRS_MULTISAMPLEMASK)
        {
            D3DDevice_SetRenderState_MultiSampleMask(Value);
        }
        else if (State == D3DRS_MULTISAMPLEMODE)
        {
            D3DDevice_SetRenderState_MultiSampleMode(Value);
        }
        else if (State == D3DRS_MULTISAMPLERENDERTARGETMODE)
        {
            D3DDevice_SetRenderState_MultiSampleRenderTargetMode(Value);
        }
        else if (State == D3DRS_SHADOWFUNC)
        {
            D3DDevice_SetRenderState_ShadowFunc(Value);
        }
        else if (State == D3DRS_LINEWIDTH)
        {
            D3DDevice_SetRenderState_LineWidth(Value);
        }
        else if (State == D3DRS_DXT1NOISEENABLE)
        {
            D3DDevice_SetRenderState_Dxt1NoiseEnable(Value);
        }
        else if (State == D3DRS_YUVENABLE)
        {
            D3DDevice_SetRenderState_YuvEnable(Value);
        }
        else if (State == D3DRS_OCCLUSIONCULLENABLE)
        {
            D3DDevice_SetRenderState_OcclusionCullEnable(Value);
        }
        else if (State == D3DRS_STENCILCULLENABLE)
        {
            D3DDevice_SetRenderState_StencilCullEnable(Value);
        }
        else if (State == D3DRS_ROPZCMPALWAYSREAD)
        {
            D3DDevice_SetRenderState_RopZCmpAlwaysRead(Value);
        }
        else if (State == D3DRS_ROPZREAD)
        {
            D3DDevice_SetRenderState_RopZRead(Value);
        }
        else if (State == D3DRS_DONOTCULLUNCOMPRESSED)
        {
            D3DDevice_SetRenderState_DoNotCullUncompressed(Value);
        }
    }

    // As above, but for SetTextureStageState:

    D3DINLINE void D3DDevice_SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
    {
        #ifdef _DEBUG
        if (D3DDevice_SetTextureState_ParameterCheck(Stage, Type, Value) != S_OK)
            return;
        #endif
        
        if (Type < D3DTSS_DEFERRED_TEXTURE_STATE_MAX)
        {
            D3D__DirtyFlags |= (D3DDIRTYFLAG_TEXTURE_STATE_0 << Stage);
            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type == D3DTSS_COLOROP)
        {
            // Only D3DTOP_BUMPENVMAP and D3DTOP_BUMPENVMAPLUMINANCE require the
            // sign flags and shader program to be recomputed:

            D3D__DirtyFlags |= (Value < D3DTOP_BUMPENVMAP)
                             ? (D3DDIRTYFLAG_COMBINERS)
                             : (D3DDIRTYFLAG_COMBINERS | 
                                D3DDIRTYFLAG_SHADER_STAGE_PROGRAM | 
                                D3DDIRTYFLAG_TEXTURE_STATE);

            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type < D3DTSS_DEFERRED_MAX)
        {
            D3D__DirtyFlags |= D3DDIRTYFROMTEXTURESTATE[Type];
            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type == D3DTSS_TEXCOORDINDEX)
        {
            D3DDevice_SetTextureState_TexCoordIndex(Stage, Value);
        }
        else if (Type == D3DTSS_BORDERCOLOR)
        {
            D3DDevice_SetTextureState_BorderColor(Stage, Value);
        }
        else if (Type == D3DTSS_COLORKEYCOLOR)
        {
            D3DDevice_SetTextureState_ColorKeyColor(Stage, Value);
        }
        else if ((Type >= D3DTSS_BUMPENVMAT00) && (Type <= D3DTSS_BUMPENVLOFFSET))
        {
            D3DDevice_SetTextureState_BumpEnv(Stage, Type, Value);
        }
    }

#endif

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DDevice8_AddRef(D3DDevice *pThis) { return D3DDevice_AddRef(); }
D3DINLINE ULONG   WINAPI IDirect3DDevice8_Release(D3DDevice *pThis) { return D3DDevice_Release(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDirect3D(D3DDevice *pThis, Direct3D **ppD3D8) { D3DDevice_GetDirect3D(ppD3D8); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDeviceCaps(D3DDevice *pThis, D3DCAPS8 *pCaps) { D3DDevice_GetDeviceCaps(pCaps); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDisplayMode(D3DDevice *pThis, D3DDISPLAYMODE *pMode) { D3DDevice_GetDisplayMode(pMode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetCreationParameters(D3DDevice *pThis, D3DDEVICE_CREATION_PARAMETERS *pParameters) { D3DDevice_GetCreationParameters(pParameters); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Reset(D3DDevice *pThis, D3DPRESENT_PARAMETERS *pPresentationParameters) { return D3DDevice_Reset(pPresentationParameters); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Present(D3DDevice *pThis, CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2) { D3DDevice_Swap(0); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackBuffer(D3DDevice *pThis, INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer) { D3DDevice_GetBackBuffer(BackBuffer, Type, ppBackBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRasterStatus(D3DDevice *pThis, D3DRASTER_STATUS *pRasterStatus) { D3DDevice_GetRasterStatus(pRasterStatus); return S_OK; }
D3DINLINE void    WINAPI IDirect3DDevice8_SetFlickerFilter(D3DDevice *pThis, DWORD Filter) { D3DDevice_SetFlickerFilter(Filter); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetSoftDisplayFilter(D3DDevice *pThis, BOOL Enable) { D3DDevice_SetSoftDisplayFilter(Enable); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetGammaRamp(D3DDevice *pThis, DWORD Flags, CONST D3DGAMMARAMP *pRamp) { D3DDevice_SetGammaRamp(Flags, pRamp); }
D3DINLINE void    WINAPI IDirect3DDevice8_GetGammaRamp(D3DDevice *pThis, D3DGAMMARAMP *pRamp) { D3DDevice_GetGammaRamp(pRamp); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateTexture(D3DDevice *pThis, UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture) { return D3DDevice_CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVolumeTexture(D3DDevice *pThis, UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture) { return D3DDevice_CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateCubeTexture(D3DDevice *pThis, UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture) { return D3DDevice_CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVertexBuffer(D3DDevice *pThis, UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer) { return D3DDevice_CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateIndexBuffer(D3DDevice *pThis, UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer) { return D3DDevice_CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePalette(D3DDevice *pThis, D3DPALETTESIZE Size, D3DPalette **ppPalette) { return D3DDevice_CreatePalette(Size, ppPalette); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateRenderTarget(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface) { return D3DDevice_CreateRenderTarget(Width, Height, Format, MultiSample, Lockable, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateDepthStencilSurface(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface) { return D3DDevice_CreateDepthStencilSurface(Width, Height, Format, MultiSample, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateImageSurface(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface) { return D3DDevice_CreateImageSurface(Width, Height, Format, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CopyRects(D3DDevice *pThis, D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray) { D3DDevice_CopyRects(pSourceSurface, pSourceRectsArray, cRects, pDestinationSurface, pDestPointsArray); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_SetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_GetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderTarget(D3DDevice *pThis, D3DSurface *pRenderTarget, D3DSurface *pNewZStencil) { D3DDevice_SetRenderTarget(pRenderTarget, pNewZStencil); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRenderTarget(D3DDevice *pThis, D3DSurface **ppRenderTarget) { D3DDevice_GetRenderTarget(ppRenderTarget); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDepthStencilSurface(D3DDevice *pThis, D3DSurface **ppZStencilSurface) { return D3DDevice_GetDepthStencilSurface(ppZStencilSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginScene(D3DDevice *pThis) { D3DDevice_BeginScene(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndScene(D3DDevice *pThis) { D3DDevice_EndScene(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Clear(D3DDevice *pThis, DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) { D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDIRTY_TRANSFORM(State); D3DDevice_SetTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix) { D3DDevice_GetTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_MultiplyTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDevice_MultiplyTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetViewport(D3DDevice *pThis, CONST D3DVIEWPORT8 *pViewport) { D3DDIRTY_VIEWPORT(); D3DDevice_SetViewport(pViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetViewport(D3DDevice *pThis, D3DVIEWPORT8 *pViewport) { D3DDevice_GetViewport(pViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetMaterial(D3DDevice *pThis, CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_MATERIAL(); D3DDevice_SetMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetMaterial(D3DDevice *pThis, D3DMATERIAL8 *pMaterial) { D3DDevice_GetMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetBackMaterial(D3DDevice *pThis, CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_BACKMATERIAL(); D3DDevice_SetBackMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackMaterial(D3DDevice *pThis, D3DMATERIAL8 *pMaterial) { D3DDevice_GetBackMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetLight(D3DDevice *pThis, DWORD Index, CONST D3DLIGHT8 *pLight) { return D3DDevice_SetLight(Index, pLight); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetLight(D3DDevice *pThis, DWORD Index, D3DLIGHT8 *pLight) { D3DDevice_GetLight(Index, pLight); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LightEnable(D3DDevice *pThis, DWORD Index, BOOL Enable) { return D3DDevice_LightEnable(Index, Enable); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetLightEnable(D3DDevice *pThis, DWORD Index, BOOL *pEnable) { D3DDevice_GetLightEnable(Index, pEnable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderState(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderState(State, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderStateNotInline(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderStateNotInline(State, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRenderState(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD *pValue) { D3DDevice_GetRenderState(State, pValue); return S_OK; }
#if D3DCOMPILE_BEGINSTATEBLOCK
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginStateBlock(D3DDevice *pThis) { D3DDevice_BeginStateBlock(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndStateBlock(D3DDevice *pThis, DWORD *pToken) { return D3DDevice_EndStateBlock(pToken); }
#endif
D3DINLINE HRESULT WINAPI IDirect3DDevice8_ApplyStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_ApplyStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CaptureStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_CaptureStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeleteStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_DeleteStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateStateBlock(D3DDevice *pThis, D3DSTATEBLOCKTYPE Type,DWORD *pToken) { return D3DDevice_CreateStateBlock(Type, pToken); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture **ppTexture) { D3DDevice_GetTexture(Stage, ppTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture *pTexture) { D3DDIRTY_TEXTURE(Stage); D3DDevice_SetTexture(Stage, pTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPalette(D3DDevice *pThis, DWORD Stage, D3DPalette **ppPalette) { D3DDevice_GetPalette(Stage, ppPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPalette(D3DDevice *pThis, DWORD Stage, D3DPalette *pPalette) { D3DDevice_SetPalette(Stage, pPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTextureStageState(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue) { D3DDevice_GetTextureStageState(Stage, Type, pValue); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTextureStageState(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageState(Stage, Type, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTextureStageStateNotInline(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawPrimitive(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount)); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedPrimitive(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount) { D3DDevice_DrawIndexedVertices(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), D3D__IndexData + StartIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawPrimitiveUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedPrimitiveUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawVertices(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, VertexCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedVertices(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, WORD *pIndexData) { D3DDevice_DrawIndexedVertices(PrimitiveType, VertexCount, pIndexData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawVerticesUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, VertexCount, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedVerticesUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, VertexCount, pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_PrimeVertexCache(D3DDevice *pThis, UINT VertexCount, CONST WORD *pIndexData) { D3DDevice_PrimeVertexCache(VertexCount, pIndexData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVertexShader(D3DDevice *pThis, CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage) { return D3DDevice_CreateVertexShader(pDeclaration, pFunction, pHandle, Usage); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShader(D3DDevice *pThis, DWORD Handle) { D3DDIRTY_VERTEXSHADER(); D3DDevice_SetVertexShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShader(D3DDevice *pThis, DWORD *pHandle) { D3DDevice_GetVertexShader(pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeleteVertexShader(D3DDevice *pThis, DWORD Handle) { D3DDevice_DeleteVertexShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderConstant(D3DDevice *pThis, INT Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_VERTEXSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderConstant(D3DDevice *pThis, INT Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetShaderConstantMode(D3DDevice *pThis, D3DSHADERCONSTANTMODE Mode) { D3DDevice_SetShaderConstantMode(Mode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetShaderConstantMode(D3DDevice *pThis, D3DSHADERCONSTANTMODE *pMode) { D3DDevice_GetShaderConstantMode(pMode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LoadVertexShader(D3DDevice *pThis, DWORD Handle, DWORD Address) { D3DDevice_LoadVertexShader(Handle, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LoadVertexShaderProgram(D3DDevice *pThis, CONST DWORD *pFunction, DWORD Address) { D3DDevice_LoadVertexShaderProgram(pFunction, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SelectVertexShader(D3DDevice *pThis, DWORD Handle, DWORD Address) { D3DDevice_SelectVertexShader(Handle, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SelectVertexShaderDirect(D3DDevice *pThis, D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address) { D3DDevice_SelectVertexShaderDirect(pVAF, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_RunVertexStateShader(D3DDevice *pThis, DWORD Address, CONST float *pData) { D3DDevice_RunVertexStateShader(Address, pData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderSize(D3DDevice *pThis, DWORD Handle, UINT* pSize) { D3DDevice_GetVertexShaderSize(Handle, pSize); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderType(D3DDevice *pThis, DWORD Handle, DWORD* pType) { D3DDevice_GetVertexShaderType(Handle, pType); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderDeclaration(D3DDevice *pThis, DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderDeclaration(Handle, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderFunction(D3DDevice *pThis, DWORD Handle,void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderFunction(Handle, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetStreamSource(D3DDevice *pThis, UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride) { D3DDIRTY_STREAM(StreamNumber); D3DDevice_SetStreamSource(StreamNumber, pStreamData, Stride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetStreamSource(D3DDevice *pThis, UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride) { D3DDevice_GetStreamSource(StreamNumber, ppStreamData, pStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetIndices(D3DDevice *pThis, D3DIndexBuffer* pIndexData, UINT BaseVertexIndex) { D3DDIRTY_INDICES(); D3DDevice_SetIndices(pIndexData, BaseVertexIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetIndices(D3DDevice *pThis, D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex) { D3DDevice_GetIndices(ppIndexData, pBaseVertexIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePixelShader(D3DDevice *pThis, CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle) { D3DDevice_CreatePixelShader(pPSDef, pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShader(D3DDevice *pThis, DWORD Handle) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShaderProgram(D3DDevice *pThis, CONST D3DPIXELSHADERDEF *pPSDef) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShaderProgram(pPSDef); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShader(D3DDevice *pThis, DWORD *pHandle) { D3DDevice_GetPixelShader(pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeletePixelShader(D3DDevice *pThis, DWORD Handle) { D3DDevice_DeletePixelShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShaderConstant(D3DDevice *pThis, DWORD Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_PIXELSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShaderConstant(D3DDevice *pThis, DWORD Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShaderFunction(D3DDevice *pThis, DWORD Handle, D3DPIXELSHADERDEF *pData) { D3DDevice_GetPixelShaderFunction(Handle, pData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawRectPatch(D3DDevice *pThis, UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo) { return D3DDevice_DrawRectPatch(Handle, pNumSegs, pRectPatchInfo); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawTriPatch(D3DDevice *pThis, UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo) { return D3DDevice_DrawTriPatch(Handle, pNumSegs, pTriPatchInfo); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeletePatch(D3DDevice *pThis, UINT Handle) { D3DDevice_DeletePatch(Handle); return S_OK; }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_IsBusy(D3DDevice *pThis) { return D3DDevice_IsBusy(); }
D3DINLINE void    WINAPI IDirect3DDevice8_BlockUntilIdle(D3DDevice *pThis) { D3DDevice_BlockUntilIdle(); }
D3DINLINE void    WINAPI IDirect3DDevice8_KickPushBuffer(D3DDevice *pThis) { D3DDevice_KickPushBuffer(); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetVerticalBlankCallback(D3DDevice *pThis, D3DVBLANKCALLBACK pCallback) { D3DDevice_SetVerticalBlankCallback(pCallback); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetSwapCallback(D3DDevice *pThis, D3DSWAPCALLBACK pCallback) { D3DDevice_SetSwapCallback(pCallback); }
D3DINLINE void    WINAPI IDirect3DDevice8_BlockUntilVerticalBlank(D3DDevice *pThis) { D3DDevice_BlockUntilVerticalBlank(); }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_InsertFence(D3DDevice *pThis) { return D3DDevice_InsertFence(); }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_IsFencePending(D3DDevice *pThis, DWORD Fence) { return D3DDevice_IsFencePending(Fence); }
D3DINLINE VOID    WINAPI IDirect3DDevice8_BlockOnFence(D3DDevice *pThis, DWORD Fence) { D3DDevice_BlockOnFence(Fence); }
D3DINLINE void    WINAPI IDirect3DDevice8_InsertCallback(D3DDevice *pThis, D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context) { D3DDevice_InsertCallback(Type, pCallback, Context); }
D3DINLINE void    WINAPI IDirect3DDevice8_FlushVertexCache(D3DDevice *pThis) { D3DDevice_FlushVertexCache(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_PersistDisplay(D3DDevice *pThis) { return D3DDevice_PersistDisplay(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPersistedSurface(D3DDevice *pThis, IDirect3DSurface8 **ppSurface) { D3DDevice_GetPersistedSurface(ppSurface); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_UpdateOverlay(D3DDevice *pThis, D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey) { D3DDevice_UpdateOverlay(pSurface, SrcRect, DstRect, EnableColorKey, ColorKey); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EnableOverlay(D3DDevice *pThis, BOOL Enable) { D3DDevice_EnableOverlay(Enable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginVisibilityTest(D3DDevice *pThis) { D3DDevice_BeginVisibilityTest(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndVisibilityTest(D3DDevice *pThis, DWORD Index) { return D3DDevice_EndVisibilityTest(Index); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVisibilityTestResult(D3DDevice *pThis, DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp) { return D3DDevice_GetVisibilityTestResult(Index, pResult, pTimeStamp); }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_GetOverlayUpdateStatus(D3DDevice *pThis) { return D3DDevice_GetOverlayUpdateStatus(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDisplayFieldStatus(D3DDevice *pThis, D3DFIELD_STATUS *pFieldStatus) { D3DDevice_GetDisplayFieldStatus(pFieldStatus); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData2f(D3DDevice *pThis, INT Register, float a, float b) { D3DDevice_SetVertexData2f(Register, a, b); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4f(D3DDevice *pThis, INT Register, float a, float b, float c, float d) { D3DDevice_SetVertexData4f(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData2s(D3DDevice *pThis, INT Register, SHORT a, SHORT b) { D3DDevice_SetVertexData2s(Register, a, b); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4s(D3DDevice *pThis, INT Register, SHORT a, SHORT b, SHORT c, SHORT d) { D3DDevice_SetVertexData4s(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4ub(D3DDevice *pThis, INT Register, BYTE a, BYTE b, BYTE c, BYTE d) { D3DDevice_SetVertexData4ub(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexDataColor(D3DDevice *pThis, INT Register, D3DCOLOR Color) { D3DDevice_SetVertexDataColor(Register, Color); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Begin(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType) { D3DDevice_Begin(PrimitiveType); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_End(D3DDevice *pThis) { D3DDevice_End(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateFixup(D3DDevice *pThis, UINT Size, D3DFixup **ppFixup) { return D3DDevice_CreateFixup(Size, ppFixup); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePushBuffer(D3DDevice *pThis, UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer** ppPushBuffer) { return D3DDevice_CreatePushBuffer(Size, RunUsingCpuCopy, ppPushBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginPushBuffer(D3DDevice *pThis, D3DPushBuffer *pPushBuffer) { D3DDevice_BeginPushBuffer(pPushBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndPushBuffer(D3DDevice *pThis) { return D3DDevice_EndPushBuffer(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_RunPushBuffer(D3DDevice *pThis, D3DPushBuffer* pPushBuffer, D3DFixup *pFixup) { D3DDevice_RunPushBuffer(pPushBuffer, pFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPushBufferOffset(D3DDevice *pThis, DWORD* pOffset) { D3DDevice_GetPushBufferOffset(pOffset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Nop(D3DDevice *pThis) { D3DDevice_Nop(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetProjectionViewportMatrix(D3DDevice *pThis, D3DMATRIX* pProjectionViewport) { D3DDevice_GetProjectionViewportMatrix(pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetModelView(D3DDevice *pThis, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DDevice_SetModelView(pModelView, pInverseModelView, pComposite); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetModelView(D3DDevice *pThis, D3DMATRIX* pModelView) { return D3DDevice_GetModelView(pModelView); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexBlendModelView(D3DDevice *pThis, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DDevice_SetVertexBlendModelView(Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexBlendModelView(D3DDevice *pThis, UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport) { return D3DDevice_GetVertexBlendModelView(Count, pModelViews, pProjectionViewport); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderInput(D3DDevice *pThis, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInput(Handle, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderInputDirect(D3DDevice *pThis, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInputDirect(pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderInput(D3DDevice *pThis, DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs) { return D3DDevice_GetVertexShaderInput(pHandle, pStreamCount, pStreamInputs); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SwitchTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture *pTexture) { D3DDevice_SwitchTexture(D3DTEXTUREDIRECTENCODE[Stage], (pTexture)->Data, (pTexture)->Format); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Suspend(D3DDevice *pThis) { D3DDevice_Suspend(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Resume(D3DDevice *pThis, BOOL Reset) { D3DDevice_Resume(Reset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetScissors(D3DDevice *pThis, DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects) { D3DDevice_SetScissors(Count, Exclusive, pRects); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetScissors(D3DDevice *pThis, DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects) { D3DDevice_GetScissors(pCount, pExclusive, pRects); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTile(D3DDevice *pThis, DWORD Index, CONST D3DTILE* pTile) { D3DDevice_SetTile(Index, pTile); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTile(D3DDevice *pThis, DWORD Index, D3DTILE* pTile) { D3DDevice_GetTile(Index, pTile); return S_OK; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetTileCompressionTags(D3DDevice *pThis, DWORD ZStartTag, DWORD ZEndTag) { return D3DDevice_GetTileCompressionTags(ZStartTag, ZEndTag); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetTileCompressionTagBits(D3DDevice *pThis, DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count) { D3DDevice_SetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DINLINE void    WINAPI IDirect3DDevice8_GetTileCompressionTagBits(D3DDevice *pThis, DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_GetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginPush(D3DDevice *pThis, DWORD Count, DWORD **ppPush) { D3DDevice_BeginPush(Count, ppPush); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndPush(D3DDevice *pThis, DWORD *pPush) { D3DDevice_EndPush(pPush); return S_OK; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_Swap(DWORD Flags) { return D3DDevice_Swap(Flags); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetBackBufferScale(float x, float y) { D3DDevice_SetBackBufferScale(x, y); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackBufferScale(float *pX, float *pY) { D3DDevice_GetBackBufferScale(pX, pY); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetScreenSpaceOffset(float x, float y) { D3DDevice_SetScreenSpaceOffset(x, y); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetScreenSpaceOffset(float *pX, float *pY) { D3DDevice_GetScreenSpaceOffset(pX, pY); return S_OK; }
D3DINLINE void    WINAPI IDirect3DDevice8_SetOverscanColor(D3DCOLOR Color) { D3DDevice_SetOverscanColor(Color); }
D3DINLINE D3DCOLOR WINAPI IDirect3DDevice8_GetOverscanColor() { return D3DDevice_GetOverscanColor(); }                                                                                                                                 
#ifdef _DEBUG
D3DINLINE DWORD   WINAPI IDirect3DDevice8_SetDebugMarker(DWORD Marker) { return D3DDevice_SetDebugMarker(Marker); }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetDebugMarker() { return D3DDevice_GetDebugMarker(); }
#else
D3DINLINE DWORD   WINAPI IDirect3DDevice8_SetDebugMarker(DWORD Marker) { return 0; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetDebugMarker() { return 0; }
#endif

#ifdef __cplusplus

D3DMINLINE ULONG   WINAPI D3DDevice::AddRef() { return D3DDevice_AddRef(); }
D3DMINLINE ULONG   WINAPI D3DDevice::Release() { return D3DDevice_Release(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDirect3D(Direct3D **ppD3D8) { D3DDevice_GetDirect3D(ppD3D8); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDeviceCaps(D3DCAPS8 *pCaps) { D3DDevice_GetDeviceCaps(pCaps); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDisplayMode(D3DDISPLAYMODE *pMode) { D3DDevice_GetDisplayMode(pMode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters) { D3DDevice_GetCreationParameters(pParameters); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Reset(D3DPRESENT_PARAMETERS *pPresentationParameters) { return D3DDevice_Reset(pPresentationParameters); }
D3DMINLINE HRESULT WINAPI D3DDevice::Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2) { D3DDevice_Swap(0); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer) { D3DDevice_GetBackBuffer(BackBuffer, Type, ppBackBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRasterStatus(D3DRASTER_STATUS *pRasterStatus) { D3DDevice_GetRasterStatus(pRasterStatus); return S_OK; }
D3DMINLINE void    WINAPI D3DDevice::SetFlickerFilter(DWORD Filter) { D3DDevice_SetFlickerFilter(Filter); }
D3DMINLINE void    WINAPI D3DDevice::SetSoftDisplayFilter(BOOL Enable) { D3DDevice_SetSoftDisplayFilter(Enable); }
D3DMINLINE void    WINAPI D3DDevice::SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp) { D3DDevice_SetGammaRamp(Flags, pRamp); }
D3DMINLINE void    WINAPI D3DDevice::GetGammaRamp(D3DGAMMARAMP *pRamp) { D3DDevice_GetGammaRamp(pRamp); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture) { return D3DDevice_CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture) { return D3DDevice_CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture) { return D3DDevice_CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer) { return D3DDevice_CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer) { return D3DDevice_CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette) { return D3DDevice_CreatePalette(Size, ppPalette); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface) { return D3DDevice_CreateRenderTarget(Width, Height, Format, MultiSample, Lockable, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface) { return D3DDevice_CreateDepthStencilSurface(Width, Height, Format, MultiSample, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface) { return D3DDevice_CreateImageSurface(Width, Height, Format, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray) { D3DDevice_CopyRects(pSourceSurface, pSourceRectsArray, cRects, pDestinationSurface, pDestPointsArray); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_SetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_GetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil) { D3DDevice_SetRenderTarget(pRenderTarget, pNewZStencil); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRenderTarget(D3DSurface **ppRenderTarget) { D3DDevice_GetRenderTarget(ppRenderTarget); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDepthStencilSurface(D3DSurface **ppZStencilSurface) { return D3DDevice_GetDepthStencilSurface(ppZStencilSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginScene() { D3DDevice_BeginScene(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndScene() { D3DDevice_EndScene(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) { D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDIRTY_TRANSFORM(State); D3DDevice_SetTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix) { D3DDevice_GetTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDevice_MultiplyTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetViewport(CONST D3DVIEWPORT8 *pViewport) { D3DDIRTY_VIEWPORT(); D3DDevice_SetViewport(pViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetViewport(D3DVIEWPORT8 *pViewport) { D3DDevice_GetViewport(pViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetMaterial(CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_MATERIAL(); D3DDevice_SetMaterial(pMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetMaterial(D3DMATERIAL8 *pMaterial) { D3DDevice_GetMaterial(pMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetBackMaterial(CONST D3DMATERIAL8 *pBackMaterial) { D3DDIRTY_BACKMATERIAL(); D3DDevice_SetBackMaterial(pBackMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackMaterial(D3DMATERIAL8 *pBackMaterial) { D3DDevice_GetBackMaterial(pBackMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetLight(DWORD Index, CONST D3DLIGHT8 *pLight) { return D3DDevice_SetLight(Index, pLight); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetLight(DWORD Index, D3DLIGHT8 *pLight) { D3DDevice_GetLight(Index, pLight); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LightEnable(DWORD Index, BOOL Enable) { return D3DDevice_LightEnable(Index, Enable); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetLightEnable(DWORD Index, BOOL *pEnable) { D3DDevice_GetLightEnable(Index, pEnable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderState(D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderState(State, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderStateNotInline(State, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue) { D3DDevice_GetRenderState(State, pValue); return S_OK; }
#if D3DCOMPILE_BEGINSTATEBLOCK
D3DMINLINE HRESULT WINAPI D3DDevice::BeginStateBlock() { D3DDevice_BeginStateBlock(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndStateBlock(DWORD *pToken) { return D3DDevice_EndStateBlock(pToken); }
#endif
D3DMINLINE HRESULT WINAPI D3DDevice::ApplyStateBlock(DWORD Token) { D3DDevice_ApplyStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CaptureStateBlock(DWORD Token) { D3DDevice_CaptureStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DeleteStateBlock(DWORD Token) { D3DDevice_DeleteStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken) { return D3DDevice_CreateStateBlock(Type, pToken); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTexture(DWORD Stage, D3DBaseTexture **ppTexture) { D3DDevice_GetTexture(Stage, ppTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTexture(DWORD Stage, D3DBaseTexture *pTexture) { D3DDIRTY_TEXTURE(Stage); D3DDevice_SetTexture(Stage, pTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPalette(DWORD Stage, D3DPalette **ppPalette) { D3DDevice_GetPalette(Stage, ppPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPalette(DWORD Stage, D3DPalette *pPalette) { D3DDevice_SetPalette(Stage, pPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue) { D3DDevice_GetTextureStageState(Stage, Type, pValue); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageState(Stage, Type, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount)); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount) { D3DDevice_DrawIndexedVertices(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), D3D__IndexData + StartIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, VertexCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedVertices(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST WORD* pIndexData) { D3DDevice_DrawIndexedVertices(PrimitiveType, VertexCount, pIndexData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, VertexCount, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, VertexCount, pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData) { D3DDevice_PrimeVertexCache(VertexCount, pIndexData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage) { return D3DDevice_CreateVertexShader(pDeclaration, pFunction, pHandle, Usage); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShader(DWORD Handle) { D3DDIRTY_VERTEXSHADER(); D3DDevice_SetVertexShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShader(DWORD *pHandle) { D3DDevice_GetVertexShader(pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode) { D3DDevice_SetShaderConstantMode(Mode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode) { D3DDevice_GetShaderConstantMode(pMode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LoadVertexShader(DWORD Handle, DWORD Address) { D3DDevice_LoadVertexShader(Handle, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address) { D3DDevice_LoadVertexShaderProgram(pFunction, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SelectVertexShader(DWORD Handle, DWORD Address) { D3DDevice_SelectVertexShader(Handle, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address) { D3DDevice_SelectVertexShaderDirect(pVAF, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::RunVertexStateShader(DWORD Address, CONST float *pData) { D3DDevice_RunVertexStateShader(Address, pData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderSize(DWORD Handle, UINT *pSize) { D3DDevice_GetVertexShaderSize(Handle, pSize); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderType(DWORD Handle, DWORD *pType) { D3DDevice_GetVertexShaderType(Handle, pType); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderDeclaration(Handle, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderFunction(DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderFunction(Handle, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DDevice::DeleteVertexShader(DWORD Handle) { D3DDevice_DeleteVertexShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_VERTEXSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride) { D3DDIRTY_STREAM(StreamNumber); D3DDevice_SetStreamSource(StreamNumber, pStreamData, Stride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride) { D3DDevice_GetStreamSource(StreamNumber, ppStreamData, pStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetIndices(D3DIndexBuffer* pIndexData, UINT BaseVertexIndex) { D3DDIRTY_INDICES(); D3DDevice_SetIndices(pIndexData, BaseVertexIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetIndices(D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex) { D3DDevice_GetIndices(ppIndexData, pBaseVertexIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle) { D3DDevice_CreatePixelShader(pPSDef, pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShader(DWORD Handle) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShaderProgram(pPSDef); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShader(DWORD *pHandle) { D3DDevice_GetPixelShader(pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DeletePixelShader(DWORD Handle) { D3DDevice_DeletePixelShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_PIXELSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData) { D3DDevice_GetPixelShaderFunction(Handle, pData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo) { return D3DDevice_DrawRectPatch(Handle, pNumSegs, pRectPatchInfo); }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo) { return D3DDevice_DrawTriPatch(Handle, pNumSegs, pTriPatchInfo); }
D3DMINLINE HRESULT WINAPI D3DDevice::DeletePatch(UINT Handle) { D3DDevice_DeletePatch(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey) { D3DDevice_UpdateOverlay(pSurface, SrcRect, DstRect, EnableColorKey, ColorKey); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EnableOverlay(BOOL Enable) { D3DDevice_EnableOverlay(Enable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginVisibilityTest() { D3DDevice_BeginVisibilityTest(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndVisibilityTest(DWORD Index) { return D3DDevice_EndVisibilityTest(Index); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVisibilityTestResult(DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp) { return D3DDevice_GetVisibilityTestResult(Index, pResult, pTimeStamp); }
D3DMINLINE BOOL    WINAPI D3DDevice::IsBusy() { return D3DDevice_IsBusy(); }
D3DMINLINE void    WINAPI D3DDevice::BlockUntilIdle() { D3DDevice_BlockUntilIdle(); }
D3DMINLINE void    WINAPI D3DDevice::KickPushBuffer() { D3DDevice_KickPushBuffer(); }
D3DMINLINE void    WINAPI D3DDevice::SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback) { D3DDevice_SetVerticalBlankCallback(pCallback); }
D3DMINLINE void    WINAPI D3DDevice::SetSwapCallback(D3DSWAPCALLBACK pCallback) { D3DDevice_SetSwapCallback(pCallback); }
D3DMINLINE void    WINAPI D3DDevice::BlockUntilVerticalBlank() { D3DDevice_BlockUntilVerticalBlank(); }
D3DMINLINE DWORD   WINAPI D3DDevice::InsertFence() { return D3DDevice_InsertFence(); }
D3DMINLINE BOOL    WINAPI D3DDevice::IsFencePending(DWORD Fence) { return D3DDevice_IsFencePending(Fence); }
D3DMINLINE void    WINAPI D3DDevice::BlockOnFence(DWORD Fence) { D3DDevice_BlockOnFence(Fence); }
D3DMINLINE void    WINAPI D3DDevice::InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context) { D3DDevice_InsertCallback(Type, pCallback, Context); }
D3DMINLINE void    WINAPI D3DDevice::FlushVertexCache() { D3DDevice_FlushVertexCache(); }
D3DMINLINE HRESULT WINAPI D3DDevice::PersistDisplay() { return D3DDevice_PersistDisplay(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPersistedSurface(IDirect3DSurface8 **ppSurface) { D3DDevice_GetPersistedSurface(ppSurface); return S_OK; }
D3DMINLINE BOOL    WINAPI D3DDevice::GetOverlayUpdateStatus() { return D3DDevice_GetOverlayUpdateStatus(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus) { D3DDevice_GetDisplayFieldStatus(pFieldStatus); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData2f(INT Register, float a, float b) { D3DDevice_SetVertexData2f(Register, a, b); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4f(INT Register, float a, float b, float c, float d) { D3DDevice_SetVertexData4f(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData2s(INT Register, SHORT a, SHORT b) { D3DDevice_SetVertexData2s(Register, a, b); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d) { D3DDevice_SetVertexData4s(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d) { D3DDevice_SetVertexData4ub(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexDataColor(INT Register, D3DCOLOR Color) { D3DDevice_SetVertexDataColor(Register, Color); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Begin(D3DPRIMITIVETYPE PrimitiveType) { D3DDevice_Begin(PrimitiveType); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::End() { D3DDevice_End(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateFixup(UINT Size, D3DFixup **ppFixup) { return D3DDevice_CreateFixup(Size, ppFixup); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer) { return D3DDevice_CreatePushBuffer(Size, RunUsingCpuCopy, ppPushBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginPushBuffer(D3DPushBuffer* pPushBuffer) { D3DDevice_BeginPushBuffer(pPushBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndPushBuffer() { return D3DDevice_EndPushBuffer(); }
D3DMINLINE HRESULT WINAPI D3DDevice::RunPushBuffer(D3DPushBuffer* pPushBuffer, D3DFixup *pFixup) { D3DDevice_RunPushBuffer(pPushBuffer, pFixup); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPushBufferOffset(DWORD* pOffset) { D3DDevice_GetPushBufferOffset(pOffset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Nop() { D3DDevice_Nop(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport) { D3DDevice_GetProjectionViewportMatrix(pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DDevice_SetModelView(pModelView, pInverseModelView, pComposite); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetModelView(D3DMATRIX* pModelView) { return D3DDevice_GetModelView(pModelView); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DDevice_SetVertexBlendModelView(Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport) { return D3DDevice_GetVertexBlendModelView(Count, pModelViews, pProjectionViewport); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInput(Handle, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInputDirect(pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs) { return D3DDevice_GetVertexShaderInput(pHandle, pStreamCount, pStreamInputs); }
D3DMINLINE HRESULT WINAPI D3DDevice::SwitchTexture(DWORD Stage, D3DBaseTexture *pTexture) { D3DDevice_SwitchTexture(D3DTEXTUREDIRECTENCODE[Stage], (pTexture)->Data, (pTexture)->Format); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Suspend() { D3DDevice_Suspend(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Resume(BOOL Reset) { D3DDevice_Resume(Reset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects) { D3DDevice_SetScissors(Count, Exclusive, pRects); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects) { D3DDevice_GetScissors(pCount, pExclusive, pRects); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTile(DWORD Index, CONST D3DTILE* pTile) { D3DDevice_SetTile(Index, pTile); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTile(DWORD Index, D3DTILE* pTile) { D3DDevice_GetTile(Index, pTile); return S_OK; }
D3DMINLINE DWORD   WINAPI D3DDevice::GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag) { return D3DDevice_GetTileCompressionTags(ZStartTag, ZEndTag); }
D3DMINLINE void    WINAPI D3DDevice::SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count) { D3DDevice_SetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DMINLINE void    WINAPI D3DDevice::GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_GetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginPush(DWORD Count, DWORD **ppPush) { D3DDevice_BeginPush(Count, ppPush); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndPush(DWORD *pPush) { D3DDevice_EndPush(pPush); return S_OK; }
D3DMINLINE DWORD   WINAPI D3DDevice::Swap(DWORD Flags) { return D3DDevice_Swap(Flags); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetBackBufferScale(float x, float y) { D3DDevice_SetBackBufferScale(x, y); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackBufferScale(float *pX, float *pY) { D3DDevice_GetBackBufferScale(pX, pY); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetScreenSpaceOffset(float x, float y) { D3DDevice_SetScreenSpaceOffset(x, y); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetScreenSpaceOffset(float *pX, float *pY) { D3DDevice_GetScreenSpaceOffset(pX, pY); return S_OK; }
D3DMINLINE void    WINAPI D3DDevice::SetOverscanColor(D3DCOLOR Color) { D3DDevice_SetOverscanColor(Color); }
D3DMINLINE D3DCOLOR WINAPI D3DDevice::GetOverscanColor() { return D3DDevice_GetOverscanColor(); }
#ifdef _DEBUG
D3DMINLINE DWORD   WINAPI D3DDevice::SetDebugMarker(DWORD Marker) { return D3DDevice_SetDebugMarker(Marker); }
D3DMINLINE DWORD   WINAPI D3DDevice::GetDebugMarker() { return D3DDevice_GetDebugMarker(); }
#else
D3DMINLINE DWORD   WINAPI D3DDevice::SetDebugMarker(DWORD Marker) { return 0; }
D3DMINLINE DWORD   WINAPI D3DDevice::GetDebugMarker() { return 0; }
#endif

#endif __cplusplus

/* D3DResource */

ULONG   WINAPI D3DResource_AddRef(D3DResource *pThis);
ULONG   WINAPI D3DResource_Release(D3DResource *pThis);
void    WINAPI D3DResource_GetDevice(D3DResource *pThis, D3DDevice **ppDevice);
HRESULT WINAPI D3DResource_SetPrivateData(D3DResource *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags);
HRESULT WINAPI D3DResource_GetPrivateData(D3DResource *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData);
void    WINAPI D3DResource_FreePrivateData(D3DResource *pThis, REFGUID refguid);
D3DRESOURCETYPE WINAPI D3DResource_GetType(D3DResource *pThis);
BOOL    WINAPI D3DResource_IsBusy(D3DResource *pThis);
void    WINAPI D3DResource_BlockUntilNotBusy(D3DResource *pThis);
void    WINAPI D3DResource_Register(D3DResource *pThis, void *pBase);
D3DINLINE void WINAPI D3DResource_MoveResourceMemory(D3DResource *pThis, D3DMEMORY where) { }

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DResource8_AddRef(D3DResource *pThis) { return D3DResource_AddRef(pThis); }
D3DINLINE ULONG   WINAPI IDirect3DResource8_Release(D3DResource *pThis) { return D3DResource_Release(pThis); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_GetDevice(D3DResource *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice(pThis, ppDevice); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DResource8_SetPrivateData(D3DResource *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData(pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_GetPrivateData(D3DResource *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData(pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_FreePrivateData(D3DResource *pThis, REFGUID refguid) { D3DResource_FreePrivateData(pThis, refguid); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DResource8_GetType(D3DResource *pThis) { return D3DResource_GetType(pThis); }
D3DINLINE BOOL    WINAPI IDirect3DResource8_IsBusy(D3DResource *pThis) { return D3DResource_IsBusy(pThis); }
D3DINLINE void    WINAPI IDirect3DResource8_BlockUntilNotBusy(D3DResource *pThis) { D3DResource_BlockUntilNotBusy(pThis); }
D3DINLINE void    WINAPI IDirect3DResource8_MoveResourceMemory(D3DResource *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory(pThis, where); }
D3DINLINE void    WINAPI IDirect3DResource8_Register(D3DResource *pThis, void *pBase) { D3DResource_Register(pThis, pBase); }

#ifdef __cplusplus

D3DMINLINE ULONG WINAPI D3DResource::AddRef() { return D3DResource_AddRef(this); }
D3DMINLINE ULONG WINAPI D3DResource::Release() { return D3DResource_Release(this); }
D3DMINLINE HRESULT WINAPI D3DResource::GetDevice(D3DDevice **ppDevice) { D3DResource_GetDevice(this, ppDevice); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DResource::SetPrivateData(REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData(this, refguid, pData, SizeOfData, Flags); }
D3DMINLINE HRESULT WINAPI D3DResource::GetPrivateData(REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData(this, refguid, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DResource::FreePrivateData(REFGUID refguid) { D3DResource_FreePrivateData(this, refguid); return S_OK; }
D3DMINLINE D3DRESOURCETYPE WINAPI D3DResource::GetType() { return D3DResource_GetType(this); }
D3DMINLINE BOOL    WINAPI D3DResource::IsBusy() { return D3DResource_IsBusy(this); }
D3DMINLINE void    WINAPI D3DResource::BlockUntilNotBusy() { D3DResource_BlockUntilNotBusy(this); }
D3DMINLINE void    WINAPI D3DResource::MoveResourceMemory(D3DMEMORY where) { D3DResource_MoveResourceMemory(this, where); }
D3DMINLINE void    WINAPI D3DResource::Register(void *pBase) { D3DResource_Register(this, pBase); }

#endif __cplusplus

/* D3DBaseTexture */

D3DINLINE ULONG   WINAPI D3DBaseTexture_AddRef(D3DBaseTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DBaseTexture_Release(D3DBaseTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_GetDevice(D3DBaseTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DBaseTexture_GetType(D3DBaseTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DBaseTexture_IsBusy(D3DBaseTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_BlockUntilNotBusy(D3DBaseTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_MoveResourceMemory(D3DBaseTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DBaseTexture_Register(D3DBaseTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DBaseTexture_SetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DBaseTexture_GetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DBaseTexture_FreePrivateData(D3DBaseTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

DWORD WINAPI D3DBaseTexture_GetLevelCount(D3DBaseTexture *pThis);

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DBaseTexture8_AddRef(D3DBaseTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DBaseTexture8_Release(D3DBaseTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_GetDevice(D3DBaseTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DBaseTexture8_GetType(D3DBaseTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DBaseTexture8_IsBusy(D3DBaseTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_BlockUntilNotBusy(D3DBaseTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_MoveResourceMemory(D3DBaseTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_Register(D3DBaseTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_SetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_GetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_FreePrivateData(D3DBaseTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE DWORD WINAPI IDirect3DBaseTexture8_GetLevelCount(D3DBaseTexture *pThis) { return D3DBaseTexture_GetLevelCount(pThis); }

#ifdef __cplusplus

D3DMINLINE DWORD WINAPI D3DBaseTexture::GetLevelCount() { return D3DBaseTexture_GetLevelCount(this); }

#endif __cplusplus

/* D3DTexture */

D3DINLINE ULONG   WINAPI D3DTexture_AddRef(D3DTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DTexture_Release(D3DTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_GetDevice(D3DTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DTexture_GetType(D3DTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DTexture_IsBusy(D3DTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_BlockUntilNotBusy(D3DTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_MoveResourceMemory(D3DTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DTexture_Register(D3DTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DTexture_GetLevelCount(D3DTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DTexture_SetPrivateData(D3DTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DTexture_GetPrivateData(D3DTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DTexture_FreePrivateData(D3DTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DTexture_GetLevelDesc(D3DTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
HRESULT WINAPI D3DTexture_GetSurfaceLevel(D3DTexture *pThis, UINT Level, D3DSurface **ppSurfaceLevel);
void    WINAPI D3DTexture_LockRect(D3DTexture *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DTexture_UnlockRect(D3DTexture *pThis, UINT Level) { }

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DTexture8_AddRef(D3DTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DTexture8_Release(D3DTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetDevice(D3DTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DTexture8_GetType(D3DTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DTexture8_IsBusy(D3DTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DTexture8_BlockUntilNotBusy(D3DTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DTexture8_MoveResourceMemory(D3DTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DTexture8_Register(D3DTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DTexture8_GetLevelCount(D3DTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_SetPrivateData(D3DTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetPrivateData(D3DTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_FreePrivateData(D3DTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetLevelDesc(D3DTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc) { D3DTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetSurfaceLevel(D3DTexture *pThis, UINT Level, D3DSurface **ppSurfaceLevel) { return D3DTexture_GetSurfaceLevel(pThis, Level, ppSurfaceLevel); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_LockRect(D3DTexture *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DTexture_LockRect(pThis, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_UnlockRect(D3DTexture *pThis, UINT Level) { D3DTexture_UnlockRect(pThis, Level); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DTexture::GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc) { D3DTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DTexture::GetSurfaceLevel(UINT Level, D3DSurface **ppSurfaceLevel) { return D3DTexture_GetSurfaceLevel(this, Level, ppSurfaceLevel); }
D3DMINLINE HRESULT WINAPI D3DTexture::LockRect(UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DTexture_LockRect(this, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DTexture::UnlockRect(UINT Level) { D3DTexture_UnlockRect(this, Level); return S_OK; }

#endif __cplusplus

/* D3DVolumeTexture */

D3DINLINE ULONG   WINAPI D3DVolumeTexture_AddRef(D3DVolumeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVolumeTexture_Release(D3DVolumeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_GetDevice(D3DVolumeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVolumeTexture_GetType(D3DVolumeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVolumeTexture_IsBusy(D3DVolumeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_BlockUntilNotBusy(D3DVolumeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_MoveResourceMemory(D3DVolumeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVolumeTexture_Register(D3DVolumeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DVolumeTexture_GetLevelCount(D3DVolumeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DVolumeTexture_SetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVolumeTexture_GetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVolumeTexture_FreePrivateData(D3DVolumeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVolumeTexture_GetLevelDesc(D3DVolumeTexture *pThis, UINT Level, D3DVOLUME_DESC *pDesc);
HRESULT WINAPI D3DVolumeTexture_GetVolumeLevel(D3DVolumeTexture *pThis, UINT Level, D3DVolume **ppVolumeLevel);
void    WINAPI D3DVolumeTexture_LockBox(D3DVolumeTexture *pThis, UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
D3DINLINE void WINAPI D3DVolumeTexture_UnlockBox(D3DVolumeTexture *pThis, UINT Level) { }

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DVolumeTexture8_AddRef(D3DVolumeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVolumeTexture8_Release(D3DVolumeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetDevice(D3DVolumeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVolumeTexture8_GetType(D3DVolumeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVolumeTexture8_IsBusy(D3DVolumeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_BlockUntilNotBusy(D3DVolumeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_MoveResourceMemory(D3DVolumeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_Register(D3DVolumeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DVolumeTexture8_GetLevelCount(D3DVolumeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_SetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_FreePrivateData(D3DVolumeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetLevelDesc(D3DVolumeTexture *pThis, UINT Level, D3DVOLUME_DESC *pDesc) { D3DVolumeTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetVolumeLevel(D3DVolumeTexture *pThis, UINT Level, D3DVolume **ppVolumeLevel) { return D3DVolumeTexture_GetVolumeLevel(pThis, Level, ppVolumeLevel); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_LockBox(D3DVolumeTexture *pThis, UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolumeTexture_LockBox(pThis, Level, pLockedVolume, pBox, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_UnlockBox(D3DVolumeTexture *pThis, UINT Level) { D3DVolumeTexture_UnlockBox(pThis, Level); return S_OK; }


#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVolumeTexture::GetLevelDesc(UINT Level, D3DVOLUME_DESC *pDesc) { D3DVolumeTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::GetVolumeLevel(UINT Level, D3DVolume **ppVolumeLevel) { return D3DVolumeTexture_GetVolumeLevel(this, Level, ppVolumeLevel); }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::LockBox(UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolumeTexture_LockBox(this, Level, pLockedVolume, pBox, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::UnlockBox(UINT Level) { D3DVolumeTexture_UnlockBox(this, Level); return S_OK; }

#endif __cplusplus

/* D3DCubeTexture */

D3DINLINE ULONG   WINAPI D3DCubeTexture_AddRef(D3DCubeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DCubeTexture_Release(D3DCubeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_GetDevice(D3DCubeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DCubeTexture_GetType(D3DCubeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DCubeTexture_IsBusy(D3DCubeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_BlockUntilNotBusy(D3DCubeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_MoveResourceMemory(D3DCubeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DCubeTexture_Register(D3DCubeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DCubeTexture_GetLevelCount(D3DCubeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DCubeTexture_SetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DCubeTexture_GetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DCubeTexture_FreePrivateData(D3DCubeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DCubeTexture_GetLevelDesc(D3DCubeTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
HRESULT WINAPI D3DCubeTexture_GetCubeMapSurface(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface);
void    WINAPI D3DCubeTexture_LockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DCubeTexture_UnlockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level) { }

D3DINLINE ULONG   WINAPI IDirect3DCubeTexture8_AddRef(D3DCubeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DCubeTexture8_Release(D3DCubeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetDevice(D3DCubeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DCubeTexture8_GetType(D3DCubeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DCubeTexture8_IsBusy(D3DCubeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_BlockUntilNotBusy(D3DCubeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_MoveResourceMemory(D3DCubeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_Register(D3DCubeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DCubeTexture8_GetLevelCount(D3DCubeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_SetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_FreePrivateData(D3DCubeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetLevelDesc(D3DCubeTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc) { D3DCubeTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetCubeMapSurface(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface) { return D3DCubeTexture_GetCubeMapSurface(pThis, FaceType, Level, ppCubeMapSurface); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_LockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DCubeTexture_LockRect(pThis, FaceType, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_UnlockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level) { D3DCubeTexture_UnlockRect(pThis, FaceType, Level); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DCubeTexture::GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc) { D3DCubeTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface) { return D3DCubeTexture_GetCubeMapSurface(this, FaceType, Level, ppCubeMapSurface); }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DCubeTexture_LockRect(this, FaceType, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level) { D3DCubeTexture_UnlockRect(this, FaceType, Level); return S_OK; }

#endif __cplusplus

/* D3DVertexBuffer */

D3DINLINE ULONG   WINAPI D3DVertexBuffer_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVertexBuffer_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVertexBuffer_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVertexBuffer_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_BlockUntilNotBusy(D3DVertexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVertexBuffer_Register(D3DVertexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DVertexBuffer_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVertexBuffer_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVertexBuffer_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVertexBuffer_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
void    WINAPI D3DVertexBuffer_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc);
D3DINLINE void WINAPI D3DVertexBuffer_Unlock(D3DVertexBuffer *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DVertexBuffer8_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVertexBuffer8_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVertexBuffer8_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVertexBuffer8_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_BlockUntilNotBusy(D3DVertexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_Register(D3DVertexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DVertexBuffer_Lock(pThis, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_Unlock(D3DVertexBuffer *pThis) { D3DVertexBuffer_Unlock(pThis); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc) { D3DVertexBuffer_GetDesc(pThis, pDesc); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVertexBuffer::Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DVertexBuffer_Lock(this, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVertexBuffer::Unlock() { D3DVertexBuffer_Unlock(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVertexBuffer::GetDesc(D3DVERTEXBUFFER_DESC *pDesc) { D3DVertexBuffer_GetDesc(this, pDesc); return S_OK; }

#endif __cplusplus

/* D3DIndexBuffer */

D3DINLINE ULONG   WINAPI D3DIndexBuffer_AddRef(D3DIndexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DIndexBuffer_Release(D3DIndexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_GetDevice(D3DIndexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DIndexBuffer_GetType(D3DIndexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DIndexBuffer_IsBusy(D3DIndexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_BlockUntilNotBusy(D3DIndexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_MoveResourceMemory(D3DIndexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DIndexBuffer_Register(D3DIndexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DIndexBuffer_SetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DIndexBuffer_GetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DIndexBuffer_FreePrivateData(D3DIndexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

D3DINLINE void    WINAPI D3DIndexBuffer_Lock(D3DIndexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { *(ppbData) = (BYTE*) (pThis)->Data + (OffsetToLock); }
D3DINLINE void    WINAPI D3DIndexBuffer_Unlock(D3DIndexBuffer *pThis) { }
void    WINAPI D3DIndexBuffer_GetDesc(D3DIndexBuffer *pThis, D3DINDEXBUFFER_DESC *pDesc);

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DIndexBuffer8_AddRef(D3DIndexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DIndexBuffer8_Release(D3DIndexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetDevice(D3DIndexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DIndexBuffer8_GetType(D3DIndexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DIndexBuffer8_IsBusy(D3DIndexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_BlockUntilNotBusy(D3DIndexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_MoveResourceMemory(D3DIndexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_Register(D3DIndexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_SetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_FreePrivateData(D3DIndexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_Lock(D3DIndexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DIndexBuffer_Lock(pThis, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_Unlock(D3DIndexBuffer *pThis) { D3DIndexBuffer_Unlock(pThis); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetDesc(D3DIndexBuffer *pThis, D3DINDEXBUFFER_DESC *pDesc) { D3DIndexBuffer_GetDesc(pThis, pDesc); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DIndexBuffer::Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DIndexBuffer_Lock(this, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DIndexBuffer::Unlock() { D3DIndexBuffer_Unlock(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DIndexBuffer::GetDesc(D3DINDEXBUFFER_DESC *pDesc) { D3DIndexBuffer_GetDesc(this, pDesc); return S_OK; }

#endif __cplusplus

/* D3DPalette */

D3DINLINE ULONG   WINAPI D3DPalette_AddRef(D3DPalette *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DPalette_Release(D3DPalette *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_GetDevice(D3DPalette *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DPalette_GetType(D3DPalette *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DPalette_IsBusy(D3DPalette *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_BlockUntilNotBusy(D3DPalette *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_MoveResourceMemory(D3DPalette *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DPalette_Register(D3DPalette *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DPalette_SetPrivateData(D3DPalette *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DPalette_GetPrivateData(D3DPalette *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DPalette_FreePrivateData(D3DPalette *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DPalette_Lock(D3DPalette *pThis, D3DCOLOR **ppColor, DWORD Flags);
D3DPALETTESIZE WINAPI D3DPalette_GetSize(D3DPalette *pThis);
D3DINLINE void WINAPI D3DPalette_Unlock(D3DPalette *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DPalette8_AddRef(D3DPalette *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DPalette8_Release(D3DPalette *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_GetDevice(D3DPalette *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DPalette8_GetType(D3DPalette *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DPalette8_IsBusy(D3DPalette *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPalette8_BlockUntilNotBusy(D3DPalette *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPalette8_MoveResourceMemory(D3DPalette *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DPalette8_Register(D3DPalette *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_SetPrivateData(D3DPalette *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_GetPrivateData(D3DPalette *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_FreePrivateData(D3DPalette *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DPalette8_Lock(D3DPalette *pThis, D3DCOLOR **ppColor, DWORD Flags) { D3DPalette_Lock(pThis, ppColor, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_Unlock(D3DPalette *pThis) { D3DPalette_Unlock(pThis); return S_OK; }
D3DINLINE D3DPALETTESIZE WINAPI IDirect3DPalette8_GetSize(D3DPalette *pThis) { return D3DPalette_GetSize(pThis); }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DPalette::Lock(D3DCOLOR **ppColors, DWORD Flags) { D3DPalette_Lock(this, ppColors, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPalette::Unlock() { D3DPalette_Unlock(this); return S_OK; }
D3DMINLINE D3DPALETTESIZE WINAPI D3DPalette::GetSize() { return D3DPalette_GetSize(this); }

#endif __cplusplus

/* D3DPushBuffer */

D3DINLINE ULONG   WINAPI D3DPushBuffer_AddRef(D3DPushBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DPushBuffer_Release(D3DPushBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_GetDevice(D3DPushBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DPushBuffer_GetType(D3DPushBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DPushBuffer_IsBusy(D3DPushBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_BlockUntilNotBusy(D3DPushBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_MoveResourceMemory(D3DPushBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DPushBuffer_Register(D3DPushBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DPushBuffer_SetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DPushBuffer_GetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DPushBuffer_FreePrivateData(D3DPushBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DPushBuffer_Verify(D3DPushBuffer* pPushBuffer, BOOL StampResources);
void    WINAPI D3DPushBuffer_BeginFixup(D3DPushBuffer* pPushBuffer, D3DFixup* pFixup, BOOL NoWait);
HRESULT WINAPI D3DPushBuffer_EndFixup(D3DPushBuffer* pPushBuffer);
void    WINAPI D3DPushBuffer_RunPushBuffer(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup);
void    WINAPI D3DPushBuffer_SetModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
void    WINAPI D3DPushBuffer_SetVertexBlendModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
void    WINAPI D3DPushBuffer_SetVertexShaderInput(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
void    WINAPI D3DPushBuffer_SetVertexShaderInputDirect(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
void    WINAPI D3DPushBuffer_SetRenderTarget(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer);
void    WINAPI D3DPushBuffer_SetTexture(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture);
void    WINAPI D3DPushBuffer_SetPalette(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage,D3DPalette *pPalette);
HRESULT WINAPI D3DPushBuffer_EndVisibilityTest(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Index);
void    WINAPI D3DPushBuffer_SetVertexShaderConstant(D3DPushBuffer* pPushBuffer, DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount);
void    WINAPI D3DPushBuffer_Jump(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT DestinationOffset);

D3DINLINE ULONG   WINAPI IDirect3DPushBuffer8_AddRef(D3DPushBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DPushBuffer8_Release(D3DPushBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetDevice(D3DPushBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DPushBuffer8_GetType(D3DPushBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DPushBuffer8_IsBusy(D3DPushBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_BlockUntilNotBusy(D3DPushBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_MoveResourceMemory(D3DPushBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_Register(D3DPushBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_FreePrivateData(D3DPushBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_Verify(D3DPushBuffer* pPushBuffer, BOOL StampResources) { D3DPushBuffer_Verify(pPushBuffer, StampResources); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_BeginFixup(D3DPushBuffer* pPushBuffer, D3DFixup* pFixup, BOOL NoWait) { D3DPushBuffer_BeginFixup(pPushBuffer, pFixup, NoWait); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_EndFixup(D3DPushBuffer* pPushBuffer) { return D3DPushBuffer_EndFixup(pPushBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_RunPushBuffer(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup) { D3DPushBuffer_RunPushBuffer(pPushBuffer, Offset, pDestinationPushBuffer, pDestinationFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DPushBuffer_SetModelView(pPushBuffer, Offset, pModelView, pInverseModelView, pComposite); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexBlendModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DPushBuffer_SetVertexBlendModelView(pPushBuffer, Offset, Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderInput(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInput(pPushBuffer, Offset, Handle, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderInputDirect(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInputDirect(pPushBuffer, Offset, pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetRenderTarget(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer) { D3DPushBuffer_SetRenderTarget(pPushBuffer, Offset, pRenderTarget, pZBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetTexture(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture) { D3DPushBuffer_SetTexture(pPushBuffer, Offset, Stage, pTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetPalette(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage,D3DPalette *pPalette) { D3DPushBuffer_SetPalette(pPushBuffer, Offset, Stage, pPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_EndVisibilityTest(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Index) { return D3DPushBuffer_EndVisibilityTest(pPushBuffer, Offset, Index); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderConstant(D3DPushBuffer* pPushBuffer, DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount) { D3DPushBuffer_SetVertexShaderConstant(pPushBuffer, Offset, Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_Jump(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT DestinationOffset) { D3DPushBuffer_Jump(pPushBuffer, Offset, DestinationOffset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetSize(D3DPushBuffer* pPushBuffer, DWORD* pSize) { *pSize = pPushBuffer->Size; return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DPushBuffer::Verify(BOOL StampResources) { D3DPushBuffer_Verify(this, StampResources); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::BeginFixup(D3DFixup* pFixup, BOOL NoWait) { D3DPushBuffer_BeginFixup(this, pFixup, NoWait); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::EndFixup() { return D3DPushBuffer_EndFixup(this); }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::RunPushBuffer(DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup) { D3DPushBuffer_RunPushBuffer(this, Offset, pDestinationPushBuffer, pDestinationFixup); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetModelView(DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DPushBuffer_SetModelView(this, Offset, pModelView, pInverseModelView, pComposite); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexBlendModelView(DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DPushBuffer_SetVertexBlendModelView(this, Offset, Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderInput(DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInput(this, Offset, Handle, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderInputDirect(DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInputDirect(this, Offset, pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetRenderTarget(DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer) { D3DPushBuffer_SetRenderTarget(this, Offset, pRenderTarget, pZBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetTexture(DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture) { D3DPushBuffer_SetTexture(this, Offset, Stage, pTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetPalette(DWORD Offset, DWORD Stage,D3DPalette *pPalette) { D3DPushBuffer_SetPalette(this, Offset, Stage, pPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::EndVisibilityTest(DWORD Offset, DWORD Index) { return D3DPushBuffer_EndVisibilityTest(this, Offset, Index); }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderConstant(DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount) { D3DPushBuffer_SetVertexShaderConstant(this, Offset, Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::Jump(DWORD Offset, UINT DestinationOffset) { D3DPushBuffer_Jump(this, Offset, DestinationOffset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::GetSize(DWORD* pSize) { *pSize = Size; return S_OK; }

#endif __cplusplus

/* D3DFixup */

D3DINLINE ULONG   WINAPI D3DFixup_AddRef(D3DFixup *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DFixup_Release(D3DFixup *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_GetDevice(D3DFixup *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DFixup_GetType(D3DFixup *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DFixup_IsBusy(D3DFixup *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_BlockUntilNotBusy(D3DFixup *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_MoveResourceMemory(D3DFixup *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DFixup_Register(D3DFixup *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DFixup_SetPrivateData(D3DFixup *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DFixup_GetPrivateData(D3DFixup *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DFixup_FreePrivateData(D3DFixup *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DFixup_Reset(D3DFixup* pFixup);
void    WINAPI D3DFixup_GetSize(D3DFixup* pFixup, DWORD* pSize);
void    WINAPI D3DFixup_GetSpace(D3DFixup* pFixup, DWORD* pSpace);

D3DINLINE ULONG   WINAPI IDirect3DFixup8_AddRef(D3DFixup *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DFixup8_Release(D3DFixup *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetDevice(D3DFixup *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DFixup8_GetType(D3DFixup *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DFixup8_IsBusy(D3DFixup *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DFixup8_BlockUntilNotBusy(D3DFixup *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DFixup8_MoveResourceMemory(D3DFixup *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DFixup8_Register(D3DFixup *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_SetPrivateData(D3DFixup *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetPrivateData(D3DFixup *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_FreePrivateData(D3DFixup *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DFixup8_Reset(D3DFixup* pFixup) { D3DFixup_Reset(pFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetSize(D3DFixup* pFixup, DWORD* pSize) { D3DFixup_GetSize(pFixup, pSize); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetSpace(D3DFixup* pFixup, DWORD* pSpace) { D3DFixup_GetSpace(pFixup, pSpace); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DFixup::Reset() { D3DFixup_Reset(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DFixup::GetSize(DWORD* pSize) { D3DFixup_GetSize(this, pSize); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DFixup::GetSpace(DWORD* pSpace) { D3DFixup_GetSpace(this, pSpace); return S_OK; }

#endif __cplusplus

/* D3DSurface */

D3DINLINE ULONG   WINAPI D3DSurface_AddRef(D3DSurface *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DSurface_Release(D3DSurface *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_GetDevice(D3DSurface *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DSurface_GetType(D3DSurface *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DSurface_IsBusy(D3DSurface *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_BlockUntilNotBusy(D3DSurface *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_MoveResourceMemory(D3DSurface *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DSurface_Register(D3DSurface *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DSurface_SetPrivateData(D3DSurface *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DSurface_GetPrivateData(D3DSurface *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DSurface_FreePrivateData(D3DSurface *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

HRESULT WINAPI D3DSurface_GetContainer(D3DSurface *pThis, D3DBaseTexture **ppBaseTexture);
void    WINAPI D3DSurface_GetDesc(D3DSurface *pThis, D3DSURFACE_DESC *pDesc);
void    WINAPI D3DSurface_LockRect(D3DSurface *pThis, D3DLOCKED_RECT *pLockedRect,CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DSurface_UnlockRect(D3DSurface *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DSurface8_AddRef(D3DSurface *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DSurface8_Release(D3DSurface *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetDevice(D3DSurface *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DSurface8_GetType(D3DSurface *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DSurface8_IsBusy(D3DSurface *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DSurface8_BlockUntilNotBusy(D3DSurface *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DSurface8_MoveResourceMemory(D3DSurface *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DSurface8_Register(D3DSurface *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_SetPrivateData(D3DSurface *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetPrivateData(D3DSurface *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_FreePrivateData(D3DSurface *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetContainer(D3DSurface *pThis, D3DBaseTexture **ppBaseTexture) { return D3DSurface_GetContainer(pThis, ppBaseTexture); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetDesc(D3DSurface *pThis, D3DSURFACE_DESC *pDesc) { D3DSurface_GetDesc(pThis, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_LockRect(D3DSurface *pThis, D3DLOCKED_RECT *pLockedRect,CONST RECT *pRect, DWORD Flags) { D3DSurface_LockRect(pThis, pLockedRect,pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_UnlockRect(D3DSurface *pThis) { D3DSurface_UnlockRect(pThis); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DSurface::GetContainer(D3DBaseTexture **ppBaseTexture) { return D3DSurface_GetContainer(this, ppBaseTexture); }
D3DMINLINE HRESULT WINAPI D3DSurface::GetDesc(D3DSURFACE_DESC *pDesc) { D3DSurface_GetDesc(this, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DSurface::LockRect(D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DSurface_LockRect(this, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DSurface::UnlockRect() { D3DSurface_UnlockRect(this); return S_OK; }

#endif __cplusplus

/* D3DVolume */

D3DINLINE ULONG   WINAPI D3DVolume_AddRef(D3DVolume *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVolume_Release(D3DVolume *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_GetDevice(D3DVolume *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVolume_GetType(D3DVolume *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVolume_IsBusy(D3DVolume *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_BlockUntilNotBusy(D3DVolume *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_MoveResourceMemory(D3DVolume *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVolume_Register(D3DVolume *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DVolume_SetPrivateData(D3DVolume *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVolume_GetPrivateData(D3DVolume *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVolume_FreePrivateData(D3DVolume *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVolume_GetContainer(D3DVolume *pThis, D3DBaseTexture **ppBaseTexture);
void    WINAPI D3DVolume_GetDesc(D3DVolume *pThis, D3DVOLUME_DESC *pDesc);
void    WINAPI D3DVolume_LockBox(D3DVolume *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
D3DINLINE void WINAPI D3DVolume_UnlockBox(D3DVolume *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DVolume8_AddRef(D3DVolume *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVolume8_Release(D3DVolume *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetDevice(D3DVolume *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVolume8_GetType(D3DVolume *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVolume8_IsBusy(D3DVolume *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolume8_BlockUntilNotBusy(D3DVolume *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolume8_MoveResourceMemory(D3DVolume *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVolume8_Register(D3DVolume *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_SetPrivateData(D3DVolume *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetPrivateData(D3DVolume *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_FreePrivateData(D3DVolume *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetContainer(D3DVolume *pThis, D3DBaseTexture **ppBaseTexture) { D3DVolume_GetContainer(pThis, ppBaseTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetDesc(D3DVolume *pThis, D3DVOLUME_DESC *pDesc) { D3DVolume_GetDesc(pThis, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_LockBox(D3DVolume *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolume_LockBox(pThis, pLockedVolume, pBox, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_UnlockBox(D3DVolume *pThis) { D3DVolume_UnlockBox(pThis); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVolume::GetContainer(D3DBaseTexture **ppBaseTexture) { D3DVolume_GetContainer(this, ppBaseTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::GetDesc(D3DVOLUME_DESC *pDesc) { D3DVolume_GetDesc(this, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::LockBox(D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolume_LockBox(this, pLockedVolume, pBox, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::UnlockBox() { D3DVolume_UnlockBox(this); return S_OK; }

#endif __cplusplus

#ifdef __cplusplus
};
#endif

#pragma warning( pop )

#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\custcntl.h ===
/*****************************************************************************\
*                                                                             *
* custcntl.h -  Custom Control Library header file                            *
*                                                                             *
*               Copyright (c) 1992-1999, Microsoft Corp.  All rights reserved *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CUSTCNTL
#define _INC_CUSTCNTL

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


/*
 * General size defines.
 */
#define CCHCCCLASS          32          // Max chars in a class name.
#define CCHCCDESC           32          // Max chars in a control description.
#define CCHCCTEXT           256         // Max chars in a text field.


/*
 * CCSTYLE - Custom Control Style structure.  This structure is passed
 * tp the Custom Control Style function when the user wants to edit the
 * styles of the custom control.
 */
typedef struct tagCCSTYLEA {
    DWORD   flStyle;                    // Style of the control.
    DWORD   flExtStyle;                 // Extended style of the control.
    CHAR    szText[CCHCCTEXT];          // Text of the control.
    LANGID  lgid;                       // Language Id of the control's dialog.
    WORD    wReserved1;                 // Reserved value.  Do not change.
} CCSTYLEA, *LPCCSTYLEA;

typedef struct tagCCSTYLEW {
    DWORD   flStyle;                    // Style of the control.
    DWORD   flExtStyle;                 // Extended style of the control.
    WCHAR   szText[CCHCCTEXT];          // Text of the control.
    LANGID  lgid;                       // Language Id of the control's dialog.
    WORD    wReserved1;                 // Reserved value.  Do not change.
} CCSTYLEW, *LPCCSTYLEW;

#ifdef UNICODE
#define CCSTYLE     CCSTYLEW
#define LPCCSTYLE   LPCCSTYLEW
#else
#define CCSTYLE     CCSTYLEA
#define LPCCSTYLE   LPCCSTYLEA
#endif // UNICODE


/*
 * The Style function prototype.  This will be called when the user
 * wants to edit the styles of a custom control.  It should display a
 * dialog to edit the styles, update the styles in the pccs structure,
 * then return TRUE for success.  If an error occurs or the user
 * cancels the dialog, FALSE should be returned.
 */
typedef BOOL (CALLBACK* LPFNCCSTYLEA)(HWND hwndParent,  LPCCSTYLEA pccs);
typedef BOOL (CALLBACK* LPFNCCSTYLEW)(HWND hwndParent,  LPCCSTYLEW pccs);

#ifdef UNICODE
#define LPFNCCSTYLE LPFNCCSTYLEW
#else
#define LPFNCCSTYLE LPFNCCSTYLEA
#endif  // UNICODE


/*
 * The SizeToText function prototype.  This will be called if the user
 * requests that the custom control be sized to fit it's text.  It
 * should use the specified styles, text and font to determine how
 * large the control must be to accommodate the text, then return this
 * value in pixels.  The value of -1 should be returned if an error
 * occurs.
 */
typedef INT (CALLBACK* LPFNCCSIZETOTEXTA)(DWORD flStyle, DWORD flExtStyle,
    HFONT hfont, LPSTR pszText);
typedef INT (CALLBACK* LPFNCCSIZETOTEXTW)(DWORD flStyle, DWORD flExtStyle,
    HFONT hfont, LPWSTR pszText);

#ifdef UNICODE
#define LPFNCCSIZETOTEXT    LPFNCCSIZETOTEXTW
#else
#define LPFNCCSIZETOTEXT    LPFNCCSIZETOTEXTA
#endif  // UNICODE


/*
 * CCSTYLEFLAG - Custom Control Style Flag structure.  A table of these
 * structures is used to specify the define strings that match the
 * different styles for a custom control.
 */
typedef struct tagCCSTYLEFLAGA {
    DWORD flStyle;                      // Style bits for this style.
    DWORD flStyleMask;                  // Mask for the style.  Can be zero.
    LPSTR pszStyle;                     // Points to the style define string.
} CCSTYLEFLAGA, *LPCCSTYLEFLAGA;

typedef struct tagCCSTYLEFLAGW {
    DWORD flStyle;                      // Style bits for this style.
    DWORD flStyleMask;                  // Mask for the style.  Can be zero.
    LPWSTR pszStyle;                    // Points to the style define string.
} CCSTYLEFLAGW, *LPCCSTYLEFLAGW;

#ifdef UNICODE
#define CCSTYLEFLAG     CCSTYLEFLAGW
#define LPCCSTYLEFLAG   LPCCSTYLEFLAGW
#else
#define CCSTYLEFLAG     CCSTYLEFLAGA
#define LPCCSTYLEFLAG   LPCCSTYLEFLAGA
#endif // UNICODE


/*
 * CCF_* defines.  These flags are used for the flOptions field of the
 * CCINFO structure, and describe some basic characteristics of the
 * custom control.
 */
#define CCF_NOTEXT          0x00000001  // Control cannot have text.


/*
 * CCINFO - Custom Control Info structure.  This structure provides
 * the dialog editor with information about the control types that the
 * DLL supports.
 */
typedef struct tagCCINFOA {
    CHAR    szClass[CCHCCCLASS];        // Class name for the control.
    DWORD   flOptions;                  // Option flags (CCF_* defines).
    CHAR    szDesc[CCHCCDESC];          // Short, descriptive text for the ctrl.
    UINT    cxDefault;                  // Default width (in dialog units).
    UINT    cyDefault;                  // Default height (in dialog units).
    DWORD   flStyleDefault;             // Default style (WS_CHILD | WS_VISIBLE).
    DWORD   flExtStyleDefault;          // Default extended style.
    DWORD   flCtrlTypeMask;             // Mask for control type styles.
    CHAR    szTextDefault[CCHCCTEXT];   // Default text.
    INT     cStyleFlags;                // Entries in the following style table.
    LPCCSTYLEFLAGA aStyleFlags;         // Points to style flag table.
    LPFNCCSTYLEA lpfnStyle;             // Pointer to the Styles function.
    LPFNCCSIZETOTEXTA lpfnSizeToText;   // Pointer to the SizeToText function.
    DWORD   dwReserved1;                // Reserved.  Must be zero.
    DWORD   dwReserved2;                // Reserved.  Must be zero.
} CCINFOA, *LPCCINFOA;

typedef struct tagCCINFOW {
    WCHAR   szClass[CCHCCCLASS];        // Class name for the control.
    DWORD   flOptions;                  // Option flags (CCF_* defines).
    WCHAR   szDesc[CCHCCDESC];          // Short, descriptive text for the ctrl.
    UINT    cxDefault;                  // Default width (in dialog units).
    UINT    cyDefault;                  // Default height (in dialog units).
    DWORD   flStyleDefault;             // Default style (WS_CHILD | WS_VISIBLE).
    DWORD   flExtStyleDefault;          // Default extended style.
    DWORD   flCtrlTypeMask;             // Mask for control type styles.
    INT     cStyleFlags;                // Entries in the following style table.
    LPCCSTYLEFLAGW aStyleFlags;         // Points to style flag table.
    WCHAR   szTextDefault[CCHCCTEXT];   // Default text.
    LPFNCCSTYLEW lpfnStyle;             // Pointer to the Styles function.
    LPFNCCSIZETOTEXTW lpfnSizeToText;   // Pointer to the SizeToText function.
    DWORD   dwReserved1;                // Reserved.  Must be zero.
    DWORD   dwReserved2;                // Reserved.  Must be zero.
} CCINFOW, *LPCCINFOW;

#ifdef UNICODE
#define CCINFO      CCINFOW
#define LPCCINFO    LPCCINFOW
#else
#define CCINFO      CCINFOA
#define LPCCINFO    LPCCINFOA
#endif // UNICODE


/*
 * The Info function prototype.  This function is the first one
 * called by the dialog editor.  Custom control DLL's must export
 * one or both of the following functions by name (the ordinal
 * used for the export does not matter):
 *
 *  UINT CALLBACK CustomControlInfoA(LPCCINFOA acci)
 *  UINT CALLBACK CustomControlInfoW(LPCCINFOW acci)
 *
 * This function must return the number of controls that the DLL
 * supports, or NULL if an error occurs.  If the acci parameter is
 * not NULL, it will be pointing to an array of CCINFOA or CCINFOW
 * structures that should be filled in with the information about
 * the different control types supported by the DLL.
 *
 * If both functions are present, the CustomControlInfoW function
 * will be used by the dialog editor.
 */
typedef UINT (CALLBACK* LPFNCCINFOA)(LPCCINFOA acci);
typedef UINT (CALLBACK* LPFNCCINFOW)(LPCCINFOW acci);

#ifdef UNICODE
#define LPFNCCINFO  LPFNCCINFOW
#else
#define LPFNCCINFO  LPFNCCINFOA
#endif  // UNICODE


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_CUSTCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3d.h ===
/*==========================================================================;
 *
 *
 *  File:   d3d.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D_H_
#define _D3D_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0700
#endif

// include this file content only if compiling for <=DX7 interfaces
#if(DIRECT3D_VERSION < 0x0800)


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#define D3DAPI WINAPI

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)
DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3D2,            0x6aae1ec1,0x662a,0x11d0,0x88,0x9d,0x00,0xaa,0x00,0xbb,0xb7,0x6a);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3D3,            0xbb223240,0xe72b,0x11d0,0xa9,0xb4,0x00,0xaa,0x00,0xc0,0x99,0x3e);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3D7,            0xf5049e77,0x4861,0x11d2,0xa4,0x7,0x0,0xa0,0xc9,0x6,0x29,0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DRefDevice,    0x50936643, 0x13e9, 0x11d1, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DNullDevice, 0x8767df22, 0xbacc, 0x11d1, 0x89, 0x69, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DTnLHalDevice, 0xf5049e78, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Internal Guid to distinguish requested MMX from MMX being used as an RGB rasterizer
 */

DEFINE_GUID( IID_IDirect3DDevice,       0x64108800,0x957d,0X11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DDevice2,  0x93281501, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DDevice3,  0xb0ab3b60, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DDevice7,  0xf5049e79, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DTexture2, 0x93281502, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */

DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );

DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DMaterial2,    0x93281503, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DMaterial3,    0xca9c46f4, 0xd3c5, 0x11d1, 0xb7, 0x5a, 0x0, 0x60, 0x8, 0x52, 0xb3, 0x12);
#endif /* DIRECT3D_VERSION >= 0x0600 */

DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DViewport2,    0x93281500, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DViewport3,    0xb0ab3b61, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DVertexBuffer, 0x7a503555, 0x4a83, 0x11d1, 0xa5, 0xdb, 0x0, 0xa0, 0xc9, 0x3, 0x67, 0xf8);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DVertexBuffer7, 0xf5049e7d, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */
#endif

#ifdef __cplusplus
struct IDirect3D;
struct IDirect3DDevice;
struct IDirect3DLight;
struct IDirect3DMaterial;
struct IDirect3DExecuteBuffer;
struct IDirect3DTexture;
struct IDirect3DViewport;
typedef struct IDirect3D            *LPDIRECT3D;
typedef struct IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight       *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport    *LPDIRECT3DVIEWPORT;

#if(DIRECT3D_VERSION >= 0x0500)
struct IDirect3D2;
struct IDirect3DDevice2;
struct IDirect3DMaterial2;
struct IDirect3DTexture2;
struct IDirect3DViewport2;
typedef struct IDirect3D2           *LPDIRECT3D2;
typedef struct IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef struct IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef struct IDirect3DTexture2    *LPDIRECT3DTEXTURE2;
typedef struct IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
struct IDirect3D3;
struct IDirect3DDevice3;
struct IDirect3DMaterial3;
struct IDirect3DViewport3;
struct IDirect3DVertexBuffer;
typedef struct IDirect3D3            *LPDIRECT3D3;
typedef struct IDirect3DDevice3      *LPDIRECT3DDEVICE3;
typedef struct IDirect3DMaterial3    *LPDIRECT3DMATERIAL3;
typedef struct IDirect3DViewport3    *LPDIRECT3DVIEWPORT3;
typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
struct IDirect3D7;
struct IDirect3DDevice7;
struct IDirect3DVertexBuffer7;
typedef struct IDirect3D7             *LPDIRECT3D7;
typedef struct IDirect3DDevice7       *LPDIRECT3DDEVICE7;
typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#else

typedef struct IDirect3D        *LPDIRECT3D;
typedef struct IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight       *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport    *LPDIRECT3DVIEWPORT;

#if(DIRECT3D_VERSION >= 0x0500)
typedef struct IDirect3D2           *LPDIRECT3D2;
typedef struct IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef struct IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef struct IDirect3DTexture2    *LPDIRECT3DTEXTURE2;
typedef struct IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
typedef struct IDirect3D3            *LPDIRECT3D3;
typedef struct IDirect3DDevice3      *LPDIRECT3DDEVICE3;
typedef struct IDirect3DMaterial3    *LPDIRECT3DMATERIAL3;
typedef struct IDirect3DViewport3    *LPDIRECT3DVIEWPORT3;
typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct IDirect3D7             *LPDIRECT3D7;
typedef struct IDirect3DDevice7       *LPDIRECT3DDEVICE7;
typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#endif

#include "d3dtypes.h"
#include "d3dcaps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Direct3D interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3D

DECLARE_INTERFACE_(IDirect3D, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D methods ***/
    STDMETHOD(Initialize)(THIS_ REFCLSID) PURE;
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,IUnknown*) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL*,IUnknown*) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT*,IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
};

typedef struct IDirect3D *LPDIRECT3D;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3D_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#else
#define IDirect3D_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D_AddRef(p) (p)->AddRef()
#define IDirect3D_Release(p) (p)->Release()
#define IDirect3D_Initialize(p,a) (p)->Initialize(a)
#define IDirect3D_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D_FindDevice(p,a,b) (p)->FindDevice(a,b)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3D2

DECLARE_INTERFACE_(IDirect3D2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D2 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,IUnknown*) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL2*,IUnknown*) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT2*,IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE,LPDIRECT3DDEVICE2*) PURE;
};

typedef struct IDirect3D2 *LPDIRECT3D2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D2_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D2_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D2_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D2_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D2_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#define IDirect3D2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#else
#define IDirect3D2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D2_AddRef(p) (p)->AddRef()
#define IDirect3D2_Release(p) (p)->Release()
#define IDirect3D2_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D2_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D2_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D2_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D2_FindDevice(p,a,b) (p)->FindDevice(a,b)
#define IDirect3D2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3D3

DECLARE_INTERFACE_(IDirect3D3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D3 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,LPUNKNOWN) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL3*,LPUNKNOWN) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT3*,LPUNKNOWN) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE4,LPDIRECT3DDEVICE3*,LPUNKNOWN) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ LPD3DVERTEXBUFFERDESC,LPDIRECT3DVERTEXBUFFER*,DWORD,LPUNKNOWN) PURE;
    STDMETHOD(EnumZBufferFormats)(THIS_ REFCLSID,LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(EvictManagedTextures)(THIS) PURE;
};

typedef struct IDirect3D3 *LPDIRECT3D3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D3_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D3_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D3_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D3_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D3_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#define IDirect3D3_CreateDevice(p,a,b,c,d) (p)->lpVtbl->CreateDevice(p,a,b,c,d)
#define IDirect3D3_CreateVertexBuffer(p,a,b,c,d) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c,d)
#define IDirect3D3_EnumZBufferFormats(p,a,b,c) (p)->lpVtbl->EnumZBufferFormats(p,a,b,c)
#define IDirect3D3_EvictManagedTextures(p) (p)->lpVtbl->EvictManagedTextures(p)
#else
#define IDirect3D3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D3_AddRef(p) (p)->AddRef()
#define IDirect3D3_Release(p) (p)->Release()
#define IDirect3D3_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D3_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D3_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D3_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D3_FindDevice(p,a,b) (p)->FindDevice(a,b)
#define IDirect3D3_CreateDevice(p,a,b,c,d) (p)->CreateDevice(a,b,c,d)
#define IDirect3D3_CreateVertexBuffer(p,a,b,c,d) (p)->CreateVertexBuffer(a,b,c,d)
#define IDirect3D3_EnumZBufferFormats(p,a,b,c) (p)->EnumZBufferFormats(a,b,c)
#define IDirect3D3_EvictManagedTextures(p) (p)->EvictManagedTextures()
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3D7

DECLARE_INTERFACE_(IDirect3D7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D7 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK7,LPVOID) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE7,LPDIRECT3DDEVICE7*) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ LPD3DVERTEXBUFFERDESC,LPDIRECT3DVERTEXBUFFER7*,DWORD) PURE;
    STDMETHOD(EnumZBufferFormats)(THIS_ REFCLSID,LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(EvictManagedTextures)(THIS) PURE;
};

typedef struct IDirect3D7 *LPDIRECT3D7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D7_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D7_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirect3D7_CreateVertexBuffer(p,a,b,c) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c)
#define IDirect3D7_EnumZBufferFormats(p,a,b,c) (p)->lpVtbl->EnumZBufferFormats(p,a,b,c)
#define IDirect3D7_EvictManagedTextures(p) (p)->lpVtbl->EvictManagedTextures(p)
#else
#define IDirect3D7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D7_AddRef(p) (p)->AddRef()
#define IDirect3D7_Release(p) (p)->Release()
#define IDirect3D7_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D7_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirect3D7_CreateVertexBuffer(p,a,b,c) (p)->CreateVertexBuffer(a,b,c)
#define IDirect3D7_EnumZBufferFormats(p,a,b,c) (p)->EnumZBufferFormats(a,b,c)
#define IDirect3D7_EvictManagedTextures(p) (p)->EvictManagedTextures()
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */
/*
 * Direct3D Device interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DDevice

DECLARE_INTERFACE_(IDirect3DDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D,LPGUID,LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles)(THIS_ LPDIRECT3DTEXTURE,LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(CreateExecuteBuffer)(THIS_ LPD3DEXECUTEBUFFERDESC,LPDIRECT3DEXECUTEBUFFER*,IUnknown*) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(Execute)(THIS_ LPDIRECT3DEXECUTEBUFFER,LPDIRECT3DVIEWPORT,DWORD) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT,LPDIRECT3DVIEWPORT*,DWORD) PURE;
    STDMETHOD(Pick)(THIS_ LPDIRECT3DEXECUTEBUFFER,LPDIRECT3DVIEWPORT,DWORD,LPD3DRECT) PURE;
    STDMETHOD(GetPickRecords)(THIS_ LPDWORD,LPD3DPICKRECORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateMatrix)(THIS_ LPD3DMATRIXHANDLE) PURE;
    STDMETHOD(SetMatrix)(THIS_ D3DMATRIXHANDLE,const LPD3DMATRIX) PURE;
    STDMETHOD(GetMatrix)(THIS_ D3DMATRIXHANDLE,LPD3DMATRIX) PURE;
    STDMETHOD(DeleteMatrix)(THIS_ D3DMATRIXHANDLE) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D*) PURE;
};

typedef struct IDirect3DDevice *LPDIRECT3DDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirect3DDevice_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice_SwapTextureHandles(p,a,b) (p)->lpVtbl->SwapTextureHandles(p,a,b)
#define IDirect3DDevice_CreateExecuteBuffer(p,a,b,c) (p)->lpVtbl->CreateExecuteBuffer(p,a,b,c)
#define IDirect3DDevice_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice_Execute(p,a,b,c) (p)->lpVtbl->Execute(p,a,b,c)
#define IDirect3DDevice_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice_Pick(p,a,b,c,d) (p)->lpVtbl->Pick(p,a,b,c,d)
#define IDirect3DDevice_GetPickRecords(p,a,b) (p)->lpVtbl->GetPickRecords(p,a,b)
#define IDirect3DDevice_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice_CreateMatrix(p,a) (p)->lpVtbl->CreateMatrix(p,a)
#define IDirect3DDevice_SetMatrix(p,a,b) (p)->lpVtbl->SetMatrix(p,a,b)
#define IDirect3DDevice_GetMatrix(p,a,b) (p)->lpVtbl->GetMatrix(p,a,b)
#define IDirect3DDevice_DeleteMatrix(p,a) (p)->lpVtbl->DeleteMatrix(p,a)
#define IDirect3DDevice_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#else
#define IDirect3DDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice_AddRef(p) (p)->AddRef()
#define IDirect3DDevice_Release(p) (p)->Release()
#define IDirect3DDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirect3DDevice_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice_SwapTextureHandles(p,a,b) (p)->SwapTextureHandles(a,b)
#define IDirect3DDevice_CreateExecuteBuffer(p,a,b,c) (p)->CreateExecuteBuffer(a,b,c)
#define IDirect3DDevice_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice_Execute(p,a,b,c) (p)->Execute(a,b,c)
#define IDirect3DDevice_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice_Pick(p,a,b,c,d) (p)->Pick(a,b,c,d)
#define IDirect3DDevice_GetPickRecords(p,a,b) (p)->GetPickRecords(a,b)
#define IDirect3DDevice_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice_CreateMatrix(p,a) (p)->CreateMatrix(a)
#define IDirect3DDevice_SetMatrix(p,a,b) (p)->SetMatrix(a,b)
#define IDirect3DDevice_GetMatrix(p,a,b) (p)->GetMatrix(a,b)
#define IDirect3DDevice_DeleteMatrix(p,a) (p)->DeleteMatrix(a)
#define IDirect3DDevice_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice_EndScene(p) (p)->EndScene()
#define IDirect3DDevice_GetDirect3D(p,a) (p)->GetDirect3D(a)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DDevice2

DECLARE_INTERFACE_(IDirect3DDevice2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice2 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles)(THIS_ LPDIRECT3DTEXTURE2,LPDIRECT3DTEXTURE2) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT2,LPDIRECT3DVIEWPORT2*,DWORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D2*) PURE;
    STDMETHOD(SetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(GetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT2 *) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD(Begin)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,DWORD) PURE;
    STDMETHOD(BeginIndexed)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(Vertex)(THIS_ LPVOID) PURE;
    STDMETHOD(Index)(THIS_ WORD) PURE;
    STDMETHOD(End)(THIS_ DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetLightState)(THIS_ D3DLIGHTSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetLightState)(THIS_ D3DLIGHTSTATETYPE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
};

typedef struct IDirect3DDevice2 *LPDIRECT3DDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice2_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice2_SwapTextureHandles(p,a,b) (p)->lpVtbl->SwapTextureHandles(p,a,b)
#define IDirect3DDevice2_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice2_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice2_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice2_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice2_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice2_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice2_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice2_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice2_SetCurrentViewport(p,a) (p)->lpVtbl->SetCurrentViewport(p,a)
#define IDirect3DDevice2_GetCurrentViewport(p,a) (p)->lpVtbl->GetCurrentViewport(p,a)
#define IDirect3DDevice2_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice2_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice2_Begin(p,a,b,c) (p)->lpVtbl->Begin(p,a,b,c)
#define IDirect3DDevice2_BeginIndexed(p,a,b,c,d,e) (p)->lpVtbl->BeginIndexed(p,a,b,c,d,e)
#define IDirect3DDevice2_Vertex(p,a) (p)->lpVtbl->Vertex(p,a)
#define IDirect3DDevice2_Index(p,a) (p)->lpVtbl->Index(p,a)
#define IDirect3DDevice2_End(p,a) (p)->lpVtbl->End(p,a)
#define IDirect3DDevice2_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice2_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice2_GetLightState(p,a,b) (p)->lpVtbl->GetLightState(p,a,b)
#define IDirect3DDevice2_SetLightState(p,a,b) (p)->lpVtbl->SetLightState(p,a,b)
#define IDirect3DDevice2_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice2_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice2_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice2_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice2_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice2_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice2_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#else
#define IDirect3DDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice2_AddRef(p) (p)->AddRef()
#define IDirect3DDevice2_Release(p) (p)->Release()
#define IDirect3DDevice2_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice2_SwapTextureHandles(p,a,b) (p)->SwapTextureHandles(a,b)
#define IDirect3DDevice2_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice2_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice2_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice2_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice2_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice2_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice2_EndScene(p) (p)->EndScene()
#define IDirect3DDevice2_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice2_SetCurrentViewport(p,a) (p)->SetCurrentViewport(a)
#define IDirect3DDevice2_GetCurrentViewport(p,a) (p)->GetCurrentViewport(a)
#define IDirect3DDevice2_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice2_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice2_Begin(p,a,b,c) (p)->Begin(a,b,c)
#define IDirect3DDevice2_BeginIndexed(p,a,b,c,d,e) (p)->BeginIndexed(a,b,c,d,e)
#define IDirect3DDevice2_Vertex(p,a) (p)->Vertex(a)
#define IDirect3DDevice2_Index(p,a) (p)->Index(a)
#define IDirect3DDevice2_End(p,a) (p)->End(a)
#define IDirect3DDevice2_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice2_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice2_GetLightState(p,a,b) (p)->GetLightState(a,b)
#define IDirect3DDevice2_SetLightState(p,a,b) (p)->SetLightState(a,b)
#define IDirect3DDevice2_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice2_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice2_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice2_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice2_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice2_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice2_GetClipStatus(p,a) (p)->GetClipStatus(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DDevice3

DECLARE_INTERFACE_(IDirect3DDevice3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice3 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT3,LPDIRECT3DVIEWPORT3*,DWORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D3*) PURE;
    STDMETHOD(SetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(GetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT3 *) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE4,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(Begin)(THIS_ D3DPRIMITIVETYPE,DWORD,DWORD) PURE;
    STDMETHOD(BeginIndexed)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(Vertex)(THIS_ LPVOID) PURE;
    STDMETHOD(Index)(THIS_ WORD) PURE;
    STDMETHOD(End)(THIS_ DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetLightState)(THIS_ D3DLIGHTSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetLightState)(THIS_ D3DLIGHTSTATETYPE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(DrawPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(ComputeSphereVisibility)(THIS_ LPD3DVECTOR,LPD3DVALUE,DWORD,DWORD,LPDWORD) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD,LPDIRECT3DTEXTURE2 *) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD,LPDIRECT3DTEXTURE2) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,DWORD) PURE;
    STDMETHOD(ValidateDevice)(THIS_ LPDWORD) PURE;
};

typedef struct IDirect3DDevice3 *LPDIRECT3DDEVICE3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice3_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice3_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice3_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice3_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice3_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice3_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice3_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice3_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice3_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice3_SetCurrentViewport(p,a) (p)->lpVtbl->SetCurrentViewport(p,a)
#define IDirect3DDevice3_GetCurrentViewport(p,a) (p)->lpVtbl->GetCurrentViewport(p,a)
#define IDirect3DDevice3_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice3_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice3_Begin(p,a,b,c) (p)->lpVtbl->Begin(p,a,b,c)
#define IDirect3DDevice3_BeginIndexed(p,a,b,c,d,e) (p)->lpVtbl->BeginIndexed(p,a,b,c,d,e)
#define IDirect3DDevice3_Vertex(p,a) (p)->lpVtbl->Vertex(p,a)
#define IDirect3DDevice3_Index(p,a) (p)->lpVtbl->Index(p,a)
#define IDirect3DDevice3_End(p,a) (p)->lpVtbl->End(p,a)
#define IDirect3DDevice3_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice3_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice3_GetLightState(p,a,b) (p)->lpVtbl->GetLightState(p,a,b)
#define IDirect3DDevice3_SetLightState(p,a,b) (p)->lpVtbl->SetLightState(p,a,b)
#define IDirect3DDevice3_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice3_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice3_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice3_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice3_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice3_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice3_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveStrided(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g)
#define IDirect3DDevice3_DrawPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawIndexedPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice3_ComputeSphereVisibility(p,a,b,c,d,e) (p)->lpVtbl->ComputeSphereVisibility(p,a,b,c,d,e)
#define IDirect3DDevice3_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice3_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice3_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice3_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice3_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#else
#define IDirect3DDevice3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice3_AddRef(p) (p)->AddRef()
#define IDirect3DDevice3_Release(p) (p)->Release()
#define IDirect3DDevice3_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice3_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice3_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice3_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice3_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice3_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice3_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice3_EndScene(p) (p)->EndScene()
#define IDirect3DDevice3_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice3_SetCurrentViewport(p,a) (p)->SetCurrentViewport(a)
#define IDirect3DDevice3_GetCurrentViewport(p,a) (p)->GetCurrentViewport(a)
#define IDirect3DDevice3_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice3_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice3_Begin(p,a,b,c) (p)->Begin(a,b,c)
#define IDirect3DDevice3_BeginIndexed(p,a,b,c,d,e) (p)->BeginIndexed(a,b,c,d,e)
#define IDirect3DDevice3_Vertex(p,a) (p)->Vertex(a)
#define IDirect3DDevice3_Index(p,a) (p)->Index(a)
#define IDirect3DDevice3_End(p,a) (p)->End(a)
#define IDirect3DDevice3_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice3_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice3_GetLightState(p,a,b) (p)->GetLightState(a,b)
#define IDirect3DDevice3_SetLightState(p,a,b) (p)->SetLightState(a,b)
#define IDirect3DDevice3_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice3_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice3_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice3_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice3_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice3_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice3_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->DrawPrimitiveStrided(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveStrided(a,b,c,d,e,f,g)
#define IDirect3DDevice3_DrawPrimitiveVB(p,a,b,c,d,e) (p)->DrawPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveVB(p,a,b,c,d,e) (p)->DrawIndexedPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice3_ComputeSphereVisibility(p,a,b,c,d,e) (p)->ComputeSphereVisibility(a,b,c,d,e)
#define IDirect3DDevice3_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice3_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice3_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice3_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice3_ValidateDevice(p,a) (p)->ValidateDevice(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3DDevice7

DECLARE_INTERFACE_(IDirect3DDevice7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice7 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC7) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D7*) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE7,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD,D3DCOLOR,D3DVALUE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT7) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT7) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL7) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL7) PURE;
    STDMETHOD(SetLight)(THIS_ DWORD,LPD3DLIGHT7) PURE;
    STDMETHOD(GetLight)(THIS_ DWORD,LPD3DLIGHT7) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(BeginStateBlock)(THIS) PURE;
    STDMETHOD(EndStateBlock)(THIS_ LPDWORD) PURE;
    STDMETHOD(PreLoad)(THIS_ LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(DrawPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER7,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER7,DWORD,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(ComputeSphereVisibility)(THIS_ LPD3DVECTOR,LPD3DVALUE,DWORD,DWORD,LPDWORD) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD,LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD,LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,DWORD) PURE;
    STDMETHOD(ValidateDevice)(THIS_ LPDWORD) PURE;
    STDMETHOD(ApplyStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(CaptureStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(DeleteStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE,LPDWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECTDRAWSURFACE7,LPPOINT,LPDIRECTDRAWSURFACE7,LPRECT,DWORD) PURE;
    STDMETHOD(LightEnable)(THIS_ DWORD,BOOL) PURE;
    STDMETHOD(GetLightEnable)(THIS_ DWORD,BOOL*) PURE;
    STDMETHOD(SetClipPlane)(THIS_ DWORD,D3DVALUE*) PURE;
    STDMETHOD(GetClipPlane)(THIS_ DWORD,D3DVALUE*) PURE;
    STDMETHOD(GetInfo)(THIS_ DWORD,LPVOID,DWORD) PURE;
};

typedef struct IDirect3DDevice7 *LPDIRECT3DDEVICE7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice7_GetCaps(p,a) (p)->lpVtbl->GetCaps(p,a)
#define IDirect3DDevice7_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice7_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice7_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice7_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice7_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice7_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice7_Clear(p,a,b,c,d,e,f) (p)->lpVtbl->Clear(p,a,b,c,d,e,f)
#define IDirect3DDevice7_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice7_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice7_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DDevice7_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice7_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DDevice7_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DDevice7_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DDevice7_SetLight(p,a,b) (p)->lpVtbl->SetLight(p,a,b)
#define IDirect3DDevice7_GetLight(p,a,b) (p)->lpVtbl->GetLight(p,a,b)
#define IDirect3DDevice7_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice7_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice7_BeginStateBlock(p) (p)->lpVtbl->BeginStateBlock(p)
#define IDirect3DDevice7_EndStateBlock(p,a) (p)->lpVtbl->EndStateBlock(p,a)
#define IDirect3DDevice7_PreLoad(p,a) (p)->lpVtbl->PreLoad(p,a)
#define IDirect3DDevice7_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice7_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice7_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveStrided(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_DrawPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_ComputeSphereVisibility(p,a,b,c,d,e) (p)->lpVtbl->ComputeSphereVisibility(p,a,b,c,d,e)
#define IDirect3DDevice7_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice7_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice7_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice7_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice7_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#define IDirect3DDevice7_ApplyStateBlock(p,a) (p)->lpVtbl->ApplyStateBlock(p,a)
#define IDirect3DDevice7_CaptureStateBlock(p,a) (p)->lpVtbl->CaptureStateBlock(p,a)
#define IDirect3DDevice7_DeleteStateBlock(p,a) (p)->lpVtbl->DeleteStateBlock(p,a)
#define IDirect3DDevice7_CreateStateBlock(p,a,b) (p)->lpVtbl->CreateStateBlock(p,a,b)
#define IDirect3DDevice7_Load(p,a,b,c,d,e) (p)->lpVtbl->Load(p,a,b,c,d,e)
#define IDirect3DDevice7_LightEnable(p,a,b) (p)->lpVtbl->LightEnable(p,a,b)
#define IDirect3DDevice7_GetLightEnable(p,a,b) (p)->lpVtbl->GetLightEnable(p,a,b)
#define IDirect3DDevice7_SetClipPlane(p,a,b) (p)->lpVtbl->SetClipPlane(p,a,b)
#define IDirect3DDevice7_GetClipPlane(p,a,b) (p)->lpVtbl->GetClipPlane(p,a,b)
#define IDirect3DDevice7_GetInfo(p,a,b,c) (p)->lpVtbl->GetInfo(p,a,b,c)
#else
#define IDirect3DDevice7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice7_AddRef(p) (p)->AddRef()
#define IDirect3DDevice7_Release(p) (p)->Release()
#define IDirect3DDevice7_GetCaps(p,a) (p)->GetCaps(a)
#define IDirect3DDevice7_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice7_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice7_EndScene(p) (p)->EndScene()
#define IDirect3DDevice7_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice7_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice7_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice7_Clear(p,a,b,c,d,e,f) (p)->Clear(a,b,c,d,e,f)
#define IDirect3DDevice7_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice7_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice7_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DDevice7_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice7_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DDevice7_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DDevice7_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DDevice7_SetLight(p,a,b) (p)->SetLight(a,b)
#define IDirect3DDevice7_GetLight(p,a,b) (p)->GetLight(a,b)
#define IDirect3DDevice7_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice7_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice7_BeginStateBlock(p) (p)->BeginStateBlock()
#define IDirect3DDevice7_EndStateBlock(p,a) (p)->EndStateBlock(a)
#define IDirect3DDevice7_PreLoad(p,a) (p)->PreLoad(a)
#define IDirect3DDevice7_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice7_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice7_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice7_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->DrawPrimitiveStrided(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveStrided(a,b,c,d,e,f,g)
#define IDirect3DDevice7_DrawPrimitiveVB(p,a,b,c,d,e) (p)->DrawPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveVB(a,b,c,d,e,f,g)
#define IDirect3DDevice7_ComputeSphereVisibility(p,a,b,c,d,e) (p)->ComputeSphereVisibility(a,b,c,d,e)
#define IDirect3DDevice7_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice7_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice7_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice7_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice7_ValidateDevice(p,a) (p)->ValidateDevice(a)
#define IDirect3DDevice7_ApplyStateBlock(p,a) (p)->ApplyStateBlock(a)
#define IDirect3DDevice7_CaptureStateBlock(p,a) (p)->CaptureStateBlock(a)
#define IDirect3DDevice7_DeleteStateBlock(p,a) (p)->DeleteStateBlock(a)
#define IDirect3DDevice7_CreateStateBlock(p,a,b) (p)->CreateStateBlock(a,b)
#define IDirect3DDevice7_Load(p,a,b,c,d,e) (p)->Load(a,b,c,d,e)
#define IDirect3DDevice7_LightEnable(p,a,b) (p)->LightEnable(a,b)
#define IDirect3DDevice7_GetLightEnable(p,a,b) (p)->GetLightEnable(a,b)
#define IDirect3DDevice7_SetClipPlane(p,a,b) (p)->SetClipPlane(a,b)
#define IDirect3DDevice7_GetClipPlane(p,a,b) (p)->GetClipPlane(a,b)
#define IDirect3DDevice7_GetInfo(p,a,b,c) (p)->GetInfo(a,b,c)
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Execute Buffer interface
 */
#undef INTERFACE
#define INTERFACE IDirect3DExecuteBuffer

DECLARE_INTERFACE_(IDirect3DExecuteBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DExecuteBuffer methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DDEVICE,LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Lock)(THIS_ LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(SetExecuteData)(THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(GetExecuteData)(THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(Validate)(THIS_ LPDWORD,LPD3DVALIDATECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD) PURE;
};

typedef struct IDirect3DExecuteBuffer *LPDIRECT3DEXECUTEBUFFER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DExecuteBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DExecuteBuffer_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DExecuteBuffer_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DExecuteBuffer_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirect3DExecuteBuffer_Lock(p,a) (p)->lpVtbl->Lock(p,a)
#define IDirect3DExecuteBuffer_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DExecuteBuffer_SetExecuteData(p,a) (p)->lpVtbl->SetExecuteData(p,a)
#define IDirect3DExecuteBuffer_GetExecuteData(p,a) (p)->lpVtbl->GetExecuteData(p,a)
#define IDirect3DExecuteBuffer_Validate(p,a,b,c,d) (p)->lpVtbl->Validate(p,a,b,c,d)
#define IDirect3DExecuteBuffer_Optimize(p,a) (p)->lpVtbl->Optimize(p,a)
#else
#define IDirect3DExecuteBuffer_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DExecuteBuffer_AddRef(p) (p)->AddRef()
#define IDirect3DExecuteBuffer_Release(p) (p)->Release()
#define IDirect3DExecuteBuffer_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirect3DExecuteBuffer_Lock(p,a) (p)->Lock(a)
#define IDirect3DExecuteBuffer_Unlock(p) (p)->Unlock()
#define IDirect3DExecuteBuffer_SetExecuteData(p,a) (p)->SetExecuteData(a)
#define IDirect3DExecuteBuffer_GetExecuteData(p,a) (p)->GetExecuteData(a)
#define IDirect3DExecuteBuffer_Validate(p,a,b,c,d) (p)->Validate(a,b,c,d)
#define IDirect3DExecuteBuffer_Optimize(p,a) (p)->Optimize(a)
#endif

/*
 * Light interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DLight

DECLARE_INTERFACE_(IDirect3DLight, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DLight methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetLight)(THIS_ LPD3DLIGHT) PURE;
    STDMETHOD(GetLight)(THIS_ LPD3DLIGHT) PURE;
};

typedef struct IDirect3DLight *LPDIRECT3DLIGHT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DLight_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DLight_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DLight_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DLight_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DLight_SetLight(p,a) (p)->lpVtbl->SetLight(p,a)
#define IDirect3DLight_GetLight(p,a) (p)->lpVtbl->GetLight(p,a)
#else
#define IDirect3DLight_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DLight_AddRef(p) (p)->AddRef()
#define IDirect3DLight_Release(p) (p)->Release()
#define IDirect3DLight_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DLight_SetLight(p,a) (p)->SetLight(a)
#define IDirect3DLight_GetLight(p,a) (p)->GetLight(a)
#endif

/*
 * Material interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DMaterial

DECLARE_INTERFACE_(IDirect3DMaterial, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE,LPD3DMATERIALHANDLE) PURE;
    STDMETHOD(Reserve)(THIS) PURE;
    STDMETHOD(Unreserve)(THIS) PURE;
};

typedef struct IDirect3DMaterial *LPDIRECT3DMATERIAL;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DMaterial_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DMaterial_Reserve(p) (p)->lpVtbl->Reserve(p)
#define IDirect3DMaterial_Unreserve(p) (p)->lpVtbl->Unreserve(p)
#else
#define IDirect3DMaterial_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial_Release(p) (p)->Release()
#define IDirect3DMaterial_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DMaterial_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DMaterial_Reserve(p) (p)->Reserve()
#define IDirect3DMaterial_Unreserve(p) (p)->Unreserve()
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DMaterial2

DECLARE_INTERFACE_(IDirect3DMaterial2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial2 methods ***/
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE2,LPD3DMATERIALHANDLE) PURE;
};

typedef struct IDirect3DMaterial2 *LPDIRECT3DMATERIAL2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial2_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial2_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial2_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#else
#define IDirect3DMaterial2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial2_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial2_Release(p) (p)->Release()
#define IDirect3DMaterial2_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial2_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial2_GetHandle(p,a,b) (p)->GetHandle(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DMaterial3

DECLARE_INTERFACE_(IDirect3DMaterial3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial3 methods ***/
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE3,LPD3DMATERIALHANDLE) PURE;
};

typedef struct IDirect3DMaterial3 *LPDIRECT3DMATERIAL3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial3_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial3_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial3_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#else
#define IDirect3DMaterial3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial3_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial3_Release(p) (p)->Release()
#define IDirect3DMaterial3_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial3_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial3_GetHandle(p,a,b) (p)->GetHandle(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Texture interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DTexture

DECLARE_INTERFACE_(IDirect3DTexture, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DTexture methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DDEVICE,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE,LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(Unload)(THIS) PURE;
};

typedef struct IDirect3DTexture *LPDIRECT3DTEXTURE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirect3DTexture_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DTexture_PaletteChanged(p,a,b) (p)->lpVtbl->PaletteChanged(p,a,b)
#define IDirect3DTexture_Load(p,a) (p)->lpVtbl->Load(p,a)
#define IDirect3DTexture_Unload(p) (p)->lpVtbl->Unload(p)
#else
#define IDirect3DTexture_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture_AddRef(p) (p)->AddRef()
#define IDirect3DTexture_Release(p) (p)->Release()
#define IDirect3DTexture_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirect3DTexture_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DTexture_PaletteChanged(p,a,b) (p)->PaletteChanged(a,b)
#define IDirect3DTexture_Load(p,a) (p)->Load(a)
#define IDirect3DTexture_Unload(p) (p)->Unload()
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DTexture2

DECLARE_INTERFACE_(IDirect3DTexture2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DTexture2 methods ***/
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE2,LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECT3DTEXTURE2) PURE;
};

typedef struct IDirect3DTexture2 *LPDIRECT3DTEXTURE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture2_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DTexture2_PaletteChanged(p,a,b) (p)->lpVtbl->PaletteChanged(p,a,b)
#define IDirect3DTexture2_Load(p,a) (p)->lpVtbl->Load(p,a)
#else
#define IDirect3DTexture2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture2_AddRef(p) (p)->AddRef()
#define IDirect3DTexture2_Release(p) (p)->Release()
#define IDirect3DTexture2_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DTexture2_PaletteChanged(p,a,b) (p)->PaletteChanged(a,b)
#define IDirect3DTexture2_Load(p,a) (p)->Load(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

/*
 * Viewport interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DViewport

DECLARE_INTERFACE_(IDirect3DViewport, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
};

typedef struct IDirect3DViewport *LPDIRECT3DVIEWPORT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#else
#define IDirect3DViewport_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport_AddRef(p) (p)->AddRef()
#define IDirect3DViewport_Release(p) (p)->Release()
#define IDirect3DViewport_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DViewport2

DECLARE_INTERFACE_(IDirect3DViewport2, IDirect3DViewport)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
    STDMETHOD(GetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
};

typedef struct IDirect3DViewport2 *LPDIRECT3DVIEWPORT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport2_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport2_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport2_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport2_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport2_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport2_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport2_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport2_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport2_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport2_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport2_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport2_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport2_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#define IDirect3DViewport2_GetViewport2(p,a) (p)->lpVtbl->GetViewport2(p,a)
#define IDirect3DViewport2_SetViewport2(p,a) (p)->lpVtbl->SetViewport2(p,a)
#else
#define IDirect3DViewport2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport2_AddRef(p) (p)->AddRef()
#define IDirect3DViewport2_Release(p) (p)->Release()
#define IDirect3DViewport2_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport2_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport2_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport2_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport2_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport2_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport2_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport2_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport2_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport2_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport2_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport2_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport2_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#define IDirect3DViewport2_GetViewport2(p,a) (p)->GetViewport2(a)
#define IDirect3DViewport2_SetViewport2(p,a) (p)->SetViewport2(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

#undef INTERFACE
#define INTERFACE IDirect3DViewport3

DECLARE_INTERFACE_(IDirect3DViewport3, IDirect3DViewport2)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport2 methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
    STDMETHOD(GetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetBackgroundDepth2)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(GetBackgroundDepth2)(THIS_ LPDIRECTDRAWSURFACE4*,LPBOOL) PURE;
    STDMETHOD(Clear2)(THIS_ DWORD,LPD3DRECT,DWORD,D3DCOLOR,D3DVALUE,DWORD) PURE;
};

typedef struct IDirect3DViewport3 *LPDIRECT3DVIEWPORT3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport3_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport3_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport3_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport3_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport3_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport3_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport3_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport3_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport3_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport3_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport3_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport3_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport3_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#define IDirect3DViewport3_GetViewport2(p,a) (p)->lpVtbl->GetViewport2(p,a)
#define IDirect3DViewport3_SetViewport2(p,a) (p)->lpVtbl->SetViewport2(p,a)
#define IDirect3DViewport3_SetBackgroundDepth2(p,a) (p)->lpVtbl->SetBackgroundDepth2(p,a)
#define IDirect3DViewport3_GetBackgroundDepth2(p,a,b) (p)->lpVtbl->GetBackgroundDepth2(p,a,b)
#define IDirect3DViewport3_Clear2(p,a,b,c,d,e,f) (p)->lpVtbl->Clear2(p,a,b,c,d,e,f)
#else
#define IDirect3DViewport3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport3_AddRef(p) (p)->AddRef()
#define IDirect3DViewport3_Release(p) (p)->Release()
#define IDirect3DViewport3_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport3_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport3_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport3_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport3_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport3_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport3_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport3_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport3_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport3_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport3_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport3_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport3_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#define IDirect3DViewport3_GetViewport2(p,a) (p)->GetViewport2(a)
#define IDirect3DViewport3_SetViewport2(p,a) (p)->SetViewport2(a)
#define IDirect3DViewport3_SetBackgroundDepth2(p,a) (p)->SetBackgroundDepth2(a)
#define IDirect3DViewport3_GetBackgroundDepth2(p,a,b) (p)->GetBackgroundDepth2(a,b)
#define IDirect3DViewport3_Clear2(p,a,b,c,d,e,f) (p)->Clear2(a,b,c,d,e,f)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer

DECLARE_INTERFACE_(IDirect3DVertexBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexBuffer methods ***/
    STDMETHOD(Lock)(THIS_ DWORD,LPVOID*,LPDWORD) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(ProcessVertices)(THIS_ DWORD,DWORD,DWORD,LPDIRECT3DVERTEXBUFFER,DWORD,LPDIRECT3DDEVICE3,DWORD) PURE;
    STDMETHOD(GetVertexBufferDesc)(THIS_ LPD3DVERTEXBUFFERDESC) PURE;
    STDMETHOD(Optimize)(THIS_ LPDIRECT3DDEVICE3,DWORD) PURE;
};

typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer_Lock(p,a,b,c) (p)->lpVtbl->Lock(p,a,b,c)
#define IDirect3DVertexBuffer_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer_ProcessVertices(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer_GetVertexBufferDesc(p,a) (p)->lpVtbl->GetVertexBufferDesc(p,a)
#define IDirect3DVertexBuffer_Optimize(p,a,b) (p)->lpVtbl->Optimize(p,a,b)
#else
#define IDirect3DVertexBuffer_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer_Release(p) (p)->Release()
#define IDirect3DVertexBuffer_Lock(p,a,b,c) (p)->Lock(a,b,c)
#define IDirect3DVertexBuffer_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer_ProcessVertices(p,a,b,c,d,e,f,g) (p)->ProcessVertices(a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer_GetVertexBufferDesc(p,a) (p)->GetVertexBufferDesc(a)
#define IDirect3DVertexBuffer_Optimize(p,a,b) (p)->Optimize(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer7

DECLARE_INTERFACE_(IDirect3DVertexBuffer7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexBuffer7 methods ***/
    STDMETHOD(Lock)(THIS_ DWORD,LPVOID*,LPDWORD) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(ProcessVertices)(THIS_ DWORD,DWORD,DWORD,LPDIRECT3DVERTEXBUFFER7,DWORD,LPDIRECT3DDEVICE7,DWORD) PURE;
    STDMETHOD(GetVertexBufferDesc)(THIS_ LPD3DVERTEXBUFFERDESC) PURE;
    STDMETHOD(Optimize)(THIS_ LPDIRECT3DDEVICE7,DWORD) PURE;
    STDMETHOD(ProcessVerticesStrided)(THIS_ DWORD,DWORD,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPDIRECT3DDEVICE7,DWORD) PURE;
};

typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer7_Lock(p,a,b,c) (p)->lpVtbl->Lock(p,a,b,c)
#define IDirect3DVertexBuffer7_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer7_ProcessVertices(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer7_GetVertexBufferDesc(p,a) (p)->lpVtbl->GetVertexBufferDesc(p,a)
#define IDirect3DVertexBuffer7_Optimize(p,a,b) (p)->lpVtbl->Optimize(p,a,b)
#define IDirect3DVertexBuffer7_ProcessVerticesStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVerticesStrided(p,a,b,c,d,e,f,g)
#else
#define IDirect3DVertexBuffer7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer7_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer7_Release(p) (p)->Release()
#define IDirect3DVertexBuffer7_Lock(p,a,b,c) (p)->Lock(a,b,c)
#define IDirect3DVertexBuffer7_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer7_ProcessVertices(p,a,b,c,d,e,f,g) (p)->ProcessVertices(a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer7_GetVertexBufferDesc(p,a) (p)->GetVertexBufferDesc(a)
#define IDirect3DVertexBuffer7_Optimize(p,a,b) (p)->Optimize(a,b)
#define IDirect3DVertexBuffer7_ProcessVerticesStrided(p,a,b,c,d,e,f,g) (p)->ProcessVerticesStrided(a,b,c,d,e,f,g)
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0500)
/****************************************************************************
 *
 * Flags for IDirect3DDevice::NextViewport
 *
 ****************************************************************************/

/*
 * Return the next viewport
 */
#define D3DNEXT_NEXT    0x00000001l

/*
 * Return the first viewport
 */
#define D3DNEXT_HEAD    0x00000002l

/*
 * Return the last viewport
 */
#define D3DNEXT_TAIL    0x00000004l


/****************************************************************************
 *
 * Flags for DrawPrimitive/DrawIndexedPrimitive
 *   Also valid for Begin/BeginIndexed
 *   Also valid for VertexBuffer::CreateVertexBuffer
 ****************************************************************************/

/*
 * Wait until the device is ready to draw the primitive
 * This will cause DP to not return DDERR_WASSTILLDRAWING
 */
#define D3DDP_WAIT                  0x00000001l
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if (DIRECT3D_VERSION == 0x0500)
/*
 * Hint that it is acceptable to render the primitive out of order.
 */
#define D3DDP_OUTOFORDER            0x00000002l
#endif


#if(DIRECT3D_VERSION >= 0x0500)
/*
 * Hint that the primitives have been clipped by the application.
 */
#define D3DDP_DONOTCLIP             0x00000004l

/*
 * Hint that the extents need not be updated.
 */
#define D3DDP_DONOTUPDATEEXTENTS    0x00000008l
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

/*
 * Hint that the lighting should not be applied on vertices.
 */

#define D3DDP_DONOTLIGHT            0x00000010l

#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Direct3D Errors
 * DirectDraw error codes are used when errors not specified here.
 */
#define D3D_OK              DD_OK
#define D3DERR_BADMAJORVERSION      MAKE_DDHRESULT(700)
#define D3DERR_BADMINORVERSION      MAKE_DDHRESULT(701)

#if(DIRECT3D_VERSION >= 0x0500)
/*
 * An invalid device was requested by the application.
 */
#define D3DERR_INVALID_DEVICE   MAKE_DDHRESULT(705)
#define D3DERR_INITFAILED       MAKE_DDHRESULT(706)

/*
 * SetRenderTarget attempted on a device that was
 * QI'd off the render target.
 */
#define D3DERR_DEVICEAGGREGATED MAKE_DDHRESULT(707)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_EXECUTE_CREATE_FAILED    MAKE_DDHRESULT(710)
#define D3DERR_EXECUTE_DESTROY_FAILED   MAKE_DDHRESULT(711)
#define D3DERR_EXECUTE_LOCK_FAILED  MAKE_DDHRESULT(712)
#define D3DERR_EXECUTE_UNLOCK_FAILED    MAKE_DDHRESULT(713)
#define D3DERR_EXECUTE_LOCKED       MAKE_DDHRESULT(714)
#define D3DERR_EXECUTE_NOT_LOCKED   MAKE_DDHRESULT(715)

#define D3DERR_EXECUTE_FAILED       MAKE_DDHRESULT(716)
#define D3DERR_EXECUTE_CLIPPED_FAILED   MAKE_DDHRESULT(717)

#define D3DERR_TEXTURE_NO_SUPPORT   MAKE_DDHRESULT(720)
#define D3DERR_TEXTURE_CREATE_FAILED    MAKE_DDHRESULT(721)
#define D3DERR_TEXTURE_DESTROY_FAILED   MAKE_DDHRESULT(722)
#define D3DERR_TEXTURE_LOCK_FAILED  MAKE_DDHRESULT(723)
#define D3DERR_TEXTURE_UNLOCK_FAILED    MAKE_DDHRESULT(724)
#define D3DERR_TEXTURE_LOAD_FAILED  MAKE_DDHRESULT(725)
#define D3DERR_TEXTURE_SWAP_FAILED  MAKE_DDHRESULT(726)
#define D3DERR_TEXTURE_LOCKED       MAKE_DDHRESULT(727)
#define D3DERR_TEXTURE_NOT_LOCKED   MAKE_DDHRESULT(728)
#define D3DERR_TEXTURE_GETSURF_FAILED   MAKE_DDHRESULT(729)

#define D3DERR_MATRIX_CREATE_FAILED MAKE_DDHRESULT(730)
#define D3DERR_MATRIX_DESTROY_FAILED    MAKE_DDHRESULT(731)
#define D3DERR_MATRIX_SETDATA_FAILED    MAKE_DDHRESULT(732)
#define D3DERR_MATRIX_GETDATA_FAILED    MAKE_DDHRESULT(733)
#define D3DERR_SETVIEWPORTDATA_FAILED   MAKE_DDHRESULT(734)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INVALIDCURRENTVIEWPORT   MAKE_DDHRESULT(735)
#define D3DERR_INVALIDPRIMITIVETYPE     MAKE_DDHRESULT(736)
#define D3DERR_INVALIDVERTEXTYPE        MAKE_DDHRESULT(737)
#define D3DERR_TEXTURE_BADSIZE          MAKE_DDHRESULT(738)
#define D3DERR_INVALIDRAMPTEXTURE       MAKE_DDHRESULT(739)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_MATERIAL_CREATE_FAILED   MAKE_DDHRESULT(740)
#define D3DERR_MATERIAL_DESTROY_FAILED  MAKE_DDHRESULT(741)
#define D3DERR_MATERIAL_SETDATA_FAILED  MAKE_DDHRESULT(742)
#define D3DERR_MATERIAL_GETDATA_FAILED  MAKE_DDHRESULT(743)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INVALIDPALETTE           MAKE_DDHRESULT(744)

#define D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY MAKE_DDHRESULT(745)
#define D3DERR_ZBUFF_NEEDS_VIDEOMEMORY  MAKE_DDHRESULT(746)
#define D3DERR_SURFACENOTINVIDMEM       MAKE_DDHRESULT(747)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_LIGHT_SET_FAILED     MAKE_DDHRESULT(750)
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_LIGHTHASVIEWPORT     MAKE_DDHRESULT(751)
#define D3DERR_LIGHTNOTINTHISVIEWPORT           MAKE_DDHRESULT(752)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_SCENE_IN_SCENE       MAKE_DDHRESULT(760)
#define D3DERR_SCENE_NOT_IN_SCENE   MAKE_DDHRESULT(761)
#define D3DERR_SCENE_BEGIN_FAILED   MAKE_DDHRESULT(762)
#define D3DERR_SCENE_END_FAILED     MAKE_DDHRESULT(763)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INBEGIN                  MAKE_DDHRESULT(770)
#define D3DERR_NOTINBEGIN               MAKE_DDHRESULT(771)
#define D3DERR_NOVIEWPORTS              MAKE_DDHRESULT(772)
#define D3DERR_VIEWPORTDATANOTSET       MAKE_DDHRESULT(773)
#define D3DERR_VIEWPORTHASNODEVICE      MAKE_DDHRESULT(774)
#define D3DERR_NOCURRENTVIEWPORT        MAKE_DDHRESULT(775)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#define D3DERR_INVALIDVERTEXFORMAT              MAKE_DDHRESULT(2048)

/*
 * Attempted to CreateTexture on a surface that had a color key
 */
#define D3DERR_COLORKEYATTACHED                 MAKE_DDHRESULT(2050)

#define D3DERR_VERTEXBUFFEROPTIMIZED            MAKE_DDHRESULT(2060)
#define D3DERR_VBUF_CREATE_FAILED               MAKE_DDHRESULT(2061)
#define D3DERR_VERTEXBUFFERLOCKED               MAKE_DDHRESULT(2062)
#define D3DERR_VERTEXBUFFERUNLOCKFAILED         MAKE_DDHRESULT(2063)

#define D3DERR_ZBUFFER_NOTPRESENT               MAKE_DDHRESULT(2070)
#define D3DERR_STENCILBUFFER_NOTPRESENT         MAKE_DDHRESULT(2071)

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_DDHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_DDHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_DDHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_DDHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_DDHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_DDHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_DDHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_DDHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_DDHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_DDHRESULT(2082)
#define D3DERR_TOOMANYPRIMITIVES                MAKE_DDHRESULT(2083)
#define D3DERR_INVALIDMATRIX                    MAKE_DDHRESULT(2084)
#define D3DERR_TOOMANYVERTICES                  MAKE_DDHRESULT(2085)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_DDHRESULT(2086)

#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#define D3DERR_INVALIDSTATEBLOCK        MAKE_DDHRESULT(2100)
#define D3DERR_INBEGINSTATEBLOCK        MAKE_DDHRESULT(2101)
#define D3DERR_NOTINBEGINSTATEBLOCK     MAKE_DDHRESULT(2102)
#endif /* DIRECT3D_VERSION >= 0x0700 */


#ifdef __cplusplus
};
#endif

#endif /* (DIRECT3D_VERSION < 0x0800) */
#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3d8.h ===
/*==========================================================================;
 *
 *
 *  File:   d3d8.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D8_H_
#define _D3D8_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)


/* This identifier is passed to Direct3DCreate8 in order to ensure that an
 * application was built against the correct header files. This number is
 * incremented whenever a header (or other) change would require applications
 * to be rebuilt. If the version doesn't match, Direct3DCreate8 will fail.
 * (The number itself has no meaning.)*/

#define D3D_SDK_VERSION 120


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <windows.h>

#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
    #define HMONITOR_DECLARED
    DECLARE_HANDLE(HMONITOR);
#endif

#define D3DAPI WINAPI

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

/* IID_IDirect3D8 */
/* {1DD9E8DA-1C77-4d40-B0CF-98FEFDFF9512} */
DEFINE_GUID(IID_IDirect3D8, 0x1dd9e8da, 0x1c77, 0x4d40, 0xb0, 0xcf, 0x98, 0xfe, 0xfd, 0xff, 0x95, 0x12);

/* IID_IDirect3DDevice8 */
/* {7385E5DF-8FE8-41D5-86B6-D7B48547B6CF} */
DEFINE_GUID(IID_IDirect3DDevice8, 0x7385e5df, 0x8fe8, 0x41d5, 0x86, 0xb6, 0xd7, 0xb4, 0x85, 0x47, 0xb6, 0xcf);

/* IID_IDirect3DResource8 */
/* {1B36BB7B-09B7-410a-B445-7D1430D7B33F} */
DEFINE_GUID(IID_IDirect3DResource8, 0x1b36bb7b, 0x9b7, 0x410a, 0xb4, 0x45, 0x7d, 0x14, 0x30, 0xd7, 0xb3, 0x3f);

/* IID_IDirect3DBaseTexture8 */
/* {B4211CFA-51B9-4a9f-AB78-DB99B2BB678E} */
DEFINE_GUID(IID_IDirect3DBaseTexture8, 0xb4211cfa, 0x51b9, 0x4a9f, 0xab, 0x78, 0xdb, 0x99, 0xb2, 0xbb, 0x67, 0x8e);

/* IID_IDirect3DTexture8 */
/* {E4CDD575-2866-4f01-B12E-7EECE1EC9358} */
DEFINE_GUID(IID_IDirect3DTexture8, 0xe4cdd575, 0x2866, 0x4f01, 0xb1, 0x2e, 0x7e, 0xec, 0xe1, 0xec, 0x93, 0x58);

/* IID_IDirect3DCubeTexture8 */
/* {3EE5B968-2ACA-4c34-8BB5-7E0C3D19B750} */
DEFINE_GUID(IID_IDirect3DCubeTexture8, 0x3ee5b968, 0x2aca, 0x4c34, 0x8b, 0xb5, 0x7e, 0x0c, 0x3d, 0x19, 0xb7, 0x50);

/* IID_IDirect3DVolumeTexture8 */
/* {4B8AAAFA-140F-42ba-9131-597EAFAA2EAD} */
DEFINE_GUID(IID_IDirect3DVolumeTexture8, 0x4b8aaafa, 0x140f, 0x42ba, 0x91, 0x31, 0x59, 0x7e, 0xaf, 0xaa, 0x2e, 0xad);

/* IID_IDirect3DVertexBuffer8 */
/* {8AEEEAC7-05F9-44d4-B591-000B0DF1CB95} */
DEFINE_GUID(IID_IDirect3DVertexBuffer8, 0x8aeeeac7, 0x05f9, 0x44d4, 0xb5, 0x91, 0x00, 0x0b, 0x0d, 0xf1, 0xcb, 0x95);

/* IID_IDirect3DIndexBuffer8 */
/* {0E689C9A-053D-44a0-9D92-DB0E3D750F86} */
DEFINE_GUID(IID_IDirect3DIndexBuffer8, 0x0e689c9a, 0x053d, 0x44a0, 0x9d, 0x92, 0xdb, 0x0e, 0x3d, 0x75, 0x0f, 0x86);

/* IID_IDirect3DSurface8 */
/* {B96EEBCA-B326-4ea5-882F-2FF5BAE021DD} */
DEFINE_GUID(IID_IDirect3DSurface8, 0xb96eebca, 0xb326, 0x4ea5, 0x88, 0x2f, 0x2f, 0xf5, 0xba, 0xe0, 0x21, 0xdd);

/* IID_IDirect3DVolume8 */
/* {BD7349F5-14F1-42e4-9C79-972380DB40C0} */
DEFINE_GUID(IID_IDirect3DVolume8, 0xbd7349f5, 0x14f1, 0x42e4, 0x9c, 0x79, 0x97, 0x23, 0x80, 0xdb, 0x40, 0xc0);

/* IID_IDirect3DSwapChain8 */
/* {928C088B-76B9-4C6B-A536-A590853876CD} */
DEFINE_GUID(IID_IDirect3DSwapChain8, 0x928c088b, 0x76b9, 0x4c6b, 0xa5, 0x36, 0xa5, 0x90, 0x85, 0x38, 0x76, 0xcd);

#endif

#ifdef __cplusplus

interface IDirect3D8;
interface IDirect3DDevice8;

interface IDirect3DResource8;
interface IDirect3DBaseTexture8;
interface IDirect3DTexture8;
interface IDirect3DVolumeTexture8;
interface IDirect3DCubeTexture8;

interface IDirect3DVertexBuffer8;
interface IDirect3DIndexBuffer8;

interface IDirect3DSurface8;
interface IDirect3DVolume8;

interface IDirect3DSwapChain8;

#endif


typedef interface IDirect3D8                IDirect3D8;
typedef interface IDirect3DDevice8          IDirect3DDevice8;
typedef interface IDirect3DResource8        IDirect3DResource8;
typedef interface IDirect3DBaseTexture8     IDirect3DBaseTexture8;
typedef interface IDirect3DTexture8         IDirect3DTexture8;
typedef interface IDirect3DVolumeTexture8   IDirect3DVolumeTexture8;
typedef interface IDirect3DCubeTexture8     IDirect3DCubeTexture8;
typedef interface IDirect3DVertexBuffer8    IDirect3DVertexBuffer8;
typedef interface IDirect3DIndexBuffer8     IDirect3DIndexBuffer8;
typedef interface IDirect3DSurface8         IDirect3DSurface8;
typedef interface IDirect3DVolume8          IDirect3DVolume8;
typedef interface IDirect3DSwapChain8       IDirect3DSwapChain8;

#include "d3d8types.h"
#include "d3d8caps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * DLL Function for creating a Direct3D8 object. This object supports
 * enumeration and allows the creation of Direct3DDevice8 objects.
 * Pass the value of the constant D3D_SDK_VERSION to this function, so
 * that the run-time can validate that your application was compiled
 * against the right headers.
 */

IDirect3D8 * WINAPI Direct3DCreate8(UINT SDKVersion);


/*
 * Direct3D interfaces
 */






#undef INTERFACE
#define INTERFACE IDirect3D8

DECLARE_INTERFACE_(IDirect3D8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D8 methods ***/
    STDMETHOD(RegisterSoftwareDevice)(THIS_ void* pInitializeFunction) PURE;
    STDMETHOD_(UINT, GetAdapterCount)(THIS) PURE;
    STDMETHOD(GetAdapterIdentifier)(THIS_ UINT Adapter,DWORD Flags,D3DADAPTER_IDENTIFIER8* pIdentifier) PURE;
    STDMETHOD_(UINT, GetAdapterModeCount)(THIS_ UINT Adapter) PURE;
    STDMETHOD(EnumAdapterModes)(THIS_ UINT Adapter,UINT Mode,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetAdapterDisplayMode)(THIS_ UINT Adapter,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(CheckDeviceType)(THIS_ UINT Adapter,D3DDEVTYPE CheckType,D3DFORMAT DisplayFormat,D3DFORMAT BackBufferFormat,BOOL Windowed) PURE;
    STDMETHOD(CheckDeviceFormat)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,DWORD Usage,D3DRESOURCETYPE RType,D3DFORMAT CheckFormat) PURE;
    STDMETHOD(CheckDeviceMultiSampleType)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT SurfaceFormat,BOOL Windowed,D3DMULTISAMPLE_TYPE MultiSampleType) PURE;
    STDMETHOD(CheckDepthStencilMatch)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat) PURE;
    STDMETHOD(GetDeviceCaps)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8* pCaps) PURE;
    STDMETHOD_(HMONITOR, GetAdapterMonitor)(THIS_ UINT Adapter) PURE;
    STDMETHOD(CreateDevice)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,HWND hFocusWindow,DWORD BehaviorFlags,D3DPRESENT_PARAMETERS* pPresentationParameters,IDirect3DDevice8** ppReturnedDeviceInterface) PURE;
};

typedef struct IDirect3D8 *LPDIRECT3D8, *PDIRECT3D8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D8_RegisterSoftwareDevice(p,a) (p)->lpVtbl->RegisterSoftwareDevice(p,a)
#define IDirect3D8_GetAdapterCount(p) (p)->lpVtbl->GetAdapterCount(p)
#define IDirect3D8_GetAdapterIdentifier(p,a,b,c) (p)->lpVtbl->GetAdapterIdentifier(p,a,b,c)
#define IDirect3D8_GetAdapterModeCount(p,a) (p)->lpVtbl->GetAdapterModeCount(p,a)
#define IDirect3D8_EnumAdapterModes(p,a,b,c) (p)->lpVtbl->EnumAdapterModes(p,a,b,c)
#define IDirect3D8_GetAdapterDisplayMode(p,a,b) (p)->lpVtbl->GetAdapterDisplayMode(p,a,b)
#define IDirect3D8_CheckDeviceType(p,a,b,c,d,e) (p)->lpVtbl->CheckDeviceType(p,a,b,c,d,e)
#define IDirect3D8_CheckDeviceFormat(p,a,b,c,d,e,f) (p)->lpVtbl->CheckDeviceFormat(p,a,b,c,d,e,f)
#define IDirect3D8_CheckDeviceMultiSampleType(p,a,b,c,d,e) (p)->lpVtbl->CheckDeviceMultiSampleType(p,a,b,c,d,e)
#define IDirect3D8_CheckDepthStencilMatch(p,a,b,c,d,e) (p)->lpVtbl->CheckDepthStencilMatch(p,a,b,c,d,e)
#define IDirect3D8_GetDeviceCaps(p,a,b,c) (p)->lpVtbl->GetDeviceCaps(p,a,b,c)
#define IDirect3D8_GetAdapterMonitor(p,a) (p)->lpVtbl->GetAdapterMonitor(p,a)
#define IDirect3D8_CreateDevice(p,a,b,c,d,e,f) (p)->lpVtbl->CreateDevice(p,a,b,c,d,e,f)
#else
#define IDirect3D8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D8_AddRef(p) (p)->AddRef()
#define IDirect3D8_Release(p) (p)->Release()
#define IDirect3D8_RegisterSoftwareDevice(p,a) (p)->RegisterSoftwareDevice(a)
#define IDirect3D8_GetAdapterCount(p) (p)->GetAdapterCount()
#define IDirect3D8_GetAdapterIdentifier(p,a,b,c) (p)->GetAdapterIdentifier(a,b,c)
#define IDirect3D8_GetAdapterModeCount(p,a) (p)->GetAdapterModeCount(a)
#define IDirect3D8_EnumAdapterModes(p,a,b,c) (p)->EnumAdapterModes(a,b,c)
#define IDirect3D8_GetAdapterDisplayMode(p,a,b) (p)->GetAdapterDisplayMode(a,b)
#define IDirect3D8_CheckDeviceType(p,a,b,c,d,e) (p)->CheckDeviceType(a,b,c,d,e)
#define IDirect3D8_CheckDeviceFormat(p,a,b,c,d,e,f) (p)->CheckDeviceFormat(a,b,c,d,e,f)
#define IDirect3D8_CheckDeviceMultiSampleType(p,a,b,c,d,e) (p)->CheckDeviceMultiSampleType(a,b,c,d,e)
#define IDirect3D8_CheckDepthStencilMatch(p,a,b,c,d,e) (p)->CheckDepthStencilMatch(a,b,c,d,e)
#define IDirect3D8_GetDeviceCaps(p,a,b,c) (p)->GetDeviceCaps(a,b,c)
#define IDirect3D8_GetAdapterMonitor(p,a) (p)->GetAdapterMonitor(a)
#define IDirect3D8_CreateDevice(p,a,b,c,d,e,f) (p)->CreateDevice(a,b,c,d,e,f)
#endif



















#undef INTERFACE
#define INTERFACE IDirect3DDevice8

DECLARE_INTERFACE_(IDirect3DDevice8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice8 methods ***/
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD_(UINT, GetAvailableTextureMem)(THIS) PURE;
    STDMETHOD(ResourceManagerDiscardBytes)(THIS_ DWORD Bytes) PURE;
    STDMETHOD(GetDirect3D)(THIS_ IDirect3D8** ppD3D8) PURE;
    STDMETHOD(GetDeviceCaps)(THIS_ D3DCAPS8* pCaps) PURE;
    STDMETHOD(GetDisplayMode)(THIS_ D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetCreationParameters)(THIS_ D3DDEVICE_CREATION_PARAMETERS *pParameters) PURE;
    STDMETHOD(SetCursorProperties)(THIS_ UINT XHotSpot,UINT YHotSpot,IDirect3DSurface8* pCursorBitmap) PURE;
    STDMETHOD_(void, SetCursorPosition)(THIS_ UINT XScreenSpace,UINT YScreenSpace,DWORD Flags) PURE;
    STDMETHOD_(BOOL, ShowCursor)(THIS_ BOOL bShow) PURE;
    STDMETHOD(CreateAdditionalSwapChain)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters,IDirect3DSwapChain8** pSwapChain) PURE;
    STDMETHOD(Reset)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters) PURE;
    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion) PURE;
    STDMETHOD(GetBackBuffer)(THIS_ UINT BackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface8** ppBackBuffer) PURE;
    STDMETHOD(GetRasterStatus)(THIS_ D3DRASTER_STATUS* pRasterStatus) PURE;
    STDMETHOD_(void, SetGammaRamp)(THIS_ DWORD Flags,CONST D3DGAMMARAMP* pRamp) PURE;
    STDMETHOD_(void, GetGammaRamp)(THIS_ D3DGAMMARAMP* pRamp) PURE;
    STDMETHOD(CreateTexture)(THIS_ UINT Width,UINT Height,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DTexture8** ppTexture) PURE;
    STDMETHOD(CreateVolumeTexture)(THIS_ UINT Width,UINT Height,UINT Depth,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DVolumeTexture8** ppVolumeTexture) PURE;
    STDMETHOD(CreateCubeTexture)(THIS_ UINT EdgeLength,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DCubeTexture8** ppCubeTexture) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ UINT Length,DWORD Usage,DWORD FVF,D3DPOOL Pool,IDirect3DVertexBuffer8** ppVertexBuffer) PURE;
    STDMETHOD(CreateIndexBuffer)(THIS_ UINT Length,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DIndexBuffer8** ppIndexBuffer) PURE;
    STDMETHOD(CreateRenderTarget)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DMULTISAMPLE_TYPE MultiSample,BOOL Lockable,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CreateDepthStencilSurface)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DMULTISAMPLE_TYPE MultiSample,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CreateImageSurface)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CopyRects)(THIS_ IDirect3DSurface8* pSourceSurface,CONST RECT* pSourceRectsArray,UINT cRects,IDirect3DSurface8* pDestinationSurface,CONST POINT* pDestPointsArray) PURE;
    STDMETHOD(UpdateTexture)(THIS_ IDirect3DBaseTexture8* pSourceTexture,IDirect3DBaseTexture8* pDestinationTexture) PURE;
    STDMETHOD(GetFrontBuffer)(THIS_ IDirect3DSurface8* pDestSurface) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ IDirect3DSurface8* pRenderTarget,IDirect3DSurface8* pNewZStencil) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ IDirect3DSurface8** ppRenderTarget) PURE;
    STDMETHOD(GetDepthStencilSurface)(THIS_ IDirect3DSurface8** ppZStencilSurface) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(Clear)(THIS_ DWORD Count,CONST D3DRECT* pRects,DWORD Flags,D3DCOLOR Color,float Z,DWORD Stencil) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE State,CONST D3DMATRIX* pMatrix) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE State,D3DMATRIX* pMatrix) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,CONST D3DMATRIX*) PURE;
    STDMETHOD(SetViewport)(THIS_ CONST D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(GetViewport)(THIS_ D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(SetMaterial)(THIS_ CONST D3DMATERIAL8* pMaterial) PURE;
    STDMETHOD(GetMaterial)(THIS_ D3DMATERIAL8* pMaterial) PURE;
    STDMETHOD(SetLight)(THIS_ DWORD Index,CONST D3DLIGHT8*) PURE;
    STDMETHOD(GetLight)(THIS_ DWORD Index,D3DLIGHT8*) PURE;
    STDMETHOD(LightEnable)(THIS_ DWORD Index,BOOL Enable) PURE;
    STDMETHOD(GetLightEnable)(THIS_ DWORD Index,BOOL* pEnable) PURE;
    STDMETHOD(SetClipPlane)(THIS_ DWORD Index,CONST float* pPlane) PURE;
    STDMETHOD(GetClipPlane)(THIS_ DWORD Index,float* pPlane) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD Value) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD* pValue) PURE;
    STDMETHOD(BeginStateBlock)(THIS) PURE;
    STDMETHOD(EndStateBlock)(THIS_ DWORD* pToken) PURE;
    STDMETHOD(ApplyStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(CaptureStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(DeleteStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE Type,DWORD* pToken) PURE;
    STDMETHOD(SetClipStatus)(THIS_ CONST D3DCLIPSTATUS8* pClipStatus) PURE;
    STDMETHOD(GetClipStatus)(THIS_ D3DCLIPSTATUS8* pClipStatus) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD Stage,IDirect3DBaseTexture8** ppTexture) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD Stage,IDirect3DBaseTexture8* pTexture) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD Stage,D3DTEXTURESTAGESTATETYPE Type,DWORD* pValue) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD Stage,D3DTEXTURESTAGESTATETYPE Type,DWORD Value) PURE;
    STDMETHOD(ValidateDevice)(THIS_ DWORD* pNumPasses) PURE;
    STDMETHOD(GetInfo)(THIS_ DWORD DevInfoID,void* pDevInfoStruct,DWORD DevInfoStructSize) PURE;
    STDMETHOD(SetPaletteEntries)(THIS_ UINT PaletteNumber,CONST PALETTEENTRY* pEntries) PURE;
    STDMETHOD(GetPaletteEntries)(THIS_ UINT PaletteNumber,PALETTEENTRY* pEntries) PURE;
    STDMETHOD(SetCurrentTexturePalette)(THIS_ UINT PaletteNumber) PURE;
    STDMETHOD(GetCurrentTexturePalette)(THIS_ UINT *PaletteNumber) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT StartVertex,UINT PrimitiveCount) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,UINT minIndex,UINT NumVertices,UINT startIndex,UINT primCount) PURE;
    STDMETHOD(DrawPrimitiveUP)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT PrimitiveCount,CONST void* pVertexStreamZeroData,UINT VertexStreamZeroStride) PURE;
    STDMETHOD(DrawIndexedPrimitiveUP)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT MinVertexIndex,UINT NumVertexIndices,UINT PrimitiveCount,CONST void* pIndexData,D3DFORMAT IndexDataFormat,CONST void* pVertexStreamZeroData,UINT VertexStreamZeroStride) PURE;
    STDMETHOD(ProcessVertices)(THIS_ UINT SrcStartIndex,UINT DestIndex,UINT VertexCount,IDirect3DVertexBuffer8* pDestBuffer,DWORD Flags) PURE;
    STDMETHOD(CreateVertexShader)(THIS_ CONST DWORD* pDeclaration,CONST DWORD* pFunction,DWORD* pHandle,DWORD Usage) PURE;
    STDMETHOD(SetVertexShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(GetVertexShader)(THIS_ DWORD* pHandle) PURE;
    STDMETHOD(DeleteVertexShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(SetVertexShaderConstant)(THIS_ DWORD Register,CONST void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetVertexShaderConstant)(THIS_ DWORD Register,void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetVertexShaderDeclaration)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(GetVertexShaderFunction)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(SetStreamSource)(THIS_ UINT StreamNumber,IDirect3DVertexBuffer8* pStreamData,UINT Stride) PURE;
    STDMETHOD(GetStreamSource)(THIS_ UINT StreamNumber,IDirect3DVertexBuffer8** ppStreamData,UINT* pStride) PURE;
    STDMETHOD(SetIndices)(THIS_ IDirect3DIndexBuffer8* pIndexData,UINT BaseVertexIndex) PURE;
    STDMETHOD(GetIndices)(THIS_ IDirect3DIndexBuffer8** ppIndexData,UINT* pBaseVertexIndex) PURE;
    STDMETHOD(CreatePixelShader)(THIS_ CONST DWORD* pFunction,DWORD* pHandle) PURE;
    STDMETHOD(SetPixelShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(GetPixelShader)(THIS_ DWORD* pHandle) PURE;
    STDMETHOD(DeletePixelShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(SetPixelShaderConstant)(THIS_ DWORD Register,CONST void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetPixelShaderConstant)(THIS_ DWORD Register,void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetPixelShaderFunction)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(DrawRectPatch)(THIS_ UINT Handle,CONST float* pNumSegs,CONST D3DRECTPATCH_INFO* pRectPatchInfo) PURE;
    STDMETHOD(DrawTriPatch)(THIS_ UINT Handle,CONST float* pNumSegs,CONST D3DTRIPATCH_INFO* pTriPatchInfo) PURE;
    STDMETHOD(DeletePatch)(THIS_ UINT Handle) PURE;
};

typedef struct IDirect3DDevice8 *LPDIRECT3DDEVICE8, *PDIRECT3DDEVICE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice8_TestCooperativeLevel(p) (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirect3DDevice8_GetAvailableTextureMem(p) (p)->lpVtbl->GetAvailableTextureMem(p)
#define IDirect3DDevice8_ResourceManagerDiscardBytes(p,a) (p)->lpVtbl->ResourceManagerDiscardBytes(p,a)
#define IDirect3DDevice8_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice8_GetDeviceCaps(p,a) (p)->lpVtbl->GetDeviceCaps(p,a)
#define IDirect3DDevice8_GetDisplayMode(p,a) (p)->lpVtbl->GetDisplayMode(p,a)
#define IDirect3DDevice8_GetCreationParameters(p,a) (p)->lpVtbl->GetCreationParameters(p,a)
#define IDirect3DDevice8_SetCursorProperties(p,a,b,c) (p)->lpVtbl->SetCursorProperties(p,a,b,c)
#define IDirect3DDevice8_SetCursorPosition(p,a,b,c) (p)->lpVtbl->SetCursorPosition(p,a,b,c)
#define IDirect3DDevice8_ShowCursor(p,a) (p)->lpVtbl->ShowCursor(p,a)
#define IDirect3DDevice8_CreateAdditionalSwapChain(p,a,b) (p)->lpVtbl->CreateAdditionalSwapChain(p,a,b)
#define IDirect3DDevice8_Reset(p,a) (p)->lpVtbl->Reset(p,a)
#define IDirect3DDevice8_Present(p,a,b,c,d) (p)->lpVtbl->Present(p,a,b,c,d)
#define IDirect3DDevice8_GetBackBuffer(p,a,b,c) (p)->lpVtbl->GetBackBuffer(p,a,b,c)
#define IDirect3DDevice8_GetRasterStatus(p,a) (p)->lpVtbl->GetRasterStatus(p,a)
#define IDirect3DDevice8_SetGammaRamp(p,a,b) (p)->lpVtbl->SetGammaRamp(p,a,b)
#define IDirect3DDevice8_GetGammaRamp(p,a) (p)->lpVtbl->GetGammaRamp(p,a)
#define IDirect3DDevice8_CreateTexture(p,a,b,c,d,e,f,g) (p)->lpVtbl->CreateTexture(p,a,b,c,d,e,f,g)
#define IDirect3DDevice8_CreateVolumeTexture(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->CreateVolumeTexture(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_CreateCubeTexture(p,a,b,c,d,e,f) (p)->lpVtbl->CreateCubeTexture(p,a,b,c,d,e,f)
#define IDirect3DDevice8_CreateVertexBuffer(p,a,b,c,d,e) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateIndexBuffer(p,a,b,c,d,e) (p)->lpVtbl->CreateIndexBuffer(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateRenderTarget(p,a,b,c,d,e,f) (p)->lpVtbl->CreateRenderTarget(p,a,b,c,d,e,f)
#define IDirect3DDevice8_CreateDepthStencilSurface(p,a,b,c,d,e) (p)->lpVtbl->CreateDepthStencilSurface(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateImageSurface(p,a,b,c,d) (p)->lpVtbl->CreateImageSurface(p,a,b,c,d)
#define IDirect3DDevice8_CopyRects(p,a,b,c,d,e) (p)->lpVtbl->CopyRects(p,a,b,c,d,e)
#define IDirect3DDevice8_UpdateTexture(p,a,b) (p)->lpVtbl->UpdateTexture(p,a,b)
#define IDirect3DDevice8_GetFrontBuffer(p,a) (p)->lpVtbl->GetFrontBuffer(p,a)
#define IDirect3DDevice8_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice8_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice8_GetDepthStencilSurface(p,a) (p)->lpVtbl->GetDepthStencilSurface(p,a)
#define IDirect3DDevice8_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice8_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice8_Clear(p,a,b,c,d,e,f) (p)->lpVtbl->Clear(p,a,b,c,d,e,f)
#define IDirect3DDevice8_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice8_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice8_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice8_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DDevice8_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DDevice8_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DDevice8_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DDevice8_SetLight(p,a,b) (p)->lpVtbl->SetLight(p,a,b)
#define IDirect3DDevice8_GetLight(p,a,b) (p)->lpVtbl->GetLight(p,a,b)
#define IDirect3DDevice8_LightEnable(p,a,b) (p)->lpVtbl->LightEnable(p,a,b)
#define IDirect3DDevice8_GetLightEnable(p,a,b) (p)->lpVtbl->GetLightEnable(p,a,b)
#define IDirect3DDevice8_SetClipPlane(p,a,b) (p)->lpVtbl->SetClipPlane(p,a,b)
#define IDirect3DDevice8_GetClipPlane(p,a,b) (p)->lpVtbl->GetClipPlane(p,a,b)
#define IDirect3DDevice8_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice8_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice8_BeginStateBlock(p) (p)->lpVtbl->BeginStateBlock(p)
#define IDirect3DDevice8_EndStateBlock(p,a) (p)->lpVtbl->EndStateBlock(p,a)
#define IDirect3DDevice8_ApplyStateBlock(p,a) (p)->lpVtbl->ApplyStateBlock(p,a)
#define IDirect3DDevice8_CaptureStateBlock(p,a) (p)->lpVtbl->CaptureStateBlock(p,a)
#define IDirect3DDevice8_DeleteStateBlock(p,a) (p)->lpVtbl->DeleteStateBlock(p,a)
#define IDirect3DDevice8_CreateStateBlock(p,a,b) (p)->lpVtbl->CreateStateBlock(p,a,b)
#define IDirect3DDevice8_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice8_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice8_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice8_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice8_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice8_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice8_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#define IDirect3DDevice8_GetInfo(p,a,b,c) (p)->lpVtbl->GetInfo(p,a,b,c)
#define IDirect3DDevice8_SetPaletteEntries(p,a,b) (p)->lpVtbl->SetPaletteEntries(p,a,b)
#define IDirect3DDevice8_GetPaletteEntries(p,a,b) (p)->lpVtbl->GetPaletteEntries(p,a,b)
#define IDirect3DDevice8_SetCurrentTexturePalette(p,a) (p)->lpVtbl->SetCurrentTexturePalette(p,a)
#define IDirect3DDevice8_GetCurrentTexturePalette(p,a) (p)->lpVtbl->GetCurrentTexturePalette(p,a)
#define IDirect3DDevice8_DrawPrimitive(p,a,b,c) (p)->lpVtbl->DrawPrimitive(p,a,b,c)
#define IDirect3DDevice8_DrawIndexedPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice8_DrawPrimitiveUP(p,a,b,c,d) (p)->lpVtbl->DrawPrimitiveUP(p,a,b,c,d)
#define IDirect3DDevice8_DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_ProcessVertices(p,a,b,c,d,e) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateVertexShader(p,a,b,c,d) (p)->lpVtbl->CreateVertexShader(p,a,b,c,d)
#define IDirect3DDevice8_SetVertexShader(p,a) (p)->lpVtbl->SetVertexShader(p,a)
#define IDirect3DDevice8_GetVertexShader(p,a) (p)->lpVtbl->GetVertexShader(p,a)
#define IDirect3DDevice8_DeleteVertexShader(p,a) (p)->lpVtbl->DeleteVertexShader(p,a)
#define IDirect3DDevice8_SetVertexShaderConstant(p,a,b,c) (p)->lpVtbl->SetVertexShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderConstant(p,a,b,c) (p)->lpVtbl->GetVertexShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderDeclaration(p,a,b,c) (p)->lpVtbl->GetVertexShaderDeclaration(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderFunction(p,a,b,c) (p)->lpVtbl->GetVertexShaderFunction(p,a,b,c)
#define IDirect3DDevice8_SetStreamSource(p,a,b,c) (p)->lpVtbl->SetStreamSource(p,a,b,c)
#define IDirect3DDevice8_GetStreamSource(p,a,b,c) (p)->lpVtbl->GetStreamSource(p,a,b,c)
#define IDirect3DDevice8_SetIndices(p,a,b) (p)->lpVtbl->SetIndices(p,a,b)
#define IDirect3DDevice8_GetIndices(p,a,b) (p)->lpVtbl->GetIndices(p,a,b)
#define IDirect3DDevice8_CreatePixelShader(p,a,b) (p)->lpVtbl->CreatePixelShader(p,a,b)
#define IDirect3DDevice8_SetPixelShader(p,a) (p)->lpVtbl->SetPixelShader(p,a)
#define IDirect3DDevice8_GetPixelShader(p,a) (p)->lpVtbl->GetPixelShader(p,a)
#define IDirect3DDevice8_DeletePixelShader(p,a) (p)->lpVtbl->DeletePixelShader(p,a)
#define IDirect3DDevice8_SetPixelShaderConstant(p,a,b,c) (p)->lpVtbl->SetPixelShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetPixelShaderConstant(p,a,b,c) (p)->lpVtbl->GetPixelShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetPixelShaderFunction(p,a,b,c) (p)->lpVtbl->GetPixelShaderFunction(p,a,b,c)
#define IDirect3DDevice8_DrawRectPatch(p,a,b,c) (p)->lpVtbl->DrawRectPatch(p,a,b,c)
#define IDirect3DDevice8_DrawTriPatch(p,a,b,c) (p)->lpVtbl->DrawTriPatch(p,a,b,c)
#define IDirect3DDevice8_DeletePatch(p,a) (p)->lpVtbl->DeletePatch(p,a)
#else
#define IDirect3DDevice8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice8_AddRef(p) (p)->AddRef()
#define IDirect3DDevice8_Release(p) (p)->Release()
#define IDirect3DDevice8_TestCooperativeLevel(p) (p)->TestCooperativeLevel()
#define IDirect3DDevice8_GetAvailableTextureMem(p) (p)->GetAvailableTextureMem()
#define IDirect3DDevice8_ResourceManagerDiscardBytes(p,a) (p)->ResourceManagerDiscardBytes(a)
#define IDirect3DDevice8_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice8_GetDeviceCaps(p,a) (p)->GetDeviceCaps(a)
#define IDirect3DDevice8_GetDisplayMode(p,a) (p)->GetDisplayMode(a)
#define IDirect3DDevice8_GetCreationParameters(p,a) (p)->GetCreationParameters(a)
#define IDirect3DDevice8_SetCursorProperties(p,a,b,c) (p)->SetCursorProperties(a,b,c)
#define IDirect3DDevice8_SetCursorPosition(p,a,b,c) (p)->SetCursorPosition(a,b,c)
#define IDirect3DDevice8_ShowCursor(p,a) (p)->ShowCursor(a)
#define IDirect3DDevice8_CreateAdditionalSwapChain(p,a,b) (p)->CreateAdditionalSwapChain(a,b)
#define IDirect3DDevice8_Reset(p,a) (p)->Reset(a)
#define IDirect3DDevice8_Present(p,a,b,c,d) (p)->Present(a,b,c,d)
#define IDirect3DDevice8_GetBackBuffer(p,a,b,c) (p)->GetBackBuffer(a,b,c)
#define IDirect3DDevice8_GetRasterStatus(p,a) (p)->GetRasterStatus(a)
#define IDirect3DDevice8_SetGammaRamp(p,a,b) (p)->SetGammaRamp(a,b)
#define IDirect3DDevice8_GetGammaRamp(p,a) (p)->GetGammaRamp(a)
#define IDirect3DDevice8_CreateTexture(p,a,b,c,d,e,f,g) (p)->CreateTexture(a,b,c,d,e,f,g)
#define IDirect3DDevice8_CreateVolumeTexture(p,a,b,c,d,e,f,g,h) (p)->CreateVolumeTexture(a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_CreateCubeTexture(p,a,b,c,d,e,f) (p)->CreateCubeTexture(a,b,c,d,e,f)
#define IDirect3DDevice8_CreateVertexBuffer(p,a,b,c,d,e) (p)->CreateVertexBuffer(a,b,c,d,e)
#define IDirect3DDevice8_CreateIndexBuffer(p,a,b,c,d,e) (p)->CreateIndexBuffer(a,b,c,d,e)
#define IDirect3DDevice8_CreateRenderTarget(p,a,b,c,d,e,f) (p)->CreateRenderTarget(a,b,c,d,e,f)
#define IDirect3DDevice8_CreateDepthStencilSurface(p,a,b,c,d,e) (p)->CreateDepthStencilSurface(a,b,c,d,e)
#define IDirect3DDevice8_CreateImageSurface(p,a,b,c,d) (p)->CreateImageSurface(a,b,c,d)
#define IDirect3DDevice8_CopyRects(p,a,b,c,d,e) (p)->CopyRects(a,b,c,d,e)
#define IDirect3DDevice8_UpdateTexture(p,a,b) (p)->UpdateTexture(a,b)
#define IDirect3DDevice8_GetFrontBuffer(p,a) (p)->GetFrontBuffer(a)
#define IDirect3DDevice8_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice8_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice8_GetDepthStencilSurface(p,a) (p)->GetDepthStencilSurface(a)
#define IDirect3DDevice8_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice8_EndScene(p) (p)->EndScene()
#define IDirect3DDevice8_Clear(p,a,b,c,d,e,f) (p)->Clear(a,b,c,d,e,f)
#define IDirect3DDevice8_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice8_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice8_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice8_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DDevice8_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DDevice8_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DDevice8_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DDevice8_SetLight(p,a,b) (p)->SetLight(a,b)
#define IDirect3DDevice8_GetLight(p,a,b) (p)->GetLight(a,b)
#define IDirect3DDevice8_LightEnable(p,a,b) (p)->LightEnable(a,b)
#define IDirect3DDevice8_GetLightEnable(p,a,b) (p)->GetLightEnable(a,b)
#define IDirect3DDevice8_SetClipPlane(p,a,b) (p)->SetClipPlane(a,b)
#define IDirect3DDevice8_GetClipPlane(p,a,b) (p)->GetClipPlane(a,b)
#define IDirect3DDevice8_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice8_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice8_BeginStateBlock(p) (p)->BeginStateBlock()
#define IDirect3DDevice8_EndStateBlock(p,a) (p)->EndStateBlock(a)
#define IDirect3DDevice8_ApplyStateBlock(p,a) (p)->ApplyStateBlock(a)
#define IDirect3DDevice8_CaptureStateBlock(p,a) (p)->CaptureStateBlock(a)
#define IDirect3DDevice8_DeleteStateBlock(p,a) (p)->DeleteStateBlock(a)
#define IDirect3DDevice8_CreateStateBlock(p,a,b) (p)->CreateStateBlock(a,b)
#define IDirect3DDevice8_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice8_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice8_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice8_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice8_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice8_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice8_ValidateDevice(p,a) (p)->ValidateDevice(a)
#define IDirect3DDevice8_GetInfo(p,a,b,c) (p)->GetInfo(a,b,c)
#define IDirect3DDevice8_SetPaletteEntries(p,a,b) (p)->SetPaletteEntries(a,b)
#define IDirect3DDevice8_GetPaletteEntries(p,a,b) (p)->GetPaletteEntries(a,b)
#define IDirect3DDevice8_SetCurrentTexturePalette(p,a) (p)->SetCurrentTexturePalette(a)
#define IDirect3DDevice8_GetCurrentTexturePalette(p,a) (p)->GetCurrentTexturePalette(a)
#define IDirect3DDevice8_DrawPrimitive(p,a,b,c) (p)->DrawPrimitive(a,b,c)
#define IDirect3DDevice8_DrawIndexedPrimitive(p,a,b,c,d,e) (p)->DrawIndexedPrimitive(a,b,c,d,e)
#define IDirect3DDevice8_DrawPrimitiveUP(p,a,b,c,d) (p)->DrawPrimitiveUP(a,b,c,d)
#define IDirect3DDevice8_DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h) (p)->DrawIndexedPrimitiveUP(a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_ProcessVertices(p,a,b,c,d,e) (p)->ProcessVertices(a,b,c,d,e)
#define IDirect3DDevice8_CreateVertexShader(p,a,b,c,d) (p)->CreateVertexShader(a,b,c,d)
#define IDirect3DDevice8_SetVertexShader(p,a) (p)->SetVertexShader(a)
#define IDirect3DDevice8_GetVertexShader(p,a) (p)->GetVertexShader(a)
#define IDirect3DDevice8_DeleteVertexShader(p,a) (p)->DeleteVertexShader(a)
#define IDirect3DDevice8_SetVertexShaderConstant(p,a,b,c) (p)->SetVertexShaderConstant(a,b,c)
#define IDirect3DDevice8_GetVertexShaderConstant(p,a,b,c) (p)->GetVertexShaderConstant(a,b,c)
#define IDirect3DDevice8_GetVertexShaderDeclaration(p,a,b,c) (p)->GetVertexShaderDeclaration(a,b,c)
#define IDirect3DDevice8_GetVertexShaderFunction(p,a,b,c) (p)->GetVertexShaderFunction(a,b,c)
#define IDirect3DDevice8_SetStreamSource(p,a,b,c) (p)->SetStreamSource(a,b,c)
#define IDirect3DDevice8_GetStreamSource(p,a,b,c) (p)->GetStreamSource(a,b,c)
#define IDirect3DDevice8_SetIndices(p,a,b) (p)->SetIndices(a,b)
#define IDirect3DDevice8_GetIndices(p,a,b) (p)->GetIndices(a,b)
#define IDirect3DDevice8_CreatePixelShader(p,a,b) (p)->CreatePixelShader(a,b)
#define IDirect3DDevice8_SetPixelShader(p,a) (p)->SetPixelShader(a)
#define IDirect3DDevice8_GetPixelShader(p,a) (p)->GetPixelShader(a)
#define IDirect3DDevice8_DeletePixelShader(p,a) (p)->DeletePixelShader(a)
#define IDirect3DDevice8_SetPixelShaderConstant(p,a,b,c) (p)->SetPixelShaderConstant(a,b,c)
#define IDirect3DDevice8_GetPixelShaderConstant(p,a,b,c) (p)->GetPixelShaderConstant(a,b,c)
#define IDirect3DDevice8_GetPixelShaderFunction(p,a,b,c) (p)->GetPixelShaderFunction(a,b,c)
#define IDirect3DDevice8_DrawRectPatch(p,a,b,c) (p)->DrawRectPatch(a,b,c)
#define IDirect3DDevice8_DrawTriPatch(p,a,b,c) (p)->DrawTriPatch(a,b,c)
#define IDirect3DDevice8_DeletePatch(p,a) (p)->DeletePatch(a)
#endif



#undef INTERFACE
#define INTERFACE IDirect3DSwapChain8

DECLARE_INTERFACE_(IDirect3DSwapChain8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DSwapChain8 methods ***/
    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion) PURE;
    STDMETHOD(GetBackBuffer)(THIS_ UINT BackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface8** ppBackBuffer) PURE;
};

typedef struct IDirect3DSwapChain8 *LPDIRECT3DSWAPCHAIN8, *PDIRECT3DSWAPCHAIN8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DSwapChain8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DSwapChain8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DSwapChain8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DSwapChain8_Present(p,a,b,c,d) (p)->lpVtbl->Present(p,a,b,c,d)
#define IDirect3DSwapChain8_GetBackBuffer(p,a,b,c) (p)->lpVtbl->GetBackBuffer(p,a,b,c)
#else
#define IDirect3DSwapChain8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DSwapChain8_AddRef(p) (p)->AddRef()
#define IDirect3DSwapChain8_Release(p) (p)->Release()
#define IDirect3DSwapChain8_Present(p,a,b,c,d) (p)->Present(a,b,c,d)
#define IDirect3DSwapChain8_GetBackBuffer(p,a,b,c) (p)->GetBackBuffer(a,b,c)
#endif



#undef INTERFACE
#define INTERFACE IDirect3DResource8

DECLARE_INTERFACE_(IDirect3DResource8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
};

typedef struct IDirect3DResource8 *LPDIRECT3DRESOURCE8, *PDIRECT3DRESOURCE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DResource8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DResource8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DResource8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DResource8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DResource8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DResource8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DResource8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DResource8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DResource8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DResource8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DResource8_GetType(p) (p)->lpVtbl->GetType(p)
#else
#define IDirect3DResource8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DResource8_AddRef(p) (p)->AddRef()
#define IDirect3DResource8_Release(p) (p)->Release()
#define IDirect3DResource8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DResource8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DResource8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DResource8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DResource8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DResource8_GetPriority(p) (p)->GetPriority()
#define IDirect3DResource8_PreLoad(p) (p)->PreLoad()
#define IDirect3DResource8_GetType(p) (p)->GetType()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DBaseTexture8

DECLARE_INTERFACE_(IDirect3DBaseTexture8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
};

typedef struct IDirect3DBaseTexture8 *LPDIRECT3DBASETEXTURE8, *PDIRECT3DBASETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DBaseTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DBaseTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DBaseTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DBaseTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DBaseTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DBaseTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DBaseTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DBaseTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DBaseTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DBaseTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DBaseTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DBaseTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DBaseTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DBaseTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#else
#define IDirect3DBaseTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DBaseTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DBaseTexture8_Release(p) (p)->Release()
#define IDirect3DBaseTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DBaseTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DBaseTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DBaseTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DBaseTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DBaseTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DBaseTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DBaseTexture8_GetType(p) (p)->GetType()
#define IDirect3DBaseTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DBaseTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DBaseTexture8_GetLevelCount(p) (p)->GetLevelCount()
#endif





#undef INTERFACE
#define INTERFACE IDirect3DTexture8

DECLARE_INTERFACE_(IDirect3DTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(GetSurfaceLevel)(THIS_ UINT Level,IDirect3DSurface8** ppSurfaceLevel) PURE;
    STDMETHOD(LockRect)(THIS_ UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS_ UINT Level) PURE;
    STDMETHOD(AddDirtyRect)(THIS_ CONST RECT* pDirtyRect) PURE;
};

typedef struct IDirect3DTexture8 *LPDIRECT3DTEXTURE8, *PDIRECT3DTEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DTexture8_GetSurfaceLevel(p,a,b) (p)->lpVtbl->GetSurfaceLevel(p,a,b)
#define IDirect3DTexture8_LockRect(p,a,b,c,d) (p)->lpVtbl->LockRect(p,a,b,c,d)
#define IDirect3DTexture8_UnlockRect(p,a) (p)->lpVtbl->UnlockRect(p,a)
#define IDirect3DTexture8_AddDirtyRect(p,a) (p)->lpVtbl->AddDirtyRect(p,a)
#else
#define IDirect3DTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DTexture8_Release(p) (p)->Release()
#define IDirect3DTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DTexture8_GetType(p) (p)->GetType()
#define IDirect3DTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DTexture8_GetSurfaceLevel(p,a,b) (p)->GetSurfaceLevel(a,b)
#define IDirect3DTexture8_LockRect(p,a,b,c,d) (p)->LockRect(a,b,c,d)
#define IDirect3DTexture8_UnlockRect(p,a) (p)->UnlockRect(a)
#define IDirect3DTexture8_AddDirtyRect(p,a) (p)->AddDirtyRect(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DVolumeTexture8

DECLARE_INTERFACE_(IDirect3DVolumeTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DVOLUME_DESC *pDesc) PURE;
    STDMETHOD(GetVolumeLevel)(THIS_ UINT Level,IDirect3DVolume8** ppVolumeLevel) PURE;
    STDMETHOD(LockBox)(THIS_ UINT Level,D3DLOCKED_BOX* pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) PURE;
    STDMETHOD(UnlockBox)(THIS_ UINT Level) PURE;
    STDMETHOD(AddDirtyBox)(THIS_ CONST D3DBOX* pDirtyBox) PURE;
};

typedef struct IDirect3DVolumeTexture8 *LPDIRECT3DVOLUMETEXTURE8, *PDIRECT3DVOLUMETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVolumeTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVolumeTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVolumeTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVolumeTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVolumeTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVolumeTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVolumeTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVolumeTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DVolumeTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DVolumeTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DVolumeTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DVolumeTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DVolumeTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DVolumeTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DVolumeTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DVolumeTexture8_GetVolumeLevel(p,a,b) (p)->lpVtbl->GetVolumeLevel(p,a,b)
#define IDirect3DVolumeTexture8_LockBox(p,a,b,c,d) (p)->lpVtbl->LockBox(p,a,b,c,d)
#define IDirect3DVolumeTexture8_UnlockBox(p,a) (p)->lpVtbl->UnlockBox(p,a)
#define IDirect3DVolumeTexture8_AddDirtyBox(p,a) (p)->lpVtbl->AddDirtyBox(p,a)
#else
#define IDirect3DVolumeTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVolumeTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DVolumeTexture8_Release(p) (p)->Release()
#define IDirect3DVolumeTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVolumeTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVolumeTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVolumeTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVolumeTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DVolumeTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DVolumeTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DVolumeTexture8_GetType(p) (p)->GetType()
#define IDirect3DVolumeTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DVolumeTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DVolumeTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DVolumeTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DVolumeTexture8_GetVolumeLevel(p,a,b) (p)->GetVolumeLevel(a,b)
#define IDirect3DVolumeTexture8_LockBox(p,a,b,c,d) (p)->LockBox(a,b,c,d)
#define IDirect3DVolumeTexture8_UnlockBox(p,a) (p)->UnlockBox(a)
#define IDirect3DVolumeTexture8_AddDirtyBox(p,a) (p)->AddDirtyBox(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DCubeTexture8

DECLARE_INTERFACE_(IDirect3DCubeTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(GetCubeMapSurface)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,IDirect3DSurface8** ppCubeMapSurface) PURE;
    STDMETHOD(LockRect)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level) PURE;
    STDMETHOD(AddDirtyRect)(THIS_ D3DCUBEMAP_FACES FaceType,CONST RECT* pDirtyRect) PURE;
};

typedef struct IDirect3DCubeTexture8 *LPDIRECT3DCUBETEXTURE8, *PDIRECT3DCUBETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DCubeTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DCubeTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DCubeTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DCubeTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DCubeTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DCubeTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DCubeTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DCubeTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DCubeTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DCubeTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DCubeTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DCubeTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DCubeTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DCubeTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DCubeTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DCubeTexture8_GetCubeMapSurface(p,a,b,c) (p)->lpVtbl->GetCubeMapSurface(p,a,b,c)
#define IDirect3DCubeTexture8_LockRect(p,a,b,c,d,e) (p)->lpVtbl->LockRect(p,a,b,c,d,e)
#define IDirect3DCubeTexture8_UnlockRect(p,a,b) (p)->lpVtbl->UnlockRect(p,a,b)
#define IDirect3DCubeTexture8_AddDirtyRect(p,a,b) (p)->lpVtbl->AddDirtyRect(p,a,b)
#else
#define IDirect3DCubeTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DCubeTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DCubeTexture8_Release(p) (p)->Release()
#define IDirect3DCubeTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DCubeTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DCubeTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DCubeTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DCubeTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DCubeTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DCubeTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DCubeTexture8_GetType(p) (p)->GetType()
#define IDirect3DCubeTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DCubeTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DCubeTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DCubeTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DCubeTexture8_GetCubeMapSurface(p,a,b,c) (p)->GetCubeMapSurface(a,b,c)
#define IDirect3DCubeTexture8_LockRect(p,a,b,c,d,e) (p)->LockRect(a,b,c,d,e)
#define IDirect3DCubeTexture8_UnlockRect(p,a,b) (p)->UnlockRect(a,b)
#define IDirect3DCubeTexture8_AddDirtyRect(p,a,b) (p)->AddDirtyRect(a,b)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer8

DECLARE_INTERFACE_(IDirect3DVertexBuffer8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ UINT OffsetToLock,UINT SizeToLock,BYTE** ppbData,DWORD Flags) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DVERTEXBUFFER_DESC *pDesc) PURE;
};

typedef struct IDirect3DVertexBuffer8 *LPDIRECT3DVERTEXBUFFER8, *PDIRECT3DVERTEXBUFFER8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVertexBuffer8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVertexBuffer8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVertexBuffer8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVertexBuffer8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DVertexBuffer8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DVertexBuffer8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DVertexBuffer8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DVertexBuffer8_Lock(p,a,b,c,d) (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirect3DVertexBuffer8_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#else
#define IDirect3DVertexBuffer8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer8_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer8_Release(p) (p)->Release()
#define IDirect3DVertexBuffer8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVertexBuffer8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVertexBuffer8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVertexBuffer8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVertexBuffer8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DVertexBuffer8_GetPriority(p) (p)->GetPriority()
#define IDirect3DVertexBuffer8_PreLoad(p) (p)->PreLoad()
#define IDirect3DVertexBuffer8_GetType(p) (p)->GetType()
#define IDirect3DVertexBuffer8_Lock(p,a,b,c,d) (p)->Lock(a,b,c,d)
#define IDirect3DVertexBuffer8_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer8_GetDesc(p,a) (p)->GetDesc(a)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DIndexBuffer8

DECLARE_INTERFACE_(IDirect3DIndexBuffer8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ UINT OffsetToLock,UINT SizeToLock,BYTE** ppbData,DWORD Flags) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DINDEXBUFFER_DESC *pDesc) PURE;
};

typedef struct IDirect3DIndexBuffer8 *LPDIRECT3DINDEXBUFFER8, *PDIRECT3DINDEXBUFFER8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DIndexBuffer8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DIndexBuffer8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DIndexBuffer8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DIndexBuffer8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DIndexBuffer8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DIndexBuffer8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DIndexBuffer8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DIndexBuffer8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DIndexBuffer8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DIndexBuffer8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DIndexBuffer8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DIndexBuffer8_Lock(p,a,b,c,d) (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirect3DIndexBuffer8_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DIndexBuffer8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#else
#define IDirect3DIndexBuffer8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DIndexBuffer8_AddRef(p) (p)->AddRef()
#define IDirect3DIndexBuffer8_Release(p) (p)->Release()
#define IDirect3DIndexBuffer8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DIndexBuffer8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DIndexBuffer8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DIndexBuffer8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DIndexBuffer8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DIndexBuffer8_GetPriority(p) (p)->GetPriority()
#define IDirect3DIndexBuffer8_PreLoad(p) (p)->PreLoad()
#define IDirect3DIndexBuffer8_GetType(p) (p)->GetType()
#define IDirect3DIndexBuffer8_Lock(p,a,b,c,d) (p)->Lock(a,b,c,d)
#define IDirect3DIndexBuffer8_Unlock(p) (p)->Unlock()
#define IDirect3DIndexBuffer8_GetDesc(p,a) (p)->GetDesc(a)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DSurface8

DECLARE_INTERFACE_(IDirect3DSurface8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DSurface8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD(GetContainer)(THIS_ REFIID riid,void** ppContainer) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(LockRect)(THIS_ D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS) PURE;
};

typedef struct IDirect3DSurface8 *LPDIRECT3DSURFACE8, *PDIRECT3DSURFACE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DSurface8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DSurface8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DSurface8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DSurface8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DSurface8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DSurface8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DSurface8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DSurface8_GetContainer(p,a,b) (p)->lpVtbl->GetContainer(p,a,b)
#define IDirect3DSurface8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#define IDirect3DSurface8_LockRect(p,a,b,c) (p)->lpVtbl->LockRect(p,a,b,c)
#define IDirect3DSurface8_UnlockRect(p) (p)->lpVtbl->UnlockRect(p)
#else
#define IDirect3DSurface8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DSurface8_AddRef(p) (p)->AddRef()
#define IDirect3DSurface8_Release(p) (p)->Release()
#define IDirect3DSurface8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DSurface8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DSurface8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DSurface8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DSurface8_GetContainer(p,a,b) (p)->GetContainer(a,b)
#define IDirect3DSurface8_GetDesc(p,a) (p)->GetDesc(a)
#define IDirect3DSurface8_LockRect(p,a,b,c) (p)->LockRect(a,b,c)
#define IDirect3DSurface8_UnlockRect(p) (p)->UnlockRect()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVolume8

DECLARE_INTERFACE_(IDirect3DVolume8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVolume8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD(GetContainer)(THIS_ REFIID riid,void** ppContainer) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DVOLUME_DESC *pDesc) PURE;
    STDMETHOD(LockBox)(THIS_ D3DLOCKED_BOX * pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) PURE;
    STDMETHOD(UnlockBox)(THIS) PURE;
};

typedef struct IDirect3DVolume8 *LPDIRECT3DVOLUME8, *PDIRECT3DVOLUME8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVolume8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVolume8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVolume8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVolume8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVolume8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVolume8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVolume8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVolume8_GetContainer(p,a,b) (p)->lpVtbl->GetContainer(p,a,b)
#define IDirect3DVolume8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#define IDirect3DVolume8_LockBox(p,a,b,c) (p)->lpVtbl->LockBox(p,a,b,c)
#define IDirect3DVolume8_UnlockBox(p) (p)->lpVtbl->UnlockBox(p)
#else
#define IDirect3DVolume8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVolume8_AddRef(p) (p)->AddRef()
#define IDirect3DVolume8_Release(p) (p)->Release()
#define IDirect3DVolume8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVolume8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVolume8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVolume8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVolume8_GetContainer(p,a,b) (p)->GetContainer(a,b)
#define IDirect3DVolume8_GetDesc(p,a) (p)->GetDesc(a)
#define IDirect3DVolume8_LockBox(p,a,b,c) (p)->LockBox(a,b,c)
#define IDirect3DVolume8_UnlockBox(p) (p)->UnlockBox()
#endif

/****************************************************************************
 * Flags for SetPrivateData method on all D3D8 interfaces
 *
 * The passed pointer is an IUnknown ptr. The SizeOfData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). Direct3D will call AddRef through this
 * pointer and Release when the private data is destroyed. The data will be
 * destroyed when another SetPrivateData with the same GUID is set, when
 * FreePrivateData is called, or when the D3D8 object is freed.
 ****************************************************************************/
#define D3DSPD_IUNKNOWN                         0x00000001L

/****************************************************************************
 *
 * Parameter for IDirect3D8 Enum and GetCaps8 functions to get the info for
 * the current mode only.
 *
 ****************************************************************************/

#define D3DCURRENT_DISPLAY_MODE                 0x00EFFFFFL

/****************************************************************************
 *
 * Flags for IDirect3D8::CreateDevice's BehaviorFlags
 *
 ****************************************************************************/

#define D3DCREATE_FPU_PRESERVE                  0x00000002L
#define D3DCREATE_MULTITHREADED                 0x00000004L

#define D3DCREATE_PUREDEVICE                    0x00000010L
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING     0x00000020L
#define D3DCREATE_HARDWARE_VERTEXPROCESSING     0x00000040L
#define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L


/****************************************************************************
 *
 * Parameter for IDirect3D8::CreateDevice's iAdapter
 *
 ****************************************************************************/

#define D3DADAPTER_DEFAULT                     0

/****************************************************************************
 *
 * Flags for IDirect3D8::EnumAdapters
 *
 ****************************************************************************/

#define D3DENUM_NO_WHQL_LEVEL                   0x00000002L

/****************************************************************************
 *
 * Maximum number of back-buffers supported in DX8
 *
 ****************************************************************************/

#define D3DPRESENT_BACK_BUFFERS_MAX             3L

/****************************************************************************
 *
 * Flags for IDirect3DDevice8::SetGammaRamp
 *
 ****************************************************************************/

#define D3DSGR_NO_CALIBRATION                  0x00000000L
#define D3DSGR_CALIBRATE                       0x00000001L

/****************************************************************************
 *
 * Flags for IDirect3DDevice8::SetCursorPosition
 *
 ****************************************************************************/

#define D3DCURSOR_IMMEDIATE_UPDATE             0x00000001L

/****************************************************************************
 *
 * Flags for DrawPrimitive/DrawIndexedPrimitive
 *   Also valid for Begin/BeginIndexed
 *   Also valid for VertexBuffer::CreateVertexBuffer
 ****************************************************************************/


/*
 *  DirectDraw error codes
 */
#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

/*
 * Direct3D Errors
 */
#define D3D_OK                              S_OK

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)
#define D3DERR_DRIVERINVALIDCALL                MAKE_D3DHRESULT(2157)

#ifdef __cplusplus
};
#endif

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\cxq_cust.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Sep 09 20:17:54 1997
 */
/* Compiler settings for cxq_cust.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cxq_cust_h__
#define __cxq_cust_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IH26XVideoEffects_FWD_DEFINED__
#define __IH26XVideoEffects_FWD_DEFINED__
typedef interface IH26XVideoEffects IH26XVideoEffects;
#endif 	/* __IH26XVideoEffects_FWD_DEFINED__ */


#ifndef __IH26XEncodeOptions_FWD_DEFINED__
#define __IH26XEncodeOptions_FWD_DEFINED__
typedef interface IH26XEncodeOptions IH26XEncodeOptions;
#endif 	/* __IH26XEncodeOptions_FWD_DEFINED__ */


#ifndef __IH26XSnapshot_FWD_DEFINED__
#define __IH26XSnapshot_FWD_DEFINED__
typedef interface IH26XSnapshot IH26XSnapshot;
#endif 	/* __IH26XSnapshot_FWD_DEFINED__ */


#ifndef __IH26XEncoderControl_FWD_DEFINED__
#define __IH26XEncoderControl_FWD_DEFINED__
typedef interface IH26XEncoderControl IH26XEncoderControl;
#endif 	/* __IH26XEncoderControl_FWD_DEFINED__ */


#ifndef __IH26XRTPControl_FWD_DEFINED__
#define __IH26XRTPControl_FWD_DEFINED__
typedef interface IH26XRTPControl IH26XRTPControl;
#endif 	/* __IH26XRTPControl_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IH26XVideoEffects_INTERFACE_DEFINED__
#define __IH26XVideoEffects_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IH26XVideoEffects
 * at Tue Sep 09 20:17:54 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 


// STRUCTURES
typedef /* [public][public][public][public][public][public] */ 
enum __MIDL_IH26XVideoEffects_0001
    {	H26X_VE_UNDEFINED	= 0,
	H26X_VE_BRIGHTNESS	= H26X_VE_UNDEFINED + 1,
	H26X_VE_CONTRAST	= H26X_VE_BRIGHTNESS + 1,
	H26X_VE_SATURATION	= H26X_VE_CONTRAST + 1,
	H26X_VE_TINT	= H26X_VE_SATURATION + 1,
	H26X_VE_MIRROR	= H26X_VE_TINT + 1,
	H26X_VE_ASPECT_CORRECT	= H26X_VE_MIRROR + 1
    }	H26X_VIDEO_EFFECT;

typedef /* [public] */ struct  __MIDL_IH26XVideoEffects_0002
    {
    int iBrightness;
    int iSaturation;
    int iContrast;
    int iMirror;
    int iAspectCorrect;
    }	VIDEO_EFFECT_VALUES;

typedef struct __MIDL_IH26XVideoEffects_0002 __RPC_FAR *PTR_VIDEO_EFFECT_VALUES;

// METHODS

EXTERN_C const IID IID_IH26XVideoEffects;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21555140-9C2B-11cf-90FA-00AA00A729EA")
    IH26XVideoEffects : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getFactoryDefault( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getFactoryLimits( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinLower,
            /* [out] */ int __RPC_FAR *pinUpper) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCurrent( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setCurrent( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [in] */ int inValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetCurrent( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XVideoEffectsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XVideoEffects __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XVideoEffects __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFactoryDefault )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinDefault);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFactoryLimits )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinLower,
            /* [out] */ int __RPC_FAR *pinUpper);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getCurrent )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setCurrent )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [in] */ int inValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *resetCurrent )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect);
        
        END_INTERFACE
    } IH26XVideoEffectsVtbl;

    interface IH26XVideoEffects
    {
        CONST_VTBL struct IH26XVideoEffectsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XVideoEffects_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XVideoEffects_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XVideoEffects_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XVideoEffects_getFactoryDefault(This,veVideoEffect,pinDefault)	\
    (This)->lpVtbl -> getFactoryDefault(This,veVideoEffect,pinDefault)

#define IH26XVideoEffects_getFactoryLimits(This,veVideoEffect,pinLower,pinUpper)	\
    (This)->lpVtbl -> getFactoryLimits(This,veVideoEffect,pinLower,pinUpper)

#define IH26XVideoEffects_getCurrent(This,veVideoEffect,pinValue)	\
    (This)->lpVtbl -> getCurrent(This,veVideoEffect,pinValue)

#define IH26XVideoEffects_setCurrent(This,veVideoEffect,inValue)	\
    (This)->lpVtbl -> setCurrent(This,veVideoEffect,inValue)

#define IH26XVideoEffects_resetCurrent(This,veVideoEffect)	\
    (This)->lpVtbl -> resetCurrent(This,veVideoEffect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XVideoEffects_getFactoryDefault_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
    /* [out] */ int __RPC_FAR *pinDefault);


void __RPC_STUB IH26XVideoEffects_getFactoryDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XVideoEffects_getFactoryLimits_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
    /* [out] */ int __RPC_FAR *pinLower,
    /* [out] */ int __RPC_FAR *pinUpper);


void __RPC_STUB IH26XVideoEffects_getFactoryLimits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XVideoEffects_getCurrent_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
    /* [out] */ int __RPC_FAR *pinValue);


void __RPC_STUB IH26XVideoEffects_getCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XVideoEffects_setCurrent_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
    /* [in] */ int inValue);


void __RPC_STUB IH26XVideoEffects_setCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XVideoEffects_resetCurrent_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect);


void __RPC_STUB IH26XVideoEffects_resetCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XVideoEffects_INTERFACE_DEFINED__ */


#ifndef __IH26XEncodeOptions_INTERFACE_DEFINED__
#define __IH26XEncodeOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IH26XEncodeOptions
 * at Tue Sep 09 20:17:54 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 


// STRUCTURES
typedef /* [public] */ struct  __MIDL_IH26XEncodeOptions_0001
    {
    int bExtendedMV;
    int bPBFrames;
    int bAdvPrediction;
    }	ENCODE_OPTIONS_VALUES;

typedef struct __MIDL_IH26XEncodeOptions_0001 __RPC_FAR *PTR_ENCODE_OPTIONS_VALUES;

// METHODS

EXTERN_C const IID IID_IH26XEncodeOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65698D40-282D-11d0-8800-444553540000")
    IH26XEncodeOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_EncodeOptions( 
            /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EncodeOptionsDefault( 
            /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_EncodeOptions( 
            /* [in] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XEncodeOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XEncodeOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XEncodeOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XEncodeOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EncodeOptions )( 
            IH26XEncodeOptions __RPC_FAR * This,
            /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EncodeOptionsDefault )( 
            IH26XEncodeOptions __RPC_FAR * This,
            /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *set_EncodeOptions )( 
            IH26XEncodeOptions __RPC_FAR * This,
            /* [in] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);
        
        END_INTERFACE
    } IH26XEncodeOptionsVtbl;

    interface IH26XEncodeOptions
    {
        CONST_VTBL struct IH26XEncodeOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XEncodeOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XEncodeOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XEncodeOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XEncodeOptions_get_EncodeOptions(This,pOptionValues)	\
    (This)->lpVtbl -> get_EncodeOptions(This,pOptionValues)

#define IH26XEncodeOptions_get_EncodeOptionsDefault(This,pOptionValues)	\
    (This)->lpVtbl -> get_EncodeOptionsDefault(This,pOptionValues)

#define IH26XEncodeOptions_set_EncodeOptions(This,pOptionValues)	\
    (This)->lpVtbl -> set_EncodeOptions(This,pOptionValues)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XEncodeOptions_get_EncodeOptions_Proxy( 
    IH26XEncodeOptions __RPC_FAR * This,
    /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);


void __RPC_STUB IH26XEncodeOptions_get_EncodeOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XEncodeOptions_get_EncodeOptionsDefault_Proxy( 
    IH26XEncodeOptions __RPC_FAR * This,
    /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);


void __RPC_STUB IH26XEncodeOptions_get_EncodeOptionsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XEncodeOptions_set_EncodeOptions_Proxy( 
    IH26XEncodeOptions __RPC_FAR * This,
    /* [in] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);


void __RPC_STUB IH26XEncodeOptions_set_EncodeOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XEncodeOptions_INTERFACE_DEFINED__ */


#ifndef __IH26XSnapshot_INTERFACE_DEFINED__
#define __IH26XSnapshot_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IH26XSnapshot
 * at Tue Sep 09 20:17:54 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 


#ifndef _WINGDI_
// STRUCTURES
typedef struct  __MIDL_IH26XSnapshot_0001
    {
    DWORD biSize;
    LONG biWidth;
    LONG biHeight;
    WORD biPlanes;
    WORD biBitCount;
    DWORD biCompression;
    DWORD biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    DWORD biClrUsed;
    DWORD biClrImportant;
    }	__RPC_FAR *LPBITMAPINFOHEADER;

#endif
// METHODS

EXTERN_C const IID IID_IH26XSnapshot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3CB194A0-10AA-11d0-8800-444553540000")
    IH26XSnapshot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getBitmapInfoHeader( 
            /* [out] */ LPBITMAPINFOHEADER lpBmi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSnapshot( 
            /* [in] */ LPBITMAPINFOHEADER lpBmi,
            /* [out] */ unsigned char __RPC_FAR *pvBuffer,
            /* [in] */ DWORD dwTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XSnapshotVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XSnapshot __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XSnapshot __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XSnapshot __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getBitmapInfoHeader )( 
            IH26XSnapshot __RPC_FAR * This,
            /* [out] */ LPBITMAPINFOHEADER lpBmi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getSnapshot )( 
            IH26XSnapshot __RPC_FAR * This,
            /* [in] */ LPBITMAPINFOHEADER lpBmi,
            /* [out] */ unsigned char __RPC_FAR *pvBuffer,
            /* [in] */ DWORD dwTimeout);
        
        END_INTERFACE
    } IH26XSnapshotVtbl;

    interface IH26XSnapshot
    {
        CONST_VTBL struct IH26XSnapshotVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XSnapshot_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XSnapshot_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XSnapshot_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XSnapshot_getBitmapInfoHeader(This,lpBmi)	\
    (This)->lpVtbl -> getBitmapInfoHeader(This,lpBmi)

#define IH26XSnapshot_getSnapshot(This,lpBmi,pvBuffer,dwTimeout)	\
    (This)->lpVtbl -> getSnapshot(This,lpBmi,pvBuffer,dwTimeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XSnapshot_getBitmapInfoHeader_Proxy( 
    IH26XSnapshot __RPC_FAR * This,
    /* [out] */ LPBITMAPINFOHEADER lpBmi);


void __RPC_STUB IH26XSnapshot_getBitmapInfoHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XSnapshot_getSnapshot_Proxy( 
    IH26XSnapshot __RPC_FAR * This,
    /* [in] */ LPBITMAPINFOHEADER lpBmi,
    /* [out] */ unsigned char __RPC_FAR *pvBuffer,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IH26XSnapshot_getSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XSnapshot_INTERFACE_DEFINED__ */


#ifndef __IH26XEncoderControl_INTERFACE_DEFINED__
#define __IH26XEncoderControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IH26XEncoderControl
 * at Tue Sep 09 20:17:54 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 


// STRUCTURES
typedef /* [public] */ struct  __MIDL_IH26XEncoderControl_0001
    {
    DWORD dwTargetFrameSize;
    BOOL bFrameSizeBRC;
    BOOL bSendKey;
    DWORD dwQuality;
    DWORD dwFrameRate;
    DWORD dwDataRate;
    DWORD dwScale;
    DWORD dwWidth;
    DWORD dwKeyFrameInterval;
    }	ENC_CMP_DATA;

typedef struct __MIDL_IH26XEncoderControl_0001 __RPC_FAR *PTR_ENC_CMP_DATA;

// METHODS

EXTERN_C const IID IID_IH26XEncoderControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9B78AA1-EA12-11cf-9FEC-00AA00A59F69")
    IH26XEncoderControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_EncodeCompression( 
            /* [out] */ PTR_ENC_CMP_DATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EncodeCompressionDefault( 
            /* [out] */ PTR_ENC_CMP_DATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_EncodeCompression( 
            /* [in] */ PTR_ENC_CMP_DATA pData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XEncoderControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XEncoderControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XEncoderControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XEncoderControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EncodeCompression )( 
            IH26XEncoderControl __RPC_FAR * This,
            /* [out] */ PTR_ENC_CMP_DATA pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EncodeCompressionDefault )( 
            IH26XEncoderControl __RPC_FAR * This,
            /* [out] */ PTR_ENC_CMP_DATA pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *set_EncodeCompression )( 
            IH26XEncoderControl __RPC_FAR * This,
            /* [in] */ PTR_ENC_CMP_DATA pData);
        
        END_INTERFACE
    } IH26XEncoderControlVtbl;

    interface IH26XEncoderControl
    {
        CONST_VTBL struct IH26XEncoderControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XEncoderControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XEncoderControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XEncoderControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XEncoderControl_get_EncodeCompression(This,pData)	\
    (This)->lpVtbl -> get_EncodeCompression(This,pData)

#define IH26XEncoderControl_get_EncodeCompressionDefault(This,pData)	\
    (This)->lpVtbl -> get_EncodeCompressionDefault(This,pData)

#define IH26XEncoderControl_set_EncodeCompression(This,pData)	\
    (This)->lpVtbl -> set_EncodeCompression(This,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XEncoderControl_get_EncodeCompression_Proxy( 
    IH26XEncoderControl __RPC_FAR * This,
    /* [out] */ PTR_ENC_CMP_DATA pData);


void __RPC_STUB IH26XEncoderControl_get_EncodeCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XEncoderControl_get_EncodeCompressionDefault_Proxy( 
    IH26XEncoderControl __RPC_FAR * This,
    /* [out] */ PTR_ENC_CMP_DATA pData);


void __RPC_STUB IH26XEncoderControl_get_EncodeCompressionDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XEncoderControl_set_EncodeCompression_Proxy( 
    IH26XEncoderControl __RPC_FAR * This,
    /* [in] */ PTR_ENC_CMP_DATA pData);


void __RPC_STUB IH26XEncoderControl_set_EncodeCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XEncoderControl_INTERFACE_DEFINED__ */


#ifndef __IH26XRTPControl_INTERFACE_DEFINED__
#define __IH26XRTPControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IH26XRTPControl
 * at Tue Sep 09 20:17:54 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 


// STRUCTURES
typedef /* [public] */ struct  __MIDL_IH26XRTPControl_0001
    {
    BOOL bRTPHeader;
    DWORD dwPacketSize;
    DWORD dwPacketLoss;
    }	ENC_RTP_DATA;

typedef struct __MIDL_IH26XRTPControl_0001 __RPC_FAR *PTR_ENC_RTP_DATA;

// METHODS

EXTERN_C const IID IID_IH26XRTPControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1FC3F2C0-2BFD-11d0-8800-444553540000")
    IH26XRTPControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_RTPCompression( 
            /* [out] */ PTR_ENC_RTP_DATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_RTPCompressionDefault( 
            /* [out] */ PTR_ENC_RTP_DATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_RTPCompression( 
            /* [in] */ PTR_ENC_RTP_DATA pData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XRTPControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XRTPControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XRTPControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XRTPControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RTPCompression )( 
            IH26XRTPControl __RPC_FAR * This,
            /* [out] */ PTR_ENC_RTP_DATA pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RTPCompressionDefault )( 
            IH26XRTPControl __RPC_FAR * This,
            /* [out] */ PTR_ENC_RTP_DATA pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *set_RTPCompression )( 
            IH26XRTPControl __RPC_FAR * This,
            /* [in] */ PTR_ENC_RTP_DATA pData);
        
        END_INTERFACE
    } IH26XRTPControlVtbl;

    interface IH26XRTPControl
    {
        CONST_VTBL struct IH26XRTPControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XRTPControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XRTPControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XRTPControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XRTPControl_get_RTPCompression(This,pData)	\
    (This)->lpVtbl -> get_RTPCompression(This,pData)

#define IH26XRTPControl_get_RTPCompressionDefault(This,pData)	\
    (This)->lpVtbl -> get_RTPCompressionDefault(This,pData)

#define IH26XRTPControl_set_RTPCompression(This,pData)	\
    (This)->lpVtbl -> set_RTPCompression(This,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XRTPControl_get_RTPCompression_Proxy( 
    IH26XRTPControl __RPC_FAR * This,
    /* [out] */ PTR_ENC_RTP_DATA pData);


void __RPC_STUB IH26XRTPControl_get_RTPCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XRTPControl_get_RTPCompressionDefault_Proxy( 
    IH26XRTPControl __RPC_FAR * This,
    /* [out] */ PTR_ENC_RTP_DATA pData);


void __RPC_STUB IH26XRTPControl_get_RTPCompressionDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XRTPControl_set_RTPCompression_Proxy( 
    IH26XRTPControl __RPC_FAR * This,
    /* [in] */ PTR_ENC_RTP_DATA pData);


void __RPC_STUB IH26XRTPControl_set_RTPCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XRTPControl_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3d8caps.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8caps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8CAPS_H
#define _D3D8CAPS_H

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#pragma pack(4)

typedef struct _D3DCAPS8
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT    AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture8's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture8's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture8's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture8's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture8's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth, MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   MaxPixelShaderValue;        // max value of pixel shader arithmetic component

} D3DCAPS8;

//
// BIT DEFINES FOR D3DCAPS8 DWORD MEMBERS
//

//
// Caps
//
#define D3DCAPS_READ_SCANLINE           0x00020000L

//
// Caps2
//
#define D3DCAPS2_NO2DDURING3DSCENE      0x00000002L
#define D3DCAPS2_FULLSCREENGAMMA        0x00020000L
#define D3DCAPS2_CANRENDERWINDOWED      0x00080000L
#define D3DCAPS2_CANCALIBRATEGAMMA      0x00100000L
#define D3DCAPS2_RESERVED               0x02000000L

//
// Caps3
//
#define D3DCAPS3_RESERVED               0x8000001fL

//
// PresentationIntervals
//
#define D3DPRESENT_INTERVAL_DEFAULT     0x00000000L
#define D3DPRESENT_INTERVAL_ONE         0x00000001L
#define D3DPRESENT_INTERVAL_TWO         0x00000002L
#define D3DPRESENT_INTERVAL_THREE       0x00000004L
#define D3DPRESENT_INTERVAL_FOUR        0x00000008L
#define D3DPRESENT_INTERVAL_IMMEDIATE   0x80000000L

//
// CursorCaps
//
// Driver supports HW color cursor in at least hi-res modes(height >=400)
#define D3DCURSORCAPS_COLOR             0x00000001L
// Driver supports HW cursor also in low-res modes(height < 400)
#define D3DCURSORCAPS_LOWRES            0x00000002L

//
// DevCaps
//
#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#define D3DDEVCAPS_DRAWPRIMITIVES2      0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX    0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT  0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL  0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION      0x00080000L /* Device has HW acceleration for rasterization */
#define D3DDEVCAPS_PUREDEVICE           0x00100000L /* Device supports D3DCREATE_PUREDEVICE */
#define D3DDEVCAPS_QUINTICRTPATCHES     0x00200000L /* Device supports quintic Beziers and BSplines */
#define D3DDEVCAPS_RTPATCHES            0x00400000L /* Device supports Rect and Tri patches */
#define D3DDEVCAPS_RTPATCHHANDLEZERO    0x00800000L /* Indicates that RT Patches may be drawn efficiently using handle 0 */
#define D3DDEVCAPS_NPATCHES             0x01000000L /* Device supports N-Patches */

//
// PrimitiveMiscCaps
//
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L
#define D3DPMISCCAPS_COLORWRITEENABLE   0x00000080L
#define D3DPMISCCAPS_CLIPPLANESCALEDPOINTS 0x00000100L /* Device correctly clips scaled points to clip planes */
#define D3DPMISCCAPS_CLIPTLVERTS        0x00000200L /* device will clip post-transformed vertex primitives */
#define D3DPMISCCAPS_TSSARGTEMP         0x00000400L /* device supports D3DTA_TEMP for temporary register */
#define D3DPMISCCAPS_BLENDOP            0x00000800L /* device supports D3DRS_BLENDOP */

//
// LineCaps
//
#define D3DLINECAPS_TEXTURE             0x00000001L
#define D3DLINECAPS_ZTEST               0x00000002L
#define D3DLINECAPS_BLEND               0x00000004L
#define D3DLINECAPS_ALPHACMP            0x00000008L
#define D3DLINECAPS_FOG                 0x00000010L

//
// RasterCaps
//
#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_ANTIALIASEDGES   0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS    0x00002000L
#define D3DPRASTERCAPS_ZBIAS            0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR   0x00008000L
#define D3DPRASTERCAPS_FOGRANGE         0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY       0x00020000L
#define D3DPRASTERCAPS_WBUFFER          0x00040000L
#define D3DPRASTERCAPS_WFOG             0x00100000L
#define D3DPRASTERCAPS_ZFOG             0x00200000L
#define D3DPRASTERCAPS_COLORPERSPECTIVE 0x00400000L /* Device iterates colors perspective correct */
#define D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  0x00800000L

//
// ZCmpCaps, AlphaCmpCaps
//
#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

//
// SourceBlendCaps, DestBlendCaps
//
#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

//
// ShadeCaps
//
#define D3DPSHADECAPS_COLORGOURAUDRGB       0x00000008L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB    0x00000200L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND     0x00004000L
#define D3DPSHADECAPS_FOGGOURAUD            0x00080000L

//
// TextureCaps
//
#define D3DPTEXTURECAPS_PERSPECTIVE         0x00000001L /* Perspective-correct texturing is supported */
#define D3DPTEXTURECAPS_POW2                0x00000002L /* Power-of-2 texture dimensions are required - applies to non-Cube/Volume textures only. */
#define D3DPTEXTURECAPS_ALPHA               0x00000004L /* Alpha in texture pixels is supported */
#define D3DPTEXTURECAPS_SQUAREONLY          0x00000020L /* Only square textures are supported */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L /* Texture indices are not scaled by the texture size prior to interpolation */
#define D3DPTEXTURECAPS_ALPHAPALETTE        0x00000080L /* Device can draw alpha from texture palettes */
// Device can use non-POW2 textures if:
//  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
//  2) D3DRS_WRAP(N) is zero for this texture's coordinates
//  3) mip mapping is not enabled (use magnification filter only)
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L
#define D3DPTEXTURECAPS_PROJECTED           0x00000400L /* Device can do D3DTTFF_PROJECTED */
#define D3DPTEXTURECAPS_CUBEMAP             0x00000800L /* Device can do cubemap textures */
#define D3DPTEXTURECAPS_VOLUMEMAP           0x00002000L /* Device can do volume textures */
#define D3DPTEXTURECAPS_MIPMAP              0x00004000L /* Device can do mipmapped textures */
#define D3DPTEXTURECAPS_MIPVOLUMEMAP        0x00008000L /* Device can do mipmapped volume textures */
#define D3DPTEXTURECAPS_MIPCUBEMAP          0x00010000L /* Device can do mipmapped cube maps */
#define D3DPTEXTURECAPS_CUBEMAP_POW2        0x00020000L /* Device requires that cubemaps be power-of-2 dimension */
#define D3DPTEXTURECAPS_VOLUMEMAP_POW2      0x00040000L /* Device requires that volume maps be power-of-2 dimension */

//
// TextureFilterCaps
//
#define D3DPTFILTERCAPS_MINFPOINT           0x00000100L /* Min Filter */
#define D3DPTFILTERCAPS_MINFLINEAR          0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC     0x00000400L
#define D3DPTFILTERCAPS_MIPFPOINT           0x00010000L /* Mip Filter */
#define D3DPTFILTERCAPS_MIPFLINEAR          0x00020000L
#define D3DPTFILTERCAPS_MAGFPOINT           0x01000000L /* Mag Filter */
#define D3DPTFILTERCAPS_MAGFLINEAR          0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC     0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC      0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC   0x10000000L

//
// TextureAddressCaps
//
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#define D3DPTADDRESSCAPS_MIRRORONCE     0x00000020L

//
// StencilCaps
//
#define D3DSTENCILCAPS_KEEP             0x00000001L
#define D3DSTENCILCAPS_ZERO             0x00000002L
#define D3DSTENCILCAPS_REPLACE          0x00000004L
#define D3DSTENCILCAPS_INCRSAT          0x00000008L
#define D3DSTENCILCAPS_DECRSAT          0x00000010L
#define D3DSTENCILCAPS_INVERT           0x00000020L
#define D3DSTENCILCAPS_INCR             0x00000040L
#define D3DSTENCILCAPS_DECR             0x00000080L

//
// TextureOpCaps
//
#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L
#define D3DTEXOPCAPS_MULTIPLYADD                0x01000000L
#define D3DTEXOPCAPS_LERP                       0x02000000L

//
// FVFCaps
//
#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */
#define D3DFVFCAPS_PSIZE                0x00100000L /* Device can receive point size */

//
// VertexProcessingCaps
//
#define D3DVTXPCAPS_TEXGEN              0x00000001L /* device can do texgen */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L /* device can do DX7-level colormaterialsource ops */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L /* device can do directional lights */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L /* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L /* device can do local viewer */
#define D3DVTXPCAPS_TWEENING            0x00000040L /* device can do vertex tweening */
#define D3DVTXPCAPS_NO_VSDT_UBYTE4      0x00000080L /* device does not support D3DVSDT_UBYTE4 */

#pragma pack()

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8CAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3drm.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRM_H__
#define __D3DRM_H__

#include "ddraw.h"

#ifdef __cplusplus
struct IDirect3DRM;
#endif

typedef struct IDirect3DRM *LPDIRECT3DRM;

#include "d3drmobj.h"

#ifdef __cplusplus
extern "C" {
#endif


DEFINE_GUID(IID_IDirect3DRM,	0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRM2,	0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x4516ec83, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
WIN_TYPES(IDirect3DRM, DIRECT3DRM);
WIN_TYPES(IDirect3DRM2, DIRECT3DRM2);
WIN_TYPES(IDirect3DRM3, DIRECT3DRM3);

/*
 * Direct3DRM Object Class (for CoCreateInstance())
 */
DEFINE_GUID(CLSID_CDirect3DRM,  0x4516ec41, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);


/* Create a Direct3DRM API */
STDAPI Direct3DRMCreate(LPDIRECT3DRM FAR *lplpDirect3DRM);

#undef INTERFACE
#define INTERFACE IDirect3DRM

DECLARE_INTERFACE_(IDirect3DRM, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev,
	LPDIRECT3DRMDEVICE *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HRSRC rs, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
	LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM2

DECLARE_INTERFACE_(IDirect3DRM2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME2 *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER2 *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE2 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE2 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
	LPDIRECT3DRMDEVICE2 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE2 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE2 *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE2 *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
	LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM3

DECLARE_INTERFACE_(IDirect3DRM3, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME3, LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3 *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION2 *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET2 *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE3 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags, LPDIRECT3DRMDEVICE3 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
	LPDIRECT3DRMDEVICE3 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE3 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE3 *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPUNKNOWN, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMSHADOW2 *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE3, LPDIRECT3DRMFRAME3, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT2 *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME3,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE3 *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURE3CALLBACK, LPVOID,
	LPDIRECT3DRMFRAME3
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;

    /* Used with IDirect3DRMObject2 */
    STDMETHOD(RegisterClient)   (THIS_ REFGUID rguid, LPDWORD lpdwID) PURE;
    STDMETHOD(UnregisterClient) (THIS_ REFGUID rguid) PURE;

    STDMETHOD(CreateClippedVisual) (THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMCLIPPEDVISUAL *) PURE;
    STDMETHOD(SetOptions) (THIS_ DWORD);
    STDMETHOD(GetOptions) (THIS_ LPDWORD);
};

#define D3DRM_OK			DD_OK
#define D3DRMERR_BADOBJECT		MAKE_DDHRESULT(781)
#define D3DRMERR_BADTYPE		MAKE_DDHRESULT(782)
#define D3DRMERR_BADALLOC		MAKE_DDHRESULT(783)
#define D3DRMERR_FACEUSED		MAKE_DDHRESULT(784)
#define D3DRMERR_NOTFOUND		MAKE_DDHRESULT(785)
#define D3DRMERR_NOTDONEYET		MAKE_DDHRESULT(786)
#define D3DRMERR_FILENOTFOUND		MAKE_DDHRESULT(787)
#define D3DRMERR_BADFILE		MAKE_DDHRESULT(788)
#define D3DRMERR_BADDEVICE		MAKE_DDHRESULT(789)
#define D3DRMERR_BADVALUE		MAKE_DDHRESULT(790)
#define D3DRMERR_BADMAJORVERSION	MAKE_DDHRESULT(791)
#define D3DRMERR_BADMINORVERSION	MAKE_DDHRESULT(792)
#define D3DRMERR_UNABLETOEXECUTE	MAKE_DDHRESULT(793)
#define D3DRMERR_LIBRARYNOTFOUND        MAKE_DDHRESULT(794)
#define D3DRMERR_INVALIDLIBRARY         MAKE_DDHRESULT(795)
#define D3DRMERR_PENDING                MAKE_DDHRESULT(796)
#define D3DRMERR_NOTENOUGHDATA          MAKE_DDHRESULT(797)
#define D3DRMERR_REQUESTTOOLARGE        MAKE_DDHRESULT(798)
#define D3DRMERR_REQUESTTOOSMALL        MAKE_DDHRESULT(799)
#define D3DRMERR_CONNECTIONLOST         MAKE_DDHRESULT(800)
#define D3DRMERR_LOADABORTED            MAKE_DDHRESULT(801)
#define D3DRMERR_NOINTERNET             MAKE_DDHRESULT(802)
#define D3DRMERR_BADCACHEFILE           MAKE_DDHRESULT(803)
#define D3DRMERR_BOXNOTSET		MAKE_DDHRESULT(804)
#define D3DRMERR_BADPMDATA              MAKE_DDHRESULT(805)
#define D3DRMERR_CLIENTNOTREGISTERED    MAKE_DDHRESULT(806)
#define D3DRMERR_NOTCREATEDFROMDDS	MAKE_DDHRESULT(807)
#define D3DRMERR_NOSUCHKEY              MAKE_DDHRESULT(808)
#define D3DRMERR_INCOMPATABLEKEY        MAKE_DDHRESULT(809)
#define D3DRMERR_ELEMENTINUSE		MAKE_DDHRESULT(810)
#define D3DRMERR_TEXTUREFORMATNOTFOUND  MAKE_DDHRESULT(811)
#define D3DRMERR_NOTAGGREGATED          MAKE_DDHRESULT(812)

#ifdef __cplusplus
};
#endif

#endif /* _D3DRMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3drmdef.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMDEFS_H__
#define __D3DRMDEFS_H__

#include <stddef.h>
#include "d3dtypes.h"

#ifdef WIN32
#define D3DRMAPI  __stdcall
#else
#define D3DRMAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef struct _D3DRMVECTOR4D
{   D3DVALUE x, y, z, w;
} D3DRMVECTOR4D, *LPD3DRMVECTOR4D;

typedef D3DVALUE D3DRMMATRIX4D[4][4];

typedef struct _D3DRMQUATERNION
{   D3DVALUE s;
    D3DVECTOR v;
} D3DRMQUATERNION, *LPD3DRMQUATERNION;

typedef struct _D3DRMRAY
{   D3DVECTOR dvDir;
    D3DVECTOR dvPos;
} D3DRMRAY, *LPD3DRMRAY;

typedef struct _D3DRMBOX
{   D3DVECTOR min, max;
} D3DRMBOX, *LPD3DRMBOX;

typedef void (*D3DRMWRAPCALLBACK)
    (LPD3DVECTOR, int* u, int* v, LPD3DVECTOR a, LPD3DVECTOR b, LPVOID);

typedef enum _D3DRMLIGHTTYPE
{   D3DRMLIGHT_AMBIENT,
    D3DRMLIGHT_POINT,
    D3DRMLIGHT_SPOT,
    D3DRMLIGHT_DIRECTIONAL,
    D3DRMLIGHT_PARALLELPOINT
} D3DRMLIGHTTYPE, *LPD3DRMLIGHTTYPE;

typedef enum _D3DRMSHADEMODE {
    D3DRMSHADE_FLAT	= 0,
    D3DRMSHADE_GOURAUD	= 1,
    D3DRMSHADE_PHONG	= 2,

    D3DRMSHADE_MASK	= 7,
    D3DRMSHADE_MAX	= 8
} D3DRMSHADEMODE, *LPD3DRMSHADEMODE;

typedef enum _D3DRMLIGHTMODE {
    D3DRMLIGHT_OFF	= 0 * D3DRMSHADE_MAX,
    D3DRMLIGHT_ON	= 1 * D3DRMSHADE_MAX,

    D3DRMLIGHT_MASK	= 7 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MAX	= 8 * D3DRMSHADE_MAX
} D3DRMLIGHTMODE, *LPD3DRMLIGHTMODE;

typedef enum _D3DRMFILLMODE {
    D3DRMFILL_POINTS	= 0 * D3DRMLIGHT_MAX,
    D3DRMFILL_WIREFRAME	= 1 * D3DRMLIGHT_MAX,
    D3DRMFILL_SOLID	= 2 * D3DRMLIGHT_MAX,

    D3DRMFILL_MASK	= 7 * D3DRMLIGHT_MAX,
    D3DRMFILL_MAX	= 8 * D3DRMLIGHT_MAX
} D3DRMFILLMODE, *LPD3DRMFILLMODE;

typedef DWORD D3DRMRENDERQUALITY, *LPD3DRMRENDERQUALITY;

#define D3DRMRENDER_WIREFRAME	(D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_WIREFRAME)
#define D3DRMRENDER_UNLITFLAT	(D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_SOLID)
#define D3DRMRENDER_FLAT	(D3DRMSHADE_FLAT+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_GOURAUD	(D3DRMSHADE_GOURAUD+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_PHONG	(D3DRMSHADE_PHONG+D3DRMLIGHT_ON+D3DRMFILL_SOLID)

#define D3DRMRENDERMODE_BLENDEDTRANSPARENCY	1
#define D3DRMRENDERMODE_SORTEDTRANSPARENCY	2
#define D3DRMRENDERMODE_LIGHTINMODELSPACE	8
#define D3DRMRENDERMODE_VIEWDEPENDENTSPECULAR	16
#define D3DRMRENDERMODE_DISABLESORTEDALPHAZWRITE 32

typedef enum _D3DRMTEXTUREQUALITY
{   D3DRMTEXTURE_NEAREST,		/* choose nearest texel */
    D3DRMTEXTURE_LINEAR,		/* interpolate 4 texels */
    D3DRMTEXTURE_MIPNEAREST,		/* nearest texel in nearest mipmap  */
    D3DRMTEXTURE_MIPLINEAR,		/* interpolate 2 texels from 2 mipmaps */
    D3DRMTEXTURE_LINEARMIPNEAREST,	/* interpolate 4 texels in nearest mipmap */
    D3DRMTEXTURE_LINEARMIPLINEAR	/* interpolate 8 texels from 2 mipmaps */
} D3DRMTEXTUREQUALITY, *LPD3DRMTEXTUREQUALITY;

/*
 * Texture flags
 */
#define D3DRMTEXTURE_FORCERESIDENT	    0x00000001 /* texture should be kept in video memory */
#define D3DRMTEXTURE_STATIC		    0x00000002 /* texture will not change */
#define D3DRMTEXTURE_DOWNSAMPLEPOINT	    0x00000004 /* point filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEBILINEAR	    0x00000008 /* bilinear filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEREDUCEDEPTH  0x00000010 /* reduce bit depth when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLENONE	    0x00000020 /* texture should never be downsampled */
#define D3DRMTEXTURE_CHANGEDPIXELS	    0x00000040 /* pixels have changed */
#define D3DRMTEXTURE_CHANGEDPALETTE	    0x00000080 /* palette has changed */
#define D3DRMTEXTURE_INVALIDATEONLY	    0x00000100 /* dirty regions are invalid */

/*
 * Shadow flags
 */
#define D3DRMSHADOW_TRUEALPHA		    0x00000001 /* shadow should render without artifacts when true alpha is on */

typedef enum _D3DRMCOMBINETYPE
{   D3DRMCOMBINE_REPLACE,
    D3DRMCOMBINE_BEFORE,
    D3DRMCOMBINE_AFTER
} D3DRMCOMBINETYPE, *LPD3DRMCOMBINETYPE;

typedef D3DCOLORMODEL D3DRMCOLORMODEL, *LPD3DRMCOLORMODEL;

typedef enum _D3DRMPALETTEFLAGS
{   D3DRMPALETTE_FREE,			/* renderer may use this entry freely */
    D3DRMPALETTE_READONLY,		/* fixed but may be used by renderer */
    D3DRMPALETTE_RESERVED		/* may not be used by renderer */
} D3DRMPALETTEFLAGS, *LPD3DRMPALETTEFLAGS;

typedef struct _D3DRMPALETTEENTRY
{   unsigned char red;		/* 0 .. 255 */
    unsigned char green;	/* 0 .. 255 */
    unsigned char blue;		/* 0 .. 255 */
    unsigned char flags;	/* one of D3DRMPALETTEFLAGS */
} D3DRMPALETTEENTRY, *LPD3DRMPALETTEENTRY;

typedef struct _D3DRMIMAGE
{   int width, height;		/* width and height in pixels */
    int aspectx, aspecty;	/* aspect ratio for non-square pixels */
    int depth;			/* bits per pixel */
    int rgb;			/* if false, pixels are indices into a
				   palette otherwise, pixels encode
				   RGB values. */
    int bytes_per_line;		/* number of bytes of memory for a
				   scanline. This must be a multiple
				   of 4. */
    void* buffer1;		/* memory to render into (first buffer). */
    void* buffer2;		/* second rendering buffer for double
				   buffering, set to NULL for single
				   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;	/* if rgb is true, these are masks for
				   the red, green and blue parts of a
				   pixel.  Otherwise, these are masks
				   for the significant bits of the
				   red, green and blue elements in the
				   palette.  For instance, most SVGA
				   displays use 64 intensities of red,
				   green and blue, so the masks should
				   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    D3DRMPALETTEENTRY* palette;	/* description of the palette (only if
				   rgb is false).  Must be (1<<depth)
				   elements. */
} D3DRMIMAGE, *LPD3DRMIMAGE;

typedef enum _D3DRMWRAPTYPE
{   D3DRMWRAP_FLAT,
    D3DRMWRAP_CYLINDER,
    D3DRMWRAP_SPHERE,
    D3DRMWRAP_CHROME,
    D3DRMWRAP_SHEET,
    D3DRMWRAP_BOX
} D3DRMWRAPTYPE, *LPD3DRMWRAPTYPE;

#define D3DRMWIREFRAME_CULL		1 /* cull backfaces */
#define D3DRMWIREFRAME_HIDDENLINE	2 /* lines are obscured by closer objects */

/*
 * Do not use righthanded perspective in Viewport2::SetProjection().
 * Set up righthanded mode by using IDirect3DRM3::SetOptions().
 */
typedef enum _D3DRMPROJECTIONTYPE
{   D3DRMPROJECT_PERSPECTIVE,
    D3DRMPROJECT_ORTHOGRAPHIC,
    D3DRMPROJECT_RIGHTHANDPERSPECTIVE, /* Only valid pre-DX6 */
    D3DRMPROJECT_RIGHTHANDORTHOGRAPHIC /* Only valid pre-DX6 */
} D3DRMPROJECTIONTYPE, *LPD3DRMPROJECTIONTYPE;

#define D3DRMOPTIONS_LEFTHANDED  0x00000001L /* Default */
#define D3DRMOPTIONS_RIGHTHANDED 0x00000002L

typedef enum _D3DRMXOFFORMAT
{   D3DRMXOF_BINARY,
    D3DRMXOF_COMPRESSED,
    D3DRMXOF_TEXT
} D3DRMXOFFORMAT, *LPD3DRMXOFFORMAT;

typedef DWORD D3DRMSAVEOPTIONS;
#define D3DRMXOFSAVE_NORMALS 1
#define D3DRMXOFSAVE_TEXTURECOORDINATES 2
#define D3DRMXOFSAVE_MATERIALS 4
#define D3DRMXOFSAVE_TEXTURENAMES 8
#define D3DRMXOFSAVE_ALL 15
#define D3DRMXOFSAVE_TEMPLATES 16
#define D3DRMXOFSAVE_TEXTURETOPOLOGY 32

typedef enum _D3DRMCOLORSOURCE
{   D3DRMCOLOR_FROMFACE,
    D3DRMCOLOR_FROMVERTEX
} D3DRMCOLORSOURCE, *LPD3DRMCOLORSOURCE;

typedef enum _D3DRMFRAMECONSTRAINT
{   D3DRMCONSTRAIN_Z,		/* use only X and Y rotations */
    D3DRMCONSTRAIN_Y,		/* use only X and Z rotations */
    D3DRMCONSTRAIN_X		/* use only Y and Z rotations */
} D3DRMFRAMECONSTRAINT, *LPD3DRMFRAMECONSTRAINT;

typedef enum _D3DRMMATERIALMODE
{   D3DRMMATERIAL_FROMMESH,
    D3DRMMATERIAL_FROMPARENT,
    D3DRMMATERIAL_FROMFRAME
} D3DRMMATERIALMODE, *LPD3DRMMATERIALMODE;

typedef enum _D3DRMFOGMODE
{   D3DRMFOG_LINEAR,		/* linear between start and end */
    D3DRMFOG_EXPONENTIAL,	/* density * exp(-distance) */
    D3DRMFOG_EXPONENTIALSQUARED	/* density * exp(-distance*distance) */
} D3DRMFOGMODE, *LPD3DRMFOGMODE;

typedef enum _D3DRMZBUFFERMODE {
    D3DRMZBUFFER_FROMPARENT,	/* default */
    D3DRMZBUFFER_ENABLE,	/* enable zbuffering */
    D3DRMZBUFFER_DISABLE	/* disable zbuffering */
} D3DRMZBUFFERMODE, *LPD3DRMZBUFFERMODE;

typedef enum _D3DRMSORTMODE {
    D3DRMSORT_FROMPARENT,	/* default */
    D3DRMSORT_NONE,		/* don't sort child frames */
    D3DRMSORT_FRONTTOBACK,	/* sort child frames front-to-back */
    D3DRMSORT_BACKTOFRONT	/* sort child frames back-to-front */
} D3DRMSORTMODE, *LPD3DRMSORTMODE;

typedef struct _D3DRMMATERIALOVERRIDE
{
    DWORD         dwSize;	/* Size of this structure */
    DWORD         dwFlags;	/* Indicate which fields are valid */
    D3DCOLORVALUE dcDiffuse;	/* RGBA */
    D3DCOLORVALUE dcAmbient;	/* RGB */
    D3DCOLORVALUE dcEmissive;	/* RGB */
    D3DCOLORVALUE dcSpecular;	/* RGB */
    D3DVALUE      dvPower;
    LPUNKNOWN     lpD3DRMTex;
} D3DRMMATERIALOVERRIDE, *LPD3DRMMATERIALOVERRIDE;

#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY     0x00000001L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY       0x00000002L
#define D3DRMMATERIALOVERRIDE_DIFFUSE               0x00000003L
#define D3DRMMATERIALOVERRIDE_AMBIENT               0x00000004L
#define D3DRMMATERIALOVERRIDE_EMISSIVE              0x00000008L
#define D3DRMMATERIALOVERRIDE_SPECULAR              0x00000010L
#define D3DRMMATERIALOVERRIDE_POWER                 0x00000020L
#define D3DRMMATERIALOVERRIDE_TEXTURE               0x00000040L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAMULTIPLY 0x00000080L
#define D3DRMMATERIALOVERRIDE_ALL                   0x000000FFL

#define D3DRMFPTF_ALPHA                           0x00000001L
#define D3DRMFPTF_NOALPHA                         0x00000002L
#define D3DRMFPTF_PALETTIZED                      0x00000004L
#define D3DRMFPTF_NOTPALETTIZED                   0x00000008L

#define D3DRMSTATECHANGE_UPDATEONLY		  0x000000001L
#define D3DRMSTATECHANGE_VOLATILE		  0x000000002L
#define D3DRMSTATECHANGE_NONVOLATILE		  0x000000004L
#define D3DRMSTATECHANGE_RENDER			  0x000000020L
#define D3DRMSTATECHANGE_LIGHT			  0x000000040L

/*
 * Values for flags in RM3::CreateDeviceFromSurface
 */
#define D3DRMDEVICE_NOZBUFFER           0x00000001L

/*
 * Values for flags in Object2::SetClientData
 */
#define D3DRMCLIENTDATA_NONE            0x00000001L
#define D3DRMCLIENTDATA_LOCALFREE       0x00000002L
#define D3DRMCLIENTDATA_IUNKNOWN        0x00000004L

/*
 * Values for flags in Frame2::AddMoveCallback.
 */
#define D3DRMCALLBACK_PREORDER		0
#define D3DRMCALLBACK_POSTORDER		1

/*
 * Values for flags in MeshBuilder2::RayPick.
 */
#define D3DRMRAYPICK_ONLYBOUNDINGBOXES		1
#define D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES	2
#define D3DRMRAYPICK_INTERPOLATEUV		4
#define D3DRMRAYPICK_INTERPOLATECOLOR		8
#define D3DRMRAYPICK_INTERPOLATENORMAL		0x10	

/*
 * Values for flags in MeshBuilder3::AddFacesIndexed.
 */
#define D3DRMADDFACES_VERTICESONLY		1

/*
 * Values for flags in MeshBuilder2::GenerateNormals.
 */
#define D3DRMGENERATENORMALS_PRECOMPACT		1
#define D3DRMGENERATENORMALS_USECREASEANGLE	2

/*
 * Values for MeshBuilder3::GetParentMesh
 */
#define D3DRMMESHBUILDER_DIRECTPARENT		1
#define D3DRMMESHBUILDER_ROOTMESH		2

/*
 * Flags for MeshBuilder3::Enable
 */
#define D3DRMMESHBUILDER_RENDERENABLE	0x00000001L
#define D3DRMMESHBUILDER_PICKENABLE     0x00000002L

/*
 * Flags for MeshBuilder3::AddMeshBuilder
 */
#define D3DRMADDMESHBUILDER_DONTCOPYAPPDATA	1
#define D3DRMADDMESHBUILDER_FLATTENSUBMESHES	2
#define D3DRMADDMESHBUILDER_NOSUBMESHES		4

/*
 * Flags for Object2::GetAge when used with MeshBuilders
 */
#define D3DRMMESHBUILDERAGE_GEOMETRY    0x00000001L
#define D3DRMMESHBUILDERAGE_MATERIALS   0x00000002L
#define D3DRMMESHBUILDERAGE_TEXTURES    0x00000004L

/*
 * Format flags for MeshBuilder3::AddTriangles.
 */
#define D3DRMFVF_TYPE                   0x00000001L
#define D3DRMFVF_NORMAL                 0x00000002L
#define D3DRMFVF_COLOR                  0x00000004L
#define D3DRMFVF_TEXTURECOORDS          0x00000008L

#define D3DRMVERTEX_STRIP               0x00000001L
#define D3DRMVERTEX_FAN                 0x00000002L
#define D3DRMVERTEX_LIST                0x00000004L

/*
 * Values for flags in Viewport2::Clear2
 */
#define D3DRMCLEAR_TARGET               0x00000001L
#define D3DRMCLEAR_ZBUFFER              0x00000002L
#define D3DRMCLEAR_DIRTYRECTS           0x00000004L
#define D3DRMCLEAR_ALL                  (D3DRMCLEAR_TARGET | \
					 D3DRMCLEAR_ZBUFFER | \
					 D3DRMCLEAR_DIRTYRECTS)

/*
 * Values for flags in Frame3::SetSceneFogMethod
 */
#define D3DRMFOGMETHOD_VERTEX          0x00000001L
#define D3DRMFOGMETHOD_TABLE           0x00000002L
#define D3DRMFOGMETHOD_ANY             0x00000004L

/*
 * Values for flags in Frame3::SetTraversalOptions
 */
#define D3DRMFRAME_RENDERENABLE        0x00000001L
#define D3DRMFRAME_PICKENABLE          0x00000002L

typedef DWORD D3DRMANIMATIONOPTIONS;
#define D3DRMANIMATION_OPEN 0x01L
#define D3DRMANIMATION_CLOSED 0x02L
#define D3DRMANIMATION_LINEARPOSITION 0x04L
#define D3DRMANIMATION_SPLINEPOSITION 0x08L
#define D3DRMANIMATION_SCALEANDROTATION 0x00000010L
#define D3DRMANIMATION_POSITION 0x00000020L

typedef DWORD D3DRMINTERPOLATIONOPTIONS;
#define D3DRMINTERPOLATION_OPEN 0x01L
#define D3DRMINTERPOLATION_CLOSED 0x02L
#define D3DRMINTERPOLATION_NEAREST 0x0100L
#define D3DRMINTERPOLATION_LINEAR 0x04L
#define D3DRMINTERPOLATION_SPLINE 0x08L
#define D3DRMINTERPOLATION_VERTEXCOLOR 0x40L
#define D3DRMINTERPOLATION_SLERPNORMALS 0x80L

typedef DWORD D3DRMLOADOPTIONS;

#define D3DRMLOAD_FROMFILE  0x00L
#define D3DRMLOAD_FROMRESOURCE 0x01L
#define D3DRMLOAD_FROMMEMORY 0x02L
#define D3DRMLOAD_FROMSTREAM 0x04L
#define D3DRMLOAD_FROMURL 0x08L

#define D3DRMLOAD_BYNAME 0x10L
#define D3DRMLOAD_BYPOSITION 0x20L
#define D3DRMLOAD_BYGUID 0x40L
#define D3DRMLOAD_FIRST 0x80L

#define D3DRMLOAD_INSTANCEBYREFERENCE 0x100L
#define D3DRMLOAD_INSTANCEBYCOPYING 0x200L

#define D3DRMLOAD_ASYNCHRONOUS 0x400L

typedef struct _D3DRMLOADRESOURCE {
  HMODULE hModule;
  LPCTSTR lpName;
  LPCTSTR lpType;
} D3DRMLOADRESOURCE, *LPD3DRMLOADRESOURCE;

typedef struct _D3DRMLOADMEMORY {
  LPVOID lpMemory;
  DWORD dSize;
} D3DRMLOADMEMORY, *LPD3DRMLOADMEMORY;

#define D3DRMPMESHSTATUS_VALID 0x01L
#define D3DRMPMESHSTATUS_INTERRUPTED 0x02L
#define D3DRMPMESHSTATUS_BASEMESHCOMPLETE 0x04L
#define D3DRMPMESHSTATUS_COMPLETE 0x08L
#define D3DRMPMESHSTATUS_RENDERABLE 0x10L

#define D3DRMPMESHEVENT_BASEMESH 0x01L
#define D3DRMPMESHEVENT_COMPLETE 0x02L

typedef struct _D3DRMPMESHLOADSTATUS {
  DWORD dwSize;            // Size of this structure
  DWORD dwPMeshSize;       // Total Size (bytes)
  DWORD dwBaseMeshSize;    // Total Size of the Base Mesh
  DWORD dwBytesLoaded;     // Total bytes loaded
  DWORD dwVerticesLoaded;  // Number of vertices loaded
  DWORD dwFacesLoaded;     // Number of faces loaded
  HRESULT dwLoadResult;    // Result of the load operation
  DWORD dwFlags;
} D3DRMPMESHLOADSTATUS, *LPD3DRMPMESHLOADSTATUS;

typedef enum _D3DRMUSERVISUALREASON {
    D3DRMUSERVISUAL_CANSEE,
    D3DRMUSERVISUAL_RENDER
} D3DRMUSERVISUALREASON, *LPD3DRMUSERVISUALREASON;


typedef struct _D3DRMANIMATIONKEY 
{
    DWORD dwSize;
    DWORD dwKeyType;
    D3DVALUE dvTime;
    DWORD dwID;
#if (!defined __cplusplus) || (!defined D3D_OVERLOADS)
    union 
    {
	D3DRMQUATERNION dqRotateKey;
	D3DVECTOR dvScaleKey;
	D3DVECTOR dvPositionKey;
    };
#else
    /*
     * We do this as D3D_OVERLOADS defines constructors for D3DVECTOR,
     * this can then not be used in a union.  Use the inlines provided
     * to extract and set the required component.
     */
    D3DVALUE dvK[4];
#endif
} D3DRMANIMATIONKEY;
typedef D3DRMANIMATIONKEY *LPD3DRMANIMATIONKEY;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
inline VOID
D3DRMAnimationGetRotateKey(const D3DRMANIMATIONKEY& rmKey,
			   D3DRMQUATERNION& rmQuat)
{
    rmQuat.s = rmKey.dvK[0];
    rmQuat.v = D3DVECTOR(rmKey.dvK[1], rmKey.dvK[2], rmKey.dvK[3]);
}

inline VOID
D3DRMAnimationGetScaleKey(const D3DRMANIMATIONKEY& rmKey,
			  D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}

inline VOID
D3DRMAnimationGetPositionKey(const D3DRMANIMATIONKEY& rmKey,
			     D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}
inline VOID
D3DRMAnimationSetRotateKey(D3DRMANIMATIONKEY& rmKey,
			   const D3DRMQUATERNION& rmQuat)
{
    rmKey.dvK[0] = rmQuat.s;
    rmKey.dvK[1] = rmQuat.v.x;
    rmKey.dvK[2] = rmQuat.v.y;
    rmKey.dvK[3] = rmQuat.v.z;
}

inline VOID
D3DRMAnimationSetScaleKey(D3DRMANIMATIONKEY& rmKey,
			  const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}

inline VOID
D3DRMAnimationSetPositionKey(D3DRMANIMATIONKEY& rmKey,
			     const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}
#endif

#define D3DRMANIMATION_ROTATEKEY 0x01
#define D3DRMANIMATION_SCALEKEY 0x02
#define D3DRMANIMATION_POSITIONKEY 0x03


typedef DWORD D3DRMMAPPING, D3DRMMAPPINGFLAG, *LPD3DRMMAPPING;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPU = 1;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPV = 2;
static const D3DRMMAPPINGFLAG D3DRMMAP_PERSPCORRECT = 4;

typedef struct _D3DRMVERTEX
{   D3DVECTOR	    position;
    D3DVECTOR	    normal;
    D3DVALUE	    tu, tv;
    D3DCOLOR	    color;
} D3DRMVERTEX, *LPD3DRMVERTEX;

typedef LONG D3DRMGROUPINDEX; /* group indexes begin a 0 */
static const D3DRMGROUPINDEX D3DRMGROUP_ALLGROUPS = -1;

/*
 * Create a color from three components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI	D3DRMCreateColorRGB(D3DVALUE red,
					  D3DVALUE green,
					  D3DVALUE blue);

/*
 * Create a color from four components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI	D3DRMCreateColorRGBA(D3DVALUE red,
						 D3DVALUE green,
						 D3DVALUE blue,
						 D3DVALUE alpha);

/*
 * Get the red component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetRed(D3DCOLOR);

/*
 * Get the green component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetGreen(D3DCOLOR);

/*
 * Get the blue component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetBlue(D3DCOLOR);

/*
 * Get the alpha component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetAlpha(D3DCOLOR);

/*
 * Add two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorAdd(LPD3DVECTOR d,
					  LPD3DVECTOR s1,
					  LPD3DVECTOR s2);

/*
 * Subtract two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorSubtract(LPD3DVECTOR d,
					       LPD3DVECTOR s1,
					       LPD3DVECTOR s2);
/*
 * Reflect a ray about a given normal.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorReflect(LPD3DVECTOR d,
					      LPD3DVECTOR ray,
					      LPD3DVECTOR norm);

/*
 * Calculate the vector cross product.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorCrossProduct(LPD3DVECTOR d,
						   LPD3DVECTOR s1,
						   LPD3DVECTOR s2);
/*
 * Return the vector dot product.
 */
extern D3DVALUE 		D3DRMAPI D3DRMVectorDotProduct(LPD3DVECTOR s1,
						 LPD3DVECTOR s2);

/*
 * Scale a vector so that its modulus is 1.  Returns its argument or
 * NULL if there was an error (e.g. a zero vector was passed).
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorNormalize(LPD3DVECTOR);
#define D3DRMVectorNormalise D3DRMVectorNormalize

/*
 * Return the length of a vector (e.g. sqrt(x*x + y*y + z*z)).
 */
extern D3DVALUE 		D3DRMAPI D3DRMVectorModulus(LPD3DVECTOR v);

/*
 * Set the rotation part of a matrix to be a rotation of theta radians
 * around the given axis.
 */

extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorRotate(LPD3DVECTOR r, LPD3DVECTOR v, LPD3DVECTOR axis, D3DVALUE theta);

/*
 * Scale a vector uniformly in all three axes
 */
extern LPD3DVECTOR	D3DRMAPI D3DRMVectorScale(LPD3DVECTOR d, LPD3DVECTOR s, D3DVALUE factor);

/*
 * Return a random unit vector
 */
extern LPD3DVECTOR	D3DRMAPI D3DRMVectorRandom(LPD3DVECTOR d);

/*
 * Returns a unit quaternion that represents a rotation of theta radians
 * around the given axis.
 */

extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromRotation(LPD3DRMQUATERNION quat,
							      LPD3DVECTOR v,
							      D3DVALUE theta);

/*
 * Calculate the product of two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionMultiply(LPD3DRMQUATERNION q,
						    	  LPD3DRMQUATERNION a,
						   	  LPD3DRMQUATERNION b);

/*
 * Interpolate between two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionSlerp(LPD3DRMQUATERNION q,
						       LPD3DRMQUATERNION a,
						       LPD3DRMQUATERNION b,
						       D3DVALUE alpha);

/*
 * Calculate the matrix for the rotation that a unit quaternion represents
 */
extern void 		D3DRMAPI D3DRMMatrixFromQuaternion(D3DRMMATRIX4D dmMat, LPD3DRMQUATERNION lpDqQuat);

/*
 * Calculate the quaternion that corresponds to a rotation matrix
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromMatrix(LPD3DRMQUATERNION, D3DRMMATRIX4D);


#if defined(__cplusplus)
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3drmwin.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMWIN_H__
#define __D3DRMWIN_H__

#ifndef WIN32
#define WIN32
#endif

#include "d3drm.h"

#include "ddraw.h"
#include "d3d.h"

/*
 * GUIDS used by Direct3DRM Windows interface
 */
DEFINE_GUID(IID_IDirect3DRMWinDevice,	0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

WIN_TYPES(IDirect3DRMWinDevice, DIRECT3DRMWINDEVICE);

#undef INTERFACE
#define INTERFACE IDirect3DRMWinDevice

DECLARE_INTERFACE_(IDirect3DRMWinDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWinDevice methods
     */

    /* Repaint the window with the last frame which was rendered. */
    STDMETHOD(HandlePaint)(THIS_ HDC hdc) PURE;

    /* Respond to a WM_ACTIVATE message. */
    STDMETHOD(HandleActivate)(THIS_ WORD wparam) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3d8types-xbox.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8types.h
 *  Content:    Xbox Direct3D types include file
 *
 ***************************************************************************/

#ifndef _D3D8TYPES_H_
#define _D3D8TYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#include <float.h>

#pragma warning(disable:4201) // anonymous unions warning
#pragma pack(4)

// D3DCOLOR is equivalent to D3DFMT_A8R8G8B8
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

// maps unsigned 8 bits/channel to D3DCOLOR
#define D3DCOLOR_ARGB(a,r,g,b) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)
#define D3DCOLOR_XRGB(r,g,b)   D3DCOLOR_ARGB(0xff,r,g,b)

// maps floating point channels (0.f to 1.f range) to D3DCOLOR
#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif
typedef struct _D3DVECTOR *LPD3DVECTOR;

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;
#define D3DRECT_DEFINED
#endif

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif

typedef struct _D3DVIEWPORT8 {
    DWORD       X;
    DWORD       Y;            /* Viewport Top left */
    DWORD       Width;
    DWORD       Height;       /* Viewport Dimensions */
    float       MinZ;         /* Min/max of clip Volume */
    float       MaxZ;
} D3DVIEWPORT8;

typedef struct _D3DMATERIAL8 {
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    float           Power;          /* Sharpness if specular highlight */
} D3DMATERIAL8;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

typedef struct _D3DLIGHT8 {
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    float           Range;            /* Cutoff range */
    float           Falloff;          /* Falloff */
    float           Attenuation0;     /* Constant attenuation */
    float           Attenuation1;     /* Linear attenuation */
    float           Attenuation2;     /* Quadratic attenuation */
    float           Theta;            /* Inner angle of spotlight cone */
    float           Phi;              /* Outer angle of spotlight cone */
} D3DLIGHT8;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x000000f0l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000001l  /* Clear target z buffer */
#define D3DCLEAR_STENCIL           0x00000002l  /* Clear stencil planes */

// The following are Xbox extensions
#define D3DCLEAR_TARGET_R          0x00000010l  /* Clear target surface R component */
#define D3DCLEAR_TARGET_G          0x00000020l  /* Clear target surface G component */
#define D3DCLEAR_TARGET_B          0x00000040l  /* Clear target surface B component */
#define D3DCLEAR_TARGET_A          0x00000080l  /* Clear target surface A component */

// The driver uses these values as the maximum value for Z in the z-buffer.

#define D3DZ_MAX_D16         65535.0
#define D3DZ_MAX_D24S8       16777215.0
#define D3DZ_MAX_F16         511.9375   

// We can't use the whole available range for the 24-bit floating point z
// because the maximum value is very, very close to the IEEE single 
// precision maximum.  Any calculation using the value will cause an overflow.
//
// Back off a bit from the max (3.4028e38),
//
#define D3DZ_MAX_F24S8       1.0e30

/*
 * The following defines the rendering states
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT               = 0x1d00,
    D3DSHADE_GOURAUD            = 0x1d01,
    D3DSHADE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;


typedef enum _D3DFILLMODE {
    D3DFILL_POINT               = 0x1b00,
    D3DFILL_WIREFRAME           = 0x1b01,
    D3DFILL_SOLID               = 0x1b02,
    D3DFILL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO               = 0,
    D3DBLEND_ONE                = 1,
    D3DBLEND_SRCCOLOR           = 0x300,
    D3DBLEND_INVSRCCOLOR        = 0x301,
    D3DBLEND_SRCALPHA           = 0x302,
    D3DBLEND_INVSRCALPHA        = 0x303,
    D3DBLEND_DESTALPHA          = 0x304,
    D3DBLEND_INVDESTALPHA       = 0x305,
    D3DBLEND_DESTCOLOR          = 0x306,
    D3DBLEND_INVDESTCOLOR       = 0x307,
    D3DBLEND_SRCALPHASAT        = 0x308,
    D3DBLEND_CONSTANTCOLOR      = 0x8001,
    D3DBLEND_INVCONSTANTCOLOR   = 0x8002,
    D3DBLEND_CONSTANTALPHA      = 0x8003,
    D3DBLEND_INVCONSTANTALPHA   = 0x8004,

    // D3DBLEND_BOTHSRCALPHA not supported on Xbox
    // D3DBLEND_BOTHINVSRCALPHA not supported on Xbox

    D3DBLEND_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum _D3DBLENDOP {
    D3DBLENDOP_ADD              = 0x8006,
    D3DBLENDOP_SUBTRACT         = 0x800a,
    D3DBLENDOP_REVSUBTRACT      = 0x800b,
    D3DBLENDOP_MIN              = 0x8007,
    D3DBLENDOP_MAX              = 0x8008,
    D3DBLENDOP_ADDSIGNED        = 0xf006,       // Xbox extension
    D3DBLENDOP_REVSUBTRACTSIGNED= 0xf005,       // Xbox extension
    D3DBLENDOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DBLENDOP;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP            = 1,
    D3DTADDRESS_MIRROR          = 2,
    D3DTADDRESS_CLAMP           = 3,
    D3DTADDRESS_BORDER          = 4,
    D3DTADDRESS_CLAMPTOEDGE     = 5, // Xbox extension

    // D3DTADDRESS_MIRRORONCE not supported on Xbox

    D3DTADDRESS_MAX             = 6,
    D3DTADDRESS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum _D3DTEXTURECOLORKEYOP {            // Xbox extension
    D3DTCOLORKEYOP_DISABLE      = 0,
    D3DTCOLORKEYOP_ALPHA        = 1,
    D3DTCOLORKEYOP_RGBA         = 2,
    D3DTCOLORKEYOP_KILL         = 3,

    D3DTCOLORKEYOP_MAX          = 4,
    D3DTCOLORKEYOP_FORCE_DWORD  = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURECOLORKEYOP;

typedef enum _D3DTEXTUREALPHAKILL {             // Xbox extension
    D3DTALPHAKILL_DISABLE       = 0,
    D3DTALPHAKILL_ENABLE        = 4,

    D3DTALPHAKILL_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREALPHAKILL;

typedef enum _D3DCULL {
    D3DCULL_NONE                = 0,
    D3DCULL_CW                  = 0x900,
    D3DCULL_CCW                 = 0x901,
    D3DCULL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum _D3DFRONT {                        // Xbox extension
    D3DFRONT_CW                 = 0x900,
    D3DFRONT_CCW                = 0x901,
    D3DFRONT_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DFRONT;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER                = 0x200,
    D3DCMP_LESS                 = 0x201,
    D3DCMP_EQUAL                = 0x202,
    D3DCMP_LESSEQUAL            = 0x203,
    D3DCMP_GREATER              = 0x204,
    D3DCMP_NOTEQUAL             = 0x205,
    D3DCMP_GREATEREQUAL         = 0x206,
    D3DCMP_ALWAYS               = 0x207,
    D3DCMP_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 0x1e00,
    D3DSTENCILOP_ZERO           = 0,
    D3DSTENCILOP_REPLACE        = 0x1e01,
    D3DSTENCILOP_INCRSAT        = 0x1e02,
    D3DSTENCILOP_DECRSAT        = 0x1e03,
    D3DSTENCILOP_INVERT         = 0x150a,
    D3DSTENCILOP_INCR           = 0x8507,
    D3DSTENCILOP_DECR           = 0x8508,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                 = 0,
    D3DFOG_EXP                  = 1,
    D3DFOG_EXP2                 = 2,
    D3DFOG_LINEAR               = 3,
    D3DFOG_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum _D3DSWATHWIDTH {                   // Xbox extension
    D3DSWATH_8                  = 0,
    D3DSWATH_16                 = 1,
    D3DSWATH_32                 = 2,
    D3DSWATH_64                 = 3,
    D3DSWATH_128                = 4,
    D3DSWATH_OFF                = 0xf,
    D3DSWATH_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSWATHWIDTH;

typedef enum _D3DPALETTESIZE {                  // Xbox extension
    D3DPALETTE_256              = 0,
    D3DPALETTE_128              = 1,
    D3DPALETTE_64               = 2,
    D3DPALETTE_32               = 3,

    D3DPALETTE_MAX              = 4,
    D3DPALETTE_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DPALETTESIZE;

typedef DWORD D3DSHADERCONSTANTMODE;            // Xbox extension

#define D3DSCM_96CONSTANTS                  0
#define D3DSCM_192CONSTANTS                 1
#define D3DSCM_192CONSTANTSANDFIXEDPIPELINE 2
#define D3DSCM_NORESERVEDCONSTANTS          0x10    // Flag

typedef enum _D3DLOGICOP {                      // Xbox extension
    D3DLOGICOP_NONE             = 0,
    D3DLOGICOP_CLEAR            = 0x1500,
    D3DLOGICOP_AND              = 0x1501,
    D3DLOGICOP_AND_REVERSE      = 0x1502,
    D3DLOGICOP_COPY             = 0x1503,
    D3DLOGICOP_AND_INVERTED     = 0x1504,
    D3DLOGICOP_NOOP             = 0x1505,
    D3DLOGICOP_XOR              = 0x1506,
    D3DLOGICOP_OR               = 0x1507,
    D3DLOGICOP_NOR              = 0x1508,
    D3DLOGICOP_EQUIV            = 0x1509,
    D3DLOGICOP_INVERT           = 0x150a,
    D3DLOGICOP_OR_REVERSE       = 0x150b,
    D3DLOGICOP_COPY_INVERTED    = 0x150c,
    D3DLOGICOP_OR_INVERTED      = 0x150d,
    D3DLOGICOP_NAND             = 0x150e,
    D3DLOGICOP_SET              = 0x150f,
    D3DLOGICOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DLOGICOP;

typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINELOOP              = 3,  // Xbox extension
    D3DPT_LINESTRIP             = 4,
    D3DPT_TRIANGLELIST          = 5,
    D3DPT_TRIANGLESTRIP         = 6,
    D3DPT_TRIANGLEFAN           = 7,
    D3DPT_QUADLIST              = 8,  // Xbox extension
    D3DPT_QUADSTRIP             = 9,  // Xbox extension
    D3DPT_POLYGON               = 10, // Xbox extension

    D3DPT_MAX                   = 11,
    D3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW          = 0,
    D3DTS_PROJECTION    = 1,
    D3DTS_TEXTURE0      = 2,
    D3DTS_TEXTURE1      = 3,
    D3DTS_TEXTURE2      = 4,
    D3DTS_TEXTURE3      = 5,
    D3DTS_WORLD         = 6,
    D3DTS_WORLD1        = 7,
    D3DTS_WORLD2        = 8,
    D3DTS_WORLD3        = 9,

    D3DTS_MAX           = 10,
    D3DTS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

#define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + D3DTS_WORLD)

typedef enum _D3DRENDERSTATETYPE {

    // Simple render states that are processed by D3D immediately:

    D3DRS_PS_MIN                        = 0,

    // The following pixel-shader renderstates are all Xbox extensions:

    D3DRS_PSALPHAINPUTS0                = 0,   // Pixel shader, Stage 0 alpha inputs                         
    D3DRS_PSALPHAINPUTS1                = 1,   // Pixel shader, Stage 1 alpha inputs                         
    D3DRS_PSALPHAINPUTS2                = 2,   // Pixel shader, Stage 2 alpha inputs                         
    D3DRS_PSALPHAINPUTS3                = 3,   // Pixel shader, Stage 3 alpha inputs                         
    D3DRS_PSALPHAINPUTS4                = 4,   // Pixel shader, Stage 4 alpha inputs                         
    D3DRS_PSALPHAINPUTS5                = 5,   // Pixel shader, Stage 5 alpha inputs                         
    D3DRS_PSALPHAINPUTS6                = 6,   // Pixel shader, Stage 6 alpha inputs                         
    D3DRS_PSALPHAINPUTS7                = 7,   // Pixel shader, Stage 7 alpha inputs                         
    D3DRS_PSFINALCOMBINERINPUTSABCD     = 8,   // Pixel shader, Final combiner inputs ABCD
    D3DRS_PSFINALCOMBINERINPUTSEFG      = 9,   // Pixel shader, Final combiner inputs EFG
    D3DRS_PSCONSTANT0_0                 = 10,  // Pixel shader, C0 in stage 0
    D3DRS_PSCONSTANT0_1                 = 11,  // Pixel shader, C0 in stage 1
    D3DRS_PSCONSTANT0_2                 = 12,  // Pixel shader, C0 in stage 2
    D3DRS_PSCONSTANT0_3                 = 13,  // Pixel shader, C0 in stage 3
    D3DRS_PSCONSTANT0_4                 = 14,  // Pixel shader, C0 in stage 4
    D3DRS_PSCONSTANT0_5                 = 15,  // Pixel shader, C0 in stage 5
    D3DRS_PSCONSTANT0_6                 = 16,  // Pixel shader, C0 in stage 6
    D3DRS_PSCONSTANT0_7                 = 17,  // Pixel shader, C0 in stage 7
    D3DRS_PSCONSTANT1_0                 = 18,  // Pixel shader, C1 in stage 0
    D3DRS_PSCONSTANT1_1                 = 19,  // Pixel shader, C1 in stage 1
    D3DRS_PSCONSTANT1_2                 = 20,  // Pixel shader, C1 in stage 2
    D3DRS_PSCONSTANT1_3                 = 21,  // Pixel shader, C1 in stage 3
    D3DRS_PSCONSTANT1_4                 = 22,  // Pixel shader, C1 in stage 4
    D3DRS_PSCONSTANT1_5                 = 23,  // Pixel shader, C1 in stage 5
    D3DRS_PSCONSTANT1_6                 = 24,  // Pixel shader, C1 in stage 6
    D3DRS_PSCONSTANT1_7                 = 25,  // Pixel shader, C1 in stage 7
    D3DRS_PSALPHAOUTPUTS0               = 26,  // Pixel shader, Stage 0 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS1               = 27,  // Pixel shader, Stage 1 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS2               = 28,  // Pixel shader, Stage 2 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS3               = 29,  // Pixel shader, Stage 3 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS4               = 30,  // Pixel shader, Stage 4 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS5               = 31,  // Pixel shader, Stage 5 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS6               = 32,  // Pixel shader, Stage 6 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS7               = 33,  // Pixel shader, Stage 7 alpha outputs                        
    D3DRS_PSRGBINPUTS0                  = 34,  // Pixel shader, Stage 0 RGB inputs                           
    D3DRS_PSRGBINPUTS1                  = 35,  // Pixel shader, Stage 1 RGB inputs                           
    D3DRS_PSRGBINPUTS2                  = 36,  // Pixel shader, Stage 2 RGB inputs                           
    D3DRS_PSRGBINPUTS3                  = 37,  // Pixel shader, Stage 3 RGB inputs                           
    D3DRS_PSRGBINPUTS4                  = 38,  // Pixel shader, Stage 4 RGB inputs                           
    D3DRS_PSRGBINPUTS5                  = 39,  // Pixel shader, Stage 5 RGB inputs                           
    D3DRS_PSRGBINPUTS6                  = 40,  // Pixel shader, Stage 6 RGB inputs                           
    D3DRS_PSRGBINPUTS7                  = 41,  // Pixel shader, Stage 7 RGB inputs                           
    D3DRS_PSCOMPAREMODE                 = 42,  // Pixel shader, Compare modes for clipplane texture mode     
    D3DRS_PSFINALCOMBINERCONSTANT0      = 43,  // Pixel shader, C0 in final combiner
    D3DRS_PSFINALCOMBINERCONSTANT1      = 44,  // Pixel shader, C1 in final combiner
    D3DRS_PSRGBOUTPUTS0                 = 45,  // Pixel shader, Stage 0 RGB outputs                          
    D3DRS_PSRGBOUTPUTS1                 = 46,  // Pixel shader, Stage 1 RGB outputs                          
    D3DRS_PSRGBOUTPUTS2                 = 47,  // Pixel shader, Stage 2 RGB outputs                          
    D3DRS_PSRGBOUTPUTS3                 = 48,  // Pixel shader, Stage 3 RGB outputs                          
    D3DRS_PSRGBOUTPUTS4                 = 49,  // Pixel shader, Stage 4 RGB outputs                          
    D3DRS_PSRGBOUTPUTS5                 = 50,  // Pixel shader, Stage 5 RGB outputs                          
    D3DRS_PSRGBOUTPUTS6                 = 51,  // Pixel shader, Stage 6 RGB outputs                          
    D3DRS_PSRGBOUTPUTS7                 = 52,  // Pixel shader, Stage 7 RGB outputs                          
    D3DRS_PSCOMBINERCOUNT               = 53,  // Pixel shader, Active combiner count (Stages 0-7)           
                                               // Pixel shader, Reserved
    D3DRS_PSDOTMAPPING                  = 55,  // Pixel shader, Input mapping for dot product modes          
    D3DRS_PSINPUTTEXTURE                = 56,  // Pixel shader, Texture source for some texture modes        
                                        
    D3DRS_PS_MAX                        = 57,  
                                        
    D3DRS_ZFUNC                         = 57,  // D3DCMPFUNC 
    D3DRS_ALPHAFUNC                     = 58,  // D3DCMPFUNC 
    D3DRS_ALPHABLENDENABLE              = 59,  // TRUE to enable alpha blending 
    D3DRS_ALPHATESTENABLE               = 60,  // TRUE to enable alpha tests 
    D3DRS_ALPHAREF                      = 61,  // BYTE
    D3DRS_SRCBLEND                      = 62,  // D3DBLEND 
    D3DRS_DESTBLEND                     = 63,  // D3DBLEND 
    D3DRS_ZWRITEENABLE                  = 64,  // TRUE to enable Z writes 
    D3DRS_DITHERENABLE                  = 65,  // TRUE to enable dithering 
    D3DRS_SHADEMODE                     = 66,  // D3DSHADEMODE 
    D3DRS_COLORWRITEENABLE              = 67,  // D3DCOLORWRITEENABLE_ALPHA, etc. per-channel write enable
    D3DRS_STENCILZFAIL                  = 68,  // D3DSTENCILOP to do if stencil test passes and Z test fails 
    D3DRS_STENCILPASS                   = 69,  // D3DSTENCILOP to do if both stencil and Z tests pass 
    D3DRS_STENCILFUNC                   = 70,  // D3DCMPFUNC
    D3DRS_STENCILREF                    = 71,  // BYTE reference value used in stencil test 
    D3DRS_STENCILMASK                   = 72,  // BYTE mask value used in stencil test 
    D3DRS_STENCILWRITEMASK              = 73,  // BYTE write mask applied to values written to stencil buffer 
    D3DRS_BLENDOP                       = 74,  // D3DBLENDOP setting
    D3DRS_BLENDCOLOR                    = 75,  // D3DCOLOR for D3DBLEND_CONSTANT, etc. (Xbox extension)
    D3DRS_SWATHWIDTH                    = 76,  // D3DSWATHWIDTH (Xbox extension)
    D3DRS_POLYGONOFFSETZSLOPESCALE      = 77,  // float Z factor for shadow maps (Xbox extension)
    D3DRS_POLYGONOFFSETZOFFSET          = 78,  // float bias for polygon offset (Xbox extension)
    D3DRS_POINTOFFSETENABLE             = 79,  // TRUE to enable polygon offset for points (Xbox extension)
    D3DRS_WIREFRAMEOFFSETENABLE         = 80,  // TRUE to enable polygon offset for lines (Xbox extension)
    D3DRS_SOLIDOFFSETENABLE             = 81,  // TRUE to enable polygon offset for fills (Xbox extension)
                                        
    D3DRS_SIMPLE_MAX                    = 82,

    // State whose handling is deferred until the next Draw[Indexed]Vertices
    // call because of interdependencies on other states:

    D3DRS_FOGENABLE                     = 82,  // TRUE to enable fog blending 
    D3DRS_FOGTABLEMODE                  = 83,  // D3DFOGMODE 
    D3DRS_FOGSTART                      = 84,  // float fog start (for both vertex and pixel fog) 
    D3DRS_FOGEND                        = 85,  // float fog end      
    D3DRS_FOGDENSITY                    = 86,  // float fog density  
    D3DRS_RANGEFOGENABLE                = 87,  // TRUE to enable range-based fog 
    D3DRS_WRAP0                         = 88,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 1st texture coord.
    D3DRS_WRAP1                         = 89,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 2nd texture coord. 
    D3DRS_WRAP2                         = 90,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 3rd texture coord. 
    D3DRS_WRAP3                         = 91,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 4th texture coord. 
    D3DRS_LIGHTING                      = 92,  // TRUE to enable lighting
    D3DRS_SPECULARENABLE                = 93,  // TRUE to enable specular 
    D3DRS_LOCALVIEWER                   = 94,  // TRUE to enable camera-relative specular highlights
    D3DRS_COLORVERTEX                   = 95,  // TRUE to enable per-vertex color
    D3DRS_BACKSPECULARMATERIALSOURCE    = 96,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKDIFFUSEMATERIALSOURCE     = 97,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKAMBIENTMATERIALSOURCE     = 98,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKEMISSIVEMATERIALSOURCE    = 99,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_SPECULARMATERIALSOURCE        = 100, // D3DMATERIALCOLORSOURCE 
    D3DRS_DIFFUSEMATERIALSOURCE         = 101, // D3DMATERIALCOLORSOURCE 
    D3DRS_AMBIENTMATERIALSOURCE         = 102, // D3DMATERIALCOLORSOURCE 
    D3DRS_EMISSIVEMATERIALSOURCE        = 103, // D3DMATERIALCOLORSOURCE 
    D3DRS_BACKAMBIENT                   = 104, // D3DCOLOR (Xbox extension)
    D3DRS_AMBIENT                       = 105, // D3DCOLOR 
    D3DRS_POINTSIZE                     = 106, // float point size 
    D3DRS_POINTSIZE_MIN                 = 107, // float point size min threshold 
    D3DRS_POINTSPRITEENABLE             = 108, // TRUE to enable point sprites
    D3DRS_POINTSCALEENABLE              = 109, // TRUE to enable point size scaling
    D3DRS_POINTSCALE_A                  = 110, // float point attenuation A value 
    D3DRS_POINTSCALE_B                  = 111, // float point attenuation B value 
    D3DRS_POINTSCALE_C                  = 112, // float point attenuation C value 
    D3DRS_POINTSIZE_MAX                 = 113, // float point size max threshold 
    D3DRS_PATCHEDGESTYLE                = 114, // D3DPATCHEDGESTYLE
    D3DRS_PATCHSEGMENTS                 = 115, // DWORD number of segments per edge when drawing patches
    D3DRS_SWAPFILTER                    = 116, // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for Swap (Xbox extension)
                                        
    D3DRS_DEFERRED_MAX                  = 117,

    // Complex state that has immediate processing:

    D3DRS_PSTEXTUREMODES                = 117, // Pixel shader, Texture addressing modes (Xbox extension)
    D3DRS_VERTEXBLEND                   = 118, // D3DVERTEXBLENDFLAGS
    D3DRS_FOGCOLOR                      = 119, // D3DCOLOR 
    D3DRS_FILLMODE                      = 120, // D3DFILLMODE        
    D3DRS_BACKFILLMODE                  = 121, // D3DFILLMODE (Xbox extension)
    D3DRS_TWOSIDEDLIGHTING              = 122, // TRUE to enable two-sided lighting (Xbox extension)
    D3DRS_NORMALIZENORMALS              = 123, // TRUE to enable automatic normalization
    D3DRS_ZENABLE                       = 124, // D3DZBUFFERTYPE (or TRUE/FALSE for legacy) 
    D3DRS_STENCILENABLE                 = 125, // TRUE to enable stenciling
    D3DRS_STENCILFAIL                   = 126, // D3DSTENCILOP to do if stencil test fails 
    D3DRS_FRONTFACE                     = 127, // D3DFRONT (Xbox extension)
    D3DRS_CULLMODE                      = 128, // D3DCULL 
    D3DRS_TEXTUREFACTOR                 = 129, // D3DCOLOR used for multi-texture blend 
    D3DRS_ZBIAS                         = 130, // LONG Z bias 
    D3DRS_LOGICOP                       = 131, // D3DLOGICOP (Xbox extension)
    D3DRS_EDGEANTIALIAS                 = 132, // TRUE to enable edge antialiasing (Xbox extension)
    D3DRS_MULTISAMPLEANTIALIAS          = 133, // TRUE to enable multisample antialiasing
    D3DRS_MULTISAMPLEMASK               = 134, // DWORD per-pixel and per-sample enable/disable
    D3DRS_MULTISAMPLEMODE               = 135, // D3DMULTISAMPLEMODE for the backbuffer (Xbox extension)
    D3DRS_MULTISAMPLERENDERTARGETMODE   = 136, // D3DMULTISAMPLEMODE for non-backbuffer render targets (Xbox extension)
    D3DRS_SHADOWFUNC                    = 137, // D3DCMPFUNC (Xbox extension)
    D3DRS_LINEWIDTH                     = 138, // float (Xbox extension)
    D3DRS_DXT1NOISEENABLE               = 139, // TRUE to enable DXT1 decompression noise (Xbox extension)
    D3DRS_YUVENABLE                     = 140, // TRUE to enable use of D3DFMT_YUY2 and D3DFMT_UYVY texture formats
    D3DRS_OCCLUSIONCULLENABLE           = 141, // TRUE to enable Z occlusion culling
    D3DRS_STENCILCULLENABLE             = 142, // TRUE to enable stencil culling
    D3DRS_ROPZCMPALWAYSREAD             = 143, // TRUE to always read target packet when Z enabled
    D3DRS_ROPZREAD                      = 144, // TRUE to always read Z
    D3DRS_DONOTCULLUNCOMPRESSED         = 145, // TRUE to never attempt occlusion culling (stencil or Z) on uncompressed packets
                                        
    D3DRS_MAX                           = 146, // Total number of renderstates 

    // Render states that are not supported on Xbox:
    //
    // D3DRS_LINEPATTERN
    // D3DRS_LASTPIXEL
    // D3DRS_CLIPPING
    // D3DRS_FOGVERTEXMODE
    // D3DRS_CLIPPLANEENABLE
    // D3DRS_SOFTWAREVERTEXPROCESSING
    // D3DRS_DEBUGMONITORTOKEN
    // D3DRS_INDEXEDVERTEXBLENDENABLE
    // D3DRS_TWEENFACTOR

    D3DRS_FORCE_DWORD                   = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// Values for material source
typedef enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL         = 0,            // Color from material is used
    D3DMCS_COLOR1           = 1,            // Diffuse vertex color is used
    D3DMCS_COLOR2           = 2,            // Specular vertex color is used
    D3DMCS_FORCE_DWORD      = 0x7fffffff,   // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;

// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 D3DRS_WRAP0

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000010L
#define D3DWRAP_V   0x00001000L
#define D3DWRAP_W   0x00100000L

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
#define D3DWRAPCOORD_0   0x00000010L    // same as D3DWRAP_U
#define D3DWRAPCOORD_1   0x00001000L    // same as D3DWRAP_V
#define D3DWRAPCOORD_2   0x00100000L    // same as D3DWRAP_W
#define D3DWRAPCOORD_3   0x01000000L

/* Flags to construct D3DRS_COLORWRITEENABLE */
#define D3DCOLORWRITEENABLE_RED     (1L<<16)
#define D3DCOLORWRITEENABLE_GREEN   (1L<<8)
#define D3DCOLORWRITEENABLE_BLUE    (1L<<0)
#define D3DCOLORWRITEENABLE_ALPHA   (1L<<24)
#define D3DCOLORWRITEENABLE_ALL     0x01010101 // Xbox extension

/*
 * State enumerants for per-stage texture processing.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    // State whose handling is deferred until the next Draw[Indexed]Vertices
    // call because of interdependencies on other states:

    D3DTSS_ADDRESSU              =  0,  // D3DTEXTUREADDRESS for U coordinate 
    D3DTSS_ADDRESSV              =  1,  // D3DTEXTUREADDRESS for V coordinate 
    D3DTSS_ADDRESSW              =  2,  // D3DTEXTUREADDRESS for W coordinate 
    D3DTSS_MAGFILTER             =  3,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for magnification 
    D3DTSS_MINFILTER             =  4,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for minification 
    D3DTSS_MIPFILTER             =  5,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use between mipmaps during minification 
    D3DTSS_MIPMAPLODBIAS         =  6,  // float mipmap LOD bias 
    D3DTSS_MAXMIPLEVEL           =  7,  // DWORD 0..(n-1) LOD index of largest map to use (0 == largest) 
    D3DTSS_MAXANISOTROPY         =  8,  // DWORD maximum anisotropy 
    D3DTSS_COLORKEYOP            =  9,  // D3DTEXTURECOLORKEYOP (Xbox extension)
    D3DTSS_COLORSIGN             = 10,  // D3DTSIGN_* (D3DTSIGN_ASIGNED etc.) for color channels (xbox extension)
    D3DTSS_ALPHAKILL             = 11,  // D3DTEXTUREALPHAKILL (Xbox extension)

    D3DTSS_DEFERRED_TEXTURE_STATE_MAX = 12,

    D3DTSS_COLOROP               = 12,  // D3DTEXTUREOP - per-stage blending controls for color channels 
    D3DTSS_COLORARG0             = 13,  // D3DTA_* (D3DTA_TEXTURE etc.) third arg for triadic ops 
    D3DTSS_COLORARG1             = 14,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg
    D3DTSS_COLORARG2             = 15,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg 
    D3DTSS_ALPHAOP               = 16,  // D3DTEXTUREOP - per-stage blending controls for alpha channel 
    D3DTSS_ALPHAARG0             = 17,  // D3DTA_* (D3DTA_TEXTURE etc.) third arg for triadic ops 
    D3DTSS_ALPHAARG1             = 18,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg
    D3DTSS_ALPHAARG2             = 19,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg) 
    D3DTSS_RESULTARG             = 20,  // D3DTA_CURRENT or D3DTA_TEMP - arg for result 
    D3DTSS_TEXTURETRANSFORMFLAGS = 21,  // D3DTEXTURETRANSFORMFLAGS controls texture transform 

    D3DTSS_DEFERRED_MAX          = 22,

    // State that has immediate processing:

    D3DTSS_BUMPENVMAT00          = 22,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT01          = 23,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT11          = 24,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT10          = 25,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVLSCALE         = 26,  // float scale for bump map luminance 
    D3DTSS_BUMPENVLOFFSET        = 27,  // float offset for bump map luminance 
    D3DTSS_TEXCOORDINDEX         = 28,  // DWORD identifies which set of texture coordinates index this texture 
    D3DTSS_BORDERCOLOR           = 29,  // D3DCOLOR 
    D3DTSS_COLORKEYCOLOR         = 30,  // D3DCOLOR value for color key (Xbox extension)
                                 
    D3DTSS_MAX                   = 32,  // Total number of texture stage states (bumped to a power of 2)

    D3DTSS_FORCE_DWORD           = 0x7fffffff, // force 32-bit size enum 
} D3DTEXTURESTAGESTATETYPE;

/*
 * The maximum number of texture stages supported on Xbox
 */

#define D3DTSS_MAXSTAGES 4

/*
 * The maximum index value possible for EndVisibilityTest
 */

#define D3DVISIBILITY_TEST_MAX 4096

// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
#define D3DTSS_TCI_PASSTHRU                             0x00000000
#define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
#define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000
#define D3DTSS_TCI_OBJECT                               0x00040000
#define D3DTSS_TCI_SPHERE                               0x00050000

#define D3DTSS_TCI_TEXCOORDINDEX_MAX                    8
#define D3DTSS_TCI_TEXGEN_MAX                           0x00060000

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum _D3DTEXTUREOP
{
    // Control
    D3DTOP_DISABLE              = 1,      // disables stage
    D3DTOP_SELECTARG1           = 2,      // the default
    D3DTOP_SELECTARG2           = 3,

    // Modulate
    D3DTOP_MODULATE             = 4,      // multiply args together
    D3DTOP_MODULATE2X           = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X           = 6,      // multiply and  2 bits

    // Add
    D3DTOP_ADD                  =  7,   // add arguments together
    D3DTOP_ADDSIGNED            =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X          =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT             = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH            = 11,   // add 2 args, subtract product
                                        // Arg1 + Arg2 - Arg1*Arg2
                                        // = Arg1 + (1-Arg1)*Arg2

    // Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 14, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 15, // alpha from D3DRENDERSTATE_TEXTUREFACTOR

    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 16, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 13, // by alpha of current color

    // Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 22,

    // Triadic ops
    D3DTOP_MULTIPLYADD          = 23, // Arg0 + Arg1*Arg2
    D3DTOP_LERP                 = 24, // (Arg0)*Arg1 + (1-Arg0)*Arg2

    // Bump mapping
    D3DTOP_BUMPENVMAP           = 25, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 26, // with luminance channel

    D3DTOP_MAX                  = 27,
    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
 * operations set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
#define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
#define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
#define D3DTA_TFACTOR           0x00000003  // select RENDERSTATE_TEXTUREFACTOR (read only)
#define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
#define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)

#define D3DTA_SELECTMAX         0x00000006
#define D3DTA_MODIFIERMAX       0x00000040

/*
 * Flags for D3DTSS_COLORSIGN (Xbox extension)
 */
#define D3DTSIGN_ASIGNED           0x10000000
#define D3DTSIGN_AUNSIGNED         0
#define D3DTSIGN_RSIGNED           0x20000000
#define D3DTSIGN_RUNSIGNED         0
#define D3DTSIGN_GSIGNED           0x40000000
#define D3DTSIGN_GUNSIGNED         0
#define D3DTSIGN_BSIGNED           0x80000000
#define D3DTSIGN_BUNSIGNED         0

//
// Values for D3DTSS_***FILTER texture stage states
//
typedef enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
    D3DTEXF_POINT           = 1,    // nearest
    D3DTEXF_LINEAR          = 2,    // linear interpolation
    D3DTEXF_ANISOTROPIC     = 3,    // anisotropic
    D3DTEXF_QUINCUNX        = 4,    // quincunx kernel (Xbox extension)
    D3DTEXF_GAUSSIANCUBIC   = 5,    // different cubic kernel

    D3DTEXF_MAX             = 6,
    D3DTEXF_FORCE_DWORD     = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREFILTERTYPE;

/* The maximum number of vertices user can pass to any d3d
   drawing function or to create vertex buffer with
*/
#define D3DMAXNUMVERTICES    ((1<<16) - 1)
/* The maximum number of primitives user can pass to any d3d
   drawing function.
*/
#define D3DMAXNUMPRIMITIVES  ((1<<16) - 1)

//-------------------------------------------------------------------
// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x00E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#define D3DFVF_XYZB1            0x006
#define D3DFVF_XYZB2            0x008
#define D3DFVF_XYZB3            0x00a
#define D3DFVF_XYZB4            0x00c

#define D3DFVF_NORMAL           0x010
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400

#define D3DFVF_RESERVED2        0xE000  // 4 reserved bits

// D3DFVF_PSIZE is not supported on Xbox with the fixed function pipeline 
// (a programmable vertex shader can be written to support per-vertex point
// sizes)

//---------------------------------------------------------------------
// Vertex Shaders
//

/*

Vertex Shader Declaration

The declaration portion of a vertex shader defines the static external
interface of the shader.  The information in the declaration includes:

- Assignments of vertex shader input registers to data streams.  These
assignments bind a specific vertex register to a single component within a
vertex stream.  A vertex stream element is identified by a byte offset
within the stream and a type.  The type specifies the arithmetic data type
plus the dimensionality (1, 2, 3, or 4 values).  Stream data which is
less than 4 values are always expanded out to 4 values with zero or more
0.F values and one 1.F value.

- Assignment of vertex shader input registers to implicit data from the
primitive tessellator.  This controls the loading of vertex data which is
not loaded from a stream, but rather is generated during primitive
tessellation prior to the vertex shader.

- Loading data into the constant memory at the time a shader is set as the
current shader.  Each token specifies values for one or more contiguous 4
DWORD constant registers.  This allows the shader to update an arbitrary
subset of the constant memory, overwriting the device state (which
contains the current values of the constant memory).  Note that these
values can be subsequently overwritten (between DrawPrimitive calls)
during the time a shader is bound to a device via the
SetVertexShaderConstant method.


Declaration arrays are single-dimensional arrays of DWORDs composed of
multiple tokens each of which is one or more DWORDs.  The single-DWORD
token value 0xFFFFFFFF is a special token used to indicate the end of the
declaration array.  The single DWORD token value 0x00000000 is a NOP token
with is ignored during the declaration parsing.  Note that 0x00000000 is a
valid value for DWORDs following the first DWORD for multiple word tokens.

[31:29] TokenType
    0x0 - NOP (requires all DWORD bits to be zero)
    0x1 - stream selector
    0x2 - stream data definition (map to vertex input memory)
    0x3 - vertex input memory from tessellator
    0x4 - constant memory from shader
    0x5 - extension
    0x6 - reserved
    0x7 - end-of-array (requires all DWORD bits to be 1)

NOP Token (single DWORD token)
    [31:29] 0x0
    [28:00] 0x0

Stream Selector (single DWORD token)
    [31:29] 0x1
    [28]    indicates whether this is a tessellator stream
    [27:04] 0x0
    [03:00] stream selector (0..15)

Stream Data Definition (single DWORD token)
    Vertex Input Register Load
      [31:29] 0x2
      [28]    0x0
      [27:24] 0x0
      [23:16] type (dimensionality and data type)
      [15:04] 0x0
      [03:00] vertex register address (0..15)
    DWORD Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27]    0x0
      [26:20] 0x0
      [19:16] count of DWORDS to skip over (0..15)
      [15:00] 0x0
    BYTE Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27]    0x1
      [26:20] 0x0
      [19:16] count of BYTES to skip over (0..15)
      [15:00] 0x0
  
Vertex Input Memory from Tessellator Data (single DWORD token)
    [31:29] 0x3
    [28]    indicates whether data is normals or u/v
    [27:24] 0x0
    [23:20] vertex register address (0..15)
    [19:04] 0x0
    [03:00] vertex register address (0..15)

Constant Memory from Shader (multiple DWORD token)
    [31:29] 0x4
    [28:25] count of 4*DWORD constants to load (0..15)
    [24:08] 0x0
    [07:00] constant memory address (0..191 - biased by 96)

Extension Token (single or multiple DWORD token)
    [31:29] 0x5
    [28:24] count of additional DWORDs in token (0..31)
    [23:00] extension-specific information

End-of-array token (single DWORD token)
    [31:29] 0x7
    [28:00] 0x1fffffff

The stream selector token must be immediately followed by a contiguous set 
of stream data definition tokens.  This token sequence fully defines that 
stream, including the set of elements within the stream, the order in 
which the elements appear, the type of each element, and the vertex 
register into which to load an element.

Streams are allowed to include data which is not loaded into a vertex 
register, thus allowing data which is not used for this shader to exist 
in the vertex stream.  This skipped data is defined only by a count of 
DWORDs to skip over, since the type i nformation is irrelevant.

The token sequence:
Stream Select: stream=0
Stream Data Definition (Load): type=FLOAT3; register=3
Stream Data Definition (Load): type=FLOAT3; register=4
Stream Data Definition (Skip): count=2
Stream Data Definition (Load): type=FLOAT2; register=7

defines stream zero to consist of 4 elements, 3 of which are loaded into 
registers and the fourth skipped over.  Register 3 is loaded with the 
first three DWORDs in each vertex interpreted as FLOAT data.  Register 4 
is loaded with the 4th, 5th, and 6th DWORDs interpreted as FLOAT data.  
The next two DWORDs (7th and 8th) are skipped over and not loaded into 
any vertex input register.   Register 7 is loaded with the 9th and 10th 
DWORDS interpreted as FLOAT data.  Placing of tokens other than NOPs 
between the Stream Selector and Stream Data Definition tokens is disallowed.

*/

// Vertex Shader 1.0 register limits. D3D device must provide at least
// specified number of registers
//

#define D3DVS_STREAMS_MAX_V1_0          16
#define D3DVS_INPUTREG_MAX_V1_0         16
#define D3DVS_TEMPREG_MAX_V1_0          12
// This max required number. Device could have more registers. Check caps.
#define D3DVS_CONSTREG_COUNT_XBOX       192
#define D3DVS_TCRDOUTREG_MAX_V1_0       8
#define D3DVS_ADDRREG_MAX_V1_0          1
#define D3DVS_ATTROUTREG_MAX_V1_0       2
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_0  128

// The following two vertex shader constant addresses are reserved on Xbox
// when the SetShaderConstantMode does not have the D3DSCM_NORESERVEDCONSTANTS 
// bit set (that is, these are reserved unless all of your vertex shaders use
// #pragma screenspace):
//
#define D3DVS_XBOX_RESERVEDCONSTANT1    -38
#define D3DVS_XBOX_RESERVEDCONSTANT2    -37

// Calling SetVertexShader with FVF_XYZRHW invalidates the first 11 or 12
// vertex shader program slots as loaded via LoadVertexShader. Max is 12...
//
#define D3DVS_XBOX_RESERVEDXYZRHWSLOTS  12

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define D3DPS_INPUTREG_MAX_DX8         8
#define D3DPS_TEMPREG_MAX_DX8          8
#define D3DPS_CONSTREG_MAX_DX8         16
#define D3DPS_TEXTUREREG_MAX_DX8       8


typedef enum _D3DVSD_TOKENTYPE
{
    D3DVSD_TOKEN_NOP        = 0,    // NOP or extension
    D3DVSD_TOKEN_STREAM,            // stream selector
    D3DVSD_TOKEN_STREAMDATA,        // stream data definition (map to vertex input memory)
    D3DVSD_TOKEN_TESSELLATOR,       // vertex input memory from tessellator
    D3DVSD_TOKEN_CONSTMEM,          // constant memory from shader
    D3DVSD_TOKEN_EXT,               // extension
    D3DVSD_TOKEN_END = 7,           // end-of-array (requires all DWORD bits to be 1)
    D3DVSD_FORCE_DWORD = 0x7fffffff,// force 32-bit size enum
} D3DVSD_TOKENTYPE;

#define D3DVSD_TOKENTYPESHIFT   29
#define D3DVSD_TOKENTYPEMASK    (7 << D3DVSD_TOKENTYPESHIFT)

#define D3DVSD_STREAMNUMBERSHIFT 0
#define D3DVSD_STREAMNUMBERMASK (0xF << D3DVSD_STREAMNUMBERSHIFT)

#define D3DVSD_DATALOADTYPESHIFT 28
#define D3DVSD_DATALOADTYPEMASK (0x1 << D3DVSD_DATALOADTYPESHIFT)

#define D3DVSD_DATATYPESHIFT 16
#define D3DVSD_DATATYPEMASK (0xFF << D3DVSD_DATATYPESHIFT)

#define D3DVSD_SKIPCOUNTSHIFT 16
#define D3DVSD_SKIPCOUNTMASK (0xF << D3DVSD_SKIPCOUNTSHIFT)

#define D3DVSD_VERTEXREGSHIFT 0
#define D3DVSD_VERTEXREGMASK (0x1F << D3DVSD_VERTEXREGSHIFT)

#define D3DVSD_VERTEXREGINSHIFT 20
#define D3DVSD_VERTEXREGINMASK (0xF << D3DVSD_VERTEXREGINSHIFT)

#define D3DVSD_CONSTCOUNTSHIFT 25
#define D3DVSD_CONSTCOUNTMASK (0xF << D3DVSD_CONSTCOUNTSHIFT)

#define D3DVSD_CONSTADDRESSSHIFT 0
#define D3DVSD_CONSTADDRESSMASK (0xFF << D3DVSD_CONSTADDRESSSHIFT)

#define D3DVSD_CONSTRSSHIFT 16
#define D3DVSD_CONSTRSMASK (0x1FFF << D3DVSD_CONSTRSSHIFT)

#define D3DVSD_EXTCOUNTSHIFT 24
#define D3DVSD_EXTCOUNTMASK (0x1F << D3DVSD_EXTCOUNTSHIFT)

#define D3DVSD_EXTINFOSHIFT 0
#define D3DVSD_EXTINFOMASK (0xFFFFFF << D3DVSD_EXTINFOSHIFT)

#define D3DVSD_MAKETOKENTYPE(tokenType) ((tokenType << D3DVSD_TOKENTYPESHIFT) & D3DVSD_TOKENTYPEMASK)

// macros for generation of CreateVertexShader Declaration token array

// Set current stream
// _StreamNumber [0..(MaxStreams-1)] stream to get data from
//
#define D3DVSD_STREAM( _StreamNumber ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (_StreamNumber))

// Set tessellator stream
//
#define D3DVSD_STREAMTESSSHIFT 28
#define D3DVSD_STREAMTESSMASK (1 << D3DVSD_STREAMTESSSHIFT)
#define D3DVSD_STREAM_TESS( ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (D3DVSD_STREAMTESSMASK))

// bind single vertex register to vertex element from vertex stream
//
// _VertexRegister [0..26] address of the vertex register
// _Type [D3DVSDT_*] dimensionality and arithmetic data type

#define D3DVSD_REG( _VertexRegister, _Type ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) |            \
     ((_Type) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Skip _DWORDCount DWORDs in vertex
//
#define D3DVSD_SKIP( _DWORDCount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x10000000 | \
     ((_DWORDCount) << D3DVSD_SKIPCOUNTSHIFT))

// Skip _BYTECount BYTEs in vertex (Xbox extension)
//
#define D3DVSD_SKIPBYTES( _BYTECount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x18000000 | \
     ((_BYTECount) << D3DVSD_SKIPCOUNTSHIFT))

// load data into vertex shader constant memory
//
// _ConstantAddress [-96..95] - address of constant array to begin filling data
// _Count [0..15] - number of constant vectors to load (4 DWORDs each)
// followed by 4*_Count DWORDS of data
//
#define D3DVSD_CONST( _ConstantAddress, _Count ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM) | \
     ((_Count) << D3DVSD_CONSTCOUNTSHIFT) | ((_ConstantAddress) + 96))

// enable tessellator generated normals
//
// _VertexRegisterIn  [0..15] address of vertex register whose input stream
//                            will be used in normal computation
// _VertexRegisterOut [0..15] address of vertex register to output the normal to
//
#define D3DVSD_TESSNORMAL( _VertexRegisterIn, _VertexRegisterOut ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | \
     ((_VertexRegisterIn) << D3DVSD_VERTEXREGINSHIFT) | \
     (_VertexRegisterOut))

// enable tessellator generated surface parameters
//
// _VertexRegister [0..15] address of vertex register to output parameters
//
#define D3DVSD_TESSUV( _VertexRegister ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | 0x10000000 | \
     (_VertexRegister))

// Generates END token
//
#define D3DVSD_END() 0xFFFFFFFF

// Generates NOP token
#define D3DVSD_NOP() 0x00000000

// bit declarations for _Type fields
#define D3DVSDT_FLOAT1      0x12    // 1D float expanded to (value, 0., 0., 1.)
#define D3DVSDT_FLOAT2      0x22    // 2D float expanded to (value, value, 0., 1.)
#define D3DVSDT_FLOAT3      0x32    // 3D float expanded to (value, value, value, 1.)
#define D3DVSDT_FLOAT4      0x42    // 4D float
#define D3DVSDT_D3DCOLOR    0x40    // 4D packed unsigned bytes mapped to 0. to 1. range
                                    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
#define D3DVSDT_SHORT2      0x25    // 2D signed short expanded to (value, value, 0., 1.)
#define D3DVSDT_SHORT4      0x45    // 4D signed short

// The following are Xbox extensions
#define D3DVSDT_NORMSHORT1  0x11    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
                                    // (signed, normalized short maps from -1.0 to 1.0)
#define D3DVSDT_NORMSHORT2  0x21    // 2D signed, normalized short expanded to (value, value, 0., 1.)
#define D3DVSDT_NORMSHORT3  0x31    // 3D signed, normalized short expanded to (value, value, value, 1.)  
#define D3DVSDT_NORMSHORT4  0x41    // 4D signed, normalized short expanded to (value, value, value, value)  
#define D3DVSDT_NORMPACKED3 0x16    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
                                    // Each component ranges from -1.0 to 1.0.  
                                    // Expanded to (value, value, value, 1.)
#define D3DVSDT_SHORT1      0x15    // 1D signed short expanded to (value, 0., 0., 1.)  
                                    // Signed shorts map to the range [-32768, 32767]
#define D3DVSDT_SHORT3      0x35    // 3D signed short expanded to (value, value, value, 1.)
#define D3DVSDT_PBYTE1      0x14    // 1D packed byte expanded to (value, 0., 0., 1.)  
                                    // Packed bytes map to the range [0, 1]
#define D3DVSDT_PBYTE2      0x24    // 2D packed byte expanded to (value, value, 0., 1.)
#define D3DVSDT_PBYTE3      0x34    // 3D packed byte expanded to (value, value, value, 1.)
#define D3DVSDT_PBYTE4      0x44    // 4D packed byte expanded to (value, value, value, value) 
#define D3DVSDT_FLOAT2H     0x72    // 2D homogeneous float expanded to (value, value,0., value.)
                                    // Useful for projective texture coordinates.
#define D3DVSDT_NONE        0x02    // No stream data

// D3DVSDT_UBYTE4 not supported on Xbox (hardware can't do it)

// assignments of vertex input registers for fixed function vertex shader
//
#define D3DVSDE_VERTEX          -1  // Xbox extension, used only in Begin/End bracket
#define D3DVSDE_POSITION        0
#define D3DVSDE_BLENDWEIGHT     1
#define D3DVSDE_NORMAL          2
#define D3DVSDE_DIFFUSE         3
#define D3DVSDE_SPECULAR        4
#define D3DVSDE_FOG             5   // Xbox extension
#define D3DVSDE_BACKDIFFUSE     7   // Xbox extension
#define D3DVSDE_BACKSPECULAR    8   // Xbox extension
#define D3DVSDE_TEXCOORD0       9
#define D3DVSDE_TEXCOORD1       10
#define D3DVSDE_TEXCOORD2       11
#define D3DVSDE_TEXCOORD3       12

// D3DVSDE_PSIZE is not supported on Xbox with the fixed function pipeline 
// (a programmable vertex shader can be written to support per-vertex point
// sizes)

// Maximum supported number of texture coordinate sets
#define D3DDP_MAXTEXCOORD   4

// Some Vertex Shader APIs take allow the vertex format to be specified with 
// a structure rather than a handle to a vertex shader object.  The following 
// structure defines how vertex attributes are read from one or more streams.

typedef struct _D3DVERTEXSHADERINPUT
{
    DWORD StreamIndex;      // which stream 
    DWORD Offset;           // Byte offset from the start of the stream.
    DWORD Format;           // format of this attribute (D3DVSDT_*)
    BYTE  TessType;         // 0=none, 1=normal, 2=autotex
    BYTE  TessSource;       // source register for normal/uv autocalc
} D3DVERTEXSHADERINPUT;

// Up to 16 different inputs are supported by the vertex shader hardware.
// Each of the 16 entries in the following structure defines which 
// stream that value comes from, what byte offset corresponds to an 
// attribute, and the format of the attribute.

typedef struct _D3DVERTEXATTRIBUTEFORMAT
{
    D3DVERTEXSHADERINPUT Input[16];
} D3DVERTEXATTRIBUTEFORMAT;


//
// Instruction Token Bit Definitions
//
#define D3DSI_OPCODE_MASK       0x0000FFFF

typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
{
    D3DSIO_NOP          = 0,    // PS/VS
    D3DSIO_MOV          ,       // PS/VS
    D3DSIO_ADD          ,       // PS/VS
    D3DSIO_SUB          ,       // PS
    D3DSIO_MAD          ,       // PS/VS
    D3DSIO_MUL          ,       // PS/VS
    D3DSIO_RCP          ,       // VS
    D3DSIO_RSQ          ,       // VS
    D3DSIO_DP3          ,       // PS/VS
    D3DSIO_DP4          ,       // VS
    D3DSIO_MIN          ,       // VS
    D3DSIO_MAX          ,       // VS
    D3DSIO_SLT          ,       // VS
    D3DSIO_SGE          ,       // VS
    D3DSIO_EXP          ,       // VS
    D3DSIO_LOG          ,       // VS
    D3DSIO_LIT          ,       // VS
    D3DSIO_DST          ,       // VS
    D3DSIO_LRP          ,       // PS
    D3DSIO_FRC          ,       // VS
    D3DSIO_M4x4         ,       // VS
    D3DSIO_M4x3         ,       // VS
    D3DSIO_M3x4         ,       // VS
    D3DSIO_M3x3         ,       // VS
    D3DSIO_M3x2         ,       // VS

    D3DSIO_TEXCOORD     = 64,   // PS
    D3DSIO_TEXKILL      ,       // PS
    D3DSIO_TEX          ,       // PS
    D3DSIO_TEXBEM       ,       // PS
    D3DSIO_TEXBEML      ,       // PS
    D3DSIO_TEXREG2AR    ,       // PS
    D3DSIO_TEXREG2GB    ,       // PS
    D3DSIO_TEXM3x2PAD   ,       // PS
    D3DSIO_TEXM3x2TEX   ,       // PS
    D3DSIO_TEXM3x3PAD   ,       // PS
    D3DSIO_TEXM3x3TEX   ,       // PS
    D3DSIO_TEXM3x3DIFF  ,       // PS
    D3DSIO_TEXM3x3SPEC  ,       // PS
    D3DSIO_TEXM3x3VSPEC ,       // PS
    D3DSIO_EXPP         ,       // VS
    D3DSIO_LOGP         ,       // VS
    D3DSIO_CND          ,       // PS
    D3DSIO_DEF          ,       // PS
    
    // Xbox Extensions
    D3DSIO_DPH          =256,   // VS
    D3DSIO_RCC          ,       // VS
    D3DSIO_XMMA         ,       // PS
    D3DSIO_XMMC         ,       // PS
    D3DSIO_XDM          ,       // PS
    D3DSIO_XDD          ,       // PS
    D3DSIO_XFC          ,       // PS
    D3DSIO_TEXM3x2DEPTH ,       // PS
    D3DSIO_TEXBRDF      ,       // PS

    D3DSIO_COMMENT      = 0xFFFE,
    D3DSIO_END          = 0xFFFF,

    D3DSIO_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;

//
// Co-Issue Instruction Modifier - if set then this instruction is to be
// issued in parallel with the previous instruction(s) for which this bit
// is not set.
//
#define D3DSI_COISSUE           0x40000000

//
// Parameter Token Bit Definitions
//
#define D3DSP_REGNUM_MASK       0x00000FFF

// destination parameter write mask
#define D3DSP_WRITEMASK_0       0x00010000  // Component 0 (X;Red)
#define D3DSP_WRITEMASK_1       0x00020000  // Component 1 (Y;Green)
#define D3DSP_WRITEMASK_2       0x00040000  // Component 2 (Z;Blue)
#define D3DSP_WRITEMASK_3       0x00080000  // Component 3 (W;Alpha)
#define D3DSP_WRITEMASK_ALL     0x000F0000  // All Components

// destination parameter modifiers
#define D3DSP_DSTMOD_SHIFT      20
#define D3DSP_DSTMOD_MASK       0x00F00000

#define D3DSP_DSTSRC_SHIFT      15          // indicates src or dst
#define D3DSP_DSTSRC_MASK       0x00008000

typedef enum _D3DSHADER_PARAM_DSTMOD_TYPE
{
    D3DSPDM_NONE    = 0<<D3DSP_DSTMOD_SHIFT, // nop
    D3DSPDM_BIAS    = 1<<D3DSP_DSTMOD_SHIFT, // subtract 0.5
    D3DSPDM_FORCE_DWORD  = 0x7fffffff,      // force 32-bit size enum
} D3DSHADER_PARAM_DSTMOD_TYPE;

// destination parameter 
#define D3DSP_DSTSHIFT_SHIFT    24
#define D3DSP_DSTSHIFT_MASK     0x0F000000

// destination/source parameter register type
#define D3DSP_REGTYPE_SHIFT     28
#define D3DSP_REGTYPE_MASK      0x70000000

typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
{
    D3DSPR_TEMP     = 0<<D3DSP_REGTYPE_SHIFT, // Temporary Register File
    D3DSPR_INPUT    = 1<<D3DSP_REGTYPE_SHIFT, // Input Register File
    D3DSPR_CONST    = 2<<D3DSP_REGTYPE_SHIFT, // Constant Register File
    D3DSPR_ADDR     = 3<<D3DSP_REGTYPE_SHIFT, // Address Register (VS)
    D3DSPR_TEXTURE  = 3<<D3DSP_REGTYPE_SHIFT, // Texture Register File (PS)
    D3DSPR_RASTOUT  = 4<<D3DSP_REGTYPE_SHIFT, // Rasterizer Register File
    D3DSPR_ATTROUT  = 5<<D3DSP_REGTYPE_SHIFT, // Attribute Output Register File
    D3DSPR_TEXCRDOUT= 6<<D3DSP_REGTYPE_SHIFT, // Texture Coordinate Output Register File
    D3DSPR_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DSHADER_PARAM_REGISTER_TYPE;

// Register offsets in the Rasterizer Register File
//
typedef enum _D3DVS_RASTOUT_OFFSETS
{
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DVS_RASTOUT_OFFSETS;

// Source operand addressing modes

#define D3DVS_ADDRESSMODE_SHIFT 13
#define D3DVS_ADDRESSMODE_MASK  (3 << D3DVS_ADDRESSMODE_SHIFT)

enum D3DVS_ADRRESSMODE
{
    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),   // Relative to register A0
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
};

// Source operand swizzle definitions
//
#define D3DVS_SWIZZLE_SHIFT     16
#define D3DVS_SWIZZLE_MASK      0x00FF0000

// The following bits define where to take component X:

#define D3DVS_X_X       (0 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Y       (1 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Z       (2 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_W       (3 << D3DVS_SWIZZLE_SHIFT)

// The following bits define where to take component Y:

#define D3DVS_Y_X       (0 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_W       (3 << (D3DVS_SWIZZLE_SHIFT + 2))

// The following bits define where to take component Z:

#define D3DVS_Z_X       (0 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_W       (3 << (D3DVS_SWIZZLE_SHIFT + 4))

// The following bits define where to take component W:

#define D3DVS_W_X       (0 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_W       (3 << (D3DVS_SWIZZLE_SHIFT + 6))

// Value when there is no swizzle (X is taken from X, Y is taken from Y,
// Z is taken from Z, W is taken from W
//
#define D3DVS_NOSWIZZLE (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)

// source parameter swizzle
#define D3DSP_SWIZZLE_SHIFT     16
#define D3DSP_SWIZZLE_MASK      0x00FF0000

#define D3DSP_NOSWIZZLE \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// pixel-shader swizzle ops
#define D3DSP_REPLICATEALPHA \
    ( (3 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// source parameter modifiers
#define D3DSP_SRCMOD_SHIFT      24
#define D3DSP_SRCMOD_MASK       0x0F000000

typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
{
    D3DSPSM_NONE    = 0<<D3DSP_SRCMOD_SHIFT, // nop
    D3DSPSM_NEG     = 1<<D3DSP_SRCMOD_SHIFT, // negate
    D3DSPSM_BIAS    = 2<<D3DSP_SRCMOD_SHIFT, // bias
    D3DSPSM_BIASNEG = 3<<D3DSP_SRCMOD_SHIFT, // bias and negate
    D3DSPSM_SIGN    = 4<<D3DSP_SRCMOD_SHIFT, // sign
    D3DSPSM_SIGNNEG = 5<<D3DSP_SRCMOD_SHIFT, // sign and negate
    D3DSPSM_COMP    = 6<<D3DSP_SRCMOD_SHIFT, // complement
    D3DSPSM_SAT     = 7<<D3DSP_SRCMOD_SHIFT, // saturate

    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
} D3DSHADER_PARAM_SRCMOD_TYPE;

// pixel shader version token
#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))

// vertex shader version token
#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))

// extract major/minor from version cap
#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)

// destination/source parameter register type
#define D3DSI_COMMENTSIZE_SHIFT     16
#define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
#define D3DSHADER_COMMENT(_DWordSize) \
    ((((_DWordSize)<<D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|D3DSIO_COMMENT)

// pixel/vertex shader end token
#define D3DPS_END()  0x0000FFFF
#define D3DVS_END()  0x0000FFFF

//-------------------------------------------------------------------------
// D3D Vertex Shader Microcode Type values:
// --------------
//
// D3DSMT_VERTEXSHADER
//   An ordinary vertex shader.
//
// D3DSMT_READWRITE_VERTEXSHADER
//   A vertex shader that can write to the constant registers.
//
// D3DSMT_VERTEXSTATESHADER
//   A vertex state shader.
//
//-------------------------------------------------------------------------

#define D3DSMT_VERTEXSHADER              1
#define D3DSMT_READWRITE_VERTEXSHADER    2
#define D3DSMT_VERTEXSTATESHADER         3

//---------------------------------------------------------------------

// High order surfaces
//
typedef enum _D3DBASISTYPE
{
   D3DBASIS_BEZIER      = 0,
   D3DBASIS_BSPLINE     = 1,
   D3DBASIS_INTERPOLATE = 2,
   D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;

typedef enum _D3DORDERTYPE
{
   D3DORDER_LINEAR      = 1,
   D3DORDER_CUBIC       = 3,
   D3DORDER_QUINTIC     = 5,
   D3DORDER_FORCE_DWORD = 0x7fffffff,
} D3DORDERTYPE;

typedef enum _D3DPATCHEDGESTYLE
{
   D3DPATCHEDGE_DISCRETE    = 0,
   D3DPATCHEDGE_CONTINUOUS  = 1,
   D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0x7fffffff,
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBF_DISABLE           = 0,     // Disable vertex blending
    D3DVBF_1WEIGHTS          = 1,     // 2 matrix blending
    D3DVBF_2WEIGHTS          = 3,     // 3 matrix blending
    D3DVBF_3WEIGHTS          = 5,     // 4 matrix blending
    D3DVBF_2WEIGHTS2MATRICES = 2,     // Xbox extension
    D3DVBF_3WEIGHTS3MATRICES = 4,     // Xbox extension
    D3DVBF_4WEIGHTS4MATRICES = 6,     // Xbox extension

    D3DVBF_MAX               = 7,
    D3DVBF_FORCE_DWORD       = 0x7fffffff, // force 32-bit size enum
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS 
{
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


//---------------------------------------------------------------------

/* Direct3D8 Device types */
typedef enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL         = 1,
    D3DDEVTYPE_REF         = 2,
    D3DDEVTYPE_SW          = 3,

    D3DDEVTYPE_FORCE_DWORD  = 0x7fffffff
} D3DDEVTYPE;

/* AntiAliasing buffer types */

typedef DWORD D3DMULTISAMPLE_TYPE;

#define D3DMULTISAMPLE_NONE                                      0x0011

// Number of samples, sample type, and filter (Xbox extensions):
//
#define D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR              0x1021
#define D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX            0x1121
#define D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR   0x2021
#define D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR     0x2012
                                                              
#define D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR              0x1022
#define D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN            0x1222
#define D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR              0x2022
#define D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN            0x2222
                                                              
#define D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN            0x1233
#define D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN            0x2233
                                                                  
// Format of the pre-filter (big) color buffer (Xbox extensions):
//                                                          
#define D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT                  0x00000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5                 0x10000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5                   0x20000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8                 0x30000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8                 0x40000 

// Defaults:
//
#define D3DMULTISAMPLE_2_SAMPLES D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMULTISAMPLE_4_SAMPLES D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMULTISAMPLE_9_SAMPLES D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN

/* Types for D3DRS_MULTISAMPLEMODE and D3DRS_MULTISAMPLERENDERTARGETMODE */
typedef enum _D3DMULTISAMPLEMODE
{
    D3DMULTISAMPLEMODE_1X                                   = 0,
    D3DMULTISAMPLEMODE_2X                                   = 1,
    D3DMULTISAMPLEMODE_4X                                   = 2,

    D3DMULTISAMPLEMODE_FORCE_DWORD                          = 0x7fffffff
} D3DMULTISAMPLETYPE;


/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D16 indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */

// DOC: The numerical values for these formats have changed from D3D8
//    : to make the mapping to the NV internal format value easier.
//    : Most noteably is that D3DFMT_UNKNOWN is no longer zero.
//
typedef enum _D3DFORMAT
{
    D3DFMT_UNKNOWN              = 0xFFFFFFFF,

    /* Swizzled formats */

    D3DFMT_A8R8G8B8             = 0x00000006,
    D3DFMT_X8R8G8B8             = 0x00000007,
    D3DFMT_R5G6B5               = 0x00000005,
    D3DFMT_R6G5B5               = 0x00000027,
    D3DFMT_X1R5G5B5             = 0x00000003,
    D3DFMT_A1R5G5B5             = 0x00000002,
    D3DFMT_A4R4G4B4             = 0x00000004,
    D3DFMT_A8                   = 0x00000019,
    D3DFMT_A8B8G8R8             = 0x0000003A,   
    D3DFMT_B8G8R8A8             = 0x0000003B,   
    D3DFMT_R4G4B4A4             = 0x00000039,   
    D3DFMT_R5G5B5A1             = 0x00000038,   
    D3DFMT_R8G8B8A8             = 0x0000003C,   
    D3DFMT_R8B8                 = 0x00000029,   
    D3DFMT_G8B8                 = 0x00000028,   

    D3DFMT_P8                   = 0x0000000B,

    D3DFMT_L8                   = 0x00000000,
    D3DFMT_A8L8                 = 0x0000001A,
    D3DFMT_AL8                  = 0x00000001,   
    D3DFMT_L16                  = 0x00000032,   

    D3DFMT_V8U8                 = 0x00000028,
    D3DFMT_L6V5U5               = 0x00000027,
    D3DFMT_X8L8V8U8             = 0x00000007,
    D3DFMT_Q8W8V8U8             = 0x0000003A,
    D3DFMT_V16U16               = 0x00000033,

    D3DFMT_D16_LOCKABLE         = 0x0000002C,
    D3DFMT_D16                  = 0x0000002C,
    D3DFMT_D24S8                = 0x0000002A,
    D3DFMT_F16                  = 0x0000002D,   
    D3DFMT_F24S8                = 0x0000002B,

    /* YUV formats */

    D3DFMT_YUY2                 = 0x00000024,
    D3DFMT_UYVY                 = 0x00000025,

    /* Compressed formats */

    D3DFMT_DXT1                 = 0x0000000C,
    D3DFMT_DXT2                 = 0x0000000E,
    D3DFMT_DXT3                 = 0x0000000E,
    D3DFMT_DXT4                 = 0x0000000F,
    D3DFMT_DXT5                 = 0x0000000F,

    /* Linear formats */

    D3DFMT_LIN_A1R5G5B5         = 0x00000010,   
    D3DFMT_LIN_A4R4G4B4         = 0x0000001D,   
    D3DFMT_LIN_A8               = 0x0000001F,   
    D3DFMT_LIN_A8B8G8R8         = 0x0000003F,   
    D3DFMT_LIN_A8R8G8B8         = 0x00000012,   
    D3DFMT_LIN_B8G8R8A8         = 0x00000040,   
    D3DFMT_LIN_G8B8             = 0x00000017,   
    D3DFMT_LIN_R4G4B4A4         = 0x0000003E,   
    D3DFMT_LIN_R5G5B5A1         = 0x0000003D,   
    D3DFMT_LIN_R5G6B5           = 0x00000011,   
    D3DFMT_LIN_R6G5B5           = 0x00000037,   
    D3DFMT_LIN_R8B8             = 0x00000016,   
    D3DFMT_LIN_R8G8B8A8         = 0x00000041,   
    D3DFMT_LIN_X1R5G5B5         = 0x0000001C,   
    D3DFMT_LIN_X8R8G8B8         = 0x0000001E,   

    D3DFMT_LIN_A8L8             = 0x00000020,   
    D3DFMT_LIN_AL8              = 0x0000001B,   
    D3DFMT_LIN_L16              = 0x00000035,   
    D3DFMT_LIN_L8               = 0x00000013,   

    D3DFMT_LIN_V16U16           = 0x00000036,
    D3DFMT_LIN_V8U8             = 0x00000017,
    D3DFMT_LIN_L6V5U5           = 0x00000037,
    D3DFMT_LIN_X8L8V8U8         = 0x0000001E,
    D3DFMT_LIN_Q8W8V8U8         = 0x00000012,

    D3DFMT_LIN_D24S8            = 0x0000002E,   
    D3DFMT_LIN_F24S8            = 0x0000002F,   
    D3DFMT_LIN_D16              = 0x00000030,   
    D3DFMT_LIN_F16              = 0x00000031,   

    D3DFMT_VERTEXDATA           = 100,
    D3DFMT_INDEX16              = 101,

    D3DFMT_FORCE_DWORD          =0x7fffffff
} D3DFORMAT;

/* Display mode flags */

#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER      0x00000001
#define D3DPRESENTFLAG_WIDESCREEN               0x00000010
#define D3DPRESENTFLAG_INTERLACED               0x00000020
#define D3DPRESENTFLAG_PROGRESSIVE              0x00000040
#define D3DPRESENTFLAG_FIELD                    0x00000080
#define D3DPRESENTFLAG_10X11PIXELASPECTRATIO    0x00000100

/* Display Modes */
typedef struct _D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    DWORD           Flags;
    D3DFORMAT       Format;
} D3DDISPLAYMODE;

/* Creation Parameters */
typedef struct _D3DDEVICE_CREATION_PARAMETERS
{
    UINT            AdapterOrdinal;
    D3DDEVTYPE      DeviceType;
    HWND            hFocusWindow;
    DWORD           BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;


/* SwapEffects */
typedef enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD           = 1,
    D3DSWAPEFFECT_FLIP              = 2,
    D3DSWAPEFFECT_COPY              = 3,
    D3DSWAPEFFECT_COPY_VSYNC        = 4,

    D3DSWAPEFFECT_FORCE_DWORD       = 0x7fffffff
} D3DSWAPEFFECT;

/* Swap flags (Xbox extension) */
#define D3DSWAP_COPY                0x00000001L
#define D3DSWAP_BYPASSCOPY          0x00000002L
#define D3DSWAP_FINISH              0x00000004L

#define D3DSWAP_DEFAULT             0x00000000L

/* Insert Callback (Xbox extension) */
typedef enum _D3DCALLBACKTYPE
{
    D3DCALLBACK_READ                = 0,
    D3DCALLBACK_WRITE               = 1,

    D3DCALLBACKTYPE_FORCE_DWORD     = 0x7fffffff
} D3DCALLBACKTYPE;

/* VBlank data (Xbox extension) */
#define D3DVBLANK_SWAPDONE          0x00000001L
#define D3DVBLANK_SWAPMISSED        0x00000002L

typedef struct _D3DVBLANKDATA
{
    DWORD           VBlank;
    DWORD           Swap;
    DWORD           Flags;
} D3DVBLANKDATA;

/* Swap data (Xbox extension) */
typedef struct _D3DSWAPDATA
{
    DWORD           Swap;
    DWORD           SwapVBlank;
    DWORD           MissedVBlanks;
    DWORD           TimeUntilSwapVBlank;
    DWORD           TimeBetweenSwapVBlanks;
} D3DSWAPDATA;

/* Pool types */

// DOC: All parameters typed as D3DPOOL will be ignored.  Change the type from an enum
//  : to a DWORD so developers can cheat and just pass '0' for this value.

typedef DWORD D3DPOOL;

#define D3DPOOL_DEFAULT             0
#define D3DPOOL_MANAGED             1
#define D3DPOOL_SYSTEMMEM           2

/* RefreshRate pre-defines */
#define D3DPRESENT_RATE_DEFAULT         0x00000000
#define D3DPRESENT_RATE_UNLIMITED       0x00000000


/* Reset and CreateDevice Parameters */
typedef struct _D3DPRESENT_PARAMETERS_
{
    UINT                BackBufferWidth;
    UINT                BackBufferHeight;
    D3DFORMAT           BackBufferFormat;
    UINT                BackBufferCount;
    D3DMULTISAMPLE_TYPE MultiSampleType;
    D3DSWAPEFFECT       SwapEffect;
    HWND                hDeviceWindow;
    BOOL                Windowed;
    BOOL                EnableAutoDepthStencil;
    D3DFORMAT           AutoDepthStencilFormat;
    DWORD               Flags;
    UINT                FullScreen_RefreshRateInHz; 
    UINT                FullScreen_PresentationInterval;
    D3DSurface         *BufferSurfaces[3];
    D3DSurface         *DepthStencilSurface;

} D3DPRESENT_PARAMETERS;

/* Gamma Ramp: Xbox changes WORD values to BYTE */

typedef struct _D3DGAMMARAMP
{
    BYTE                red  [256];
    BYTE                green[256];
    BYTE                blue [256];
} D3DGAMMARAMP;

/* Back buffer types */
typedef DWORD D3DBACKBUFFER_TYPE;

#define D3DBACKBUFFER_TYPE_MONO   0


/* Types */
typedef enum _D3DRESOURCETYPE 
{
    D3DRTYPE_NONE                   =  0,
    D3DRTYPE_SURFACE                =  1,
    D3DRTYPE_VOLUME                 =  2,
    D3DRTYPE_TEXTURE                =  3,
    D3DRTYPE_VOLUMETEXTURE          =  4,
    D3DRTYPE_CUBETEXTURE            =  5,
    D3DRTYPE_VERTEXBUFFER           =  6,
    D3DRTYPE_INDEXBUFFER            =  7,
    D3DRTYPE_PUSHBUFFER             =  8,
    D3DRTYPE_PALETTE                =  9,
    D3DRTYPE_FIXUP                  =  10,

    D3DRTYPE_FORCE_DWORD            = 0x7fffffff
} D3DRESOURCETYPE;

/* Locations */

// Enumeration used for memory movement (Xbox extension)
//
typedef enum _D3DMEMORY 
{
    D3DMEM_AGP                      = 0,
    D3DMEM_VIDEO                    = 1
} D3DMEMORY;

/* Usages */
#define D3DUSAGE_RENDERTARGET           (0x00000001L)
#define D3DUSAGE_DEPTHSTENCIL           (0x00000002L)

/* Usages for Vertex/Index buffers */
#define D3DUSAGE_WRITEONLY              (0x00000008L)
#define D3DUSAGE_POINTS                 (0x00000040L)
#define D3DUSAGE_RTPATCHES              (0x00000080L)
#define D3DUSAGE_DYNAMIC                (0x00000200L)

/* Usages for CreateVertexShader */
#define D3DUSAGE_PERSISTENTDIFFUSE      (0x00000400L)   // Xbox extension
#define D3DUSAGE_PERSISTENTSPECULAR     (0x00000800L)   // Xbox extension
#define D3DUSAGE_PERSISTENTBACKDIFFUSE  (0x00001000L)   // Xbox extension
#define D3DUSAGE_PERSISTENTBACKSPECULAR (0x00002000L)   // Xbox extension

/* Usages for CreateTexture/CreateImageSurface */
#define D3DUSAGE_BORDERSOURCE_COLOR     (0x00000000L)   // Xbox extension
#define D3DUSAGE_BORDERSOURCE_TEXTURE   (0x00010000L)   // Xbox extension


/* CubeMap Face identifiers */
typedef enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X     = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X     = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y     = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y     = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z     = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z     = 5,

    D3DCUBEMAP_FACE_FORCE_DWORD    = 0x7fffffff
} D3DCUBEMAP_FACES;


/* Lock flags */

#define D3DLOCK_NOFLUSH             0x00000010L // Xbox extension
#define D3DLOCK_NOOVERWRITE         0x00000020L 
#define D3DLOCK_TILED               0x00000040L // Xbox extension
#define D3DLOCK_READONLY            0x00000080L

// D3DLOCK_NOSYSLOCK not supported on Xbox
// D3DLOCK_NO_DIRTY_UPDATE not supported on Xbox
// D3DLOCK_DISCARD not supported on Xbox 
//
//     (NOTE: The lack of D3DLOCK_DISCARD support can cause significant 
//      performance degradation for the unwary.  See the documentation
//      for notes on using IsBusy or fences in order to manage your own
//      pool of temporary vertex buffers when generating vertex data
//      dynamically.)

/* Vertex Buffer Description */
typedef struct _D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;

} D3DVERTEXBUFFER_DESC;

/* Index Buffer Description */
typedef struct _D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
} D3DINDEXBUFFER_DESC;


/* Surface Description */
typedef struct _D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC;

typedef struct _D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC;

/* Structure for LockRect */
typedef struct _D3DLOCKED_RECT
{
    INT                 Pitch;
    void*               pBits;
} D3DLOCKED_RECT;

/* Structures for LockBox */
typedef struct _D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX;

typedef struct _D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    void*               pBits;
} D3DLOCKED_BOX;

/* Structures for high order primitives */
typedef struct _D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DRECTPATCH_INFO;

typedef struct _D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DTRIPATCH_INFO;

/* Adapter Identifier */
#define MAX_DEVICE_IDENTIFIER_STRING        512
typedef struct _D3DADAPTER_IDENTIFIER8
{
    char            Driver[MAX_DEVICE_IDENTIFIER_STRING];
    char            Description[MAX_DEVICE_IDENTIFIER_STRING];

#ifdef _WIN32
    LARGE_INTEGER   DriverVersion;            /* Defined for 32 bit components */
#else
    DWORD           DriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD           DriverVersionHighPart;
#endif

    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;

    GUID            DeviceIdentifier;

    DWORD           WHQLLevel;

} D3DADAPTER_IDENTIFIER8;


/* Raster Status structure returned by GetRasterStatus */
typedef struct _D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS;


/* Field Type enum defines possible values for a display field */
typedef enum _D3DFIELDTYPE                      // Xbox extension
{                    
    D3DFIELD_ODD            = 1,
    D3DFIELD_EVEN           = 2,
    D3DFIELD_PROGRESSIVE    = 3,
    D3DFIELD_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DFIELDTYPE;


/* Field Status structure is returned by GetDisplayFieldStatus */
typedef struct _D3DFIELD_STATUS                 // Xbox extension
{
    D3DFIELDTYPE   Field;
    UINT           VBlankCount;
} D3DFIELD_STATUS;


/* SetVertexInput struct */
typedef struct _D3DSTREAM_INPUT                 // Xbox extension
{
    D3DVertexBuffer    *VertexBuffer;
    UINT                Stride;
    UINT                Offset;
} D3DSTREAM_INPUT;


/* Maximum number of scissors rectangles */     
#define D3DSCISSORS_MAX             8

/* D3DTILE constants */
#define D3DTILE_MAXTILES            8
#define D3DTILE_MAXTAGS             76800
#define D3DTILE_TAGSIZE             64
#define D3DTILE_ALIGNMENT           0x4000

/* D3DTILE macro for calculating the end tag for a Z-compressed tile */
#define D3DTILE_ZENDTAG(pTile) ((((pTile)->ZStartTag + ((pTile)->Size / D3DTILE_TAGSIZE)) + 255) & ~255)

/* D3DTILE Flags */
#define D3DTILE_FLAGS_ZBUFFER       0x00000001
#define D3DTILE_FLAGS_ZCOMPRESS     0x80000000
#define D3DTILE_FLAGS_Z32BITS       0x04000000
#define D3DTILE_FLAGS_Z16BITS       0x00000000

/* D3DTILE Pitch values */
#define D3DTILE_PITCH_0200          0x0200
#define D3DTILE_PITCH_0300          0x0300
#define D3DTILE_PITCH_0400          0x0400
#define D3DTILE_PITCH_0500          0x0500
#define D3DTILE_PITCH_0600          0x0600
#define D3DTILE_PITCH_0700          0x0700
#define D3DTILE_PITCH_0800          0x0800
#define D3DTILE_PITCH_0A00          0x0A00
#define D3DTILE_PITCH_0C00          0x0C00
#define D3DTILE_PITCH_0E00          0x0E00
#define D3DTILE_PITCH_1000          0x1000
#define D3DTILE_PITCH_1400          0x1400
#define D3DTILE_PITCH_1800          0x1800
#define D3DTILE_PITCH_1C00          0x1C00
#define D3DTILE_PITCH_2000          0x2000
#define D3DTILE_PITCH_2800          0x2800
#define D3DTILE_PITCH_3000          0x3000
#define D3DTILE_PITCH_3800          0x3800
#define D3DTILE_PITCH_4000          0x4000
#define D3DTILE_PITCH_5000          0x5000
#define D3DTILE_PITCH_6000          0x6000
#define D3DTILE_PITCH_7000          0x7000
#define D3DTILE_PITCH_8000          0x8000
#define D3DTILE_PITCH_A000          0xA000
#define D3DTILE_PITCH_C000          0xC000
#define D3DTILE_PITCH_E000          0xE000

/* SetTile struct */
typedef struct _D3DTILE                         // Xbox extension
{                   
    DWORD   Flags;
    void*   pMemory;
    DWORD   Size;
    DWORD   Pitch;
    DWORD   ZStartTag; 
    DWORD   ZOffset;
} D3DTILE;

/* CopyRectsState Operation values */
typedef enum _D3DCOPYRECTOPERATION
{
    D3DCOPYRECT_SRCCOPY_AND         = 0,
    D3DCOPYRECT_ROP_AND             = 1,
    D3DCOPYRECT_BLEND_AND           = 2,
    D3DCOPYRECT_SRCCOPY             = 3,
    D3DCOPYRECT_SRCCOPY_PREMULT     = 4,
    D3DCOPYRECT_BLEND_PREMULT       = 5,
    D3DCOPYRECT_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCOPYRECTOPERATION;

/* CopyRectsState Color Format values */
typedef enum _D3DCOPYRECTCOLORFORMAT
{
    D3DCOPYRECT_COLOR_FORMAT_DEFAULT                 = 0,
    D3DCOPYRECT_COLOR_FORMAT_Y8                      = 1,
    D3DCOPYRECT_COLOR_FORMAT_X1R5G5B5_Z1R5G5B5       = 2,
    D3DCOPYRECT_COLOR_FORMAT_X1R5G5B5_O1R5G5B5       = 3,
    D3DCOPYRECT_COLOR_FORMAT_R5G6B5                  = 4,
    D3DCOPYRECT_COLOR_FORMAT_Y16                     = 5,
    D3DCOPYRECT_COLOR_FORMAT_X8R8G8B8_Z8R8G8B8       = 6,
    D3DCOPYRECT_COLOR_FORMAT_X8R8G8B8_O8R8G8B8       = 7,
    D3DCOPYRECT_COLOR_FORMAT_X1A7R8G8B8_Z1A7R8G8B8   = 8,
    D3DCOPYRECT_COLOR_FORMAT_X1A7R8G8B8_O1A7R8G8B8   = 9,
    D3DCOPYRECT_COLOR_FORMAT_A8R8G8B8                = 10,
    D3DCOPYRECT_COLOR_FORMAT_Y32                     = 11,
    D3DCOPYRECT_COLOR_FORMAT_FORCE_DWORD             = 0x7fffffff, /* force 32-bit size enum */
} D3DCOPYRECTCOLORFORMAT;

/* CopyRectsState struct */
typedef struct _D3DCOPYRECTSTATE                // Xbox extension
{
    D3DCOPYRECTCOLORFORMAT ColorFormat;
    D3DCOPYRECTOPERATION Operation;

    BOOL ColorKeyEnable;
    DWORD ColorKeyValue;

    // D3DCOPYRECT_BLEND_AND alpha value 
    // The VALUE_FRACTION bits (30:21) contain the 10 bit unsigned fraction of the alpha value.
    // The VALUE bits (31:31) contain the 1 bit signed integer of the alpha value.
    DWORD BlendAlpha;

    // D3DCOPYRECT_*_PREMULT alpha value
    // Contains an alpha value for all four channels.
    DWORD PremultAlpha;

    // Clipping Rect
    DWORD ClippingPoint;    // y_x S16_S16
    DWORD ClippingSize;     // height_width U16_U16

} D3DCOPYRECTSTATE;

/* CopyRectRopState struct */
typedef struct _D3DCOPYRECTROPSTATE             // Xbox extension
{
    DWORD Rop;              // Ternary raster operation.
                            //   DSTINVERT:0x55, SRCCOPY:0xCC,
                            //   SRCPAINT:0xEE, SRCINVERT:0x66,
                            //   ...

    DWORD Shape;            // 0:8X_8Y, 1:64X_1Y, 2:1X_64Y
    DWORD PatternSelect;    // 1:monochrome, 2:color

    DWORD MonoColor0;       // Color to use when bit is "0"
    DWORD MonoColor1;       // Color to use when bit is "1" 

    DWORD MonoPattern0;     // 8x8 = 64 bit pattern
    DWORD MonoPattern1;     //

    CONST DWORD *ColorPattern;  // Color Pattern used if PatternSelect == color
                                // 32-bit: Array of 64 DWORDS
                                // 16-bit: Array of 32 DWORDS

} D3DCOPYRECTROPSTATE;

/*----------------------------------------------
/* Pixel Shader Binary Format
/*----------------------------------------------

/*---------------------------------------------------*/
/*  This structure holds all of the state necessary  */
/*  to define an Xbox Pixel Shader.  It is the       */
/*  structure generated when a pixel shader is       */
/*  assembled.  Each member of this structure        */
/*  corresponds to a D3D Renderstate that can be     */
/*  set at any time using the SetRenderState()       */
/*  method.                                          */
/*  The members of this structure have been ordered  */
/*  to enable the most efficient hardware load       */
/*  possible.                                        */
/*---------------------------------------------------*/

typedef struct _D3DPixelShaderDef
{
   DWORD    PSAlphaInputs[8];          // Alpha inputs for each stage
   DWORD    PSFinalCombinerInputsABCD; // Final combiner inputs
   DWORD    PSFinalCombinerInputsEFG;  // Final combiner inputs (continued)
   DWORD    PSConstant0[8];            // C0 for each stage
   DWORD    PSConstant1[8];            // C1 for each stage
   DWORD    PSAlphaOutputs[8];         // Alpha output for each stage
   DWORD    PSRGBInputs[8];            // RGB inputs for each stage
   DWORD    PSCompareMode;             // Compare modes for clipplane texture mode
   DWORD    PSFinalCombinerConstant0;  // C0 in final combiner
   DWORD    PSFinalCombinerConstant1;  // C1 in final combiner
   DWORD    PSRGBOutputs[8];           // Stage 0 RGB outputs
   DWORD    PSCombinerCount;           // Active combiner count (Stages 0-7)
   DWORD    PSTextureModes;            // Texture addressing modes
   DWORD    PSDotMapping;              // Input mapping for dot product modes
   DWORD    PSInputTexture;            // Texture source for some texture modes
   DWORD    PSC0Mapping;               // Mapping of c0 regs to D3D constants
   DWORD    PSC1Mapping;               // Mapping of c1 regs to D3D constants
   DWORD    PSFinalCombinerConstants;  // Final combiner constant mapping
} D3DPIXELSHADERDEF;

/*---------------------------------------------------------------------------*/
/*  Texture configuration - The following members of the D3DPixelShaderDef   */
/*  structure define the addressing modes of each of the four texture stages:*/
/*      PSTextureModes                                                       */
/*      PSDotMapping                                                         */
/*      PSInputTexture                                                       */
/*      PSCompareMode                                                        */
/*---------------------------------------------------------------------------*/

// =========================================================================================================
// PSTextureModes
// --------.--------.--------.---xxxxx stage0
// --------.--------.------xx.xxx----- stage1
// --------.--------.-xxxxx--.-------- stage2
// --------.----xxxx.x-------.-------- stage3

#define PS_TEXTUREMODES(t0,t1,t2,t3) (((t3)<<15)|((t2)<<10)|((t1)<<5)|(t0))

/*
Texture modes:
NONE           :stage inactive
PROJECT2D      :argb = texture(s/q, t/q)
PROJECT3D      :argb = texture(s/q, t/q, r/q)
CUBEMAP        :argb = cubemap(s,t,r)
PASSTHRU       :argb = s,t,r,q
CLIPPLANE      :pixel not drawn if s,t,r, or q < 0.  PSCompareMode affects comparison
BUMPENVMAP     :argb=texture(s+mat00*src.r+mat01*src.g,
                             t+mat10*src.r+mat11*src.g)
                mat00 set via D3DTSS_BUMPENVMAT00, etc.
BUMPENVMAP_LUM :argb=texture(s+mat00*src.r+mat01*src.g, 
                             t+mat10*src.r+mat11*src.g) * (lum_scale*src.b + lum_bias)
                lum_scale set by D3DTSS_BUMPENVLSCALE
                lum_bias set by D3DTSS_BUMPENVLOFFSET
                mat00 set via D3DTSS_BUMPENVMAT00, etc.
BRDF           :argb = texture(eyeSigma, lightSigma, dPhi)
                       eyeSigma = Sigma of eye vector in spherical coordinates
                       lightSigma = Sigma of light vector in spherical coordinates
                       dPhi = Phi of eye - Phi of light
DOT_ST         :argb = texture(<DotResult of stage-1>, (s,t,r).(src.r,src.g,src.b))
DOT_ZW         :frag depth = (<DotResult of stage-1>/((s,t,r).(src.r,src.g,src.b))
DOT_RFLCT_DIFF :n = (<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b),<DotResult of stage+1>)
                argb = cubemap(n)
DOT_RFLCT_SPEC :n = (<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b))
                r = 2*n*(n.e)/(n.n) - e where e is eye vector built from q coord of each stage
                argb = cubemap(r)
DOT_STR_3D     :argb=texture((<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b)))
DOT_STR_CUBE   :argb=cubemap((<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b)))
DEPENDENT_AR   :argb = texture(src.a, src.r) 
DEPENDENT_GB   :argb = texture(src.g, src.b)
DOTPRODUCT     :argb = (s,t,r).(src.r,src.g,src.b)
DOT_RFLCT_SPEC_CONST :n = (<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b))
                r = 2*n*(n.e)/(n.n) - e where e is eye vector set via SetEyeVector()
                argb = cubemap(r)
*/

enum PS_TEXTUREMODES
{                                 // valid in stage 0 1 2 3
    PS_TEXTUREMODES_NONE=                 0x00L, // * * * *
    PS_TEXTUREMODES_PROJECT2D=            0x01L, // * * * *
    PS_TEXTUREMODES_PROJECT3D=            0x02L, // * * * *
    PS_TEXTUREMODES_CUBEMAP=              0x03L, // * * * *
    PS_TEXTUREMODES_PASSTHRU=             0x04L, // * * * *
    PS_TEXTUREMODES_CLIPPLANE=            0x05L, // * * * *
    PS_TEXTUREMODES_BUMPENVMAP=           0x06L, // - * * *
    PS_TEXTUREMODES_BUMPENVMAP_LUM=       0x07L, // - * * *
    PS_TEXTUREMODES_BRDF=                 0x08L, // - - * *
    PS_TEXTUREMODES_DOT_ST=               0x09L, // - - * *
    PS_TEXTUREMODES_DOT_ZW=               0x0aL, // - - * *
    PS_TEXTUREMODES_DOT_RFLCT_DIFF=       0x0bL, // - - * -
    PS_TEXTUREMODES_DOT_RFLCT_SPEC=       0x0cL, // - - - *
    PS_TEXTUREMODES_DOT_STR_3D=           0x0dL, // - - - *
    PS_TEXTUREMODES_DOT_STR_CUBE=         0x0eL, // - - - *
    PS_TEXTUREMODES_DPNDNT_AR=            0x0fL, // - * * *
    PS_TEXTUREMODES_DPNDNT_GB=            0x10L, // - * * *
    PS_TEXTUREMODES_DOTPRODUCT=           0x11L, // - * * -
    PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST= 0x12L, // - - - *
    // 0x13-0x1f reserved
};


// =========================================================================================================
// PSDotMapping
// --------.--------.--------.-----xxx // stage1
// --------.--------.--------.-xxx---- // stage2
// --------.--------.-----xxx.-------- // stage3

#define PS_DOTMAPPING(t0,t1,t2,t3) (((t3)<<8)|((t2)<<4)|(t1))

// Mappings:
// ZERO_TO_ONE         :rgb->(r,g,b): 0x0=>0.0, 0xff=>1.0
// MINUS1_TO_1_D3D     :rgb->(r,g,b): 0x0=>-128/127, 0x01=>-1.0, 0x80=>0.0, 0xff=>1.0
// MINUS1_TO_1_GL      :rgb->(r,g,b): 0x80=>-1.0, 0x7f=>1.0
// MINUS1_TO_1         :rgb->(r,g,b): 0x80=>-128/127, 0x81=>-1.0, 0x0=>0.0, 0x7f=>1.0
// HILO_1              :HL->(H,L,1.0): 0x0000=>0.0, 0xffff=>1.0
// HILO_HEMISPHERE_D3D :HL->(H,L,sqrt(1-H*H-L*L)): 0x8000=>-1.0, 0x0=>0.0, 0x7fff=32767/32768
// HILO_HEMISPHERE_GL  :HL->(H,L,sqrt(1-H*H-L*L)): 0x8000=>-1.0, 0x7fff=>1.0
// HILO_HEMISPHERE     :HL->(H,L,sqrt(1-H*H-L*L)): 0x8001=>-1.0, 0x0=>0.0, 0x7fff=>1.0, 0x8000=>-32768/32767

enum PS_DOTMAPPING
{                              // valid in stage 0 1 2 3
    PS_DOTMAPPING_ZERO_TO_ONE=         0x00L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1_D3D=     0x01L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1_GL=      0x02L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1=         0x03L, // - * * *
    PS_DOTMAPPING_HILO_1=              0x04L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE_D3D= 0x05L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE_GL=  0x06L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE=     0x07L, // - * * *
};

// =========================================================================================================
// PSCompareMode
// --------.--------.--------.----xxxx // stage0
// --------.--------.--------.xxxx---- // stage1
// --------.--------.----xxxx.-------- // stage2
// --------.--------.xxxx----.-------- // stage3

#define PS_COMPAREMODE(t0,t1,t2,t3) (((t3)<<12)|((t2)<<8)|((t1)<<4)|(t0))

enum PS_COMPAREMODE
{
    PS_COMPAREMODE_S_LT= 0x00L,
    PS_COMPAREMODE_S_GE= 0x01L,
    
    PS_COMPAREMODE_T_LT= 0x00L,
    PS_COMPAREMODE_T_GE= 0x02L,
    
    PS_COMPAREMODE_R_LT= 0x00L,
    PS_COMPAREMODE_R_GE= 0x04L,
    
    PS_COMPAREMODE_Q_LT= 0x00L,
    PS_COMPAREMODE_Q_GE= 0x08L,
};

// =========================================================================================================
// PSInputTexture
// --------.-------x.--------.-------- // stage2
// --------.--xx----.--------.-------- // stage3
//
// Selects the other texture to use as an input in the following texture modes:
// DOT_ST, DOT_STR_3D, DOT_STR_CUBE, DOT_ZW, DOT_RFLCT_SPEC, 
// DOT_RFLCT_DIFF, DPNDNT_AR, DPNDNT_GB, BUMPENVMAP,
// BUMPENVMAP_LUM, DOT_PRODUCT

#define PS_INPUTTEXTURE(t0,t1,t2,t3) (((t3)<<20)|((t2)<<16))


/*---------------------------------------------------------------------------------*/
/*  Color combiners - The following members of the D3DPixelShaderDef structure     */
/*  define the state for the eight stages of color combiners:                      */
/*      PSCombinerCount - Number of stages                                         */
/*      PSAlphaInputs[8] - Inputs for alpha portion of each stage                  */
/*      PSRGBInputs[8] - Inputs for RGB portion of each stage                      */
/*      PSConstant0[8] - Constant 0 for each stage                                 */
/*      PSConstant1[8] - Constant 1 for each stage                                 */
/*      PSFinalCombinerConstant0 - Constant 0 for final combiner                   */
/*      PSFinalCombinerConstant1 - Constant 1 for final combiner                   */
/*      PSAlphaOutputs[8] - Outputs for alpha portion of each stage                */
/*      PSRGBOutputs[8] - Outputs for RGB portion of each stage                    */
/*---------------------------------------------------------------------------------*/


// =========================================================================================================
// PSCombinerCount
// --------.--------.--------.----xxxx // number of combiners (1-8)
// --------.--------.-------x.-------- // mux bit (0= LSB, 1= MSB)
// --------.--------.---x----.-------- // separate C0
// --------.-------x.--------.-------- // separate C1

#define PS_COMBINERCOUNT(count, flags) (((flags)<<8)|(count))
// count is 1-8, flags contains one or more values from PS_COMBINERCOUNTFLAGS

enum PS_COMBINERCOUNTFLAGS
{
    PS_COMBINERCOUNT_MUX_LSB=     0x0000L, // mux on r0.a lsb
    PS_COMBINERCOUNT_MUX_MSB=     0x0001L, // mux on r0.a msb
    
    PS_COMBINERCOUNT_SAME_C0=     0x0000L, // c0 same in each stage
    PS_COMBINERCOUNT_UNIQUE_C0=   0x0010L, // c0 unique in each stage
    
    PS_COMBINERCOUNT_SAME_C1=     0x0000L, // c1 same in each stage
    PS_COMBINERCOUNT_UNIQUE_C1=   0x0100L  // c1 unique in each stage
};


// =========================================================================================================
// PSRGBInputs[0-7]
// PSAlphaInputs[0-7]
// PSFinalCombinerInputsABCD
// PSFinalCombinerInputsEFG
// --------.--------.--------.----xxxx // D register
// --------.--------.--------.---x---- // D channel (0= RGB/BLUE, 1= ALPHA)
// --------.--------.--------.xxx----- // D input mapping
// --------.--------.----xxxx.-------- // C register
// --------.--------.---x----.-------- // C channel (0= RGB/BLUE, 1= ALPHA)
// --------.--------.xxx-----.-------- // C input mapping
// --------.----xxxx.--------.-------- // B register
// --------.---x----.--------.-------- // B channel (0= RGB/BLUE, 1= ALPHA)
// --------.xxx-----.--------.-------- // B input mapping
// ----xxxx.--------.--------.-------- // A register
// ---x----.--------.--------.-------- // A channel (0= RGB/BLUE, 1= ALPHA)
// xxx-----.--------.--------.-------- // A input mapping

// examples:
// 
// shader.PSRGBInputs[3]= PS_COMBINERINPUTS(
//     PS_REGISTER_T0 | PS_INPUTMAPPING_EXPAND_NORMAL     | PS_CHANNEL_RGB,
//     PS_REGISTER_C0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
//     PS_REGISTER_ZERO,
//     PS_REGISTER_ZERO);
// 
// shader.PSFinalCombinerInputsABCD= PS_COMBINERINPUTS(
//     PS_REGISTER_T0     | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
//     PS_REGISTER_ZERO   | PS_INPUTMAPPING_EXPAND_NORMAL     | PS_CHANNEL_RGB,
//     PS_REGISTER_EFPROD | PS_INPUTMAPPING_UNSIGNED_INVERT   | PS_CHANNEL_RGB,
//     PS_REGISTER_ZERO);
//
// PS_FINALCOMBINERSETTING is set in 4th field of PSFinalCombinerInputsEFG with PS_COMBINERINPUTS
// example:
// 
// shader.PSFinalCombinerInputsEFG= PS_COMBINERINPUTS(
//     PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
//     PS_REGISTER_R1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
//     PS_REGISTER_R1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_BLUE,
//    PS_FINALCOMBINERSETTING_CLAMP_SUM | PS_FINALCOMBINERSETTING_COMPLEMENT_R0);

#define PS_COMBINERINPUTS(a,b,c,d) (((a)<<24)|((b)<<16)|((c)<<8)|(d))
// For PSFinalCombinerInputsEFG,
//     a,b,c contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING for input E,F, and G
//     d contains values from PS_FINALCOMBINERSETTING
// For all other inputs,
//     a,b,c,d each contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING

enum PS_INPUTMAPPING
{
    PS_INPUTMAPPING_UNSIGNED_IDENTITY= 0x00L, // max(0,x)         OK for final combiner
    PS_INPUTMAPPING_UNSIGNED_INVERT=   0x20L, // 1 - max(0,x)     OK for final combiner
    PS_INPUTMAPPING_EXPAND_NORMAL=     0x40L, // 2*max(0,x) - 1   invalid for final combiner
    PS_INPUTMAPPING_EXPAND_NEGATE=     0x60L, // 1 - 2*max(0,x)   invalid for final combiner
    PS_INPUTMAPPING_HALFBIAS_NORMAL=   0x80L, // max(0,x) - 1/2   invalid for final combiner
    PS_INPUTMAPPING_HALFBIAS_NEGATE=   0xa0L, // 1/2 - max(0,x)   invalid for final combiner
    PS_INPUTMAPPING_SIGNED_IDENTITY=   0xc0L, // x                invalid for final combiner
    PS_INPUTMAPPING_SIGNED_NEGATE=     0xe0L, // -x               invalid for final combiner
};

enum PS_REGISTER
{
    PS_REGISTER_ZERO=              0x00L, // r    
    PS_REGISTER_DISCARD=           0x00L, // w
    PS_REGISTER_C0=                0x01L, // r
    PS_REGISTER_C1=                0x02L, // r
    PS_REGISTER_FOG=               0x03L, // r
    PS_REGISTER_V0=                0x04L, // r/w  
    PS_REGISTER_V1=                0x05L, // r/w
    PS_REGISTER_T0=                0x08L, // r/w
    PS_REGISTER_T1=                0x09L, // r/w
    PS_REGISTER_T2=                0x0aL, // r/w
    PS_REGISTER_T3=                0x0bL, // r/w
    PS_REGISTER_R0=                0x0cL, // r/w
    PS_REGISTER_R1=                0x0dL, // r/w
    PS_REGISTER_V1R0_SUM=          0x0eL, // r
    PS_REGISTER_EF_PROD=           0x0fL, // r
    
    PS_REGISTER_ONE=               PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT, // OK for final combiner
    PS_REGISTER_NEGATIVE_ONE=      PS_REGISTER_ZERO | PS_INPUTMAPPING_EXPAND_NORMAL,   // invalid for final combiner
    PS_REGISTER_ONE_HALF=          PS_REGISTER_ZERO | PS_INPUTMAPPING_HALFBIAS_NEGATE, // invalid for final combiner
    PS_REGISTER_NEGATIVE_ONE_HALF= PS_REGISTER_ZERO | PS_INPUTMAPPING_HALFBIAS_NORMAL, // invalid for final combiner
};

// FOG ALPHA is only available in final combiner
// V1R0_SUM and EF_PROD are only available in final combiner (A,B,C,D inputs only)
// V1R0_SUM_ALPHA and EF_PROD_ALPHA are not available
// R0_ALPHA is initialized to T0_ALPHA in stage0

enum PS_CHANNEL
{
    PS_CHANNEL_RGB=   0x00, // used as RGB source
    PS_CHANNEL_BLUE=  0x00, // used as ALPHA source
    PS_CHANNEL_ALPHA= 0x10, // used as RGB or ALPHA source
};


enum PS_FINALCOMBINERSETTING
{
    PS_FINALCOMBINERSETTING_CLAMP_SUM=     0x80, // V1+R0 sum clamped to [0,1]
    
    PS_FINALCOMBINERSETTING_COMPLEMENT_V1= 0x40, // unsigned invert mapping
    
    PS_FINALCOMBINERSETTING_COMPLEMENT_R0= 0x20, // unsigned invert mapping
};

// =========================================================================================================
// PSRGBOutputs[0-7]
// PSAlphaOutputs[0-7]
// --------.--------.--------.----xxxx // CD register
// --------.--------.--------.xxxx---- // AB register
// --------.--------.----xxxx.-------- // SUM register
// --------.--------.---x----.-------- // CD output (0= multiply, 1= dot product)
// --------.--------.--x-----.-------- // AB output (0= multiply, 1= dot product)
// --------.--------.-x------.-------- // AB_CD mux/sum select (0= sum, 1= mux)
// --------.------xx.x-------.-------- // Output mapping
// --------.-----x--.--------.-------- // CD blue to alpha
// --------.----x---.--------.-------- // AB blue to alpha

#define PS_COMBINEROUTPUTS(ab,cd,mux_sum,flags) (((flags)<<12)|((mux_sum)<<8)|((ab)<<4)|(cd))
// ab,cd,mux_sum contain a value from PS_REGISTER
// flags contains values from PS_COMBINEROUTPUT

enum PS_COMBINEROUTPUT
{
    PS_COMBINEROUTPUT_IDENTITY=            0x00L, // y = x        
    PS_COMBINEROUTPUT_BIAS=                0x08L, // y = x - 0.5  
    PS_COMBINEROUTPUT_SHIFTLEFT_1=         0x10L, // y = x*2      
    PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS=    0x18L, // y = (x - 0.5)*2
    PS_COMBINEROUTPUT_SHIFTLEFT_2=         0x20L, // y = x*4      
    PS_COMBINEROUTPUT_SHIFTRIGHT_1=        0x30L, // y = x/2      
    
    PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA=    0x80L, // RGB only
    
    PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA=    0x40L, // RGB only
    
    PS_COMBINEROUTPUT_AB_MULTIPLY=         0x00L,
    PS_COMBINEROUTPUT_AB_DOT_PRODUCT=      0x02L, // RGB only
    
    PS_COMBINEROUTPUT_CD_MULTIPLY=         0x00L,
    PS_COMBINEROUTPUT_CD_DOT_PRODUCT=      0x01L, // RGB only
    
    PS_COMBINEROUTPUT_AB_CD_SUM=           0x00L, // 3rd output is AB+CD
    PS_COMBINEROUTPUT_AB_CD_MUX=           0x04L, // 3rd output is MUX(AB,CD) based on R0.a
};

// AB_CD register output must be DISCARD if either AB_DOT_PRODUCT or CD_DOT_PRODUCT are set

// =========================================================================================================
// PSC0Mapping
// PSC1Mapping
// --------.--------.--------.----xxxx // offset of D3D constant for stage 0
// --------.--------.--------.xxxx---- // offset of D3D constant for stage 1
// --------.--------.----xxxx.-------- // offset of D3D constant for stage 2
// --------.--------.xxxx----.-------- // offset of D3D constant for stage 3
// --------.----xxxx.--------.-------- // offset of D3D constant for stage 4
// --------.xxxx----.--------.-------- // offset of D3D constant for stage 5
// ----xxxx.--------.--------.-------- // offset of D3D constant for stage 6
// xxxx----.--------.--------.-------- // offset of D3D constant for stage 7

#define PS_CONSTANTMAPPING(s0,s1,s2,s3,s4,s5,s6,s7) \
     (((DWORD)(s0)&0xf)<< 0) | (((DWORD)(s1)&0xf)<< 4) | \
     (((DWORD)(s2)&0xf)<< 8) | (((DWORD)(s3)&0xf)<<12) | \
     (((DWORD)(s4)&0xf)<<16) | (((DWORD)(s5)&0xf)<<20) | \
     (((DWORD)(s6)&0xf)<<24) | (((DWORD)(s7)&0xf)<<28) 
// s0-s7 contain the offset of the D3D constant that corresponds to the 
// c0 or c1 constant in stages 0 through 7.  These mappings are only used in 
// SetPixelShaderConstant().
   
// =========================================================================================================
// PSFinalCombinerConstants
// --------.--------.--------.----xxxx // offset of D3D constant for C0
// --------.--------.--------.xxxx---- // offset of D3D constant for C1
// --------.--------.-------x.-------- // Adjust texture flag

#define PS_FINALCOMBINERCONSTANTS(c0,c1,flags) (((DWORD)(flags) << 8) | ((DWORD)(c0)&0xf)<< 0) | (((DWORD)(c1)&0xf)<< 4)
// c0 and c1 contain the offset of the D3D constant that corresponds to the
// constants in the final combiner.  These mappings are only used in 
// SetPixelShaderConstant().  Flags contains values from PS_GLOBALFLAGS

enum PS_GLOBALFLAGS
{
    // if this flag is set, the texture mode for each texture stage is adjusted as follows:
    //     if set texture is a cubemap, 
    //         change PS_TEXTUREMODES_PROJECT2D to PS_TEXTUREMODES_CUBEMAP
    //         change PS_TEXTUREMODES_PROJECT3D to PS_TEXTUREMODES_CUBEMAP
    //         change PS_TEXTUREMODES_DOT_STR_3D to PS_TEXTUREMODES_DOT_STR_CUBE
    //     if set texture is a volume texture, 
    //         change PS_TEXTUREMODES_PROJECT2D to PS_TEXTUREMODES_PROJECT3D
    //         change PS_TEXTUREMODES_CUBEMAP to PS_TEXTUREMODES_PROJECT3D
    //         change PS_TEXTUREMODES_DOT_STR_CUBE to PS_TEXTUREMODES_DOT_STR_3D
    //     if set texture is neither cubemap or volume texture, 
    //         change PS_TEXTUREMODES_PROJECT3D to PS_TEXTUREMODES_PROJECT2D
    //         change PS_TEXTUREMODES_CUBEMAP to PS_TEXTUREMODES_PROJECT2D

    PS_GLOBALFLAGS_NO_TEXMODE_ADJUST=     0x0000L, // don't adjust texture modes
    PS_GLOBALFLAGS_TEXMODE_ADJUST=        0x0001L, // adjust texture modes according to set texture
};

   
typedef struct _D3DPixelShaderDefFile
{
    DWORD               FileID;         // Uniquely identifies the file as pixel shader binary
    D3DPIXELSHADERDEF   Psd;            // The pixel shader def structure
} D3DPIXELSHADERDEF_FILE;

#define D3DPIXELSHADERDEF_FILE_ID   0x30425350  // "PSB0"

/*----------------------- End of Pixel Shader Defines -----------------------*/

/*----------------------------------------------
/* Push-Buffer Binary Format
/*----------------------------------------------

/*---------------------------------------------------*/
/*  These defines describe the binary format of the  */
/*  push-buffer.  They may be used in conjunction    */
/*  with BeginPush/EndPush and RunPushBuffer.        */
/*---------------------------------------------------*/

/* Encoding support */

#define D3DPUSH_ENCODE(Method, Count)   (((Count) << 18) + (Method))
#define D3DPUSH_NOINCREMENT_FLAG        0x40000000

/* Methods */

#define D3DPUSH_SET_BEGIN_END           0x000017fc      // D3DPRIMITIVETYPE or 0 to end
#define D3DPUSH_INLINE_ARRAY            0x00001818


/*----------------------- End of Push-Buffer Defines -----------------------*/


#pragma pack()
#pragma warning(default:4201)

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8TYPES(P)_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3drmobj.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *
 ***************************************************************************/

#ifndef _D3DRMOBJ_H_
#define _D3DRMOBJ_H_

#include <objbase.h> /* Use Windows header files */
#define VIRTUAL
#include "d3drmdef.h"

#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The methods for IUnknown
 */
#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)	   	(THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)	   	(THIS) kind; \
    STDMETHOD_(ULONG, Release)	   	(THIS) kind

/*
 * The methods for IDirect3DRMObject
 */
#define IDIRECT3DRMOBJECT_METHODS(kind) \
    STDMETHOD(Clone)			(THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD(AddDestroyCallback)  	(THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(DeleteDestroyCallback)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(SetAppData)	   	(THIS_ DWORD data) kind; \
    STDMETHOD_(DWORD, GetAppData)  	(THIS) kind; \
    STDMETHOD(SetName)		   	(THIS_ LPCSTR) kind; \
    STDMETHOD(GetName)			(THIS_ LPDWORD lpdwSize, LPSTR lpName) kind; \
    STDMETHOD(GetClassName)		(THIS_ LPDWORD lpdwSize, LPSTR lpName) kind


#define WIN_TYPES(itype, ptype) \
    typedef interface itype FAR *LP##ptype, FAR **LPLP##ptype

WIN_TYPES(IDirect3DRMObject, DIRECT3DRMOBJECT);
WIN_TYPES(IDirect3DRMObject2, DIRECT3DRMOBJECT2);
WIN_TYPES(IDirect3DRMDevice, DIRECT3DRMDEVICE);
WIN_TYPES(IDirect3DRMDevice2, DIRECT3DRMDEVICE2);
WIN_TYPES(IDirect3DRMDevice3, DIRECT3DRMDEVICE3);
WIN_TYPES(IDirect3DRMViewport, DIRECT3DRMVIEWPORT);
WIN_TYPES(IDirect3DRMViewport2, DIRECT3DRMVIEWPORT2);
WIN_TYPES(IDirect3DRMFrame, DIRECT3DRMFRAME);
WIN_TYPES(IDirect3DRMFrame2, DIRECT3DRMFRAME2);
WIN_TYPES(IDirect3DRMFrame3, DIRECT3DRMFRAME3);
WIN_TYPES(IDirect3DRMVisual, DIRECT3DRMVISUAL);
WIN_TYPES(IDirect3DRMMesh, DIRECT3DRMMESH);
WIN_TYPES(IDirect3DRMMeshBuilder, DIRECT3DRMMESHBUILDER);
WIN_TYPES(IDirect3DRMMeshBuilder2, DIRECT3DRMMESHBUILDER2);
WIN_TYPES(IDirect3DRMMeshBuilder3, DIRECT3DRMMESHBUILDER3);
WIN_TYPES(IDirect3DRMFace, DIRECT3DRMFACE);
WIN_TYPES(IDirect3DRMFace2, DIRECT3DRMFACE2);
WIN_TYPES(IDirect3DRMLight, DIRECT3DRMLIGHT);
WIN_TYPES(IDirect3DRMTexture, DIRECT3DRMTEXTURE);
WIN_TYPES(IDirect3DRMTexture2, DIRECT3DRMTEXTURE2);
WIN_TYPES(IDirect3DRMTexture3, DIRECT3DRMTEXTURE3);
WIN_TYPES(IDirect3DRMWrap, DIRECT3DRMWRAP);
WIN_TYPES(IDirect3DRMMaterial, DIRECT3DRMMATERIAL);
WIN_TYPES(IDirect3DRMMaterial2, DIRECT3DRMMATERIAL2);
WIN_TYPES(IDirect3DRMInterpolator, DIRECT3DRMINTERPOLATOR);
WIN_TYPES(IDirect3DRMAnimation, DIRECT3DRMANIMATION);
WIN_TYPES(IDirect3DRMAnimation2, DIRECT3DRMANIMATION2);
WIN_TYPES(IDirect3DRMAnimationSet, DIRECT3DRMANIMATIONSET);
WIN_TYPES(IDirect3DRMAnimationSet2, DIRECT3DRMANIMATIONSET2);
WIN_TYPES(IDirect3DRMUserVisual, DIRECT3DRMUSERVISUAL);
WIN_TYPES(IDirect3DRMShadow, DIRECT3DRMSHADOW);
WIN_TYPES(IDirect3DRMShadow2, DIRECT3DRMSHADOW2);
WIN_TYPES(IDirect3DRMArray, DIRECT3DRMARRAY);
WIN_TYPES(IDirect3DRMObjectArray, DIRECT3DRMOBJECTARRAY);
WIN_TYPES(IDirect3DRMDeviceArray, DIRECT3DRMDEVICEARRAY);
WIN_TYPES(IDirect3DRMFaceArray, DIRECT3DRMFACEARRAY);
WIN_TYPES(IDirect3DRMViewportArray, DIRECT3DRMVIEWPORTARRAY);
WIN_TYPES(IDirect3DRMFrameArray, DIRECT3DRMFRAMEARRAY);
WIN_TYPES(IDirect3DRMAnimationArray, DIRECT3DRMANIMATIONARRAY);
WIN_TYPES(IDirect3DRMVisualArray, DIRECT3DRMVISUALARRAY);
WIN_TYPES(IDirect3DRMPickedArray, DIRECT3DRMPICKEDARRAY);
WIN_TYPES(IDirect3DRMPicked2Array, DIRECT3DRMPICKED2ARRAY);
WIN_TYPES(IDirect3DRMLightArray, DIRECT3DRMLIGHTARRAY);
WIN_TYPES(IDirect3DRMProgressiveMesh, DIRECT3DRMPROGRESSIVEMESH);
WIN_TYPES(IDirect3DRMClippedVisual, DIRECT3DRMCLIPPEDVISUAL);

/*
 * Direct3DRM Object classes
 */
DEFINE_GUID(CLSID_CDirect3DRMDevice,	    0x4fa3568e, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewport,	    0x4fa3568f, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFrame,	    0x4fa35690, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMesh,	    0x4fa35691, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMeshBuilder,   0x4fa35692, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFace,	    0x4fa35693, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMLight,	    0x4fa35694, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMTexture,	    0x4fa35695, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMWrap,	    0x4fa35696, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMaterial,	    0x4fa35697, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimation,	    0x4fa35698, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimationSet,  0x4fa35699, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMUserVisual,    0x4fa3569a, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMShadow,	    0x4fa3569b, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewportInterpolator, 
0xde9eaa1, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMFrameInterpolator, 
0xde9eaa2, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMeshInterpolator, 
0xde9eaa3, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMLightInterpolator, 
0xde9eaa6, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMaterialInterpolator, 
0xde9eaa7, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMTextureInterpolator, 
0xde9eaa8, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMProgressiveMesh, 0x4516ec40, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMClippedVisual,   0x5434e72d, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);


/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject, 	    0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice, 	    0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,	    0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport, 	    0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame, 	    0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,	    0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual, 	    0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh, 	    0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,	    0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0x4516ec82, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFace, 	    0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFace2,           0x4516ec81, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMLight, 	    0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture, 	    0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap, 	    0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial, 	    0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation, 	    0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,	    0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,	    0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray, 	    0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,	    0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray, 	    0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,	    0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,	    0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray, 
0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,	    0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,	    0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,	    0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);

typedef void (__cdecl *D3DRMOBJECTCALLBACK)(LPDIRECT3DRMOBJECT obj, LPVOID arg);
typedef void (__cdecl *D3DRMFRAMEMOVECALLBACK)(LPDIRECT3DRMFRAME obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMFRAME3MOVECALLBACK)(LPDIRECT3DRMFRAME3 obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMUPDATECALLBACK)(LPDIRECT3DRMDEVICE obj, LPVOID arg, int, LPD3DRECT);
typedef void (__cdecl *D3DRMDEVICE3UPDATECALLBACK)(LPDIRECT3DRMDEVICE3 obj, LPVOID arg, int, LPD3DRECT);
typedef int (__cdecl *D3DRMUSERVISUALCALLBACK)
    (   LPDIRECT3DRMUSERVISUAL obj, LPVOID arg,	D3DRMUSERVISUALREASON reason,
        LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view
    );
typedef HRESULT (__cdecl *D3DRMLOADTEXTURECALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE *);
typedef HRESULT (__cdecl *D3DRMLOADTEXTURE3CALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE3 *);
typedef void (__cdecl *D3DRMLOADCALLBACK)
    (LPDIRECT3DRMOBJECT object, REFIID objectguid, LPVOID arg);

typedef HRESULT (__cdecl *D3DRMDOWNSAMPLECALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     LPDIRECTDRAWSURFACE pDDSSrc, LPDIRECTDRAWSURFACE pDDSDst);
typedef HRESULT (__cdecl *D3DRMVALIDATIONCALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     DWORD dwFlags, DWORD dwcRects, LPRECT pRects);


typedef struct _D3DRMPICKDESC
{
    ULONG	ulFaceIdx;
    LONG	lGroupIdx;
    D3DVECTOR	vPosition;

} D3DRMPICKDESC, *LPD3DRMPICKDESC;

typedef struct _D3DRMPICKDESC2
{
    ULONG	ulFaceIdx;
    LONG	lGroupIdx;
    D3DVECTOR	dvPosition;
    D3DVALUE	tu;
    D3DVALUE	tv;
    D3DVECTOR	dvNormal;
    D3DCOLOR	dcColor;

} D3DRMPICKDESC2, *LPD3DRMPICKDESC2;

#undef INTERFACE
#define INTERFACE IDirect3DRMObject

/*
 * Base class
 */
DECLARE_INTERFACE_(IDirect3DRMObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObject2

DECLARE_INTERFACE_(IDirect3DRMObject2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * IDirect3DRMObject2 methods
     */
    STDMETHOD(AddDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE;
    STDMETHOD(Clone)(THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) PURE; \
    STDMETHOD(DeleteDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE; \
    STDMETHOD(GetClientData)(THIS_ DWORD dwID, LPVOID* lplpvData) PURE;
    STDMETHOD(GetDirect3DRM)(THIS_ LPDIRECT3DRM* lplpDirect3DRM) PURE;
    STDMETHOD(GetName)(THIS_ LPDWORD lpdwSize, LPSTR lpName) PURE;
    STDMETHOD(SetClientData)(THIS_ DWORD dwID, LPVOID lpvData, DWORD dwFlags) PURE;
    STDMETHOD(SetName)(THIS_ LPCSTR lpName) PURE;
    STDMETHOD(GetAge)(THIS_ DWORD dwFlags, LPDWORD pdwAge) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisual

DECLARE_INTERFACE_(IDirect3DRMVisual, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice

DECLARE_INTERFACE_(IDirect3DRMDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice2

DECLARE_INTERFACE_(IDirect3DRMDevice2, IDirect3DRMDevice)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice3

DECLARE_INTERFACE_(IDirect3DRMDevice3, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;

    /*
     * IDirect3DRMDevice3 methods
     */
    STDMETHOD(FindPreferredTextureFormat)(THIS_ DWORD dwBitDepths, DWORD dwFlags, LPDDPIXELFORMAT lpDDPF) PURE;
    STDMETHOD(RenderStateChange)(THIS_ D3DRENDERSTATETYPE drsType, DWORD dwVal, DWORD dwFlags) PURE;
    STDMETHOD(LightStateChange)(THIS_ D3DLIGHTSTATETYPE drsType, DWORD dwVal, DWORD dwFlags) PURE;
    STDMETHOD(GetStateChangeOptions)(THIS_ DWORD dwStateClass, DWORD dwStateNum, LPDWORD pdwFlags) PURE;
    STDMETHOD(SetStateChangeOptions)(THIS_ DWORD dwStateClass, DWORD dwStateNum, DWORD dwFlags) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMViewport

DECLARE_INTERFACE_(IDirect3DRMViewport, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMFRAME camera,
	DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewport2
DECLARE_INTERFACE_(IDirect3DRMViewport2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport2 methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMDEVICE3 dev, LPDIRECT3DRMFRAME3 camera,
	DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME3) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE3 *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
    STDMETHOD(TransformVectors)(THIS_ DWORD dwNumVectors,
				LPD3DRMVECTOR4D lpDstVectors,
				LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ DWORD dwNumVectors,
				       LPD3DVECTOR lpDstVectors,
				       LPD3DRMVECTOR4D lpSrcVectors) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame

DECLARE_INTERFACE_(IDirect3DRMFrame, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame2

DECLARE_INTERFACE_(IDirect3DRMFrame2, IDirect3DRMFrame)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;

    /*
     * IDirect3DRMFrame2 methods
     */
    STDMETHOD(AddMoveCallback2)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
		       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat, 
		    D3DRMSAVEOPTIONS d3dSaveFlags);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame3

DECLARE_INTERFACE_(IDirect3DRMFrame3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame3 methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME3 child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(GetTransform)(THIS_ LPDIRECT3DRMFRAME3 reference,
			     D3DRMMATRIX4D rmMatrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME3 target, LPDIRECT3DRMFRAME3 reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME3 reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
		       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat, 
		    D3DRMSAVEOPTIONS d3dSaveFlags);
    STDMETHOD(TransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
				DWORD dwNumVectors,
				LPD3DVECTOR lpDstVectors,
				LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
				       DWORD dwNumVectors,
				       LPD3DVECTOR lpDstVectors,
				       LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(SetTraversalOptions)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetTraversalOptions)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetSceneFogMethod)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetSceneFogMethod)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
    STDMETHOD(GetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMesh

DECLARE_INTERFACE_(IDirect3DRMMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMesh methods
     */
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(AddGroup)(THIS_ unsigned vCount, unsigned fCount, unsigned vPerFace, unsigned *fData, D3DRMGROUPINDEX *returnId) PURE;
    STDMETHOD(SetVertices)(THIS_ D3DRMGROUPINDEX id, unsigned index, unsigned count, D3DRMVERTEX *values) PURE;
    STDMETHOD(SetGroupColor)(THIS_ D3DRMGROUPINDEX id, D3DCOLOR value) PURE;
    STDMETHOD(SetGroupColorRGB)(THIS_ D3DRMGROUPINDEX id, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetGroupMapping)(THIS_ D3DRMGROUPINDEX id, D3DRMMAPPING value) PURE;
    STDMETHOD(SetGroupQuality)(THIS_ D3DRMGROUPINDEX id, D3DRMRENDERQUALITY value) PURE;
    STDMETHOD(SetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL value) PURE;
    STDMETHOD(SetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE value) PURE;

    STDMETHOD_(unsigned, GetGroupCount)(THIS) PURE;
    STDMETHOD(GetGroup)(THIS_ D3DRMGROUPINDEX id, unsigned *vCount, unsigned *fCount, unsigned *vPerFace, DWORD *fDataSize, unsigned *fData) PURE;
    STDMETHOD(GetVertices)(THIS_ D3DRMGROUPINDEX id, DWORD index, DWORD count, D3DRMVERTEX *returnPtr) PURE;
    STDMETHOD_(D3DCOLOR, GetGroupColor)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMMAPPING, GetGroupMapping)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetGroupQuality)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD(GetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL *returnPtr) PURE;
    STDMETHOD(GetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE *returnPtr) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMProgressiveMesh

DECLARE_INTERFACE_(IDirect3DRMProgressiveMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMProgressiveMesh methods
     */
    STDMETHOD(Load) (THIS_ LPVOID lpObjLocation, LPVOID lpObjId, 
		     D3DRMLOADOPTIONS dloLoadflags, D3DRMLOADTEXTURECALLBACK lpCallback,
		     LPVOID lpArg) PURE;
    STDMETHOD(GetLoadStatus) (THIS_ LPD3DRMPMESHLOADSTATUS lpStatus) PURE;
    STDMETHOD(SetMinRenderDetail) (THIS_ D3DVALUE d3dVal) PURE;
    STDMETHOD(Abort) (THIS_ DWORD dwFlags) PURE;
    
    STDMETHOD(GetFaceDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(GetVertexDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(SetFaceDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(SetVertexDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(GetFaceDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetVertexDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetDetail) (THIS_ D3DVALUE *lpdvVal) PURE;
    STDMETHOD(SetDetail) (THIS_ D3DVALUE d3dVal) PURE;

    STDMETHOD(RegisterEvents) (THIS_ HANDLE hEvent, DWORD dwFlags, DWORD dwReserved) PURE;
    STDMETHOD(CreateMesh) (THIS_ LPDIRECT3DRMMESH *lplpD3DRMMesh) PURE;
    STDMETHOD(Duplicate) (THIS_ LPDIRECT3DRMPROGRESSIVEMESH *lplpD3DRMPMesh) PURE;
    STDMETHOD(GetBox) (THIS_ LPD3DRMBOX lpBBox) PURE;
    STDMETHOD(SetQuality) (THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(GetQuality) (THIS_ LPD3DRMRENDERQUALITY lpdwquality) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow

DECLARE_INTERFACE_(IDirect3DRMShadow, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMVISUAL visual, LPDIRECT3DRMLIGHT light,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow2

DECLARE_INTERFACE_(IDirect3DRMShadow2, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (	THIS_ LPUNKNOWN pUNK, LPDIRECT3DRMLIGHT light,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;

    /*
     * IDirect3DRMShadow2 methods
     */
    STDMETHOD(GetVisual)(THIS_ LPDIRECT3DRMVISUAL *) PURE;
    STDMETHOD(SetVisual)(THIS_ LPUNKNOWN pUNK, DWORD) PURE;
    STDMETHOD(GetLight)(THIS_ LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(SetLight)(THIS_ LPDIRECT3DRMLIGHT, DWORD) PURE;
    STDMETHOD(GetPlane)(THIS_ LPD3DVALUE px, LPD3DVALUE py, LPD3DVALUE pz,
			LPD3DVALUE nx, LPD3DVALUE ny, LPD3DVALUE nz) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE px, D3DVALUE py, D3DVALUE pz,
			D3DVALUE nx, D3DVALUE ny, D3DVALUE nz, DWORD) PURE;
    STDMETHOD(GetOptions)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetOptions)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace

DECLARE_INTERFACE_(IDirect3DRMFace, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace2

DECLARE_INTERFACE_(IDirect3DRMFace2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder2

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder2, IDirect3DRMMeshBuilder)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;

    /*
     * IDirect3DRMMeshBuilder2 methods
     */
    STDMETHOD(GenerateNormals2)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder3

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder3 methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3, DWORD dwFlags) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE2) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetGeometry)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;
    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;
    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD(GetVertex)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(GetNormal)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(DeleteVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteFace)(THIS_ LPDIRECT3DRMFACE2) PURE;
    STDMETHOD(Empty)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(AddFacesIndexed)(THIS_ DWORD dwFlags, DWORD *lpdwvIndices, DWORD *dwIndexFirst, DWORD *dwCount) PURE;
    STDMETHOD(CreateSubMesh)(THIS_ LPUNKNOWN *) PURE;
    STDMETHOD(GetParentMesh)(THIS_ DWORD, LPUNKNOWN *) PURE;
    STDMETHOD(GetSubMeshes)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(DeleteSubMesh)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(Enable)(THIS_ DWORD) PURE;
    STDMETHOD(GetEnable)(THIS_ DWORD *) PURE;
    STDMETHOD(AddTriangles)(THIS_ DWORD dwFlags, DWORD dwFormat,
			    DWORD dwVertexCount, LPVOID lpvData) PURE;
    STDMETHOD(SetVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetVertices)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD(SetNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetNormals)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD_(int, GetNormalCount)(THIS) PURE;
};  

#undef INTERFACE
#define INTERFACE IDirect3DRMLight

DECLARE_INTERFACE_(IDirect3DRMLight, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMLight methods
     */
    STDMETHOD(SetType)(THIS_ D3DRMLIGHTTYPE) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetRange)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUmbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetPenumbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetConstantAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetLinearAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetQuadraticAttenuation)(THIS_ D3DVALUE) PURE;

    STDMETHOD_(D3DVALUE, GetRange)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetUmbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetPenumbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetConstantAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetLinearAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetQuadraticAttenuation)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD_(D3DRMLIGHTTYPE, GetType)(THIS) PURE;

    STDMETHOD(SetEnableFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(GetEnableFrame)(THIS_ LPDIRECT3DRMFRAME*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture

DECLARE_INTERFACE_(IDirect3DRMTexture, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture2

DECLARE_INTERFACE_(IDirect3DRMTexture2, IDirect3DRMTexture)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;

    /*
     * IDirect3DRMTexture2 methods
     */
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture3

DECLARE_INTERFACE_(IDirect3DRMTexture3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture3 methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ DWORD dwFlags, DWORD dwcRects, LPRECT pRects) PURE;
    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
    STDMETHOD(GetSurface)(THIS_ DWORD dwFlags, LPDIRECTDRAWSURFACE* lplpDDS) PURE;
    STDMETHOD(SetCacheOptions)(THIS_ LONG lImportance, DWORD dwFlags) PURE;
    STDMETHOD(GetCacheOptions)(THIS_ LPLONG lplImportance, LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetDownsampleCallback)(THIS_ D3DRMDOWNSAMPLECALLBACK pCallback, LPVOID pArg) PURE;
    STDMETHOD(SetValidationCallback)(THIS_ D3DRMVALIDATIONCALLBACK pCallback, LPVOID pArg) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMWrap

DECLARE_INTERFACE_(IDirect3DRMWrap, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWrap methods
     */
    STDMETHOD(Init)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME ref,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv
    ) PURE;
    STDMETHOD(Apply)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(ApplyRelative)(THIS_ LPDIRECT3DRMFRAME frame, LPDIRECT3DRMOBJECT) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial

DECLARE_INTERFACE_(IDirect3DRMMaterial, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;

    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial2

DECLARE_INTERFACE_(IDirect3DRMMaterial2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial2 methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetAmbient)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(SetAmbient)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation

DECLARE_INTERFACE_(IDirect3DRMAnimation, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation2

DECLARE_INTERFACE_(IDirect3DRMAnimation2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation2 methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME3 frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
    STDMETHOD(GetFrame)(THIS_ LPDIRECT3DRMFRAME3 *lpD3DFrame) PURE;
    STDMETHOD(DeleteKeyByID)(THIS_ DWORD dwID) PURE;
    STDMETHOD(AddKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(ModifyKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(GetKeys)(THIS_ D3DVALUE dvTimeMin,
		       D3DVALUE dvTimeMax, LPDWORD lpdwNumKeys,
		       LPD3DRMANIMATIONKEY lpKey);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet

DECLARE_INTERFACE_(IDirect3DRMAnimationSet, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet2

DECLARE_INTERFACE_(IDirect3DRMAnimationSet2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet2 methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME3 parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(GetAnimations)(THIS_ LPDIRECT3DRMANIMATIONARRAY *) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMUserVisual

DECLARE_INTERFACE_(IDirect3DRMUserVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMUserVisual methods
     */
    STDMETHOD(Init)(THIS_ D3DRMUSERVISUALCALLBACK fn, void *arg) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMArray

DECLARE_INTERFACE_(IDirect3DRMArray, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    /* No GetElement method as it would get overloaded
     * in derived classes, and overloading is
     * a no-no in COM
     */
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObjectArray

DECLARE_INTERFACE_(IDirect3DRMObjectArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMOBJECT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDeviceArray

DECLARE_INTERFACE_(IDirect3DRMDeviceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrameArray

DECLARE_INTERFACE_(IDirect3DRMFrameArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFRAME *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewportArray

DECLARE_INTERFACE_(IDirect3DRMViewportArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisualArray

DECLARE_INTERFACE_(IDirect3DRMVisualArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationArray

DECLARE_INTERFACE_(IDirect3DRMAnimationArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMANIMATION2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPickedArray

DECLARE_INTERFACE_(IDirect3DRMPickedArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMLightArray

DECLARE_INTERFACE_(IDirect3DRMLightArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMLIGHT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFaceArray

DECLARE_INTERFACE_(IDirect3DRMFaceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFACE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPicked2Array

DECLARE_INTERFACE_(IDirect3DRMPicked2Array, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC2) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMInterpolator

DECLARE_INTERFACE_(IDirect3DRMInterpolator, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMInterpolator methods
     */
    STDMETHOD(AttachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(GetAttachedObjects)(THIS_ LPDIRECT3DRMOBJECTARRAY *) PURE;
    STDMETHOD(DetachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(SetIndex)(THIS_ D3DVALUE) PURE;
    STDMETHOD_(D3DVALUE, GetIndex)(THIS) PURE;
    STDMETHOD(Interpolate)(THIS_ D3DVALUE, LPDIRECT3DRMOBJECT, D3DRMINTERPOLATIONOPTIONS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMClippedVisual

DECLARE_INTERFACE_(IDirect3DRMClippedVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMClippedVisual methods
     */
    STDMETHOD(Init) (THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(AddPlane) (THIS_ LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD, LPDWORD) PURE;
    STDMETHOD(DeletePlane)(THIS_ DWORD, DWORD) PURE;
    STDMETHOD(GetPlaneIDs)(THIS_ LPDWORD, LPDWORD, DWORD) PURE;
    STDMETHOD(GetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
    STDMETHOD(SetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
};

#ifdef __cplusplus
};
#endif
#endif /* _D3DRMOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\D3drmvis.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drmvis.h
 *  Content:	Direct3DRM external visualinclude file
 *
 ***************************************************************************/

#ifndef _D3DRMVIS_H_
#define _D3DRMVIS_H_

#include "d3drm.h"
#include "d3drmobj.h"

#include <ocidl.h>
#include "dxfile.h"

#ifdef __cplusplus
extern "C" {
#endif

WIN_TYPES(IDirect3DRMExternalVisual, DIRECT3DRMEXTERNALVISUAL);
WIN_TYPES(IDirect3DRMExternalUtil, DIRECT3DRMEXTERNALUTIL);

DEFINE_GUID(IID_IDirect3DRMExternalVisual,
0x4516ec80, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMExternalUtil,
0x4516ec80, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);

/* In IDirect3DRMExternalVisual::CanSee() */
#define D3DRMEXTVIS_CANNOTSEE 0x00000001L
#define D3DRMEXTVIS_CANSEE    0x00000002L

/* In IDirect3DRMExternalVisual::Pick() */
#define D3DRMEXTVIS_NOTPICKED 0x00000001L
#define D3DRMEXTVIS_PICKED    0x00000002L

/* In D3DRMEXTVISRENDERCONTEXT.dwOverrides */
#define D3DRMEXTVIS_RENDERCONTEXT_OVERRIDEMATERIAL 0x00000001L
#define D3DRMEXTVIS_RENDERCONTEXT_OVERRIDETEXTURE  0x00000002L
#define D3DRMEXTVIS_RENDERCONTEXT_DEVICEOVERRIDE   0x00000004L

/* In D3DRMEXTVISRENDERCONTEXT.dwZBufferMode */
#define D3DRMEXTVIS_RENDERCONTEXT_ZBUFFERON        0x00000001L
#define D3DRMEXTVIS_RENDERCONTEXT_ZBUFFEROFF       0x00000002L

/*
 * Structure for IDirect3DRMExternalVisual::SetRenderContext()
 */
typedef struct
{
    DWORD dwSize;		/* Size of structure */
    DWORD dwFlags;		/* Must be zero */
    DWORD dwOverrides;		/* Indicates which overrides are in effect */
    D3DMATERIALHANDLE hMat;	/* If non-zero, this material handle MUST
				   be used for all rendering */
    D3DTEXTUREHANDLE hTex;	/* If non-zero, this texture handle MUST
				   be used for all rendering */
    D3DRMMATERIALOVERRIDE dmUserOverride; /* contains per-attribute overrides
					     for materials */
    D3DRMSHADEMODE pShadeMode;  /* Flat, gouraud or phong */
    D3DRMLIGHTMODE pLightMode;  /* On or off */
    D3DRMFILLMODE pFillMode;    /* Points, wireframe or solid */
    DWORD dwZBufferMode;	/* As defined above */
    DWORD dwRenderMode;		/* Blended transparency and/or sorted */
} D3DRMEXTVISRENDERCONTEXT, *LPD3DRMEXTVISRENDERCONTEXT;

/*
 * Structure for IDirect3DRMExternalVisual::RayPick()
 */
typedef struct
{
    D3DVALUE  dDistance;
    D3DVECTOR dvPosition;
    D3DVECTOR dvNormal;
    D3DVALUE  tu;
    D3DVALUE  tv;
    D3DCOLOR  dcColor;
} D3DRMEXTVISRAYPICKINFO, *LPD3DRMEXTVISRAYPICKINFO;

#undef INTERFACE
#define INTERFACE IDirect3DRMExternalVisual
DECLARE_INTERFACE_(IDirect3DRMExternalVisual, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * IDirect3DRMExternalVisual methods
     */
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DRM, LPDIRECT3DRMEXTERNALUTIL,
			  DWORD dwFlags) PURE;
    STDMETHOD(Load)(THIS_ IDirectXFileData *dObject, 
		    IPropertyBag *pPropBag, 
		    DWORD dwFlags) PURE;

    /*
     * Information about device state, viewport state, overrides, etc...
     */
    STDMETHOD(SetRenderContext)(THIS_ LPD3DRMEXTVISRENDERCONTEXT pCntx,
				DWORD dwFlags) PURE;
    
    /*
     * Rendering operations
     */
    STDMETHOD(CanSee)(THIS_ LPDIRECT3DRMDEVICE2, LPDIRECT3DRMVIEWPORT2,
		      LPDWORD pdwCanSee) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMDEVICE2, LPDIRECT3DRMVIEWPORT2,
		      DWORD dwFlags) PURE;
    STDMETHOD(DeviceChange)(THIS) PURE;

    /* 
     * Notify external visuals when BeginScene/EndScene are called during 
     * rendering
     */
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;

    /*
     * Picking
     */
    STDMETHOD(Pick)(THIS_ LPDIRECT3DRMVIEWPORT2 pViewIn,
		    LPDIRECT3DRMFRAME3 pFrameIn,
		    DWORD dwXIn, DWORD dwYIn,
		    LPD3DVALUE pdvZOut, LPDWORD pdwPicked) PURE;

    /*
     * RayPicking
     *
     * dwFlags can contain:
     * D3DRMRAYPICK_INTERPOLATENORMAL - pPickInfo.dvNormal must be filled in
     * D3DRMRAYPICK_INTERPOLATECOLOR  - pPickInfo.dcColor must be filled in
     * D3DRMRAYPICK_INTERPOLATEUV     - pPickInfo.tu, tv must be filled in
     */
    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME3 pFrameIn,
		       LPD3DRMRAY pRayIn,
		       DWORD dwFlags,
		       LPDWORD pdwPicked,
		       LPD3DRMEXTVISRAYPICKINFO pPickInfo) PURE;

    /*
     * Misc
     */
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(GetAge)(THIS_ LPDWORD) PURE;
};

/*
 * Flags for UpdateBounds
 */
#define D3DRMEXTUTIL_BOUNDSINVALIDATE 0x00000001L
#define D3DRMEXTUTIL_BOUNDSVALID      0x00000002L

#undef INTERFACE
#define INTERFACE IDirect3DRMExternalUtil
DECLARE_INTERFACE_(IDirect3DRMExternalUtil, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * External Visual must use these methods to provide IDirect3DRMObject
     * functionality.
     */
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMExternalUtil methods
     */

    /*
     * Texture Management
     */
    STDMETHOD(FindDeviceTexture)(LPDIRECT3DRMDEVICE2, LPDIRECT3DRMTEXTURE,
				 LPDWORD dwDevTexId) PURE;
    STDMETHOD(GetTextureHandle)(DWORD dwDevTexId, LPDWORD pdwHandle) PURE;
    STDMETHOD(DestroyDeviceTexture)(DWORD dwDevTexId) PURE;
    STDMETHOD(ValidateDeviceTextures)(LPDIRECT3DRMDEVICE2,
				      LPDWORD dwDevTexIds,
				      DWORD dwNumIds) PURE;
    STDMETHOD(UpdateBounds)(DWORD dwFlags,
			    LPD3DVECTOR dvMin,
			    LPD3DVECTOR dvMax) PURE;
    STDMETHOD(SetExtents)(LPDIRECT3DRMVIEWPORT2,
			  DWORD dwNumExtents, 
			  LPD3DCLIPSTATUS pExtents) PURE;
};

#ifdef __cplusplus
};
#endif /* __cplusplus */

#endif /* _D3DRMVIS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dcaps.h ===
/*==========================================================================;
 *
 *
 *  File:       d3dcaps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3DCAPS_H
#define _D3DCAPS_H

/*
 *  Pull in DirectDraw include file automatically:
 */
#include "ddraw.h"

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0700
#endif

#pragma pack(4)

/* Description of capabilities of transform */

typedef struct _D3DTRANSFORMCAPS {
    DWORD dwSize;
    DWORD dwCaps;
} D3DTRANSFORMCAPS, *LPD3DTRANSFORMCAPS;

#define D3DTRANSFORMCAPS_CLIP           0x00000001L /* Will clip whilst transforming */

/* Description of capabilities of lighting */

typedef struct _D3DLIGHTINGCAPS {
    DWORD dwSize;
    DWORD dwCaps;                   /* Lighting caps */
    DWORD dwLightingModel;          /* Lighting model - RGB or mono */
    DWORD dwNumLights;              /* Number of lights that can be handled */
} D3DLIGHTINGCAPS, *LPD3DLIGHTINGCAPS;

#define D3DLIGHTINGMODEL_RGB            0x00000001L
#define D3DLIGHTINGMODEL_MONO           0x00000002L

#define D3DLIGHTCAPS_POINT              0x00000001L /* Point lights supported */
#define D3DLIGHTCAPS_SPOT               0x00000002L /* Spot lights supported */
#define D3DLIGHTCAPS_DIRECTIONAL        0x00000004L /* Directional lights supported */
#if(DIRECT3D_VERSION < 0x700)
#define D3DLIGHTCAPS_PARALLELPOINT      0x00000008L /* Parallel point lights supported */
#endif
#if(DIRECT3D_VERSION < 0x500)
#define D3DLIGHTCAPS_GLSPOT             0x00000010L /* GL syle spot lights supported */
#endif

/* Description of capabilities for each primitive type */

typedef struct _D3DPrimCaps {
    DWORD dwSize;
    DWORD dwMiscCaps;                 /* Capability flags */
    DWORD dwRasterCaps;
    DWORD dwZCmpCaps;
    DWORD dwSrcBlendCaps;
    DWORD dwDestBlendCaps;
    DWORD dwAlphaCmpCaps;
    DWORD dwShadeCaps;
    DWORD dwTextureCaps;
    DWORD dwTextureFilterCaps;
    DWORD dwTextureBlendCaps;
    DWORD dwTextureAddressCaps;
    DWORD dwStippleWidth;             /* maximum width and height of */
    DWORD dwStippleHeight;            /* of supported stipple (up to 32x32) */
} D3DPRIMCAPS, *LPD3DPRIMCAPS;

/* D3DPRIMCAPS dwMiscCaps */

#define D3DPMISCCAPS_MASKPLANES         0x00000001L
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CONFORMANT         0x00000008L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L

/* D3DPRIMCAPS dwRasterCaps */

#define D3DPRASTERCAPS_DITHER                   0x00000001L
#define D3DPRASTERCAPS_ROP2                     0x00000002L
#define D3DPRASTERCAPS_XOR                      0x00000004L
#define D3DPRASTERCAPS_PAT                      0x00000008L
#define D3DPRASTERCAPS_ZTEST                    0x00000010L
#define D3DPRASTERCAPS_SUBPIXEL                 0x00000020L
#define D3DPRASTERCAPS_SUBPIXELX                0x00000040L
#define D3DPRASTERCAPS_FOGVERTEX                0x00000080L
#define D3DPRASTERCAPS_FOGTABLE                 0x00000100L
#define D3DPRASTERCAPS_STIPPLE                  0x00000200L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   0x00000400L
#define D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT 0x00000800L
#define D3DPRASTERCAPS_ANTIALIASEDGES           0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS            0x00002000L
#define D3DPRASTERCAPS_ZBIAS                    0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR           0x00008000L
#define D3DPRASTERCAPS_FOGRANGE                 0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY               0x00020000L
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
#define D3DPRASTERCAPS_WBUFFER                      0x00040000L
#define D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT   0x00080000L
#define D3DPRASTERCAPS_WFOG                         0x00100000L
#define D3DPRASTERCAPS_ZFOG                         0x00200000L
#endif /* DIRECT3D_VERSION >= 0x0600 */

/* D3DPRIMCAPS dwZCmpCaps, dwAlphaCmpCaps */

#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

/* D3DPRIMCAPS dwSourceBlendCaps, dwDestBlendCaps */

#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

/* D3DPRIMCAPS dwShadeCaps */

#define D3DPSHADECAPS_COLORFLATMONO             0x00000001L
#define D3DPSHADECAPS_COLORFLATRGB              0x00000002L
#define D3DPSHADECAPS_COLORGOURAUDMONO          0x00000004L
#define D3DPSHADECAPS_COLORGOURAUDRGB           0x00000008L
#define D3DPSHADECAPS_COLORPHONGMONO            0x00000010L
#define D3DPSHADECAPS_COLORPHONGRGB             0x00000020L

#define D3DPSHADECAPS_SPECULARFLATMONO          0x00000040L
#define D3DPSHADECAPS_SPECULARFLATRGB           0x00000080L
#define D3DPSHADECAPS_SPECULARGOURAUDMONO       0x00000100L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB        0x00000200L
#define D3DPSHADECAPS_SPECULARPHONGMONO         0x00000400L
#define D3DPSHADECAPS_SPECULARPHONGRGB          0x00000800L

#define D3DPSHADECAPS_ALPHAFLATBLEND            0x00001000L
#define D3DPSHADECAPS_ALPHAFLATSTIPPLED         0x00002000L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND         0x00004000L
#define D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED      0x00008000L
#define D3DPSHADECAPS_ALPHAPHONGBLEND           0x00010000L
#define D3DPSHADECAPS_ALPHAPHONGSTIPPLED        0x00020000L

#define D3DPSHADECAPS_FOGFLAT                   0x00040000L
#define D3DPSHADECAPS_FOGGOURAUD                0x00080000L
#define D3DPSHADECAPS_FOGPHONG                  0x00100000L

/* D3DPRIMCAPS dwTextureCaps */

/*
 * Perspective-correct texturing is supported
 */
#define D3DPTEXTURECAPS_PERSPECTIVE     0x00000001L

/*
 * Power-of-2 texture dimensions are required
 */
#define D3DPTEXTURECAPS_POW2            0x00000002L

/*
 * Alpha in texture pixels is supported
 */
#define D3DPTEXTURECAPS_ALPHA           0x00000004L

/*
 * Color-keyed textures are supported
 */
#define D3DPTEXTURECAPS_TRANSPARENCY    0x00000008L

/*
 * obsolete, see D3DPTADDRESSCAPS_BORDER
 */
#define D3DPTEXTURECAPS_BORDER          0x00000010L

/*
 * Only square textures are supported
 */
#define D3DPTEXTURECAPS_SQUAREONLY      0x00000020L

#if(DIRECT3D_VERSION >= 0x0600)
/*
 * Texture indices are not scaled by the texture size prior
 * to interpolation.
 */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L

/*
 * Device can draw alpha from texture palettes
 */
#define D3DPTEXTURECAPS_ALPHAPALETTE    0x00000080L

/*
 * Device can use non-POW2 textures if:
 *  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
 *  2) D3DRS_WRAP(N) is zero for this texture's coordinates
 *  3) mip mapping is not enabled (use magnification filter only)
 */
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L

#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)

// 0x00000200L unused

/*
 * Device can divide transformed texture coordinates by the
 * COUNTth texture coordinate (can do D3DTTFF_PROJECTED)
 */
#define D3DPTEXTURECAPS_PROJECTED  0x00000400L

/*
 * Device can do cubemap textures
 */
#define D3DPTEXTURECAPS_CUBEMAP           0x00000800L

#define D3DPTEXTURECAPS_COLORKEYBLEND     0x00001000L
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* D3DPRIMCAPS dwTextureFilterCaps */

#define D3DPTFILTERCAPS_NEAREST         0x00000001L
#define D3DPTFILTERCAPS_LINEAR          0x00000002L
#define D3DPTFILTERCAPS_MIPNEAREST      0x00000004L
#define D3DPTFILTERCAPS_MIPLINEAR       0x00000008L
#define D3DPTFILTERCAPS_LINEARMIPNEAREST 0x00000010L
#define D3DPTFILTERCAPS_LINEARMIPLINEAR 0x00000020L

#if(DIRECT3D_VERSION >= 0x0600)
/* Device3 Min Filter */
#define D3DPTFILTERCAPS_MINFPOINT       0x00000100L
#define D3DPTFILTERCAPS_MINFLINEAR      0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC 0x00000400L

/* Device3 Mip Filter */
#define D3DPTFILTERCAPS_MIPFPOINT       0x00010000L
#define D3DPTFILTERCAPS_MIPFLINEAR      0x00020000L

/* Device3 Mag Filter */
#define D3DPTFILTERCAPS_MAGFPOINT         0x01000000L
#define D3DPTFILTERCAPS_MAGFLINEAR        0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC   0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC    0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC 0x10000000L
#endif /* DIRECT3D_VERSION >= 0x0600 */

/* D3DPRIMCAPS dwTextureBlendCaps */

#define D3DPTBLENDCAPS_DECAL            0x00000001L
#define D3DPTBLENDCAPS_MODULATE         0x00000002L
#define D3DPTBLENDCAPS_DECALALPHA       0x00000004L
#define D3DPTBLENDCAPS_MODULATEALPHA    0x00000008L
#define D3DPTBLENDCAPS_DECALMASK        0x00000010L
#define D3DPTBLENDCAPS_MODULATEMASK     0x00000020L
#define D3DPTBLENDCAPS_COPY             0x00000040L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPTBLENDCAPS_ADD              0x00000080L
#endif /* DIRECT3D_VERSION >= 0x0500 */

/* D3DPRIMCAPS dwTextureAddressCaps */
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

/* D3DDEVICEDESC dwStencilCaps */

#define D3DSTENCILCAPS_KEEP     0x00000001L
#define D3DSTENCILCAPS_ZERO     0x00000002L
#define D3DSTENCILCAPS_REPLACE  0x00000004L
#define D3DSTENCILCAPS_INCRSAT  0x00000008L
#define D3DSTENCILCAPS_DECRSAT  0x00000010L
#define D3DSTENCILCAPS_INVERT   0x00000020L
#define D3DSTENCILCAPS_INCR     0x00000040L
#define D3DSTENCILCAPS_DECR     0x00000080L

/* D3DDEVICEDESC dwTextureOpCaps */

#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L

/* D3DDEVICEDESC dwFVFCaps flags */

#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */

#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 */
typedef struct _D3DDeviceDesc {
    DWORD            dwSize;                 /* Size of D3DDEVICEDESC structure */
    DWORD            dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;          /* Color model of device */
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL             bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD            dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD            dwMaxVertexCount;       /* Maximum vertex count */
#if(DIRECT3D_VERSION >= 0x0500)
    // *** New fields for DX5 *** //

    // Width and height caps are 0 for legacy HALs.
    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
    // New fields for DX6
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    // Guard band that the rasterizer can accommodate
    // Screen-space vertices inside this space but outside the viewport
    // will get clipped properly.
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
#endif /* DIRECT3D_VERSION >= 0x0600 */
} D3DDEVICEDESC, *LPD3DDEVICEDESC;

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DDeviceDesc7 {
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */

    DWORD       dwMinTextureWidth, dwMinTextureHeight;
    DWORD       dwMaxTextureWidth, dwMaxTextureHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;
    GUID        deviceGUID;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
} D3DDEVICEDESC7, *LPD3DDEVICEDESC7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#define D3DDEVICEDESCSIZE (sizeof(D3DDEVICEDESC))
#define D3DDEVICEDESC7SIZE (sizeof(D3DDEVICEDESC7))

typedef HRESULT (CALLBACK * LPD3DENUMDEVICESCALLBACK)(GUID FAR *lpGuid, LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC, LPD3DDEVICEDESC, LPVOID);

#if(DIRECT3D_VERSION >= 0x0700)
typedef HRESULT (CALLBACK * LPD3DENUMDEVICESCALLBACK7)(LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC7, LPVOID);
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* D3DDEVICEDESC dwFlags indicating valid fields */

#define D3DDD_COLORMODEL            0x00000001L /* dcmColorModel is valid */
#define D3DDD_DEVCAPS               0x00000002L /* dwDevCaps is valid */
#define D3DDD_TRANSFORMCAPS         0x00000004L /* dtcTransformCaps is valid */
#define D3DDD_LIGHTINGCAPS          0x00000008L /* dlcLightingCaps is valid */
#define D3DDD_BCLIPPING             0x00000010L /* bClipping is valid */
#define D3DDD_LINECAPS              0x00000020L /* dpcLineCaps is valid */
#define D3DDD_TRICAPS               0x00000040L /* dpcTriCaps is valid */
#define D3DDD_DEVICERENDERBITDEPTH  0x00000080L /* dwDeviceRenderBitDepth is valid */
#define D3DDD_DEVICEZBUFFERBITDEPTH 0x00000100L /* dwDeviceZBufferBitDepth is valid */
#define D3DDD_MAXBUFFERSIZE         0x00000200L /* dwMaxBufferSize is valid */
#define D3DDD_MAXVERTEXCOUNT        0x00000400L /* dwMaxVertexCount is valid */

/* D3DDEVICEDESC dwDevCaps flags */

#define D3DDEVCAPS_FLOATTLVERTEX        0x00000001L /* Device accepts floating point */
                                                    /* for post-transform vertex data */
#define D3DDEVCAPS_SORTINCREASINGZ      0x00000002L /* Device needs data sorted for increasing Z */
#define D3DDEVCAPS_SORTDECREASINGZ      0X00000004L /* Device needs data sorted for decreasing Z */
#define D3DDEVCAPS_SORTEXACT            0x00000008L /* Device needs data sorted exactly */

#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
#define D3DDEVCAPS_DRAWPRIMITIVES2         0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX       0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT     0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL     0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION         0x00080000L /* Device has HW acceleration for rasterization */

/*
 * These are the flags in the D3DDEVICEDESC7.dwVertexProcessingCaps field
 */

/* device can do texgen */
#define D3DVTXPCAPS_TEXGEN              0x00000001L
/* device can do IDirect3DDevice7 colormaterialsource ops */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L
/* device can do vertex fog */
#define D3DVTXPCAPS_VERTEXFOG           0x00000004L
/* device can do directional lights */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L
/* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L
/* device can do local viewer */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L

#endif /* DIRECT3D_VERSION >= 0x0700 */

#define D3DFDS_COLORMODEL        0x00000001L /* Match color model */
#define D3DFDS_GUID              0x00000002L /* Match guid */
#define D3DFDS_HARDWARE          0x00000004L /* Match hardware/software */
#define D3DFDS_TRIANGLES         0x00000008L /* Match in triCaps */
#define D3DFDS_LINES             0x00000010L /* Match in lineCaps  */
#define D3DFDS_MISCCAPS          0x00000020L /* Match primCaps.dwMiscCaps */
#define D3DFDS_RASTERCAPS        0x00000040L /* Match primCaps.dwRasterCaps */
#define D3DFDS_ZCMPCAPS          0x00000080L /* Match primCaps.dwZCmpCaps */
#define D3DFDS_ALPHACMPCAPS      0x00000100L /* Match primCaps.dwAlphaCmpCaps */
#define D3DFDS_SRCBLENDCAPS      0x00000200L /* Match primCaps.dwSourceBlendCaps */
#define D3DFDS_DSTBLENDCAPS      0x00000400L /* Match primCaps.dwDestBlendCaps */
#define D3DFDS_SHADECAPS         0x00000800L /* Match primCaps.dwShadeCaps */
#define D3DFDS_TEXTURECAPS       0x00001000L /* Match primCaps.dwTextureCaps */
#define D3DFDS_TEXTUREFILTERCAPS 0x00002000L /* Match primCaps.dwTextureFilterCaps */
#define D3DFDS_TEXTUREBLENDCAPS  0x00004000L /* Match primCaps.dwTextureBlendCaps */
#define D3DFDS_TEXTUREADDRESSCAPS  0x00008000L /* Match primCaps.dwTextureBlendCaps */

/*
 * FindDevice arguments
 */
typedef struct _D3DFINDDEVICESEARCH {
    DWORD               dwSize;
    DWORD               dwFlags;
    BOOL                bHardware;
    D3DCOLORMODEL       dcmColorModel;
    GUID                guid;
    DWORD               dwCaps;
    D3DPRIMCAPS         dpcPrimCaps;
} D3DFINDDEVICESEARCH, *LPD3DFINDDEVICESEARCH;

typedef struct _D3DFINDDEVICERESULT {
    DWORD               dwSize;
    GUID                guid;           /* guid which matched */
    D3DDEVICEDESC       ddHwDesc;       /* hardware D3DDEVICEDESC */
    D3DDEVICEDESC       ddSwDesc;       /* software D3DDEVICEDESC */
} D3DFINDDEVICERESULT, *LPD3DFINDDEVICERESULT;

/*
 * Description of execute buffer.
 */
typedef struct _D3DExecuteBufferDesc {
    DWORD               dwSize;         /* size of this structure */
    DWORD               dwFlags;        /* flags indicating which fields are valid */
    DWORD               dwCaps;         /* capabilities of execute buffer */
    DWORD               dwBufferSize;   /* size of execute buffer data */
    LPVOID              lpData;         /* pointer to actual data */
} D3DEXECUTEBUFFERDESC, *LPD3DEXECUTEBUFFERDESC;

/* D3DEXECUTEBUFFER dwFlags indicating valid fields */

#define D3DDEB_BUFSIZE          0x00000001l     /* buffer size valid */
#define D3DDEB_CAPS             0x00000002l     /* caps valid */
#define D3DDEB_LPDATA           0x00000004l     /* lpData valid */

/* D3DEXECUTEBUFFER dwCaps */

#define D3DDEBCAPS_SYSTEMMEMORY 0x00000001l     /* buffer in system memory */
#define D3DDEBCAPS_VIDEOMEMORY  0x00000002l     /* buffer in device memory */
#define D3DDEBCAPS_MEM (D3DDEBCAPS_SYSTEMMEMORY|D3DDEBCAPS_VIDEOMEMORY)

#if(DIRECT3D_VERSION < 0x0800)

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DDEVINFO_TEXTUREMANAGER {
    BOOL    bThrashing;                 /* indicates if thrashing */
    DWORD   dwApproxBytesDownloaded;    /* Approximate number of bytes downloaded by texture manager */
    DWORD   dwNumEvicts;                /* number of textures evicted */
    DWORD   dwNumVidCreates;            /* number of textures created in video memory */
    DWORD   dwNumTexturesUsed;          /* number of textures used */
    DWORD   dwNumUsedTexInVid;          /* number of used textures present in video memory */
    DWORD   dwWorkingSet;               /* number of textures in video memory */
    DWORD   dwWorkingSetBytes;          /* number of bytes in video memory */
    DWORD   dwTotalManaged;             /* total number of managed textures */
    DWORD   dwTotalBytes;               /* total number of bytes of managed textures */
    DWORD   dwLastPri;                  /* priority of last texture evicted */
} D3DDEVINFO_TEXTUREMANAGER, *LPD3DDEVINFO_TEXTUREMANAGER;

typedef struct _D3DDEVINFO_TEXTURING {
    DWORD   dwNumLoads;                 /* counts Load() API calls */
    DWORD   dwApproxBytesLoaded;        /* Approximate number bytes loaded via Load() */
    DWORD   dwNumPreLoads;              /* counts PreLoad() API calls */
    DWORD   dwNumSet;                   /* counts SetTexture() API calls */
    DWORD   dwNumCreates;               /* counts texture creates */
    DWORD   dwNumDestroys;              /* counts texture destroys */
    DWORD   dwNumSetPriorities;         /* counts SetPriority() API calls */
    DWORD   dwNumSetLODs;               /* counts SetLOD() API calls */
    DWORD   dwNumLocks;                 /* counts number of texture locks */
    DWORD   dwNumGetDCs;                /* counts number of GetDCs to textures */
} D3DDEVINFO_TEXTURING, *LPD3DDEVINFO_TEXTURING;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#endif //(DIRECT3D_VERSION < 0x0800)

#pragma pack()


#endif /* _D3DCAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3d8types.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8types.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8TYPES_H_
#define _D3D8TYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#include <float.h>

#pragma warning(disable:4201) // anonymous unions warning
#pragma pack(4)

// D3DCOLOR is equivalent to D3DFMT_A8R8G8B8
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

// maps unsigned 8 bits/channel to D3DCOLOR
#define D3DCOLOR_ARGB(a,r,g,b) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)
#define D3DCOLOR_XRGB(r,g,b)   D3DCOLOR_ARGB(0xff,r,g,b)

// maps floating point channels (0.f to 1.f range) to D3DCOLOR
#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))


#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;
#define D3DRECT_DEFINED
#endif

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif

typedef struct _D3DVIEWPORT8 {
    DWORD       X;
    DWORD       Y;            /* Viewport Top left */
    DWORD       Width;
    DWORD       Height;       /* Viewport Dimensions */
    float       MinZ;         /* Min/max of clip Volume */
    float       MaxZ;
} D3DVIEWPORT8;

/*
 * Values for clip fields.
 */

// Max number of user clipping planes, supported in D3D.
#define D3DMAXUSERCLIPPLANES 32

// These bits could be ORed together to use with D3DRS_CLIPPLANEENABLE
//
#define D3DCLIPPLANE0 (1 << 0)
#define D3DCLIPPLANE1 (1 << 1)
#define D3DCLIPPLANE2 (1 << 2)
#define D3DCLIPPLANE3 (1 << 3)
#define D3DCLIPPLANE4 (1 << 4)
#define D3DCLIPPLANE5 (1 << 5)

// The following bits are used in the ClipUnion and ClipIntersection
// members of the D3DCLIPSTATUS8
//

#define D3DCS_LEFT        0x00000001L
#define D3DCS_RIGHT       0x00000002L
#define D3DCS_TOP         0x00000004L
#define D3DCS_BOTTOM      0x00000008L
#define D3DCS_FRONT       0x00000010L
#define D3DCS_BACK        0x00000020L
#define D3DCS_PLANE0      0x00000040L
#define D3DCS_PLANE1      0x00000080L
#define D3DCS_PLANE2      0x00000100L
#define D3DCS_PLANE3      0x00000200L
#define D3DCS_PLANE4      0x00000400L
#define D3DCS_PLANE5      0x00000800L

#define D3DCS_ALL D3DCS_LEFT   | \
                  D3DCS_RIGHT  | \
                  D3DCS_TOP    | \
                  D3DCS_BOTTOM | \
                  D3DCS_FRONT  | \
                  D3DCS_BACK   | \
                  D3DCS_PLANE0 | \
                  D3DCS_PLANE1 | \
                  D3DCS_PLANE2 | \
                  D3DCS_PLANE3 | \
                  D3DCS_PLANE4 | \
                  D3DCS_PLANE5;

typedef struct _D3DCLIPSTATUS8 {
    DWORD ClipUnion;
    DWORD ClipIntersection;
} D3DCLIPSTATUS8;

typedef struct _D3DMATERIAL8 {
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    float           Power;          /* Sharpness if specular highlight */
} D3DMATERIAL8;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

typedef struct _D3DLIGHT8 {
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    float           Range;            /* Cutoff range */
    float           Falloff;          /* Falloff */
    float           Attenuation0;     /* Constant attenuation */
    float           Attenuation1;     /* Linear attenuation */
    float           Attenuation2;     /* Quadratic attenuation */
    float           Theta;            /* Inner angle of spotlight cone */
    float           Phi;              /* Outer angle of spotlight cone */
} D3DLIGHT8;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x00000001l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000002l  /* Clear target z buffer */
#define D3DCLEAR_STENCIL           0x00000004l  /* Clear stencil planes */

/*
 * The following defines the rendering states
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT               = 1,
    D3DSHADE_GOURAUD            = 2,
    D3DSHADE_PHONG              = 3,
    D3DSHADE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;

typedef enum _D3DFILLMODE {
    D3DFILL_POINT               = 1,
    D3DFILL_WIREFRAME           = 2,
    D3DFILL_SOLID               = 3,
    D3DFILL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef struct _D3DLINEPATTERN {
    WORD    wRepeatFactor;
    WORD    wLinePattern;
} D3DLINEPATTERN;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO               = 1,
    D3DBLEND_ONE                = 2,
    D3DBLEND_SRCCOLOR           = 3,
    D3DBLEND_INVSRCCOLOR        = 4,
    D3DBLEND_SRCALPHA           = 5,
    D3DBLEND_INVSRCALPHA        = 6,
    D3DBLEND_DESTALPHA          = 7,
    D3DBLEND_INVDESTALPHA       = 8,
    D3DBLEND_DESTCOLOR          = 9,
    D3DBLEND_INVDESTCOLOR       = 10,
    D3DBLEND_SRCALPHASAT        = 11,
    D3DBLEND_BOTHSRCALPHA       = 12,
    D3DBLEND_BOTHINVSRCALPHA    = 13,
    D3DBLEND_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum _D3DBLENDOP {
    D3DBLENDOP_ADD              = 1,
    D3DBLENDOP_SUBTRACT         = 2,
    D3DBLENDOP_REVSUBTRACT      = 3,
    D3DBLENDOP_MIN              = 4,
    D3DBLENDOP_MAX              = 5,
    D3DBLENDOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DBLENDOP;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP            = 1,
    D3DTADDRESS_MIRROR          = 2,
    D3DTADDRESS_CLAMP           = 3,
    D3DTADDRESS_BORDER          = 4,
    D3DTADDRESS_MIRRORONCE      = 5,
    D3DTADDRESS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum _D3DCULL {
    D3DCULL_NONE                = 1,
    D3DCULL_CW                  = 2,
    D3DCULL_CCW                 = 3,
    D3DCULL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER                = 1,
    D3DCMP_LESS                 = 2,
    D3DCMP_EQUAL                = 3,
    D3DCMP_LESSEQUAL            = 4,
    D3DCMP_GREATER              = 5,
    D3DCMP_NOTEQUAL             = 6,
    D3DCMP_GREATEREQUAL         = 7,
    D3DCMP_ALWAYS               = 8,
    D3DCMP_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 1,
    D3DSTENCILOP_ZERO           = 2,
    D3DSTENCILOP_REPLACE        = 3,
    D3DSTENCILOP_INCRSAT        = 4,
    D3DSTENCILOP_DECRSAT        = 5,
    D3DSTENCILOP_INVERT         = 6,
    D3DSTENCILOP_INCR           = 7,
    D3DSTENCILOP_DECR           = 8,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                 = 0,
    D3DFOG_EXP                  = 1,
    D3DFOG_EXP2                 = 2,
    D3DFOG_LINEAR               = 3,
    D3DFOG_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINESTRIP             = 3,
    D3DPT_TRIANGLELIST          = 4,
    D3DPT_TRIANGLESTRIP         = 5,
    D3DPT_TRIANGLEFAN           = 6,
    D3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW          = 2,
    D3DTS_PROJECTION    = 3,
    D3DTS_TEXTURE0      = 16,
    D3DTS_TEXTURE1      = 17,
    D3DTS_TEXTURE2      = 18,
    D3DTS_TEXTURE3      = 19,
    D3DTS_TEXTURE4      = 20,
    D3DTS_TEXTURE5      = 21,
    D3DTS_TEXTURE6      = 22,
    D3DTS_TEXTURE7      = 23,
    D3DTS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

#define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + 256)
#define D3DTS_WORLD  D3DTS_WORLDMATRIX(0)
#define D3DTS_WORLD1 D3DTS_WORLDMATRIX(1)
#define D3DTS_WORLD2 D3DTS_WORLDMATRIX(2)
#define D3DTS_WORLD3 D3DTS_WORLDMATRIX(3)

typedef enum _D3DRENDERSTATETYPE {
    D3DRS_ZENABLE                   = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
    D3DRS_FILLMODE                  = 8,    /* D3DFILL_MODE        */
    D3DRS_SHADEMODE                 = 9,    /* D3DSHADEMODE */
    D3DRS_LINEPATTERN               = 10,   /* D3DLINEPATTERN */
    D3DRS_ZWRITEENABLE              = 14,   /* TRUE to enable z writes */
    D3DRS_ALPHATESTENABLE           = 15,   /* TRUE to enable alpha tests */
    D3DRS_LASTPIXEL                 = 16,   /* TRUE for last-pixel on lines */
    D3DRS_SRCBLEND                  = 19,   /* D3DBLEND */
    D3DRS_DESTBLEND                 = 20,   /* D3DBLEND */
    D3DRS_CULLMODE                  = 22,   /* D3DCULL */
    D3DRS_ZFUNC                     = 23,   /* D3DCMPFUNC */
    D3DRS_ALPHAREF                  = 24,   /* D3DFIXED */
    D3DRS_ALPHAFUNC                 = 25,   /* D3DCMPFUNC */
    D3DRS_DITHERENABLE              = 26,   /* TRUE to enable dithering */
    D3DRS_ALPHABLENDENABLE          = 27,   /* TRUE to enable alpha blending */
    D3DRS_FOGENABLE                 = 28,   /* TRUE to enable fog blending */
    D3DRS_SPECULARENABLE            = 29,   /* TRUE to enable specular */
    D3DRS_ZVISIBLE                  = 30,   /* TRUE to enable z checking */
    D3DRS_FOGCOLOR                  = 34,   /* D3DCOLOR */
    D3DRS_FOGTABLEMODE              = 35,   /* D3DFOGMODE */
    D3DRS_FOGSTART                  = 36,   /* Fog start (for both vertex and pixel fog) */
    D3DRS_FOGEND                    = 37,   /* Fog end      */
    D3DRS_FOGDENSITY                = 38,   /* Fog density  */
    D3DRS_EDGEANTIALIAS             = 40,   /* TRUE to enable edge antialiasing */
    D3DRS_ZBIAS                     = 47,   /* LONG Z bias */
    D3DRS_RANGEFOGENABLE            = 48,   /* Enables range-based fog */
    D3DRS_STENCILENABLE             = 52,   /* BOOL enable/disable stenciling */
    D3DRS_STENCILFAIL               = 53,   /* D3DSTENCILOP to do if stencil test fails */
    D3DRS_STENCILZFAIL              = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    D3DRS_STENCILPASS               = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    D3DRS_STENCILFUNC               = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRS_STENCILREF                = 57,   /* Reference value used in stencil test */
    D3DRS_STENCILMASK               = 58,   /* Mask value used in stencil test */
    D3DRS_STENCILWRITEMASK          = 59,   /* Write mask applied to values written to stencil buffer */
    D3DRS_TEXTUREFACTOR             = 60,   /* D3DCOLOR used for multi-texture blend */
    D3DRS_WRAP0                     = 128,  /* wrap for 1st texture coord. set */
    D3DRS_WRAP1                     = 129,  /* wrap for 2nd texture coord. set */
    D3DRS_WRAP2                     = 130,  /* wrap for 3rd texture coord. set */
    D3DRS_WRAP3                     = 131,  /* wrap for 4th texture coord. set */
    D3DRS_WRAP4                     = 132,  /* wrap for 5th texture coord. set */
    D3DRS_WRAP5                     = 133,  /* wrap for 6th texture coord. set */
    D3DRS_WRAP6                     = 134,  /* wrap for 7th texture coord. set */
    D3DRS_WRAP7                     = 135,  /* wrap for 8th texture coord. set */
    D3DRS_CLIPPING                  = 136,
    D3DRS_LIGHTING                  = 137,
    D3DRS_AMBIENT                   = 139,
    D3DRS_FOGVERTEXMODE             = 140,
    D3DRS_COLORVERTEX               = 141,
    D3DRS_LOCALVIEWER               = 142,
    D3DRS_NORMALIZENORMALS          = 143,
    D3DRS_DIFFUSEMATERIALSOURCE     = 145,
    D3DRS_SPECULARMATERIALSOURCE    = 146,
    D3DRS_AMBIENTMATERIALSOURCE     = 147,
    D3DRS_EMISSIVEMATERIALSOURCE    = 148,
    D3DRS_VERTEXBLEND               = 151,
    D3DRS_CLIPPLANEENABLE           = 152,
    D3DRS_SOFTWAREVERTEXPROCESSING  = 153,
    D3DRS_POINTSIZE                 = 154,   /* float point size */
    D3DRS_POINTSIZE_MIN             = 155,   /* float point size min threshold */
    D3DRS_POINTSPRITEENABLE         = 156,   /* BOOL point texture coord control */
    D3DRS_POINTSCALEENABLE          = 157,   /* BOOL point size scale enable */
    D3DRS_POINTSCALE_A              = 158,   /* float point attenuation A value */
    D3DRS_POINTSCALE_B              = 159,   /* float point attenuation B value */
    D3DRS_POINTSCALE_C              = 160,   /* float point attenuation C value */
    D3DRS_MULTISAMPLEANTIALIAS      = 161,  // BOOL - set to do FSAA with multisample buffer
    D3DRS_MULTISAMPLEMASK           = 162,  // DWORD - per-sample enable/disable
    D3DRS_PATCHEDGESTYLE            = 163,  // Sets whether patch edges will use float style tessellation
    D3DRS_PATCHSEGMENTS             = 164,  // Number of segments per edge when drawing patches
    D3DRS_DEBUGMONITORTOKEN         = 165,  // DEBUG ONLY - token to debug monitor
    D3DRS_POINTSIZE_MAX             = 166,   /* float point size max threshold */
    D3DRS_INDEXEDVERTEXBLENDENABLE  = 167,
    D3DRS_COLORWRITEENABLE          = 168,  // per-channel write enable
    D3DRS_TWEENFACTOR               = 170,   // float tween factor
    D3DRS_BLENDOP                   = 171,   // D3DBLENDOP setting

    D3DRS_FORCE_DWORD               = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// Values for material source
typedef enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL         = 0,            // Color from material is used
    D3DMCS_COLOR1           = 1,            // Diffuse vertex color is used
    D3DMCS_COLOR2           = 2,            // Specular vertex color is used
    D3DMCS_FORCE_DWORD      = 0x7fffffff,   // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;

// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 128UL

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000001L
#define D3DWRAP_V   0x00000002L
#define D3DWRAP_W   0x00000004L

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
#define D3DWRAPCOORD_0   0x00000001L    // same as D3DWRAP_U
#define D3DWRAPCOORD_1   0x00000002L    // same as D3DWRAP_V
#define D3DWRAPCOORD_2   0x00000004L    // same as D3DWRAP_W
#define D3DWRAPCOORD_3   0x00000008L

/* Flags to construct D3DRS_COLORWRITEENABLE */
#define D3DCOLORWRITEENABLE_RED     (1L<<0)
#define D3DCOLORWRITEENABLE_GREEN   (1L<<1)
#define D3DCOLORWRITEENABLE_BLUE    (1L<<2)
#define D3DCOLORWRITEENABLE_ALPHA   (1L<<3)

/*
 * State enumerants for per-stage texture processing.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP        =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
    D3DTSS_COLORARG1      =  2, /* D3DTA_* (texture arg) */
    D3DTSS_COLORARG2      =  3, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAOP        =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
    D3DTSS_ALPHAARG1      =  5, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAARG2      =  6, /* D3DTA_* (texture arg) */
    D3DTSS_BUMPENVMAT00   =  7, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT01   =  8, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT10   =  9, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT11   = 10, /* float (bump mapping matrix) */
    D3DTSS_TEXCOORDINDEX  = 11, /* identifies which set of texture coordinates index this texture */
    D3DTSS_ADDRESSU       = 13, /* D3DTEXTUREADDRESS for U coordinate */
    D3DTSS_ADDRESSV       = 14, /* D3DTEXTUREADDRESS for V coordinate */
    D3DTSS_BORDERCOLOR    = 15, /* D3DCOLOR */
    D3DTSS_MAGFILTER      = 16, /* D3DTEXTUREFILTER filter to use for magnification */
    D3DTSS_MINFILTER      = 17, /* D3DTEXTUREFILTER filter to use for minification */
    D3DTSS_MIPFILTER      = 18, /* D3DTEXTUREFILTER filter to use between mipmaps during minification */
    D3DTSS_MIPMAPLODBIAS  = 19, /* float Mipmap LOD bias */
    D3DTSS_MAXMIPLEVEL    = 20, /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
    D3DTSS_MAXANISOTROPY  = 21, /* DWORD maximum anisotropy */
    D3DTSS_BUMPENVLSCALE  = 22, /* float scale for bump map luminance */
    D3DTSS_BUMPENVLOFFSET = 23, /* float offset for bump map luminance */
    D3DTSS_TEXTURETRANSFORMFLAGS = 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */
    D3DTSS_ADDRESSW       = 25, /* D3DTEXTUREADDRESS for W coordinate */
    D3DTSS_COLORARG0      = 26, /* D3DTA_* third arg for triadic ops */
    D3DTSS_ALPHAARG0      = 27, /* D3DTA_* third arg for triadic ops */
    D3DTSS_RESULTARG      = 28, /* D3DTA_* arg for result (CURRENT or TEMP) */
    D3DTSS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURESTAGESTATETYPE;

// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
#define D3DTSS_TCI_PASSTHRU                             0x00000000
#define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
#define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum _D3DTEXTUREOP
{
    // Control
    D3DTOP_DISABLE              = 1,      // disables stage
    D3DTOP_SELECTARG1           = 2,      // the default
    D3DTOP_SELECTARG2           = 3,

    // Modulate
    D3DTOP_MODULATE             = 4,      // multiply args together
    D3DTOP_MODULATE2X           = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X           = 6,      // multiply and  2 bits

    // Add
    D3DTOP_ADD                  =  7,   // add arguments together
    D3DTOP_ADDSIGNED            =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X          =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT             = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH            = 11,   // add 2 args, subtract product
                                        // Arg1 + Arg2 - Arg1*Arg2
                                        // = Arg1 + (1-Arg1)*Arg2

    // Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRENDERSTATE_TEXTUREFACTOR

    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color

    // Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

    // Bump mapping
    D3DTOP_BUMPENVMAP           = 22, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 23, // with luminance channel

    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 24,

    // Triadic ops
    D3DTOP_MULTIPLYADD          = 25, // Arg0 + Arg1*Arg2
    D3DTOP_LERP                 = 26, // (Arg0)*Arg1 + (1-Arg0)*Arg2

    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
 * operations set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
#define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
#define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
#define D3DTA_TFACTOR           0x00000003  // select RENDERSTATE_TEXTUREFACTOR (read only)
#define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
#define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)

//
// Values for D3DTSS_***FILTER texture stage states
//
typedef enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
    D3DTEXF_POINT           = 1,    // nearest
    D3DTEXF_LINEAR          = 2,    // linear interpolation
    D3DTEXF_ANISOTROPIC     = 3,    // anisotropic
    D3DTEXF_FLATCUBIC       = 4,    // cubic
    D3DTEXF_GAUSSIANCUBIC   = 5,    // different cubic kernel
    D3DTEXF_FORCE_DWORD     = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREFILTERTYPE;

/* Bits for Flags in ProcessVertices call */

#define D3DPV_DONOTCOPYDATA     (1 << 0)

//-------------------------------------------------------------------

// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x00E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#define D3DFVF_XYZB1            0x006
#define D3DFVF_XYZB2            0x008
#define D3DFVF_XYZB3            0x00a
#define D3DFVF_XYZB4            0x00c
#define D3DFVF_XYZB5            0x00e

#define D3DFVF_NORMAL           0x010
#define D3DFVF_PSIZE            0x020
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400
#define D3DFVF_TEX5             0x500
#define D3DFVF_TEX6             0x600
#define D3DFVF_TEX7             0x700
#define D3DFVF_TEX8             0x800

#define D3DFVF_LASTBETA_UBYTE4  0x1000

#define D3DFVF_RESERVED2        0xE000  // 4 reserved bits

//---------------------------------------------------------------------
// Vertex Shaders
//

/*

Vertex Shader Declaration

The declaration portion of a vertex shader defines the static external
interface of the shader.  The information in the declaration includes:

- Assignments of vertex shader input registers to data streams.  These
assignments bind a specific vertex register to a single component within a
vertex stream.  A vertex stream element is identified by a byte offset
within the stream and a type.  The type specifies the arithmetic data type
plus the dimensionality (1, 2, 3, or 4 values).  Stream data which is
less than 4 values are always expanded out to 4 values with zero or more
0.F values and one 1.F value.

- Assignment of vertex shader input registers to implicit data from the
primitive tessellator.  This controls the loading of vertex data which is
not loaded from a stream, but rather is generated during primitive
tessellation prior to the vertex shader.

- Loading data into the constant memory at the time a shader is set as the
current shader.  Each token specifies values for one or more contiguous 4
DWORD constant registers.  This allows the shader to update an arbitrary
subset of the constant memory, overwriting the device state (which
contains the current values of the constant memory).  Note that these
values can be subsequently overwritten (between DrawPrimitive calls)
during the time a shader is bound to a device via the
SetVertexShaderConstant method.


Declaration arrays are single-dimensional arrays of DWORDs composed of
multiple tokens each of which is one or more DWORDs.  The single-DWORD
token value 0xFFFFFFFF is a special token used to indicate the end of the
declaration array.  The single DWORD token value 0x00000000 is a NOP token
with is ignored during the declaration parsing.  Note that 0x00000000 is a
valid value for DWORDs following the first DWORD for multiple word tokens.

[31:29] TokenType
    0x0 - NOP (requires all DWORD bits to be zero)
    0x1 - stream selector
    0x2 - stream data definition (map to vertex input memory)
    0x3 - vertex input memory from tessellator
    0x4 - constant memory from shader
    0x5 - extension
    0x6 - reserved
    0x7 - end-of-array (requires all DWORD bits to be 1)

NOP Token (single DWORD token)
    [31:29] 0x0
    [28:00] 0x0

Stream Selector (single DWORD token)
    [31:29] 0x1
    [28]    indicates whether this is a tessellator stream
    [27:04] 0x0
    [03:00] stream selector (0..15)

Stream Data Definition (single DWORD token)
    Vertex Input Register Load
      [31:29] 0x2
      [28]    0x0
      [27:20] 0x0
      [19:16] type (dimensionality and data type)
      [15:04] 0x0
      [03:00] vertex register address (0..15)
    Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27:20] 0x0
      [19:16] count of DWORDS to skip over (0..15)
      [15:00] 0x0
    Vertex Input Memory from Tessellator Data (single DWORD token)
      [31:29] 0x3
      [28]    indicates whether data is normals or u/v
      [27:24] 0x0
      [23:20] vertex register address (0..15)
      [19:16] type (dimensionality)
      [15:04] 0x0
      [03:00] vertex register address (0..15)

Constant Memory from Shader (multiple DWORD token)
    [31:29] 0x4
    [28:25] count of 4*DWORD constants to load (0..15)
    [24:07] 0x0
    [06:00] constant memory address (0..95)

Extension Token (single or multiple DWORD token)
    [31:29] 0x5
    [28:24] count of additional DWORDs in token (0..31)
    [23:00] extension-specific information

End-of-array token (single DWORD token)
    [31:29] 0x7
    [28:00] 0x1fffffff

The stream selector token must be immediately followed by a contiguous set of stream data definition tokens.  This token sequence fully defines that stream, including the set of elements within the stream, the order in which the elements appear, the type of each element, and the vertex register into which to load an element.
Streams are allowed to include data which is not loaded into a vertex register, thus allowing data which is not used for this shader to exist in the vertex stream.  This skipped data is defined only by a count of DWORDs to skip over, since the type information is irrelevant.
The token sequence:
Stream Select: stream=0
Stream Data Definition (Load): type=FLOAT3; register=3
Stream Data Definition (Load): type=FLOAT3; register=4
Stream Data Definition (Skip): count=2
Stream Data Definition (Load): type=FLOAT2; register=7

defines stream zero to consist of 4 elements, 3 of which are loaded into registers and the fourth skipped over.  Register 3 is loaded with the first three DWORDs in each vertex interpreted as FLOAT data.  Register 4 is loaded with the 4th, 5th, and 6th DWORDs interpreted as FLOAT data.  The next two DWORDs (7th and 8th) are skipped over and not loaded into any vertex input register.   Register 7 is loaded with the 9th and 10th DWORDS interpreted as FLOAT data.
Placing of tokens other than NOPs between the Stream Selector and Stream Data Definition tokens is disallowed.

*/

typedef enum _D3DVSD_TOKENTYPE
{
    D3DVSD_TOKEN_NOP        = 0,    // NOP or extension
    D3DVSD_TOKEN_STREAM,            // stream selector
    D3DVSD_TOKEN_STREAMDATA,        // stream data definition (map to vertex input memory)
    D3DVSD_TOKEN_TESSELLATOR,       // vertex input memory from tessellator
    D3DVSD_TOKEN_CONSTMEM,          // constant memory from shader
    D3DVSD_TOKEN_EXT,               // extension
    D3DVSD_TOKEN_END = 7,           // end-of-array (requires all DWORD bits to be 1)
    D3DVSD_FORCE_DWORD = 0x7fffffff,// force 32-bit size enum
} D3DVSD_TOKENTYPE;

#define D3DVSD_TOKENTYPESHIFT   29
#define D3DVSD_TOKENTYPEMASK    (7 << D3DVSD_TOKENTYPESHIFT)

#define D3DVSD_STREAMNUMBERSHIFT 0
#define D3DVSD_STREAMNUMBERMASK (0xF << D3DVSD_STREAMNUMBERSHIFT)

#define D3DVSD_DATALOADTYPESHIFT 28
#define D3DVSD_DATALOADTYPEMASK (0x1 << D3DVSD_DATALOADTYPESHIFT)

#define D3DVSD_DATATYPESHIFT 16
#define D3DVSD_DATATYPEMASK (0xF << D3DVSD_DATATYPESHIFT)

#define D3DVSD_SKIPCOUNTSHIFT 16
#define D3DVSD_SKIPCOUNTMASK (0xF << D3DVSD_SKIPCOUNTSHIFT)

#define D3DVSD_VERTEXREGSHIFT 0
#define D3DVSD_VERTEXREGMASK (0x1F << D3DVSD_VERTEXREGSHIFT)

#define D3DVSD_VERTEXREGINSHIFT 20
#define D3DVSD_VERTEXREGINMASK (0xF << D3DVSD_VERTEXREGINSHIFT)

#define D3DVSD_CONSTCOUNTSHIFT 25
#define D3DVSD_CONSTCOUNTMASK (0xF << D3DVSD_CONSTCOUNTSHIFT)

#define D3DVSD_CONSTADDRESSSHIFT 0
#define D3DVSD_CONSTADDRESSMASK (0x7F << D3DVSD_CONSTADDRESSSHIFT)

#define D3DVSD_CONSTRSSHIFT 16
#define D3DVSD_CONSTRSMASK (0x1FFF << D3DVSD_CONSTRSSHIFT)

#define D3DVSD_EXTCOUNTSHIFT 24
#define D3DVSD_EXTCOUNTMASK (0x1F << D3DVSD_EXTCOUNTSHIFT)

#define D3DVSD_EXTINFOSHIFT 0
#define D3DVSD_EXTINFOMASK (0xFFFFFF << D3DVSD_EXTINFOSHIFT)

#define D3DVSD_MAKETOKENTYPE(tokenType) ((tokenType << D3DVSD_TOKENTYPESHIFT) & D3DVSD_TOKENTYPEMASK)

// macros for generation of CreateVertexShader Declaration token array

// Set current stream
// _StreamNumber [0..(MaxStreams-1)] stream to get data from
//
#define D3DVSD_STREAM( _StreamNumber ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (_StreamNumber))

// Set tessellator stream
//
#define D3DVSD_STREAMTESSSHIFT 28
#define D3DVSD_STREAMTESSMASK (1 << D3DVSD_STREAMTESSSHIFT)
#define D3DVSD_STREAM_TESS( ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (D3DVSD_STREAMTESSMASK))

// bind single vertex register to vertex element from vertex stream
//
// _VertexRegister [0..15] address of the vertex register
// _Type [D3DVSDT_*] dimensionality and arithmetic data type

#define D3DVSD_REG( _VertexRegister, _Type ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) |            \
     ((_Type) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Skip _DWORDCount DWORDs in vertex
//
#define D3DVSD_SKIP( _DWORDCount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x10000000 | \
     ((_DWORDCount) << D3DVSD_SKIPCOUNTSHIFT))

// load data into vertex shader constant memory
//
// _ConstantAddress [0..95] - address of constant array to begin filling data
// _Count [0..15] - number of constant vectors to load (4 DWORDs each)
// followed by 4*_Count DWORDS of data
//
#define D3DVSD_CONST( _ConstantAddress, _Count ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM) | \
     ((_Count) << D3DVSD_CONSTCOUNTSHIFT) | (_ConstantAddress))

// enable tessellator generated normals
//
// _VertexRegisterIn  [0..15] address of vertex register whose input stream
//                            will be used in normal computation
// _VertexRegisterOut [0..15] address of vertex register to output the normal to
//
#define D3DVSD_TESSNORMAL( _VertexRegisterIn, _VertexRegisterOut ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | \
     ((_VertexRegisterIn) << D3DVSD_VERTEXREGINSHIFT) | \
     ((0x02) << D3DVSD_DATATYPESHIFT) | (_VertexRegisterOut))

// enable tessellator generated surface parameters
//
// _VertexRegister [0..15] address of vertex register to output parameters
//
#define D3DVSD_TESSUV( _VertexRegister ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | 0x10000000 | \
     ((0x01) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Generates END token
//
#define D3DVSD_END() 0xFFFFFFFF

// Generates NOP token
#define D3DVSD_NOP() 0x00000000

// bit declarations for _Type fields
#define D3DVSDT_FLOAT1      0x00    // 1D float expanded to (value, 0., 0., 1.)
#define D3DVSDT_FLOAT2      0x01    // 2D float expanded to (value, value, 0., 1.)
#define D3DVSDT_FLOAT3      0x02    // 3D float expanded to (value, value, value, 1.)
#define D3DVSDT_FLOAT4      0x03    // 4D float
#define D3DVSDT_D3DCOLOR    0x04    // 4D packed unsigned bytes mapped to 0. to 1. range
                                    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
#define D3DVSDT_UBYTE4      0x05    // 4D unsigned byte
#define D3DVSDT_SHORT2      0x06    // 2D signed short expanded to (value, value, 0., 1.)
#define D3DVSDT_SHORT4      0x07    // 4D signed short

// assignments of vertex input registers for fixed function vertex shader
//
#define D3DVSDE_POSITION        0
#define D3DVSDE_BLENDWEIGHT     1
#define D3DVSDE_BLENDINDICES    2
#define D3DVSDE_NORMAL          3
#define D3DVSDE_PSIZE           4
#define D3DVSDE_DIFFUSE         5
#define D3DVSDE_SPECULAR        6
#define D3DVSDE_TEXCOORD0       7
#define D3DVSDE_TEXCOORD1       8
#define D3DVSDE_TEXCOORD2       9
#define D3DVSDE_TEXCOORD3       10
#define D3DVSDE_TEXCOORD4       11
#define D3DVSDE_TEXCOORD5       12
#define D3DVSDE_TEXCOORD6       13
#define D3DVSDE_TEXCOORD7       14
#define D3DVSDE_POSITION2       15
#define D3DVSDE_NORMAL2         16

// Maximum supported number of texture coordinate sets
#define D3DDP_MAXTEXCOORD   8


//
// Instruction Token Bit Definitions
//
#define D3DSI_OPCODE_MASK       0x0000FFFF

typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
{
    D3DSIO_NOP          = 0,    // PS/VS
    D3DSIO_MOV          ,       // PS/VS
    D3DSIO_ADD          ,       // PS/VS
    D3DSIO_SUB          ,       // PS
    D3DSIO_MAD          ,       // PS/VS
    D3DSIO_MUL          ,       // PS/VS
    D3DSIO_RCP          ,       // VS
    D3DSIO_RSQ          ,       // VS
    D3DSIO_DP3          ,       // PS/VS
    D3DSIO_DP4          ,       // PS/VS
    D3DSIO_MIN          ,       // VS
    D3DSIO_MAX          ,       // VS
    D3DSIO_SLT          ,       // VS
    D3DSIO_SGE          ,       // VS
    D3DSIO_EXP          ,       // VS
    D3DSIO_LOG          ,       // VS
    D3DSIO_LIT          ,       // VS
    D3DSIO_DST          ,       // VS
    D3DSIO_LRP          ,       // PS
    D3DSIO_FRC          ,       // VS
    D3DSIO_M4x4         ,       // VS
    D3DSIO_M4x3         ,       // VS
    D3DSIO_M3x4         ,       // VS
    D3DSIO_M3x3         ,       // VS
    D3DSIO_M3x2         ,       // VS

    D3DSIO_TEXCOORD     = 64,   // PS
    D3DSIO_TEXKILL      ,       // PS
    D3DSIO_TEX          ,       // PS
    D3DSIO_TEXBEM       ,       // PS
    D3DSIO_TEXBEML      ,       // PS
    D3DSIO_TEXREG2AR    ,       // PS
    D3DSIO_TEXREG2GB    ,       // PS
    D3DSIO_TEXM3x2PAD   ,       // PS
    D3DSIO_TEXM3x2TEX   ,       // PS
    D3DSIO_TEXM3x3PAD   ,       // PS
    D3DSIO_TEXM3x3TEX   ,       // PS
    D3DSIO_TEXM3x3DIFF  ,       // PS
    D3DSIO_TEXM3x3SPEC  ,       // PS
    D3DSIO_TEXM3x3VSPEC ,       // PS
    D3DSIO_EXPP         ,       // VS
    D3DSIO_LOGP         ,       // VS
    D3DSIO_CND          ,       // PS
    D3DSIO_DEF          ,       // PS
    D3DSIO_COMMENT      = 0xFFFE,
    D3DSIO_END          = 0xFFFF,

    D3DSIO_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;

//
// Co-Issue Instruction Modifier - if set then this instruction is to be
// issued in parallel with the previous instruction(s) for which this bit
// is not set.
//
#define D3DSI_COISSUE           0x40000000

//
// Parameter Token Bit Definitions
//
#define D3DSP_REGNUM_MASK       0x00000FFF

// destination parameter write mask
#define D3DSP_WRITEMASK_0       0x00010000  // Component 0 (X;Red)
#define D3DSP_WRITEMASK_1       0x00020000  // Component 1 (Y;Green)
#define D3DSP_WRITEMASK_2       0x00040000  // Component 2 (Z;Blue)
#define D3DSP_WRITEMASK_3       0x00080000  // Component 3 (W;Alpha)
#define D3DSP_WRITEMASK_ALL     0x000F0000  // All Components

// destination parameter modifiers
#define D3DSP_DSTMOD_SHIFT      20
#define D3DSP_DSTMOD_MASK       0x00F00000

typedef enum _D3DSHADER_PARAM_DSTMOD_TYPE
{
    D3DSPDM_NONE    = 0<<D3DSP_DSTMOD_SHIFT, // nop
    D3DSPDM_SATURATE= 1<<D3DSP_DSTMOD_SHIFT, // clamp to 0. to 1. range
    D3DSPDM_FORCE_DWORD  = 0x7fffffff,      // force 32-bit size enum
} D3DSHADER_PARAM_DSTMOD_TYPE;

// destination parameter 
#define D3DSP_DSTSHIFT_SHIFT    24
#define D3DSP_DSTSHIFT_MASK     0x0F000000

// destination/source parameter register type
#define D3DSP_REGTYPE_SHIFT     28
#define D3DSP_REGTYPE_MASK      0x70000000

typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
{
    D3DSPR_TEMP     = 0<<D3DSP_REGTYPE_SHIFT, // Temporary Register File
    D3DSPR_INPUT    = 1<<D3DSP_REGTYPE_SHIFT, // Input Register File
    D3DSPR_CONST    = 2<<D3DSP_REGTYPE_SHIFT, // Constant Register File
    D3DSPR_ADDR     = 3<<D3DSP_REGTYPE_SHIFT, // Address Register (VS)
    D3DSPR_TEXTURE  = 3<<D3DSP_REGTYPE_SHIFT, // Texture Register File (PS)
    D3DSPR_RASTOUT  = 4<<D3DSP_REGTYPE_SHIFT, // Rasterizer Register File
    D3DSPR_ATTROUT  = 5<<D3DSP_REGTYPE_SHIFT, // Attribute Output Register File
    D3DSPR_TEXCRDOUT= 6<<D3DSP_REGTYPE_SHIFT, // Texture Coordinate Output Register File
    D3DSPR_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DSHADER_PARAM_REGISTER_TYPE;

// Register offsets in the Rasterizer Register File
//
typedef enum _D3DVS_RASTOUT_OFFSETS
{
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DVS_RASTOUT_OFFSETS;

// Source operand addressing modes

#define D3DVS_ADDRESSMODE_SHIFT 13
#define D3DVS_ADDRESSMODE_MASK  (1 << D3DVS_ADDRESSMODE_SHIFT)

typedef enum _D3DVS_ADDRESSMODE_TYPE
{
    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),   // Relative to register A0
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVS_ADDRESSMODE_TYPE;

// Source operand swizzle definitions
//
#define D3DVS_SWIZZLE_SHIFT     16
#define D3DVS_SWIZZLE_MASK      0x00FF0000

// The following bits define where to take component X:

#define D3DVS_X_X       (0 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Y       (1 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Z       (2 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_W       (3 << D3DVS_SWIZZLE_SHIFT)

// The following bits define where to take component Y:

#define D3DVS_Y_X       (0 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_W       (3 << (D3DVS_SWIZZLE_SHIFT + 2))

// The following bits define where to take component Z:

#define D3DVS_Z_X       (0 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_W       (3 << (D3DVS_SWIZZLE_SHIFT + 4))

// The following bits define where to take component W:

#define D3DVS_W_X       (0 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_W       (3 << (D3DVS_SWIZZLE_SHIFT + 6))

// Value when there is no swizzle (X is taken from X, Y is taken from Y,
// Z is taken from Z, W is taken from W
//
#define D3DVS_NOSWIZZLE (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)

// source parameter swizzle
#define D3DSP_SWIZZLE_SHIFT     16
#define D3DSP_SWIZZLE_MASK      0x00FF0000

#define D3DSP_NOSWIZZLE \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// pixel-shader swizzle ops
#define D3DSP_REPLICATEALPHA \
    ( (3 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// source parameter modifiers
#define D3DSP_SRCMOD_SHIFT      24
#define D3DSP_SRCMOD_MASK       0x0F000000

typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
{
    D3DSPSM_NONE    = 0<<D3DSP_SRCMOD_SHIFT, // nop
    D3DSPSM_NEG     = 1<<D3DSP_SRCMOD_SHIFT, // negate
    D3DSPSM_BIAS    = 2<<D3DSP_SRCMOD_SHIFT, // bias
    D3DSPSM_BIASNEG = 3<<D3DSP_SRCMOD_SHIFT, // bias and negate
    D3DSPSM_SIGN    = 4<<D3DSP_SRCMOD_SHIFT, // sign
    D3DSPSM_SIGNNEG = 5<<D3DSP_SRCMOD_SHIFT, // sign and negate
    D3DSPSM_COMP    = 6<<D3DSP_SRCMOD_SHIFT, // complement
    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
} D3DSHADER_PARAM_SRCMOD_TYPE;

// pixel shader version token
#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))

// vertex shader version token
#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))

// extract major/minor from version cap
#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)

// destination/source parameter register type
#define D3DSI_COMMENTSIZE_SHIFT     16
#define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
#define D3DSHADER_COMMENT(_DWordSize) \
    ((((_DWordSize)<<D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|D3DSIO_COMMENT)

// pixel/vertex shader end token
#define D3DPS_END()  0x0000FFFF
#define D3DVS_END()  0x0000FFFF

//---------------------------------------------------------------------

// High order surfaces
//
typedef enum _D3DBASISTYPE
{
   D3DBASIS_BEZIER      = 0,
   D3DBASIS_BSPLINE     = 1,
   D3DBASIS_INTERPOLATE = 2,
   D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;

typedef enum _D3DORDERTYPE
{
   D3DORDER_LINEAR      = 1,
   D3DORDER_CUBIC       = 3,
   D3DORDER_QUINTIC     = 5,
   D3DORDER_FORCE_DWORD = 0x7fffffff,
} D3DORDERTYPE;

typedef enum _D3DPATCHEDGESTYLE
{
   D3DPATCHEDGE_DISCRETE    = 0,
   D3DPATCHEDGE_CONTINUOUS  = 1,
   D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0x7fffffff,
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBF_DISABLE  = 0,     // Disable vertex blending
    D3DVBF_1WEIGHTS = 1,     // 2 matrix blending
    D3DVBF_2WEIGHTS = 2,     // 3 matrix blending
    D3DVBF_3WEIGHTS = 3,     // 4 matrix blending
    D3DVBF_TWEENING = 255,   // blending using D3DRS_TWEENFACTOR
    D3DVBF_0WEIGHTS = 256,   // one matrix is used with weight 1.0
    D3DVBF_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS {
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


//---------------------------------------------------------------------

/* Direct3D8 Device types */
typedef enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL         = 1,
    D3DDEVTYPE_REF         = 2,
    D3DDEVTYPE_SW          = 3,

    D3DDEVTYPE_FORCE_DWORD  = 0x7fffffff
} D3DDEVTYPE;

/* Multi-Sample buffer types */
typedef enum _D3DMULTISAMPLE_TYPE
{
    D3DMULTISAMPLE_NONE            =  0,
    D3DMULTISAMPLE_2_SAMPLES       =  2,
    D3DMULTISAMPLE_3_SAMPLES       =  3,
    D3DMULTISAMPLE_4_SAMPLES       =  4,
    D3DMULTISAMPLE_5_SAMPLES       =  5,
    D3DMULTISAMPLE_6_SAMPLES       =  6,
    D3DMULTISAMPLE_7_SAMPLES       =  7,
    D3DMULTISAMPLE_8_SAMPLES       =  8,
    D3DMULTISAMPLE_9_SAMPLES       =  9,
    D3DMULTISAMPLE_10_SAMPLES      = 10,
    D3DMULTISAMPLE_11_SAMPLES      = 11,
    D3DMULTISAMPLE_12_SAMPLES      = 12,
    D3DMULTISAMPLE_13_SAMPLES      = 13,
    D3DMULTISAMPLE_14_SAMPLES      = 14,
    D3DMULTISAMPLE_15_SAMPLES      = 15,
    D3DMULTISAMPLE_16_SAMPLES      = 16,

    D3DMULTISAMPLE_FORCE_DWORD     = 0x7fffffff
} D3DMULTISAMPLE_TYPE;

/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D16 indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */
#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |       \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif /* defined(MAKEFOURCC) */


typedef enum _D3DFORMAT
{
    D3DFMT_UNKNOWN              =  0,

    D3DFMT_R8G8B8               = 20,
    D3DFMT_A8R8G8B8             = 21,
    D3DFMT_X8R8G8B8             = 22,
    D3DFMT_R5G6B5               = 23,
    D3DFMT_X1R5G5B5             = 24,
    D3DFMT_A1R5G5B5             = 25,
    D3DFMT_A4R4G4B4             = 26,
    D3DFMT_R3G3B2               = 27,
    D3DFMT_A8                   = 28,
    D3DFMT_A8R3G3B2             = 29,
    D3DFMT_X4R4G4B4             = 30,

    D3DFMT_A8P8                 = 40,
    D3DFMT_P8                   = 41,

    D3DFMT_L8                   = 50,
    D3DFMT_A8L8                 = 51,
    D3DFMT_A4L4                 = 52,

    D3DFMT_V8U8                 = 60,
    D3DFMT_L6V5U5               = 61,
    D3DFMT_X8L8V8U8             = 62,
    D3DFMT_Q8W8V8U8             = 63,
    D3DFMT_V16U16               = 64,
    D3DFMT_W11V11U10            = 65,

    D3DFMT_UYVY                 = MAKEFOURCC('U', 'Y', 'V', 'Y'),
    D3DFMT_YUY2                 = MAKEFOURCC('Y', 'U', 'Y', '2'),
    D3DFMT_DXT1                 = MAKEFOURCC('D', 'X', 'T', '1'),
    D3DFMT_DXT2                 = MAKEFOURCC('D', 'X', 'T', '2'),
    D3DFMT_DXT3                 = MAKEFOURCC('D', 'X', 'T', '3'),
    D3DFMT_DXT4                 = MAKEFOURCC('D', 'X', 'T', '4'),
    D3DFMT_DXT5                 = MAKEFOURCC('D', 'X', 'T', '5'),

    D3DFMT_D16_LOCKABLE         = 70,
    D3DFMT_D32                  = 71,
    D3DFMT_D15S1                = 73,
    D3DFMT_D24S8                = 75,
    D3DFMT_D16                  = 80,
    D3DFMT_D24X8                = 77,
    D3DFMT_D24X4S4              = 79,


    D3DFMT_VERTEXDATA           =100,
    D3DFMT_INDEX16              =101,
    D3DFMT_INDEX32              =102,

    D3DFMT_FORCE_DWORD          =0x7fffffff
} D3DFORMAT;

/* Display Modes */
typedef struct _D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    D3DFORMAT       Format;
} D3DDISPLAYMODE;

/* Creation Parameters */
typedef struct _D3DDEVICE_CREATION_PARAMETERS
{
    UINT            AdapterOrdinal;
    D3DDEVTYPE      DeviceType;
    HWND            hFocusWindow;
    DWORD           BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;


/* SwapEffects */
typedef enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD           = 1,
    D3DSWAPEFFECT_FLIP              = 2,
    D3DSWAPEFFECT_COPY              = 3,
    D3DSWAPEFFECT_COPY_VSYNC        = 4,

    D3DSWAPEFFECT_FORCE_DWORD       = 0x7fffffff
} D3DSWAPEFFECT;

/* Pool types */
typedef enum _D3DPOOL {
    D3DPOOL_DEFAULT                 = 0,
    D3DPOOL_MANAGED                 = 1,
    D3DPOOL_SYSTEMMEM               = 2,

    D3DPOOL_FORCE_DWORD             = 0x7fffffff
} D3DPOOL;


/* RefreshRate pre-defines */
#define D3DPRESENT_RATE_DEFAULT         0x00000000
#define D3DPRESENT_RATE_UNLIMITED       0x7fffffff


/* Resize Optional Parameters */
typedef struct _D3DPRESENT_PARAMETERS_
{
    UINT                BackBufferWidth;
    UINT                BackBufferHeight;
    D3DFORMAT           BackBufferFormat;
    UINT                BackBufferCount;

    D3DMULTISAMPLE_TYPE MultiSampleType;

    D3DSWAPEFFECT       SwapEffect;
    HWND                hDeviceWindow;
    BOOL                Windowed;
    BOOL                EnableAutoDepthStencil;
    D3DFORMAT           AutoDepthStencilFormat;
    DWORD               Flags;

    /* Following elements must be zero for Windowed mode */
    UINT                FullScreen_RefreshRateInHz;
    UINT                FullScreen_PresentationInterval;

} D3DPRESENT_PARAMETERS;

// Values for D3DPRESENT_PARAMETERS.Flags

#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER  0x00000001


/* Gamma Ramp: Same as DX7 */

typedef struct _D3DGAMMARAMP
{
    WORD                red  [256];
    WORD                green[256];
    WORD                blue [256];
} D3DGAMMARAMP;

/* Back buffer types */
typedef enum _D3DBACKBUFFER_TYPE
{
    D3DBACKBUFFER_TYPE_MONO         = 0,
    D3DBACKBUFFER_TYPE_LEFT         = 1,
    D3DBACKBUFFER_TYPE_RIGHT        = 2,

    D3DBACKBUFFER_TYPE_FORCE_DWORD  = 0x7fffffff
} D3DBACKBUFFER_TYPE;


/* Types */
typedef enum _D3DRESOURCETYPE {
    D3DRTYPE_SURFACE                =  1,
    D3DRTYPE_VOLUME                 =  2,
    D3DRTYPE_TEXTURE                =  3,
    D3DRTYPE_VOLUMETEXTURE          =  4,
    D3DRTYPE_CUBETEXTURE            =  5,
    D3DRTYPE_VERTEXBUFFER           =  6,
    D3DRTYPE_INDEXBUFFER            =  7,


    D3DRTYPE_FORCE_DWORD            = 0x7fffffff
} D3DRESOURCETYPE;

/* Usages */
#define D3DUSAGE_RENDERTARGET       (0x00000001L)
#define D3DUSAGE_DEPTHSTENCIL       (0x00000002L)

/* Usages for Vertex/Index buffers */
#define D3DUSAGE_WRITEONLY          (0x00000008L)
#define D3DUSAGE_SOFTWAREPROCESSING (0x00000010L)
#define D3DUSAGE_DONOTCLIP          (0x00000020L)
#define D3DUSAGE_POINTS             (0x00000040L)
#define D3DUSAGE_RTPATCHES          (0x00000080L)
#define D3DUSAGE_NPATCHES           (0x00000100L)
#define D3DUSAGE_DYNAMIC            (0x00000200L)









/* CubeMap Face identifiers */
typedef enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X     = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X     = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y     = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y     = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z     = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z     = 5,

    D3DCUBEMAP_FACE_FORCE_DWORD    = 0x7fffffff
} D3DCUBEMAP_FACES;


/* Lock flags */

#define D3DLOCK_READONLY           0x00000010L
#define D3DLOCK_DISCARD             0x00002000L
#define D3DLOCK_NOOVERWRITE        0x00001000L
#define D3DLOCK_NOSYSLOCK          0x00000800L

#define D3DLOCK_NO_DIRTY_UPDATE     0x00008000L






/* Vertex Buffer Description */
typedef struct _D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;

    DWORD               FVF;

} D3DVERTEXBUFFER_DESC;

/* Index Buffer Description */
typedef struct _D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;
} D3DINDEXBUFFER_DESC;


/* Surface Description */
typedef struct _D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC;

typedef struct _D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC;

/* Structure for LockRect */
typedef struct _D3DLOCKED_RECT
{
    INT                 Pitch;
    void*               pBits;
} D3DLOCKED_RECT;

/* Structures for LockBox */
typedef struct _D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX;

typedef struct _D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    void*               pBits;
} D3DLOCKED_BOX;

/* Structures for LockRange */
typedef struct _D3DRANGE
{
    UINT                Offset;
    UINT                Size;
} D3DRANGE;

/* Structures for high order primitives */
typedef struct _D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DRECTPATCH_INFO;

typedef struct _D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DTRIPATCH_INFO;

/* Adapter Identifier */

#define MAX_DEVICE_IDENTIFIER_STRING        512
typedef struct _D3DADAPTER_IDENTIFIER8
{
    char            Driver[MAX_DEVICE_IDENTIFIER_STRING];
    char            Description[MAX_DEVICE_IDENTIFIER_STRING];

#ifdef _WIN32
    LARGE_INTEGER   DriverVersion;            /* Defined for 32 bit components */
#else
    DWORD           DriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD           DriverVersionHighPart;
#endif

    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;

    GUID            DeviceIdentifier;

    DWORD           WHQLLevel;

} D3DADAPTER_IDENTIFIER8;


/* Raster Status structure returned by GetRasterStatus */
typedef struct _D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS;



/* Debug monitor tokens (DEBUG only)

   Note that if D3DRS_DEBUGMONITORTOKEN is set, the call is treated as
   passing a token to the debug monitor.  For example, if, after passing
   D3DDMT_ENABLE/DISABLE to D3DRS_DEBUGMONITORTOKEN other token values
   are passed in, the enabled/disabled state of the debug
   monitor will still persist.

   The debug monitor defaults to enabled.

   Calling GetRenderState on D3DRS_DEBUGMONITORTOKEN is not of any use.
*/
typedef enum _D3DDEBUGMONITORTOKENS {
    D3DDMT_ENABLE            = 0,    // enable debug monitor
    D3DDMT_DISABLE           = 1,    // disable debug monitor
    D3DDMT_FORCE_DWORD     = 0x7fffffff,
} D3DDEBUGMONITORTOKENS;

#pragma pack()
#pragma warning(default:4201)

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8TYPES(P)_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx8math.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8math.inl
//  Content:    D3DX math inline functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8MATH_INL__
#define __D3DX8MATH_INL__


//===========================================================================
//
// Inline Class Methods
//
//===========================================================================

#ifdef __cplusplus

//--------------------------
// 2D Vector
//--------------------------

D3DXINLINE
D3DXVECTOR2::D3DXVECTOR2( CONST FLOAT *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
}

D3DXINLINE
D3DXVECTOR2::D3DXVECTOR2( FLOAT fx, FLOAT fy )
{
    x = fx;
    y = fy;
}

// casting
D3DXINLINE
D3DXVECTOR2::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

D3DXINLINE
D3DXVECTOR2::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}

// assignment operators
D3DXINLINE D3DXVECTOR2&
D3DXVECTOR2::operator += ( CONST D3DXVECTOR2& v )
{
    x += v.x;
    y += v.y;
    return *this;
}

D3DXINLINE D3DXVECTOR2&
D3DXVECTOR2::operator -= ( CONST D3DXVECTOR2& v )
{
    x -= v.x;
    y -= v.y;
    return *this;
}

D3DXINLINE D3DXVECTOR2&
D3DXVECTOR2::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR2&
D3DXVECTOR2::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    return *this;
}

// unary operators
D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator - () const
{
    return D3DXVECTOR2(-x, -y);
}

// binary operators
D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator + ( CONST D3DXVECTOR2& v ) const
{
    return D3DXVECTOR2(x + v.x, y + v.y);
}

D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator - ( CONST D3DXVECTOR2& v ) const
{
    return D3DXVECTOR2(x - v.x, y - v.y);
}

D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator * ( FLOAT f ) const
{
    return D3DXVECTOR2(x * f, y * f);
}

D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR2(x * fInv, y * fInv);
}


D3DXINLINE D3DXVECTOR2
operator * ( FLOAT f, CONST D3DXVECTOR2& v )
{
    return D3DXVECTOR2(f * v.x, f * v.y);
}

D3DXINLINE BOOL
D3DXVECTOR2::operator == ( CONST D3DXVECTOR2& v ) const
{
    return x == v.x && y == v.y;
}

D3DXINLINE BOOL
D3DXVECTOR2::operator != ( CONST D3DXVECTOR2& v ) const
{
    return x != v.x || y != v.y;
}




//--------------------------
// 3D Vector
//--------------------------
D3DXINLINE
D3DXVECTOR3::D3DXVECTOR3( CONST FLOAT *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
}

D3DXINLINE
D3DXVECTOR3::D3DXVECTOR3( CONST D3DVECTOR& v )
{
    x = v.x;
    y = v.y;
    z = v.z;
}

D3DXINLINE
D3DXVECTOR3::D3DXVECTOR3( FLOAT fx, FLOAT fy, FLOAT fz )
{
    x = fx;
    y = fy;
    z = fz;
}


// casting
D3DXINLINE
D3DXVECTOR3::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

D3DXINLINE
D3DXVECTOR3::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
D3DXINLINE D3DXVECTOR3&
D3DXVECTOR3::operator += ( CONST D3DXVECTOR3& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}

D3DXINLINE D3DXVECTOR3&
D3DXVECTOR3::operator -= ( CONST D3DXVECTOR3& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}

D3DXINLINE D3DXVECTOR3&
D3DXVECTOR3::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR3&
D3DXVECTOR3::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator - () const
{
    return D3DXVECTOR3(-x, -y, -z);
}


// binary operators
D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator + ( CONST D3DXVECTOR3& v ) const
{
    return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);
}

D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator - ( CONST D3DXVECTOR3& v ) const
{
    return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);
}

D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator * ( FLOAT f ) const
{
    return D3DXVECTOR3(x * f, y * f, z * f);
}

D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
}


D3DXINLINE D3DXVECTOR3
operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
{
    return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
}


D3DXINLINE BOOL
D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
{
    return x == v.x && y == v.y && z == v.z;
}

D3DXINLINE BOOL
D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
{
    return x != v.x || y != v.y || z != v.z;
}



//--------------------------
// 4D Vector
//--------------------------
D3DXINLINE
D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

D3DXINLINE
D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
D3DXINLINE
D3DXVECTOR4::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

D3DXINLINE
D3DXVECTOR4::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
D3DXINLINE D3DXVECTOR4&
D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}

D3DXINLINE D3DXVECTOR4&
D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}

D3DXINLINE D3DXVECTOR4&
D3DXVECTOR4::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR4&
D3DXVECTOR4::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator - () const
{
    return D3DXVECTOR4(-x, -y, -z, -w);
}


// binary operators
D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
{
    return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
}

D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
{
    return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
}

D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator * ( FLOAT f ) const
{
    return D3DXVECTOR4(x * f, y * f, z * f, w * f);
}

D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
}


D3DXINLINE D3DXVECTOR4
operator * ( FLOAT f, CONST D3DXVECTOR4& v )
{
    return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
}


D3DXINLINE BOOL
D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
{
    return x == v.x && y == v.y && z == v.z && w == v.w;
}

D3DXINLINE BOOL
D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
{
    return x != v.x || y != v.y || z != v.z || w != v.w;
}


//--------------------------
// Matrix
//--------------------------
D3DXINLINE
D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    memcpy(&_11, pf, sizeof(D3DXMATRIX));
}

D3DXINLINE
D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
{
    memcpy(&_11, &mat, sizeof(D3DXMATRIX));
}

D3DXINLINE
D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
                        FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
                        FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
                        FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
{
    _11 = f11; _12 = f12; _13 = f13; _14 = f14;
    _21 = f21; _22 = f22; _23 = f23; _24 = f24;
    _31 = f31; _32 = f32; _33 = f33; _34 = f34;
    _41 = f41; _42 = f42; _43 = f43; _44 = f44;
}



// access grants
D3DXINLINE FLOAT&
D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
{
    return m[iRow][iCol];
}

D3DXINLINE FLOAT
D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
{
    return m[iRow][iCol];
}


// casting operators
D3DXINLINE
D3DXMATRIX::operator FLOAT* ()
{
    return (FLOAT *) &_11;
}

D3DXINLINE
D3DXMATRIX::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &_11;
}


// assignment operators
D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
{
    D3DXMatrixMultiply(this, this, &mat);
    return *this;
}

D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
{
    _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
    _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
    _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
    _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
    return *this;
}

D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
{
    _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
    _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
    _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
    _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
    return *this;
}

D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator *= ( FLOAT f )
{
    _11 *= f; _12 *= f; _13 *= f; _14 *= f;
    _21 *= f; _22 *= f; _23 *= f; _24 *= f;
    _31 *= f; _32 *= f; _33 *= f; _34 *= f;
    _41 *= f; _42 *= f; _43 *= f; _44 *= f;
    return *this;
}

D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
    _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
    _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
    _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator + () const
{
    return *this;
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator - () const
{
    return D3DXMATRIX(-_11, -_12, -_13, -_14,
                      -_21, -_22, -_23, -_24,
                      -_31, -_32, -_33, -_34,
                      -_41, -_42, -_43, -_44);
}


// binary operators
D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
{
    D3DXMATRIX matT;
    D3DXMatrixMultiply(&matT, this, &mat);
    return matT;
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
{
    return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
                      _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
                      _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
                      _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
{
    return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
                      _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
                      _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
                      _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator * ( FLOAT f ) const
{
    return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
                      _21 * f, _22 * f, _23 * f, _24 * f,
                      _31 * f, _32 * f, _33 * f, _34 * f,
                      _41 * f, _42 * f, _43 * f, _44 * f);
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
                      _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
                      _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
                      _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
}


D3DXINLINE D3DXMATRIX
operator * ( FLOAT f, CONST D3DXMATRIX& mat )
{
    return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
                      f * mat._21, f * mat._22, f * mat._23, f * mat._24,
                      f * mat._31, f * mat._32, f * mat._33, f * mat._34,
                      f * mat._41, f * mat._42, f * mat._43, f * mat._44);
}


D3DXINLINE BOOL
D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
{
    return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
}

D3DXINLINE BOOL
D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
{
    return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
}



//--------------------------
// Quaternion
//--------------------------

D3DXINLINE
D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

D3DXINLINE
D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
D3DXINLINE
D3DXQUATERNION::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

D3DXINLINE
D3DXQUATERNION::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
{
    x += q.x;
    y += q.y;
    z += q.z;
    w += q.w;
    return *this;
}

D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
{
    x -= q.x;
    y -= q.y;
    z -= q.z;
    w -= q.w;
    return *this;
}

D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
{
    D3DXQuaternionMultiply(this, this, &q);
    return *this;
}

D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator + () const
{
    return *this;
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator - () const
{
    return D3DXQUATERNION(-x, -y, -z, -w);
}


// binary operators
D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
{
    return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
{
    return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
{
    D3DXQUATERNION qT;
    D3DXQuaternionMultiply(&qT, this, &q);
    return qT;
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator * ( FLOAT f ) const
{
    return D3DXQUATERNION(x * f, y * f, z * f, w * f);
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
}


D3DXINLINE D3DXQUATERNION
operator * (FLOAT f, CONST D3DXQUATERNION& q )
{
    return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
}


D3DXINLINE BOOL
D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
{
    return x == q.x && y == q.y && z == q.z && w == q.w;
}

D3DXINLINE BOOL
D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
{
    return x != q.x || y != q.y || z != q.z || w != q.w;
}



//--------------------------
// Plane
//--------------------------

D3DXINLINE
D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    a = pf[0];
    b = pf[1];
    c = pf[2];
    d = pf[3];
}

D3DXINLINE
D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
{
    a = fa;
    b = fb;
    c = fc;
    d = fd;
}


// casting
D3DXINLINE
D3DXPLANE::operator FLOAT* ()
{
    return (FLOAT *) &a;
}

D3DXINLINE
D3DXPLANE::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &a;
}


// unary operators
D3DXINLINE D3DXPLANE
D3DXPLANE::operator + () const
{
    return *this;
}

D3DXINLINE D3DXPLANE
D3DXPLANE::operator - () const
{
    return D3DXPLANE(-a, -b, -c, -d);
}


// binary operators
D3DXINLINE BOOL
D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
{
    return a == p.a && b == p.b && c == p.c && d == p.d;
}

D3DXINLINE BOOL
D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
{
    return a != p.a || b != p.b || c != p.c || d != p.d;
}




//--------------------------
// Color
//--------------------------

D3DXINLINE
D3DXCOLOR::D3DXCOLOR( DWORD dw )
{
    CONST FLOAT f = 1.0f / 255.0f;
    r = f * (FLOAT) (unsigned char) (dw >> 16);
    g = f * (FLOAT) (unsigned char) (dw >>  8);
    b = f * (FLOAT) (unsigned char) (dw >>  0);
    a = f * (FLOAT) (unsigned char) (dw >> 24);
}

D3DXINLINE
D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    r = pf[0];
    g = pf[1];
    b = pf[2];
    a = pf[3];
}

D3DXINLINE
D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
{
    r = c.r;
    g = c.g;
    b = c.b;
    a = c.a;
}

D3DXINLINE
D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
{
    r = fr;
    g = fg;
    b = fb;
    a = fa;
}


// casting
D3DXINLINE
D3DXCOLOR::operator DWORD () const
{
    DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
    DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
    DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
    DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

    return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
}


D3DXINLINE
D3DXCOLOR::operator FLOAT * ()
{
    return (FLOAT *) &r;
}

D3DXINLINE
D3DXCOLOR::operator CONST FLOAT * () const
{
    return (CONST FLOAT *) &r;
}


D3DXINLINE
D3DXCOLOR::operator D3DCOLORVALUE * ()
{
    return (D3DCOLORVALUE *) &r;
}

D3DXINLINE
D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
{
    return (CONST D3DCOLORVALUE *) &r;
}


D3DXINLINE
D3DXCOLOR::operator D3DCOLORVALUE& ()
{
    return *((D3DCOLORVALUE *) &r);
}

D3DXINLINE
D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
{
    return *((CONST D3DCOLORVALUE *) &r);
}


// assignment operators
D3DXINLINE D3DXCOLOR&
D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
{
    r += c.r;
    g += c.g;
    b += c.b;
    a += c.a;
    return *this;
}

D3DXINLINE D3DXCOLOR&
D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
{
    r -= c.r;
    g -= c.g;
    b -= c.b;
    a -= c.a;
    return *this;
}

D3DXINLINE D3DXCOLOR&
D3DXCOLOR::operator *= ( FLOAT f )
{
    r *= f;
    g *= f;
    b *= f;
    a *= f;
    return *this;
}

D3DXINLINE D3DXCOLOR&
D3DXCOLOR::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    r *= fInv;
    g *= fInv;
    b *= fInv;
    a *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator + () const
{
    return *this;
}

D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator - () const
{
    return D3DXCOLOR(-r, -g, -b, -a);
}


// binary operators
D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
{
    return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
}

D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
{
    return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
}

D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator * ( FLOAT f ) const
{
    return D3DXCOLOR(r * f, g * f, b * f, a * f);
}

D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
}


D3DXINLINE D3DXCOLOR
operator * (FLOAT f, CONST D3DXCOLOR& c )
{
    return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
}


D3DXINLINE BOOL
D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
{
    return r == c.r && g == c.g && b == c.b && a == c.a;
}

D3DXINLINE BOOL
D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
{
    return r != c.r || g != c.g || b != c.b || a != c.a;
}


#endif //__cplusplus



//===========================================================================
//
// Inline functions
//
//===========================================================================


//--------------------------
// 2D Vector
//--------------------------

D3DXINLINE FLOAT D3DXVec2Length
    ( CONST D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y);
#else
    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
#endif
}

D3DXINLINE FLOAT D3DXVec2LengthSq
    ( CONST D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y;
}

D3DXINLINE FLOAT D3DXVec2Dot
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y;
}

D3DXINLINE FLOAT D3DXVec2CCW
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->y - pV1->y * pV2->x;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      FLOAT s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    return pOut;
}


//--------------------------
// 3D Vector
//--------------------------

D3DXINLINE FLOAT D3DXVec3Length
    ( CONST D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#else
    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#endif
}

D3DXINLINE FLOAT D3DXVec3LengthSq
    ( CONST D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
}

D3DXINLINE FLOAT D3DXVec3Dot
    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
    D3DXVECTOR3 v;

#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
    v.z = pV1->x * pV2->y - pV1->y * pV2->x;

    *pOut = v;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      FLOAT s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    return pOut;
}


//--------------------------
// 4D Vector
//--------------------------

D3DXINLINE FLOAT D3DXVec4Length
    ( CONST D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#else
    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#endif
}

D3DXINLINE FLOAT D3DXVec4LengthSq
    ( CONST D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
}

D3DXINLINE FLOAT D3DXVec4Dot
    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    pOut->w = pV1->w + pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    pOut->w = pV1->w - pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    pOut->w = pV->w * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      FLOAT s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    pOut->w = pV1->w + s * (pV2->w - pV1->w);
    return pOut;
}


//--------------------------
// 4D Matrix
//--------------------------

D3DXINLINE D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
    pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
    pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
    pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
    return pOut;
}


D3DXINLINE BOOL D3DXMatrixIsIdentity
    ( CONST D3DXMATRIX *pM )
{
#ifdef D3DX_DEBUG
    if(!pM)
        return FALSE;
#endif

    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
           pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
           pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
           pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
}


//--------------------------
// Quaternion
//--------------------------

D3DXINLINE FLOAT D3DXQuaternionLength
    ( CONST D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#else
    return (FLOAT) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#endif
}

D3DXINLINE FLOAT D3DXQuaternionLengthSq
    ( CONST D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

    return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
}

D3DXINLINE FLOAT D3DXQuaternionDot
    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 )
{
#ifdef D3DX_DEBUG
    if(!pQ1 || !pQ2)
        return 0.0f;
#endif

    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}


D3DXINLINE D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->x = pOut->y = pOut->z = 0.0f;
    pOut->w = 1.0f;
    return pOut;
}

D3DXINLINE BOOL D3DXQuaternionIsIdentity
    ( CONST D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return FALSE;
#endif

    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
}


D3DXINLINE D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pQ)
        return NULL;
#endif

    pOut->x = -pQ->x;
    pOut->y = -pQ->y;
    pOut->z = -pQ->z;
    pOut->w =  pQ->w;
    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXINLINE FLOAT D3DXPlaneDot
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d * pV->w;
}

D3DXINLINE FLOAT D3DXPlaneDotCoord
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
}

D3DXINLINE FLOAT D3DXPlaneDotNormal
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
}


//--------------------------
// Color
//--------------------------

D3DXINLINE D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 1.0f - pC->r;
    pOut->g = 1.0f - pC->g;
    pOut->b = 1.0f - pC->b;
    pOut->a = pC->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorAdd
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + pC2->r;
    pOut->g = pC1->g + pC2->g;
    pOut->b = pC1->b + pC2->b;
    pOut->a = pC1->a + pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorSubtract
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r - pC2->r;
    pOut->g = pC1->g - pC2->g;
    pOut->b = pC1->b - pC2->b;
    pOut->a = pC1->a - pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorScale
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = pC->r * s;
    pOut->g = pC->g * s;
    pOut->b = pC->b * s;
    pOut->a = pC->a * s;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorModulate
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r * pC2->r;
    pOut->g = pC1->g * pC2->g;
    pOut->b = pC1->b * pC2->b;
    pOut->a = pC1->a * pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorLerp
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + s * (pC2->r - pC1->r);
    pOut->g = pC1->g + s * (pC2->g - pC1->g);
    pOut->b = pC1->b + s * (pC2->b - pC1->b);
    pOut->a = pC1->a + s * (pC2->a - pC1->a);
    return pOut;
}


#endif // __D3DX8MATH_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx8core.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8core.h
//  Content:    D3DX core types and functions
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8CORE_H__
#define __D3DX8CORE_H__


///////////////////////////////////////////////////////////////////////////
// ID3DXBuffer:
// ------------
// The buffer object is used to return arbitrary lenght data.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXBuffer ID3DXBuffer;
typedef interface ID3DXBuffer *LPD3DXBUFFER;

// {932E6A7E-C68E-45dd-A7BF-53D19C86DB1F}
DEFINE_GUID(IID_ID3DXBuffer, 
0x932e6a7e, 0xc68e, 0x45dd, 0xa7, 0xbf, 0x53, 0xd1, 0x9c, 0x86, 0xdb, 0x1f);

DECLARE_INTERFACE_(ID3DXBuffer, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBuffer
    STDMETHOD_(LPVOID, GetBufferPointer)(THIS) PURE;
    STDMETHOD_(DWORD, GetBufferSize)(THIS) PURE;
};





///////////////////////////////////////////////////////////////////////////
// ID3DXFont:
// ----------
// Font objects contain the textures and resources needed to render
// a specific font on a specific device.
//
// Begin -
//    Prepartes device for drawing text.  This is optional.. if DrawText
//    is called outside of Begin/End, it will call Begin and End for you.
//
// DrawText -
//    Draws formatted text on a D3D device.  Some parameters are 
//    surprisingly similar to those of GDI's DrawText function.  See GDI 
//    documentation for a detailed description of these parameters.
//
// End -
//    Restores device state to how it was when Begin was called.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXFont ID3DXFont;
typedef interface ID3DXFont *LPD3DXFONT;


// {2D501DF7-D253-4414-865F-A6D54A753138}
DEFINE_GUID( IID_ID3DXFont,
0x2d501df7, 0xd253, 0x4414, 0x86, 0x5f, 0xa6, 0xd5, 0x4a, 0x75, 0x31, 0x38);


DECLARE_INTERFACE_(ID3DXFont, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXFont
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetLogFont)(THIS_ LOGFONT* pLogFont) PURE;

    STDMETHOD(Begin)(THIS) PURE;

    STDMETHOD_(INT, DrawTextA)(THIS_ LPCSTR  pString, INT Count, LPRECT pRect, DWORD Format, D3DCOLOR Color) PURE;
    STDMETHOD_(INT, DrawTextW)(THIS_ LPCWSTR pString, INT Count, LPRECT pRect, DWORD Format, D3DCOLOR Color) PURE;

    STDMETHOD(End)(THIS) PURE;
};

#ifndef DrawText
#ifdef UNICODE
#define DrawText DrawTextW
#else
#define DrawText DrawTextA
#endif
#endif


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateFont(
        LPDIRECT3DDEVICE8   pDevice,
        HFONT               hFont,
        LPD3DXFONT*         ppFont);


HRESULT WINAPI
    D3DXCreateFontIndirect(
        LPDIRECT3DDEVICE8   pDevice,
        CONST LOGFONT*      pLogFont,
        LPD3DXFONT*         ppFont);

#ifdef __cplusplus
}
#endif //__cplusplus







///////////////////////////////////////////////////////////////////////////
// ID3DXSprite:
// ------------
// This object intends to provide an easy way to drawing sprites using D3D.
//
// Begin - 
//    Prepares device for drawing sprites
//
// Draw, DrawAffine, DrawTransform
//    Draws a sprite in screen-space.  Before transformation, the sprite is
//    the size of SrcRect, with its top-left corner at the origin (0,0).  
//    The color and alpha channels are modulated by Color.
//
// End - 
//     Restores device state to how it was when Begin was called.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXSprite ID3DXSprite;
typedef interface ID3DXSprite *LPD3DXSPRITE;


// {E8691849-87B8-4929-9050-1B0542D5538C}
DEFINE_GUID( IID_ID3DXSprite, 
0xe8691849, 0x87b8, 0x4929, 0x90, 0x50, 0x1b, 0x5, 0x42, 0xd5, 0x53, 0x8c);


DECLARE_INTERFACE_(ID3DXSprite, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSprite
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;

    STDMETHOD(Begin)(THIS) PURE;

    STDMETHOD(Draw)(THIS_ LPDIRECT3DTEXTURE8  pSrcTexture, 
        CONST RECT* pSrcRect, CONST D3DXVECTOR2* pScaling, 
        CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation, 
        CONST D3DXVECTOR2* pTranslation, D3DCOLOR Color) PURE;

    STDMETHOD(DrawTransform)(THIS_ LPDIRECT3DTEXTURE8 pSrcTexture, 
        CONST RECT* pSrcRect, CONST D3DXMATRIX* pTransform, 
        D3DCOLOR Color) PURE;

    STDMETHOD(End)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


HRESULT WINAPI
    D3DXCreateSprite(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXSPRITE*       ppSprite);

#ifdef __cplusplus
}
#endif //__cplusplus





///////////////////////////////////////////////////////////////////////////
// ID3DXRenderToSurface:
// ---------------------
// This object abstracts rendering to surfaces.  These surfaces do not 
// necessarily need to be render targets.  If they are not, a compatible
// render target is used, and the result copied into surface at end scene.
///////////////////////////////////////////////////////////////////////////

typedef struct _D3DXRTS_DESC
{
    UINT                Width;
    UINT                Height;
    D3DFORMAT           Format;
    BOOL                DepthStencil;
    D3DFORMAT           DepthStencilFormat;

} D3DXRTS_DESC;


typedef interface ID3DXRenderToSurface ID3DXRenderToSurface;
typedef interface ID3DXRenderToSurface *LPD3DXRENDERTOSURFACE;


// {69CC587C-E40C-458d-B5D3-B029E18EB60A}
DEFINE_GUID( IID_ID3DXRenderToSurface, 
0x69cc587c, 0xe40c, 0x458d, 0xb5, 0xd3, 0xb0, 0x29, 0xe1, 0x8e, 0xb6, 0xa);


DECLARE_INTERFACE_(ID3DXRenderToSurface, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXRenderToSurface
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXRTS_DESC* pDesc) PURE;

    STDMETHOD(BeginScene)(THIS_ LPDIRECT3DSURFACE8 pSurface, CONST D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateRenderToSurface(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Width,
        UINT                    Height,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRENDERTOSURFACE*  ppRenderToSurface);

#ifdef __cplusplus
}
#endif //__cplusplus



///////////////////////////////////////////////////////////////////////////
// ID3DXRenderToEnvMap:
// --------------------
///////////////////////////////////////////////////////////////////////////

typedef struct _D3DXRTE_DESC
{
    UINT        Size;
    D3DFORMAT   Format;
    BOOL        DepthStencil;
    D3DFORMAT   DepthStencilFormat;
} D3DXRTE_DESC;


typedef interface ID3DXRenderToEnvMap ID3DXRenderToEnvMap;
typedef interface ID3DXRenderToEnvMap *LPD3DXRenderToEnvMap;

// {9F6779E5-60A9-4d8b-AEE4-32770F405DBA}
DEFINE_GUID( IID_ID3DXRenderToEnvMap, 
0x9f6779e5, 0x60a9, 0x4d8b, 0xae, 0xe4, 0x32, 0x77, 0xf, 0x40, 0x5d, 0xba);


DECLARE_INTERFACE_(ID3DXRenderToEnvMap, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXRenderToEnvMap
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXRTE_DESC* pDesc) PURE;

    STDMETHOD(BeginCube)(THIS_ 
        LPDIRECT3DCUBETEXTURE8 pCubeTex) PURE;

    STDMETHOD(BeginSphere)(THIS_
        LPDIRECT3DTEXTURE8 pTex) PURE;

    STDMETHOD(BeginHemisphere)(THIS_ 
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg) PURE;

    STDMETHOD(BeginParabolic)(THIS_ 
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg) PURE;

    STDMETHOD(Face)(THIS_ D3DCUBEMAP_FACES Face) PURE;
    STDMETHOD(End)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateRenderToEnvMap(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Size,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRenderToEnvMap*   ppRenderToEnvMap);

#ifdef __cplusplus
}
#endif //__cplusplus



///////////////////////////////////////////////////////////////////////////
// Shader assemblers:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// D3DXASM flags:
// --------------
//
// D3DXASM_DEBUG
//   Generate debug info.
//
// D3DXASM_SKIPVALIDATION
//   Do not validate the generated code against known capabilities and
//   constraints.  This option is only recommended when assembling shaders
//   you KNOW will work.  (ie. have assembled before without this option.)
//-------------------------------------------------------------------------

#define D3DXASM_DEBUG           (1 << 0)
#define D3DXASM_SKIPVALIDATION  (1 << 1)


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

//-------------------------------------------------------------------------
// D3DXAssembleShader:
// ------------------------
// Assembles an ascii description of a vertex or pixel shader into 
// binary form.
//
// Parameters:
//  pSrcFile
//      Source file name
//  pSrcData
//      Pointer to source code
//  SrcDataLen
//      Size of source code, in bytes
//  Flags
//      D3DXASM_xxx flags
//  ppConstants
//      Returns an ID3DXBuffer object containing constant declarations.
//  ppCompiledShader
//      Returns an ID3DXBuffer object containing the object code.
//  ppCompilationErrors
//      Returns an ID3DXBuffer object containing ascii error messages
//-------------------------------------------------------------------------

HRESULT WINAPI
    D3DXAssembleShaderFromFileA(
        LPCSTR                pSrcFile,
        DWORD                 Flags,
        LPD3DXBUFFER*         ppConstants,
        LPD3DXBUFFER*         ppCompiledShader,
        LPD3DXBUFFER*         ppCompilationErrors);

HRESULT WINAPI
    D3DXAssembleShaderFromFileW(
        LPCWSTR               pSrcFile,
        DWORD                 Flags,
        LPD3DXBUFFER*         ppConstants,
        LPD3DXBUFFER*         ppCompiledShader,
        LPD3DXBUFFER*         ppCompilationErrors);

#ifdef UNICODE
#define D3DXAssembleShaderFromFile D3DXAssembleShaderFromFileW
#else
#define D3DXAssembleShaderFromFile D3DXAssembleShaderFromFileA
#endif

HRESULT WINAPI
    D3DXAssembleShader(
        LPCVOID               pSrcData,
        UINT                  SrcDataLen,
        DWORD                 Flags,
        LPD3DXBUFFER*         ppConstants,
        LPD3DXBUFFER*         ppCompiledShader,
        LPD3DXBUFFER*         ppCompilationErrors);


#ifdef __cplusplus
}
#endif //__cplusplus


///////////////////////////////////////////////////////////////////////////
// Misc APIs:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXGetFVFVertexSize:
// ---------------------
// Returns the size (in bytes) of a vertex for a given FVF.
//-------------------------------------------------------------------------

UINT WINAPI
    D3DXGetFVFVertexSize(DWORD FVF);
        

//-------------------------------------------------------------------------
// D3DXGetErrorString:
// ------------------
// Returns the error string for given an hresult.  Interprets all D3DX and
// D3D hresults.
//
// Parameters:
//  hr
//      The error code to be deciphered.
//  pBuffer
//      Pointer to the buffer to be filled in.
//  BufferLen
//      Count of characters in buffer.  Any error message longer than this
//      length will be truncated to fit.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXGetErrorStringA(
        HRESULT             hr,
        LPSTR               pBuffer,
        UINT                BufferLen);

HRESULT WINAPI
    D3DXGetErrorStringW(
        HRESULT             hr,
        LPWSTR              pBuffer,
        UINT                BufferLen);

#ifdef UNICODE
#define D3DXGetErrorString D3DXGetErrorStringW
#else
#define D3DXGetErrorString D3DXGetErrorStringA
#endif



#ifdef __cplusplus
}
#endif //__cplusplus


#endif //__D3DX8CORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx8.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8_H__
#define __D3DX8_H__

#include <d3d8.h>
#include <limits.h>

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#define D3DX_DEFAULT ULONG_MAX
#define D3DX_DEFAULT_FLOAT FLT_MAX

#include "d3dx8math.h"
#include "d3dx8core.h"
#include "d3dx8tex.h"
#include "d3dx8mesh.h"
#include "d3dx8shape.h"
#include "d3dx8effect.h"


#endif //__D3DX8_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx8effect.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8effect.h
//  Content:    D3DX effect types and functions
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8EFFECT_H__
#define __D3DX8EFFECT_H__


typedef enum _D3DXPARAMETERTYPE
{
    D3DXPT_DWORD        = 0,
    D3DXPT_FLOAT        = 1,
    D3DXPT_VECTOR       = 2,
    D3DXPT_MATRIX       = 3,
    D3DXPT_TEXTURE      = 4,
    D3DXPT_VERTEXSHADER = 5,
    D3DXPT_PIXELSHADER  = 6,
    D3DXPT_CONSTANT     = 7,
    D3DXPT_FORCE_DWORD  = 0x7fffffff /* force 32-bit size enum */

} D3DXPARAMETERTYPE;


typedef struct _D3DXEFFECT_DESC
{
    UINT Parameters;
    UINT Techniques;
    DWORD Usage;

} D3DXEFFECT_DESC;


typedef struct _D3DXPARAMETER_DESC
{
    DWORD Name;
    D3DXPARAMETERTYPE Type;

} D3DXPARAMETER_DESC;


typedef struct _D3DXTECHNIQUE_DESC
{
    DWORD Name;
    UINT Passes;

} D3DXTECHNIQUE_DESC;


typedef struct _D3DXPASS_DESC
{
    DWORD Name;

} D3DXPASS_DESC;


typedef struct ID3DXEffect *LPD3DXEFFECT;
typedef struct ID3DXTechnique *LPD3DXTECHNIQUE;




//////////////////////////////////////////////////////////////////////////////
// ID3DXTechnique ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// {A00F378D-AF79-4917-907E-4D635EE63844}
DEFINE_GUID( IID_ID3DXTechnique, 
0xa00f378d, 0xaf79, 0x4917, 0x90, 0x7e, 0x4d, 0x63, 0x5e, 0xe6, 0x38, 0x44);


DECLARE_INTERFACE_(ID3DXTechnique, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXTechnique
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXTECHNIQUE_DESC* pDesc) PURE;
    STDMETHOD(GetPassDesc)(THIS_ UINT Index, D3DXPASS_DESC* pDesc) PURE;

    STDMETHOD_(BOOL, IsParameterUsed)(THIS_ DWORD dwName) PURE;

    STDMETHOD(Validate)(THIS) PURE;
    STDMETHOD(Begin)(THIS_ UINT *pPasses) PURE;
    STDMETHOD(Pass)(THIS_ UINT Index) PURE;
    STDMETHOD(End)(THIS) PURE;
};
 

//////////////////////////////////////////////////////////////////////////////
// ID3DXEffect ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


// {281BBDD4-AEDF-4907-8650-E79CDFD45165}
DEFINE_GUID( IID_ID3DXEffect, 
0x281bbdd4, 0xaedf, 0x4907, 0x86, 0x50, 0xe7, 0x9c, 0xdf, 0xd4, 0x51, 0x65);


DECLARE_INTERFACE_(ID3DXEffect, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXEffect
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXEFFECT_DESC* pDesc) PURE;

    STDMETHOD(GetParameterDesc)(THIS_ UINT Index, D3DXPARAMETER_DESC* pDesc) PURE;
    STDMETHOD(GetTechniqueDesc)(THIS_ UINT Index, D3DXTECHNIQUE_DESC* pDesc) PURE;

    STDMETHOD(SetDword)(THIS_ DWORD Name, DWORD dw) PURE;
    STDMETHOD(GetDword)(THIS_ DWORD Name, DWORD* pdw) PURE; 
    STDMETHOD(SetFloat)(THIS_ DWORD Name, FLOAT f) PURE;
    STDMETHOD(GetFloat)(THIS_ DWORD Name, FLOAT* pf) PURE;
    STDMETHOD(SetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector) PURE;
    STDMETHOD(GetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector) PURE;
    STDMETHOD(SetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix) PURE;
    STDMETHOD(GetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 pTexture) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 *ppTexture) PURE;
    STDMETHOD(SetVertexShader)(THIS_ DWORD Name, DWORD Handle) PURE;
    STDMETHOD(GetVertexShader)(THIS_ DWORD Name, DWORD* pHandle) PURE;
    STDMETHOD(SetPixelShader)(THIS_ DWORD Name, DWORD Handle) PURE;
    STDMETHOD(GetPixelShader)(THIS_ DWORD Name, DWORD* pHandle) PURE;

    STDMETHOD(GetTechnique)(THIS_ UINT Index, LPD3DXTECHNIQUE* ppTechnique) PURE;
    STDMETHOD(CloneEffect)(THIS_ LPDIRECT3DDEVICE8 pDevice, DWORD Usage, LPD3DXEFFECT* ppEffect) PURE;
};



//////////////////////////////////////////////////////////////////////////////
// APIs //////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//----------------------------------------------------------------------------
// D3DXCompileEffect:
// ------------------
// Compiles an ascii effect description into a binary form usable by
// D3DXCreateEffect.
//
// Parameters:
//  pSrcFile
//      Name of the file containing the ascii effect description
//  pSrcData
//      Pointer to ascii effect description
//  SrcDataSize
//      Size of the effect description in bytes
//  ppCompiledEffect
//      Returns a buffer containing compiled effect.
//  ppCompilationErrors
//      Returns a buffer containing any error messages which occurred during
//      compile.  Or NULL if you do not care about the error messages.
//
//----------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCompileEffectFromFileA(
        LPCSTR            pSrcFile,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);

HRESULT WINAPI
    D3DXCompileEffectFromFileW(
        LPCWSTR           pSrcFile,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);

#ifdef UNICODE
#define D3DXCompileEffectFromFile D3DXCompileEffectFromFileW
#else
#define D3DXCompileEffectFromFile D3DXCompileEffectFromFileA
#endif


HRESULT WINAPI
    D3DXCompileEffect(
        LPCVOID           pSrcData,
        UINT              SrcDataSize,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);



//----------------------------------------------------------------------------
// D3DXCreateEffect:
// -----------------
// Creates an effect object, given compiled binary effect data
//
// Parameters:
//  pDevice
//      Pointer to the device to be used.
//  pCompiledEffect
//      Pointer to compiled effect data
//  CompiledEffectSize
//      Size of compiled effect data in bytes
//  Usage
//      Allows the specification of D3DUSAGE_SOFTWAREPROCESSING 
//  ppEffect
//      Returns the created effect object
//----------------------------------------------------------------------------


HRESULT WINAPI
    D3DXCreateEffect(
        LPDIRECT3DDEVICE8 pDevice,
        LPCVOID           pCompiledEffect,
        UINT              CompiledEffectSize,
        DWORD             Usage,
        LPD3DXEFFECT*     ppEffect);



#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX_H__
#define __D3DX_H__

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#include "d3dxcore.h"
#include "d3dxmath.h"
#include "d3dxshapes.h"
#include "d3dxsprite.h"

#endif //__D3DX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dtypes.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dtypes.h
 *  Content:    Direct3D types include file
 *
 ***************************************************************************/

#ifndef _D3DTYPES_H_
#define _D3DTYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0700
#endif

#if (DIRECT3D_VERSION >= 0x0800)
#pragma message("should not include d3dtypes.h when compiling for DX8 or newer interfaces")
#endif

#include <windows.h>

#include <float.h>
#include "ddraw.h"

#pragma warning(disable:4201) // anonymous unions warning
#pragma pack(4)


/* D3DVALUE is the fundamental Direct3D fractional data type */

#define D3DVALP(val, prec) ((float)(val))
#define D3DVAL(val) ((float)(val))

#ifndef DX_SHARED_DEFINES

/*
 * This definition is shared with other DirectX components whose header files
 * might already have defined it. Therefore, we don't define this type if
 * someone else already has (as indicated by the definition of
 * DX_SHARED_DEFINES). We don't set DX_SHARED_DEFINES here as there are
 * other types in this header that are also shared. The last of these
 * shared defines in this file will set DX_SHARED_DEFINES.
 */
typedef float D3DVALUE, *LPD3DVALUE;

#endif /* DX_SHARED_DEFINES */

#define D3DDivide(a, b)    (float)((double) (a) / (double) (b))
#define D3DMultiply(a, b)    ((a) * (b))

typedef LONG D3DFIXED;

#ifndef RGB_MAKE
/*
 * Format of CI colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |         color index           |   fraction    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define CI_GETALPHA(ci)    ((ci) >> 24)
#define CI_GETINDEX(ci)    (((ci) >> 8) & 0xffff)
#define CI_GETFRACTION(ci) ((ci) & 0xff)
#define CI_ROUNDINDEX(ci)  CI_GETINDEX((ci) + 0x80)
#define CI_MASKALPHA(ci)   ((ci) & 0xffffff)
#define CI_MAKE(a, i, f)    (((a) << 24) | ((i) << 8) | (f))

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGBA_GETALPHA(rgb)      ((rgb) >> 24)
#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

/* D3DRGB and D3DRGBA may be used as initialisers for D3DCOLORs
 * The float values must be in the range 0..1
 */
#define D3DRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
#define D3DRGBA(r, g, b, a) \
    (   (((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
    |   (((long)((g) * 255)) << 8) | (long)((b) * 255) \
    )

/*
 * Format of RGB colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    ignored    |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGB_GETRED(rgb)         (((rgb) >> 16) & 0xff)
#define RGB_GETGREEN(rgb)       (((rgb) >> 8) & 0xff)
#define RGB_GETBLUE(rgb)        ((rgb) & 0xff)
#define RGBA_SETALPHA(rgba, x) (((x) << 24) | ((rgba) & 0x00ffffff))
#define RGB_MAKE(r, g, b)       ((D3DCOLOR) (((r) << 16) | ((g) << 8) | (b)))
#define RGBA_TORGB(rgba)       ((D3DCOLOR) ((rgba) & 0xffffff))
#define RGB_TORGBA(rgb)        ((D3DCOLOR) ((rgb) | 0xff000000))

#endif

/*
 * Flags for Enumerate functions
 */

/*
 * Stop the enumeration
 */
#define D3DENUMRET_CANCEL                        DDENUMRET_CANCEL

/*
 * Continue the enumeration
 */
#define D3DENUMRET_OK                            DDENUMRET_OK

typedef HRESULT (CALLBACK* LPD3DVALIDATECALLBACK)(LPVOID lpUserArg, DWORD dwOffset);
typedef HRESULT (CALLBACK* LPD3DENUMTEXTUREFORMATSCALLBACK)(LPDDSURFACEDESC lpDdsd, LPVOID lpContext);
typedef HRESULT (CALLBACK* LPD3DENUMPIXELFORMATSCALLBACK)(LPDDPIXELFORMAT lpDDPixFmt, LPVOID lpContext);

#ifndef DX_SHARED_DEFINES

/*
 * This definition is shared with other DirectX components whose header files
 * might already have defined it. Therefore, we don't define this type if
 * someone else already has (as indicated by the definition of
 * DX_SHARED_DEFINES). We don't set DX_SHARED_DEFINES here as there are
 * other types in this header that are also shared. The last of these
 * shared defines in this file will set DX_SHARED_DEFINES.
 */
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif
typedef DWORD *LPD3DCOLOR;

#endif /* DX_SHARED_DEFINES */

typedef DWORD D3DMATERIALHANDLE, *LPD3DMATERIALHANDLE;
typedef DWORD D3DTEXTUREHANDLE, *LPD3DTEXTUREHANDLE;
typedef DWORD D3DMATRIXHANDLE, *LPD3DMATRIXHANDLE;

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    union {
    D3DVALUE r;
    D3DVALUE dvR;
    };
    union {
    D3DVALUE g;
    D3DVALUE dvG;
    };
    union {
    D3DVALUE b;
    D3DVALUE dvB;
    };
    union {
    D3DVALUE a;
    D3DVALUE dvA;
    };
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif
typedef struct _D3DCOLORVALUE *LPD3DCOLORVALUE;

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    union {
    LONG x1;
    LONG lX1;
    };
    union {
    LONG y1;
    LONG lY1;
    };
    union {
    LONG x2;
    LONG lX2;
    };
    union {
    LONG y2;
    LONG lY2;
    };
} D3DRECT;
#define D3DRECT_DEFINED
#endif
typedef struct _D3DRECT *LPD3DRECT;

#ifndef DX_SHARED_DEFINES

/*
 * This definition is shared with other DirectX components whose header files
 * might already have defined it. Therefore, we don't define this type if
 * someone else already has (as indicated by the definition of
 * DX_SHARED_DEFINES).
 */

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    union {
    D3DVALUE x;
    D3DVALUE dvX;
    };
    union {
    D3DVALUE y;
    D3DVALUE dvY;
    };
    union {
    D3DVALUE z;
    D3DVALUE dvZ;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)

public:

    // =====================================
    // Constructors
    // =====================================

    _D3DVECTOR() { }
    _D3DVECTOR(D3DVALUE f);
    _D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z);
    _D3DVECTOR(const D3DVALUE f[3]);

    // =====================================
    // Access grants
    // =====================================

    const D3DVALUE&operator[](int i) const;
    D3DVALUE&operator[](int i);

    // =====================================
    // Assignment operators
    // =====================================

    _D3DVECTOR& operator += (const _D3DVECTOR& v);
    _D3DVECTOR& operator -= (const _D3DVECTOR& v);
    _D3DVECTOR& operator *= (const _D3DVECTOR& v);
    _D3DVECTOR& operator /= (const _D3DVECTOR& v);
    _D3DVECTOR& operator *= (D3DVALUE s);
    _D3DVECTOR& operator /= (D3DVALUE s);

    // =====================================
    // Unary operators
    // =====================================

    friend _D3DVECTOR operator + (const _D3DVECTOR& v);
    friend _D3DVECTOR operator - (const _D3DVECTOR& v);


    // =====================================
    // Binary operators
    // =====================================

    // Addition and subtraction
        friend _D3DVECTOR operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
    // Scalar multiplication and division
        friend _D3DVECTOR operator * (const _D3DVECTOR& v, D3DVALUE s);
        friend _D3DVECTOR operator * (D3DVALUE s, const _D3DVECTOR& v);
        friend _D3DVECTOR operator / (const _D3DVECTOR& v, D3DVALUE s);
    // Memberwise multiplication and division
        friend _D3DVECTOR operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Vector dominance
        friend int operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend int operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Bitwise equality
        friend int operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Length-related functions
        friend D3DVALUE SquareMagnitude (const _D3DVECTOR& v);
        friend D3DVALUE Magnitude (const _D3DVECTOR& v);

    // Returns vector with same direction and unit length
        friend _D3DVECTOR Normalize (const _D3DVECTOR& v);

    // Return min/max component of the input vector
        friend D3DVALUE Min (const _D3DVECTOR& v);
        friend D3DVALUE Max (const _D3DVECTOR& v);

    // Return memberwise min/max of input vectors
        friend _D3DVECTOR Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Dot and cross product
        friend D3DVALUE DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif
typedef struct _D3DVECTOR *LPD3DVECTOR;

/*
 * As this is the last of the shared defines to be defined we now set
 * D3D_SHARED_DEFINES to flag that fact that this header has defined these
 * types.
 */
#define DX_SHARED_DEFINES

#endif /* DX_SHARED_DEFINES */

/*
 * Vertex data types supported in an ExecuteBuffer.
 */

/*
 * Homogeneous vertices
 */

typedef struct _D3DHVERTEX {
    DWORD           dwFlags;        /* Homogeneous clipping flags */
    union {
    D3DVALUE    hx;
    D3DVALUE    dvHX;
    };
    union {
    D3DVALUE    hy;
    D3DVALUE    dvHY;
    };
    union {
    D3DVALUE    hz;
    D3DVALUE    dvHZ;
    };
} D3DHVERTEX, *LPD3DHVERTEX;

/*
 * Transformed/lit vertices
 */
typedef struct _D3DTLVERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;        /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    union {
    D3DVALUE    tu;             /* Texture coordinates */
    D3DVALUE    dvTU;
    };
    union {
    D3DVALUE    tv;
    D3DVALUE    dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DTLVERTEX() { }
    _D3DTLVERTEX(const D3DVECTOR& v, float _rhw,
                 D3DCOLOR _color, D3DCOLOR _specular,
                 float _tu, float _tv)
        { sx = v.x; sy = v.y; sz = v.z; rhw = _rhw;
          color = _color; specular = _specular;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTLVERTEX, *LPD3DTLVERTEX;

/*
 * Untransformed/lit vertices
 */
typedef struct _D3DLVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    DWORD            dwReserved;
    union {
    D3DCOLOR     color;         /* Vertex color */
    D3DCOLOR     dcColor;
    };
    union {
    D3DCOLOR     specular;      /* Specular component of vertex */
    D3DCOLOR     dcSpecular;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DLVERTEX() { }
    _D3DLVERTEX(const D3DVECTOR& v,
                D3DCOLOR _color, D3DCOLOR _specular,
                float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z; dwReserved = 0;
          color = _color; specular = _specular;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DLVERTEX, *LPD3DLVERTEX;

/*
 * Untransformed/unlit vertices
 */

typedef struct _D3DVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    union {
    D3DVALUE     nx;            /* Normal */
    D3DVALUE     dvNX;
    };
    union {
    D3DVALUE     ny;
    D3DVALUE     dvNY;
    };
    union {
    D3DVALUE     nz;
    D3DVALUE     dvNZ;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DVERTEX() { }
    _D3DVERTEX(const D3DVECTOR& v, const D3DVECTOR& n, float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z;
          nx = n.x; ny = n.y; nz = n.z;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DVERTEX, *LPD3DVERTEX;


/*
 * Matrix, viewport, and tranformation structures and definitions.
 */

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    union {
        struct {
#endif

#endif /* DIRECT3D_VERSION >= 0x0500 */
            D3DVALUE        _11, _12, _13, _14;
            D3DVALUE        _21, _22, _23, _24;
            D3DVALUE        _31, _32, _33, _34;
            D3DVALUE        _41, _42, _43, _44;

#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
        };
        D3DVALUE m[4][4];
    };
    _D3DMATRIX() { }
    _D3DMATRIX( D3DVALUE _m00, D3DVALUE _m01, D3DVALUE _m02, D3DVALUE _m03,
                D3DVALUE _m10, D3DVALUE _m11, D3DVALUE _m12, D3DVALUE _m13,
                D3DVALUE _m20, D3DVALUE _m21, D3DVALUE _m22, D3DVALUE _m23,
                D3DVALUE _m30, D3DVALUE _m31, D3DVALUE _m32, D3DVALUE _m33
        )
        {
                m[0][0] = _m00; m[0][1] = _m01; m[0][2] = _m02; m[0][3] = _m03;
                m[1][0] = _m10; m[1][1] = _m11; m[1][2] = _m12; m[1][3] = _m13;
                m[2][0] = _m20; m[2][1] = _m21; m[2][2] = _m22; m[2][3] = _m23;
                m[3][0] = _m30; m[3][1] = _m31; m[3][2] = _m32; m[3][3] = _m33;
        }

    D3DVALUE& operator()(int iRow, int iColumn) { return m[iRow][iColumn]; }
    const D3DVALUE& operator()(int iRow, int iColumn) const { return m[iRow][iColumn]; }
#if(DIRECT3D_VERSION >= 0x0600)
    friend _D3DMATRIX operator* (const _D3DMATRIX&, const _D3DMATRIX&);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif
typedef struct _D3DMATRIX *LPD3DMATRIX;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
#include "d3dvec.inl"
#endif

typedef struct _D3DVIEWPORT {
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;        /* Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;   /* Dimensions */
    D3DVALUE    dvScaleX;   /* Scale homogeneous to screen */
    D3DVALUE    dvScaleY;   /* Scale homogeneous to screen */
    D3DVALUE    dvMaxX;     /* Min/max homogeneous x coord */
    D3DVALUE    dvMaxY;     /* Min/max homogeneous y coord */
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;     /* Min/max homogeneous z coord */
} D3DVIEWPORT, *LPD3DVIEWPORT;

#if(DIRECT3D_VERSION >= 0x0500)
typedef struct _D3DVIEWPORT2 {
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;        /* Viewport Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;   /* Viewport Dimensions */
    D3DVALUE    dvClipX;        /* Top left of clip volume */
    D3DVALUE    dvClipY;
    D3DVALUE    dvClipWidth;    /* Clip Volume Dimensions */
    D3DVALUE    dvClipHeight;
    D3DVALUE    dvMinZ;         /* Min/max of clip Volume */
    D3DVALUE    dvMaxZ;
} D3DVIEWPORT2, *LPD3DVIEWPORT2;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DVIEWPORT7 {
    DWORD       dwX;
    DWORD       dwY;            /* Viewport Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;       /* Viewport Dimensions */
    D3DVALUE    dvMinZ;         /* Min/max of clip Volume */
    D3DVALUE    dvMaxZ;
} D3DVIEWPORT7, *LPD3DVIEWPORT7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Values for clip fields.
 */

#if(DIRECT3D_VERSION >= 0x0700)

// Max number of user clipping planes, supported in D3D.
#define D3DMAXUSERCLIPPLANES 32

// These bits could be ORed together to use with D3DRENDERSTATE_CLIPPLANEENABLE
//
#define D3DCLIPPLANE0 (1 << 0)
#define D3DCLIPPLANE1 (1 << 1)
#define D3DCLIPPLANE2 (1 << 2)
#define D3DCLIPPLANE3 (1 << 3)
#define D3DCLIPPLANE4 (1 << 4)
#define D3DCLIPPLANE5 (1 << 5)

#endif /* DIRECT3D_VERSION >= 0x0700 */

#define D3DCLIP_LEFT                0x00000001L
#define D3DCLIP_RIGHT               0x00000002L
#define D3DCLIP_TOP             0x00000004L
#define D3DCLIP_BOTTOM              0x00000008L
#define D3DCLIP_FRONT               0x00000010L
#define D3DCLIP_BACK                0x00000020L
#define D3DCLIP_GEN0                0x00000040L
#define D3DCLIP_GEN1                0x00000080L
#define D3DCLIP_GEN2                0x00000100L
#define D3DCLIP_GEN3                0x00000200L
#define D3DCLIP_GEN4                0x00000400L
#define D3DCLIP_GEN5                0x00000800L

/*
 * Values for d3d status.
 */
#define D3DSTATUS_CLIPUNIONLEFT         D3DCLIP_LEFT
#define D3DSTATUS_CLIPUNIONRIGHT        D3DCLIP_RIGHT
#define D3DSTATUS_CLIPUNIONTOP          D3DCLIP_TOP
#define D3DSTATUS_CLIPUNIONBOTTOM       D3DCLIP_BOTTOM
#define D3DSTATUS_CLIPUNIONFRONT        D3DCLIP_FRONT
#define D3DSTATUS_CLIPUNIONBACK         D3DCLIP_BACK
#define D3DSTATUS_CLIPUNIONGEN0         D3DCLIP_GEN0
#define D3DSTATUS_CLIPUNIONGEN1         D3DCLIP_GEN1
#define D3DSTATUS_CLIPUNIONGEN2         D3DCLIP_GEN2
#define D3DSTATUS_CLIPUNIONGEN3         D3DCLIP_GEN3
#define D3DSTATUS_CLIPUNIONGEN4         D3DCLIP_GEN4
#define D3DSTATUS_CLIPUNIONGEN5         D3DCLIP_GEN5

#define D3DSTATUS_CLIPINTERSECTIONLEFT      0x00001000L
#define D3DSTATUS_CLIPINTERSECTIONRIGHT     0x00002000L
#define D3DSTATUS_CLIPINTERSECTIONTOP       0x00004000L
#define D3DSTATUS_CLIPINTERSECTIONBOTTOM    0x00008000L
#define D3DSTATUS_CLIPINTERSECTIONFRONT     0x00010000L
#define D3DSTATUS_CLIPINTERSECTIONBACK      0x00020000L
#define D3DSTATUS_CLIPINTERSECTIONGEN0      0x00040000L
#define D3DSTATUS_CLIPINTERSECTIONGEN1      0x00080000L
#define D3DSTATUS_CLIPINTERSECTIONGEN2      0x00100000L
#define D3DSTATUS_CLIPINTERSECTIONGEN3      0x00200000L
#define D3DSTATUS_CLIPINTERSECTIONGEN4      0x00400000L
#define D3DSTATUS_CLIPINTERSECTIONGEN5      0x00800000L
#define D3DSTATUS_ZNOTVISIBLE               0x01000000L
/* Do not use 0x80000000 for any status flags in future as it is reserved */

#define D3DSTATUS_CLIPUNIONALL  (       \
        D3DSTATUS_CLIPUNIONLEFT |   \
        D3DSTATUS_CLIPUNIONRIGHT    |   \
        D3DSTATUS_CLIPUNIONTOP  |   \
        D3DSTATUS_CLIPUNIONBOTTOM   |   \
        D3DSTATUS_CLIPUNIONFRONT    |   \
        D3DSTATUS_CLIPUNIONBACK |   \
        D3DSTATUS_CLIPUNIONGEN0 |   \
        D3DSTATUS_CLIPUNIONGEN1 |   \
        D3DSTATUS_CLIPUNIONGEN2 |   \
        D3DSTATUS_CLIPUNIONGEN3 |   \
        D3DSTATUS_CLIPUNIONGEN4 |   \
        D3DSTATUS_CLIPUNIONGEN5     \
        )

#define D3DSTATUS_CLIPINTERSECTIONALL   (       \
        D3DSTATUS_CLIPINTERSECTIONLEFT  |   \
        D3DSTATUS_CLIPINTERSECTIONRIGHT |   \
        D3DSTATUS_CLIPINTERSECTIONTOP   |   \
        D3DSTATUS_CLIPINTERSECTIONBOTTOM    |   \
        D3DSTATUS_CLIPINTERSECTIONFRONT |   \
        D3DSTATUS_CLIPINTERSECTIONBACK  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN0  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN1  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN2  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN3  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN4  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN5      \
        )

#define D3DSTATUS_DEFAULT   (           \
        D3DSTATUS_CLIPINTERSECTIONALL   |   \
        D3DSTATUS_ZNOTVISIBLE)


/*
 * Options for direct transform calls
 */
#define D3DTRANSFORM_CLIPPED       0x00000001l
#define D3DTRANSFORM_UNCLIPPED     0x00000002l

typedef struct _D3DTRANSFORMDATA {
    DWORD           dwSize;
    LPVOID      lpIn;           /* Input vertices */
    DWORD           dwInSize;       /* Stride of input vertices */
    LPVOID      lpOut;          /* Output vertices */
    DWORD           dwOutSize;      /* Stride of output vertices */
    LPD3DHVERTEX    lpHOut;         /* Output homogeneous vertices */
    DWORD           dwClip;         /* Clipping hint */
    DWORD           dwClipIntersection;
    DWORD           dwClipUnion;    /* Union of all clip flags */
    D3DRECT         drExtent;       /* Extent of transformed vertices */
} D3DTRANSFORMDATA, *LPD3DTRANSFORMDATA;

/*
 * Structure defining position and direction properties for lighting.
 */
typedef struct _D3DLIGHTINGELEMENT {
    D3DVECTOR dvPosition;           /* Lightable point in model space */
    D3DVECTOR dvNormal;             /* Normalised unit vector */
} D3DLIGHTINGELEMENT, *LPD3DLIGHTINGELEMENT;

/*
 * Structure defining material properties for lighting.
 */
typedef struct _D3DMATERIAL {
    DWORD           dwSize;
    union {
    D3DCOLORVALUE   diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   dcvDiffuse;
    };
    union {
    D3DCOLORVALUE   ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   dcvAmbient;
    };
    union {
    D3DCOLORVALUE   specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   dcvSpecular;
    };
    union {
    D3DCOLORVALUE   emissive;       /* Emissive color RGB */
    D3DCOLORVALUE   dcvEmissive;
    };
    union {
    D3DVALUE        power;          /* Sharpness if specular highlight */
    D3DVALUE        dvPower;
    };
    D3DTEXTUREHANDLE    hTexture;       /* Handle to texture map */
    DWORD           dwRampSize;
} D3DMATERIAL, *LPD3DMATERIAL;

#if(DIRECT3D_VERSION >= 0x0700)

typedef struct _D3DMATERIAL7 {
    union {
    D3DCOLORVALUE   diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   dcvDiffuse;
    };
    union {
    D3DCOLORVALUE   ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   dcvAmbient;
    };
    union {
    D3DCOLORVALUE   specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   dcvSpecular;
    };
    union {
    D3DCOLORVALUE   emissive;       /* Emissive color RGB */
    D3DCOLORVALUE   dcvEmissive;
    };
    union {
    D3DVALUE        power;          /* Sharpness if specular highlight */
    D3DVALUE        dvPower;
    };
} D3DMATERIAL7, *LPD3DMATERIAL7;

#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
// Note: The following light type (D3DLIGHT_PARALLELPOINT)
// is no longer supported from D3D for DX7 onwards.
    D3DLIGHT_PARALLELPOINT  = 4,
#if(DIRECT3D_VERSION < 0x0500) // For backward compatible headers
    D3DLIGHT_GLSPOT         = 5,
#endif
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

#else
typedef enum _D3DLIGHTTYPE D3DLIGHTTYPE;
#define D3DLIGHT_PARALLELPOINT  (D3DLIGHTTYPE)4
#define D3DLIGHT_GLSPOT         (D3DLIGHTTYPE)5

#endif //(DIRECT3D_VERSION < 0x0800)

/*
 * Structure defining a light source and its properties.
 */
typedef struct _D3DLIGHT {
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;            /* Type of light source */
    D3DCOLORVALUE   dcvColor;           /* Color of light */
    D3DVECTOR       dvPosition;         /* Position in world space */
    D3DVECTOR       dvDirection;        /* Direction in world space */
    D3DVALUE        dvRange;            /* Cutoff range */
    D3DVALUE        dvFalloff;          /* Falloff */
    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
} D3DLIGHT, *LPD3DLIGHT;

#if(DIRECT3D_VERSION >= 0x0700)

typedef struct _D3DLIGHT7 {
    D3DLIGHTTYPE    dltType;            /* Type of light source */
    D3DCOLORVALUE   dcvDiffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   dcvSpecular;        /* Specular color of light */
    D3DCOLORVALUE   dcvAmbient;         /* Ambient color of light */
    D3DVECTOR       dvPosition;         /* Position in world space */
    D3DVECTOR       dvDirection;        /* Direction in world space */
    D3DVALUE        dvRange;            /* Cutoff range */
    D3DVALUE        dvFalloff;          /* Falloff */
    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
} D3DLIGHT7, *LPD3DLIGHT7;

#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0500)
/*
 * Structure defining a light source and its properties.
 */

/* flags bits */
#define D3DLIGHT_ACTIVE         0x00000001
#define D3DLIGHT_NO_SPECULAR    0x00000002
#define D3DLIGHT_ALL (D3DLIGHT_ACTIVE | D3DLIGHT_NO_SPECULAR)

/* maximum valid light range */
#define D3DLIGHT_RANGE_MAX      ((float)sqrt(FLT_MAX))

typedef struct _D3DLIGHT2 {
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;        /* Type of light source */
    D3DCOLORVALUE   dcvColor;       /* Color of light */
    D3DVECTOR       dvPosition;     /* Position in world space */
    D3DVECTOR       dvDirection;    /* Direction in world space */
    D3DVALUE        dvRange;        /* Cutoff range */
    D3DVALUE        dvFalloff;      /* Falloff */
    D3DVALUE        dvAttenuation0; /* Constant attenuation */
    D3DVALUE        dvAttenuation1; /* Linear attenuation */
    D3DVALUE        dvAttenuation2; /* Quadratic attenuation */
    D3DVALUE        dvTheta;        /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;          /* Outer angle of spotlight cone */
    DWORD           dwFlags;
} D3DLIGHT2, *LPD3DLIGHT2;

#endif /* DIRECT3D_VERSION >= 0x0500 */
typedef struct _D3DLIGHTDATA {
    DWORD                dwSize;
    LPD3DLIGHTINGELEMENT lpIn;      /* Input positions and normals */
    DWORD                dwInSize;  /* Stride of input elements */
    LPD3DTLVERTEX        lpOut;     /* Output colors */
    DWORD                dwOutSize; /* Stride of output colors */
} D3DLIGHTDATA, *LPD3DLIGHTDATA;

#if(DIRECT3D_VERSION >= 0x0500)
/*
 * Before DX5, these values were in an enum called
 * D3DCOLORMODEL. This was not correct, since they are
 * bit flags. A driver can surface either or both flags
 * in the dcmColorModel member of D3DDEVICEDESC.
 */
#define D3DCOLOR_MONO   1
#define D3DCOLOR_RGB    2

typedef DWORD D3DCOLORMODEL;
#endif /* DIRECT3D_VERSION >= 0x0500 */

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x00000001l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000002l  /* Clear target z buffer */
#if(DIRECT3D_VERSION >= 0x0600)
#define D3DCLEAR_STENCIL           0x00000004l  /* Clear stencil planes */
#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Execute buffers are allocated via Direct3D.  These buffers may then
 * be filled by the application with instructions to execute along with
 * vertex data.
 */

/*
 * Supported op codes for execute instructions.
 */
typedef enum _D3DOPCODE {
    D3DOP_POINT                 = 1,
    D3DOP_LINE                  = 2,
    D3DOP_TRIANGLE      = 3,
    D3DOP_MATRIXLOAD        = 4,
    D3DOP_MATRIXMULTIPLY    = 5,
    D3DOP_STATETRANSFORM        = 6,
    D3DOP_STATELIGHT        = 7,
    D3DOP_STATERENDER       = 8,
    D3DOP_PROCESSVERTICES       = 9,
    D3DOP_TEXTURELOAD       = 10,
    D3DOP_EXIT                  = 11,
    D3DOP_BRANCHFORWARD     = 12,
    D3DOP_SPAN          = 13,
    D3DOP_SETSTATUS     = 14,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DOP_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DOPCODE;

typedef struct _D3DINSTRUCTION {
    BYTE bOpcode;   /* Instruction opcode */
    BYTE bSize;     /* Size of each instruction data unit */
    WORD wCount;    /* Count of instruction data units to follow */
} D3DINSTRUCTION, *LPD3DINSTRUCTION;

/*
 * Structure for texture loads
 */
typedef struct _D3DTEXTURELOAD {
    D3DTEXTUREHANDLE hDestTexture;
    D3DTEXTUREHANDLE hSrcTexture;
} D3DTEXTURELOAD, *LPD3DTEXTURELOAD;

/*
 * Structure for picking
 */
typedef struct _D3DPICKRECORD {
    BYTE     bOpcode;
    BYTE     bPad;
    DWORD    dwOffset;
    D3DVALUE dvZ;
} D3DPICKRECORD, *LPD3DPICKRECORD;

/*
 * The following defines the rendering states which can be set in the
 * execute buffer.
 */

#if(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT              = 1,
    D3DSHADE_GOURAUD           = 2,
    D3DSHADE_PHONG             = 3,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DSHADE_FORCE_DWORD       = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DSHADEMODE;

typedef enum _D3DFILLMODE {
    D3DFILL_POINT          = 1,
    D3DFILL_WIREFRAME          = 2,
    D3DFILL_SOLID          = 3,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DFILL_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DFILLMODE;

typedef struct _D3DLINEPATTERN {
    WORD    wRepeatFactor;
    WORD    wLinePattern;
} D3DLINEPATTERN;

#endif //(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DTEXTUREFILTER {
    D3DFILTER_NEAREST          = 1,
    D3DFILTER_LINEAR           = 2,
    D3DFILTER_MIPNEAREST       = 3,
    D3DFILTER_MIPLINEAR        = 4,
    D3DFILTER_LINEARMIPNEAREST = 5,
    D3DFILTER_LINEARMIPLINEAR  = 6,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DFILTER_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTEXTUREFILTER;

#if(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DBLEND {
    D3DBLEND_ZERO              = 1,
    D3DBLEND_ONE               = 2,
    D3DBLEND_SRCCOLOR          = 3,
    D3DBLEND_INVSRCCOLOR       = 4,
    D3DBLEND_SRCALPHA          = 5,
    D3DBLEND_INVSRCALPHA       = 6,
    D3DBLEND_DESTALPHA         = 7,
    D3DBLEND_INVDESTALPHA      = 8,
    D3DBLEND_DESTCOLOR         = 9,
    D3DBLEND_INVDESTCOLOR      = 10,
    D3DBLEND_SRCALPHASAT       = 11,
    D3DBLEND_BOTHSRCALPHA      = 12,
    D3DBLEND_BOTHINVSRCALPHA   = 13,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DBLEND_FORCE_DWORD       = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DBLEND;

#endif //(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DTEXTUREBLEND {
    D3DTBLEND_DECAL            = 1,
    D3DTBLEND_MODULATE         = 2,
    D3DTBLEND_DECALALPHA       = 3,
    D3DTBLEND_MODULATEALPHA    = 4,
    D3DTBLEND_DECALMASK        = 5,
    D3DTBLEND_MODULATEMASK     = 6,
    D3DTBLEND_COPY             = 7,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DTBLEND_ADD              = 8,
    D3DTBLEND_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTEXTUREBLEND;

#if(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP           = 1,
    D3DTADDRESS_MIRROR         = 2,
    D3DTADDRESS_CLAMP          = 3,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DTADDRESS_BORDER         = 4,
    D3DTADDRESS_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTEXTUREADDRESS;

typedef enum _D3DCULL {
    D3DCULL_NONE               = 1,
    D3DCULL_CW                 = 2,
    D3DCULL_CCW                = 3,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DCULL_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DCULL;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER               = 1,
    D3DCMP_LESS                = 2,
    D3DCMP_EQUAL               = 3,
    D3DCMP_LESSEQUAL           = 4,
    D3DCMP_GREATER             = 5,
    D3DCMP_NOTEQUAL            = 6,
    D3DCMP_GREATEREQUAL        = 7,
    D3DCMP_ALWAYS              = 8,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DCMP_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DCMPFUNC;

#if(DIRECT3D_VERSION >= 0x0600)
typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 1,
    D3DSTENCILOP_ZERO           = 2,
    D3DSTENCILOP_REPLACE        = 3,
    D3DSTENCILOP_INCRSAT        = 4,
    D3DSTENCILOP_DECRSAT        = 5,
    D3DSTENCILOP_INVERT         = 6,
    D3DSTENCILOP_INCR           = 7,
    D3DSTENCILOP_DECR           = 8,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;
#endif /* DIRECT3D_VERSION >= 0x0600 */

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                = 0,
    D3DFOG_EXP                 = 1,
    D3DFOG_EXP2                = 2,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DFOG_LINEAR              = 3,
    D3DFOG_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DFOGMODE;

#if(DIRECT3D_VERSION >= 0x0600)
typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;
#endif /* DIRECT3D_VERSION >= 0x0600 */

#endif //(DIRECT3D_VERSION < 0x0800)

#if(DIRECT3D_VERSION >= 0x0500)
typedef enum _D3DANTIALIASMODE {
    D3DANTIALIAS_NONE          = 0,
    D3DANTIALIAS_SORTDEPENDENT = 1,
    D3DANTIALIAS_SORTINDEPENDENT = 2,
    D3DANTIALIAS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DANTIALIASMODE;

// Vertex types supported by Direct3D
typedef enum _D3DVERTEXTYPE {
    D3DVT_VERTEX        = 1,
    D3DVT_LVERTEX       = 2,
    D3DVT_TLVERTEX      = 3,
    D3DVT_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DVERTEXTYPE;

#if(DIRECT3D_VERSION < 0x0800)

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST     = 1,
    D3DPT_LINELIST      = 2,
    D3DPT_LINESTRIP     = 3,
    D3DPT_TRIANGLELIST  = 4,
    D3DPT_TRIANGLESTRIP = 5,
    D3DPT_TRIANGLEFAN   = 6,
    D3DPT_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

#endif //(DIRECT3D_VERSION < 0x0800)

#endif /* DIRECT3D_VERSION >= 0x0500 */
/*
 * Amount to add to a state to generate the override for that state.
 */
#define D3DSTATE_OVERRIDE_BIAS      256

/*
 * A state which sets the override flag for the specified state type.
 */
#define D3DSTATE_OVERRIDE(type) (D3DRENDERSTATETYPE)(((DWORD) (type) + D3DSTATE_OVERRIDE_BIAS))

#if(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTRANSFORMSTATE_WORLD         = 1,
    D3DTRANSFORMSTATE_VIEW          = 2,
    D3DTRANSFORMSTATE_PROJECTION    = 3,
#if(DIRECT3D_VERSION >= 0x0700)
    D3DTRANSFORMSTATE_WORLD1        = 4,  // 2nd matrix to blend
    D3DTRANSFORMSTATE_WORLD2        = 5,  // 3rd matrix to blend
    D3DTRANSFORMSTATE_WORLD3        = 6,  // 4th matrix to blend
    D3DTRANSFORMSTATE_TEXTURE0      = 16,
    D3DTRANSFORMSTATE_TEXTURE1      = 17,
    D3DTRANSFORMSTATE_TEXTURE2      = 18,
    D3DTRANSFORMSTATE_TEXTURE3      = 19,
    D3DTRANSFORMSTATE_TEXTURE4      = 20,
    D3DTRANSFORMSTATE_TEXTURE5      = 21,
    D3DTRANSFORMSTATE_TEXTURE6      = 22,
    D3DTRANSFORMSTATE_TEXTURE7      = 23,
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0500)
    D3DTRANSFORMSTATE_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTRANSFORMSTATETYPE;

#else

//
// legacy transform state names
//
typedef enum _D3DTRANSFORMSTATETYPE D3DTRANSFORMSTATETYPE;
#define D3DTRANSFORMSTATE_WORLD         (D3DTRANSFORMSTATETYPE)1
#define D3DTRANSFORMSTATE_VIEW          (D3DTRANSFORMSTATETYPE)2
#define D3DTRANSFORMSTATE_PROJECTION    (D3DTRANSFORMSTATETYPE)3
#define D3DTRANSFORMSTATE_WORLD1        (D3DTRANSFORMSTATETYPE)4
#define D3DTRANSFORMSTATE_WORLD2        (D3DTRANSFORMSTATETYPE)5
#define D3DTRANSFORMSTATE_WORLD3        (D3DTRANSFORMSTATETYPE)6
#define D3DTRANSFORMSTATE_TEXTURE0      (D3DTRANSFORMSTATETYPE)16
#define D3DTRANSFORMSTATE_TEXTURE1      (D3DTRANSFORMSTATETYPE)17
#define D3DTRANSFORMSTATE_TEXTURE2      (D3DTRANSFORMSTATETYPE)18
#define D3DTRANSFORMSTATE_TEXTURE3      (D3DTRANSFORMSTATETYPE)19
#define D3DTRANSFORMSTATE_TEXTURE4      (D3DTRANSFORMSTATETYPE)20
#define D3DTRANSFORMSTATE_TEXTURE5      (D3DTRANSFORMSTATETYPE)21
#define D3DTRANSFORMSTATE_TEXTURE6      (D3DTRANSFORMSTATETYPE)22
#define D3DTRANSFORMSTATE_TEXTURE7      (D3DTRANSFORMSTATETYPE)23

#endif //(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DLIGHTSTATETYPE {
    D3DLIGHTSTATE_MATERIAL          = 1,
    D3DLIGHTSTATE_AMBIENT           = 2,
    D3DLIGHTSTATE_COLORMODEL        = 3,
    D3DLIGHTSTATE_FOGMODE           = 4,
    D3DLIGHTSTATE_FOGSTART          = 5,
    D3DLIGHTSTATE_FOGEND            = 6,
    D3DLIGHTSTATE_FOGDENSITY        = 7,
#if(DIRECT3D_VERSION >= 0x0600)
    D3DLIGHTSTATE_COLORVERTEX       = 8,
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0500)
    D3DLIGHTSTATE_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DLIGHTSTATETYPE;

#if(DIRECT3D_VERSION < 0x0800)

typedef enum _D3DRENDERSTATETYPE {
    D3DRENDERSTATE_ANTIALIAS          = 2,    /* D3DANTIALIASMODE */
    D3DRENDERSTATE_TEXTUREPERSPECTIVE = 4,    /* TRUE for perspective correction */
    D3DRENDERSTATE_ZENABLE            = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
    D3DRENDERSTATE_FILLMODE           = 8,    /* D3DFILL_MODE        */
    D3DRENDERSTATE_SHADEMODE          = 9,    /* D3DSHADEMODE */
    D3DRENDERSTATE_LINEPATTERN        = 10,   /* D3DLINEPATTERN */
    D3DRENDERSTATE_ZWRITEENABLE       = 14,   /* TRUE to enable z writes */
    D3DRENDERSTATE_ALPHATESTENABLE    = 15,   /* TRUE to enable alpha tests */
    D3DRENDERSTATE_LASTPIXEL          = 16,   /* TRUE for last-pixel on lines */
    D3DRENDERSTATE_SRCBLEND           = 19,   /* D3DBLEND */
    D3DRENDERSTATE_DESTBLEND          = 20,   /* D3DBLEND */
    D3DRENDERSTATE_CULLMODE           = 22,   /* D3DCULL */
    D3DRENDERSTATE_ZFUNC              = 23,   /* D3DCMPFUNC */
    D3DRENDERSTATE_ALPHAREF           = 24,   /* D3DFIXED */
    D3DRENDERSTATE_ALPHAFUNC          = 25,   /* D3DCMPFUNC */
    D3DRENDERSTATE_DITHERENABLE       = 26,   /* TRUE to enable dithering */
#if(DIRECT3D_VERSION >= 0x0500)
    D3DRENDERSTATE_ALPHABLENDENABLE   = 27,   /* TRUE to enable alpha blending */
#endif /* DIRECT3D_VERSION >= 0x0500 */
    D3DRENDERSTATE_FOGENABLE          = 28,   /* TRUE to enable fog blending */
    D3DRENDERSTATE_SPECULARENABLE     = 29,   /* TRUE to enable specular */
    D3DRENDERSTATE_ZVISIBLE           = 30,   /* TRUE to enable z checking */
    D3DRENDERSTATE_STIPPLEDALPHA      = 33,   /* TRUE to enable stippled alpha (RGB device only) */
    D3DRENDERSTATE_FOGCOLOR           = 34,   /* D3DCOLOR */
    D3DRENDERSTATE_FOGTABLEMODE       = 35,   /* D3DFOGMODE */
#if(DIRECT3D_VERSION >= 0x0700)
    D3DRENDERSTATE_FOGSTART           = 36,   /* Fog start (for both vertex and pixel fog) */
    D3DRENDERSTATE_FOGEND             = 37,   /* Fog end      */
    D3DRENDERSTATE_FOGDENSITY         = 38,   /* Fog density  */
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0500)
    D3DRENDERSTATE_EDGEANTIALIAS      = 40,   /* TRUE to enable edge antialiasing */
    D3DRENDERSTATE_COLORKEYENABLE     = 41,   /* TRUE to enable source colorkeyed textures */
    D3DRENDERSTATE_ZBIAS              = 47,   /* LONG Z bias */
    D3DRENDERSTATE_RANGEFOGENABLE     = 48,   /* Enables range-based fog */
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
    D3DRENDERSTATE_STENCILENABLE      = 52,   /* BOOL enable/disable stenciling */
    D3DRENDERSTATE_STENCILFAIL        = 53,   /* D3DSTENCILOP to do if stencil test fails */
    D3DRENDERSTATE_STENCILZFAIL       = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    D3DRENDERSTATE_STENCILPASS        = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    D3DRENDERSTATE_STENCILFUNC        = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRENDERSTATE_STENCILREF         = 57,   /* Reference value used in stencil test */
    D3DRENDERSTATE_STENCILMASK        = 58,   /* Mask value used in stencil test */
    D3DRENDERSTATE_STENCILWRITEMASK   = 59,   /* Write mask applied to values written to stencil buffer */
    D3DRENDERSTATE_TEXTUREFACTOR      = 60,   /* D3DCOLOR used for multi-texture blend */
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0600)

    /*
     * 128 values [128, 255] are reserved for texture coordinate wrap flags.
     * These are constructed with the D3DWRAP_U and D3DWRAP_V macros. Using
     * a flags word preserves forward compatibility with texture coordinates
     * that are >2D.
     */
    D3DRENDERSTATE_WRAP0              = 128,  /* wrap for 1st texture coord. set */
    D3DRENDERSTATE_WRAP1              = 129,  /* wrap for 2nd texture coord. set */
    D3DRENDERSTATE_WRAP2              = 130,  /* wrap for 3rd texture coord. set */
    D3DRENDERSTATE_WRAP3              = 131,  /* wrap for 4th texture coord. set */
    D3DRENDERSTATE_WRAP4              = 132,  /* wrap for 5th texture coord. set */
    D3DRENDERSTATE_WRAP5              = 133,  /* wrap for 6th texture coord. set */
    D3DRENDERSTATE_WRAP6              = 134,  /* wrap for 7th texture coord. set */
    D3DRENDERSTATE_WRAP7              = 135,  /* wrap for 8th texture coord. set */
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
    D3DRENDERSTATE_CLIPPING            = 136,
    D3DRENDERSTATE_LIGHTING            = 137,
    D3DRENDERSTATE_EXTENTS             = 138,
    D3DRENDERSTATE_AMBIENT             = 139,
    D3DRENDERSTATE_FOGVERTEXMODE       = 140,
    D3DRENDERSTATE_COLORVERTEX         = 141,
    D3DRENDERSTATE_LOCALVIEWER         = 142,
    D3DRENDERSTATE_NORMALIZENORMALS    = 143,
    D3DRENDERSTATE_COLORKEYBLENDENABLE = 144,
    D3DRENDERSTATE_DIFFUSEMATERIALSOURCE    = 145,
    D3DRENDERSTATE_SPECULARMATERIALSOURCE   = 146,
    D3DRENDERSTATE_AMBIENTMATERIALSOURCE    = 147,
    D3DRENDERSTATE_EMISSIVEMATERIALSOURCE   = 148,
    D3DRENDERSTATE_VERTEXBLEND              = 151,
    D3DRENDERSTATE_CLIPPLANEENABLE          = 152,

#endif /* DIRECT3D_VERSION >= 0x0700 */

//
// retired renderstates - not supported for DX7 interfaces
//
    D3DRENDERSTATE_TEXTUREHANDLE      = 1,    /* Texture handle for legacy interfaces (Texture,Texture2) */
    D3DRENDERSTATE_TEXTUREADDRESS     = 3,    /* D3DTEXTUREADDRESS  */
    D3DRENDERSTATE_WRAPU              = 5,    /* TRUE for wrapping in u */
    D3DRENDERSTATE_WRAPV              = 6,    /* TRUE for wrapping in v */
    D3DRENDERSTATE_MONOENABLE         = 11,   /* TRUE to enable mono rasterization */
    D3DRENDERSTATE_ROP2               = 12,   /* ROP2 */
    D3DRENDERSTATE_PLANEMASK          = 13,   /* DWORD physical plane mask */
    D3DRENDERSTATE_TEXTUREMAG         = 17,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_TEXTUREMIN         = 18,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_TEXTUREMAPBLEND    = 21,   /* D3DTEXTUREBLEND */
    D3DRENDERSTATE_SUBPIXEL           = 31,   /* TRUE to enable subpixel correction */
    D3DRENDERSTATE_SUBPIXELX          = 32,   /* TRUE to enable correction in X only */
    D3DRENDERSTATE_STIPPLEENABLE      = 39,   /* TRUE to enable stippling */
#if(DIRECT3D_VERSION >= 0x0500)
    D3DRENDERSTATE_BORDERCOLOR        = 43,   /* Border color for texturing w/border */
    D3DRENDERSTATE_TEXTUREADDRESSU    = 44,   /* Texture addressing mode for U coordinate */
    D3DRENDERSTATE_TEXTUREADDRESSV    = 45,   /* Texture addressing mode for V coordinate */
    D3DRENDERSTATE_MIPMAPLODBIAS      = 46,   /* D3DVALUE Mipmap LOD bias */
    D3DRENDERSTATE_ANISOTROPY         = 49,   /* Max. anisotropy. 1 = no anisotropy */
#endif /* DIRECT3D_VERSION >= 0x0500 */
    D3DRENDERSTATE_FLUSHBATCH         = 50,   /* Explicit flush for DP batching (DX5 Only) */
#if(DIRECT3D_VERSION >= 0x0600)
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT=51, /* BOOL enable sort-independent transparency */
#endif /* DIRECT3D_VERSION >= 0x0600 */
    D3DRENDERSTATE_STIPPLEPATTERN00   = 64,   /* Stipple pattern 01...  */
    D3DRENDERSTATE_STIPPLEPATTERN01   = 65,
    D3DRENDERSTATE_STIPPLEPATTERN02   = 66,
    D3DRENDERSTATE_STIPPLEPATTERN03   = 67,
    D3DRENDERSTATE_STIPPLEPATTERN04   = 68,
    D3DRENDERSTATE_STIPPLEPATTERN05   = 69,
    D3DRENDERSTATE_STIPPLEPATTERN06   = 70,
    D3DRENDERSTATE_STIPPLEPATTERN07   = 71,
    D3DRENDERSTATE_STIPPLEPATTERN08   = 72,
    D3DRENDERSTATE_STIPPLEPATTERN09   = 73,
    D3DRENDERSTATE_STIPPLEPATTERN10   = 74,
    D3DRENDERSTATE_STIPPLEPATTERN11   = 75,
    D3DRENDERSTATE_STIPPLEPATTERN12   = 76,
    D3DRENDERSTATE_STIPPLEPATTERN13   = 77,
    D3DRENDERSTATE_STIPPLEPATTERN14   = 78,
    D3DRENDERSTATE_STIPPLEPATTERN15   = 79,
    D3DRENDERSTATE_STIPPLEPATTERN16   = 80,
    D3DRENDERSTATE_STIPPLEPATTERN17   = 81,
    D3DRENDERSTATE_STIPPLEPATTERN18   = 82,
    D3DRENDERSTATE_STIPPLEPATTERN19   = 83,
    D3DRENDERSTATE_STIPPLEPATTERN20   = 84,
    D3DRENDERSTATE_STIPPLEPATTERN21   = 85,
    D3DRENDERSTATE_STIPPLEPATTERN22   = 86,
    D3DRENDERSTATE_STIPPLEPATTERN23   = 87,
    D3DRENDERSTATE_STIPPLEPATTERN24   = 88,
    D3DRENDERSTATE_STIPPLEPATTERN25   = 89,
    D3DRENDERSTATE_STIPPLEPATTERN26   = 90,
    D3DRENDERSTATE_STIPPLEPATTERN27   = 91,
    D3DRENDERSTATE_STIPPLEPATTERN28   = 92,
    D3DRENDERSTATE_STIPPLEPATTERN29   = 93,
    D3DRENDERSTATE_STIPPLEPATTERN30   = 94,
    D3DRENDERSTATE_STIPPLEPATTERN31   = 95,

//
// retired renderstate names - the values are still used under new naming conventions
//
    D3DRENDERSTATE_FOGTABLESTART      = 36,   /* Fog table start    */
    D3DRENDERSTATE_FOGTABLEEND        = 37,   /* Fog table end      */
    D3DRENDERSTATE_FOGTABLEDENSITY    = 38,   /* Fog table density  */

#if(DIRECT3D_VERSION >= 0x0500)
    D3DRENDERSTATE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DRENDERSTATETYPE;

#else

typedef enum _D3DRENDERSTATETYPE D3DRENDERSTATETYPE;

//
// legacy renderstate names
//
#define D3DRENDERSTATE_TEXTUREPERSPECTIVE       (D3DRENDERSTATETYPE)4
#define D3DRENDERSTATE_ZENABLE                  (D3DRENDERSTATETYPE)7
#define D3DRENDERSTATE_FILLMODE                 (D3DRENDERSTATETYPE)8
#define D3DRENDERSTATE_SHADEMODE                (D3DRENDERSTATETYPE)9
#define D3DRENDERSTATE_LINEPATTERN              (D3DRENDERSTATETYPE)10
#define D3DRENDERSTATE_ZWRITEENABLE             (D3DRENDERSTATETYPE)14
#define D3DRENDERSTATE_ALPHATESTENABLE          (D3DRENDERSTATETYPE)15
#define D3DRENDERSTATE_LASTPIXEL                (D3DRENDERSTATETYPE)16
#define D3DRENDERSTATE_SRCBLEND                 (D3DRENDERSTATETYPE)19
#define D3DRENDERSTATE_DESTBLEND                (D3DRENDERSTATETYPE)20
#define D3DRENDERSTATE_CULLMODE                 (D3DRENDERSTATETYPE)22
#define D3DRENDERSTATE_ZFUNC                    (D3DRENDERSTATETYPE)23
#define D3DRENDERSTATE_ALPHAREF                 (D3DRENDERSTATETYPE)24
#define D3DRENDERSTATE_ALPHAFUNC                (D3DRENDERSTATETYPE)25
#define D3DRENDERSTATE_DITHERENABLE             (D3DRENDERSTATETYPE)26
#define D3DRENDERSTATE_ALPHABLENDENABLE         (D3DRENDERSTATETYPE)27
#define D3DRENDERSTATE_FOGENABLE                (D3DRENDERSTATETYPE)28
#define D3DRENDERSTATE_SPECULARENABLE           (D3DRENDERSTATETYPE)29
#define D3DRENDERSTATE_ZVISIBLE                 (D3DRENDERSTATETYPE)30
#define D3DRENDERSTATE_STIPPLEDALPHA            (D3DRENDERSTATETYPE)33
#define D3DRENDERSTATE_FOGCOLOR                 (D3DRENDERSTATETYPE)34
#define D3DRENDERSTATE_FOGTABLEMODE             (D3DRENDERSTATETYPE)35
#define D3DRENDERSTATE_FOGSTART                 (D3DRENDERSTATETYPE)36
#define D3DRENDERSTATE_FOGEND                   (D3DRENDERSTATETYPE)37
#define D3DRENDERSTATE_FOGDENSITY               (D3DRENDERSTATETYPE)38
#define D3DRENDERSTATE_EDGEANTIALIAS            (D3DRENDERSTATETYPE)40
#define D3DRENDERSTATE_ZBIAS                    (D3DRENDERSTATETYPE)47
#define D3DRENDERSTATE_RANGEFOGENABLE           (D3DRENDERSTATETYPE)48
#define D3DRENDERSTATE_STENCILENABLE            (D3DRENDERSTATETYPE)52
#define D3DRENDERSTATE_STENCILFAIL              (D3DRENDERSTATETYPE)53
#define D3DRENDERSTATE_STENCILZFAIL             (D3DRENDERSTATETYPE)54
#define D3DRENDERSTATE_STENCILPASS              (D3DRENDERSTATETYPE)55
#define D3DRENDERSTATE_STENCILFUNC              (D3DRENDERSTATETYPE)56
#define D3DRENDERSTATE_STENCILREF               (D3DRENDERSTATETYPE)57
#define D3DRENDERSTATE_STENCILMASK              (D3DRENDERSTATETYPE)58
#define D3DRENDERSTATE_STENCILWRITEMASK         (D3DRENDERSTATETYPE)59
#define D3DRENDERSTATE_TEXTUREFACTOR            (D3DRENDERSTATETYPE)60
#define D3DRENDERSTATE_WRAP0                    (D3DRENDERSTATETYPE)128
#define D3DRENDERSTATE_WRAP1                    (D3DRENDERSTATETYPE)129
#define D3DRENDERSTATE_WRAP2                    (D3DRENDERSTATETYPE)130
#define D3DRENDERSTATE_WRAP3                    (D3DRENDERSTATETYPE)131
#define D3DRENDERSTATE_WRAP4                    (D3DRENDERSTATETYPE)132
#define D3DRENDERSTATE_WRAP5                    (D3DRENDERSTATETYPE)133
#define D3DRENDERSTATE_WRAP6                    (D3DRENDERSTATETYPE)134
#define D3DRENDERSTATE_WRAP7                    (D3DRENDERSTATETYPE)135

#define D3DRENDERSTATE_CLIPPING                 (D3DRENDERSTATETYPE)136
#define D3DRENDERSTATE_LIGHTING                 (D3DRENDERSTATETYPE)137
#define D3DRENDERSTATE_EXTENTS                  (D3DRENDERSTATETYPE)138
#define D3DRENDERSTATE_AMBIENT                  (D3DRENDERSTATETYPE)139
#define D3DRENDERSTATE_FOGVERTEXMODE            (D3DRENDERSTATETYPE)140
#define D3DRENDERSTATE_COLORVERTEX              (D3DRENDERSTATETYPE)141
#define D3DRENDERSTATE_LOCALVIEWER              (D3DRENDERSTATETYPE)142
#define D3DRENDERSTATE_NORMALIZENORMALS         (D3DRENDERSTATETYPE)143
#define D3DRENDERSTATE_COLORKEYBLENDENABLE      (D3DRENDERSTATETYPE)144
#define D3DRENDERSTATE_DIFFUSEMATERIALSOURCE    (D3DRENDERSTATETYPE)145
#define D3DRENDERSTATE_SPECULARMATERIALSOURCE   (D3DRENDERSTATETYPE)146
#define D3DRENDERSTATE_AMBIENTMATERIALSOURCE    (D3DRENDERSTATETYPE)147
#define D3DRENDERSTATE_EMISSIVEMATERIALSOURCE   (D3DRENDERSTATETYPE)148
#define D3DRENDERSTATE_VERTEXBLEND              (D3DRENDERSTATETYPE)151
#define D3DRENDERSTATE_CLIPPLANEENABLE          (D3DRENDERSTATETYPE)152

//
// retired renderstates - not supported for DX7 interfaces
//
#define D3DRENDERSTATE_TEXTUREHANDLE     (D3DRENDERSTATETYPE)1
#define D3DRENDERSTATE_ANTIALIAS         (D3DRENDERSTATETYPE)2
#define D3DRENDERSTATE_TEXTUREADDRESS    (D3DRENDERSTATETYPE)3
#define D3DRENDERSTATE_WRAPU             (D3DRENDERSTATETYPE)5
#define D3DRENDERSTATE_WRAPV             (D3DRENDERSTATETYPE)6
#define D3DRENDERSTATE_MONOENABLE        (D3DRENDERSTATETYPE)11
#define D3DRENDERSTATE_ROP2              (D3DRENDERSTATETYPE)12
#define D3DRENDERSTATE_PLANEMASK         (D3DRENDERSTATETYPE)13
#define D3DRENDERSTATE_TEXTUREMAG        (D3DRENDERSTATETYPE)17
#define D3DRENDERSTATE_TEXTUREMIN        (D3DRENDERSTATETYPE)18
#define D3DRENDERSTATE_TEXTUREMAPBLEND   (D3DRENDERSTATETYPE)21
#define D3DRENDERSTATE_SUBPIXEL          (D3DRENDERSTATETYPE)31
#define D3DRENDERSTATE_SUBPIXELX         (D3DRENDERSTATETYPE)32
#define D3DRENDERSTATE_STIPPLEENABLE     (D3DRENDERSTATETYPE)39
#define D3DRENDERSTATE_OLDALPHABLENDENABLE  (D3DRENDERSTATETYPE)42
#define D3DRENDERSTATE_BORDERCOLOR       (D3DRENDERSTATETYPE)43
#define D3DRENDERSTATE_TEXTUREADDRESSU   (D3DRENDERSTATETYPE)44
#define D3DRENDERSTATE_TEXTUREADDRESSV   (D3DRENDERSTATETYPE)45
#define D3DRENDERSTATE_MIPMAPLODBIAS     (D3DRENDERSTATETYPE)46
#define D3DRENDERSTATE_ANISOTROPY        (D3DRENDERSTATETYPE)49
#define D3DRENDERSTATE_FLUSHBATCH        (D3DRENDERSTATETYPE)50
#define D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT (D3DRENDERSTATETYPE)51
#define D3DRENDERSTATE_STIPPLEPATTERN00  (D3DRENDERSTATETYPE)64
#define D3DRENDERSTATE_STIPPLEPATTERN01  (D3DRENDERSTATETYPE)65
#define D3DRENDERSTATE_STIPPLEPATTERN02  (D3DRENDERSTATETYPE)66
#define D3DRENDERSTATE_STIPPLEPATTERN03  (D3DRENDERSTATETYPE)67
#define D3DRENDERSTATE_STIPPLEPATTERN04  (D3DRENDERSTATETYPE)68
#define D3DRENDERSTATE_STIPPLEPATTERN05  (D3DRENDERSTATETYPE)69
#define D3DRENDERSTATE_STIPPLEPATTERN06  (D3DRENDERSTATETYPE)70
#define D3DRENDERSTATE_STIPPLEPATTERN07  (D3DRENDERSTATETYPE)71
#define D3DRENDERSTATE_STIPPLEPATTERN08  (D3DRENDERSTATETYPE)72
#define D3DRENDERSTATE_STIPPLEPATTERN09  (D3DRENDERSTATETYPE)73
#define D3DRENDERSTATE_STIPPLEPATTERN10  (D3DRENDERSTATETYPE)74
#define D3DRENDERSTATE_STIPPLEPATTERN11  (D3DRENDERSTATETYPE)75
#define D3DRENDERSTATE_STIPPLEPATTERN12  (D3DRENDERSTATETYPE)76
#define D3DRENDERSTATE_STIPPLEPATTERN13  (D3DRENDERSTATETYPE)77
#define D3DRENDERSTATE_STIPPLEPATTERN14  (D3DRENDERSTATETYPE)78
#define D3DRENDERSTATE_STIPPLEPATTERN15  (D3DRENDERSTATETYPE)79
#define D3DRENDERSTATE_STIPPLEPATTERN16  (D3DRENDERSTATETYPE)80
#define D3DRENDERSTATE_STIPPLEPATTERN17  (D3DRENDERSTATETYPE)81
#define D3DRENDERSTATE_STIPPLEPATTERN18  (D3DRENDERSTATETYPE)82
#define D3DRENDERSTATE_STIPPLEPATTERN19  (D3DRENDERSTATETYPE)83
#define D3DRENDERSTATE_STIPPLEPATTERN20  (D3DRENDERSTATETYPE)84
#define D3DRENDERSTATE_STIPPLEPATTERN21  (D3DRENDERSTATETYPE)85
#define D3DRENDERSTATE_STIPPLEPATTERN22  (D3DRENDERSTATETYPE)86
#define D3DRENDERSTATE_STIPPLEPATTERN23  (D3DRENDERSTATETYPE)87
#define D3DRENDERSTATE_STIPPLEPATTERN24  (D3DRENDERSTATETYPE)88
#define D3DRENDERSTATE_STIPPLEPATTERN25  (D3DRENDERSTATETYPE)89
#define D3DRENDERSTATE_STIPPLEPATTERN26  (D3DRENDERSTATETYPE)90
#define D3DRENDERSTATE_STIPPLEPATTERN27  (D3DRENDERSTATETYPE)91
#define D3DRENDERSTATE_STIPPLEPATTERN28  (D3DRENDERSTATETYPE)92
#define D3DRENDERSTATE_STIPPLEPATTERN29  (D3DRENDERSTATETYPE)93
#define D3DRENDERSTATE_STIPPLEPATTERN30  (D3DRENDERSTATETYPE)94
#define D3DRENDERSTATE_STIPPLEPATTERN31  (D3DRENDERSTATETYPE)95

//
// retired renderstates - not supported for DX8 interfaces
//
#define D3DRENDERSTATE_COLORKEYENABLE        (D3DRENDERSTATETYPE)41
#define D3DRENDERSTATE_COLORKEYBLENDENABLE   (D3DRENDERSTATETYPE)144

//
// retired renderstate names - the values are still used under new naming conventions
//
#define D3DRENDERSTATE_BLENDENABLE       (D3DRENDERSTATETYPE)27
#define D3DRENDERSTATE_FOGTABLESTART     (D3DRENDERSTATETYPE)36
#define D3DRENDERSTATE_FOGTABLEEND       (D3DRENDERSTATETYPE)37
#define D3DRENDERSTATE_FOGTABLEDENSITY   (D3DRENDERSTATETYPE)38

#endif //(DIRECT3D_VERSION < 0x0800)


#if(DIRECT3D_VERSION < 0x0800)

// Values for material source
typedef enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL = 0,                // Color from material is used
    D3DMCS_COLOR1   = 1,                // Diffuse vertex color is used
    D3DMCS_COLOR2   = 2,                // Specular vertex color is used
    D3DMCS_FORCE_DWORD = 0x7fffffff,    // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;


#if(DIRECT3D_VERSION >= 0x0500)
// For back-compatibility with legacy compilations
#define D3DRENDERSTATE_BLENDENABLE      D3DRENDERSTATE_ALPHABLENDENABLE
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 128UL

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000001L
#define D3DWRAP_V   0x00000002L

#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
#define D3DWRAPCOORD_0   0x00000001L    // same as D3DWRAP_U
#define D3DWRAPCOORD_1   0x00000002L    // same as D3DWRAP_V
#define D3DWRAPCOORD_2   0x00000004L
#define D3DWRAPCOORD_3   0x00000008L

#endif /* DIRECT3D_VERSION >= 0x0700 */

#endif //(DIRECT3D_VERSION < 0x0800)

#define D3DRENDERSTATE_STIPPLEPATTERN(y) (D3DRENDERSTATE_STIPPLEPATTERN00 + (y))

typedef struct _D3DSTATE {
    union {
#if(DIRECT3D_VERSION < 0x0800)
    D3DTRANSFORMSTATETYPE   dtstTransformStateType;
#endif //(DIRECT3D_VERSION < 0x0800)
    D3DLIGHTSTATETYPE   dlstLightStateType;
    D3DRENDERSTATETYPE  drstRenderStateType;
    };
    union {
    DWORD           dwArg[1];
    D3DVALUE        dvArg[1];
    };
} D3DSTATE, *LPD3DSTATE;


/*
 * Operation used to load matrices
 * hDstMat = hSrcMat
 */
typedef struct _D3DMATRIXLOAD {
    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
    D3DMATRIXHANDLE hSrcMatrix;   /* Source matrix */
} D3DMATRIXLOAD, *LPD3DMATRIXLOAD;

/*
 * Operation used to multiply matrices
 * hDstMat = hSrcMat1 * hSrcMat2
 */
typedef struct _D3DMATRIXMULTIPLY {
    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
    D3DMATRIXHANDLE hSrcMatrix1;  /* First source matrix */
    D3DMATRIXHANDLE hSrcMatrix2;  /* Second source matrix */
} D3DMATRIXMULTIPLY, *LPD3DMATRIXMULTIPLY;

/*
 * Operation used to transform and light vertices.
 */
typedef struct _D3DPROCESSVERTICES {
    DWORD        dwFlags;    /* Do we transform or light or just copy? */
    WORD         wStart;     /* Index to first vertex in source */
    WORD         wDest;      /* Index to first vertex in local buffer */
    DWORD        dwCount;    /* Number of vertices to be processed */
    DWORD    dwReserved; /* Must be zero */
} D3DPROCESSVERTICES, *LPD3DPROCESSVERTICES;

#define D3DPROCESSVERTICES_TRANSFORMLIGHT   0x00000000L
#define D3DPROCESSVERTICES_TRANSFORM        0x00000001L
#define D3DPROCESSVERTICES_COPY         0x00000002L
#define D3DPROCESSVERTICES_OPMASK       0x00000007L

#define D3DPROCESSVERTICES_UPDATEEXTENTS    0x00000008L
#define D3DPROCESSVERTICES_NOCOLOR      0x00000010L


#if(DIRECT3D_VERSION >= 0x0600)


#if(DIRECT3D_VERSION < 0x0800)

/*
 * State enumerants for per-stage texture processing.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP        =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
    D3DTSS_COLORARG1      =  2, /* D3DTA_* (texture arg) */
    D3DTSS_COLORARG2      =  3, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAOP        =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
    D3DTSS_ALPHAARG1      =  5, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAARG2      =  6, /* D3DTA_* (texture arg) */
    D3DTSS_BUMPENVMAT00   =  7, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT01   =  8, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT10   =  9, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT11   = 10, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_TEXCOORDINDEX  = 11, /* identifies which set of texture coordinates index this texture */
    D3DTSS_ADDRESS        = 12, /* D3DTEXTUREADDRESS for both coordinates */
    D3DTSS_ADDRESSU       = 13, /* D3DTEXTUREADDRESS for U coordinate */
    D3DTSS_ADDRESSV       = 14, /* D3DTEXTUREADDRESS for V coordinate */
    D3DTSS_BORDERCOLOR    = 15, /* D3DCOLOR */
    D3DTSS_MAGFILTER      = 16, /* D3DTEXTUREMAGFILTER filter to use for magnification */
    D3DTSS_MINFILTER      = 17, /* D3DTEXTUREMINFILTER filter to use for minification */
    D3DTSS_MIPFILTER      = 18, /* D3DTEXTUREMIPFILTER filter to use between mipmaps during minification */
    D3DTSS_MIPMAPLODBIAS  = 19, /* D3DVALUE Mipmap LOD bias */
    D3DTSS_MAXMIPLEVEL    = 20, /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
    D3DTSS_MAXANISOTROPY  = 21, /* DWORD maximum anisotropy */
    D3DTSS_BUMPENVLSCALE  = 22, /* D3DVALUE scale for bump map luminance */
    D3DTSS_BUMPENVLOFFSET = 23, /* D3DVALUE offset for bump map luminance */
#if(DIRECT3D_VERSION >= 0x0700)
    D3DTSS_TEXTURETRANSFORMFLAGS = 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DTSS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURESTAGESTATETYPE;

#if(DIRECT3D_VERSION >= 0x0700)
// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
#define D3DTSS_TCI_PASSTHRU                             0x00000000
#define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
#define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum _D3DTEXTUREOP
{
// Control
    D3DTOP_DISABLE    = 1,      // disables stage
    D3DTOP_SELECTARG1 = 2,      // the default
    D3DTOP_SELECTARG2 = 3,

// Modulate
    D3DTOP_MODULATE   = 4,      // multiply args together
    D3DTOP_MODULATE2X = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X = 6,      // multiply and  2 bits

// Add
    D3DTOP_ADD          =  7,   // add arguments together
    D3DTOP_ADDSIGNED    =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X  =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT     = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH    = 11,   // add 2 args, subtract product
                                // Arg1 + Arg2 - Arg1*Arg2
                                // = Arg1 + (1-Arg1)*Arg2

// Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRENDERSTATE_TEXTUREFACTOR
    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color

// Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

// Bump mapping
    D3DTOP_BUMPENVMAP           = 22, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 23, // with luminance channel
    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 24,

    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG1,2 and ALPHAARG1,2 texture blending operations
 * set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color
#define D3DTA_CURRENT           0x00000001  // select result of previous stage
#define D3DTA_TEXTURE           0x00000002  // select texture color
#define D3DTA_TFACTOR           0x00000003  // select RENDERSTATE_TEXTUREFACTOR
#if(DIRECT3D_VERSION >= 0x0700)
#define D3DTA_SPECULAR          0x00000004  // select specular color
#endif /* DIRECT3D_VERSION >= 0x0700 */
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components

#endif //(DIRECT3D_VERSION < 0x0800)

/*
 *  IDirect3DTexture2 State Filter Types
 */
typedef enum _D3DTEXTUREMAGFILTER
{
    D3DTFG_POINT        = 1,    // nearest
    D3DTFG_LINEAR       = 2,    // linear interpolation
    D3DTFG_FLATCUBIC    = 3,    // cubic
    D3DTFG_GAUSSIANCUBIC = 4,   // different cubic kernel
    D3DTFG_ANISOTROPIC  = 5,    //
#if(DIRECT3D_VERSION >= 0x0700)
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DTFG_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREMAGFILTER;

typedef enum _D3DTEXTUREMINFILTER
{
    D3DTFN_POINT        = 1,    // nearest
    D3DTFN_LINEAR       = 2,    // linear interpolation
    D3DTFN_ANISOTROPIC  = 3,    //
    D3DTFN_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREMINFILTER;

typedef enum _D3DTEXTUREMIPFILTER
{
    D3DTFP_NONE         = 1,    // mipmapping disabled (use MAG filter)
    D3DTFP_POINT        = 2,    // nearest
    D3DTFP_LINEAR       = 3,    // linear interpolation
    D3DTFP_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREMIPFILTER;

#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Triangle flags
 */

/*
 * Tri strip and fan flags.
 * START loads all three vertices
 * EVEN and ODD load just v3 with even or odd culling
 * START_FLAT contains a count from 0 to 29 that allows the
 * whole strip or fan to be culled in one hit.
 * e.g. for a quad len = 1
 */
#define D3DTRIFLAG_START            0x00000000L
#define D3DTRIFLAG_STARTFLAT(len) (len)     /* 0 < len < 30 */
#define D3DTRIFLAG_ODD              0x0000001eL
#define D3DTRIFLAG_EVEN             0x0000001fL

/*
 * Triangle edge flags
 * enable edges for wireframe or antialiasing
 */
#define D3DTRIFLAG_EDGEENABLE1          0x00000100L /* v0-v1 edge */
#define D3DTRIFLAG_EDGEENABLE2          0x00000200L /* v1-v2 edge */
#define D3DTRIFLAG_EDGEENABLE3          0x00000400L /* v2-v0 edge */
#define D3DTRIFLAG_EDGEENABLETRIANGLE \
        (D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2 | D3DTRIFLAG_EDGEENABLE3)

/*
 * Primitive structures and related defines.  Vertex offsets are to types
 * D3DVERTEX, D3DLVERTEX, or D3DTLVERTEX.
 */

/*
 * Triangle list primitive structure
 */
typedef struct _D3DTRIANGLE {
    union {
    WORD    v1;            /* Vertex indices */
    WORD    wV1;
    };
    union {
    WORD    v2;
    WORD    wV2;
    };
    union {
    WORD    v3;
    WORD    wV3;
    };
    WORD        wFlags;       /* Edge (and other) flags */
} D3DTRIANGLE, *LPD3DTRIANGLE;

/*
 * Line list structure.
 * The instruction count defines the number of line segments.
 */
typedef struct _D3DLINE {
    union {
    WORD    v1;            /* Vertex indices */
    WORD    wV1;
    };
    union {
    WORD    v2;
    WORD    wV2;
    };
} D3DLINE, *LPD3DLINE;

/*
 * Span structure
 * Spans join a list of points with the same y value.
 * If the y value changes, a new span is started.
 */
typedef struct _D3DSPAN {
    WORD    wCount; /* Number of spans */
    WORD    wFirst; /* Index to first vertex */
} D3DSPAN, *LPD3DSPAN;

/*
 * Point structure
 */
typedef struct _D3DPOINT {
    WORD    wCount;     /* number of points     */
    WORD    wFirst;     /* index to first vertex    */
} D3DPOINT, *LPD3DPOINT;


/*
 * Forward branch structure.
 * Mask is logically anded with the driver status mask
 * if the result equals 'value', the branch is taken.
 */
typedef struct _D3DBRANCH {
    DWORD   dwMask;     /* Bitmask against D3D status */
    DWORD   dwValue;
    BOOL    bNegate;        /* TRUE to negate comparison */
    DWORD   dwOffset;   /* How far to branch forward (0 for exit)*/
} D3DBRANCH, *LPD3DBRANCH;

/*
 * Status used for set status instruction.
 * The D3D status is initialised on device creation
 * and is modified by all execute calls.
 */
typedef struct _D3DSTATUS {
    DWORD       dwFlags;    /* Do we set extents or status */
    DWORD   dwStatus;   /* D3D status */
    D3DRECT drExtent;
} D3DSTATUS, *LPD3DSTATUS;

#define D3DSETSTATUS_STATUS     0x00000001L
#define D3DSETSTATUS_EXTENTS        0x00000002L
#define D3DSETSTATUS_ALL    (D3DSETSTATUS_STATUS | D3DSETSTATUS_EXTENTS)

#if(DIRECT3D_VERSION >= 0x0500)
typedef struct _D3DCLIPSTATUS {
    DWORD dwFlags; /* Do we set 2d extents, 3D extents or status */
    DWORD dwStatus; /* Clip status */
    float minx, maxx; /* X extents */
    float miny, maxy; /* Y extents */
    float minz, maxz; /* Z extents */
} D3DCLIPSTATUS, *LPD3DCLIPSTATUS;

#define D3DCLIPSTATUS_STATUS        0x00000001L
#define D3DCLIPSTATUS_EXTENTS2      0x00000002L
#define D3DCLIPSTATUS_EXTENTS3      0x00000004L

#endif /* DIRECT3D_VERSION >= 0x0500 */
/*
 * Statistics structure
 */
typedef struct _D3DSTATS {
    DWORD        dwSize;
    DWORD        dwTrianglesDrawn;
    DWORD        dwLinesDrawn;
    DWORD        dwPointsDrawn;
    DWORD        dwSpansDrawn;
    DWORD        dwVerticesProcessed;
} D3DSTATS, *LPD3DSTATS;

/*
 * Execute options.
 * When calling using D3DEXECUTE_UNCLIPPED all the primitives
 * inside the buffer must be contained within the viewport.
 */
#define D3DEXECUTE_CLIPPED       0x00000001l
#define D3DEXECUTE_UNCLIPPED     0x00000002l

typedef struct _D3DEXECUTEDATA {
    DWORD       dwSize;
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;   /* Status after execute */
} D3DEXECUTEDATA, *LPD3DEXECUTEDATA;

/*
 * Palette flags.
 * This are or'ed with the peFlags in the PALETTEENTRYs passed to DirectDraw.
 */
#define D3DPAL_FREE 0x00    /* Renderer may use this entry freely */
#define D3DPAL_READONLY 0x40    /* Renderer may not set this entry */
#define D3DPAL_RESERVED 0x80    /* Renderer may not use this entry */


#if(DIRECT3D_VERSION >= 0x0600)

typedef struct _D3DVERTEXBUFFERDESC {
    DWORD dwSize;
    DWORD dwCaps;
    DWORD dwFVF;
    DWORD dwNumVertices;
} D3DVERTEXBUFFERDESC, *LPD3DVERTEXBUFFERDESC;

#define D3DVBCAPS_SYSTEMMEMORY      0x00000800l
#define D3DVBCAPS_WRITEONLY         0x00010000l
#define D3DVBCAPS_OPTIMIZED         0x80000000l
#define D3DVBCAPS_DONOTCLIP         0x00000001l

/* Vertex Operations for ProcessVertices */
#define D3DVOP_LIGHT       (1 << 10)
#define D3DVOP_TRANSFORM   (1 << 0)
#define D3DVOP_CLIP        (1 << 2)
#define D3DVOP_EXTENTS     (1 << 3)


#if(DIRECT3D_VERSION < 0x0800)

/* The maximum number of vertices user can pass to any d3d
   drawing function or to create vertex buffer with
*/
#define D3DMAXNUMVERTICES    ((1<<16) - 1)
/* The maximum number of primitives user can pass to any d3d
   drawing function.
*/
#define D3DMAXNUMPRIMITIVES  ((1<<16) - 1)

#if(DIRECT3D_VERSION >= 0x0700)

/* Bits for dwFlags in ProcessVertices call */
#define D3DPV_DONOTCOPYDATA (1 << 0)

#endif /* DIRECT3D_VERSION >= 0x0700 */

#endif //(DIRECT3D_VERSION < 0x0800)

//-------------------------------------------------------------------

#if(DIRECT3D_VERSION < 0x0800)

// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x00E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#if(DIRECT3D_VERSION >= 0x0700)
#define D3DFVF_XYZB1            0x006
#define D3DFVF_XYZB2            0x008
#define D3DFVF_XYZB3            0x00a
#define D3DFVF_XYZB4            0x00c
#define D3DFVF_XYZB5            0x00e

#endif /* DIRECT3D_VERSION >= 0x0700 */
#define D3DFVF_NORMAL           0x010
#define D3DFVF_RESERVED1        0x020
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400
#define D3DFVF_TEX5             0x500
#define D3DFVF_TEX6             0x600
#define D3DFVF_TEX7             0x700
#define D3DFVF_TEX8             0x800

#define D3DFVF_RESERVED2        0xf000  // 4 reserved bits

#else
#define D3DFVF_RESERVED1        0x020
#endif //(DIRECT3D_VERSION < 0x0800)

#define D3DFVF_VERTEX ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 )
#define D3DFVF_LVERTEX ( D3DFVF_XYZ | D3DFVF_RESERVED1 | D3DFVF_DIFFUSE | \
                         D3DFVF_SPECULAR | D3DFVF_TEX1 )
#define D3DFVF_TLVERTEX ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | \
                          D3DFVF_TEX1 )


typedef struct _D3DDP_PTRSTRIDE
{
    LPVOID lpvData;
    DWORD  dwStride;
} D3DDP_PTRSTRIDE;

#define D3DDP_MAXTEXCOORD 8

typedef struct _D3DDRAWPRIMITIVESTRIDEDDATA
{
    D3DDP_PTRSTRIDE position;
    D3DDP_PTRSTRIDE normal;
    D3DDP_PTRSTRIDE diffuse;
    D3DDP_PTRSTRIDE specular;
    D3DDP_PTRSTRIDE textureCoords[D3DDP_MAXTEXCOORD];
} D3DDRAWPRIMITIVESTRIDEDDATA, *LPD3DDRAWPRIMITIVESTRIDEDDATA;
//---------------------------------------------------------------------
// ComputeSphereVisibility return values
//
#define D3DVIS_INSIDE_FRUSTUM       0
#define D3DVIS_INTERSECT_FRUSTUM    1
#define D3DVIS_OUTSIDE_FRUSTUM      2
#define D3DVIS_INSIDE_LEFT          0
#define D3DVIS_INTERSECT_LEFT       (1 << 2)
#define D3DVIS_OUTSIDE_LEFT         (2 << 2)
#define D3DVIS_INSIDE_RIGHT         0
#define D3DVIS_INTERSECT_RIGHT      (1 << 4)
#define D3DVIS_OUTSIDE_RIGHT        (2 << 4)
#define D3DVIS_INSIDE_TOP           0
#define D3DVIS_INTERSECT_TOP        (1 << 6)
#define D3DVIS_OUTSIDE_TOP          (2 << 6)
#define D3DVIS_INSIDE_BOTTOM        0
#define D3DVIS_INTERSECT_BOTTOM     (1 << 8)
#define D3DVIS_OUTSIDE_BOTTOM       (2 << 8)
#define D3DVIS_INSIDE_NEAR          0
#define D3DVIS_INTERSECT_NEAR       (1 << 10)
#define D3DVIS_OUTSIDE_NEAR         (2 << 10)
#define D3DVIS_INSIDE_FAR           0
#define D3DVIS_INTERSECT_FAR        (1 << 12)
#define D3DVIS_OUTSIDE_FAR          (2 << 12)

#define D3DVIS_MASK_FRUSTUM         (3 << 0)
#define D3DVIS_MASK_LEFT            (3 << 2)
#define D3DVIS_MASK_RIGHT           (3 << 4)
#define D3DVIS_MASK_TOP             (3 << 6)
#define D3DVIS_MASK_BOTTOM          (3 << 8)
#define D3DVIS_MASK_NEAR            (3 << 10)
#define D3DVIS_MASK_FAR             (3 << 12)

#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION < 0x0800)

#if(DIRECT3D_VERSION >= 0x0700)

// To be used with GetInfo()
#define D3DDEVINFOID_TEXTUREMANAGER    1
#define D3DDEVINFOID_D3DTEXTUREMANAGER 2
#define D3DDEVINFOID_TEXTURING         3

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0xffffffff
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRENDERSTATE_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBLEND_DISABLE  = 0, // Disable vertex blending
    D3DVBLEND_1WEIGHT  = 1, // blend between 2 matrices
    D3DVBLEND_2WEIGHTS = 2, // blend between 3 matrices
    D3DVBLEND_3WEIGHTS = 3, // blend between 4 matrices
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS {
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


#endif /* DIRECT3D_VERSION >= 0x0700 */

#else
//
// legacy vertex blend names
//
typedef enum _D3DVERTEXBLENDFLAGS D3DVERTEXBLENDFLAGS;
#define D3DVBLEND_DISABLE  (D3DVERTEXBLENDFLAGS)0
#define D3DVBLEND_1WEIGHT  (D3DVERTEXBLENDFLAGS)1
#define D3DVBLEND_2WEIGHTS (D3DVERTEXBLENDFLAGS)2
#define D3DVBLEND_3WEIGHTS (D3DVERTEXBLENDFLAGS)3

#endif //(DIRECT3D_VERSION < 0x0800)

#pragma pack()
#pragma warning(default:4201)

#endif /* _D3DTYPES_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx8math.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8math.h
//  Content:    D3DX math types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8MATH_H__
#define __D3DX8MATH_H__

#include <math.h>
#pragma warning(disable:4201) // anonymous unions warning



typedef struct ID3DXMatrixStack *LPD3DXMATRIXSTACK;

// {E3357330-CC5E-11d2-A434-00A0C90629A8}
DEFINE_GUID( IID_ID3DXMatrixStack,
0xe3357330, 0xcc5e, 0x11d2, 0xa4, 0x34, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);


//===========================================================================
//
// General purpose utilities
//
//===========================================================================
#define D3DX_PI    ((FLOAT)  3.141592654f)
#define D3DX_1BYPI ((FLOAT)  0.318309886f)

#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))



//===========================================================================
//
// Vectors
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------
typedef struct D3DXVECTOR2
{
#ifdef __cplusplus
public:
    D3DXVECTOR2() {};
    D3DXVECTOR2( CONST FLOAT * );
    D3DXVECTOR2( FLOAT x, FLOAT y );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR2& operator += ( CONST D3DXVECTOR2& );
    D3DXVECTOR2& operator -= ( CONST D3DXVECTOR2& );
    D3DXVECTOR2& operator *= ( FLOAT );
    D3DXVECTOR2& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR2 operator + () const;
    D3DXVECTOR2 operator - () const;

    // binary operators
    D3DXVECTOR2 operator + ( CONST D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator - ( CONST D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator * ( FLOAT ) const;
    D3DXVECTOR2 operator / ( FLOAT ) const;

    friend D3DXVECTOR2 operator * ( FLOAT, CONST D3DXVECTOR2& );

    BOOL operator == ( CONST D3DXVECTOR2& ) const;
    BOOL operator != ( CONST D3DXVECTOR2& ) const;


public:
#endif //__cplusplus
    FLOAT x, y;
} D3DXVECTOR2, *LPD3DXVECTOR2;


//--------------------------
// 3D Vector
//--------------------------
#ifdef __cplusplus
typedef struct D3DXVECTOR3 : public D3DVECTOR
{
public:
    D3DXVECTOR3() {};
    D3DXVECTOR3( CONST FLOAT * );
    D3DXVECTOR3( CONST D3DVECTOR& );
    D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR3& operator += ( CONST D3DXVECTOR3& );
    D3DXVECTOR3& operator -= ( CONST D3DXVECTOR3& );
    D3DXVECTOR3& operator *= ( FLOAT );
    D3DXVECTOR3& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR3 operator + () const;
    D3DXVECTOR3 operator - () const;

    // binary operators
    D3DXVECTOR3 operator + ( CONST D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator - ( CONST D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator * ( FLOAT ) const;
    D3DXVECTOR3 operator / ( FLOAT ) const;

    friend D3DXVECTOR3 operator * ( FLOAT, CONST struct D3DXVECTOR3& );

    BOOL operator == ( CONST D3DXVECTOR3& ) const;
    BOOL operator != ( CONST D3DXVECTOR3& ) const;

} D3DXVECTOR3, *LPD3DXVECTOR3;

#else //!__cplusplus
typedef struct _D3DVECTOR D3DXVECTOR3, *LPD3DXVECTOR3;
#endif //!__cplusplus


//--------------------------
// 4D Vector
//--------------------------
typedef struct D3DXVECTOR4
{
#ifdef __cplusplus
public:
    D3DXVECTOR4() {};
    D3DXVECTOR4( CONST FLOAT* );
    D3DXVECTOR4( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR4& operator += ( CONST D3DXVECTOR4& );
    D3DXVECTOR4& operator -= ( CONST D3DXVECTOR4& );
    D3DXVECTOR4& operator *= ( FLOAT );
    D3DXVECTOR4& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR4 operator + () const;
    D3DXVECTOR4 operator - () const;

    // binary operators
    D3DXVECTOR4 operator + ( CONST D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator - ( CONST D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator * ( FLOAT ) const;
    D3DXVECTOR4 operator / ( FLOAT ) const;

    friend D3DXVECTOR4 operator * ( FLOAT, CONST D3DXVECTOR4& );

    BOOL operator == ( CONST D3DXVECTOR4& ) const;
    BOOL operator != ( CONST D3DXVECTOR4& ) const;

public:
#endif //__cplusplus
    FLOAT x, y, z, w;
} D3DXVECTOR4, *LPD3DXVECTOR4;


//===========================================================================
//
// Matrices
//
//===========================================================================
#ifdef __cplusplus
typedef struct D3DXMATRIX : public D3DMATRIX
{
public:
    D3DXMATRIX() {};
    D3DXMATRIX( CONST FLOAT * );
    D3DXMATRIX( CONST D3DMATRIX& );
    D3DXMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
                FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
                FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
                FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );


    // access grants
    FLOAT& operator () ( UINT Row, UINT Col );
    FLOAT  operator () ( UINT Row, UINT Col ) const;

    // casting operators
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXMATRIX& operator *= ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator += ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator -= ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator *= ( FLOAT );
    D3DXMATRIX& operator /= ( FLOAT );

    // unary operators
    D3DXMATRIX operator + () const;
    D3DXMATRIX operator - () const;

    // binary operators
    D3DXMATRIX operator * ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator + ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator - ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator * ( FLOAT ) const;
    D3DXMATRIX operator / ( FLOAT ) const;

    friend D3DXMATRIX operator * ( FLOAT, CONST D3DXMATRIX& );

    BOOL operator == ( CONST D3DXMATRIX& ) const;
    BOOL operator != ( CONST D3DXMATRIX& ) const;

} D3DXMATRIX, *LPD3DXMATRIX;

#else //!__cplusplus
typedef struct _D3DMATRIX D3DXMATRIX, *LPD3DXMATRIX;
#endif //!__cplusplus


//===========================================================================
//
//    Quaternions
//
//===========================================================================
typedef struct D3DXQUATERNION
{
#ifdef __cplusplus
public:
    D3DXQUATERNION() {}
    D3DXQUATERNION( CONST FLOAT * );
    D3DXQUATERNION( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXQUATERNION& operator += ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator -= ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( FLOAT );
    D3DXQUATERNION& operator /= ( FLOAT );

    // unary operators
    D3DXQUATERNION  operator + () const;
    D3DXQUATERNION  operator - () const;

    // binary operators
    D3DXQUATERNION operator + ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator - ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( FLOAT ) const;
    D3DXQUATERNION operator / ( FLOAT ) const;

    friend D3DXQUATERNION operator * (FLOAT, CONST D3DXQUATERNION& );

    BOOL operator == ( CONST D3DXQUATERNION& ) const;
    BOOL operator != ( CONST D3DXQUATERNION& ) const;

#endif //__cplusplus
    FLOAT x, y, z, w;
} D3DXQUATERNION, *LPD3DXQUATERNION;


//===========================================================================
//
// Planes
//
//===========================================================================
typedef struct D3DXPLANE
{
#ifdef __cplusplus
public:
    D3DXPLANE() {}
    D3DXPLANE( CONST FLOAT* );
    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // unary operators
    D3DXPLANE operator + () const;
    D3DXPLANE operator - () const;

    // binary operators
    BOOL operator == ( CONST D3DXPLANE& ) const;
    BOOL operator != ( CONST D3DXPLANE& ) const;

#endif //__cplusplus
    FLOAT a, b, c, d;
} D3DXPLANE, *LPD3DXPLANE;


//===========================================================================
//
// Colors
//
//===========================================================================

typedef struct D3DXCOLOR
{
#ifdef __cplusplus
public:
    D3DXCOLOR() {}
    D3DXCOLOR( DWORD argb );
    D3DXCOLOR( CONST FLOAT * );
    D3DXCOLOR( CONST D3DCOLORVALUE& );
    D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );

    // casting
    operator DWORD () const;

    operator FLOAT* ();
    operator CONST FLOAT* () const;

    operator D3DCOLORVALUE* ();
    operator CONST D3DCOLORVALUE* () const;

    operator D3DCOLORVALUE& ();
    operator CONST D3DCOLORVALUE& () const;

    // assignment operators
    D3DXCOLOR& operator += ( CONST D3DXCOLOR& );
    D3DXCOLOR& operator -= ( CONST D3DXCOLOR& );
    D3DXCOLOR& operator *= ( FLOAT );
    D3DXCOLOR& operator /= ( FLOAT );

    // unary operators
    D3DXCOLOR operator + () const;
    D3DXCOLOR operator - () const;

    // binary operators
    D3DXCOLOR operator + ( CONST D3DXCOLOR& ) const;
    D3DXCOLOR operator - ( CONST D3DXCOLOR& ) const;
    D3DXCOLOR operator * ( FLOAT ) const;
    D3DXCOLOR operator / ( FLOAT ) const;

    friend D3DXCOLOR operator * (FLOAT, CONST D3DXCOLOR& );

    BOOL operator == ( CONST D3DXCOLOR& ) const;
    BOOL operator != ( CONST D3DXCOLOR& ) const;

#endif //__cplusplus
    FLOAT r, g, b, a;
} D3DXCOLOR, *LPD3DXCOLOR;



//===========================================================================
//
// D3DX math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

FLOAT D3DXVec2Length
    ( CONST D3DXVECTOR2 *pV );

FLOAT D3DXVec2LengthSq
    ( CONST D3DXVECTOR2 *pV );

FLOAT D3DXVec2Dot
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
FLOAT D3DXVec2CCW
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s );

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR2* WINAPI D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR2* WINAPI D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pT1,
      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR2* WINAPI D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV0, CONST D3DXVECTOR2 *pV1,
      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, 0, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

FLOAT D3DXVec3Length
    ( CONST D3DXVECTOR3 *pV );

FLOAT D3DXVec3LengthSq
    ( CONST D3DXVECTOR3 *pV );

FLOAT D3DXVec3Dot
    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR3* WINAPI D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR3* WINAPI D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pT1,
      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR3* WINAPI D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV0, CONST D3DXVECTOR3 *pV1,
      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      CONST D3DXVECTOR3 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, z, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a 
// non-affine matrix, the matrix you pass to this function should be the 
// transpose of the inverse of the matrix you would use to transform a coord.
D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Project vector from object space into screen space
D3DXVECTOR3* WINAPI D3DXVec3Project
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);

// Project vector from screen space into object space
D3DXVECTOR3* WINAPI D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

FLOAT D3DXVec4Length
    ( CONST D3DXVECTOR4 *pV );

FLOAT D3DXVec4LengthSq
    ( CONST D3DXVECTOR4 *pV );

FLOAT D3DXVec4Dot
    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 );

D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
D3DXVECTOR4* WINAPI D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      CONST D3DXVECTOR4 *pV3);

D3DXVECTOR4* WINAPI D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR4* WINAPI D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pT1,
      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR4* WINAPI D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV0, CONST D3DXVECTOR4 *pV1,
      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      CONST D3DXVECTOR4 *pV3, FLOAT f, FLOAT g);

// Transform vector by matrix.
D3DXVECTOR4* WINAPI D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut );

BOOL D3DXMatrixIsIdentity
    ( CONST D3DXMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

FLOAT WINAPI D3DXMatrixfDeterminant
    ( CONST D3DXMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2
// followed by the transformation M1.  (Out = M1 * M2)
D3DXMATRIX* WINAPI D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );

D3DXMATRIX* WINAPI D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
D3DXMATRIX* WINAPI D3DXMatrixInverse
    ( D3DXMATRIX *pOut, FLOAT *pDeterminant, CONST D3DXMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
D3DXMATRIX* WINAPI D3DXMatrixScaling
    ( D3DXMATRIX *pOut, FLOAT sx, FLOAT sy, FLOAT sz );

// Build a matrix which translates by (x, y, z)
D3DXMATRIX* WINAPI D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, FLOAT x, FLOAT y, FLOAT z );

// Build a matrix which rotates around the X axis
D3DXMATRIX* WINAPI D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Y axis
D3DXMATRIX* WINAPI D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Z axis
D3DXMATRIX* WINAPI D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around an arbitrary axis
D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );

// Build a matrix from a quaternion
D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, CONST D3DXQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );


// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pScalingCenter,
      CONST D3DXQUATERNION *pScalingRotation, CONST D3DXVECTOR3 *pScaling,
      CONST D3DXVECTOR3 *pRotationCenter, CONST D3DXQUATERNION *pRotation,
      CONST D3DXVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR3 *pRotationCenter,
      CONST D3DXQUATERNION *pRotation, CONST D3DXVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
      CONST D3DXVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
      CONST D3DXVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
D3DXMATRIX* WINAPI D3DXMatrixShadow
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR4 *pLight,
      CONST D3DXPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
D3DXMATRIX* WINAPI D3DXMatrixReflect
    ( D3DXMATRIX *pOut, CONST D3DXPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

FLOAT D3DXQuaternionLength
    ( CONST D3DXQUATERNION *pQ );

// Length squared, or "norm"
FLOAT D3DXQuaternionLengthSq
    ( CONST D3DXQUATERNION *pQ );

FLOAT D3DXQuaternionDot
    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 );

// (0, 0, 0, 1)
D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut );

BOOL D3DXQuaternionIsIdentity
    ( CONST D3DXQUATERNION *pQ );

// (-x, -y, -z, w)
D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI D3DXQuaternionToAxisAngle
    ( CONST D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, FLOAT *pAngle );

// Build a quaternion from a rotation matrix.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, CONST D3DXMATRIX *pM);

// Rotation about arbitrary axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );

// Quaternion multiplication.  The result represents the rotation Q2
// followed by the rotation Q1.  (Out = Q2 * Q1)
D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2 );

D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Conjugate and re-norm
D3DXQUATERNION* WINAPI D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
D3DXQUATERNION* WINAPI D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
D3DXQUATERNION* WINAPI D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, FLOAT t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
D3DXQUATERNION* WINAPI D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
      CONST D3DXQUATERNION *pQ4, FLOAT t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
      FLOAT f, FLOAT g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
FLOAT D3DXPlaneDot
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV);

// ax + by + cz + d
FLOAT D3DXPlaneDotCoord
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);

// ax + by + cz
FLOAT D3DXPlaneDotNormal
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
D3DXPLANE* WINAPI D3DXPlaneNormalize
    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV1,
      CONST D3DXVECTOR3 *pV2);

// Construct a plane from a point and a normal
D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pPoint, CONST D3DXVECTOR3 *pNormal);

// Construct a plane from 3 points
D3DXPLANE* WINAPI D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      CONST D3DXVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
D3DXPLANE* WINAPI D3DXPlaneTransform
    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC);

D3DXCOLOR* D3DXColorAdd
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorSubtract
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorScale
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
D3DXCOLOR* D3DXColorModulate
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
D3DXCOLOR* D3DXColorLerp
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
D3DXCOLOR* WINAPI D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT c);

#ifdef __cplusplus
}
#endif






//===========================================================================
//
//    Matrix Stack
//
//===========================================================================

DECLARE_INTERFACE_(ID3DXMatrixStack, IUnknown)
{
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // ID3DXMatrixStack methods
    //

    // Pops the top of the stack, returns the current top
    // *after* popping the top.
    STDMETHOD(Pop)(THIS) PURE;

    // Pushes the stack by one, duplicating the current matrix.
    STDMETHOD(Push)(THIS) PURE;

    // Loads identity in the current matrix.
    STDMETHOD(LoadIdentity)(THIS) PURE;

    // Loads the given matrix into the current matrix
    STDMETHOD(LoadMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Right-Multiplies the given matrix to the current matrix.
    // (transformation is about the current world origin)
    STDMETHOD(MultMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Left-Multiplies the given matrix to the current matrix
    // (transformation is about the local origin of the object)
    STDMETHOD(MultMatrixLocal)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the current world origin)
    STDMETHOD(RotateAxis)
        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the local origin of the object)
    STDMETHOD(RotateAxisLocal)
        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // current world origin)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRoll)
        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // local origin of the object)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRollLocal)
        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;

    // Right multiply the current matrix with the computed scale
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Scale)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Left multiply the current matrix with the computed scale
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(ScaleLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Right multiply the current matrix with the computed translation
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Translate)(THIS_ FLOAT x, FLOAT y, FLOAT z ) PURE;

    // Left multiply the current matrix with the computed translation
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(TranslateLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Obtain the current matrix at the top of the stack
    STDMETHOD_(D3DXMATRIX*, GetTop)(THIS) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI D3DXCreateMatrixStack( DWORD Flags, LPD3DXMATRIXSTACK *ppStack );

#ifdef __cplusplus
}
#endif

#include "d3dx8math.inl"

#pragma warning(default:4201)

#endif // __D3DX8MATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dvec.inl ===
/****************************************************************** 
 *                                                                *
 *   D3DVec.inl                                                   *
 *                                                                *
 *   Float-valued 3D vector class for Direct3D.                   *
 *                                                                *
 *   Copyright (c) 1996-1998 Microsoft Corp. All rights reserved. *
 *                                                                *
 ******************************************************************/

#include <math.h>

// =====================================
// Constructors
// =====================================

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE f)
{
    x = y = z = f;
}

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z)
{
    x = _x; y = _y; z = _z;
}

inline
_D3DVECTOR::_D3DVECTOR(const D3DVALUE f[3])
{
    x = f[0]; y = f[1]; z = f[2];
}

// =====================================
// Access grants
// =====================================

inline const D3DVALUE&
_D3DVECTOR::operator[](int i) const
{
    return (&x)[i];
}

inline D3DVALUE&
_D3DVECTOR::operator[](int i)
{
    return (&x)[i];
}


// =====================================
// Assignment operators
// =====================================

inline _D3DVECTOR&
_D3DVECTOR::operator += (const _D3DVECTOR& v)
{
   x += v.x;   y += v.y;   z += v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator -= (const _D3DVECTOR& v)
{
   x -= v.x;   y -= v.y;   z -= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (const _D3DVECTOR& v)
{
   x *= v.x;   y *= v.y;   z *= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (const _D3DVECTOR& v)
{
   x /= v.x;   y /= v.y;   z /= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (D3DVALUE s)
{
   x *= s;   y *= s;   z *= s;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (D3DVALUE s)
{
   x /= s;   y /= s;   z /= s;
   return *this;
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v)
{
   return v;
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v)
{
   return _D3DVECTOR(-v.x, -v.y, -v.z);
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x/v2.x, v1.y/v2.y, v1.z/v2.z);
}

inline int
operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] < v2[0] && v1[1] < v2[1] && v1[2] < v2[2];
}

inline int
operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] <= v2[0] && v1[1] <= v2[1] && v1[2] <= v2[2];
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator * (D3DVALUE s, const _D3DVECTOR& v)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(v.x/s, v.y/s, v.z/s);
}

inline int
operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x==v2.x && v1.y==v2.y && v1.z == v2.z;
}

inline D3DVALUE
Magnitude (const _D3DVECTOR& v)
{
   return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline D3DVALUE
SquareMagnitude (const _D3DVECTOR& v)
{
   return v.x*v.x + v.y*v.y + v.z*v.z;
}

inline _D3DVECTOR
Normalize (const _D3DVECTOR& v)
{
   return v / Magnitude(v);
}

inline D3DVALUE
Min (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (v.y < ret) ret = v.y;
   if (v.z < ret) ret = v.z;
   return ret;
}

inline D3DVALUE
Max (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (ret < v.y) ret = v.y;
   if (ret < v.z) ret = v.z;
   return ret;
}

inline _D3DVECTOR
Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] < v2[0] ? v1[0] : v2[0],
                   v1[1] < v2[1] ? v1[1] : v2[1],
                   v1[2] < v2[2] ? v1[2] : v2[2]);
}

inline _D3DVECTOR
Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] > v2[0] ? v1[0] : v2[0],
                   v1[1] > v2[1] ? v1[1] : v2[1],
                   v1[2] > v2[2] ? v1[2] : v2[2]);
}

inline D3DVALUE
DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x*v2.x + v1.y * v2.y + v1.z*v2.z;
}

inline _D3DVECTOR
CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
	_D3DVECTOR result;

	result[0] = v1[1] * v2[2] - v1[2] * v2[1];
	result[1] = v1[2] * v2[0] - v1[0] * v2[2];
	result[2] = v1[0] * v2[1] - v1[1] * v2[0];

	return result;
}

inline _D3DMATRIX
operator* (const _D3DMATRIX& a, const _D3DMATRIX& b)
{
    _D3DMATRIX ret;
    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
            ret(i, j) = 0.0f;
            for (int k=0; k<4; k++) {
                ret(i, j) += a(i, k) * b(k, j);
            }
        }
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx8tex.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8tex.h
//  Content:    D3DX texturing APIs
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8TEX_H__
#define __D3DX8TEX_H__


//-------------------------------------------------------------------------
// D3DX_FILTER flags:
// ------------------
//
// A valid filter must contain one of these values:
//
//  D3DX_FILTER_NONE
//      No scaling or filtering will take place.  Pixels outside the bounds
//      of the source image are assumed to be transparent black.
//  D3DX_FILTER_POINT
//      Each destination pixel is computed by sampling the nearest pixel
//      from the source image.
//  D3DX_FILTER_LINEAR
//      Each destination pixel is computed by linearly interpolating between
//      the nearest pixels in the source image.  This filter works best 
//      when the scale on each axis is less than 2.
//  D3DX_FILTER_TRIANGLE
//      Every pixel in the source image contributes equally to the
//      destination image.  This is the slowest of all the filters.
//  D3DX_FILTER_BOX
//      Each pixel is computed by averaging a 2x2(x2) box pixels from 
//      the source image. Only works when the dimensions of the 
//      destination are half those of the source. (as with mip maps)
//
//
// And can be OR'd with any of these optional flags:
//
//  D3DX_FILTER_MIRROR_U
//      Indicates that pixels off the edge of the texture on the U-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR_V
//      Indicates that pixels off the edge of the texture on the V-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR_W
//      Indicates that pixels off the edge of the texture on the W-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR
//      Same as specifying D3DX_FILTER_MIRROR_U, D3DX_FILTER_MIRROR_V,
//      and D3DX_FILTER_MIRROR_V
//  D3DX_FILTER_DITHER
//      Dithers the resulting image.
//
//-------------------------------------------------------------------------

#define D3DX_FILTER_NONE      (1 << 0)
#define D3DX_FILTER_POINT     (2 << 0)
#define D3DX_FILTER_LINEAR    (3 << 0)
#define D3DX_FILTER_TRIANGLE  (4 << 0)
#define D3DX_FILTER_BOX       (5 << 0)

#define D3DX_FILTER_MIRROR_U  (1 << 16)
#define D3DX_FILTER_MIRROR_V  (2 << 16)
#define D3DX_FILTER_MIRROR_W  (4 << 16)
#define D3DX_FILTER_MIRROR    (7 << 16)
#define D3DX_FILTER_DITHER    (8 << 16)


//-------------------------------------------------------------------------
// D3DXIMAGE_INFO:
// ---------------
// This structure is used to return a rough description of what the
// the original contents of an image file looked like.
// 
//  Width
//      Width of original image in pixels
//  Height
//      Height of original image in pixels
//  Depth
//      Depth of original image in pixels
//  MipLevels
//      Number of mip levels in original image
//  Format
//      D3D format which most closely describes the data in original image
//
//-------------------------------------------------------------------------


typedef struct _D3DXIMAGE_INFO
{
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT MipLevels;
    D3DFORMAT Format;

} D3DXIMAGE_INFO;



#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromFile/Resource:
// ---------------------------------
// Load surface from a file or resource
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcFile
//      File name of the source image.
//  pSrcModule
//      Module where resource is located, or NULL for module associated
//      with image the os used to create the current process.
//  pSrcResource
//      Resource name
//  pSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  pSrcRect
//      Source rectangle, or NULL for entire image
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for 
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the 
//      description of the data in the source image file, or NULL.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromFileA(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCSTR                pSrcFile,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);

HRESULT WINAPI
    D3DXLoadSurfaceFromFileW(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCWSTR               pSrcFile,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);

#ifdef UNICODE
#define D3DXLoadSurfaceFromFile D3DXLoadSurfaceFromFileW
#else
#define D3DXLoadSurfaceFromFile D3DXLoadSurfaceFromFileA
#endif


HRESULT WINAPI
    D3DXLoadSurfaceFromResourceA(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);

HRESULT WINAPI
    D3DXLoadSurfaceFromResourceW(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        HMODULE               hSrcModule,
        LPCWSTR               pSrcResource,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);


#ifdef UNICODE
#define D3DXLoadSurfaceFromResource D3DXLoadSurfaceFromResourceW
#else
#define D3DXLoadSurfaceFromResource D3DXLoadSurfaceFromResourceA
#endif


HRESULT WINAPI
    D3DXLoadSurfaceFromFileInMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);



//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromSurface:
// --------------------------
// Load surface from another surface (with color conversion)
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcSurface
//      Source surface
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcRect
//      Source rectangle, or NULL for entire surface
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for 
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromSurface(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPDIRECT3DSURFACE8    pSrcSurface,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromMemory:
// ------------------------
// Load surface from memory.
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcMemory
//      Pointer to the top-left corner of the source image in memory
//  SrcFormat
//      Pixel format of the source image.
//  SrcPitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the width of one row of cells, in bytes.
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcRect
//      Source rectangle.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for 
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  SrcPitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//-------------------------------------------------------------------------
// D3DXLoadVolumeFromVolume:
// --------------------------
// Load volume from another volume (with color conversion)
//
// Parameters:
//  pDestVolume
//      Destination volume, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestBox
//      Destination box, or NULL for entire volume
//  pSrcVolume
//      Source volume
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcBox
//      Source box, or NULL for entire volume
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for 
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadVolumeFromVolume(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPDIRECT3DVOLUME8     pSrcVolume,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


//-------------------------------------------------------------------------
// D3DXLoadVolumeFromMemory:
// ------------------------
// Load volume from memory.
//
// Parameters:
//  pDestVolume
//      Destination volume, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestBox
//      Destination box, or NULL for entire volume
//  pSrcMemory
//      Pointer to the top-left corner of the source volume in memory
//  SrcFormat
//      Pixel format of the source volume.
//  SrcRowPitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the size of one row of cells, in bytes.
//  SrcSlicePitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the size of one slice of cells, in bytes.
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcBox
//      Source box.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for 
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadVolumeFromMemory(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  SrcRowPitch,
        UINT                  SrcSlicePitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




//-------------------------------------------------------------------------
// D3DXCheckTextureRequirements:
// -----------------------------
//
// Checks texture creation parameters.  If parameters are invalid, this
// function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pWidth
//      Desired width in pixels, or NULL.  Returns corrected width.
//  pHeight
//      Desired height in pixels, or NULL.  Returns corrected height.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  Usage
//      Texture usage flags
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//  Pool
//      Memory pool to be used to create texture
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateTexture:
// ------------------
// Create an empty texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Width
//      width in pixels; must be non-zero
//  Height
//      height in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Pixel format.
//  Pool
//      Memory pool to be used to create texture
//  ppTexture
//      The texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTexture(
        LPDIRECT3DDEVICE8     pDevice,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        LPDIRECT3DTEXTURE8*   ppTexture);


//-------------------------------------------------------------------------
// D3DXCreateTextureFromFile:
// --------------------------
// Create a texture object from a file.
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  pSrcFile
//      File name.
//  hSrcModule
//      Module handle. if NULL, current module will be used.
//  pSrcResource
//      Resource name in module
//  pvSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  Width
//      Width in pixels; if zero or D3DX_DEFAULT, the width will be taken
//      from the file.
//  Height
//      Height in pixels; if zero of D3DX_DEFAULT, the height will be taken
//      from the file.
//  MipLevels
//      Number of mip levels;  if zero or D3DX_DEFAULT, a complete mipmap
//      chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Desired pixel format.  If D3DFMT_UNKNOWN, the format will be
//      taken from the file.
//  Pool
//      Memory pool to be used to create texture
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  MipFilter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for 
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the 
//      description of the data in the source image file, or NULL.
//  pPalette
//      256 color palette to be filled in, or NULL
//  ppTexture
//      The texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTextureFromFileA(
        LPDIRECT3DDEVICE8     pDevice,
        LPCSTR                pSrcFile,
        LPDIRECT3DTEXTURE8*   ppTexture);

HRESULT WINAPI
    D3DXCreateTextureFromFileW(
        LPDIRECT3DDEVICE8     pDevice,
        LPCWSTR               pSrcFile,
        LPDIRECT3DTEXTURE8*   ppTexture);

#ifdef UNICODE
#define D3DXCreateTextureFromFile D3DXCreateTextureFromFileW
#else
#define D3DXCreateTextureFromFile D3DXCreateTextureFromFileA
#endif


HRESULT WINAPI
    D3DXCreateTextureFromResourceA(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        LPDIRECT3DTEXTURE8*   ppTexture);

HRESULT WINAPI
    D3DXCreateTextureFromResourceW(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCWSTR               pSrcResource,
        LPDIRECT3DTEXTURE8*   ppTexture);

#ifdef UNICODE
#define D3DXCreateTextureFromResource D3DXCreateTextureFromResourceW
#else
#define D3DXCreateTextureFromResource D3DXCreateTextureFromResourceA
#endif


HRESULT WINAPI
    D3DXCreateTextureFromFileExA(
        LPDIRECT3DDEVICE8     pDevice,
        LPCSTR                pSrcFile,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);

HRESULT WINAPI
    D3DXCreateTextureFromFileExW(
        LPDIRECT3DDEVICE8     pDevice,
        LPCWSTR               pSrcFile,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);

#ifdef UNICODE
#define D3DXCreateTextureFromFileEx D3DXCreateTextureFromFileExW
#else
#define D3DXCreateTextureFromFileEx D3DXCreateTextureFromFileExA
#endif


HRESULT WINAPI
    D3DXCreateTextureFromResourceExA(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);

HRESULT WINAPI
    D3DXCreateTextureFromResourceExW(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCWSTR               pSrcResource,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);

#ifdef UNICODE
#define D3DXCreateTextureFromResourceEx D3DXCreateTextureFromResourceExW
#else
#define D3DXCreateTextureFromResourceEx D3DXCreateTextureFromResourceExA
#endif


HRESULT WINAPI
    D3DXCreateTextureFromFileInMemory(
        LPDIRECT3DDEVICE8     pDevice,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        LPDIRECT3DTEXTURE8*   ppTexture);


HRESULT WINAPI
    D3DXCreateTextureFromFileInMemoryEx(
        LPDIRECT3DDEVICE8     pDevice,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);



//-------------------------------------------------------------------------
// D3DXFilterTexture:
// ------------------
// Filters mipmaps levels of a texture.
//
// Parameters:
//  pTexture
//      The texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL for non-palettized formats
//  SrcLevel
//      The level whose image is used to generate the subsequent levels. 
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterTexture(
        LPDIRECT3DTEXTURE8    pTexture,
        CONST PALETTEENTRY*   pPalette,
        UINT                  SrcLevel,
        DWORD                 Filter);





///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////





//-------------------------------------------------------------------------
// D3DXCheckCubeTextureRequirements:
// ---------------------------------
//
// Checks cube texture creation parameters.  If parameters are invalid, 
// this function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pSize
//      Desired width and height in pixels, or NULL.  Returns corrected size.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  Usage
//      Texture usage flags
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//  Pool
//      Memory pool to be used to create texture
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckCubeTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pSize,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateCubeTexture:
// ----------------------
// Create an empty cube texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Size
//      width and height in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Pixel format.
//  Pool
//      Memory pool to be used to create texture
//  ppCubeTexture
//      The cube texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCubeTexture(
        LPDIRECT3DDEVICE8         pDevice,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


//-------------------------------------------------------------------------
// D3DXCreateCubeTextureFromFile:
// --------------------------
// Create a cube texture object from a file.
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  pSrcFile
//      File name.
//  pvSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  Size
//      Width and height in pixels; if zero or D3DX_DEFAULT, the size 
//      will be taken from the file.
//  MipLevels
//      Number of mip levels;  if zero or D3DX_DEFAULT, a complete mipmap
//      chain will be created.
//  Format
//      Desired pixel format.  If D3DFMT_UNKNOWN, the format will be
//      taken from the file.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  MipFilter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for 
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the 
//      description of the data in the source image file, or NULL.
//  pPalette
//      256 color palette to be filled in, or NULL
//  ppCubeTexture
//      The cube texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCubeTextureFromFileA(
        LPDIRECT3DDEVICE8         pDevice,
        LPCSTR                    pSrcFile,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);

HRESULT WINAPI
    D3DXCreateCubeTextureFromFileW(
        LPDIRECT3DDEVICE8         pDevice,
        LPCWSTR                   pSrcFile,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);

#ifdef UNICODE
#define D3DXCreateCubeTextureFromFile D3DXCreateCubeTextureFromFileW
#else
#define D3DXCreateCubeTextureFromFile D3DXCreateCubeTextureFromFileA
#endif


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileExA(
        LPDIRECT3DDEVICE8         pDevice,
        LPCSTR                    pSrcFile,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        DWORD                     Filter,
        DWORD                     MipFilter,
        D3DCOLOR                  ColorKey,
        D3DXIMAGE_INFO*           pSrcInfo,
        PALETTEENTRY*             pPalette,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);

HRESULT WINAPI
    D3DXCreateCubeTextureFromFileExW(
        LPDIRECT3DDEVICE8         pDevice,
        LPCWSTR                   pSrcFile,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        DWORD                     Filter,
        DWORD                     MipFilter,
        D3DCOLOR                  ColorKey,
        D3DXIMAGE_INFO*           pSrcInfo,
        PALETTEENTRY*             pPalette,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);

#ifdef UNICODE
#define D3DXCreateCubeTextureFromFileEx D3DXCreateCubeTextureFromFileExW
#else
#define D3DXCreateCubeTextureFromFileEx D3DXCreateCubeTextureFromFileExA
#endif


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileInMemory(
        LPDIRECT3DDEVICE8         pDevice,
        LPCVOID                   pSrcData,
        UINT                      SrcDataSize,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileInMemoryEx(
        LPDIRECT3DDEVICE8         pDevice,
        LPCVOID                   pSrcData,
        UINT                      SrcDataSize,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        DWORD                     Filter,
        DWORD                     MipFilter,
        D3DCOLOR                  ColorKey,
        D3DXIMAGE_INFO*           pSrcInfo,
        PALETTEENTRY*             pPalette,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


//-------------------------------------------------------------------------
// D3DXFilterCubeTexture:
// ----------------------
// Filters mipmaps levels of a cube texture map.
//
// Parameters:
//  pCubeTexture
//      The cube texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL
//  SrcLevel
//      The level whose image is used to generate the subsequent levels. 
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterCubeTexture(
        LPDIRECT3DCUBETEXTURE8    pCubeTexture,
        CONST PALETTEENTRY*       pPalette,
        UINT                      SrcLevel,
        DWORD                     Filter);




///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




//-------------------------------------------------------------------------
// D3DXCheckVolumeTextureRequirements:
// -----------------------------------
//
// Checks volume texture creation parameters.  If parameters are invalid, 
// this function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pWidth
//      Desired width in pixels, or NULL.  Returns corrected size.
//  pHeight
//      Desired height in pixels, or NULL.  Returns corrected size.
//  pDepth
//      Desired depth in pixels, or NULL.  Returns corrected size.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckVolumeTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pDepth,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateVolumeTexture:
// ----------------------
// Create an empty volume texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Width
//      width in pixels; must be non-zero
//  Height
//      height in pixels; must be non-zero
//  Depth
//      depth in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Format
//      pixel format.
//  ppVolumeTexture
//      The volume texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateVolumeTexture(
        LPDIRECT3DDEVICE8         pDevice,
        UINT                      Width,
        UINT                      Height,
        UINT                      Depth,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        LPDIRECT3DVOLUMETEXTURE8* ppVolumeTexture);


//-------------------------------------------------------------------------
// D3DXFilterVolumeTexture:
// ------------------------
// Filters mipmaps levels of a volume texture map.
//
// Parameters:
//  pVolumeTexture
//      The volume texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL
//  SrcLevel
//      The level whose image is used to generate the subsequent levels. 
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterVolumeTexture(
        LPDIRECT3DVOLUMETEXTURE8  pVolumeTexture,
        CONST PALETTEENTRY*       pPalette,
        UINT                      SrcLevel,
        DWORD                     Filter);



#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8TEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dxmath.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.h
//  Content:    D3DX math types and functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DXMATH_H__
#define __D3DXMATH_H__

#include <d3d.h>
#include <math.h>
#include <limits.h>
#include "d3dxerr.h"

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#pragma warning(disable:4201) // anonymous unions warning



typedef struct ID3DXMatrixStack *LPD3DXMATRIXSTACK;

// {E3357330-CC5E-11d2-A434-00A0C90629A8}
DEFINE_GUID( IID_ID3DXMatrixStack,
             0xe3357330, 0xcc5e, 0x11d2, 0xa4, 0x34, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);


//===========================================================================
//
// General purpose utilities
//
//===========================================================================
#define D3DX_PI    ((float)  3.141592654f)
#define D3DX_1BYPI ((float)  0.318309886f)

#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))



//===========================================================================
//
// Vectors
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------
typedef struct D3DXVECTOR2
{
#ifdef __cplusplus
public:
    D3DXVECTOR2() {};
    D3DXVECTOR2( const float * );
    D3DXVECTOR2( float x, float y );

    // casting
    operator float* ();
    operator const float* () const;

    // assignment operators
    D3DXVECTOR2& operator += ( const D3DXVECTOR2& );
    D3DXVECTOR2& operator -= ( const D3DXVECTOR2& );
    D3DXVECTOR2& operator *= ( float );
    D3DXVECTOR2& operator /= ( float );

    // unary operators
    D3DXVECTOR2 operator + () const;
    D3DXVECTOR2 operator - () const;

    // binary operators
    D3DXVECTOR2 operator + ( const D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator - ( const D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator * ( float ) const;
    D3DXVECTOR2 operator / ( float ) const;

    friend D3DXVECTOR2 operator * ( float, const D3DXVECTOR2& );

    BOOL operator == ( const D3DXVECTOR2& ) const;
    BOOL operator != ( const D3DXVECTOR2& ) const;


public:
#endif //__cplusplus
    float x, y;
} D3DXVECTOR2, *LPD3DXVECTOR2;


//--------------------------
// 3D Vector
//--------------------------
typedef struct D3DXVECTOR3
{
#ifdef __cplusplus
public:
    D3DXVECTOR3() {};
    D3DXVECTOR3( const float * );
    D3DXVECTOR3( const D3DVECTOR& );
    D3DXVECTOR3( float x, float y, float z );

    // casting
    operator float* ();
    operator const float* () const;

    operator D3DVECTOR* ();
    operator const D3DVECTOR* () const;

    operator D3DVECTOR& ();
    operator const D3DVECTOR& () const;

    // assignment operators
    D3DXVECTOR3& operator += ( const D3DXVECTOR3& );
    D3DXVECTOR3& operator -= ( const D3DXVECTOR3& );
    D3DXVECTOR3& operator *= ( float );
    D3DXVECTOR3& operator /= ( float );

    // unary operators
    D3DXVECTOR3 operator + () const;
    D3DXVECTOR3 operator - () const;

    // binary operators
    D3DXVECTOR3 operator + ( const D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator - ( const D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator * ( float ) const;
    D3DXVECTOR3 operator / ( float ) const;

    friend D3DXVECTOR3 operator * ( float, const struct D3DXVECTOR3& );

    BOOL operator == ( const D3DXVECTOR3& ) const;
    BOOL operator != ( const D3DXVECTOR3& ) const;

public:
#endif //__cplusplus
    float x, y, z;
} D3DXVECTOR3, *LPD3DXVECTOR3;


//--------------------------
// 4D Vector
//--------------------------
typedef struct D3DXVECTOR4
{
#ifdef __cplusplus
public:
    D3DXVECTOR4() {};
    D3DXVECTOR4( const float* );
    D3DXVECTOR4( float x, float y, float z, float w );

    // casting
    operator float* ();
    operator const float* () const;

    // assignment operators
    D3DXVECTOR4& operator += ( const D3DXVECTOR4& );
    D3DXVECTOR4& operator -= ( const D3DXVECTOR4& );
    D3DXVECTOR4& operator *= ( float );
    D3DXVECTOR4& operator /= ( float );

    // unary operators
    D3DXVECTOR4 operator + () const;
    D3DXVECTOR4 operator - () const;

    // binary operators
    D3DXVECTOR4 operator + ( const D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator - ( const D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator * ( float ) const;
    D3DXVECTOR4 operator / ( float ) const;

    friend D3DXVECTOR4 operator * ( float, const D3DXVECTOR4& );

    BOOL operator == ( const D3DXVECTOR4& ) const;
    BOOL operator != ( const D3DXVECTOR4& ) const;

public:
#endif //__cplusplus
    float x, y, z, w;
} D3DXVECTOR4, *LPD3DXVECTOR4;


//===========================================================================
//
// Matrices
//
//===========================================================================
typedef struct D3DXMATRIX
{
#ifdef __cplusplus
public:
    D3DXMATRIX() {};
    D3DXMATRIX( const float * );
    D3DXMATRIX( const D3DMATRIX& );
    D3DXMATRIX( float m00, float m01, float m02, float m03,
                float m10, float m11, float m12, float m13,
                float m20, float m21, float m22, float m23,
                float m30, float m31, float m32, float m33 );


    // access grants
    float& operator () ( UINT iRow, UINT iCol );
    float  operator () ( UINT iRow, UINT iCol ) const;

    // casting operators
    operator float* ();
    operator const float* () const;

    operator D3DMATRIX* ();
    operator const D3DMATRIX* () const;

    operator D3DMATRIX& ();
    operator const D3DMATRIX& () const;

    // assignment operators
    D3DXMATRIX& operator *= ( const D3DXMATRIX& );
    D3DXMATRIX& operator += ( const D3DXMATRIX& );
    D3DXMATRIX& operator -= ( const D3DXMATRIX& );
    D3DXMATRIX& operator *= ( float );
    D3DXMATRIX& operator /= ( float );

    // unary operators
    D3DXMATRIX operator + () const;
    D3DXMATRIX operator - () const;

    // binary operators
    D3DXMATRIX operator * ( const D3DXMATRIX& ) const;
    D3DXMATRIX operator + ( const D3DXMATRIX& ) const;
    D3DXMATRIX operator - ( const D3DXMATRIX& ) const;
    D3DXMATRIX operator * ( float ) const;
    D3DXMATRIX operator / ( float ) const;

    friend D3DXMATRIX operator * ( float, const D3DXMATRIX& );

    BOOL operator == ( const D3DXMATRIX& ) const;
    BOOL operator != ( const D3DXMATRIX& ) const;


#endif //__cplusplus

    union
    {
        float m[4][4];
#ifdef __cplusplus
        struct
        {
            float m00, m01, m02, m03;
            float m10, m11, m12, m13;
            float m20, m21, m22, m23;
            float m30, m31, m32, m33;
        };
#endif //__cplusplus
    };
} D3DXMATRIX, *LPD3DXMATRIX;


//===========================================================================
//
//    Quaternions
//
//===========================================================================
typedef struct D3DXQUATERNION
{
#ifdef __cplusplus
public:
    D3DXQUATERNION() {}
    D3DXQUATERNION( const float * );
    D3DXQUATERNION( float x, float y, float z, float w );

    // casting
    operator float* ();
    operator const float* () const;

    // assignment operators
    D3DXQUATERNION& operator += ( const D3DXQUATERNION& );
    D3DXQUATERNION& operator -= ( const D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( const D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( float );
    D3DXQUATERNION& operator /= ( float );

    // unary operators
    D3DXQUATERNION  operator + () const;
    D3DXQUATERNION  operator - () const;

    // binary operators
    D3DXQUATERNION operator + ( const D3DXQUATERNION& ) const;
    D3DXQUATERNION operator - ( const D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( const D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( float ) const;
    D3DXQUATERNION operator / ( float ) const;

    friend D3DXQUATERNION operator * (float, const D3DXQUATERNION& );

    BOOL operator == ( const D3DXQUATERNION& ) const;
    BOOL operator != ( const D3DXQUATERNION& ) const;

#endif //__cplusplus
    float x, y, z, w;
} D3DXQUATERNION, *LPD3DXQUATERNION;


//===========================================================================
//
// Planes
//
//===========================================================================
typedef struct D3DXPLANE
{
#ifdef __cplusplus
public:
    D3DXPLANE() {}
    D3DXPLANE( const float* );
    D3DXPLANE( float a, float b, float c, float d );

    // casting
    operator float* ();
    operator const float* () const;

    // unary operators
    D3DXPLANE operator + () const;
    D3DXPLANE operator - () const;

    // binary operators
    BOOL operator == ( const D3DXPLANE& ) const;
    BOOL operator != ( const D3DXPLANE& ) const;

#endif //__cplusplus
    float a, b, c, d;
} D3DXPLANE, *LPD3DXPLANE;


//===========================================================================
//
// Colors
//
//===========================================================================

typedef struct D3DXCOLOR
{
#ifdef __cplusplus
public:
    D3DXCOLOR() {}
    D3DXCOLOR( DWORD argb );
    D3DXCOLOR( const float * );
    D3DXCOLOR( const D3DCOLORVALUE& );
    D3DXCOLOR( float r, float g, float b, float a );

    // casting
    operator DWORD () const;

    operator float* ();
    operator const float* () const;

    operator D3DCOLORVALUE* ();
    operator const D3DCOLORVALUE* () const;

    operator D3DCOLORVALUE& ();
    operator const D3DCOLORVALUE& () const;

    // assignment operators
    D3DXCOLOR& operator += ( const D3DXCOLOR& );
    D3DXCOLOR& operator -= ( const D3DXCOLOR& );
    D3DXCOLOR& operator *= ( float );
    D3DXCOLOR& operator /= ( float );

    // unary operators
    D3DXCOLOR operator + () const;
    D3DXCOLOR operator - () const;

    // binary operators
    D3DXCOLOR operator + ( const D3DXCOLOR& ) const;
    D3DXCOLOR operator - ( const D3DXCOLOR& ) const;
    D3DXCOLOR operator * ( float ) const;
    D3DXCOLOR operator / ( float ) const;

    friend D3DXCOLOR operator * (float, const D3DXCOLOR& );

    BOOL operator == ( const D3DXCOLOR& ) const;
    BOOL operator != ( const D3DXCOLOR& ) const;

#endif //__cplusplus
    FLOAT r, g, b, a;
} D3DXCOLOR, *LPD3DXCOLOR;



//===========================================================================
//
// D3DX math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

float D3DXVec2Length
    ( const D3DXVECTOR2 *pV );

float D3DXVec2LengthSq
    ( const D3DXVECTOR2 *pV );

float D3DXVec2Dot
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
float D3DXVec2CCW
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, float s );

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR2* WINAPI D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR2* WINAPI D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g);

// Transform (x, y, 0, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

float D3DXVec3Length
    ( const D3DXVECTOR3 *pV );

float D3DXVec3LengthSq
    ( const D3DXVECTOR3 *pV );

float D3DXVec3Dot
    ( const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, float s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR3* WINAPI D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR3* WINAPI D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g);

// Transform (x, y, z, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Transform (x, y, z, 0) by matrix.
D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

float D3DXVec4Length
    ( const D3DXVECTOR4 *pV );

float D3DXVec4LengthSq
    ( const D3DXVECTOR4 *pV );

float D3DXVec4Dot
    ( const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2 );

D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, float s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
D3DXVECTOR4* WINAPI D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3);

D3DXVECTOR4* WINAPI D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR4* WINAPI D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g);

// Transform vector by matrix.
D3DXVECTOR4* WINAPI D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut );

BOOL D3DXMatrixIsIdentity
    ( const D3DXMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

float WINAPI D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2 
// followed by the transformation M1.  (Out = M1 * M2)
D3DXMATRIX* WINAPI D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 );

D3DXMATRIX* WINAPI D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
D3DXMATRIX* WINAPI D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
D3DXMATRIX* WINAPI D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz );

// Build a matrix which translates by (x, y, z)
D3DXMATRIX* WINAPI D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z );

// Build a matrix which rotates around the X axis
D3DXMATRIX* WINAPI D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around the Y axis
D3DXMATRIX* WINAPI D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around the Z axis
D3DXMATRIX* WINAPI D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around an arbitrary axis
D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle );

// Build a matrix from a quaternion
D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll );


// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter,
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter,
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAt
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspective
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFov
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenter
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrtho
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenter
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
D3DXMATRIX* WINAPI D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
D3DXMATRIX* WINAPI D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

float D3DXQuaternionLength
    ( const D3DXQUATERNION *pQ );

// Length squared, or "norm"
float D3DXQuaternionLengthSq
    ( const D3DXQUATERNION *pQ );

float D3DXQuaternionDot
    ( const D3DXQUATERNION *pQ1, const D3DXQUATERNION *pQ2 );

// (0, 0, 0, 1)
D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut );

BOOL D3DXQuaternionIsIdentity
    ( const D3DXQUATERNION *pQ );

// (-x, -y, -z, w)
D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle );

// Build a quaternion from a rotation matrix.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM);

// Rotation about arbitrary axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll );

// Quaternion multiplication.  The result represents the rotation Q2 
// followed by the rotation Q1.  (Out = Q2 * Q1)
D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 );

D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Conjugate and re-norm
D3DXQUATERNION* WINAPI D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
D3DXQUATERNION* WINAPI D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
D3DXQUATERNION* WINAPI D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
D3DXQUATERNION* WINAPI D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
float D3DXPlaneDot
    ( const D3DXPLANE *pP, const D3DXVECTOR4 *pV);

// ax + by + cz + d
float D3DXPlaneDotCoord
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV);

// ax + by + cz
float D3DXPlaneDotNormal
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
D3DXPLANE* WINAPI D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2);

// Construct a plane from a point and a normal
D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal);

// Construct a plane from 3 points
D3DXPLANE* WINAPI D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
D3DXPLANE* WINAPI D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC);

D3DXCOLOR* D3DXColorAdd
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorSubtract
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorScale
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
D3DXCOLOR* D3DXColorModulate
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
D3DXCOLOR* D3DXColorLerp
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2, float s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
D3DXCOLOR* WINAPI D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c);

#ifdef __cplusplus
}
#endif






//===========================================================================
//
//    Matrix Stack
//
//===========================================================================

DECLARE_INTERFACE_(ID3DXMatrixStack, IUnknown)
{
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // ID3DXMatrixStack methods
    //

    // Pops the top of the stack, returns the current top
    // *after* popping the top.
    STDMETHOD(Pop)(THIS) PURE;

    // Pushes the stack by one, duplicating the current matrix.
    STDMETHOD(Push)(THIS) PURE;

    // Loads identity in the current matrix.
    STDMETHOD(LoadIdentity)(THIS) PURE;

    // Loads the given matrix into the current matrix
    STDMETHOD(LoadMatrix)(THIS_ const D3DXMATRIX* pM ) PURE;

    // Right-Multiplies the given matrix to the current matrix.
    // (transformation is about the current world origin)
    STDMETHOD(MultMatrix)(THIS_ const D3DXMATRIX* pM ) PURE;

    // Left-Multiplies the given matrix to the current matrix
    // (transformation is about the local origin of the object)
    STDMETHOD(MultMatrixLocal)(THIS_ const D3DXMATRIX* pM ) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the current world origin)
    STDMETHOD(RotateAxis)
        (THIS_ const D3DXVECTOR3* pV, float angle) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the local origin of the object)
    STDMETHOD(RotateAxisLocal)
        (THIS_ const D3DXVECTOR3* pV, float angle) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // current world origin)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRoll)
        (THIS_ float yaw, float pitch, float roll) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // local origin of the object)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRollLocal)
        (THIS_ float yaw, float pitch, float roll) PURE;

    // Right multiply the current matrix with the computed scale
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Scale)(THIS_ float x, float y, float z) PURE;

    // Left multiply the current matrix with the computed scale
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(ScaleLocal)(THIS_ float x, float y, float z) PURE;

    // Right multiply the current matrix with the computed translation
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Translate)(THIS_ float x, float y, float z ) PURE;

    // Left multiply the current matrix with the computed translation
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(TranslateLocal)(THIS_ float x, float y, float z) PURE;

    // Obtain the current matrix at the top of the stack
    STDMETHOD_(D3DXMATRIX*, GetTop)(THIS) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI D3DXCreateMatrixStack( DWORD flags, LPD3DXMATRIXSTACK *ppStack );

#ifdef __cplusplus
}
#endif

#include "d3dxmath.inl"

#pragma warning(default:4201)

#endif // __D3DXMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dxerr.h ===
//----------------------------------------------------------------------
//                                                                      
//   d3dxerr.h --  0xC code definitions for the D3DX API                
//                                                                      
//   Copyright (c) 1991-1999, Microsoft Corp. All rights reserved.      
//                                                                      
//----------------------------------------------------------------------
#ifndef __D3DXERR_H__
#define __D3DXERR_H__

// 
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_D3DX    0x877



//
// MessageId: D3DXERR_NOMEMORY
//
// MessageText:
//
//  Out of memory.
// 
#define D3DXERR_NOMEMORY    ((HRESULT)0xC8770BB8L)


//
// MessageId: D3DXERR_NULLPOINTER
//
// MessageText:
//
//  A NULL pointer was passed as a parameter.
// 
#define D3DXERR_NULLPOINTER    ((HRESULT)0xC8770BB9L)


//
// MessageId: D3DXERR_INVALIDD3DXDEVICEINDEX
//
// MessageText:
//
//  The Device Index passed in is invalid.
// 
#define D3DXERR_INVALIDD3DXDEVICEINDEX    ((HRESULT)0xC8770BBAL)


//
// MessageId: D3DXERR_NODIRECTDRAWAVAILABLE
//
// MessageText:
//
//  DirectDraw has not been created.
// 
#define D3DXERR_NODIRECTDRAWAVAILABLE    ((HRESULT)0xC8770BBBL)


//
// MessageId: D3DXERR_NODIRECT3DAVAILABLE
//
// MessageText:
//
//  Direct3D has not been created.
// 
#define D3DXERR_NODIRECT3DAVAILABLE    ((HRESULT)0xC8770BBCL)


//
// MessageId: D3DXERR_NODIRECT3DDEVICEAVAILABLE
//
// MessageText:
//
//  Direct3D device has not been created.
// 
#define D3DXERR_NODIRECT3DDEVICEAVAILABLE    ((HRESULT)0xC8770BBDL)


//
// MessageId: D3DXERR_NOPRIMARYAVAILABLE
//
// MessageText:
//
//  Primary surface has not been created.
// 
#define D3DXERR_NOPRIMARYAVAILABLE    ((HRESULT)0xC8770BBEL)


//
// MessageId: D3DXERR_NOZBUFFERAVAILABLE
//
// MessageText:
//
//  Z buffer has not been created.
// 
#define D3DXERR_NOZBUFFERAVAILABLE    ((HRESULT)0xC8770BBFL)


//
// MessageId: D3DXERR_NOBACKBUFFERAVAILABLE
//
// MessageText:
//
//  Backbuffer has not been created.
// 
#define D3DXERR_NOBACKBUFFERAVAILABLE    ((HRESULT)0xC8770BC0L)


//
// MessageId: D3DXERR_COULDNTUPDATECAPS
//
// MessageText:
//
//  Failed to update caps database after changing display mode.
// 
#define D3DXERR_COULDNTUPDATECAPS    ((HRESULT)0xC8770BC1L)


//
// MessageId: D3DXERR_NOZBUFFER
//
// MessageText:
//
//  Could not create Z buffer.
// 
#define D3DXERR_NOZBUFFER    ((HRESULT)0xC8770BC2L)


//
// MessageId: D3DXERR_INVALIDMODE
//
// MessageText:
//
//  Display mode is not valid.
// 
#define D3DXERR_INVALIDMODE    ((HRESULT)0xC8770BC3L)


//
// MessageId: D3DXERR_INVALIDPARAMETER
//
// MessageText:
//
//  One or more of the parameters passed is invalid.
// 
#define D3DXERR_INVALIDPARAMETER    ((HRESULT)0xC8770BC4L)


//
// MessageId: D3DXERR_INITFAILED
//
// MessageText:
//
//  D3DX failed to initialize itself.
// 
#define D3DXERR_INITFAILED    ((HRESULT)0xC8770BC5L)


//
// MessageId: D3DXERR_STARTUPFAILED
//
// MessageText:
//
//  D3DX failed to start up.
// 
#define D3DXERR_STARTUPFAILED    ((HRESULT)0xC8770BC6L)


//
// MessageId: D3DXERR_D3DXNOTSTARTEDYET
//
// MessageText:
//
//  D3DXInitialize() must be called first.
// 
#define D3DXERR_D3DXNOTSTARTEDYET    ((HRESULT)0xC8770BC7L)


//
// MessageId: D3DXERR_NOTINITIALIZED
//
// MessageText:
//
//  D3DX is not initialized yet.
// 
#define D3DXERR_NOTINITIALIZED    ((HRESULT)0xC8770BC8L)


//
// MessageId: D3DXERR_FAILEDDRAWTEXT
//
// MessageText:
//
//  Failed to render text to the surface.
// 
#define D3DXERR_FAILEDDRAWTEXT    ((HRESULT)0xC8770BC9L)


//
// MessageId: D3DXERR_BADD3DXCONTEXT
//
// MessageText:
//
//  Bad D3DX context.
// 
#define D3DXERR_BADD3DXCONTEXT    ((HRESULT)0xC8770BCAL)


//
// MessageId: D3DXERR_CAPSNOTSUPPORTED
//
// MessageText:
//
//  The requested device capabilities are not supported.
// 
#define D3DXERR_CAPSNOTSUPPORTED    ((HRESULT)0xC8770BCBL)


//
// MessageId: D3DXERR_UNSUPPORTEDFILEFORMAT
//
// MessageText:
//
//  The image file format is unrecognized.
// 
#define D3DXERR_UNSUPPORTEDFILEFORMAT    ((HRESULT)0xC8770BCCL)


//
// MessageId: D3DXERR_IFLERROR
//
// MessageText:
//
//  The image file loading library error.
// 
#define D3DXERR_IFLERROR    ((HRESULT)0xC8770BCDL)


//
// MessageId: D3DXERR_FAILEDGETCAPS
//
// MessageText:
//
//  Could not obtain device caps.
// 
#define D3DXERR_FAILEDGETCAPS    ((HRESULT)0xC8770BCEL)


//
// MessageId: D3DXERR_CANNOTRESIZEFULLSCREEN
//
// MessageText:
//
//  Resize does not work for full-screen.
// 
#define D3DXERR_CANNOTRESIZEFULLSCREEN    ((HRESULT)0xC8770BCFL)


//
// MessageId: D3DXERR_CANNOTRESIZENONWINDOWED
//
// MessageText:
//
//  Resize does not work for non-windowed contexts.
// 
#define D3DXERR_CANNOTRESIZENONWINDOWED    ((HRESULT)0xC8770BD0L)


//
// MessageId: D3DXERR_FRONTBUFFERALREADYEXISTS
//
// MessageText:
//
//  Front buffer already exists.
// 
#define D3DXERR_FRONTBUFFERALREADYEXISTS    ((HRESULT)0xC8770BD1L)


//
// MessageId: D3DXERR_FULLSCREENPRIMARYEXISTS
//
// MessageText:
//
//  The app is using the primary in full-screen mode.
// 
#define D3DXERR_FULLSCREENPRIMARYEXISTS    ((HRESULT)0xC8770BD2L)


//
// MessageId: D3DXERR_GETDCFAILED
//
// MessageText:
//
//  Could not get device context.
// 
#define D3DXERR_GETDCFAILED    ((HRESULT)0xC8770BD3L)


//
// MessageId: D3DXERR_BITBLTFAILED
//
// MessageText:
//
//  Could not bitBlt.
// 
#define D3DXERR_BITBLTFAILED    ((HRESULT)0xC8770BD4L)


//
// MessageId: D3DXERR_NOTEXTURE
//
// MessageText:
//
//  There is no surface backing up this texture.
// 
#define D3DXERR_NOTEXTURE    ((HRESULT)0xC8770BD5L)


//
// MessageId: D3DXERR_MIPLEVELABSENT
//
// MessageText:
//
//  There is no such miplevel for this surface.
// 
#define D3DXERR_MIPLEVELABSENT    ((HRESULT)0xC8770BD6L)


//
// MessageId: D3DXERR_SURFACENOTPALETTED
//
// MessageText:
//
//  The surface is not paletted.
// 
#define D3DXERR_SURFACENOTPALETTED    ((HRESULT)0xC8770BD7L)


//
// MessageId: D3DXERR_ENUMFORMATSFAILED
//
// MessageText:
//
//  An error occured while enumerating surface formats.
// 
#define D3DXERR_ENUMFORMATSFAILED    ((HRESULT)0xC8770BD8L)


//
// MessageId: D3DXERR_COLORDEPTHTOOLOW
//
// MessageText:
//
//  D3DX only supports color depths of 16 bit or greater.
// 
#define D3DXERR_COLORDEPTHTOOLOW    ((HRESULT)0xC8770BD9L)


//
// MessageId: D3DXERR_INVALIDFILEFORMAT
//
// MessageText:
//
//  The file format is invalid.
// 
#define D3DXERR_INVALIDFILEFORMAT    ((HRESULT)0xC8770BDAL)


//
// MessageId: D3DXERR_NOMATCHFOUND
//
// MessageText:
//
//  No suitable match found.
// 
#define D3DXERR_NOMATCHFOUND    ((HRESULT)0xC8770BDBL)



#endif //__D3DXERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx8mesh.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8mesh.h
//  Content:    D3DX mesh types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8MESH_H__
#define __D3DX8MESH_H__

#include "dxfile.h"     // defines LPDIRECTXFILEDATA

// {A69BA991-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXBaseMesh,
0xa69ba991, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {9D84AC46-6B90-49a9-A721-085C7A3E3DAE}
DEFINE_GUID(IID_ID3DXMesh, 
0x9d84ac46, 0x6b90, 0x49a9, 0xa7, 0x21, 0x8, 0x5c, 0x7a, 0x3e, 0x3d, 0xae);

// {15981AA8-1A05-48e3-BBE7-FF5D49654E3F}
DEFINE_GUID(IID_ID3DXPMesh, 
0x15981aa8, 0x1a05, 0x48e3, 0xbb, 0xe7, 0xff, 0x5d, 0x49, 0x65, 0x4e, 0x3f);

// {BC3BBDE2-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXSPMesh, 
0xbc3bbde2, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {82A53844-F322-409e-A2E9-992E1104069D}
DEFINE_GUID(IID_ID3DXSkinMesh, 
0x82a53844, 0xf322, 0x409e, 0xa2, 0xe9, 0x99, 0x2e, 0x11, 0x4, 0x6, 0x9d);


enum _D3DXMESH {
	D3DXMESH_32BIT			        = 0x001, // If set, then use 32 bit indices, if not set use 16 bit indices. 32BIT meshes currently not supported on ID3DXSkinMesh object
    D3DXMESH_DONOTCLIP              = 0x002, // Use D3DUSAGE_DONOTCLIP for VB & IB.
    D3DXMESH_POINTS                 = 0x004, // Use D3DUSAGE_POINTS for VB & IB. 
    D3DXMESH_RTPATCHES              = 0x008, // Use D3DUSAGE_RTPATCHES for VB & IB. 
	D3DXMESH_NPATCHES				= 0x4000,// Use D3DUSAGE_NPATCHES for VB & IB. 
	D3DXMESH_VB_SYSTEMMEM		    = 0x010, // Use D3DPOOL_SYSTEMMEM for VB. Overrides D3DXMESH_MANAGEDVERTEXBUFFER
    D3DXMESH_VB_MANAGED             = 0x020, // Use D3DPOOL_MANAGED for VB. 
    D3DXMESH_VB_WRITEONLY           = 0x040, // Use D3DUSAGE_WRITEONLY for VB.
    D3DXMESH_VB_DYNAMIC             = 0x080, // Use D3DUSAGE_DYNAMIC for VB.
	D3DXMESH_IB_SYSTEMMEM			= 0x100, // Use D3DPOOL_SYSTEMMEM for IB. Overrides D3DXMESH_MANAGEDINDEXBUFFER
    D3DXMESH_IB_MANAGED             = 0x200, // Use D3DPOOL_MANAGED for IB.
    D3DXMESH_IB_WRITEONLY           = 0x400, // Use D3DUSAGE_WRITEONLY for IB.
    D3DXMESH_IB_DYNAMIC             = 0x800, // Use D3DUSAGE_DYNAMIC for IB.

    D3DXMESH_VB_SHARE               = 0x1000, // Valid for Clone* calls only, forces cloned mesh/pmesh to share vertex buffer

    D3DXMESH_USEHWONLY              = 0x2000, // Valid for ID3DXSkinMesh::ConvertToBlendedMesh

    // Helper options
    D3DXMESH_SYSTEMMEM				= 0x110, // D3DXMESH_VB_SYSTEMMEM | D3DXMESH_IB_SYSTEMMEM
    D3DXMESH_MANAGED                = 0x220, // D3DXMESH_VB_MANAGED | D3DXMESH_IB_MANAGED
    D3DXMESH_WRITEONLY              = 0x440, // D3DXMESH_VB_WRITEONLY | D3DXMESH_IB_WRITEONLY
    D3DXMESH_DYNAMIC                = 0x880, // D3DXMESH_VB_DYNAMIC | D3DXMESH_IB_DYNAMIC

};

// option field values for specifying min value in D3DXGeneratePMesh and D3DXSimplifyMesh
enum _D3DXMESHSIMP
{
    D3DXMESHSIMP_VERTEX   = 0x1,
    D3DXMESHSIMP_FACE     = 0x2,

};

enum _MAX_FVF_DECL_SIZE
{
	MAX_FVF_DECL_SIZE = 20
};

typedef struct ID3DXBaseMesh *LPD3DXBASEMESH;
typedef struct ID3DXMesh *LPD3DXMESH;
typedef struct ID3DXPMesh *LPD3DXPMESH;
typedef struct ID3DXSPMesh *LPD3DXSPMESH;
typedef struct ID3DXSkinMesh *LPD3DXSKINMESH;

typedef struct _D3DXATTRIBUTERANGE
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
} D3DXATTRIBUTERANGE;

typedef D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE;

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
struct D3DXMATERIAL
{
    D3DMATERIAL8  MatD3D;
    LPSTR         pTextureFilename;
};
typedef struct D3DXMATERIAL *LPD3DXMATERIAL;
#ifdef __cplusplus
}
#endif //__cplusplus

typedef struct _D3DXATTRIBUTEWEIGHTS
{
    FLOAT Position;
    FLOAT Boundary;
    FLOAT Normal;
    FLOAT Diffuse;
    FLOAT Specular;
    FLOAT Tex[8];
} D3DXATTRIBUTEWEIGHTS;

typedef D3DXATTRIBUTEWEIGHTS* LPD3DXATTRIBUTEWEIGHTS;

DECLARE_INTERFACE_(ID3DXBaseMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options, 
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
	STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
	STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
	STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
	STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;
};

DECLARE_INTERFACE_(ID3DXMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options, 
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
	STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
	STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
	STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
	STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXMesh
	STDMETHOD(LockAttributeBuffer)(THIS_ DWORD Flags, DWORD** ppData) PURE;
	STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;
    STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;
    STDMETHOD(GenerateAdjacency)(THIS_ FLOAT fEpsilon, DWORD* pAdjacency) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, 
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,  
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(OptimizeInplace)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, 
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap) PURE;
};

DECLARE_INTERFACE_(ID3DXPMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options, 
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
	STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
	STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
	STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
	STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXPMesh
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options, 
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(SetNumFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(SetNumVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinVertices)(THIS) PURE;
    STDMETHOD(Save)(THIS_ IStream *pStream, LPD3DXMATERIAL pMaterials, DWORD NumMaterials) PURE;

    STDMETHOD(Optimize)(THIS_ DWORD Flags, DWORD* pAdjacencyOut, 
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,  
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(GetAdjacency)(THIS_ DWORD* pAdjacency) PURE;
};

DECLARE_INTERFACE_(ID3DXSPMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSPMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options, 
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options, 
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ReduceFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(ReduceVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
};

#define UNUSED16 (0xffff)
#define UNUSED32 (0xffffffff)

// ID3DXMesh::Optimize options
enum _D3DXMESHOPT {
	D3DXMESHOPT_COMPACT       = 0x001,
	D3DXMESHOPT_ATTRSORT      = 0x002,
	D3DXMESHOPT_VERTEXCACHE   = 0x004,
	D3DXMESHOPT_STRIPREORDER  = 0x008,
    D3DXMESHOPT_IGNOREVERTS   = 0x010,  // optimize faces only, don't touch vertices
    D3DXMESHOPT_SHAREVB       = 0x020,
};

// Subset of the mesh that has the same attribute and bone combination.
// This subset can be rendered in a single draw call
typedef struct _D3DXBONECOMBINATION
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
	DWORD* BoneId;
} D3DXBONECOMBINATION, *LPD3DXBONECOMBINATION;

DECLARE_INTERFACE_(ID3DXSkinMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

	// ID3DXMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
	STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
	STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
	STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
	STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
	STDMETHOD(LockAttributeBuffer)(THIS_ DWORD flags, DWORD** ppData) PURE;
	STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    // ID3DXSkinMesh
    STDMETHOD_(DWORD, GetNumBones)(THIS) PURE;
    STDMETHOD(GetOriginalMesh)(THIS_ LPD3DXMESH* ppMesh) PURE;
	STDMETHOD(SetBoneInfluence)(THIS_ DWORD bone, DWORD numInfluences, CONST DWORD* vertices, CONST FLOAT* weights) PURE;
	STDMETHOD_(DWORD, GetNumBoneInfluences)(THIS_ DWORD bone) PURE;
	STDMETHOD(GetBoneInfluence)(THIS_ DWORD bone, DWORD* vertices, FLOAT* weights) PURE;
	STDMETHOD(GetMaxVertexInfluences)(THIS_ DWORD* maxVertexInfluences) PURE;
	STDMETHOD(GetMaxFaceInfluences)(THIS_ DWORD* maxFaceInfluences) PURE;
	STDMETHOD(ConvertToBlendedMesh)(THIS_ DWORD options, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut,
							DWORD* pNumBoneCombinations, LPD3DXBUFFER* ppBoneCombinationTable, LPD3DXMESH* ppMesh) PURE;
	STDMETHOD(ConvertToIndexedBlendedMesh)(THIS_ DWORD options, 
                                           CONST LPDWORD pAdjacencyIn, 
                                           DWORD paletteSize, 
                                           LPDWORD pAdjacencyOut, 
 							               DWORD* pNumBoneCombinations, 
                                           LPD3DXBUFFER* ppBoneCombinationTable, 
                                           LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(GenerateSkinnedMesh)(THIS_ DWORD options, FLOAT minWeight, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut, LPD3DXMESH* ppMesh) PURE;
	STDMETHOD(UpdateSkinnedMesh)(THIS_ CONST D3DXMATRIX* pBoneTransforms, LPD3DXMESH pMesh) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI 
    D3DXCreateMesh(
        DWORD NumFaces, 
        DWORD NumVertices, 
        DWORD Options, 
        CONST DWORD *pDeclaration, 
        LPDIRECT3DDEVICE8 pD3D, 
        LPD3DXMESH* ppMesh);

HRESULT WINAPI 
    D3DXCreateMeshFVF(
        DWORD NumFaces, 
        DWORD NumVertices, 
        DWORD Options, 
        DWORD FVF, 
        LPDIRECT3DDEVICE8 pD3D, 
        LPD3DXMESH* ppMesh);

HRESULT WINAPI 
    D3DXCreateSPMesh(
        LPD3DXMESH pMesh, 
        CONST DWORD* pAdjacency, 
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        LPD3DXSPMESH* ppSMesh);

// clean a mesh up for simplification, try to make manifold
HRESULT WINAPI
    D3DXCleanMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency,
    LPD3DXMESH* ppMeshOut);

HRESULT WINAPI
    D3DXValidMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency);

HRESULT WINAPI 
    D3DXGeneratePMesh(
        LPD3DXMESH pMesh, 
        CONST DWORD* pAdjacency, 
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue, 
        DWORD Options, 
        LPD3DXPMESH* ppPMesh);

HRESULT WINAPI 
    D3DXSimplifyMesh(
        LPD3DXMESH pMesh, 
        CONST DWORD* pAdjacency, 
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue, 
        DWORD Options, 
        LPD3DXMESH* ppMesh);

HRESULT WINAPI 
    D3DXComputeBoundingSphere(
        PVOID pPointsFVF, 
        DWORD NumVertices, 
        DWORD FVF,
        D3DXVECTOR3 *pCenter, 
        FLOAT *pRadius);

HRESULT WINAPI 
    D3DXComputeBoundingBox(
        PVOID pPointsFVF, 
        DWORD NumVertices, 
        DWORD FVF,
        D3DXVECTOR3 *pMin, 
        D3DXVECTOR3 *pMax);

HRESULT WINAPI 
    D3DXComputeNormals(
        LPD3DXBASEMESH pMesh);

HRESULT WINAPI 
    D3DXCreateBuffer(
        DWORD NumBytes, 
        LPD3DXBUFFER *ppBuffer);


HRESULT WINAPI
    D3DXLoadMeshFromX(
        LPSTR pFilename, 
        DWORD Options, 
        LPDIRECT3DDEVICE8 pD3D, 
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials, 
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI 
    D3DXSaveMeshToX(
        LPSTR pFilename,
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXMATERIAL pMaterials,
        DWORD NumMaterials,
        DWORD Format
        );

HRESULT WINAPI 
    D3DXCreatePMeshFromStream(
        IStream *pStream, 
	DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice, 
        LPD3DXBUFFER *ppMaterials,
        DWORD* pNumMaterials,
        LPD3DXPMESH *ppPMesh);

HRESULT WINAPI
    D3DXCreateSkinMesh(
        DWORD numFaces, 
        DWORD numVertices, 
        DWORD numBones,
        DWORD options, 
        CONST DWORD *pDeclaration, 
        LPDIRECT3DDEVICE8 pD3D, 
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFVF(
        DWORD numFaces, 
        DWORD numVertices, 
        DWORD numBones,
        DWORD options, 
        DWORD fvf, 
        LPDIRECT3DDEVICE8 pD3D, 
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFromMesh(
        LPD3DXMESH pMesh,
        DWORD numBones,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI 
    D3DXLoadMeshFromXof(
        LPDIRECTXFILEDATA pXofObjMesh, 
        DWORD Options, 
        LPDIRECT3DDEVICE8 pD3DDevice, 
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials, 
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXLoadSkinMeshFromXof(
        LPDIRECTXFILEDATA pxofobjMesh, 
        DWORD options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER* ppAdjacency,
        LPD3DXBUFFER* ppMaterials,
        PDWORD pMatOut,
        LPD3DXBUFFER* ppBoneNames,
        LPD3DXBUFFER* ppBoneTransforms,
        LPD3DXSKINMESH* ppMesh);

HRESULT WINAPI
    D3DXTesselateMesh(
        LPD3DXMESH pMeshIn,             
        CONST DWORD* pAdjacency,             
        FLOAT NumSegs,                    
        BOOL  QuadraticInterpNormals,     // if false use linear intrep for normals, if true use quadratic
        LPD3DXMESH *ppMeshOut);         

HRESULT WINAPI
    D3DXDeclaratorFromFVF(
        DWORD FVF,
		DWORD Declaration[MAX_FVF_DECL_SIZE]);

HRESULT WINAPI
    D3DXFVFFromDeclarator(
        CONST DWORD *pDeclarator,
        DWORD *pFVF);

HRESULT WINAPI 
    D3DXWeldVertices(
        CONST LPD3DXMESH pMesh,         
        float fEpsilon,                 
        CONST DWORD *rgdwAdjacencyIn, 
        DWORD *rgdwAdjacencyOut,
        DWORD* pFaceRemap, 
        LPD3DXBUFFER *ppbufVertexRemap);

HRESULT WINAPI
    D3DXIntersect(
        LPD3DXBASEMESH pMesh,
        CONST D3DXVECTOR3 *pRayPos,
        CONST D3DXVECTOR3 *pRayDir,
        BOOL    *pHit,
        DWORD   *pFaceIndex,
        FLOAT   *pU,
        FLOAT   *pV,
        FLOAT   *pDist);

BOOL WINAPI
    D3DXSphereBoundProbe(
        CONST D3DXVECTOR3 *pvCenter,
        FLOAT fRadius,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

BOOL WINAPI 
    D3DXBoxBoundProbe(
        CONST D3DXVECTOR3 *pvMin, 
        CONST D3DXVECTOR3 *pvMax,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

enum _D3DXERR {
    D3DXERR_CANNOTMODIFYINDEXBUFFER		= MAKE_DDHRESULT(2900),
	D3DXERR_INVALIDMESH					= MAKE_DDHRESULT(2901),
	D3DXERR_CANNOTATTRSORT              = MAKE_DDHRESULT(2902),
	D3DXERR_SKINNINGNOTSUPPORTED		= MAKE_DDHRESULT(2903),
	D3DXERR_TOOMANYINFLUENCES			= MAKE_DDHRESULT(2904),
    D3DXERR_INVALIDDATA                 = MAKE_DDHRESULT(2905),
};

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8MESH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dxcore.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxcore.h
//  Content:    D3DX core types and functions
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXCORE_H__
#define __D3DXCORE_H__

#include <d3d.h>
#include <limits.h>
#include "d3dxerr.h"


typedef struct ID3DXContext *LPD3DXCONTEXT;

// {9B74ED7A-BBEF-11d2-9F8E-0000F8080835}
DEFINE_GUID(IID_ID3DXContext, 
     0x9b74ed7a, 0xbbef, 0x11d2, 0x9f, 0x8e, 0x0, 0x0, 0xf8, 0x8, 0x8, 0x35);


///////////////////////////////////////////////////////////////////////////
// Defines and Enumerators used below:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// D3DX_DEFAULT:
// ---------
// A predefined value that could be used for any parameter in D3DX APIs or 
// member functions that is an enumerant or a handle.  The D3DX 
// documentation indicates wherever D3DX_DEFAULT may be used, 
// and how it will be interpreted in each situation.
//-------------------------------------------------------------------------
#define D3DX_DEFAULT ULONG_MAX
                            
//-------------------------------------------------------------------------
// D3DX_DEFAULT_FLOAT:
// ------------------
// Similar to D3DX_DEFAULT, but used for floating point parameters.
// The D3DX documentation indicates wherever D3DX_DEFAULT_FLOAT may be used, 
// and how it will be interpreted in each situation.
//-------------------------------------------------------------------------
#define D3DX_DEFAULT_FLOAT FLT_MAX
                            
//-------------------------------------------------------------------------
// Hardware Acceleration Level:
// ---------------------------
// These constants represent pre-defined hardware acceleration levels,
// and may be used as a default anywhere a (DWORD) deviceIndex is required.
// Each pre-define indicates a different level of hardware acceleration.
// They are an alternative to using explicit deviceIndices retrieved by
// D3DXGetDeviceDescription().
//
// The only case these pre-defines should be used as device indices is if
// a particular level of acceleration is required, and given more than 
// one capable device on the computer, it does not matter which one
// is used.
//
// The method of selection is as follows: If one of the D3DX devices on 
// the primary DDraw device supports a requested hardware acceleration 
// level, it will be used. Otherwise, the first matching device discovered 
// by D3DX will be used.  
//
// Of course, it is possible for no match to exist for any of the
// pre-defines on a particular computer.  Passing such a value into the
// D3DX apis will simply cause them to fail, reporting that no match
// is available.
// 
// D3DX_HWLEVEL_NULL:      Null implementation (draws nothing)
// D3DX_HWLEVEL_REFERENCE: Reference implementation (slowest)
// D3DX_HWLEVEL_2D:        2D acceleration only (RGB rasterizer used)
// D3DX_HWLEVEL_RASTER:    Rasterization acceleration (likely most useful)
// D3DX_HWLEVEL_TL:        Transform and lighting acceleration 
// D3DX_DEFAULT:           The highest level of acceleration available
//                         on the primary DDraw device.
//-------------------------------------------------------------------------
#define D3DX_HWLEVEL_NULL       (D3DX_DEFAULT - 1)
#define D3DX_HWLEVEL_REFERENCE  (D3DX_DEFAULT - 2)
#define D3DX_HWLEVEL_2D         (D3DX_DEFAULT - 3) 
#define D3DX_HWLEVEL_RASTER     (D3DX_DEFAULT - 4) 
#define D3DX_HWLEVEL_TL         (D3DX_DEFAULT - 5) 

//-------------------------------------------------------------------------
// Surface Class:
// -------------
// These are the various types of 2D-surfaces classified according to their
// usage. Note that a number of them overlap. e.g. STENCILBUFFERS and 
// DEPTHBUFFERS overlap (since in DX7 implementation the stencil and depth
// bits are part of the same pixel format).
//
// Mapping to the DX7 DDPIXELFORMAT concepts:
// -----------------------------------------
// D3DX_SC_DEPTHBUFFER:    All ddpfs which have the DDPF_ZPIXELS or the
//                           DDPF_ZBUFFER flags set.
// D3DX_SC_STENCILBUFFER:  All ddpfs which have the DDPF_STENCILBUFFER 
//                          flag set.
// D3DX_SC_BUMPMAP:        All ddpfs which have the DDPF_BUMPLUMINANCE 
//                           or the DDPF_BUMPDUDV flags set.
// D3DX_SC_LUMINANCEMAP:   All ddpfs which have the DDPF_BUMPLUMINANCE
//                           or the DDPF_LUMINANCE flags set.
// D3DX_SC_COLORTEXTURE:   All the surfaces that have color information in
//                           them and can be used for texturing.
// D3DX_SC_COLORRENDERTGT: All the surfaces that contain color 
//                           information and can be used as render targets.
//-------------------------------------------------------------------------
#define D3DX_SC_DEPTHBUFFER     0x01
#define D3DX_SC_STENCILBUFFER   0x02
#define D3DX_SC_COLORTEXTURE    0x04
#define D3DX_SC_BUMPMAP         0x08
#define D3DX_SC_LUMINANCEMAP    0x10
#define D3DX_SC_COLORRENDERTGT  0x20

//-------------------------------------------------------------------------
// Surface Formats:
// ---------------
// These are the various types of surface formats that can be enumerated, 
// there is no DDPIXELFORMAT structure in D3DX, the enums carry the meaning 
// (like FOURCCs).
//
// All the surface classes are represented here.  
//
//-------------------------------------------------------------------------
typedef enum _D3DX_SURFACEFORMAT
{
    D3DX_SF_UNKNOWN    = 0,
    D3DX_SF_R8G8B8     = 1,
    D3DX_SF_A8R8G8B8   = 2,
    D3DX_SF_X8R8G8B8   = 3,
    D3DX_SF_R5G6B5     = 4,
    D3DX_SF_R5G5B5     = 5,
    D3DX_SF_PALETTE4   = 6,
    D3DX_SF_PALETTE8   = 7,
    D3DX_SF_A1R5G5B5   = 8,
    D3DX_SF_X4R4G4B4   = 9,
    D3DX_SF_A4R4G4B4   =10,
    D3DX_SF_L8         =11,      // 8 bit luminance-only
    D3DX_SF_A8L8       =12,      // 16 bit alpha-luminance
    D3DX_SF_U8V8       =13,      // 16 bit bump map format
    D3DX_SF_U5V5L6     =14,      // 16 bit bump map format with luminance
    D3DX_SF_U8V8L8     =15,      // 24 bit bump map format with luminance
    D3DX_SF_UYVY       =16,      // UYVY format (PC98 compliance)
    D3DX_SF_YUY2       =17,      // YUY2 format (PC98 compliance)
    D3DX_SF_DXT1       =18,      // S3 texture compression technique 1
    D3DX_SF_DXT3       =19,      // S3 texture compression technique 3
    D3DX_SF_DXT5       =20,      // S3 texture compression technique 5
    D3DX_SF_R3G3B2     =21,      // 8 bit RGB texture format
    D3DX_SF_A8         =22,      // 8 bit alpha-only
    D3DX_SF_TEXTUREMAX =23,      // Last texture format

    D3DX_SF_Z16S0      =256,
    D3DX_SF_Z32S0      =257,
    D3DX_SF_Z15S1      =258,
    D3DX_SF_Z24S8      =259,
    D3DX_SF_S1Z15      =260,
    D3DX_SF_S8Z24      =261,
    D3DX_SF_DEPTHMAX   =262,     // Last depth format

    D3DX_SF_FORCEMAX  = (DWORD)(-1)
} D3DX_SURFACEFORMAT;

//-------------------------------------------------------------------------
// Filtering types for Texture APIs 
//
// -------------
// These are the various filter types for generation of mip-maps 
//
// D3DX_FILTERTYPE
// -----------------------------------------
// D3DX_FT_POINT:   Point sampling only - no filtering
// D3DX_FT_LINEAR:  Bi-linear filtering
//
//-------------------------------------------------------------------------
typedef enum _D3DX_FILTERTYPE
{
    D3DX_FT_POINT    = 0x01,
    D3DX_FT_LINEAR   = 0x02,
    D3DX_FT_DEFAULT  = D3DX_DEFAULT
} D3DX_FILTERTYPE;

///////////////////////////////////////////////////////////////////////////
// Structures used below:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// D3DX_VIDMODEDESC: Display mode description.
// ----------------
// width:       Screen Width 
// height:      Screen Height
// bpp:         Bits per pixel
// refreshRate: Refresh rate
//-------------------------------------------------------------------------
typedef struct  _D3DX_VIDMODEDESC
{
    DWORD width;
    DWORD height;
    DWORD bpp;
    DWORD refreshRate;
} D3DX_VIDMODEDESC;

//-------------------------------------------------------------------------
// D3DX_DEVICEDESC: Description of a device that can do 3D
// ---------------
// deviceIndex:   Unique (DWORD) number for the device.
// hwLevel:       Level of acceleration afforded.  This is one of the
//                predefined Device Indices, and exists in this
//                structure for informational purposes only.  More than
//                one device on the system may have the same hwLevel.
//                To refer to a particular device with the D3DX apis,
//                use the value in the deviceIndex member instead.
// ddGuid:        The ddraw GUID
// d3dDeviceGuid: Direct3D Device GUID
// ddDeviceID:    DDraw's GetDeviceIdentifier GUID.  This GUID is unique to
//                a particular driver revision on a particular video card.
// driverDesc:    String describing the driver
// monitor:       Handle to the video monitor used by this device (multimon
//                specific).  Devices that use different monitors on a 
//                multimon system report different values in this field.
//                Therefore, to test for a multimon system, an application 
//                should look for more than one different monitor handle in 
//                the list of D3DX devices.
// onPrimary:     Indicates if this device is on the primary monitor
//                (multimon specific).
//-------------------------------------------------------------------------
#define D3DX_DRIVERDESC_LENGTH    256

typedef struct _D3DX_DEVICEDESC
{
    DWORD       deviceIndex;  
    DWORD       hwLevel;
    GUID        ddGuid;       
    GUID        d3dDeviceGuid;   
    GUID        ddDeviceID;      
    char        driverDesc[D3DX_DRIVERDESC_LENGTH];          
    HMONITOR    monitor;
    BOOL        onPrimary;
} D3DX_DEVICEDESC;

///////////////////////////////////////////////////////////////////////////
// APIs:
///////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
    
//-------------------------------------------------------------------------
// D3DXInitialize: The very first call a D3DX app must make.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXInitialize();

//-------------------------------------------------------------------------
// D3DXUninitialize: The very last call a D3DX app must make.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXUninitialize();

//-------------------------------------------------------------------------
// D3DXGetDeviceCount: Returns the maximum number of D3DXdevices 
// ------------------  available.
//
// D3DXGetDeviceDescription: Lists the 2D and 3D capabilities of the devices. 
// ------------------------  Also, the various guids needed by ddraw and d3d.
//
// Params: 
//     [in] DWORD deviceIndex: Which device? Starts at 0.
//     [in] D3DX_DEVICEDESC* pd3dxDevice: Pointer to the D3DX_DEVICEDESC
//                                        structure to be filled in.
//-------------------------------------------------------------------------
DWORD WINAPI 
    D3DXGetDeviceCount();

HRESULT WINAPI
    D3DXGetDeviceDescription(DWORD            deviceIndex, 
                             D3DX_DEVICEDESC* pd3dxDeviceDesc);

//-------------------------------------------------------------------------
// D3DXGetMaxNumVideoModes: Returns the maximum number of video-modes .
// -----------------------  
//
// Params:
//     [in]  DWORD deviceIndex: The device being referred to.
//     [in]  DWORD flags: If D3DX_GVM_REFRESHRATE is set, then the refresh
//                        rates are not ignored.
//
// D3DXGetVideoMode:  Describes a particular video mode for this device
// ----------------
//
// Note:  These queries will simply give you a list of modes that the
//        display adapter tells DirectX that it supports.
//        There is no guarantee that D3DXCreateContext(Ex) will succeed 
//        with all listed video modes.  This is a fundamental limitation 
//        of the current DirectX architecture which D3DX cannot hide in 
//        any clean way.
//
// Params:
//     [in]  DWORD deviceIndex: The device being referred to.
//     [in]  DWORD flags: If D3DX_GVM_REFRESHRATE is set, then the refresh
//                        rates are returned
//     [in]  DWORD which: Which VideoMode ? Starts at 0.
//     [out] D3DX_VIDMODEDESC* pModeList: Pointer to the D3DX_VIDMODEDESC
//                        structure that will be filled in.
//-------------------------------------------------------------------------
DWORD WINAPI 
    D3DXGetMaxNumVideoModes(DWORD       deviceIndex, 
                            DWORD       flags);

HRESULT WINAPI
    D3DXGetVideoMode(DWORD             deviceIndex, 
                     DWORD             flags, 
                     DWORD             modeIndex, 
                     D3DX_VIDMODEDESC* pModeDesc);

#define D3DX_GVM_REFRESHRATE      0x00000001
//-------------------------------------------------------------------------
// D3DXGetMaxSurfaceFormats: Returns the maximum number of surface
// ------------------------  formats supported by the device at that
//                           video mode.
//
// D3DXGetSurfaceFormat: Describes one of the supported surface formats.
// --------------------- 
//
// Params:
//     [in]  DWORD  deviceIndex: The device being referred to.
//     [in]  D3DX_VIDMODEDESC* pDesc: The display mode at which the supported
//                                    surface formats are requested. If it is
//                                    NULL, the current display mode is 
//                                    assumed.
//     [in]  DWORD surfClassFlags: Required surface classes.  Only surface
//                                 formats which support all specified 
//                                 surface classes will be returned.  
//                                 (Multiple surface classes may be specified
//                                 using bitwise OR.) 
//     [in]  DWORD which: Which surface formats to retrieve. Starts at 0.
//     [out] D3DX_SURFACEFORMAT* pFormat: The surface format
//-------------------------------------------------------------------------
DWORD WINAPI 
    D3DXGetMaxSurfaceFormats(DWORD             deviceIndex, 
                             D3DX_VIDMODEDESC* pDesc,
                             DWORD             surfClassFlags);
HRESULT WINAPI
    D3DXGetSurfaceFormat(DWORD               deviceIndex,
                         D3DX_VIDMODEDESC*   pDesc,
                         DWORD               surfClassFlags,                   
                         DWORD               surfaceIndex, 
                         D3DX_SURFACEFORMAT* pFormat);


//-------------------------------------------------------------------------
// D3DXGetCurrentVideoMode: Retrieves the current video mode for this device.
// -------------------
//
// Params:
//     [in]  DWORD deviceIndex: The device being referred to.
//     [out] D3DX_VIDMODEDESC* pVidMode: The current video mode
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXGetCurrentVideoMode(DWORD             deviceIndex, 
                            D3DX_VIDMODEDESC* pVidMode);

//-------------------------------------------------------------------------
// D3DXGetDeviceCaps: Lists all the capabilities of a device at a display 
//                    mode.
// ----------------
//
// Params:
//     [in]  DWORD  deviceIndex: The device being referred to.
//     [in]  D3DX_VIDMODEDESC* pDesc:  If this is NULL, we will return the 
//                                     caps at the current display mode of 
//                                     the device.
//     [out] D3DDEVICEDESC7* pD3DDeviceDesc7: D3D Caps ( NULL to ignore 
//                                              parameter)
//     [out] DDCAPS7* pDDHalCaps: DDraw HAL Caps (NULL to ignore parameter)
//     [out] DDCAPS7* pDDHelCaps: DDraw HEL Caps (NULL to ignore  paramter)
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXGetDeviceCaps(DWORD             deviceIndex, 
                      D3DX_VIDMODEDESC* pVidMode,
                      D3DDEVICEDESC7*   pD3DCaps,
                      DDCAPS*           pDDHALCaps,
                      DDCAPS*           pDDHELCaps);

//-------------------------------------------------------------------------
// D3DXCreateContext: Initializes the chosen device. It is the simplest init
// -----------------  function available.  Parameters are treated the same
//                    as the matching subset of parameters in 
//                    D3DXCreateContextEx, documented below.
//                    Remaining D3DXCreateContextEx parameters that are
//                    not present in D3DXCreateContext are treated as
//                    D3DX_DEFAULT.  Note that multimon is not supported
//                    with D3DXCreateContext.
//
// D3DXCreateContextEx: A more advanced function to initialize the device.
// -------------------  Also accepts D3DX_DEFAULT for most of the parameters
//                      and then will do what D3DXCreateContext did.
//
// Note: Do not expect D3DXCreateContext(Ex) to be fail-safe (as with any
//       API).  Supported device capablilites should be used as a guide
//       for choosing parameter values.  Keep in mind that there will 
//       inevitably be some combinations of parameters that just do not work.
// 
// Params:
//     [in]  DWORD deviceIndex: The device being referred to.   
//     [in]  DWORD flags: The valid flags are D3DX_CONTEXT_FULLSCREEN, and
//                        D3DX_CONTEXT_OFFSCREEN.  These flags cannot both
//                        be specified.  If no flags are specified, the
//                        context defaults to windowed mode.
//
//     [in]  HWND  hwnd: Device window.  See note.
//     [in]  HWND  hwndFocus: Window which receives keyboard messages from 
//                            the device window.  The device window should be 
//                            a child of focus window.  Useful for multimon 
//                            applications.  See note.
//     NOTE: 
//         windowed:   
//             hwnd must be a valid window.  hwndFocus must be NULL or 
//             D3DX_DEFAULT.
//
//         fullscreen: 
//             Either hwnd or hwndFocus must be a valid window.  (Both cannot
//             be NULL or D3DX_DEFAULT).  If hwnd is NULL or D3DX_DEFAULT, 
//             a default device window will be created as a child of hwndFocus.
//
//         offscreen:
//             Both hwnd and hwndFocus must be NULL or D3DX_DEFAULT
//
//     [in]  DWORD numColorBits: If D3DX_DEFAULT is passed for windowed mode,
//                               the current desktop's color depth is chosen.
//                               For full screen mode, D3DX_DEFAULT causes 16
//                               bit color to be used.                               
//     [in]  DWORD numAlphaBits: If D3DX_DEFAULT is passed, 0 is chosen.
//     [in]  DWORD numDepthbits: If D3DX_DEFAULT is passed,
//                               the highest available number of depth bits
//                               is chosen.  See note.
//     [in]  DWORD numStencilBits: If D3DX_DEFAULT is passed, the highest
//                                 available number of stencil bits is chosen.
//                                 See note.
//
//     NOTE: If both numDepthBits and numStencilBits are D3DX_DEFAULT,
//           D3DX first picks the highest available number of stencil
//           bits.  Then, for the chosen number of stencil bits, 
//           the highest available number of depth bits is chosen.
//           If only one of numStencilBits or numDepthBits 
//           is D3DX_DEFAULT, the highest number of bits available 
//           for this parameter is chosen out of only the formats
//           that support the number of bits requested for the
//           fixed parameter.
//
//     [in]  DWORD numBackBuffers: Number of back buffers, or D3DX_DEFAULT.
//                                 See note.
//
//     NOTE:
//        windowed: D3DX_DEFAULT means 1.  You must specify one back buffer.
//
//        fullscreen: D3DX_DEFAULT means 1.  Any number of back buffers can be
//            specified.
//
//        offscreen: D3DX_DEFAULT means 0.  You cannot specify additional back 
//            buffers.
//
//     [in]  DWORD width: Width, in pixels, or D3DX_DEFAULT.  See note.
//     [in]  DWORD height: Height, in pixels, or D3DX_DEFAULT.  See note.
//
//     NOTE: 
//        windowed: If either width or height is D3DX_DEFAULT, both values
//            default to the dimensions of the client area of hwnd.
//
//        fullscreen: If either width or height is D3DX_DEFAULT, width 
//            defaults to 640, and height defaults to 480.
//
//        offscreen: An error is returned if either width or height is 
//            D3DX_DEFAULT.
//
//     [in]  DWORD refreshRate: D3DX_DEFAULT means we let ddraw choose for 
//                              us.  Ignored for windowed and offscreen modes.
//     [out] LPD3DXCONTEXT* ppCtx: This is the Context object that is used for
//                                 rendering on that device.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateContext(DWORD          deviceIndex,  
                      DWORD          flags,
                      HWND           hwnd,
                      DWORD          width, 
                      DWORD          height,
                      LPD3DXCONTEXT* ppCtx);

HRESULT WINAPI
    D3DXCreateContextEx(DWORD          deviceIndex,  
                        DWORD          flags,
                        HWND           hwnd,
                        HWND           hwndFocus, 
                        DWORD          numColorBits,
                        DWORD          numAlphaBits,
                        DWORD          numDepthbits,
                        DWORD          numStencilBits,
                        DWORD          numBackBuffers,
                        DWORD          width, 
                        DWORD          height,
                        DWORD          refreshRate,
                        LPD3DXCONTEXT* ppCtx);

// The D3DXCreateContext(Ex) flags are:
#define D3DX_CONTEXT_FULLSCREEN  0x00000001
#define D3DX_CONTEXT_OFFSCREEN   0x00000002

//-------------------------------------------------------------------------
// D3DXGetErrorString: Prints out the error string given an hresult. Prints
// ------------------  Win32 as well as DX6 error messages besides the D3DX
//                     messages.
//
// Params:
//     [in]  HRESULT hr: The error code to be deciphered.
//     [in]  DWORD strLength: Length of the string passed in.
//     [out] LPSTR pStr:  The string output. This string of appropriate
//                       size needs to be passed in.
//-------------------------------------------------------------------------
void WINAPI
    D3DXGetErrorString(HRESULT hr, 
                       DWORD   strLength, 
                       LPSTR   pStr);

//-------------------------------------------------------------------------
// D3DXMakeDDPixelFormat: Fills in a DDPIXELFORMAT structure based on the 
// ---------------------   D3DX surface format requested.
//
// Params:
//     [in]  D3DX_SURFACEFORMAT d3dxFormat: Surface format.
//     [out] DDPIXELFORMAT*     pddpf:      Pixel format matching the given
//                                          surface format.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXMakeDDPixelFormat(D3DX_SURFACEFORMAT d3dxFormat, 
                          DDPIXELFORMAT*     pddpf);

//-------------------------------------------------------------------------
// D3DXMakeSurfaceFormat: Determines the surface format corresponding to 
// ---------------------  a given DDPIXELFORMAT. 
//
// Params:
//     [in]  DDPIXELFORMAT* pddpf: Pixel format.
// Return Value:
//     D3DX_SURFACEFORMAT: Surface format matching the given pixel format.
//                         D3DX_SF_UNKNOWN if the format is not supported
//-------------------------------------------------------------------------
D3DX_SURFACEFORMAT WINAPI
    D3DXMakeSurfaceFormat(DDPIXELFORMAT* pddpf);

#ifdef __cplusplus
}
#endif //__cplusplus    

///////////////////////////////////////////////////////////////////////////
// Interfaces:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// ID3DXContext interface: 
//
// This encapsulates all the stuff that the app might 
// want to do at initialization time and any global control over d3d and 
// ddraw.
//-------------------------------------------------------------------------


DECLARE_INTERFACE_(ID3DXContext, IUnknown)
{
    //
    // IUnknown methods 
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Get the DDraw and Direct3D objects to call DirectDraw or
    // Direct3D Immediate Mode functions. 
    // If the objects don't exist (because they have not
    // been created for some reason) NULL is returned.
    // All the objects returned in the following Get* functions
    // are addref'ed. It is the application's responsibility to
    // release them when no longer needed.
    STDMETHOD_(LPDIRECTDRAW7,GetDD)(THIS) PURE;
    STDMETHOD_(LPDIRECT3D7,GetD3D)(THIS) PURE;
    STDMETHOD_(LPDIRECT3DDEVICE7,GetD3DDevice)(THIS) PURE;

    // Get the various buffers that get created at the init time
    // These are addref'ed as well. It is the application's responsibility
    // to release them before the app quits or when it needs a resize.
    STDMETHOD_(LPDIRECTDRAWSURFACE7,GetPrimary)(THIS) PURE;
    STDMETHOD_(LPDIRECTDRAWSURFACE7,GetZBuffer)(THIS) PURE;
    STDMETHOD_(LPDIRECTDRAWSURFACE7,GetBackBuffer)(THIS_ DWORD which) PURE;

    // Get the associated window handles 
    STDMETHOD_(HWND,GetWindow)(THIS) PURE;
    STDMETHOD_(HWND,GetFocusWindow)(THIS) PURE;

    // 
    // Various Get methods, in case the user had specified default
    // parameters
    //
    STDMETHOD(GetDeviceIndex)(THIS_ 
                              LPDWORD pDeviceIndex, 
                              LPDWORD pHwLevel) PURE;

    STDMETHOD_(DWORD, GetNumBackBuffers)(THIS) PURE;

    STDMETHOD(GetNumBits)(THIS_
                          LPDWORD pColorBits, 
                          LPDWORD pDepthBits,
                          LPDWORD pAlphaBits, 
                          LPDWORD pStencilBits) PURE;

    STDMETHOD(GetBufferSize)(THIS_ 
                             LPDWORD pWidth, 
                             LPDWORD pHeight) PURE;

    // Get the flags that were used to create this context
    STDMETHOD_(DWORD, GetCreationFlags)(THIS) PURE;
    STDMETHOD_(DWORD, GetRefreshRate)(THIS) PURE;
    
    // Restoring surfaces in case stuff is lost
    STDMETHOD(RestoreSurfaces)(THIS) PURE;
    
    // Resize all the buffers to the new width and height
    STDMETHOD(Resize)(THIS_ DWORD width, DWORD height) PURE;

    // Update the frame using a flip or a blit,
    // If the D3DX_UPDATE_NOVSYNC flag is set, blit is used if the 
    // driver cannot flip without waiting for vsync in full-screen mode.
    STDMETHOD(UpdateFrame)(THIS_ DWORD flags) PURE;

    // Render a string at the specified coordinates, with the specified 
    // colour. This is only provided as a convenience for 
    // debugging/information during development.
    // topLeftX and topLeftY represent the location of the top left corner
    // of the string, on the render target.  
    // The coordinate and color parameters each have a range of 0.0-1.0
    STDMETHOD(DrawDebugText)(THIS_
                             float topLeftX, 
                             float topLeftY,
                             D3DCOLOR color,
                             LPSTR pString) PURE;

    // Clears to the current viewport
    // The following are the valid flags:
    // D3DCLEAR_TARGET  (to clear the render target )
    // D3DCLEAR_ZBUFFER (to clear the depth-buffer )
    // D3DCLEAR_STENCIL (to clear the stencil-buffer )
    STDMETHOD(Clear)(THIS_ DWORD ClearFlags) PURE;

    STDMETHOD(SetClearColor)(THIS_ D3DCOLOR color ) PURE;
    STDMETHOD(SetClearDepth)(THIS_ float z) PURE;
    STDMETHOD(SetClearStencil)(THIS_ DWORD stencil) PURE;
};


//-------------------------------------------------------------------------
// Flags for Update member function:
//

// Flag to indicate that blit should be used instead of a flip
// for full-screen rendering.
#define D3DX_UPDATE_NOVSYNC (1<<0)

///////////////////////////////////////////////////////////////////////////
// Texturing APIs:
///////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
    
//-------------------------------------------------------------------------
// D3DXCheckTextureRequirements: Return information about texture creation 
// ----------------------------  (used by CreateTexture, CreateTextureFromFile
//                                and CreateCubeMapTexture)
//
// Parameters:
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
//  pFlags   
//      allows specification of D3DX_TEXTURE_NOMIPMAP
//      D3DX_TEXTURE_NOMIPMAP may be returned in the case where mipmap creation 
//      is not supported.
//  pWidth
//      width in pixels or NULL 
//      returns corrected width
//  pHeight       
//      height in pixels or NULL
//      returns corrected height
//  pPixelFormat
//      surface format 
//      returns best match to input format
//
//  Notes: 1. Unless the flags is set to specifically prevent creating 
//            mipmaps, mipmaps are generated all the way till 1x1 surface.
//         2. width, height and pixelformat are altered based on available 
//            hardware. For example:
//              a. Texture dimensions may be required to be powers of 2
//              b. We may require width == height for some devices
//              c. If PixelFormat is unavailable, a best fit is made
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCheckTextureRequirements( LPDIRECT3DDEVICE7     pd3dDevice,
                                  LPDWORD               pFlags, 
                                  LPDWORD               pWidth,  
                                  LPDWORD               pHeight,  
                                  D3DX_SURFACEFORMAT*   pPixelFormat);

//-------------------------------------------------------------------------
// D3DXCreateTexture: Create an empty texture object
// -----------------
//
// Parameters:
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
//  pFlags   
//      allows specification of D3DX_TEXTURE_NOMIPMAP
//      D3DX_TEXTURE_NOMIPMAP may be returned in the case where mipmap creation 
//      is not supported. Additionally, D3DX_TEXTURE_STAGE<n> can be specified
//      to indicate which texture stage the texture is for e.g. 
//      D3D_TEXTURE_STAGE1 indicates that the texture is for use with texture 
//      stage one. Stage Zero is the default if no TEXTURE_STAGE flags are
//      set.
//  pWidth
//      width in pixels; 0 or NULL is unacceptable
//      returns corrected width
//  pHeight       
//      height in pixels; 0 or NULL is unacceptable
//      returns corrected height
//  pPixelFormat
//      surface format. D3DX_DEFAULT is unacceptable.
//      returns actual format that was used
//  pDDPal
//      DDraw palette that is set (if present) on paletted surfaces.
//      It is ignored even if it is set, for non-paletted surfaces.
//  ppDDSurf
//      The ddraw surface that will be created
//  pNumMipMaps
//      the number of mipmaps actually generated
//
//  Notes: See notes for D3DXCheckTextureRequirements. 
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateTexture( LPDIRECT3DDEVICE7     pd3dDevice,
                       LPDWORD               pFlags, 
                       LPDWORD               pWidth,  
                       LPDWORD               pHeight,  
                       D3DX_SURFACEFORMAT*   pPixelFormat,
                       LPDIRECTDRAWPALETTE   pDDPal,
                       LPDIRECTDRAWSURFACE7* ppDDSurf,
                       LPDWORD               pNumMipMaps);

//-------------------------------------------------------------------------
// D3DXCreateCubeMapTexture: Create blank cube-map texture
// ------------------------
//
// Parameters:
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
//  pFlags   
//      allows specification of D3DX_TEXTURE_NOMIPMAP
//      D3DX_TEXTURE_NOMIPMAP may be returned in the case where mipmap creation 
//      is not supported. Additionally, D3DX_TEXTURE_STAGE<n> can be specified
//      to indicate which texture stage the texture is for e.g. 
//      D3D_TEXTURE_STAGE1 indicates that the texture is for use with texture 
//      stage one. Stage Zero is the default if no TEXTURE_STAGE flags are
//      set.
//  cubefaces
//      allows specification of which faces of the cube-map to generate.
//      D3DX_DEFAULT, 0, and DDSCAPS2_CUBEMAP_ALLFACES all mean
//      "create all 6 faces of the cubemap". Any combination of
//      DDSCAPS2_CUBEMAP_POSITIVEX, DDSCAPS2_CUBEMAP_NEGATIVEX,
//      DDSCAPS2_CUBEMAP_POSITIVEY, DDSCAPS2_CUBEMAP_NEGATIVEY,
//      DDSCAPS2_CUBEMAP_POSITIVEZ, or DDSCAPS2_CUBEMAP_NEGATIVEZ, is
//      valid.
//  colorEmptyFaces
//      allows specification of the color to use for the faces that were not
//      specified in the cubefaces parameter.
//  pWidth
//      width in pixels; 0 or NULL is unacceptable
//      returns corrected width
//  pHeight       
//      height in pixels; 0 or NULL is unacceptable
//      returns corrected height
//  pPixelFormat
//      surface format. D3DX_DEFAULT is unacceptable.
//      returns actual format that was used
//  pDDPal
//      DDraw palette that is set (if present) on paletted surfaces.
//      It is ignored even if it is set, for non-paletted surfaces.
//  ppDDSurf
//      the ddraw surface that will be created
//  pNumMipMaps
//      the number of mipmaps generated for a particular face of the 
//      cubemap.
//
//  Notes: See notes for D3DXCheckTextureRequirements. 
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateCubeMapTexture( LPDIRECT3DDEVICE7     pd3dDevice,
                              LPDWORD               pFlags, 
                              DWORD                 cubefaces,
                              D3DCOLOR              colorEmptyFaces,
                              LPDWORD               pWidth,  
                              LPDWORD               pHeight,  
                              D3DX_SURFACEFORMAT    *pPixelFormat,
                              LPDIRECTDRAWPALETTE   pDDPal,
                              LPDIRECTDRAWSURFACE7* ppDDSurf,
                              LPDWORD               pNumMipMaps);


//-------------------------------------------------------------------------
// D3DXCreateTextureFromFile: Create a texture object from a file or from the 
// -------------------------  resource. Only BMP and DIB are supported from the
//                            resource portion of the executable.
//
// Parameters:
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
//  pFlags   
//      allows specification of D3DX_TEXTURE_NOMIPMAP
//      D3DX_TEXTURE_NOMIPMAP may be returned in the case where mipmap creation 
//      is not supported. Additionally, D3DX_TEXTURE_STAGE<n> can be specified
//      to indicate which texture stage the texture is for e.g. 
//      D3D_TEXTURE_STAGE1 indicates that the texture is for use with texture 
//      stage one. Stage Zero is the default if no TEXTURE_STAGE flags are
//      set.
//  pWidth  
//      Width in pixels. If 0 or D3DX_DEFAULT, the width will be taken 
//      from the file
//      returns corrected width
//  pHeight   
//      Height in pixels. If 0 or D3DX_DEFAULT, the height will be taken 
//      from the file
//      returns corrected height
//  pPixelFormat
//      If D3DX_SF_UNKNOWN is passed in, pixel format closest to the bitmap 
//      will be chosen
//      returns actual format that was used
//  pDDPal
//      DDraw palette that is set (if present) on paletted surfaces.
//      It is ignored even if it is set, for non-paletted surfaces.
//  ppDDSurf
//      The ddraw surface that will be created.
//  pNumMipMaps
//      The number of mipmaps generated.
//  pSrcName
//      File name. BMP, DIB, DDS, are supported. 
//      
//      TGA is supported for the following cases: 16, 24, 32bpp direct color and 8bpp palettized. 
//      Also, 8, 16bpp grayscale is supported. RLE versions of the above 
//      TGA formats are also supported. ColorKey and Premultiplied Alpha 
//      are not currently supported for TGA files.
//      returns created format
//
//  Notes: See notes for D3DXCheckTextureRequirements. 
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateTextureFromFile( LPDIRECT3DDEVICE7     pd3dDevice,
                               LPDWORD               pFlags, 
                               LPDWORD               pWidth,  
                               LPDWORD               pHeight,  
                               D3DX_SURFACEFORMAT*   pPixelFormat,
                               LPDIRECTDRAWPALETTE   pDDPal,
                               LPDIRECTDRAWSURFACE7* ppDDSurf,
                               LPDWORD               pNumMipMaps,
                               LPSTR                 pSrcName,
                               D3DX_FILTERTYPE       filterType);

//-------------------------------------------------------------------------
// D3DXLoadTextureFromFile: Load from a file into a mipmap level. Doing the 
// -----------------------  necessary color conversion and rescaling. File
//                          format support is identical to 
//                          D3DXCreateTextureFromFile's.
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
// pTexture
//      a pointer to a DD7Surface which was created with either 
//      CreateTextureFromFile or CreateTexture.
// mipMapLevel
//      indicates mipmap level
//      Note: 
//          1. Error if mipmap level doesn't exist
//          2. If D3DX_DEFAULT and equal number of mipmap levels exist
//             then all the source mip-levels are loaded
//          3. If the source has mipmaps and the dest doesn't, use the top one
//          4. If the dest has miplevels and source doesn't, we expand
//          5. If there are unequal numbers of miplevels, we expand
// pSrcName
//      File name. BMP, DIB, DDS, are supported. 
//      For details on TGA support, refer to the comments for 
//      D3DXCreateTextureFromFile
// pSrcRect
//      the source rectangle or null (whole surface)
// pDestRect
//      the destination rectangle or null (whole surface)
// filterType 
//      filter used for mipmap generation
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXLoadTextureFromFile( LPDIRECT3DDEVICE7    pd3dDevice,
                             LPDIRECTDRAWSURFACE7 pTexture,
                             DWORD                mipMapLevel,
                             LPSTR                pSrcName, 
                             RECT*                pSrcRect, 
                             RECT*                pDestRect,
                             D3DX_FILTERTYPE      filterType);

//-------------------------------------------------------------------------
// D3DXLoadTextureFromSurface: Load from a DDraw Surface into a mipmap level. 
// --------------------------  Doing the necessary color conversion.
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
// pTexture
//      a pointer to a DD7Surface which was created with either 
//      CreateTextureFromFile or CreateTexture.
// mipMapLevel
//      indicates mipmap level
//      Note: 
//          1. Error if mipmap level doesn't exist
//          2. If D3DX_DEFAULT and equal number of mipmap levels exist
//             then all the source mip-levels are loaded
//          3. If the source has mipmaps and the dest doesn't, use the top one
//          4. If the dest has miplevels and source doesn't, we expand
//          5. If there are unequal numbers of miplevels, we expand
// pSurfaceSrc
//      the source surface
// pSrcRect
//      the source rectangle or null (whole surface)
// pDestRect
//      the destination rectangle or null (whole surface)
// filterType 
//      filter used for mipmap generation
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXLoadTextureFromSurface( LPDIRECT3DDEVICE7    pd3dDevice,
                                LPDIRECTDRAWSURFACE7 pTexture,
                                DWORD                mipMapLevel,
                                LPDIRECTDRAWSURFACE7 pSurfaceSrc, 
                                RECT*                pSrcRect, 
                                RECT*                pDestRect,
                                D3DX_FILTERTYPE      filterType);

//-------------------------------------------------------------------------
// D3DXLoadTextureFromMemory: Load a mip level from memory. Doing the necessary
// -------------------------  color conversion.
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
// pTexture
//      a pointer to a DD7Surface which was created with either 
//      CreateTextureFromFile or CreateTexture.
// mipMapLevel
//      indicates mipmap level
//      Note: 
//          1. Error if mipmap level doesn't exist
//          2. If D3DX_DEFAULT and equal number of mipmap levels exist
//             then all the source mip-levels are loaded
//          3. If the source has mipmaps and the dest doesn't, use the top one
//          4. If the dest has miplevels and source doesn't, we expand
//          5. If there are unequal numbers of miplevels, we expand
// pMemory
//      pointer to source memory from which the texture will be loaded
// pDDPal
//      DirectDraw Palette, that the app passes in optionally if the memory is 
//      supposed to be paletteized.
// srcPixelFormat
//      PixelFormat of the source.
// srcPitch
//      The pitch of the memory or D3DX_DEFAULT (based on srcPixelFormat)
// pDestRect
//      The destination rectangle or null (whole surface)
// filterType 
//      filter used for mipmap generation
// 
// Assumptions: The source (memory) is loaded in full
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXLoadTextureFromMemory( LPDIRECT3DDEVICE7    pd3dDevice, 
                               LPDIRECTDRAWSURFACE7 pTexture,
                               DWORD                mipMapLevel, 
                               LPVOID               pMemory,
                               LPDIRECTDRAWPALETTE  pDDPal,
                               D3DX_SURFACEFORMAT   srcPixelFormat,
                               DWORD                srcPitch,
                               RECT*                pDestRect,
                               D3DX_FILTERTYPE      filterType);

#ifdef __cplusplus
}
#endif //__cplusplus    

//-------------------------------------------------------------------------
// Flags for texture create functions; applies to 
// D3DXCreateTexture, D3DXCreateCubeMapTexture and D3DXCreateTextureFromFile.
//

// Flag to indicate that mipmap generation is not desired.
#define D3DX_TEXTURE_NOMIPMAP  (1 << 8)

// Flags to indicate which texture stage the texture is
// intended for use with. Specifying the stage is necessary at
// texture creation time for HW devices that expose the
// D3DDEVCAPS_SEPARATETEXTUREMEMORIES bit in their D3DDEVICEDESC
// structure.
#define D3DX_TEXTURE_STAGE0    (0)
#define D3DX_TEXTURE_STAGE1    (1)
#define D3DX_TEXTURE_STAGE2    (2)
#define D3DX_TEXTURE_STAGE3    (3)
#define D3DX_TEXTURE_STAGE4    (4)
#define D3DX_TEXTURE_STAGE5    (5)
#define D3DX_TEXTURE_STAGE6    (6)
#define D3DX_TEXTURE_STAGE7    (7)

// Mask to extract the texture stage value out of the flags to
// the texture create functions.
#define D3DX_TEXTURE_STAGE_MASK (0x7)

#endif //__D3DXCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dx8shape.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8shapes.h
//  Content:    D3DX simple shapes
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8SHAPES_H__
#define __D3DX8SHAPES_H__

///////////////////////////////////////////////////////////////////////////
// Functions:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXCreatePolygon: 
// ------------------
// Creates a mesh containing an n-sided polygon.  The polygon is centered
// at the origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Length      Length of each side.
//  Sides       Number of sides the polygon has.  (Must be >= 3)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreatePolygon(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Length, 
        UINT                Sides, 
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateBox: 
// --------------
// Creates a mesh containing an axis-aligned box.  The box is centered at
// the origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Width       Width of box (along X-axis)
//  Height      Height of box (along Y-axis)
//  Depth       Depth of box (along Z-axis)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateBox(
        LPDIRECT3DDEVICE8   pDevice, 
        FLOAT               Width,
        FLOAT               Height,
        FLOAT               Depth,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateCylinder:
// -------------------
// Creates a mesh containing a cylinder.  The generated cylinder is
// centered at the origin, and its axis is aligned with the Z-axis.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Radius1     Radius at -Z end (should be >= 0.0f)
//  Radius2     Radius at +Z end (should be >= 0.0f)
//  Length      Length of cylinder (along Z-axis)
//  Slices      Number of slices about the main axis
//  Stacks      Number of stacks along the main axis
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateCylinder(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Radius1, 
        FLOAT               Radius2, 
        FLOAT               Length, 
        UINT                Slices, 
        UINT                Stacks,   
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateSphere:
// -----------------
// Creates a mesh containing a sphere.  The sphere is centered at the
// origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Radius      Radius of the sphere (should be >= 0.0f)
//  Slices      Number of slices about the main axis
//  Stacks      Number of stacks along the main axis
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateSphere(
        LPDIRECT3DDEVICE8  pDevice, 
        FLOAT              Radius, 
        UINT               Slices, 
        UINT               Stacks,
        LPD3DXMESH*        ppMesh,
        LPD3DXBUFFER*      ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateTorus:
// ----------------
// Creates a mesh containing a torus.  The generated torus is centered at
// the origin, and its axis is aligned with the Z-axis.
//
// Parameters: 
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  InnerRadius Inner radius of the torus (should be >= 0.0f)
//  OuterRadius Outer radius of the torue (should be >= 0.0f)
//  Sides       Number of sides in a cross-section (must be >= 3)
//  Rings       Number of rings making up the torus (must be >= 3)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTorus(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               InnerRadius,
        FLOAT               OuterRadius, 
        UINT                Sides,
        UINT                Rings, 
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateTeapot: 
// -----------------
// Creates a mesh containing a teapot.
//
// Parameters: 
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTeapot(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateText: 
// --------------- 
// Creates a mesh containing the specified text using the font associated
// with the device context.
//
// Parameters:
//
//  pDevice       The D3D device with which the mesh is going to be used.
//  hDC           Device context, with desired font selected
//  pText         Text to generate
//  Deviation     Maximum chordal deviation from true font outlines
//  Extrusion     Amount to extrude text in -Z direction
//  ppMesh        The mesh object which will be created
//  pGlyphMetrics Address of buffer to receive glyph metric data (or NULL)
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTextA(
        LPDIRECT3DDEVICE8   pDevice,
        HDC                 hDC,
        LPCSTR              pText,
        FLOAT               Deviation,
        FLOAT               Extrusion,
        LPD3DXMESH*         ppMesh,
        LPGLYPHMETRICSFLOAT pGlyphMetrics);

HRESULT WINAPI
    D3DXCreateTextW(
        LPDIRECT3DDEVICE8   pDevice,
        HDC                 hDC,
        LPCWSTR             pText,
        FLOAT               Deviation,
        FLOAT               Extrusion,
        LPD3DXMESH*         ppMesh,
        LPGLYPHMETRICSFLOAT pGlyphMetrics);

#ifdef UNICODE
#define D3DXCreateText D3DXCreateTextW
#else
#define D3DXCreateText D3DXCreateTextA
#endif


#ifdef __cplusplus
}
#endif //__cplusplus    

#endif //__D3DX8SHAPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dxshapes.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxshapes.h
//  Content:    D3DX simple shapes
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXSHAPES_H__
#define __D3DXSHAPES_H__

#include <d3d.h>
#include <limits.h>
#include "d3dxerr.h"


typedef struct ID3DXSimpleShape *LPD3DXSIMPLESHAPE;

// {CFCD4602-EB7B-11d2-A440-00A0C90629A8}
DEFINE_GUID( IID_ID3DXSimpleShape, 
0xcfcd4602, 0xeb7b, 0x11d2, 0xa4, 0x40, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8 );


///////////////////////////////////////////////////////////////////////////
// Interfaces:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// ID3DXSimpleShape interface: 
//-------------------------------------------------------------------------

DECLARE_INTERFACE_(ID3DXSimpleShape, IUnknown)
{
    // IUnknown methods 
    STDMETHOD(QueryInterface)(THIS_ REFIID  riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // ID3DXSimpleShape methods
    STDMETHOD_(LPDIRECT3DVERTEXBUFFER7, GetVB)(THIS) PURE;
    STDMETHOD_(DWORD, GetIndices)(THIS_ LPWORD *ppIndices) PURE;
    STDMETHOD(Draw)(THIS) PURE;
};



///////////////////////////////////////////////////////////////////////////
// Functions:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXCreatePolygon: Creates an 'n' sided polygon using the device
// ----------------  specified. It returns a vertex buffer that can be used
//                   for drawing or manipulation by the program later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float sideSize: Length of a side.
//     [in]  DWORD numTexCoords:   The number of texture coordinates desired
//                                 in the vertex-buffer. (Default is 1)
//                                 D3DX_DEFAULT is a valid input.
//     [out] IDirect3DVertexBuffer7** ppVB: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreatePolygon(LPDIRECT3DDEVICE7  pDevice,
                      float              sideSize, 
                      DWORD              numSides, 
                      DWORD              numTexCoords, 
                      LPD3DXSIMPLESHAPE* ppShape );

//-------------------------------------------------------------------------
// D3DXCreateBox: Creates a box (cuboid) of given dimensions using the  
// ------------  device. It returns a vertex buffer that can
//               be used for drawing or manipulation by the program later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float width: Width of the box (along x-axis)
//     [in]  float height: Height of the box (along y-axis)
//     [in]  float depth: Depth of the box (along z-axis)
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                               in the vertex-buffer. Default is 1. 
//                               D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output vertex-buffer.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateBox(LPDIRECT3DDEVICE7  pDevice, 
                  float              width,
                  float              height,
                  float              depth,
                  DWORD              numTexCoords, 
                  LPD3DXSIMPLESHAPE* ppShape );

//-------------------------------------------------------------------------
// D3DXCreateCylinder: Creates a cylinder of given dimensions using the  
// -----------------  device. It returns a vertex buffer that
//                    can be used for drawing or manipulation by the program
//                    later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float baseRadius: Base-radius (default is 1.0f, shd be >= 0.0f)
//     [in]  float topRadius: Top-radius (default is 1.0f, shd be >= 0.0f)
//     [in]  float height: Height (default is 1.0f, shd be >= 0.0f)
//     [in]  DWORD numSlices: Number of slices about the main axis.
//                            (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numStacks: Number of stacks along the main axis. 
//                            (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                               in the vertex-buffer. Default is 1. 
//                               D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateCylinder(LPDIRECT3DDEVICE7  pDevice,
                       float              baseRadius, 
                       float              topRadius, 
                       float              height, 
                       DWORD              numSlices, 
                       DWORD              numStacks,   
                       DWORD              numTexCoords, 
                       LPD3DXSIMPLESHAPE* ppShape );


//-------------------------------------------------------------------------
// D3DXCreateTorus: Creates a torus of given dimensions using the  
// --------------  device specified. It returns a vertex buffer that can
//                 be used for drawing or manipulation by the program later
//                 on. It draws a doughnut, centered at (0, 0, 0) whose axis 
//                 is aligned with the z-axis. With the innerRadius used
//                 as the radius of the cross-section (minor-Radius) and 
//                 the outerRadius used as the radius of the central 'hole'. 
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float innerRadius: inner radius (default is 1.0f, shd be >= 0.0f)
//     [in]  float outerRadius: outer radius (default is 2.0f, shd be >= 0.0f)
//     [in]  DWORD numSides: Number of sides in the cross-section 
//                           (default is 8). D3DX_DEFAULT is a valid input.
//     [in]  DWORD numRings: Number of rings making up the torus 
//                           (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                                 in the vertex-buffer. Default is 1. 
//                                 D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTorus(LPDIRECT3DDEVICE7  pDevice,
                    float              innerRadius,
                    float              outerRadius, 
                    DWORD              numSides,
                    DWORD              numRings, 
                    DWORD              numTexCoords,  
                    LPD3DXSIMPLESHAPE* ppShape );

//-------------------------------------------------------------------------
// D3DXCreateTeapot: Creates a teapot using the device specified. 
// ----------------  It returns a vertex buffer that can be used for
//                   drawing or manipulation by the program later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                               in the vertex-buffer. Default is 1. 
//                               D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTeapot(LPDIRECT3DDEVICE7  pDevice,
                     DWORD              numTexCoords, 
                     LPD3DXSIMPLESHAPE* ppShape);

//-------------------------------------------------------------------------
// D3DXCreateSphere: Creates a cylinder of given dimensions using the
// ----------------  device specified. 
//                   It returns a vertex buffer that can be used for
//                   drawing or manipulation by the program later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float radius: radius (default is 1.0f, shd be >= 0.0f)
//     [in]  float height: Height (default is 1.0f, shd be >= 0.0f)
//     [in]  DWORD numSlices: Number of slices about the main axis
//                            (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numStacks: Number of stacks along the main axis
//                            (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                               in the vertex-buffer. Default is 1. 
//                               D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateSphere(LPDIRECT3DDEVICE7  pDevice, 
                     float              radius, 
                     DWORD              numSlices, 
                     DWORD              numStacks,
                     DWORD              numTexCoords, 
                     LPD3DXSIMPLESHAPE* ppShape);

#ifdef __cplusplus
}
#endif //__cplusplus    
#endif //__D3DXSHAPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dapi.h ===
/*******************************************************************
 *
 * Copyright (c) Microsoft Corp. 1986-1996. All Rights Reserved.
 *
 *
 *    DESCRIPTION:   This header file defines the functions, structures,
 *                   and macros used to access the Microsoft Exchange
 *                   APIs for modifying entries in the Exchange 4.0 DIT.
 *                   These APIs permit a calling process to create, 
 *                   modify, or delete DIT objects by specifying the
 *                   name of a CSV text file containing attributes 
 *                   for objects to import into ( or to modify) 
 *                   the DIT.  See the Directory Access Functions
 *                   section of the Exchange Developer's Kit for 
 *                   more detailed description of this interface.
 *                   
 *                   Calling programs must link with DAPI.LIB.
 *                   
 *                   Error and warning codes are defined in DAPIMSG.H
 *
 *
 *******************************************************************/

/** include files **/
#ifndef _WINDOWS_
#include <windows.h>
#endif

/** local definitions **/

#ifndef  _DAPI_INCLUDED_
#define  _DAPI_INCLUDED_

#ifdef __cplusplus
extern "C"
{
#endif

// Import / Export APIs check for the presence of this signature in 
// the dwDAPISignature field in the import parameter blocks.
// This signature will be incremented each time one of the parameter
// blocks is changed so that header synchronization problems can be 
// detected.
#define  DAPI_SIGNATURE                   0x46414400


// Combinable flags used to control the API functions.

   // The following flags control filtering of DAPI events
   // The default action is DAPI_EVENT_ALL
#define DAPI_EVENT_MASK                   0x00000007  /* bit-field containing event-filtering requested 
                                                         if none of these bits are set, DAPI_EVENT_ALL is assumed */
#define DAPI_EVENT_MIN                    0x00000001  /* No warning or error logging.
                                                         Log start and stop messages */
#define DAPI_EVENT_SOME                   0x00000002  /* Start, Stop, and Error messages will be logged. */
#define DAPI_EVENT_ALL                    0x00000004  /* Start, Stop, Error, and Warning messages
                                                         will be logged. */
                                                         
   // The following flags control schema read and use of the schema
#define DAPI_FORCE_SCHEMA_LOAD            0x00000010  /* Unload previously loaded schema
                                                         and read schema again.
                                                         Default action is to re-use
                                                         previously loaded schema if read
                                                         from the same messaging domain */
#define DAPI_RAW_MODE                     0x00000020  /* Import / Export in "Raw" mode.  Import
                                                         lines are taken literally.  No
                                                         attributes will be inherited, 
                                                         constructed, etc.  Aliases for 
                                                         attribute and class names will
                                                         not be recognized. */
                                                         
#define DAPI_OVERRIDE_CONTAINER           0x00000040  /* Container specified in the parameter block
                                                         overrides the contents of the container column.
                                                         Default behaviour is for the value specified
                                                         in the Obj-Container column to override
                                                         that specified in the parameter block */
                                                 
#define DAPI_IMPORT_NO_ERR_FILE           0x00000080  /* Do not create Error File -- BatchImport only */
#define DAPI_IMPORT_WRITE_THROUGH         0x00400000  /* Commit write operations immediately */

// Flags defined for "Batch" operations only -- ignored by DAPIRead, DAPIWrite
#define DAPI_YES_TO_ALL                   0x00000100  /* Force "yes" response on any
                                                         user-prompt UI 
                                                         (i.e., continue w/o proxy addresses, etc.) */

#define DAPI_SUPPRESS_PROGRESS            0x00000200  /* Suppress progress thermometer on batch operations.
                                                         Default is to display progress */
#define DAPI_SUPPRESS_COMPLETION          0x00000400  /* Suppress completion notification message box on batch operations */
                                                         
#define DAPI_SUPPRESS_ARCHIVES            0x00000800  /* Suppress creation of "archive" copies
                                                         of output files -- BatchImport and BatchExport only*/
                                                         


// Flags defined for BatchExport
#define DAPI_EXPORT_MAILBOX               0x00001000  /* Export Mailbox recipients */
#define DAPI_EXPORT_CUSTOM                0x00002000  /* Export remote address recipients */
#define DAPI_EXPORT_DIST_LIST             0x00004000  /* Export Distribution Lists */
#define DAPI_EXPORT_RECIPIENTS       (DAPI_EXPORT_MAILBOX | DAPI_EXPORT_CUSTOM | DAPI_EXPORT_DIST_LIST)
                                                      /* Export all recipient objects */

#define DAPI_EXPORT_ALL_CLASSES           0x00008000  /* If this flag is set, all objects meeting other restrictions
                                                         (i.e., USN level, container scope, etc.) will be exported,
                                                         regardless of class */

#define DAPI_EXPORT_HIDDEN                0x00010000  /* Include Hidden objects in export.
                                                                      Default is no export if Hide-From-Address-Book */
#define DAPI_EXPORT_SUBTREE               0x00020000  /* Traverse the Directory Information Tree hierarchy,
                                                         exporting objects that meet the export restrictions */
#define DAPI_EXPORT_BASEPOINT_ONLY        0x00040000  /* Export only the requested attributes from
                                                         the named BasePoint object.  All other 
                                                         export restrictions are ignored (class flags, 
                                                         rgpszClasses, pszServerName). 
                                                         This flag implies DAPI_SUPPRESS_PROGRESS
                                                         and DAPI_SUPPRESS_COMPLETION */

// Flags defined only for BatchImport
#define DAPI_OVERRIDE_SYNCH_STATE         0x00080000  /* Override server's synchronization status,
                                                         normally checked on BatchImport.
                                                         NOTE:  This flag should normally NOT be set.
                                                                The normal behaviour is to prevent BatchImport
                                                                operations from possible conflict with directory
                                                                synchronization */


// Flags defined only for DAPIRead                                                         
#define  DAPI_READ_DEFINED_ATTRIBUTES     0x00100000  /* return all attributes that are set
                                                         for the current object. 
                                                         This flag is ignored if pAttributes is specified. */

#define  DAPI_READ_ALL_ATTRIBUTES         0x00200000  /* return all attributes that are defined
                                                         for the class of the current object. 
                                                         This flag is ignored if pAttributes is specified. */


 // The following flags control NT Security management
#define DAPI_RESTRICT_ACCESS              0x01000000  /* Apply NT Security Descriptor to 
                                                         created objects */
#define DAPI_CREATE_NT_ACCOUNT            0x02000000  /* Create NT accounts 
                                                         (valid only in Create/Modify mode) */
#define DAPI_CREATE_RANDOM_PASSWORD       0x04000000  /* Generate random passwords for
                                                         created NT accounts.  Ignored if DAPI_CREATE_NT_ACCOUNT
                                                         is not set */
                                                         
#define DAPI_DELETE_NT_ACCOUNT            0x08000000  /* Delete ASSOC-NT-ACCOUNT when
                                                         deleting mailbox */
// Flags defined only for DAPIWrite
#define DAPI_MODIFY_REPLACE_PROPERTIES    0x00800000  /* Append values to multi-value attributes when modifying */

#define  DAPI_WRITE_UPDATE                0x10000000  /* Modify if object exists, create if it doesn't.
                                                         NOTE:  This is the default mode */
#define  DAPI_WRITE_CREATE                0x20000000  /* Create object -- fail if object exists */
#define  DAPI_WRITE_MODIFY                0x30000000  /* Modify object -- fail if object does not exist */
#define  DAPI_WRITE_DELETE                0x40000000  /* Delete object */
#define  DAPI_WRITE_MODE_MASK             0x70000000



// Callback flags
#define  DAPI_CALLBACK_CHAIN              0x00000001  /* If set in dwFlags field of the ERROR_CALLBACK
                                                         and the CALLBACKPROGRESS structures, the default
                                                         handler will be invoked after calling out to the 
                                                         caller-supplied handler function, unless the user
                                                         function returns FALSE, indicating cancel.
                                                         NOTE:  This flag is not defined for the EXPORT_CALLBACK
                                                                structure.
                                                         NOTE:  This flag should not be set in the dwFlags
                                                                field of the main parameter block */


// default delimiter values used when parsing the import file

#define DAPI_DEFAULT_DELIMA   ','
#define DAPI_DEFAULT_QUOTEA   '"'
#define DAPI_DEFAULT_MV_SEPA  '%'
#define DAPI_DEFAULT_DELIMW   L','
#define DAPI_DEFAULT_QUOTEW   L'"'
#define DAPI_DEFAULT_MV_SEPW  L'%'


#define DAPI_CTRL_FILE_PTRA   '='
#define DAPI_CTRL_FILE_PTRW   L'='
#define DAPI_CTRL_ANR_PREFIXA '='
#define DAPI_CTRL_ANR_PREFIXW L'='
#define DAPI_CTRL_META_CHARA  '~'
#define DAPI_CTRL_META_CHARW  L'~'
#define pszSubstServerA       "~SERVER"
#define pszSubstServerW       L"~SERVER"
#define cchSubstServer        ((sizeof (pszSubstServerA) / sizeof(CHAR)) - 1)
#define pszDeleteKeyA         "~DEL"
#define pszDeleteKeyW         L"~DEL"
#define cchDeleteKey          ((sizeof (pszDeleteKeyA) / sizeof(CHAR)) - 1)

#define DAPI_UNICODE_FILE     ((UINT)-1)

#ifdef UNICODE

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMW
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEW
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPW
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRW
#define DAPI_CTRL_ANR_PREFIX  DAPI_CTRL_ANR_PREFIXW
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARW
#define pszSubstServer        pszSubstServerW
#define pszDeleteKey          pszDeleteKeyW

#else

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMA
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEA
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPA
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRA
#define DAPI_CTRL_ANR_PREFIX  DAPI_CTRL_ANR_PREFIXA
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARA
#define pszSubstServer        pszSubstServerA
#define pszDeleteKey          pszDeleteKeyA

#endif


/*******************************************************************************
* Batch Operation Progress Callback Function Definitions
* Pointers to functions of these types are provided by the caller via the 
* CALLBACKPROGRESS structure in the Batch function parameter block
*               
********************************************************************************
*               
*  procedure :  PDAPI_FInitProgress
*               
*    purpose :  Initialize progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FResetProgress
*               
*    purpose :  Re-initialize progress handler (possibly reset progress bar)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not re-initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FEndProgress
*               
*    purpose :  Terminate progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not terminate progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgress
*               
*    purpose :  Completed processing item.  Called to indicate time to increment
*               progress display.
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgressText
*               
*    purpose :  Replace progress text area with provided text string
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************/
typedef BOOL (PASCAL * PDAPI_FInitProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FEndProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FResetProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgressText)
                          (LPVOID lpvAppDefined, LPTSTR pszText);
            
typedef struct CallBackProgressEntryPoints
{
   DWORD                      dwFlags;
   LPVOID                     lpvAppDefined;
   PDAPI_FInitProgress        pfnInitProgress;
   PDAPI_FUpdateProgress      pfnUpdateProgress;
   PDAPI_FEndProgress         pfnEndProgress;
   PDAPI_FResetProgress       pfnResetProgress;
   PDAPI_FUpdateProgressText  pfnUpdateProgressText;
} CALLBACKPROGRESS, *PCALLBACKPROGRESS;



// Values specified in the ulEvalTag field of the 
//    DAPI_ENTRY and EXPORT_CALLBACK structures
//    
typedef enum _DAPI_EVAL
{
   VALUE_ARRAY = 0,           // Each attribute has an entry in the array
                              //    Text strings and object names exported as text
                              //    Numerical values exported as numbers
                              //    Binary data exported as binary string
   TEXT_VALUE_ARRAY,          // Each attribute has an entry in the array
                              //    All values converted to text representation
   TEXT_LINE                  // first item in the rgEntryValues array
                              //    is a delimited text line
} DAPI_EVAL, *PDAPI_EVAL;

typedef enum _EXP_TYPE_TAG
{
   EXPORT_HEADER = 0,         // export item contains column headers
   EXPORT_ENTRY               // export item contains attribute values
} EXP_TYPE, * PEXP_TYPE;


typedef enum enumDAPI_DATA_TYPE
{
   DAPI_NO_VALUE = 0,
   DAPI_STRING8,
   DAPI_UNICODE,
   DAPI_BINARY,
   DAPI_INT,
   DAPI_BOOL,
} DAPI_DATA_TYPE, * PDAPI_DATA_TYPE;

#ifdef UNICODE
#define DAPI_TEXT DAPI_UNICODE
#else
#define DAPI_TEXT DAPI_STRING8
#endif

typedef union _DAPI_VALUE
{
   LPSTR    pszA;
   LPWSTR   pszW;
#ifdef UNICODE
   LPWSTR   pszValue;
#else
   LPSTR    pszValue;
#endif
   LPBYTE   lpBinary;
   INT      iValue;
   BOOL     bool;
} DAPI_VALUE, * PDAPI_VALUE;



// The ATT_VALUE structure contains a text representation of an attribute value
// A linked list of these structures is used for a multi-valued attribute
typedef struct _ATT_VALUE
{
   DAPI_DATA_TYPE       DapiType;         // How to evaluate DAPI_VALUE union
   DAPI_VALUE           Value;
   UINT                 size;             // size of the value -- 
                                          //    # chars if string type
                                          //    else, # bytes
   struct _ATT_VALUE *  pNextValue;
} ATT_VALUE, * PATT_VALUE;


typedef struct _DAPI_ENTRY
{
   UINT           unAttributes;              // Number of attributes exported
   DAPI_EVAL      ulEvalTag;                 // rgEntryValues is interpreted based on this value
   PATT_VALUE     rgEntryValues;             // if (ulEvalTag == TEXT_LINE)
                                             //    There is a single value, w/ delimited line
                                             // else
                                             //    unAttributes, each w/ 1 or more value in list
} DAPI_ENTRY, * PDAPI_ENTRY;

// Define type for address of application routine 
// for call-back on each exported entry.
// Return value of FALSE indicates that export operation should be cancelled
typedef BOOL (PASCAL DAPI_FNExportEntry) (
               EXP_TYPE    ExportDataType,   // What type of data is being exported
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_ENTRY pExportEntry      // pointer to exported entry data
                                             // NOTE: Data in this structure
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNExportEntry * PDAPI_FNExportEntry;

typedef struct _EXPORT_CALLBACK
{
   DWORD       dwFlags;                      // Flags defined to control callback functionality
                                             // See flag definitions below
   DAPI_EVAL   ulEvalTag;                    // Specifies data format on callback
   LPVOID      lpvAppDefined;                // Application-defined field, passed as parm to callback
   PDAPI_FNExportEntry  pfnExportEntry;      // Pointer to function called to process
                                             // each exported entry

} EXPORT_CALLBACK, * PEXPORT_CALLBACK;



/*******************************************************************************
*  procedure :  pfnErrorCallback
*               
*    purpose :  The following section defines structures for the error callback
*               mechanism of the Batch Import APIs
*               Events will be filtered based on the ControlfFlags set in the 
*               API parameter block
*               
********************************************************************************/

// Define flags used for export callback

// Define the maximum number of substitutions in a single event string
#define DAPI_MAX_SUBST 8


typedef struct _DAPI_EVENTA
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPSTR             rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPSTR             pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPSTR             pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTA * pNextEvent;       // Pointer to next event
} DAPI_EVENTA, *PDAPI_EVENTA;

typedef struct _DAPI_EVENTW
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPWSTR            rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPWSTR            pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPWSTR            pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTW * pNextEvent;       // Pointer to next event
} DAPI_EVENTW, *PDAPI_EVENTW;

#ifdef UNICODE
typedef DAPI_EVENTW  DAPI_EVENT;
typedef PDAPI_EVENTW PDAPI_EVENT;
#else
typedef DAPI_EVENTA  DAPI_EVENT;
typedef PDAPI_EVENTA PDAPI_EVENT;
#endif

// Define type for address of application routine 
// for call-back on each error encountered.
// Return value of FALSE indicates that operation should be cancelled
typedef BOOL (PASCAL DAPI_FNErrorCallback) (
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_EVENT pDapiEvent        // Event information structure
                                             // NOTE: Data in the event record
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNErrorCallback * PDAPI_FNErrorCallback;


typedef struct tagERROR_CALLBACK
{
   DWORD                   dwFlags;          // Flags defined to control callback functionality
                                             // See flag definitions above
   LPVOID                  lpvAppDefined;    // Application-defined field, passed back in callback
   PDAPI_FNErrorCallback   pfnErrorCallback; // Address of function that should be
                                             // called on each error encountered
                                             // If not supplied (NULL), default
                                             // error handler is called, which
                                             // writes the error into the 
                                             // NT Application event log

} ERROR_CALLBACK, * PERROR_CALLBACK;





/*******************************************************************************
*  
*   Batch Directory Import Interface definitions
*               
********************************************************************************/

/*******************************************************************************
*  procedure :  DAPIUninitialize
*               
*    purpose :  Notify DAPI that it is time to terminate background threads
*               and such in preparation for process shutdown
*               
* parameters :  dwFlags		combinable bits which may be set to control function
*               
*    returns :  nothing
*               
*    created :  11/01/95 
*               
*    changes :  
*               
********************************************************************************/
extern void APIENTRY DAPIUninitialize (
                              DWORD    dwFlags // Flags for call
);



/*******************************************************************************
*  procedure :  SchemaPreload
*               
*    purpose :  Called to perform asyncronous schema load.  This entry point
*               spawns a thread that initializes all the attribute and class
*               tables for normal import/export operation.
*               
* parameters :  pSchemaPreloadParms    pointer to SchemaPreloadParameter block
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY SchemaPreloadA (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPSTR    pszDSA   // name of DSA from which to read schema
);

extern void APIENTRY SchemaPreloadW (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPWSTR   pszDSA   // name of DSA from which to read schema
);

#ifdef UNICODE
#define  SchemaPreload  SchemaPreloadW
#else
#define  SchemaPreload  SchemaPreloadA
#endif

typedef struct _BIMPORT_PARMSW
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;                // Windows handle to use when displaying message boxes
   LPWSTR   pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   WCHAR    chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR    chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR    chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR    creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPWSTR   pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPWSTR   pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSW, *PBIMPORT_PARMSW, *LPBIMPORT_PARMSW;

typedef struct _BIMPORT_PARMSA
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPSTR    pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSA, *PBIMPORT_PARMSA, *LPBIMPORT_PARMSA;

#ifdef UNICODE
typedef  BIMPORT_PARMSW    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSW   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSW  LPBIMPORT_PARMS;
#else
typedef  BIMPORT_PARMSA    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSA   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSA  LPBIMPORT_PARMS;
#endif

// The BatchImport function provides single-call BatchImport from the
//    specified import file.  All import parameters are specified in the
//    BIMPORT_PARMS structure pointed to by lpBimportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Import.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD APIENTRY BatchImportW (LPBIMPORT_PARMSW lpBimportParms);
extern DWORD APIENTRY BatchImportA (LPBIMPORT_PARMSA lpBimportParms);

#ifdef UNICODE
#define BatchImport        BatchImportW
#else
#define BatchImport        BatchImportA
#endif

/*******************************************************************************
*  
*   Batch Directory Export Interface definitions
*               
********************************************************************************/

typedef struct _BEXPORT_PARMSW
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPWSTR   pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   WCHAR     chColSep;           // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR     chQuote;            // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR     chMVSep;            // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR     cReserved;          // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes;      // DAPI_ENTRY filled with names of attributes to export
                                       // Optional if pszExportFile specified
                                       // Required if ExportCallback specified
   LPWSTR   pszHomeServer;       // Name of server for server-associated export
   LPWSTR * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSW, *PBEXPORT_PARMSW, *LPBEXPORT_PARMSW;

typedef struct _BEXPORT_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     cReserved;           // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes; // DAPI_ENTRY filled with names of attributes to export
                                        // Optional if pszExportFile specified
                                        // Required if ExportCallback specified
   LPSTR    pszHomeServer;       // Name of server for server-associated export
   LPSTR  * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSA, *PBEXPORT_PARMSA, *LPBEXPORT_PARMSA;


#ifdef UNICODE
typedef  BEXPORT_PARMSW    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSW   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSW  LPBEXPORT_PARMS;
#else
typedef  BEXPORT_PARMSA    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSA   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSA  LPBEXPORT_PARMS;
#endif



// Batch Export entry points

// The BatchExport function provides single-call BatchExport from the
//    specified import file.  All import parameters are specified in the
//    BEXPORT_PARMS structure pointed to by lpBexportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Export.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD   APIENTRY BatchExportW (LPBEXPORT_PARMSW lpBexportParms);
extern DWORD   APIENTRY BatchExportA (LPBEXPORT_PARMSA lpBexportParms);

#ifdef UNICODE
#define BatchExport     BatchExportW
#else
#define BatchExport     BatchExportA
#endif


/*******************************************************************************
*  
*  Single-Object Interface definitions             
*               
********************************************************************************/

typedef struct _DAPI_PARMSW
{
   DWORD        dwDAPISignature;
   DWORD        dwFlags;         // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPWSTR       pszDSAName;      // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR       pszBasePoint;    // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR       pszContainer;    // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPWSTR       pszNTDomain;     // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPWSTR       pszCreateTemplate;// DN of the template object used for default values
   PDAPI_ENTRY  pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSW, *PDAPI_PARMSW, FAR *LPDAPI_PARMSW;

typedef struct _DAPI_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPSTR    pszCreateTemplate;   // DN of the template object used for default values
   PDAPI_ENTRY   pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSA, *PDAPI_PARMSA, FAR *LPDAPI_PARMSA;


#ifdef UNICODE
typedef  DAPI_PARMSW    DAPI_PARMS;
typedef  PDAPI_PARMSW   PDAPI_PARMS;
typedef  LPDAPI_PARMSW  LPDAPI_PARMS;
#else
typedef  DAPI_PARMSA    DAPI_PARMS;
typedef  PDAPI_PARMSA   PDAPI_PARMS;
typedef  LPDAPI_PARMSA  LPDAPI_PARMS;
#endif


typedef  LPVOID   DAPI_HANDLE;
typedef  LPVOID * PDAPI_HANDLE;
typedef  LPVOID FAR * LPDAPI_HANDLE;

#define  DAPI_INVALID_HANDLE  ((DAPI_HANDLE) -1)



// DAPIStart initializes a DAPI session.
//    for use by DAPIRead and DAPIWrite.  The return value is 0 if no errors
//    are encountered.  A pointer to a DAPI_EVENT structure is returned if an 
//    error is encountered.  
//    NOTE:  The DAPI_HANDLE must be returned via a call to DAPIEnd.
//           If a non-NULL value is returned, its memory must be freed by
//           a call to DAPIFreeMemory
extern PDAPI_EVENTW APIENTRY DAPIStartW  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSW     lpDAPIParms);
extern PDAPI_EVENTA APIENTRY DAPIStartA  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSA     lpDAPIParms);

#ifdef UNICODE
#define DAPIStart    DAPIStartW
#else
#define DAPIStart    DAPIStartA
#endif

// DAPIEnd invalidates the DAPI_HANDLE obtained by the call to DAPIStart.
//    NOTE:  There are no separate Unicode / Ansi entry points defined 
extern   void  APIENTRY DAPIEnd (LPDAPI_HANDLE lphDAPISession);


// DAPIRead() Reads indicated attributes from the named Directory Object
// Parameters:  
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        control operation
//    pszObjectName  String containing name of object to read.
//                      If specified as RDN, combined w/ session's
//                      pszBasePoint and pszParentContainer.
//                      If specified w/ prefix of "/cn=", the string 
//                      is concatenated to the session pszBasePoint.
//                      If specified w/ prefix of "/o=", the string
//                      is taken to be a fully-qualified DN.
//    pAttList       Pointer to DAPI_ENTRY structure containing names of
//                      attributes to read.  The session default list is
//                      overridden for the present call only.
//    ppValues       Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the values read from the DIT entry.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
//    ppAttributes   Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the names of attributes read
//                      from the DIT IFF DAPI_ALL_ATTRIBUTES or DAPI_LEGAL_ATTRIBUTES
//                      were set in dwFlags.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
extern PDAPI_EVENTW APIENTRY DAPIReadW   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPWSTR         pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);
extern PDAPI_EVENTA APIENTRY DAPIReadA   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPSTR          pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);

#ifdef UNICODE
#define DAPIRead     DAPIReadW
#else
#define DAPIRead     DAPIReadA
#endif


// DAPIWrite() 
//   Perform the indicated write operation on the named object
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
// Parameters:  
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        Operational control
//    pAttributes   Pointer to DAPI_ENTRY structure containing names of
//                      attributes to write.  The session default list is
//                      used if this parameter is NULL
//    pValues        Pointer to DAPI_ENTRY structure containing the values 
//                      to set on the DIT entry.
//    lpulUSN         Optional:  Address of variable receiving USN of updated
//                      DIT entry.  May be specified as NULL to suppress this
//                      return value.
//    lppszCreatedAccount  Address receiving pointer to name of created NT account
//    lppszPassword  Address receiving pointer to password generated if
//                      NT Account is created. 
extern PDAPI_EVENTW APIENTRY DAPIWriteW (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPWSTR *       lppszCreatedAccount,
                                             LPWSTR *       lppszPassword);
extern PDAPI_EVENTA APIENTRY DAPIWriteA (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPSTR *        lppszCreatedAccount,
                                             LPSTR *        lppszPassword);
#ifdef UNICODE
#define DAPIWrite      DAPIWriteW
#else
#define DAPIWrite      DAPIWriteA
#endif


/*******************************************************************************
*  procedure :  DAPIAllocBuffer
*               
*    purpose :  Allocate buffer, logically linking it to the pvAllocBase
*               The first buffer in logically linked set of allocations must be 
*               freed by call to DAPIFreeMemory
*               
* parameters :  cbSize		dword containing size of allocation request (in bytes)
*               pvAllocBase	base for logical linking of allocated block
*                             May be NULL
*                             If non-NULL, must be a block previously allocated
*                             by DAPIAllocBuffer or returned by DAPI function
*               
*    returns :  ptr to allocated block
*               
*    history :  
*               
********************************************************************************/
extern LPVOID APIENTRY DAPIAllocBuffer (DWORD	cbSize, LPVOID	pvAllocBase);


/*******************************************************************************
*  procedure :  DAPIFreeMemory
*               
*    purpose :  Release memory allocated for structures returned by DAPI calls.
*               
* parameters :  lpVoid  pointer to block to free
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY DAPIFreeMemory (LPVOID   lpVoid);


/* 
 * NetUserList interface definitions
 */
// When getting callbacks from NTExport / NWExport, these indices
// can be used to interpret the value array returned in the callback
// >>>>    NOTE:  These indices are NOT valid for Bexport callback!    <<<<
#define  NET_CLASS         0
#define  NET_COMMON_NAME   1
#define  NET_DISPLAY_NAME  2
#define  NET_HOME_SERVER   3
#define  NET_COMMENT       4     /* NTExport only */

#define  NTEXP_ENTRY_COUNT 5 /* number of parts in NT User export */
#define  NWEXP_ENTRY_COUNT 4 /* number of parts in NetWare user export */



/*******************************************************************************
*  
* NTIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NTEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszDCName;        // Name of Domain Controller from which to get users
                                       // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
   LPWSTR            pszNTDomain;      // Name of Domain from which to read users
                                       // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
} NTEXPORT_PARMSW, *PNTEXPORT_PARMSW, FAR *LPNTEXPORT_PARMSW;

typedef struct _NTEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszDCName;        // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
                                       // Name of Domain from which to read users
   LPSTR             pszNTDomain;      // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
                                       
} NTEXPORT_PARMSA, *PNTEXPORT_PARMSA, FAR *LPNTEXPORT_PARMSA;

#ifdef UNICODE
typedef  NTEXPORT_PARMSW      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSW     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSW    LPNTEXPORT_PARMS;
#else
typedef  NTEXPORT_PARMSA      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSA     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSA    LPNTEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NTExportW (LPNTEXPORT_PARMSW pNTExportParms);
extern   DWORD APIENTRY    NTExportA (LPNTEXPORT_PARMSA pNTExportParms);

#ifdef UNICODE
#define NTExport              NTExportW
#else
#define NTExport              NTExportA
#endif


/*******************************************************************************
*  
* NWIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NWEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszFileServer;    // Name of the file server to connect to
   LPWSTR            pszUserName;      // User Name -- Must have administrator priviliges
   LPWSTR            pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSW, *PNWEXPORT_PARMSW, *LPNWEXPORT_PARMSW;

typedef struct _NWEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszFileServer;    // Name of the file server to connect to
   LPSTR             pszUserName;      // User Name -- Must have administrator priviliges
   LPSTR             pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSA, *PNWEXPORT_PARMSA, *LPNWEXPORT_PARMSA;

#ifdef UNICODE
typedef  NWEXPORT_PARMSW      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSW     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSW    LPNWEXPORT_PARMS;
#else
typedef  NWEXPORT_PARMSA      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSA     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSA    LPNWEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NWExportW (LPNWEXPORT_PARMSW pNWExportParms);
extern   DWORD APIENTRY    NWExportA (LPNWEXPORT_PARMSA pNWExportParms);

#ifdef UNICODE
#define NWExport              NWExportW
#else
#define NWExport              NWExportA
#endif


// Definitions for the DAPIGetSiteInfo call

typedef struct _NAME_INFOA
{
   LPSTR    pszName;                            // Simple object name
   LPSTR    pszDNString;                        // DN of object
   LPSTR    pszDisplayName;                     // Display name of object
} NAME_INFOA, *PNAME_INFOA;

typedef struct _NAME_INFOW
{
   LPWSTR   pszName;                            // Simple object name
   LPWSTR   pszDNString;                        // DN of object
   LPWSTR   pszDisplayName;                     // Display name of object
} NAME_INFOW, *PNAME_INFOW;

typedef struct _PSITE_INFOA
{
   LPSTR       pszCountry;                      // Country code
   NAME_INFOA  objServer;                       // Name information for server
   NAME_INFOA  objSite;                         // Name information for site containing server
   NAME_INFOA  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOA, *PSITE_INFOA;

typedef struct _PSITE_INFOW
{
   LPWSTR      pszCountry;                      // Country code
   NAME_INFOW  objServer;                       // Name information for server
   NAME_INFOW  objSite;                         // Name information for site containing server
   NAME_INFOW  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOW, *PSITE_INFOW;

#ifdef UNICODE
typedef  NAME_INFOW        NAME_INFO;
typedef  PNAME_INFOW       PNAME_INFO;
typedef  SITE_INFOW        SITE_INFO;
typedef  PSITE_INFOW       PSITE_INFO;
#else
typedef  NAME_INFOA        NAME_INFO;
typedef  PNAME_INFOA       PNAME_INFO;
typedef  SITE_INFOA        SITE_INFO;
typedef  PSITE_INFOA       PSITE_INFO;
#endif

extern PDAPI_EVENTA APIENTRY DAPIGetSiteInfoA (
                              DWORD    dwFlags,                // Flags for request
                              LPSTR    pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOA *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return data
);

extern PDAPI_EVENTW APIENTRY DAPIGetSiteInfoW (
                              DWORD    dwFlags,                // Flags for request
                              LPWSTR   pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOW *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return dataname of DSA from which to read schema
);

#ifdef UNICODE
#define  DAPIGetSiteInfo DAPIGetSiteInfoW
#else
#define  DAPIGetSiteInfo DAPIGetSiteInfoA
#endif



#ifdef __cplusplus
}
#endif

#endif   // _DAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\danim.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Tue Nov 11 05:16:35 1997
 */
/* Compiler settings for ..\danim.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )

#ifndef __danim_h__
#define __danim_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDAViewSite_FWD_DEFINED__
#define __IDAViewSite_FWD_DEFINED__
typedef interface IDAViewSite IDAViewSite;
#endif 	/* __IDAViewSite_FWD_DEFINED__ */


#ifndef __IDAView_FWD_DEFINED__
#define __IDAView_FWD_DEFINED__
typedef interface IDAView IDAView;
#endif 	/* __IDAView_FWD_DEFINED__ */


#ifndef __IDABehavior_FWD_DEFINED__
#define __IDABehavior_FWD_DEFINED__
typedef interface IDABehavior IDABehavior;
#endif 	/* __IDABehavior_FWD_DEFINED__ */


#ifndef __IDANumber_FWD_DEFINED__
#define __IDANumber_FWD_DEFINED__
typedef interface IDANumber IDANumber;
#endif 	/* __IDANumber_FWD_DEFINED__ */


#ifndef __IDABvrHook_FWD_DEFINED__
#define __IDABvrHook_FWD_DEFINED__
typedef interface IDABvrHook IDABvrHook;
#endif 	/* __IDABvrHook_FWD_DEFINED__ */


#ifndef __IDADrawingSurface_FWD_DEFINED__
#define __IDADrawingSurface_FWD_DEFINED__
typedef interface IDADrawingSurface IDADrawingSurface;
#endif 	/* __IDADrawingSurface_FWD_DEFINED__ */


#ifndef __IDAPickableResult_FWD_DEFINED__
#define __IDAPickableResult_FWD_DEFINED__
typedef interface IDAPickableResult IDAPickableResult;
#endif 	/* __IDAPickableResult_FWD_DEFINED__ */


#ifndef __DABehavior_FWD_DEFINED__
#define __DABehavior_FWD_DEFINED__

#ifdef __cplusplus
typedef class DABehavior DABehavior;
#else
typedef struct DABehavior DABehavior;
#endif /* __cplusplus */

#endif 	/* __DABehavior_FWD_DEFINED__ */


#ifndef __IDAUntilNotifier_FWD_DEFINED__
#define __IDAUntilNotifier_FWD_DEFINED__
typedef interface IDAUntilNotifier IDAUntilNotifier;
#endif 	/* __IDAUntilNotifier_FWD_DEFINED__ */


#ifndef __IDABoolean_FWD_DEFINED__
#define __IDABoolean_FWD_DEFINED__
typedef interface IDABoolean IDABoolean;
#endif 	/* __IDABoolean_FWD_DEFINED__ */


#ifndef __IDACamera_FWD_DEFINED__
#define __IDACamera_FWD_DEFINED__
typedef interface IDACamera IDACamera;
#endif 	/* __IDACamera_FWD_DEFINED__ */


#ifndef __IDAColor_FWD_DEFINED__
#define __IDAColor_FWD_DEFINED__
typedef interface IDAColor IDAColor;
#endif 	/* __IDAColor_FWD_DEFINED__ */


#ifndef __IDAGeometry_FWD_DEFINED__
#define __IDAGeometry_FWD_DEFINED__
typedef interface IDAGeometry IDAGeometry;
#endif 	/* __IDAGeometry_FWD_DEFINED__ */


#ifndef __IDAImage_FWD_DEFINED__
#define __IDAImage_FWD_DEFINED__
typedef interface IDAImage IDAImage;
#endif 	/* __IDAImage_FWD_DEFINED__ */


#ifndef __IDAMatte_FWD_DEFINED__
#define __IDAMatte_FWD_DEFINED__
typedef interface IDAMatte IDAMatte;
#endif 	/* __IDAMatte_FWD_DEFINED__ */


#ifndef __IDAMicrophone_FWD_DEFINED__
#define __IDAMicrophone_FWD_DEFINED__
typedef interface IDAMicrophone IDAMicrophone;
#endif 	/* __IDAMicrophone_FWD_DEFINED__ */


#ifndef __IDAMontage_FWD_DEFINED__
#define __IDAMontage_FWD_DEFINED__
typedef interface IDAMontage IDAMontage;
#endif 	/* __IDAMontage_FWD_DEFINED__ */


#ifndef __IDAPath2_FWD_DEFINED__
#define __IDAPath2_FWD_DEFINED__
typedef interface IDAPath2 IDAPath2;
#endif 	/* __IDAPath2_FWD_DEFINED__ */


#ifndef __IDAPoint2_FWD_DEFINED__
#define __IDAPoint2_FWD_DEFINED__
typedef interface IDAPoint2 IDAPoint2;
#endif 	/* __IDAPoint2_FWD_DEFINED__ */


#ifndef __IDAPoint3_FWD_DEFINED__
#define __IDAPoint3_FWD_DEFINED__
typedef interface IDAPoint3 IDAPoint3;
#endif 	/* __IDAPoint3_FWD_DEFINED__ */


#ifndef __IDASound_FWD_DEFINED__
#define __IDASound_FWD_DEFINED__
typedef interface IDASound IDASound;
#endif 	/* __IDASound_FWD_DEFINED__ */


#ifndef __IDAString_FWD_DEFINED__
#define __IDAString_FWD_DEFINED__
typedef interface IDAString IDAString;
#endif 	/* __IDAString_FWD_DEFINED__ */


#ifndef __IDATransform2_FWD_DEFINED__
#define __IDATransform2_FWD_DEFINED__
typedef interface IDATransform2 IDATransform2;
#endif 	/* __IDATransform2_FWD_DEFINED__ */


#ifndef __IDATransform3_FWD_DEFINED__
#define __IDATransform3_FWD_DEFINED__
typedef interface IDATransform3 IDATransform3;
#endif 	/* __IDATransform3_FWD_DEFINED__ */


#ifndef __IDAVector2_FWD_DEFINED__
#define __IDAVector2_FWD_DEFINED__
typedef interface IDAVector2 IDAVector2;
#endif 	/* __IDAVector2_FWD_DEFINED__ */


#ifndef __IDAVector3_FWD_DEFINED__
#define __IDAVector3_FWD_DEFINED__
typedef interface IDAVector3 IDAVector3;
#endif 	/* __IDAVector3_FWD_DEFINED__ */


#ifndef __IDAFontStyle_FWD_DEFINED__
#define __IDAFontStyle_FWD_DEFINED__
typedef interface IDAFontStyle IDAFontStyle;
#endif 	/* __IDAFontStyle_FWD_DEFINED__ */


#ifndef __IDALineStyle_FWD_DEFINED__
#define __IDALineStyle_FWD_DEFINED__
typedef interface IDALineStyle IDALineStyle;
#endif 	/* __IDALineStyle_FWD_DEFINED__ */


#ifndef __IDAEndStyle_FWD_DEFINED__
#define __IDAEndStyle_FWD_DEFINED__
typedef interface IDAEndStyle IDAEndStyle;
#endif 	/* __IDAEndStyle_FWD_DEFINED__ */


#ifndef __IDAJoinStyle_FWD_DEFINED__
#define __IDAJoinStyle_FWD_DEFINED__
typedef interface IDAJoinStyle IDAJoinStyle;
#endif 	/* __IDAJoinStyle_FWD_DEFINED__ */


#ifndef __IDADashStyle_FWD_DEFINED__
#define __IDADashStyle_FWD_DEFINED__
typedef interface IDADashStyle IDADashStyle;
#endif 	/* __IDADashStyle_FWD_DEFINED__ */


#ifndef __IDABbox2_FWD_DEFINED__
#define __IDABbox2_FWD_DEFINED__
typedef interface IDABbox2 IDABbox2;
#endif 	/* __IDABbox2_FWD_DEFINED__ */


#ifndef __IDABbox3_FWD_DEFINED__
#define __IDABbox3_FWD_DEFINED__
typedef interface IDABbox3 IDABbox3;
#endif 	/* __IDABbox3_FWD_DEFINED__ */


#ifndef __IDAPair_FWD_DEFINED__
#define __IDAPair_FWD_DEFINED__
typedef interface IDAPair IDAPair;
#endif 	/* __IDAPair_FWD_DEFINED__ */


#ifndef __IDAEvent_FWD_DEFINED__
#define __IDAEvent_FWD_DEFINED__
typedef interface IDAEvent IDAEvent;
#endif 	/* __IDAEvent_FWD_DEFINED__ */


#ifndef __IDAArray_FWD_DEFINED__
#define __IDAArray_FWD_DEFINED__
typedef interface IDAArray IDAArray;
#endif 	/* __IDAArray_FWD_DEFINED__ */


#ifndef __IDATuple_FWD_DEFINED__
#define __IDATuple_FWD_DEFINED__
typedef interface IDATuple IDATuple;
#endif 	/* __IDATuple_FWD_DEFINED__ */


#ifndef __IDAUserData_FWD_DEFINED__
#define __IDAUserData_FWD_DEFINED__
typedef interface IDAUserData IDAUserData;
#endif 	/* __IDAUserData_FWD_DEFINED__ */


#ifndef __DABoolean_FWD_DEFINED__
#define __DABoolean_FWD_DEFINED__

#ifdef __cplusplus
typedef class DABoolean DABoolean;
#else
typedef struct DABoolean DABoolean;
#endif /* __cplusplus */

#endif 	/* __DABoolean_FWD_DEFINED__ */


#ifndef __DACamera_FWD_DEFINED__
#define __DACamera_FWD_DEFINED__

#ifdef __cplusplus
typedef class DACamera DACamera;
#else
typedef struct DACamera DACamera;
#endif /* __cplusplus */

#endif 	/* __DACamera_FWD_DEFINED__ */


#ifndef __DAColor_FWD_DEFINED__
#define __DAColor_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAColor DAColor;
#else
typedef struct DAColor DAColor;
#endif /* __cplusplus */

#endif 	/* __DAColor_FWD_DEFINED__ */


#ifndef __DAGeometry_FWD_DEFINED__
#define __DAGeometry_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAGeometry DAGeometry;
#else
typedef struct DAGeometry DAGeometry;
#endif /* __cplusplus */

#endif 	/* __DAGeometry_FWD_DEFINED__ */


#ifndef __DAImage_FWD_DEFINED__
#define __DAImage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAImage DAImage;
#else
typedef struct DAImage DAImage;
#endif /* __cplusplus */

#endif 	/* __DAImage_FWD_DEFINED__ */


#ifndef __DAMatte_FWD_DEFINED__
#define __DAMatte_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAMatte DAMatte;
#else
typedef struct DAMatte DAMatte;
#endif /* __cplusplus */

#endif 	/* __DAMatte_FWD_DEFINED__ */


#ifndef __DAMicrophone_FWD_DEFINED__
#define __DAMicrophone_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAMicrophone DAMicrophone;
#else
typedef struct DAMicrophone DAMicrophone;
#endif /* __cplusplus */

#endif 	/* __DAMicrophone_FWD_DEFINED__ */


#ifndef __DAMontage_FWD_DEFINED__
#define __DAMontage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAMontage DAMontage;
#else
typedef struct DAMontage DAMontage;
#endif /* __cplusplus */

#endif 	/* __DAMontage_FWD_DEFINED__ */


#ifndef __DANumber_FWD_DEFINED__
#define __DANumber_FWD_DEFINED__

#ifdef __cplusplus
typedef class DANumber DANumber;
#else
typedef struct DANumber DANumber;
#endif /* __cplusplus */

#endif 	/* __DANumber_FWD_DEFINED__ */


#ifndef __DAPath2_FWD_DEFINED__
#define __DAPath2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAPath2 DAPath2;
#else
typedef struct DAPath2 DAPath2;
#endif /* __cplusplus */

#endif 	/* __DAPath2_FWD_DEFINED__ */


#ifndef __DAPoint2_FWD_DEFINED__
#define __DAPoint2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAPoint2 DAPoint2;
#else
typedef struct DAPoint2 DAPoint2;
#endif /* __cplusplus */

#endif 	/* __DAPoint2_FWD_DEFINED__ */


#ifndef __DAPoint3_FWD_DEFINED__
#define __DAPoint3_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAPoint3 DAPoint3;
#else
typedef struct DAPoint3 DAPoint3;
#endif /* __cplusplus */

#endif 	/* __DAPoint3_FWD_DEFINED__ */


#ifndef __DASound_FWD_DEFINED__
#define __DASound_FWD_DEFINED__

#ifdef __cplusplus
typedef class DASound DASound;
#else
typedef struct DASound DASound;
#endif /* __cplusplus */

#endif 	/* __DASound_FWD_DEFINED__ */


#ifndef __DAString_FWD_DEFINED__
#define __DAString_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAString DAString;
#else
typedef struct DAString DAString;
#endif /* __cplusplus */

#endif 	/* __DAString_FWD_DEFINED__ */


#ifndef __DATransform2_FWD_DEFINED__
#define __DATransform2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DATransform2 DATransform2;
#else
typedef struct DATransform2 DATransform2;
#endif /* __cplusplus */

#endif 	/* __DATransform2_FWD_DEFINED__ */


#ifndef __DATransform3_FWD_DEFINED__
#define __DATransform3_FWD_DEFINED__

#ifdef __cplusplus
typedef class DATransform3 DATransform3;
#else
typedef struct DATransform3 DATransform3;
#endif /* __cplusplus */

#endif 	/* __DATransform3_FWD_DEFINED__ */


#ifndef __DAVector2_FWD_DEFINED__
#define __DAVector2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAVector2 DAVector2;
#else
typedef struct DAVector2 DAVector2;
#endif /* __cplusplus */

#endif 	/* __DAVector2_FWD_DEFINED__ */


#ifndef __DAVector3_FWD_DEFINED__
#define __DAVector3_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAVector3 DAVector3;
#else
typedef struct DAVector3 DAVector3;
#endif /* __cplusplus */

#endif 	/* __DAVector3_FWD_DEFINED__ */


#ifndef __DAFontStyle_FWD_DEFINED__
#define __DAFontStyle_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAFontStyle DAFontStyle;
#else
typedef struct DAFontStyle DAFontStyle;
#endif /* __cplusplus */

#endif 	/* __DAFontStyle_FWD_DEFINED__ */


#ifndef __DALineStyle_FWD_DEFINED__
#define __DALineStyle_FWD_DEFINED__

#ifdef __cplusplus
typedef class DALineStyle DALineStyle;
#else
typedef struct DALineStyle DALineStyle;
#endif /* __cplusplus */

#endif 	/* __DALineStyle_FWD_DEFINED__ */


#ifndef __DAEndStyle_FWD_DEFINED__
#define __DAEndStyle_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAEndStyle DAEndStyle;
#else
typedef struct DAEndStyle DAEndStyle;
#endif /* __cplusplus */

#endif 	/* __DAEndStyle_FWD_DEFINED__ */


#ifndef __DAJoinStyle_FWD_DEFINED__
#define __DAJoinStyle_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAJoinStyle DAJoinStyle;
#else
typedef struct DAJoinStyle DAJoinStyle;
#endif /* __cplusplus */

#endif 	/* __DAJoinStyle_FWD_DEFINED__ */


#ifndef __DADashStyle_FWD_DEFINED__
#define __DADashStyle_FWD_DEFINED__

#ifdef __cplusplus
typedef class DADashStyle DADashStyle;
#else
typedef struct DADashStyle DADashStyle;
#endif /* __cplusplus */

#endif 	/* __DADashStyle_FWD_DEFINED__ */


#ifndef __DABbox2_FWD_DEFINED__
#define __DABbox2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DABbox2 DABbox2;
#else
typedef struct DABbox2 DABbox2;
#endif /* __cplusplus */

#endif 	/* __DABbox2_FWD_DEFINED__ */


#ifndef __DABbox3_FWD_DEFINED__
#define __DABbox3_FWD_DEFINED__

#ifdef __cplusplus
typedef class DABbox3 DABbox3;
#else
typedef struct DABbox3 DABbox3;
#endif /* __cplusplus */

#endif 	/* __DABbox3_FWD_DEFINED__ */


#ifndef __DAPair_FWD_DEFINED__
#define __DAPair_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAPair DAPair;
#else
typedef struct DAPair DAPair;
#endif /* __cplusplus */

#endif 	/* __DAPair_FWD_DEFINED__ */


#ifndef __DAEvent_FWD_DEFINED__
#define __DAEvent_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAEvent DAEvent;
#else
typedef struct DAEvent DAEvent;
#endif /* __cplusplus */

#endif 	/* __DAEvent_FWD_DEFINED__ */


#ifndef __DAArray_FWD_DEFINED__
#define __DAArray_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAArray DAArray;
#else
typedef struct DAArray DAArray;
#endif /* __cplusplus */

#endif 	/* __DAArray_FWD_DEFINED__ */


#ifndef __DATuple_FWD_DEFINED__
#define __DATuple_FWD_DEFINED__

#ifdef __cplusplus
typedef class DATuple DATuple;
#else
typedef struct DATuple DATuple;
#endif /* __cplusplus */

#endif 	/* __DATuple_FWD_DEFINED__ */


#ifndef __DAUserData_FWD_DEFINED__
#define __DAUserData_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAUserData DAUserData;
#else
typedef struct DAUserData DAUserData;
#endif /* __cplusplus */

#endif 	/* __DAUserData_FWD_DEFINED__ */


#ifndef __IDAPreferences_FWD_DEFINED__
#define __IDAPreferences_FWD_DEFINED__
typedef interface IDAPreferences IDAPreferences;
#endif 	/* __IDAPreferences_FWD_DEFINED__ */


#ifndef __DAView_FWD_DEFINED__
#define __DAView_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAView DAView;
#else
typedef struct DAView DAView;
#endif /* __cplusplus */

#endif 	/* __DAView_FWD_DEFINED__ */


#ifndef __IDASite_FWD_DEFINED__
#define __IDASite_FWD_DEFINED__
typedef interface IDASite IDASite;
#endif 	/* __IDASite_FWD_DEFINED__ */


#ifndef __IDAImportationResult_FWD_DEFINED__
#define __IDAImportationResult_FWD_DEFINED__
typedef interface IDAImportationResult IDAImportationResult;
#endif 	/* __IDAImportationResult_FWD_DEFINED__ */


#ifndef __DAImportationResult_FWD_DEFINED__
#define __DAImportationResult_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAImportationResult DAImportationResult;
#else
typedef struct DAImportationResult DAImportationResult;
#endif /* __cplusplus */

#endif 	/* __DAImportationResult_FWD_DEFINED__ */


#ifndef __DAPickableResult_FWD_DEFINED__
#define __DAPickableResult_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAPickableResult DAPickableResult;
#else
typedef struct DAPickableResult DAPickableResult;
#endif /* __cplusplus */

#endif 	/* __DAPickableResult_FWD_DEFINED__ */


#ifndef __IDAStatics_FWD_DEFINED__
#define __IDAStatics_FWD_DEFINED__
typedef interface IDAStatics IDAStatics;
#endif 	/* __IDAStatics_FWD_DEFINED__ */


#ifndef __DAStatics_FWD_DEFINED__
#define __DAStatics_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAStatics DAStatics;
#else
typedef struct DAStatics DAStatics;
#endif /* __cplusplus */

#endif 	/* __DAStatics_FWD_DEFINED__ */


#ifndef __IDAViewerControl_FWD_DEFINED__
#define __IDAViewerControl_FWD_DEFINED__
typedef interface IDAViewerControl IDAViewerControl;
#endif 	/* __IDAViewerControl_FWD_DEFINED__ */


#ifndef __IDAViewerControlWindowed_FWD_DEFINED__
#define __IDAViewerControlWindowed_FWD_DEFINED__
typedef interface IDAViewerControlWindowed IDAViewerControlWindowed;
#endif 	/* __IDAViewerControlWindowed_FWD_DEFINED__ */


#ifndef __DAViewerControl_FWD_DEFINED__
#define __DAViewerControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAViewerControl DAViewerControl;
#else
typedef struct DAViewerControl DAViewerControl;
#endif /* __cplusplus */

#endif 	/* __DAViewerControl_FWD_DEFINED__ */


#ifndef __DAViewerControlWindowed_FWD_DEFINED__
#define __DAViewerControlWindowed_FWD_DEFINED__

#ifdef __cplusplus
typedef class DAViewerControlWindowed DAViewerControlWindowed;
#else
typedef struct DAViewerControlWindowed DAViewerControlWindowed;
#endif /* __cplusplus */

#endif 	/* __DAViewerControlWindowed_FWD_DEFINED__ */


/* header files for imported files */
#include "ocmm.h"
#include "effect.h"
#include "servprov.h"


/****************************************
 * Generated header for interface: __MIDL_itf_danim_0000
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


    typedef interface IDABehavior IDABehavior;
    typedef interface IDANumber IDANumber;
    typedef interface IDABvrHook IDABvrHook;
typedef IDAPickableResult *PickableResultPtr;





#ifndef __DirectAnimation_LIBRARY_DEFINED__
#define __DirectAnimation_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DirectAnimation
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 











    typedef interface IDABoolean IDABoolean;

    typedef interface IDACamera IDACamera;

    typedef interface IDAColor IDAColor;

    typedef interface IDAGeometry IDAGeometry;

    typedef interface IDAImage IDAImage;

    typedef interface IDAMatte IDAMatte;

    typedef interface IDAMicrophone IDAMicrophone;

    typedef interface IDAMontage IDAMontage;

    typedef interface IDANumber IDANumber;

    typedef interface IDAPath2 IDAPath2;

    typedef interface IDAPoint2 IDAPoint2;

    typedef interface IDAPoint3 IDAPoint3;

    typedef interface IDASound IDASound;

    typedef interface IDAString IDAString;

    typedef interface IDATransform2 IDATransform2;

    typedef interface IDATransform3 IDATransform3;

    typedef interface IDAVector2 IDAVector2;

    typedef interface IDAVector3 IDAVector3;

    typedef interface IDAFontStyle IDAFontStyle;

    typedef interface IDALineStyle IDALineStyle;

    typedef interface IDAEndStyle IDAEndStyle;

    typedef interface IDAJoinStyle IDAJoinStyle;

    typedef interface IDADashStyle IDADashStyle;

    typedef interface IDABbox2 IDABbox2;

    typedef interface IDABbox3 IDABbox3;

    typedef interface IDAPair IDAPair;

    typedef interface IDAEvent IDAEvent;

    typedef interface IDAArray IDAArray;

    typedef interface IDATuple IDATuple;

    typedef interface IDAUserData IDAUserData;
typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_danim_0151_0001
    {	DAEmpty	= 0,
	DASolid	= 1,
	DADash	= 2
    }	DA_DASH_STYLE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_danim_0151_0002
    {	DAEndFlat	= 0,
	DAEndSquare	= 1,
	DAEndRound	= 2
    }	DA_END_STYLE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_danim_0151_0003
    {	DAJoinBevel	= 0,
	DAJoinRound	= 1,
	DAJoinMiter	= 2
    }	DA_JOIN_STYLE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_danim_0156_0001
    {	DAMultimediaTimer	= 0,
	DAContainerTimer	= 1,
	DAWMTimer	= 2
    }	DA_TIMER_SOURCE;


EXTERN_C const IID LIBID_DirectAnimation;

#ifndef __IDAViewSite_INTERFACE_DEFINED__
#define __IDAViewSite_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAViewSite
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAViewSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("283807B3-2C60-11d0-A31D-00AA00B92C03")
    IDAViewSite : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStatusText( 
            /* [in] */ BSTR StatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAViewSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAViewSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAViewSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAViewSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAViewSite * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAViewSite * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAViewSite * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAViewSite * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusText )( 
            IDAViewSite * This,
            /* [in] */ BSTR StatusText);
        
        END_INTERFACE
    } IDAViewSiteVtbl;

    interface IDAViewSite
    {
        CONST_VTBL struct IDAViewSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAViewSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAViewSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAViewSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAViewSite_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAViewSite_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAViewSite_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAViewSite_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAViewSite_SetStatusText(This,StatusText)	\
    (This)->lpVtbl -> SetStatusText(This,StatusText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAViewSite_SetStatusText_Proxy( 
    IDAViewSite * This,
    /* [in] */ BSTR StatusText);




#endif 	/* __IDAViewSite_INTERFACE_DEFINED__ */


#ifndef __IDAView_INTERFACE_DEFINED__
#define __IDAView_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAView
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("283807B4-2C60-11d0-A31D-00AA00B92C03")
    IDAView : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SimulationTime( 
            /* [retval][out] */ double *simTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Tick( 
            /* [in] */ double simTime,
            /* [retval][out] */ VARIANT_BOOL *needToRender) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddBvrToRun( 
            /* [in] */ IDABehavior *bvr,
            /* [retval][out] */ LONG *pId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRunningBvr( 
            /* [in] */ LONG id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartModel( 
            /* [in] */ IDAImage *pImage,
            /* [in] */ IDASound *pSound,
            /* [in] */ double startTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopModel( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Window( 
            /* [retval][out] */ HWND *hwnd) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Window( 
            /* [in] */ HWND hwnd) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IDirectDrawSurface( 
            /* [retval][out] */ IUnknown **ddsurf) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IDirectDrawSurface( 
            /* [in] */ IUnknown *ddsurf) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DC( 
            /* [retval][out] */ HDC *dc) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DC( 
            /* [in] */ HDC dc) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CompositeDirectlyToTarget( 
            /* [retval][out] */ VARIANT_BOOL *composeToTarget) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CompositeDirectlyToTarget( 
            /* [in] */ VARIANT_BOOL composeToTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetViewport( 
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ LONG w,
            /* [in] */ LONG h) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipRect( 
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ LONG w,
            /* [in] */ LONG h) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RePaint( 
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ LONG w,
            /* [in] */ LONG h) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PaletteChanged( 
            /* [in] */ VARIANT_BOOL bNew) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Site( 
            /* [retval][out] */ IDAViewSite **pViewSite) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Site( 
            /* [in] */ IDAViewSite *pViewSite) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClientSite( 
            /* [in] */ IOleClientSite *pClientSite) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientSite( 
            /* [retval][out] */ IOleClientSite **pClientSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMouseMove( 
            /* [in] */ double when,
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ BYTE modifiers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMouseButton( 
            /* [in] */ double when,
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ BYTE button,
            /* [in] */ VARIANT_BOOL bPressed,
            /* [in] */ BYTE modifiers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKey( 
            /* [in] */ double when,
            /* [in] */ LONG key,
            /* [in] */ VARIANT_BOOL bPressed,
            /* [in] */ BYTE modifiers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFocus( 
            /* [in] */ VARIANT_BOOL bHasFocus) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Preferences( 
            /* [retval][out] */ IDAPreferences **prefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryHitPoint( 
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT prcBounds,
            /* [in] */ POINT ptLoc,
            /* [in] */ LONG lCloseHint,
            /* [retval][out] */ DWORD *pHitResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAView * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAView * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAView * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAView * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SimulationTime )( 
            IDAView * This,
            /* [retval][out] */ double *simTime);
        
        HRESULT ( STDMETHODCALLTYPE *Tick )( 
            IDAView * This,
            /* [in] */ double simTime,
            /* [retval][out] */ VARIANT_BOOL *needToRender);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IDAView * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddBvrToRun )( 
            IDAView * This,
            /* [in] */ IDABehavior *bvr,
            /* [retval][out] */ LONG *pId);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRunningBvr )( 
            IDAView * This,
            /* [in] */ LONG id);
        
        HRESULT ( STDMETHODCALLTYPE *StartModel )( 
            IDAView * This,
            /* [in] */ IDAImage *pImage,
            /* [in] */ IDASound *pSound,
            /* [in] */ double startTime);
        
        HRESULT ( STDMETHODCALLTYPE *StopModel )( 
            IDAView * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Window )( 
            IDAView * This,
            /* [retval][out] */ HWND *hwnd);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Window )( 
            IDAView * This,
            /* [in] */ HWND hwnd);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IDirectDrawSurface )( 
            IDAView * This,
            /* [retval][out] */ IUnknown **ddsurf);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IDirectDrawSurface )( 
            IDAView * This,
            /* [in] */ IUnknown *ddsurf);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DC )( 
            IDAView * This,
            /* [retval][out] */ HDC *dc);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DC )( 
            IDAView * This,
            /* [in] */ HDC dc);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CompositeDirectlyToTarget )( 
            IDAView * This,
            /* [retval][out] */ VARIANT_BOOL *composeToTarget);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CompositeDirectlyToTarget )( 
            IDAView * This,
            /* [in] */ VARIANT_BOOL composeToTarget);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewport )( 
            IDAView * This,
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ LONG w,
            /* [in] */ LONG h);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipRect )( 
            IDAView * This,
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ LONG w,
            /* [in] */ LONG h);
        
        HRESULT ( STDMETHODCALLTYPE *RePaint )( 
            IDAView * This,
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ LONG w,
            /* [in] */ LONG h);
        
        HRESULT ( STDMETHODCALLTYPE *PaletteChanged )( 
            IDAView * This,
            /* [in] */ VARIANT_BOOL bNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Site )( 
            IDAView * This,
            /* [retval][out] */ IDAViewSite **pViewSite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Site )( 
            IDAView * This,
            /* [in] */ IDAViewSite *pViewSite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientSite )( 
            IDAView * This,
            /* [in] */ IOleClientSite *pClientSite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientSite )( 
            IDAView * This,
            /* [retval][out] */ IOleClientSite **pClientSite);
        
        HRESULT ( STDMETHODCALLTYPE *OnMouseMove )( 
            IDAView * This,
            /* [in] */ double when,
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ BYTE modifiers);
        
        HRESULT ( STDMETHODCALLTYPE *OnMouseButton )( 
            IDAView * This,
            /* [in] */ double when,
            /* [in] */ LONG xPos,
            /* [in] */ LONG yPos,
            /* [in] */ BYTE button,
            /* [in] */ VARIANT_BOOL bPressed,
            /* [in] */ BYTE modifiers);
        
        HRESULT ( STDMETHODCALLTYPE *OnKey )( 
            IDAView * This,
            /* [in] */ double when,
            /* [in] */ LONG key,
            /* [in] */ VARIANT_BOOL bPressed,
            /* [in] */ BYTE modifiers);
        
        HRESULT ( STDMETHODCALLTYPE *OnFocus )( 
            IDAView * This,
            /* [in] */ VARIANT_BOOL bHasFocus);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Preferences )( 
            IDAView * This,
            /* [retval][out] */ IDAPreferences **prefs);
        
        HRESULT ( STDMETHODCALLTYPE *QueryHitPoint )( 
            IDAView * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT prcBounds,
            /* [in] */ POINT ptLoc,
            /* [in] */ LONG lCloseHint,
            /* [retval][out] */ DWORD *pHitResult);
        
        END_INTERFACE
    } IDAViewVtbl;

    interface IDAView
    {
        CONST_VTBL struct IDAViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAView_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAView_get_SimulationTime(This,simTime)	\
    (This)->lpVtbl -> get_SimulationTime(This,simTime)

#define IDAView_Tick(This,simTime,needToRender)	\
    (This)->lpVtbl -> Tick(This,simTime,needToRender)

#define IDAView_Render(This)	\
    (This)->lpVtbl -> Render(This)

#define IDAView_AddBvrToRun(This,bvr,pId)	\
    (This)->lpVtbl -> AddBvrToRun(This,bvr,pId)

#define IDAView_RemoveRunningBvr(This,id)	\
    (This)->lpVtbl -> RemoveRunningBvr(This,id)

#define IDAView_StartModel(This,pImage,pSound,startTime)	\
    (This)->lpVtbl -> StartModel(This,pImage,pSound,startTime)

#define IDAView_StopModel(This)	\
    (This)->lpVtbl -> StopModel(This)

#define IDAView_get_Window(This,hwnd)	\
    (This)->lpVtbl -> get_Window(This,hwnd)

#define IDAView_put_Window(This,hwnd)	\
    (This)->lpVtbl -> put_Window(This,hwnd)

#define IDAView_get_IDirectDrawSurface(This,ddsurf)	\
    (This)->lpVtbl -> get_IDirectDrawSurface(This,ddsurf)

#define IDAView_put_IDirectDrawSurface(This,ddsurf)	\
    (This)->lpVtbl -> put_IDirectDrawSurface(This,ddsurf)

#define IDAView_get_DC(This,dc)	\
    (This)->lpVtbl -> get_DC(This,dc)

#define IDAView_put_DC(This,dc)	\
    (This)->lpVtbl -> put_DC(This,dc)

#define IDAView_get_CompositeDirectlyToTarget(This,composeToTarget)	\
    (This)->lpVtbl -> get_CompositeDirectlyToTarget(This,composeToTarget)

#define IDAView_put_CompositeDirectlyToTarget(This,composeToTarget)	\
    (This)->lpVtbl -> put_CompositeDirectlyToTarget(This,composeToTarget)

#define IDAView_SetViewport(This,xPos,yPos,w,h)	\
    (This)->lpVtbl -> SetViewport(This,xPos,yPos,w,h)

#define IDAView_SetClipRect(This,xPos,yPos,w,h)	\
    (This)->lpVtbl -> SetClipRect(This,xPos,yPos,w,h)

#define IDAView_RePaint(This,xPos,yPos,w,h)	\
    (This)->lpVtbl -> RePaint(This,xPos,yPos,w,h)

#define IDAView_PaletteChanged(This,bNew)	\
    (This)->lpVtbl -> PaletteChanged(This,bNew)

#define IDAView_get_Site(This,pViewSite)	\
    (This)->lpVtbl -> get_Site(This,pViewSite)

#define IDAView_put_Site(This,pViewSite)	\
    (This)->lpVtbl -> put_Site(This,pViewSite)

#define IDAView_put_ClientSite(This,pClientSite)	\
    (This)->lpVtbl -> put_ClientSite(This,pClientSite)

#define IDAView_get_ClientSite(This,pClientSite)	\
    (This)->lpVtbl -> get_ClientSite(This,pClientSite)

#define IDAView_OnMouseMove(This,when,xPos,yPos,modifiers)	\
    (This)->lpVtbl -> OnMouseMove(This,when,xPos,yPos,modifiers)

#define IDAView_OnMouseButton(This,when,xPos,yPos,button,bPressed,modifiers)	\
    (This)->lpVtbl -> OnMouseButton(This,when,xPos,yPos,button,bPressed,modifiers)

#define IDAView_OnKey(This,when,key,bPressed,modifiers)	\
    (This)->lpVtbl -> OnKey(This,when,key,bPressed,modifiers)

#define IDAView_OnFocus(This,bHasFocus)	\
    (This)->lpVtbl -> OnFocus(This,bHasFocus)

#define IDAView_get_Preferences(This,prefs)	\
    (This)->lpVtbl -> get_Preferences(This,prefs)

#define IDAView_QueryHitPoint(This,dwAspect,prcBounds,ptLoc,lCloseHint,pHitResult)	\
    (This)->lpVtbl -> QueryHitPoint(This,dwAspect,prcBounds,ptLoc,lCloseHint,pHitResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAView_get_SimulationTime_Proxy( 
    IDAView * This,
    /* [retval][out] */ double *simTime);



HRESULT STDMETHODCALLTYPE IDAView_Tick_Proxy( 
    IDAView * This,
    /* [in] */ double simTime,
    /* [retval][out] */ VARIANT_BOOL *needToRender);



HRESULT STDMETHODCALLTYPE IDAView_Render_Proxy( 
    IDAView * This);



HRESULT STDMETHODCALLTYPE IDAView_AddBvrToRun_Proxy( 
    IDAView * This,
    /* [in] */ IDABehavior *bvr,
    /* [retval][out] */ LONG *pId);



HRESULT STDMETHODCALLTYPE IDAView_RemoveRunningBvr_Proxy( 
    IDAView * This,
    /* [in] */ LONG id);



HRESULT STDMETHODCALLTYPE IDAView_StartModel_Proxy( 
    IDAView * This,
    /* [in] */ IDAImage *pImage,
    /* [in] */ IDASound *pSound,
    /* [in] */ double startTime);



HRESULT STDMETHODCALLTYPE IDAView_StopModel_Proxy( 
    IDAView * This);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAView_get_Window_Proxy( 
    IDAView * This,
    /* [retval][out] */ HWND *hwnd);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAView_put_Window_Proxy( 
    IDAView * This,
    /* [in] */ HWND hwnd);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAView_get_IDirectDrawSurface_Proxy( 
    IDAView * This,
    /* [retval][out] */ IUnknown **ddsurf);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAView_put_IDirectDrawSurface_Proxy( 
    IDAView * This,
    /* [in] */ IUnknown *ddsurf);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAView_get_DC_Proxy( 
    IDAView * This,
    /* [retval][out] */ HDC *dc);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAView_put_DC_Proxy( 
    IDAView * This,
    /* [in] */ HDC dc);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAView_get_CompositeDirectlyToTarget_Proxy( 
    IDAView * This,
    /* [retval][out] */ VARIANT_BOOL *composeToTarget);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAView_put_CompositeDirectlyToTarget_Proxy( 
    IDAView * This,
    /* [in] */ VARIANT_BOOL composeToTarget);



HRESULT STDMETHODCALLTYPE IDAView_SetViewport_Proxy( 
    IDAView * This,
    /* [in] */ LONG xPos,
    /* [in] */ LONG yPos,
    /* [in] */ LONG w,
    /* [in] */ LONG h);



HRESULT STDMETHODCALLTYPE IDAView_SetClipRect_Proxy( 
    IDAView * This,
    /* [in] */ LONG xPos,
    /* [in] */ LONG yPos,
    /* [in] */ LONG w,
    /* [in] */ LONG h);



HRESULT STDMETHODCALLTYPE IDAView_RePaint_Proxy( 
    IDAView * This,
    /* [in] */ LONG xPos,
    /* [in] */ LONG yPos,
    /* [in] */ LONG w,
    /* [in] */ LONG h);



HRESULT STDMETHODCALLTYPE IDAView_PaletteChanged_Proxy( 
    IDAView * This,
    /* [in] */ VARIANT_BOOL bNew);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAView_get_Site_Proxy( 
    IDAView * This,
    /* [retval][out] */ IDAViewSite **pViewSite);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAView_put_Site_Proxy( 
    IDAView * This,
    /* [in] */ IDAViewSite *pViewSite);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAView_put_ClientSite_Proxy( 
    IDAView * This,
    /* [in] */ IOleClientSite *pClientSite);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAView_get_ClientSite_Proxy( 
    IDAView * This,
    /* [retval][out] */ IOleClientSite **pClientSite);



HRESULT STDMETHODCALLTYPE IDAView_OnMouseMove_Proxy( 
    IDAView * This,
    /* [in] */ double when,
    /* [in] */ LONG xPos,
    /* [in] */ LONG yPos,
    /* [in] */ BYTE modifiers);



HRESULT STDMETHODCALLTYPE IDAView_OnMouseButton_Proxy( 
    IDAView * This,
    /* [in] */ double when,
    /* [in] */ LONG xPos,
    /* [in] */ LONG yPos,
    /* [in] */ BYTE button,
    /* [in] */ VARIANT_BOOL bPressed,
    /* [in] */ BYTE modifiers);



HRESULT STDMETHODCALLTYPE IDAView_OnKey_Proxy( 
    IDAView * This,
    /* [in] */ double when,
    /* [in] */ LONG key,
    /* [in] */ VARIANT_BOOL bPressed,
    /* [in] */ BYTE modifiers);



HRESULT STDMETHODCALLTYPE IDAView_OnFocus_Proxy( 
    IDAView * This,
    /* [in] */ VARIANT_BOOL bHasFocus);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAView_get_Preferences_Proxy( 
    IDAView * This,
    /* [retval][out] */ IDAPreferences **prefs);



HRESULT STDMETHODCALLTYPE IDAView_QueryHitPoint_Proxy( 
    IDAView * This,
    /* [in] */ DWORD dwAspect,
    /* [in] */ LPCRECT prcBounds,
    /* [in] */ POINT ptLoc,
    /* [in] */ LONG lCloseHint,
    /* [retval][out] */ DWORD *pHitResult);




#endif 	/* __IDAView_INTERFACE_DEFINED__ */


#ifndef __IDABehavior_INTERFACE_DEFINED__
#define __IDABehavior_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDABehavior
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDABehavior;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("283807B7-2C60-11d0-A31D-00AA00B92C03")
    IDABehavior : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassName( 
            /* [retval][out] */ BSTR *pClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IDABehavior *toBvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Importance( 
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RunOnce( 
            /* [retval][out] */ IDABehavior **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubstituteTime( 
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchTo( 
            /* [in] */ IDABehavior *switchTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToNumber( 
            /* [in] */ double numToSwitchTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToString( 
            /* [in] */ BSTR strToSwitchTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Hook( 
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Duration( 
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DurationAnim( 
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Repeat( 
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RepeatForever( 
            /* [retval][out] */ IDABehavior **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsReady( 
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDABehaviorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDABehavior * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDABehavior * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDABehavior * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDABehavior * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDABehavior * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDABehavior * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDABehavior * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDABehavior * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDABehavior * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDABehavior * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDABehavior * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDABehavior * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDABehavior * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDABehavior * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDABehavior * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDABehavior * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDABehavior * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDABehavior * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDABehavior * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDABehavior * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDABehavior * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        END_INTERFACE
    } IDABehaviorVtbl;

    interface IDABehavior
    {
        CONST_VTBL struct IDABehaviorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDABehavior_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDABehavior_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDABehavior_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDABehavior_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDABehavior_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDABehavior_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDABehavior_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDABehavior_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDABehavior_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDABehavior_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDABehavior_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDABehavior_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDABehavior_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDABehavior_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDABehavior_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDABehavior_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDABehavior_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDABehavior_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDABehavior_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDABehavior_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDABehavior_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDABehavior_GetClassName_Proxy( 
    IDABehavior * This,
    /* [retval][out] */ BSTR *pClassName);



HRESULT STDMETHODCALLTYPE IDABehavior_Init_Proxy( 
    IDABehavior * This,
    /* [in] */ IDABehavior *toBvr);



HRESULT STDMETHODCALLTYPE IDABehavior_Importance_Proxy( 
    IDABehavior * This,
    /* [in] */ double relativeImportance,
    /* [retval][out] */ IDABehavior **ppBvr);



HRESULT STDMETHODCALLTYPE IDABehavior_RunOnce_Proxy( 
    IDABehavior * This,
    /* [retval][out] */ IDABehavior **bvr);



HRESULT STDMETHODCALLTYPE IDABehavior_SubstituteTime_Proxy( 
    IDABehavior * This,
    /* [in] */ IDANumber *xform,
    /* [retval][out] */ IDABehavior **bvr);



HRESULT STDMETHODCALLTYPE IDABehavior_SwitchTo_Proxy( 
    IDABehavior * This,
    /* [in] */ IDABehavior *switchTo);



HRESULT STDMETHODCALLTYPE IDABehavior_SwitchToNumber_Proxy( 
    IDABehavior * This,
    /* [in] */ double numToSwitchTo);



HRESULT STDMETHODCALLTYPE IDABehavior_SwitchToString_Proxy( 
    IDABehavior * This,
    /* [in] */ BSTR strToSwitchTo);



HRESULT STDMETHODCALLTYPE IDABehavior_Hook_Proxy( 
    IDABehavior * This,
    /* [in] */ IDABvrHook *notifier,
    /* [retval][out] */ IDABehavior **pBvr);



HRESULT STDMETHODCALLTYPE IDABehavior_Duration_Proxy( 
    IDABehavior * This,
    /* [in] */ double duration,
    /* [retval][out] */ IDABehavior **bvr);



HRESULT STDMETHODCALLTYPE IDABehavior_DurationAnim_Proxy( 
    IDABehavior * This,
    /* [in] */ IDANumber *duration,
    /* [retval][out] */ IDABehavior **bvr);



HRESULT STDMETHODCALLTYPE IDABehavior_Repeat_Proxy( 
    IDABehavior * This,
    /* [in] */ LONG count,
    /* [retval][out] */ IDABehavior **bvr);



HRESULT STDMETHODCALLTYPE IDABehavior_RepeatForever_Proxy( 
    IDABehavior * This,
    /* [retval][out] */ IDABehavior **bvr);



HRESULT STDMETHODCALLTYPE IDABehavior_IsReady_Proxy( 
    IDABehavior * This,
    /* [in] */ VARIANT_BOOL bBlock,
    /* [retval][out] */ VARIANT_BOOL *b);




#endif 	/* __IDABehavior_INTERFACE_DEFINED__ */


#ifndef __IDANumber_INTERFACE_DEFINED__
#define __IDANumber_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDANumber
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDANumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9CDE7340-3C20-11d0-A330-00AA00B92C03")
    IDANumber : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Extract( 
            /* [retval][out] */ double *ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AnimateProperty( 
            /* [in] */ BSTR propertyPath_0,
            /* [in] */ BSTR scriptingLanguage_1,
            /* [in] */ VARIANT_BOOL invokeAsMethod_2,
            /* [in] */ double minUpdateInterval_3,
            /* [retval][out] */ IDANumber **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToStringAnim( 
            /* [in] */ IDANumber *precision_0,
            /* [retval][out] */ IDAString **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToString( 
            /* [in] */ double precision_0,
            /* [retval][out] */ IDAString **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDANumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDANumber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDANumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDANumber * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDANumber * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDANumber * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDANumber * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDANumber * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDANumber * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDANumber * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDANumber * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDANumber * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDANumber * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDANumber * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDANumber * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDANumber * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDANumber * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDANumber * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDANumber * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDANumber * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDANumber * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDANumber * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Extract )( 
            IDANumber * This,
            /* [retval][out] */ double *ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *AnimateProperty )( 
            IDANumber * This,
            /* [in] */ BSTR propertyPath_0,
            /* [in] */ BSTR scriptingLanguage_1,
            /* [in] */ VARIANT_BOOL invokeAsMethod_2,
            /* [in] */ double minUpdateInterval_3,
            /* [retval][out] */ IDANumber **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *ToStringAnim )( 
            IDANumber * This,
            /* [in] */ IDANumber *precision_0,
            /* [retval][out] */ IDAString **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *ToString )( 
            IDANumber * This,
            /* [in] */ double precision_0,
            /* [retval][out] */ IDAString **ret_1);
        
        END_INTERFACE
    } IDANumberVtbl;

    interface IDANumber
    {
        CONST_VTBL struct IDANumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDANumber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDANumber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDANumber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDANumber_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDANumber_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDANumber_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDANumber_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDANumber_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDANumber_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDANumber_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDANumber_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDANumber_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDANumber_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDANumber_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDANumber_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDANumber_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDANumber_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDANumber_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDANumber_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDANumber_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDANumber_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDANumber_Extract(This,ret_0)	\
    (This)->lpVtbl -> Extract(This,ret_0)

#define IDANumber_AnimateProperty(This,propertyPath_0,scriptingLanguage_1,invokeAsMethod_2,minUpdateInterval_3,ret_4)	\
    (This)->lpVtbl -> AnimateProperty(This,propertyPath_0,scriptingLanguage_1,invokeAsMethod_2,minUpdateInterval_3,ret_4)

#define IDANumber_ToStringAnim(This,precision_0,ret_1)	\
    (This)->lpVtbl -> ToStringAnim(This,precision_0,ret_1)

#define IDANumber_ToString(This,precision_0,ret_1)	\
    (This)->lpVtbl -> ToString(This,precision_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDANumber_Extract_Proxy( 
    IDANumber * This,
    /* [retval][out] */ double *ret_0);



HRESULT STDMETHODCALLTYPE IDANumber_AnimateProperty_Proxy( 
    IDANumber * This,
    /* [in] */ BSTR propertyPath_0,
    /* [in] */ BSTR scriptingLanguage_1,
    /* [in] */ VARIANT_BOOL invokeAsMethod_2,
    /* [in] */ double minUpdateInterval_3,
    /* [retval][out] */ IDANumber **ret_4);



HRESULT STDMETHODCALLTYPE IDANumber_ToStringAnim_Proxy( 
    IDANumber * This,
    /* [in] */ IDANumber *precision_0,
    /* [retval][out] */ IDAString **ret_1);



HRESULT STDMETHODCALLTYPE IDANumber_ToString_Proxy( 
    IDANumber * This,
    /* [in] */ double precision_0,
    /* [retval][out] */ IDAString **ret_1);




#endif 	/* __IDANumber_INTERFACE_DEFINED__ */


#ifndef __IDABvrHook_INTERFACE_DEFINED__
#define __IDABvrHook_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDABvrHook
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDABvrHook;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3E2487C4-8709-11d0-B177-00C04FC2A0CA")
    IDABvrHook : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LONG id,
            /* [in] */ VARIANT_BOOL startingPerformance,
            /* [in] */ double startTime,
            /* [in] */ double gTime,
            /* [in] */ double lTime,
            /* [in] */ IDABehavior *sampleVal,
            /* [in] */ IDABehavior *curRunningBvr,
            /* [retval][out] */ IDABehavior **ppBvr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDABvrHookVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDABvrHook * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDABvrHook * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDABvrHook * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IDABvrHook * This,
            /* [in] */ LONG id,
            /* [in] */ VARIANT_BOOL startingPerformance,
            /* [in] */ double startTime,
            /* [in] */ double gTime,
            /* [in] */ double lTime,
            /* [in] */ IDABehavior *sampleVal,
            /* [in] */ IDABehavior *curRunningBvr,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        END_INTERFACE
    } IDABvrHookVtbl;

    interface IDABvrHook
    {
        CONST_VTBL struct IDABvrHookVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDABvrHook_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDABvrHook_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDABvrHook_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDABvrHook_Notify(This,id,startingPerformance,startTime,gTime,lTime,sampleVal,curRunningBvr,ppBvr)	\
    (This)->lpVtbl -> Notify(This,id,startingPerformance,startTime,gTime,lTime,sampleVal,curRunningBvr,ppBvr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDABvrHook_Notify_Proxy( 
    IDABvrHook * This,
    /* [in] */ LONG id,
    /* [in] */ VARIANT_BOOL startingPerformance,
    /* [in] */ double startTime,
    /* [in] */ double gTime,
    /* [in] */ double lTime,
    /* [in] */ IDABehavior *sampleVal,
    /* [in] */ IDABehavior *curRunningBvr,
    /* [retval][out] */ IDABehavior **ppBvr);




#endif 	/* __IDABvrHook_INTERFACE_DEFINED__ */


#ifndef __IDADrawingSurface_INTERFACE_DEFINED__
#define __IDADrawingSurface_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDADrawingSurface
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDADrawingSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BC0BFD34-D21D-11d0-9385-00C04FB6BD36")
    IDADrawingSurface : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ IDAImage **img) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LineStyle( 
            /* [in] */ IDALineStyle *ls) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ IDALineStyle *bs) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FontStyle( 
            /* [in] */ IDAFontStyle *fs) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClipMatte( 
            /* [in] */ IDAMatte *matte) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MouseEventsEnabled( 
            /* [in] */ VARIANT_BOOL on) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HatchFillTransparent( 
            /* [in] */ VARIANT_BOOL fillOff) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LocalContextImage( 
            /* [retval][out] */ IDAImage **img) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveGraphicsState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreGraphicsState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Opacity( 
            /* [in] */ double opac) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpacityAnim( 
            /* [in] */ IDANumber *opac) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Crop( 
            /* [in] */ double lowerLeftX,
            /* [in] */ double lowerLeftY,
            /* [in] */ double upperRightX,
            /* [in] */ double upperRightY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CropPoints( 
            /* [in] */ IDAPoint2 *min,
            /* [in] */ IDAPoint2 *max) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform2 *xform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LineColor( 
            /* [in] */ IDAColor *clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LineWidth( 
            /* [in] */ double w) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LineDashStyle( 
            /* [in] */ DA_DASH_STYLE id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LineEndStyle( 
            /* [in] */ DA_END_STYLE id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LineJoinStyle( 
            /* [in] */ DA_JOIN_STYLE id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BorderColor( 
            /* [in] */ IDAColor *clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BorderWidth( 
            /* [in] */ double w) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BorderDashStyle( 
            /* [in] */ DA_DASH_STYLE id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BorderEndStyle( 
            /* [in] */ DA_END_STYLE obsolete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BorderJoinStyle( 
            /* [in] */ DA_JOIN_STYLE id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Font( 
            /* [in] */ BSTR FontFace,
            /* [in] */ LONG sizeInPoints,
            /* [in] */ VARIANT_BOOL Bold,
            /* [in] */ VARIANT_BOOL italic,
            /* [in] */ VARIANT_BOOL underline,
            /* [in] */ VARIANT_BOOL strikethrough) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextureFill( 
            /* [in] */ IDAImage *obsolete1,
            /* [in] */ double obsolete2,
            /* [in] */ double obsolete3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImageFill( 
            /* [in] */ IDAImage *obsolete1,
            /* [in] */ double obsolete2,
            /* [in] */ double obsolete3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillTexture( 
            /* [in] */ IDAImage *img) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillImage( 
            /* [in] */ IDAImage *img) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillStyle( 
            /* [in] */ int ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillColor( 
            /* [in] */ IDAColor *foreground) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SecondaryFillColor( 
            /* [in] */ IDAColor *val) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientShape( 
            /* [in] */ VARIANT pts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientExtent( 
            /* [in] */ double startx,
            /* [in] */ double starty,
            /* [in] */ double finishx,
            /* [in] */ double finishy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientExtentPoints( 
            /* [in] */ IDAPoint2 *startColor,
            /* [in] */ IDAPoint2 *stopColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientRolloffPower( 
            /* [in] */ double power) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientRolloffPowerAnim( 
            /* [in] */ IDANumber *power) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FixedFillScale( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HorizontalFillScale( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VerticalFillScale( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AutoSizeFillScale( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PolylineEx( 
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAPoint2 *pts[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Polyline( 
            /* [in] */ VARIANT v) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PolygonEx( 
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAPoint2 *pts[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Polygon( 
            /* [in] */ VARIANT v) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LinePoints( 
            /* [in] */ IDAPoint2 *p1,
            /* [in] */ IDAPoint2 *p2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Line( 
            /* [in] */ double startX,
            /* [in] */ double startY,
            /* [in] */ double endX,
            /* [in] */ double endY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ArcRadians( 
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double startAngle,
            /* [in] */ double endAngle,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ArcDegrees( 
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double startAngle,
            /* [in] */ double endAngle,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Oval( 
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] *